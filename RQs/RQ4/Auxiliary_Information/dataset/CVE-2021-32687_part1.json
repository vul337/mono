{
  "cve_id": "CVE-2021-32687",
  "cwe_ids": [
    "CWE-190",
    "CWE-680"
  ],
  "cvss_vector": "AV:N/AC:M/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix Integer overflow issue with intsets (CVE-2021-32687)\n\nThe vulnerability involves changing the default set-max-intset-entries\nconfiguration parameter to a very large value and constructing specially\ncrafted commands to manipulate sets",
  "commit_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
  "git_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
  "file_path": "src/rdb.c",
  "func_name": "rdbLoadObject",
  "func_before": "robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {\n    robj *o = NULL, *ele, *dec;\n    uint64_t len;\n    unsigned int i;\n\n    if (rdbtype == RDB_TYPE_STRING) {\n        /* Read string value */\n        if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == RDB_TYPE_LIST) {\n        /* Read list value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        /* Load every single element of the list */\n        while(len--) {\n            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            dec = getDecodedObject(ele);\n            size_t len = sdslen(dec->ptr);\n            quicklistPushTail(o->ptr, dec->ptr, len);\n            decrRefCount(dec);\n            decrRefCount(ele);\n        }\n    } else if (rdbtype == RDB_TYPE_SET) {\n        /* Read Set value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        /* Use a regular set when there are too many entries. */\n        if (len > server.set_max_intset_entries) {\n            o = createSetObject();\n            /* It's faster to expand the dict to the right size asap in order\n             * to avoid rehashing */\n            if (len > DICT_HT_INITIAL_SIZE)\n                dictExpand(o->ptr,len);\n        } else {\n            o = createIntsetObject();\n        }\n\n        /* Load every single element of the set */\n        for (i = 0; i < len; i++) {\n            long long llval;\n            sds sdsele;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (o->encoding == OBJ_ENCODING_INTSET) {\n                /* Fetch integer value from element. */\n                if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {\n                    o->ptr = intsetAdd(o->ptr,llval,NULL);\n                } else {\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                    dictExpand(o->ptr,len);\n                }\n            }\n\n            /* This will also be called when the set was just converted\n             * to a regular hash table encoded set. */\n            if (o->encoding == OBJ_ENCODING_HT) {\n                dictAdd((dict*)o->ptr,sdsele,NULL);\n            } else {\n                sdsfree(sdsele);\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {\n        /* Read list/set value. */\n        uint64_t zsetlen;\n        size_t maxelelen = 0;\n        zset *zs;\n\n        if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createZsetObject();\n        zs = o->ptr;\n\n        if (zsetlen > DICT_HT_INITIAL_SIZE)\n            dictExpand(zs->dict,zsetlen);\n\n        /* Load every single element of the sorted set. */\n        while(zsetlen--) {\n            sds sdsele;\n            double score;\n            zskiplistNode *znode;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (rdbtype == RDB_TYPE_ZSET_2) {\n                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            }\n\n            /* Don't care about integer-encoded strings. */\n            if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);\n\n            znode = zslInsert(zs->zsl,score,sdsele);\n            dictAdd(zs->dict,sdsele,&znode->score);\n        }\n\n        /* Convert *after* loading, since sorted sets are not stored ordered. */\n        if (zsetLength(o) <= server.zset_max_ziplist_entries &&\n            maxelelen <= server.zset_max_ziplist_value)\n                zsetConvert(o,OBJ_ENCODING_ZIPLIST);\n    } else if (rdbtype == RDB_TYPE_HASH) {\n        uint64_t len;\n        int ret;\n        sds field, value;\n\n        len = rdbLoadLen(rdb, NULL);\n        if (len == RDB_LENERR) return NULL;\n\n        o = createHashObject();\n\n        /* Too many entries? Use a hash table. */\n        if (len > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n\n        /* Load every field and value into the ziplist */\n        while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {\n            len--;\n            /* Load raw strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to ziplist */\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)field,\n                    sdslen(field), ZIPLIST_TAIL);\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)value,\n                    sdslen(value), ZIPLIST_TAIL);\n\n            /* Convert to hash table if size threshold is exceeded */\n            if (sdslen(field) > server.hash_max_ziplist_value ||\n                sdslen(value) > server.hash_max_ziplist_value)\n            {\n                sdsfree(field);\n                sdsfree(value);\n                hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            }\n            sdsfree(field);\n            sdsfree(value);\n        }\n\n        if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)\n            dictExpand(o->ptr,len);\n\n        /* Load remaining fields and values into the hash table */\n        while (o->encoding == OBJ_ENCODING_HT && len > 0) {\n            len--;\n            /* Load encoded strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to hash table */\n            ret = dictAdd((dict*)o->ptr, field, value);\n            if (ret == DICT_ERR) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* All pairs should be read by now */\n        serverAssert(len == 0);\n    } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        while (len--) {\n            unsigned char *zl =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (zl == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            quicklistAppendZiplist(o->ptr, zl);\n        }\n    } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||\n               rdbtype == RDB_TYPE_LIST_ZIPLIST ||\n               rdbtype == RDB_TYPE_SET_INTSET   ||\n               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||\n               rdbtype == RDB_TYPE_HASH_ZIPLIST)\n    {\n        unsigned char *encoded =\n            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n        if (encoded == NULL) return NULL;\n        o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */\n\n        /* Fix the object encoding, and make sure to convert the encoded\n         * data type into the base type if accordingly to the current\n         * configuration there are too many elements in the encoded data\n         * type. Note that we only check the length and not max element\n         * size as this is an O(N) scan. Eventually everything will get\n         * converted. */\n        switch(rdbtype) {\n            case RDB_TYPE_HASH_ZIPMAP:\n                /* Convert to ziplist encoded hash. This must be deprecated\n                 * when loading dumps created by Redis 2.4 gets deprecated. */\n                {\n                    unsigned char *zl = ziplistNew();\n                    unsigned char *zi = zipmapRewind(o->ptr);\n                    unsigned char *fstr, *vstr;\n                    unsigned int flen, vlen;\n                    unsigned int maxlen = 0;\n\n                    while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {\n                        if (flen > maxlen) maxlen = flen;\n                        if (vlen > maxlen) maxlen = vlen;\n                        zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);\n                        zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);\n                    }\n\n                    zfree(o->ptr);\n                    o->ptr = zl;\n                    o->type = OBJ_HASH;\n                    o->encoding = OBJ_ENCODING_ZIPLIST;\n\n                    if (hashTypeLength(o) > server.hash_max_ziplist_entries ||\n                        maxlen > server.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(o, OBJ_ENCODING_HT);\n                    }\n                }\n                break;\n            case RDB_TYPE_LIST_ZIPLIST:\n                o->type = OBJ_LIST;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);\n                break;\n            case RDB_TYPE_SET_INTSET:\n                o->type = OBJ_SET;\n                o->encoding = OBJ_ENCODING_INTSET;\n                if (intsetLen(o->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                break;\n            case RDB_TYPE_ZSET_ZIPLIST:\n                o->type = OBJ_ZSET;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (zsetLength(o) > server.zset_max_ziplist_entries)\n                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);\n                break;\n            case RDB_TYPE_HASH_ZIPLIST:\n                o->type = OBJ_HASH;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n                    hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            default:\n                /* totally unreachable */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",rdbtype);\n                break;\n        }\n    } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        uint64_t listpacks = rdbLoadLen(rdb,NULL);\n        if (listpacks == RDB_LENERR) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        while(listpacks--) {\n            /* Get the master ID, the one we'll use as key of the radix tree\n             * node: the entries inside the listpack itself are delta-encoded\n             * relatively to this ID. */\n            sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (nodekey == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            if (sdslen(nodekey) != sizeof(streamID)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* Load the listpack. */\n            unsigned char *lp =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (lp == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(nodekey);\n                decrRefCount(o);\n                return NULL;\n            }\n            unsigned char *first = lpFirst(lp);\n            if (first == NULL) {\n                /* Serialized listpacks should never be empty, since on\n                 * deletion we should remove the radix tree key if the\n                 * resulting listpack is empty. */\n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* Insert the key in the radix tree. */\n            int retval = raxInsert(s->rax,\n                (unsigned char*)nodekey,sizeof(streamID),lp,NULL);\n            sdsfree(nodekey);\n            if (!retval)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* Load total number of items inside the stream. */\n        s->length = rdbLoadLen(rdb,NULL);\n\n        /* Load the last entry ID. */\n        s->last_id.ms = rdbLoadLen(rdb,NULL);\n        s->last_id.seq = rdbLoadLen(rdb,NULL);\n\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        /* Consumer groups loading */\n        uint64_t cgroups_count = rdbLoadLen(rdb,NULL);\n        if (cgroups_count == RDB_LENERR) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n        while(cgroups_count--) {\n            /* Get the consumer group name and ID. We can then create the\n             * consumer group ASAP and populate its structure as\n             * we read more data. */\n            streamID cg_id;\n            sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (cgname == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(o);\n                return NULL;\n            }\n\n            cg_id.ms = rdbLoadLen(rdb,NULL);\n            cg_id.seq = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(cgname);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);\n            if (cgroup == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         cgname);\n            sdsfree(cgname);\n\n            /* Load the global PEL for this consumer group, however we'll\n             * not yet populate the NACK structures with the message\n             * owner, since consumers for this group and their messages will\n             * be read as a next step. So for now leave them not resolved\n             * and later populate it. */\n            uint64_t pel_size = rdbLoadLen(rdb,NULL);\n            if (pel_size == RDB_LENERR) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(pel_size--) {\n                unsigned char rawid[sizeof(streamID)];\n                if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamNACK *nack = streamCreateNACK(NULL);\n                nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                nack->delivery_count = rdbLoadLen(rdb,NULL);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(o);\n                    streamFreeNACK(nack);\n                    return NULL;\n                }\n                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* Now that we loaded our global PEL, we need to load the\n             * consumers and their local PELs. */\n            uint64_t consumers_num = rdbLoadLen(rdb,NULL);\n            if (consumers_num == RDB_LENERR) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(consumers_num--) {\n                sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n                if (cname == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamConsumer *consumer =\n                    streamLookupConsumer(cgroup,cname,SLC_NONE);\n                sdsfree(cname);\n                consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n\n                /* Load the PEL about entries owned by this specific\n                 * consumer. */\n                pel_size = rdbLoadLen(rdb,NULL);\n                if (pel_size == RDB_LENERR) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                while(pel_size--) {\n                    unsigned char rawid[sizeof(streamID)];\n                    if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(o);\n                        return NULL;\n                    }\n                    streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));\n                    if (nack == raxNotFound)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* Set the NACK consumer, that was left to NULL when\n                     * loading the global PEL. Then set the same shared\n                     * NACK structure also in the consumer-specific PEL. */\n                    nack->consumer = consumer;\n                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {\n        uint64_t moduleid = rdbLoadLen(rdb,NULL);\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n        char name[10];\n\n        if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {\n            moduleTypeNameByID(name,moduleid);\n            return rdbLoadCheckModuleValue(rdb,name);\n        }\n\n        if (mt == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data I can't load: no matching module '%s'\", name);\n            exit(1);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        initStaticStringObject(keyobj,key);\n        moduleInitIOContext(io,mt,rdb,&keyobj);\n        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;\n        /* Call the rdb_load method of the module providing the 10 bit\n         * encoding version in the lower 10 bits of the module ID. */\n        void *ptr = mt->rdb_load(&io,moduleid&1023);\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n\n        /* Module v2 serialization has an EOF mark at the end. */\n        if (io.ver == 2) {\n            uint64_t eof = rdbLoadLen(rdb,NULL);\n            if (eof == RDB_LENERR) {\n                o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */\n                decrRefCount(o);\n                return NULL;\n            }\n            if (eof != RDB_MODULE_OPCODE_EOF) {\n                serverLog(LL_WARNING,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                exit(1);\n            }\n        }\n\n        if (ptr == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n            exit(1);\n        }\n        o = createModuleObject(mt,ptr);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",rdbtype);\n        return NULL;\n    }\n    return o;\n}",
  "abstract_func_before": "robj *rdbLoadObject(int VAR_0, rio *VAR_1, sds VAR_2) {\n    robj *VAR_3 = NULL, *VAR_4, *VAR_5;\n    uint64_t VAR_6;\n    unsigned int VAR_7;\n\n    if (VAR_0 == VAR_8) {\n        /* COMMENT_0 */\n        if ((VAR_3 = rdbLoadEncodedStringObject(VAR_1)) == NULL) return NULL;\n        VAR_3 = tryObjectEncoding(VAR_3);\n    } else if (VAR_0 == VAR_9) {\n        /* COMMENT_1 */\n        if ((VAR_6 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n\n        VAR_3 = createQuicklistObject();\n        quicklistSetOptions(VAR_3->ptr, VAR_11.list_max_ziplist_size,\n                            VAR_11.list_compress_depth);\n\n        /* COMMENT_2 */\n        while(VAR_6--) {\n            if ((VAR_4 = rdbLoadEncodedStringObject(VAR_1)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            VAR_5 = getDecodedObject(VAR_4);\n            size_t VAR_6 = sdslen(VAR_5->ptr);\n            quicklistPushTail(VAR_3->ptr, VAR_5->ptr, VAR_6);\n            decrRefCount(VAR_5);\n            decrRefCount(VAR_4);\n        }\n    } else if (VAR_0 == VAR_12) {\n        /* COMMENT_3 */\n        if ((VAR_6 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n\n        /* COMMENT_4 */\n        if (VAR_6 > VAR_11.set_max_intset_entries) {\n            VAR_3 = createSetObject();\n            /* COMMENT_5 */\n                                    \n            if (VAR_6 > VAR_13)\n                dictExpand(VAR_3->ptr,VAR_6);\n        } else {\n            VAR_3 = createIntsetObject();\n        }\n\n        /* COMMENT_7 */\n        for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++) {\n            long long VAR_14;\n            sds VAR_15;\n\n            if ((VAR_15 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            if (VAR_3->encoding == VAR_17) {\n                /* COMMENT_8 */\n                if (isSdsRepresentableAsLongLong(VAR_15,&VAR_14) == VAR_18) {\n                    VAR_3->ptr = intsetAdd(VAR_3->ptr,VAR_14,NULL);\n                } else {\n                    setTypeConvert(VAR_3,VAR_19);\n                    dictExpand(VAR_3->ptr,VAR_6);\n                }\n            }\n\n            /* COMMENT_9 */\n                                                      \n            if (VAR_3->encoding == VAR_19) {\n                dictAdd((dict*)VAR_3->ptr,VAR_15,NULL);\n            } else {\n                sdsfree(VAR_15);\n            }\n        }\n    } else if (VAR_0 == VAR_20 || VAR_0 == VAR_21) {\n        /* COMMENT_11 */\n        uint64_t VAR_22;\n        size_t VAR_23 = 0;\n        zset *VAR_24;\n\n        if ((VAR_22 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n        VAR_3 = createZsetObject();\n        VAR_24 = VAR_3->ptr;\n\n        if (VAR_22 > VAR_13)\n            dictExpand(VAR_24->dict,VAR_22);\n\n        /* COMMENT_12 */\n        while(VAR_22--) {\n            sds VAR_15;\n            double VAR_25;\n            zskiplistNode *VAR_26;\n\n            if ((VAR_15 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            if (VAR_0 == VAR_20) {\n                if (rdbLoadBinaryDoubleValue(VAR_1,&VAR_25) == -1) {\n                    decrRefCount(VAR_3);\n                    sdsfree(VAR_15);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(VAR_1,&VAR_25) == -1) {\n                    decrRefCount(VAR_3);\n                    sdsfree(VAR_15);\n                    return NULL;\n                }\n            }\n\n            /* COMMENT_13 */\n            if (sdslen(VAR_15) > VAR_23) VAR_23 = sdslen(VAR_15);\n\n            VAR_26 = zslInsert(VAR_24->zsl,VAR_25,VAR_15);\n            dictAdd(VAR_24->dict,VAR_15,&VAR_26->score);\n        }\n\n        /* COMMENT_14 */\n        if (zsetLength(VAR_3) <= VAR_11.zset_max_ziplist_entries &&\n            VAR_23 <= VAR_11.zset_max_ziplist_value)\n                zsetConvert(VAR_3,VAR_27);\n    } else if (VAR_0 == VAR_28) {\n        uint64_t VAR_6;\n        int VAR_29;\n        sds VAR_30, VAR_31;\n\n        VAR_6 = rdbLoadLen(VAR_1, NULL);\n        if (VAR_6 == VAR_10) return NULL;\n\n        VAR_3 = createHashObject();\n\n        /* COMMENT_15 */\n        if (VAR_6 > VAR_11.hash_max_ziplist_entries)\n            hashTypeConvert(VAR_3, VAR_19);\n\n        /* COMMENT_16 */\n        while (VAR_3->encoding == VAR_27 && VAR_6 > 0) {\n            VAR_6--;\n            /* COMMENT_17 */\n            if ((VAR_30 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if ((VAR_31 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL)) == NULL) {\n                sdsfree(VAR_30);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            /* COMMENT_18 */\n            VAR_3->ptr = ziplistPush(VAR_3->ptr, (unsigned char*)VAR_30,\n                    sdslen(VAR_30), VAR_32);\n            VAR_3->ptr = ziplistPush(VAR_3->ptr, (unsigned char*)VAR_31,\n                    sdslen(VAR_31), VAR_32);\n\n            /* COMMENT_19 */\n            if (sdslen(VAR_30) > VAR_11.hash_max_ziplist_value ||\n                sdslen(VAR_31) > VAR_11.hash_max_ziplist_value)\n            {\n                sdsfree(VAR_30);\n                sdsfree(VAR_31);\n                hashTypeConvert(VAR_3, VAR_19);\n                break;\n            }\n            sdsfree(VAR_30);\n            sdsfree(VAR_31);\n        }\n\n        if (VAR_3->encoding == VAR_19 && VAR_6 > VAR_13)\n            dictExpand(VAR_3->ptr,VAR_6);\n\n        /* COMMENT_20 */\n        while (VAR_3->encoding == VAR_19 && VAR_6 > 0) {\n            VAR_6--;\n            /* COMMENT_21 */\n            if ((VAR_30 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if ((VAR_31 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL)) == NULL) {\n                sdsfree(VAR_30);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            /* COMMENT_22 */\n            VAR_29 = dictAdd((dict*)VAR_3->ptr, VAR_30, VAR_31);\n            if (VAR_29 == VAR_33) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* COMMENT_23 */\n        serverAssert(VAR_6 == 0);\n    } else if (VAR_0 == VAR_34) {\n        if ((VAR_6 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n        VAR_3 = createQuicklistObject();\n        quicklistSetOptions(VAR_3->ptr, VAR_11.list_max_ziplist_size,\n                            VAR_11.list_compress_depth);\n\n        while (VAR_6--) {\n            unsigned char *VAR_35 =\n                rdbGenericLoadStringObject(VAR_1,VAR_36,NULL);\n            if (VAR_35 == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            quicklistAppendZiplist(VAR_3->ptr, VAR_35);\n        }\n    } else if (VAR_0 == VAR_37  ||\n               VAR_0 == VAR_38 ||\n               VAR_0 == VAR_39   ||\n               VAR_0 == VAR_40 ||\n               VAR_0 == VAR_41)\n    {\n        unsigned char *VAR_42 =\n            rdbGenericLoadStringObject(VAR_1,VAR_36,NULL);\n        if (VAR_42 == NULL) return NULL;\n        VAR_3 = createObject(VAR_43,VAR_42); /* COMMENT_24 */\n\n        /* COMMENT_25 */\n                                                                     \n                                                                        \n                                                                       \n                                                                       \n                        \n        switch(VAR_0) {\n            case VAR_37:\n                /* COMMENT_31 */\n                                                                              \n                {\n                    unsigned char *VAR_35 = ziplistNew();\n                    unsigned char *VAR_44 = zipmapRewind(VAR_3->ptr);\n                    unsigned char *VAR_45, *VAR_46;\n                    unsigned int VAR_47, VAR_48;\n                    unsigned int VAR_49 = 0;\n\n                    while ((VAR_44 = zipmapNext(VAR_44, &VAR_45, &VAR_47, &VAR_46, &VAR_48)) != NULL) {\n                        if (VAR_47 > VAR_49) VAR_49 = VAR_47;\n                        if (VAR_48 > VAR_49) VAR_49 = VAR_48;\n                        VAR_35 = ziplistPush(VAR_35, VAR_45, VAR_47, VAR_32);\n                        VAR_35 = ziplistPush(VAR_35, VAR_46, VAR_48, VAR_32);\n                    }\n\n                    zfree(VAR_3->ptr);\n                    VAR_3->ptr = VAR_35;\n                    VAR_3->type = VAR_50;\n                    VAR_3->encoding = VAR_27;\n\n                    if (hashTypeLength(VAR_3) > VAR_11.hash_max_ziplist_entries ||\n                        VAR_49 > VAR_11.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(VAR_3, VAR_19);\n                    }\n                }\n                break;\n            case VAR_38:\n                VAR_3->type = VAR_51;\n                VAR_3->encoding = VAR_27;\n                listTypeConvert(VAR_3,VAR_52);\n                break;\n            case VAR_39:\n                VAR_3->type = VAR_53;\n                VAR_3->encoding = VAR_17;\n                if (intsetLen(VAR_3->ptr) > VAR_11.set_max_intset_entries)\n                    setTypeConvert(VAR_3,VAR_19);\n                break;\n            case VAR_40:\n                VAR_3->type = VAR_54;\n                VAR_3->encoding = VAR_27;\n                if (zsetLength(VAR_3) > VAR_11.zset_max_ziplist_entries)\n                    zsetConvert(VAR_3,VAR_55);\n                break;\n            case VAR_41:\n                VAR_3->type = VAR_50;\n                VAR_3->encoding = VAR_27;\n                if (hashTypeLength(VAR_3) > VAR_11.hash_max_ziplist_entries)\n                    hashTypeConvert(VAR_3, VAR_19);\n                break;\n            default:\n                /* COMMENT_33 */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",VAR_0);\n                break;\n        }\n    } else if (VAR_0 == VAR_56) {\n        VAR_3 = createStreamObject();\n        stream *VAR_57 = VAR_3->ptr;\n        uint64_t VAR_58 = rdbLoadLen(VAR_1,NULL);\n        if (VAR_58 == VAR_10) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(VAR_3);\n            return NULL;\n        }\n\n        while(VAR_58--) {\n            /* COMMENT_34 */\n                                                                             \n                                        \n            sds VAR_59 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL);\n            if (VAR_59 == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if (sdslen(VAR_59) != sizeof(VAR_60)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* COMMENT_37 */\n            unsigned char *VAR_61 =\n                rdbGenericLoadStringObject(VAR_1,VAR_36,NULL);\n            if (VAR_61 == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(VAR_59);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            unsigned char *VAR_62 = lpFirst(VAR_61);\n            if (VAR_62 == NULL) {\n                /* COMMENT_38 */\n                                                                      \n                                                  \n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* COMMENT_41 */\n            int VAR_63 = raxInsert(VAR_57->rax,\n                (unsigned char*)VAR_59,sizeof(VAR_60),VAR_61,NULL);\n            sdsfree(VAR_59);\n            if (!VAR_63)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* COMMENT_42 */\n        VAR_57->length = rdbLoadLen(VAR_1,NULL);\n\n        /* COMMENT_43 */\n        VAR_57->last_id.ms = rdbLoadLen(VAR_1,NULL);\n        VAR_57->last_id.seq = rdbLoadLen(VAR_1,NULL);\n\n        if (rioGetReadError(VAR_1)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(VAR_3);\n            return NULL;\n        }\n\n        /* COMMENT_44 */\n        uint64_t VAR_64 = rdbLoadLen(VAR_1,NULL);\n        if (VAR_64 == VAR_10) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(VAR_3);\n            return NULL;\n        }\n        while(VAR_64--) {\n            /* COMMENT_45 */\n                                                                \n                                    \n            streamID VAR_65;\n            sds VAR_66 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL);\n            if (VAR_66 == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            VAR_65.ms = rdbLoadLen(VAR_1,NULL);\n            VAR_65.seq = rdbLoadLen(VAR_1,NULL);\n            if (rioGetReadError(VAR_1)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(VAR_66);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            streamCG *VAR_67 = streamCreateCG(VAR_57,VAR_66,sdslen(VAR_66),&VAR_65);\n            if (VAR_67 == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         VAR_66);\n            sdsfree(VAR_66);\n\n            /* COMMENT_48 */\n                                                                    \n                                                                            \n                                                                         \n                                        \n            uint64_t VAR_68 = rdbLoadLen(VAR_1,NULL);\n            if (VAR_68 == VAR_10) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            while(VAR_68--) {\n                unsigned char VAR_69[sizeof(streamID)];\n                if (rioRead(VAR_1,VAR_69,sizeof(VAR_69)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n                streamNACK *VAR_70 = streamCreateNACK(NULL);\n                VAR_70->delivery_time = rdbLoadMillisecondTime(VAR_1,VAR_71);\n                VAR_70->delivery_count = rdbLoadLen(VAR_1,NULL);\n                if (rioGetReadError(VAR_1)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(VAR_3);\n                    streamFreeNACK(VAR_70);\n                    return NULL;\n                }\n                if (!raxInsert(VAR_67->pel,VAR_69,sizeof(VAR_69),VAR_70,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* COMMENT_53 */\n                                                 \n            uint64_t VAR_72 = rdbLoadLen(VAR_1,NULL);\n            if (VAR_72 == VAR_10) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            while(VAR_72--) {\n                sds VAR_73 = rdbGenericLoadStringObject(VAR_1,VAR_16,NULL);\n                if (VAR_73 == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n                streamConsumer *VAR_74 =\n                    streamLookupConsumer(VAR_67,VAR_73,VAR_75);\n                sdsfree(VAR_73);\n                VAR_74->seen_time = rdbLoadMillisecondTime(VAR_1,VAR_71);\n                if (rioGetReadError(VAR_1)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n\n                /* COMMENT_55 */\n                               \n                VAR_68 = rdbLoadLen(VAR_1,NULL);\n                if (VAR_68 == VAR_10) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n                while(VAR_68--) {\n                    unsigned char VAR_69[sizeof(streamID)];\n                    if (rioRead(VAR_1,VAR_69,sizeof(VAR_69)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(VAR_3);\n                        return NULL;\n                    }\n                    streamNACK *VAR_70 = raxFind(VAR_67->pel,VAR_69,sizeof(VAR_69));\n                    if (VAR_70 == VAR_76)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* COMMENT_57 */\n                                                                       \n                                                                           \n                    VAR_70->consumer = VAR_74;\n                    if (!raxInsert(VAR_74->pel,VAR_69,sizeof(VAR_69),VAR_70,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (VAR_0 == VAR_77 || VAR_0 == VAR_78) {\n        uint64_t VAR_79 = rdbLoadLen(VAR_1,NULL);\n        if (rioGetReadError(VAR_1)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *VAR_80 = moduleTypeLookupModuleByID(VAR_79);\n        char VAR_81[10];\n\n        if (VAR_82 && VAR_0 == VAR_78) {\n            moduleTypeNameByID(VAR_81,VAR_79);\n            return rdbLoadCheckModuleValue(VAR_1,VAR_81);\n        }\n\n        if (VAR_80 == NULL) {\n            moduleTypeNameByID(VAR_81,VAR_79);\n            serverLog(VAR_83,\"The RDB file contains module data I can't load: no matching module '%s'\", VAR_81);\n            exit(1);\n        }\n        RedisModuleIO VAR_84;\n        robj VAR_85;\n        initStaticStringObject(VAR_85,VAR_2);\n        moduleInitIOContext(VAR_84,VAR_80,VAR_1,&VAR_85);\n        VAR_84.ver = (VAR_0 == VAR_77) ? 1 : 2;\n        /* COMMENT_60 */\n                                                                     \n        void *VAR_86 = VAR_80->rdb_load(&VAR_84,VAR_79&1023);\n        if (VAR_84.ctx) {\n            moduleFreeContext(VAR_84.ctx);\n            zfree(VAR_84.ctx);\n        }\n\n        /* COMMENT_62 */\n        if (VAR_84.ver == 2) {\n            uint64_t VAR_87 = rdbLoadLen(VAR_1,NULL);\n            if (VAR_87 == VAR_10) {\n                VAR_3 = createModuleObject(VAR_80,VAR_86); /* COMMENT_63 */\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if (VAR_87 != VAR_88) {\n                serverLog(VAR_83,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", VAR_81);\n                exit(1);\n            }\n        }\n\n        if (VAR_86 == NULL) {\n            moduleTypeNameByID(VAR_81,VAR_79);\n            serverLog(VAR_83,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", VAR_81);\n            exit(1);\n        }\n        VAR_3 = createModuleObject(VAR_80,VAR_86);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",VAR_0);\n        return NULL;\n    }\n    return VAR_3;\n}",
  "func_graph_path_before": "redis/a30d367a71b7017581cf1ca104242a3c644dec0f/rdb.c/vul/before/0.json",
  "func": "robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {\n    robj *o = NULL, *ele, *dec;\n    uint64_t len;\n    unsigned int i;\n\n    if (rdbtype == RDB_TYPE_STRING) {\n        /* Read string value */\n        if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == RDB_TYPE_LIST) {\n        /* Read list value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        /* Load every single element of the list */\n        while(len--) {\n            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            dec = getDecodedObject(ele);\n            size_t len = sdslen(dec->ptr);\n            quicklistPushTail(o->ptr, dec->ptr, len);\n            decrRefCount(dec);\n            decrRefCount(ele);\n        }\n    } else if (rdbtype == RDB_TYPE_SET) {\n        /* Read Set value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        /* Use a regular set when there are too many entries. */\n        size_t max_entries = server.set_max_intset_entries;\n        if (max_entries >= 1<<30) max_entries = 1<<30;\n        if (len > max_entries) {\n            o = createSetObject();\n            /* It's faster to expand the dict to the right size asap in order\n             * to avoid rehashing */\n            if (len > DICT_HT_INITIAL_SIZE)\n                dictExpand(o->ptr,len);\n        } else {\n            o = createIntsetObject();\n        }\n\n        /* Load every single element of the set */\n        for (i = 0; i < len; i++) {\n            long long llval;\n            sds sdsele;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (o->encoding == OBJ_ENCODING_INTSET) {\n                /* Fetch integer value from element. */\n                if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {\n                    o->ptr = intsetAdd(o->ptr,llval,NULL);\n                } else {\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                    dictExpand(o->ptr,len);\n                }\n            }\n\n            /* This will also be called when the set was just converted\n             * to a regular hash table encoded set. */\n            if (o->encoding == OBJ_ENCODING_HT) {\n                dictAdd((dict*)o->ptr,sdsele,NULL);\n            } else {\n                sdsfree(sdsele);\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {\n        /* Read list/set value. */\n        uint64_t zsetlen;\n        size_t maxelelen = 0;\n        zset *zs;\n\n        if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createZsetObject();\n        zs = o->ptr;\n\n        if (zsetlen > DICT_HT_INITIAL_SIZE)\n            dictExpand(zs->dict,zsetlen);\n\n        /* Load every single element of the sorted set. */\n        while(zsetlen--) {\n            sds sdsele;\n            double score;\n            zskiplistNode *znode;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (rdbtype == RDB_TYPE_ZSET_2) {\n                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            }\n\n            /* Don't care about integer-encoded strings. */\n            if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);\n\n            znode = zslInsert(zs->zsl,score,sdsele);\n            dictAdd(zs->dict,sdsele,&znode->score);\n        }\n\n        /* Convert *after* loading, since sorted sets are not stored ordered. */\n        if (zsetLength(o) <= server.zset_max_ziplist_entries &&\n            maxelelen <= server.zset_max_ziplist_value)\n                zsetConvert(o,OBJ_ENCODING_ZIPLIST);\n    } else if (rdbtype == RDB_TYPE_HASH) {\n        uint64_t len;\n        int ret;\n        sds field, value;\n\n        len = rdbLoadLen(rdb, NULL);\n        if (len == RDB_LENERR) return NULL;\n\n        o = createHashObject();\n\n        /* Too many entries? Use a hash table. */\n        if (len > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n\n        /* Load every field and value into the ziplist */\n        while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {\n            len--;\n            /* Load raw strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to ziplist */\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)field,\n                    sdslen(field), ZIPLIST_TAIL);\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)value,\n                    sdslen(value), ZIPLIST_TAIL);\n\n            /* Convert to hash table if size threshold is exceeded */\n            if (sdslen(field) > server.hash_max_ziplist_value ||\n                sdslen(value) > server.hash_max_ziplist_value)\n            {\n                sdsfree(field);\n                sdsfree(value);\n                hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            }\n            sdsfree(field);\n            sdsfree(value);\n        }\n\n        if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)\n            dictExpand(o->ptr,len);\n\n        /* Load remaining fields and values into the hash table */\n        while (o->encoding == OBJ_ENCODING_HT && len > 0) {\n            len--;\n            /* Load encoded strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to hash table */\n            ret = dictAdd((dict*)o->ptr, field, value);\n            if (ret == DICT_ERR) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* All pairs should be read by now */\n        serverAssert(len == 0);\n    } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        while (len--) {\n            unsigned char *zl =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (zl == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            quicklistAppendZiplist(o->ptr, zl);\n        }\n    } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||\n               rdbtype == RDB_TYPE_LIST_ZIPLIST ||\n               rdbtype == RDB_TYPE_SET_INTSET   ||\n               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||\n               rdbtype == RDB_TYPE_HASH_ZIPLIST)\n    {\n        unsigned char *encoded =\n            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n        if (encoded == NULL) return NULL;\n        o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */\n\n        /* Fix the object encoding, and make sure to convert the encoded\n         * data type into the base type if accordingly to the current\n         * configuration there are too many elements in the encoded data\n         * type. Note that we only check the length and not max element\n         * size as this is an O(N) scan. Eventually everything will get\n         * converted. */\n        switch(rdbtype) {\n            case RDB_TYPE_HASH_ZIPMAP:\n                /* Convert to ziplist encoded hash. This must be deprecated\n                 * when loading dumps created by Redis 2.4 gets deprecated. */\n                {\n                    unsigned char *zl = ziplistNew();\n                    unsigned char *zi = zipmapRewind(o->ptr);\n                    unsigned char *fstr, *vstr;\n                    unsigned int flen, vlen;\n                    unsigned int maxlen = 0;\n\n                    while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {\n                        if (flen > maxlen) maxlen = flen;\n                        if (vlen > maxlen) maxlen = vlen;\n                        zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);\n                        zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);\n                    }\n\n                    zfree(o->ptr);\n                    o->ptr = zl;\n                    o->type = OBJ_HASH;\n                    o->encoding = OBJ_ENCODING_ZIPLIST;\n\n                    if (hashTypeLength(o) > server.hash_max_ziplist_entries ||\n                        maxlen > server.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(o, OBJ_ENCODING_HT);\n                    }\n                }\n                break;\n            case RDB_TYPE_LIST_ZIPLIST:\n                o->type = OBJ_LIST;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);\n                break;\n            case RDB_TYPE_SET_INTSET:\n                o->type = OBJ_SET;\n                o->encoding = OBJ_ENCODING_INTSET;\n                if (intsetLen(o->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                break;\n            case RDB_TYPE_ZSET_ZIPLIST:\n                o->type = OBJ_ZSET;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (zsetLength(o) > server.zset_max_ziplist_entries)\n                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);\n                break;\n            case RDB_TYPE_HASH_ZIPLIST:\n                o->type = OBJ_HASH;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n                    hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            default:\n                /* totally unreachable */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",rdbtype);\n                break;\n        }\n    } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        uint64_t listpacks = rdbLoadLen(rdb,NULL);\n        if (listpacks == RDB_LENERR) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        while(listpacks--) {\n            /* Get the master ID, the one we'll use as key of the radix tree\n             * node: the entries inside the listpack itself are delta-encoded\n             * relatively to this ID. */\n            sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (nodekey == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            if (sdslen(nodekey) != sizeof(streamID)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* Load the listpack. */\n            unsigned char *lp =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (lp == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(nodekey);\n                decrRefCount(o);\n                return NULL;\n            }\n            unsigned char *first = lpFirst(lp);\n            if (first == NULL) {\n                /* Serialized listpacks should never be empty, since on\n                 * deletion we should remove the radix tree key if the\n                 * resulting listpack is empty. */\n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* Insert the key in the radix tree. */\n            int retval = raxInsert(s->rax,\n                (unsigned char*)nodekey,sizeof(streamID),lp,NULL);\n            sdsfree(nodekey);\n            if (!retval)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* Load total number of items inside the stream. */\n        s->length = rdbLoadLen(rdb,NULL);\n\n        /* Load the last entry ID. */\n        s->last_id.ms = rdbLoadLen(rdb,NULL);\n        s->last_id.seq = rdbLoadLen(rdb,NULL);\n\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        /* Consumer groups loading */\n        uint64_t cgroups_count = rdbLoadLen(rdb,NULL);\n        if (cgroups_count == RDB_LENERR) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n        while(cgroups_count--) {\n            /* Get the consumer group name and ID. We can then create the\n             * consumer group ASAP and populate its structure as\n             * we read more data. */\n            streamID cg_id;\n            sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (cgname == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(o);\n                return NULL;\n            }\n\n            cg_id.ms = rdbLoadLen(rdb,NULL);\n            cg_id.seq = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(cgname);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);\n            if (cgroup == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         cgname);\n            sdsfree(cgname);\n\n            /* Load the global PEL for this consumer group, however we'll\n             * not yet populate the NACK structures with the message\n             * owner, since consumers for this group and their messages will\n             * be read as a next step. So for now leave them not resolved\n             * and later populate it. */\n            uint64_t pel_size = rdbLoadLen(rdb,NULL);\n            if (pel_size == RDB_LENERR) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(pel_size--) {\n                unsigned char rawid[sizeof(streamID)];\n                if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamNACK *nack = streamCreateNACK(NULL);\n                nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                nack->delivery_count = rdbLoadLen(rdb,NULL);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(o);\n                    streamFreeNACK(nack);\n                    return NULL;\n                }\n                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* Now that we loaded our global PEL, we need to load the\n             * consumers and their local PELs. */\n            uint64_t consumers_num = rdbLoadLen(rdb,NULL);\n            if (consumers_num == RDB_LENERR) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(consumers_num--) {\n                sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n                if (cname == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamConsumer *consumer =\n                    streamLookupConsumer(cgroup,cname,SLC_NONE);\n                sdsfree(cname);\n                consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n\n                /* Load the PEL about entries owned by this specific\n                 * consumer. */\n                pel_size = rdbLoadLen(rdb,NULL);\n                if (pel_size == RDB_LENERR) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                while(pel_size--) {\n                    unsigned char rawid[sizeof(streamID)];\n                    if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(o);\n                        return NULL;\n                    }\n                    streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));\n                    if (nack == raxNotFound)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* Set the NACK consumer, that was left to NULL when\n                     * loading the global PEL. Then set the same shared\n                     * NACK structure also in the consumer-specific PEL. */\n                    nack->consumer = consumer;\n                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {\n        uint64_t moduleid = rdbLoadLen(rdb,NULL);\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n        char name[10];\n\n        if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {\n            moduleTypeNameByID(name,moduleid);\n            return rdbLoadCheckModuleValue(rdb,name);\n        }\n\n        if (mt == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data I can't load: no matching module '%s'\", name);\n            exit(1);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        initStaticStringObject(keyobj,key);\n        moduleInitIOContext(io,mt,rdb,&keyobj);\n        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;\n        /* Call the rdb_load method of the module providing the 10 bit\n         * encoding version in the lower 10 bits of the module ID. */\n        void *ptr = mt->rdb_load(&io,moduleid&1023);\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n\n        /* Module v2 serialization has an EOF mark at the end. */\n        if (io.ver == 2) {\n            uint64_t eof = rdbLoadLen(rdb,NULL);\n            if (eof == RDB_LENERR) {\n                o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */\n                decrRefCount(o);\n                return NULL;\n            }\n            if (eof != RDB_MODULE_OPCODE_EOF) {\n                serverLog(LL_WARNING,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                exit(1);\n            }\n        }\n\n        if (ptr == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n            exit(1);\n        }\n        o = createModuleObject(mt,ptr);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",rdbtype);\n        return NULL;\n    }\n    return o;\n}",
  "abstract_func": "robj *rdbLoadObject(int VAR_0, rio *VAR_1, sds VAR_2) {\n    robj *VAR_3 = NULL, *VAR_4, *VAR_5;\n    uint64_t VAR_6;\n    unsigned int VAR_7;\n\n    if (VAR_0 == VAR_8) {\n        /* COMMENT_0 */\n        if ((VAR_3 = rdbLoadEncodedStringObject(VAR_1)) == NULL) return NULL;\n        VAR_3 = tryObjectEncoding(VAR_3);\n    } else if (VAR_0 == VAR_9) {\n        /* COMMENT_1 */\n        if ((VAR_6 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n\n        VAR_3 = createQuicklistObject();\n        quicklistSetOptions(VAR_3->ptr, VAR_11.list_max_ziplist_size,\n                            VAR_11.list_compress_depth);\n\n        /* COMMENT_2 */\n        while(VAR_6--) {\n            if ((VAR_4 = rdbLoadEncodedStringObject(VAR_1)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            VAR_5 = getDecodedObject(VAR_4);\n            size_t VAR_6 = sdslen(VAR_5->ptr);\n            quicklistPushTail(VAR_3->ptr, VAR_5->ptr, VAR_6);\n            decrRefCount(VAR_5);\n            decrRefCount(VAR_4);\n        }\n    } else if (VAR_0 == VAR_12) {\n        /* COMMENT_3 */\n        if ((VAR_6 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n\n        /* COMMENT_4 */\n        size_t VAR_13 = VAR_11.set_max_intset_entries;\n        if (VAR_13 >= 1<<30) VAR_13 = 1<<30;\n        if (VAR_6 > VAR_13) {\n            VAR_3 = createSetObject();\n            /* COMMENT_5 */\n                                    \n            if (VAR_6 > VAR_14)\n                dictExpand(VAR_3->ptr,VAR_6);\n        } else {\n            VAR_3 = createIntsetObject();\n        }\n\n        /* COMMENT_7 */\n        for (VAR_7 = 0; VAR_7 < VAR_6; VAR_7++) {\n            long long VAR_15;\n            sds VAR_16;\n\n            if ((VAR_16 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            if (VAR_3->encoding == VAR_18) {\n                /* COMMENT_8 */\n                if (isSdsRepresentableAsLongLong(VAR_16,&VAR_15) == VAR_19) {\n                    VAR_3->ptr = intsetAdd(VAR_3->ptr,VAR_15,NULL);\n                } else {\n                    setTypeConvert(VAR_3,VAR_20);\n                    dictExpand(VAR_3->ptr,VAR_6);\n                }\n            }\n\n            /* COMMENT_9 */\n                                                      \n            if (VAR_3->encoding == VAR_20) {\n                dictAdd((dict*)VAR_3->ptr,VAR_16,NULL);\n            } else {\n                sdsfree(VAR_16);\n            }\n        }\n    } else if (VAR_0 == VAR_21 || VAR_0 == VAR_22) {\n        /* COMMENT_11 */\n        uint64_t VAR_23;\n        size_t VAR_24 = 0;\n        zset *VAR_25;\n\n        if ((VAR_23 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n        VAR_3 = createZsetObject();\n        VAR_25 = VAR_3->ptr;\n\n        if (VAR_23 > VAR_14)\n            dictExpand(VAR_25->dict,VAR_23);\n\n        /* COMMENT_12 */\n        while(VAR_23--) {\n            sds VAR_16;\n            double VAR_26;\n            zskiplistNode *VAR_27;\n\n            if ((VAR_16 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            if (VAR_0 == VAR_21) {\n                if (rdbLoadBinaryDoubleValue(VAR_1,&VAR_26) == -1) {\n                    decrRefCount(VAR_3);\n                    sdsfree(VAR_16);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(VAR_1,&VAR_26) == -1) {\n                    decrRefCount(VAR_3);\n                    sdsfree(VAR_16);\n                    return NULL;\n                }\n            }\n\n            /* COMMENT_13 */\n            if (sdslen(VAR_16) > VAR_24) VAR_24 = sdslen(VAR_16);\n\n            VAR_27 = zslInsert(VAR_25->zsl,VAR_26,VAR_16);\n            dictAdd(VAR_25->dict,VAR_16,&VAR_27->score);\n        }\n\n        /* COMMENT_14 */\n        if (zsetLength(VAR_3) <= VAR_11.zset_max_ziplist_entries &&\n            VAR_24 <= VAR_11.zset_max_ziplist_value)\n                zsetConvert(VAR_3,VAR_28);\n    } else if (VAR_0 == VAR_29) {\n        uint64_t VAR_6;\n        int VAR_30;\n        sds VAR_31, VAR_32;\n\n        VAR_6 = rdbLoadLen(VAR_1, NULL);\n        if (VAR_6 == VAR_10) return NULL;\n\n        VAR_3 = createHashObject();\n\n        /* COMMENT_15 */\n        if (VAR_6 > VAR_11.hash_max_ziplist_entries)\n            hashTypeConvert(VAR_3, VAR_20);\n\n        /* COMMENT_16 */\n        while (VAR_3->encoding == VAR_28 && VAR_6 > 0) {\n            VAR_6--;\n            /* COMMENT_17 */\n            if ((VAR_31 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if ((VAR_32 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL)) == NULL) {\n                sdsfree(VAR_31);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            /* COMMENT_18 */\n            VAR_3->ptr = ziplistPush(VAR_3->ptr, (unsigned char*)VAR_31,\n                    sdslen(VAR_31), VAR_33);\n            VAR_3->ptr = ziplistPush(VAR_3->ptr, (unsigned char*)VAR_32,\n                    sdslen(VAR_32), VAR_33);\n\n            /* COMMENT_19 */\n            if (sdslen(VAR_31) > VAR_11.hash_max_ziplist_value ||\n                sdslen(VAR_32) > VAR_11.hash_max_ziplist_value)\n            {\n                sdsfree(VAR_31);\n                sdsfree(VAR_32);\n                hashTypeConvert(VAR_3, VAR_20);\n                break;\n            }\n            sdsfree(VAR_31);\n            sdsfree(VAR_32);\n        }\n\n        if (VAR_3->encoding == VAR_20 && VAR_6 > VAR_14)\n            dictExpand(VAR_3->ptr,VAR_6);\n\n        /* COMMENT_20 */\n        while (VAR_3->encoding == VAR_20 && VAR_6 > 0) {\n            VAR_6--;\n            /* COMMENT_21 */\n            if ((VAR_31 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL)) == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if ((VAR_32 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL)) == NULL) {\n                sdsfree(VAR_31);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            /* COMMENT_22 */\n            VAR_30 = dictAdd((dict*)VAR_3->ptr, VAR_31, VAR_32);\n            if (VAR_30 == VAR_34) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* COMMENT_23 */\n        serverAssert(VAR_6 == 0);\n    } else if (VAR_0 == VAR_35) {\n        if ((VAR_6 = rdbLoadLen(VAR_1,NULL)) == VAR_10) return NULL;\n        VAR_3 = createQuicklistObject();\n        quicklistSetOptions(VAR_3->ptr, VAR_11.list_max_ziplist_size,\n                            VAR_11.list_compress_depth);\n\n        while (VAR_6--) {\n            unsigned char *VAR_36 =\n                rdbGenericLoadStringObject(VAR_1,VAR_37,NULL);\n            if (VAR_36 == NULL) {\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            quicklistAppendZiplist(VAR_3->ptr, VAR_36);\n        }\n    } else if (VAR_0 == VAR_38  ||\n               VAR_0 == VAR_39 ||\n               VAR_0 == VAR_40   ||\n               VAR_0 == VAR_41 ||\n               VAR_0 == VAR_42)\n    {\n        unsigned char *VAR_43 =\n            rdbGenericLoadStringObject(VAR_1,VAR_37,NULL);\n        if (VAR_43 == NULL) return NULL;\n        VAR_3 = createObject(VAR_44,VAR_43); /* COMMENT_24 */\n\n        /* COMMENT_25 */\n                                                                     \n                                                                        \n                                                                       \n                                                                       \n                        \n        switch(VAR_0) {\n            case VAR_38:\n                /* COMMENT_31 */\n                                                                              \n                {\n                    unsigned char *VAR_36 = ziplistNew();\n                    unsigned char *VAR_45 = zipmapRewind(VAR_3->ptr);\n                    unsigned char *VAR_46, *VAR_47;\n                    unsigned int VAR_48, VAR_49;\n                    unsigned int VAR_50 = 0;\n\n                    while ((VAR_45 = zipmapNext(VAR_45, &VAR_46, &VAR_48, &VAR_47, &VAR_49)) != NULL) {\n                        if (VAR_48 > VAR_50) VAR_50 = VAR_48;\n                        if (VAR_49 > VAR_50) VAR_50 = VAR_49;\n                        VAR_36 = ziplistPush(VAR_36, VAR_46, VAR_48, VAR_33);\n                        VAR_36 = ziplistPush(VAR_36, VAR_47, VAR_49, VAR_33);\n                    }\n\n                    zfree(VAR_3->ptr);\n                    VAR_3->ptr = VAR_36;\n                    VAR_3->type = VAR_51;\n                    VAR_3->encoding = VAR_28;\n\n                    if (hashTypeLength(VAR_3) > VAR_11.hash_max_ziplist_entries ||\n                        VAR_50 > VAR_11.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(VAR_3, VAR_20);\n                    }\n                }\n                break;\n            case VAR_39:\n                VAR_3->type = VAR_52;\n                VAR_3->encoding = VAR_28;\n                listTypeConvert(VAR_3,VAR_53);\n                break;\n            case VAR_40:\n                VAR_3->type = VAR_54;\n                VAR_3->encoding = VAR_18;\n                if (intsetLen(VAR_3->ptr) > VAR_11.set_max_intset_entries)\n                    setTypeConvert(VAR_3,VAR_20);\n                break;\n            case VAR_41:\n                VAR_3->type = VAR_55;\n                VAR_3->encoding = VAR_28;\n                if (zsetLength(VAR_3) > VAR_11.zset_max_ziplist_entries)\n                    zsetConvert(VAR_3,VAR_56);\n                break;\n            case VAR_42:\n                VAR_3->type = VAR_51;\n                VAR_3->encoding = VAR_28;\n                if (hashTypeLength(VAR_3) > VAR_11.hash_max_ziplist_entries)\n                    hashTypeConvert(VAR_3, VAR_20);\n                break;\n            default:\n                /* COMMENT_33 */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",VAR_0);\n                break;\n        }\n    } else if (VAR_0 == VAR_57) {\n        VAR_3 = createStreamObject();\n        stream *VAR_58 = VAR_3->ptr;\n        uint64_t VAR_59 = rdbLoadLen(VAR_1,NULL);\n        if (VAR_59 == VAR_10) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(VAR_3);\n            return NULL;\n        }\n\n        while(VAR_59--) {\n            /* COMMENT_34 */\n                                                                             \n                                        \n            sds VAR_60 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL);\n            if (VAR_60 == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if (sdslen(VAR_60) != sizeof(VAR_61)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* COMMENT_37 */\n            unsigned char *VAR_62 =\n                rdbGenericLoadStringObject(VAR_1,VAR_37,NULL);\n            if (VAR_62 == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(VAR_60);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            unsigned char *VAR_63 = lpFirst(VAR_62);\n            if (VAR_63 == NULL) {\n                /* COMMENT_38 */\n                                                                      \n                                                  \n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* COMMENT_41 */\n            int VAR_64 = raxInsert(VAR_58->rax,\n                (unsigned char*)VAR_60,sizeof(VAR_61),VAR_62,NULL);\n            sdsfree(VAR_60);\n            if (!VAR_64)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* COMMENT_42 */\n        VAR_58->length = rdbLoadLen(VAR_1,NULL);\n\n        /* COMMENT_43 */\n        VAR_58->last_id.ms = rdbLoadLen(VAR_1,NULL);\n        VAR_58->last_id.seq = rdbLoadLen(VAR_1,NULL);\n\n        if (rioGetReadError(VAR_1)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(VAR_3);\n            return NULL;\n        }\n\n        /* COMMENT_44 */\n        uint64_t VAR_65 = rdbLoadLen(VAR_1,NULL);\n        if (VAR_65 == VAR_10) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(VAR_3);\n            return NULL;\n        }\n        while(VAR_65--) {\n            /* COMMENT_45 */\n                                                                \n                                    \n            streamID VAR_66;\n            sds VAR_67 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL);\n            if (VAR_67 == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            VAR_66.ms = rdbLoadLen(VAR_1,NULL);\n            VAR_66.seq = rdbLoadLen(VAR_1,NULL);\n            if (rioGetReadError(VAR_1)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(VAR_67);\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n\n            streamCG *VAR_68 = streamCreateCG(VAR_58,VAR_67,sdslen(VAR_67),&VAR_66);\n            if (VAR_68 == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         VAR_67);\n            sdsfree(VAR_67);\n\n            /* COMMENT_48 */\n                                                                    \n                                                                            \n                                                                         \n                                        \n            uint64_t VAR_69 = rdbLoadLen(VAR_1,NULL);\n            if (VAR_69 == VAR_10) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            while(VAR_69--) {\n                unsigned char VAR_70[sizeof(streamID)];\n                if (rioRead(VAR_1,VAR_70,sizeof(VAR_70)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n                streamNACK *VAR_71 = streamCreateNACK(NULL);\n                VAR_71->delivery_time = rdbLoadMillisecondTime(VAR_1,VAR_72);\n                VAR_71->delivery_count = rdbLoadLen(VAR_1,NULL);\n                if (rioGetReadError(VAR_1)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(VAR_3);\n                    streamFreeNACK(VAR_71);\n                    return NULL;\n                }\n                if (!raxInsert(VAR_68->pel,VAR_70,sizeof(VAR_70),VAR_71,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* COMMENT_53 */\n                                                 \n            uint64_t VAR_73 = rdbLoadLen(VAR_1,NULL);\n            if (VAR_73 == VAR_10) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            while(VAR_73--) {\n                sds VAR_74 = rdbGenericLoadStringObject(VAR_1,VAR_17,NULL);\n                if (VAR_74 == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n                streamConsumer *VAR_75 =\n                    streamLookupConsumer(VAR_68,VAR_74,VAR_76);\n                sdsfree(VAR_74);\n                VAR_75->seen_time = rdbLoadMillisecondTime(VAR_1,VAR_72);\n                if (rioGetReadError(VAR_1)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n\n                /* COMMENT_55 */\n                               \n                VAR_69 = rdbLoadLen(VAR_1,NULL);\n                if (VAR_69 == VAR_10) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(VAR_3);\n                    return NULL;\n                }\n                while(VAR_69--) {\n                    unsigned char VAR_70[sizeof(streamID)];\n                    if (rioRead(VAR_1,VAR_70,sizeof(VAR_70)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(VAR_3);\n                        return NULL;\n                    }\n                    streamNACK *VAR_71 = raxFind(VAR_68->pel,VAR_70,sizeof(VAR_70));\n                    if (VAR_71 == VAR_77)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* COMMENT_57 */\n                                                                       \n                                                                           \n                    VAR_71->consumer = VAR_75;\n                    if (!raxInsert(VAR_75->pel,VAR_70,sizeof(VAR_70),VAR_71,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (VAR_0 == VAR_78 || VAR_0 == VAR_79) {\n        uint64_t VAR_80 = rdbLoadLen(VAR_1,NULL);\n        if (rioGetReadError(VAR_1)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *VAR_81 = moduleTypeLookupModuleByID(VAR_80);\n        char VAR_82[10];\n\n        if (VAR_83 && VAR_0 == VAR_79) {\n            moduleTypeNameByID(VAR_82,VAR_80);\n            return rdbLoadCheckModuleValue(VAR_1,VAR_82);\n        }\n\n        if (VAR_81 == NULL) {\n            moduleTypeNameByID(VAR_82,VAR_80);\n            serverLog(VAR_84,\"The RDB file contains module data I can't load: no matching module '%s'\", VAR_82);\n            exit(1);\n        }\n        RedisModuleIO VAR_85;\n        robj VAR_86;\n        initStaticStringObject(VAR_86,VAR_2);\n        moduleInitIOContext(VAR_85,VAR_81,VAR_1,&VAR_86);\n        VAR_85.ver = (VAR_0 == VAR_78) ? 1 : 2;\n        /* COMMENT_60 */\n                                                                     \n        void *VAR_87 = VAR_81->rdb_load(&VAR_85,VAR_80&1023);\n        if (VAR_85.ctx) {\n            moduleFreeContext(VAR_85.ctx);\n            zfree(VAR_85.ctx);\n        }\n\n        /* COMMENT_62 */\n        if (VAR_85.ver == 2) {\n            uint64_t VAR_88 = rdbLoadLen(VAR_1,NULL);\n            if (VAR_88 == VAR_10) {\n                VAR_3 = createModuleObject(VAR_81,VAR_87); /* COMMENT_63 */\n                decrRefCount(VAR_3);\n                return NULL;\n            }\n            if (VAR_88 != VAR_89) {\n                serverLog(VAR_84,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", VAR_82);\n                exit(1);\n            }\n        }\n\n        if (VAR_87 == NULL) {\n            moduleTypeNameByID(VAR_82,VAR_80);\n            serverLog(VAR_84,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", VAR_82);\n            exit(1);\n        }\n        VAR_3 = createModuleObject(VAR_81,VAR_87);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",VAR_0);\n        return NULL;\n    }\n    return VAR_3;\n}",
  "func_graph_path": "redis/a30d367a71b7017581cf1ca104242a3c644dec0f/rdb.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,9 @@\n         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n \n         /* Use a regular set when there are too many entries. */\n-        if (len > server.set_max_intset_entries) {\n+        size_t max_entries = server.set_max_intset_entries;\n+        if (max_entries >= 1<<30) max_entries = 1<<30;\n+        if (len > max_entries) {\n             o = createSetObject();\n             /* It's faster to expand the dict to the right size asap in order\n              * to avoid rehashing */",
  "diff_line_info": {
    "deleted_lines": [
      "        if (len > server.set_max_intset_entries) {"
    ],
    "added_lines": [
      "        size_t max_entries = server.set_max_intset_entries;",
      "        if (max_entries >= 1<<30) max_entries = 1<<30;",
      "        if (len > max_entries) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nStep-by-Step Explanation:\n\n1. **Security Indicators:** The commit message references a CVE (CVE-2021-32687) and mentions \"Integer overflow issue,\" which are clear indicators of a security vulnerability.\n\n2. **Vulnerability Description:** Aligns exactly with the commit, confirming it's a security fix.\n\n3. **Code Changes:** Implements a cap on the max_entries variable to prevent overflow, directly addressing the security flaw.\n\nThese elements consistently point to a security fix with high confidence."
}