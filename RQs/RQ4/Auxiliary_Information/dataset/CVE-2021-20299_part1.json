{
  "cve_id": "CVE-2021-20299",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "AcademySoftwareFoundation/openexr",
  "commit_msg": "add sanity check for reading multipart files with no parts (#840)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "commit_hash": "25e9515b06a6bc293d871622b8cafaee7af84e0f",
  "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/25e9515b06a6bc293d871622b8cafaee7af84e0f",
  "file_path": "OpenEXR/IlmImf/ImfMultiPartInputFile.cpp",
  "func_name": "MultiPartInputFile::initialize",
  "func_before": "void\nMultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*_data->is, _data->version);\n    \n    bool multipart = isMultiPart(_data->version);\n    bool tiled = isTiled(_data->version);\n\n    //\n    // Multipart files don't have and shouldn't have the tiled bit set.\n    //\n\n    if (tiled && multipart)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int pos = 0;\n    while (true)\n    {\n        Header header;\n        header.readFrom(*_data->is, _data->version);\n\n        //\n        // If we read nothing then we stop reading.\n        //\n\n        if (header.readsNothing())\n        {\n            pos++;\n            break;\n        }\n\n        _data->_headers.push_back(header);\n        \n        if(multipart == false)\n          break;\n    }\n\n    //\n    // Perform usual check on headers.\n    //\n\n    for (size_t i = 0; i < _data->_headers.size(); i++)\n    {\n        //\n        // Silently invent a type if the file is a single part regular image.\n        //\n\n        if( _data->_headers[i].hasType() == false )\n        {\n            if(multipart)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n        }\n        else\n        {\n            \n            //\n            // Silently fix the header type if it's wrong\n            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,\n            //  so doesn't effect deep image types)\n            //\n\n            if(!multipart && !isNonImage(_data->version))\n            {\n                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n            }\n        }\n         \n\n        \n        if( _data->_headers[i].hasName() == false )\n        {\n            if(multipart)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(_data->_headers[i].type()))\n            _data->_headers[i].sanityCheck(true, multipart);\n        else\n            _data->_headers[i].sanityCheck(false, multipart);\n    }\n\n    //\n    // Check name uniqueness.\n    //\n\n    if (multipart)\n    {\n        set<string> names;\n        for (size_t i = 0; i < _data->_headers.size(); i++)\n        {\n        \n            if (names.find(_data->_headers[i].name()) != names.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                   \" is not a unique name.\");\n            }\n            names.insert(_data->_headers[i].name());\n        }\n    }\n    \n    //\n    // Check shared attributes compliance.\n    //\n\n    if (multipart && strictSharedAttribute)\n    {\n        for (size_t i = 1; i < _data->_headers.size(); i++)\n        {\n            vector <string> attrs;\n            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))\n            {\n                string attrNames;\n                for (size_t j=0; j<attrs.size(); j++)\n                    attrNames += \" \" + attrs[j];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     attrNames);\n            }\n        }\n    }\n\n    //\n    // Create InputParts and read chunk offset tables.\n    //\n        \n    for (size_t i = 0; i < _data->_headers.size(); i++)\n        _data->parts.push_back(\n                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));\n\n    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);\n}",
  "abstract_func_before": "void\nMultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*VAR_0->is, VAR_0->version);\n    \n    bool VAR_1 = isMultiPart(VAR_0->version);\n    bool VAR_2 = isTiled(VAR_0->version);\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_0 */\n\n    if (VAR_2 && VAR_1)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int VAR_3 = 0;\n    while (true)\n    {\n        Header VAR_4;\n        VAR_4.readFrom(*VAR_0->is, VAR_0->version);\n\n        /* COMMENT_0 */\n        /* COMMENT_2 */\n        /* COMMENT_0 */\n\n        if (VAR_4.readsNothing())\n        {\n            VAR_3++;\n            break;\n        }\n\n        VAR_0->_headers.push_back(VAR_4);\n        \n        if(VAR_1 == false)\n          break;\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_3 */\n    /* COMMENT_0 */\n\n    for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n    {\n        /* COMMENT_0 */\n        /* COMMENT_4 */\n        /* COMMENT_0 */\n\n        if( VAR_0->_headers[VAR_5].hasType() == false )\n        {\n            if(VAR_1)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);\n        }\n        else\n        {\n            \n            /* COMMENT_0 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_0 */\n\n            if(!VAR_1 && !isNonImage(VAR_0->version))\n            {\n                VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);\n            }\n        }\n         \n\n        \n        if( VAR_0->_headers[VAR_5].hasName() == false )\n        {\n            if(VAR_1)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(VAR_0->_headers[VAR_5].type()))\n            VAR_0->_headers[VAR_5].sanityCheck(true, VAR_1);\n        else\n            VAR_0->_headers[VAR_5].sanityCheck(false, VAR_1);\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_8 */\n    /* COMMENT_0 */\n\n    if (VAR_1)\n    {\n        set<string> VAR_8;\n        for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n        {\n        \n            if (VAR_8.find(VAR_0->_headers[VAR_5].name()) != VAR_8.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + VAR_0->_headers[VAR_5].name() +\n                                   \" is not a unique name.\");\n            }\n            VAR_8.insert(VAR_0->_headers[VAR_5].name());\n        }\n    }\n    \n    /* COMMENT_0 */\n    /* COMMENT_9 */\n    /* COMMENT_0 */\n\n    if (VAR_1 && VAR_9)\n    {\n        for (size_t VAR_5 = 1; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n        {\n            vector <string> VAR_10;\n            if (VAR_0->checkSharedAttributesValues (VAR_0->_headers[0], VAR_0->_headers[VAR_5], VAR_10))\n            {\n                string VAR_11;\n                for (size_t VAR_12=0; VAR_12<VAR_10.size(); VAR_12++)\n                    VAR_11 += \" \" + VAR_10[VAR_12];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + VAR_0->_headers[VAR_5].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     VAR_11);\n            }\n        }\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_10 */\n    /* COMMENT_0 */\n        \n    for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n        VAR_0->parts.push_back(\n                new InputPartData(VAR_0, VAR_0->_headers[VAR_5], VAR_5, VAR_0->numThreads, VAR_0->version));\n\n    VAR_0->readChunkOffsetTables(VAR_0->reconstructChunkOffsetTable);\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/openexr/25e9515b06a6bc293d871622b8cafaee7af84e0f/ImfMultiPartInputFile.cpp/vul/before/0.json",
  "func": "void\nMultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*_data->is, _data->version);\n    \n    bool multipart = isMultiPart(_data->version);\n    bool tiled = isTiled(_data->version);\n\n    //\n    // Multipart files don't have and shouldn't have the tiled bit set.\n    //\n\n    if (tiled && multipart)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int pos = 0;\n    while (true)\n    {\n        Header header;\n        header.readFrom(*_data->is, _data->version);\n\n        //\n        // If we read nothing then we stop reading.\n        //\n\n        if (header.readsNothing())\n        {\n            pos++;\n            break;\n        }\n\n        _data->_headers.push_back(header);\n        \n        if(multipart == false)\n          break;\n    }\n\n    //\n    // Perform usual check on headers.\n    //\n\n    if ( _data->_headers.size() == 0)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\");\n    }\n\n    for (size_t i = 0; i < _data->_headers.size(); i++)\n    {\n        //\n        // Silently invent a type if the file is a single part regular image.\n        //\n\n        if( _data->_headers[i].hasType() == false )\n        {\n            if(multipart)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n        }\n        else\n        {\n            \n            //\n            // Silently fix the header type if it's wrong\n            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,\n            //  so doesn't effect deep image types)\n            //\n\n            if(!multipart && !isNonImage(_data->version))\n            {\n                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);\n            }\n        }\n         \n\n        \n        if( _data->_headers[i].hasName() == false )\n        {\n            if(multipart)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(_data->_headers[i].type()))\n            _data->_headers[i].sanityCheck(true, multipart);\n        else\n            _data->_headers[i].sanityCheck(false, multipart);\n    }\n\n    //\n    // Check name uniqueness.\n    //\n\n    if (multipart)\n    {\n        set<string> names;\n        for (size_t i = 0; i < _data->_headers.size(); i++)\n        {\n        \n            if (names.find(_data->_headers[i].name()) != names.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                   \" is not a unique name.\");\n            }\n            names.insert(_data->_headers[i].name());\n        }\n    }\n    \n    //\n    // Check shared attributes compliance.\n    //\n\n    if (multipart && strictSharedAttribute)\n    {\n        for (size_t i = 1; i < _data->_headers.size(); i++)\n        {\n            vector <string> attrs;\n            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))\n            {\n                string attrNames;\n                for (size_t j=0; j<attrs.size(); j++)\n                    attrNames += \" \" + attrs[j];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     attrNames);\n            }\n        }\n    }\n\n    //\n    // Create InputParts and read chunk offset tables.\n    //\n        \n    for (size_t i = 0; i < _data->_headers.size(); i++)\n        _data->parts.push_back(\n                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));\n\n    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);\n}",
  "abstract_func": "void\nMultiPartInputFile::initialize()\n{\n    readMagicNumberAndVersionField(*VAR_0->is, VAR_0->version);\n    \n    bool VAR_1 = isMultiPart(VAR_0->version);\n    bool VAR_2 = isTiled(VAR_0->version);\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_0 */\n\n    if (VAR_2 && VAR_1)\n        throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");\n\n    \n    int VAR_3 = 0;\n    while (true)\n    {\n        Header VAR_4;\n        VAR_4.readFrom(*VAR_0->is, VAR_0->version);\n\n        /* COMMENT_0 */\n        /* COMMENT_2 */\n        /* COMMENT_0 */\n\n        if (VAR_4.readsNothing())\n        {\n            VAR_3++;\n            break;\n        }\n\n        VAR_0->_headers.push_back(VAR_4);\n        \n        if(VAR_1 == false)\n          break;\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_3 */\n    /* COMMENT_0 */\n\n    if ( VAR_0->_headers.size() == 0)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\");\n    }\n\n    for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n    {\n        /* COMMENT_0 */\n        /* COMMENT_4 */\n        /* COMMENT_0 */\n\n        if( VAR_0->_headers[VAR_5].hasType() == false )\n        {\n            if(VAR_1)\n\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");\n          \n            VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);\n        }\n        else\n        {\n            \n            /* COMMENT_0 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_0 */\n\n            if(!VAR_1 && !isNonImage(VAR_0->version))\n            {\n                VAR_0->_headers[VAR_5].setType(VAR_2 ? VAR_6 : VAR_7);\n            }\n        }\n         \n\n        \n        if( VAR_0->_headers[VAR_5].hasName() == false )\n        {\n            if(VAR_1)\n                throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");\n        }\n        \n        if (isTiled(VAR_0->_headers[VAR_5].type()))\n            VAR_0->_headers[VAR_5].sanityCheck(true, VAR_1);\n        else\n            VAR_0->_headers[VAR_5].sanityCheck(false, VAR_1);\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_8 */\n    /* COMMENT_0 */\n\n    if (VAR_1)\n    {\n        set<string> VAR_8;\n        for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n        {\n        \n            if (VAR_8.find(VAR_0->_headers[VAR_5].name()) != VAR_8.end())\n            {\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + VAR_0->_headers[VAR_5].name() +\n                                   \" is not a unique name.\");\n            }\n            VAR_8.insert(VAR_0->_headers[VAR_5].name());\n        }\n    }\n    \n    /* COMMENT_0 */\n    /* COMMENT_9 */\n    /* COMMENT_0 */\n\n    if (VAR_1 && VAR_9)\n    {\n        for (size_t VAR_5 = 1; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n        {\n            vector <string> VAR_10;\n            if (VAR_0->checkSharedAttributesValues (VAR_0->_headers[0], VAR_0->_headers[VAR_5], VAR_10))\n            {\n                string VAR_11;\n                for (size_t VAR_12=0; VAR_12<VAR_10.size(); VAR_12++)\n                    VAR_11 += \" \" + VAR_10[VAR_12];\n                throw IEX_NAMESPACE::InputExc (\"Header name \" + VAR_0->_headers[VAR_5].name() +\n                                     \" has non-conforming shared attributes: \"+\n                                     VAR_11);\n            }\n        }\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_10 */\n    /* COMMENT_0 */\n        \n    for (size_t VAR_5 = 0; VAR_5 < VAR_0->_headers.size(); VAR_5++)\n        VAR_0->parts.push_back(\n                new InputPartData(VAR_0, VAR_0->_headers[VAR_5], VAR_5, VAR_0->numThreads, VAR_0->version));\n\n    VAR_0->readChunkOffsetTables(VAR_0->reconstructChunkOffsetTable);\n}",
  "func_graph_path": "AcademySoftwareFoundation/openexr/25e9515b06a6bc293d871622b8cafaee7af84e0f/ImfMultiPartInputFile.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,11 @@\n     //\n     // Perform usual check on headers.\n     //\n+\n+    if ( _data->_headers.size() == 0)\n+    {\n+        throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\");\n+    }\n \n     for (size_t i = 0; i < _data->_headers.size(); i++)\n     {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if ( _data->_headers.size() == 0)",
      "    {",
      "        throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\");",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/840",
  "description": {
    "pr_info": {
      "title": "add sanity check for reading multipart files with no parts",
      "number": 840
    },
    "comment": [
      "Add test to protect against reading files with no parts/headers.\r\n\r\nThere is a check to prevent files with no parts being written, and the Technical Introduction declares that files must have at least one part.\r\n\r\nAddresses https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25740 and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25743\r\n\r\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}