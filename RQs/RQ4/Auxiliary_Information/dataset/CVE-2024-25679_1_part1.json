{
  "cve_id": "CVE-2024-25679",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "p-quic/pquic",
  "commit_msg": "discard the keys after handshake is done; use the correct original_destination_connection_id; discard the re-transmission packets correctly; limit the active_connection_id",
  "commit_hash": "2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "git_url": "https://github.com/p-quic/pquic/commit/2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "file_path": "picoquic/packet.c",
  "func_name": "picoquic_parse_header_and_decrypt",
  "func_before": "int picoquic_parse_header_and_decrypt(\n    picoquic_quic_t* quic,\n    uint8_t* bytes,\n    uint32_t length,\n    uint32_t packet_length,\n    struct sockaddr* addr_from,\n    uint64_t current_time,\n    picoquic_packet_header* ph,\n    picoquic_cnx_t** pcnx,\n    uint32_t * consumed,\n    int * new_context_created)\n{\n    /* Parse the clear text header. Ret == 0 means an incorrect packet that could not be parsed */\n    int already_received = 0;\n    size_t decoded_length = 0;\n    int ret = picoquic_parse_packet_header(quic, bytes, length, addr_from, ph, pcnx, 1);\n\n    if (ret == 0) {\n        /* TODO: clarify length, payload length, packet length -- special case of initial packet */\n        length = ph->offset + ph->payload_length;\n        *consumed = length;\n\n\n        if (ph->ptype == picoquic_packet_initial) {\n            if ((*pcnx == NULL || !(*pcnx)->client_mode)) {\n                /* Create a connection context if the CI is acceptable */\n                if (packet_length < PICOQUIC_ENFORCED_INITIAL_MTU) {\n                    /* Unexpected packet. Reject, drop and log. */\n                    ret = PICOQUIC_ERROR_INITIAL_TOO_SHORT;\n                }\n            }\n            if (ret == 0 && *pcnx == NULL) {\n                /* if listening is OK, listen */\n                *pcnx = picoquic_create_cnx(quic, ph->dest_cnx_id, ph->srce_cnx_id, addr_from, current_time, ph->vn,\n                                            NULL, NULL, 0);\n                *new_context_created = (*pcnx == NULL) ? 0 : 1;\n            }\n        }\n\n        /* TODO: replace switch by reference to epoch */\n\n        if (*pcnx != NULL) {\n            picoquic_path_t* path_from = picoquic_get_incoming_path(*pcnx, ph);\n            switch (ph->ptype) {\n            case picoquic_packet_version_negotiation:\n                /* Packet is not encrypted */\n                break;\n            case picoquic_packet_initial:\n                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,\n                    (*pcnx)->crypto_context[0].hp_dec,\n                    (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);\n                length = ph->offset + ph->payload_length;\n                *consumed = length;\n                break;\n            case picoquic_packet_retry:\n                /* packet is not encrypted, no sequence number. */\n                ph->pn = 0;\n                ph->pn64 = 0;\n                ph->pnmask = 0;\n                decoded_length = ph->payload_length;\n                break;\n            case picoquic_packet_handshake:\n                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, length, ph,\n                    (*pcnx)->crypto_context[2].hp_dec,\n                    (*pcnx)->crypto_context[2].aead_decrypt, &already_received, path_from);\n                break;\n            case picoquic_packet_0rtt_protected:\n                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, length, ph,\n                    (*pcnx)->crypto_context[1].hp_dec,\n                    (*pcnx)->crypto_context[1].aead_decrypt, &already_received, path_from);\n                break;\n            case picoquic_packet_1rtt_protected_phi0:\n            case picoquic_packet_1rtt_protected_phi1:\n                /* TODO : roll key based on PHI */\n                /* AEAD Decrypt, in place */\n                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, length, ph,\n                    (*pcnx)->crypto_context[3].hp_dec,\n                    (*pcnx)->crypto_context[3].aead_decrypt, &already_received, path_from);\n                break;\n            default:\n                /* Packet type error. Log and ignore */\n                ret = PICOQUIC_ERROR_DETECTED;\n                break;\n            }\n\n            /* TODO: consider the error \"too soon\" */\n            if (decoded_length > (length - ph->offset)) {\n                ret = PICOQUIC_ERROR_AEAD_CHECK;\n                if (*new_context_created) {\n                    picoquic_delete_cnx(*pcnx);\n                    *pcnx = NULL;\n                    *new_context_created = 0;\n                }\n            }\n            else if (already_received != 0) {\n                ret = PICOQUIC_ERROR_DUPLICATE;\n            }\n            else {\n                ph->payload_length = (uint16_t)decoded_length;\n            }\n        }\n        else if (ph->ptype == picoquic_packet_1rtt_protected_phi0 ||\n            ph->ptype == picoquic_packet_1rtt_protected_phi1)\n        {\n            /* This may be a stateles reset */\n            *pcnx = picoquic_cnx_by_net(quic, addr_from);\n\n            if (*pcnx != NULL && length >= PICOQUIC_RESET_PACKET_MIN_SIZE &&\n                memcmp(bytes + length - PICOQUIC_RESET_SECRET_SIZE,\n                (*pcnx)->path[0]->reset_secret, PICOQUIC_RESET_SECRET_SIZE) == 0) {\n                ret = PICOQUIC_ERROR_STATELESS_RESET;\n            }\n            else {\n                *pcnx = NULL;\n            }\n        }\n    }\n\n    return ret;\n}",
  "abstract_func_before": "int picoquic_parse_header_and_decrypt(\n    picoquic_quic_t* VAR_0,\n    uint8_t* VAR_1,\n    uint32_t VAR_2,\n    uint32_t VAR_3,\n    struct sockaddr* VAR_4,\n    uint64_t VAR_5,\n    picoquic_packet_header* VAR_6,\n    picoquic_cnx_t** VAR_7,\n    uint32_t * VAR_8,\n    int * VAR_9)\n{\n    /* COMMENT_0 */\n    int VAR_10 = 0;\n    size_t VAR_11 = 0;\n    int VAR_12 = picoquic_parse_packet_header(VAR_0, VAR_1, VAR_2, VAR_4, VAR_6, VAR_7, 1);\n\n    if (VAR_12 == 0) {\n        /* COMMENT_1 */\n        VAR_2 = VAR_6->offset + VAR_6->payload_length;\n        *VAR_8 = VAR_2;\n\n\n        if (VAR_6->ptype == VAR_13) {\n            if ((*VAR_7 == NULL || !(*VAR_7)->client_mode)) {\n                /* COMMENT_2 */\n                if (VAR_3 < VAR_14) {\n                    /* COMMENT_3 */\n                    VAR_12 = VAR_15;\n                }\n            }\n            if (VAR_12 == 0 && *VAR_7 == NULL) {\n                /* COMMENT_4 */\n                *VAR_7 = picoquic_create_cnx(VAR_0, VAR_6->dest_cnx_id, VAR_6->srce_cnx_id, VAR_4, VAR_5, VAR_6->vn,\n                                            NULL, NULL, 0);\n                *VAR_9 = (*VAR_7 == NULL) ? 0 : 1;\n            }\n        }\n\n        /* COMMENT_5 */\n\n        if (*VAR_7 != NULL) {\n            picoquic_path_t* VAR_16 = picoquic_get_incoming_path(*VAR_7, VAR_6);\n            switch (VAR_6->ptype) {\n            case VAR_17:\n                /* COMMENT_6 */\n                break;\n            case VAR_13:\n                VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_3, VAR_6,\n                    (*VAR_7)->crypto_context[0].hp_dec,\n                    (*VAR_7)->crypto_context[0].aead_decrypt, &VAR_10, VAR_16);\n                VAR_2 = VAR_6->offset + VAR_6->payload_length;\n                *VAR_8 = VAR_2;\n                break;\n            case VAR_18:\n                /* COMMENT_7 */\n                VAR_6->pn = 0;\n                VAR_6->pn64 = 0;\n                VAR_6->pnmask = 0;\n                VAR_11 = VAR_6->payload_length;\n                break;\n            case VAR_19:\n                VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_2, VAR_6,\n                    (*VAR_7)->crypto_context[2].hp_dec,\n                    (*VAR_7)->crypto_context[2].aead_decrypt, &VAR_10, VAR_16);\n                break;\n            case VAR_20:\n                VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_2, VAR_6,\n                    (*VAR_7)->crypto_context[1].hp_dec,\n                    (*VAR_7)->crypto_context[1].aead_decrypt, &VAR_10, VAR_16);\n                break;\n            case VAR_21:\n            case VAR_22:\n                /* COMMENT_8 */\n                /* COMMENT_9 */\n                VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_2, VAR_6,\n                    (*VAR_7)->crypto_context[3].hp_dec,\n                    (*VAR_7)->crypto_context[3].aead_decrypt, &VAR_10, VAR_16);\n                break;\n            default:\n                /* COMMENT_10 */\n                VAR_12 = VAR_23;\n                break;\n            }\n\n            /* COMMENT_11 */\n            if (VAR_11 > (VAR_2 - VAR_6->offset)) {\n                VAR_12 = VAR_24;\n                if (*VAR_9) {\n                    picoquic_delete_cnx(*VAR_7);\n                    *VAR_7 = NULL;\n                    *VAR_9 = 0;\n                }\n            }\n            else if (VAR_10 != 0) {\n                VAR_12 = VAR_25;\n            }\n            else {\n                VAR_6->payload_length = (uint16_t)VAR_11;\n            }\n        }\n        else if (VAR_6->ptype == VAR_21 ||\n            VAR_6->ptype == VAR_22)\n        {\n            /* COMMENT_12 */\n            *VAR_7 = picoquic_cnx_by_net(VAR_0, VAR_4);\n\n            if (*VAR_7 != NULL && VAR_2 >= VAR_26 &&\n                memcmp(VAR_1 + VAR_2 - VAR_27,\n                (*VAR_7)->path[0]->reset_secret, VAR_27) == 0) {\n                VAR_12 = VAR_28;\n            }\n            else {\n                *VAR_7 = NULL;\n            }\n        }\n    }\n\n    return VAR_12;\n}",
  "func_graph_path_before": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/packet.c/vul/before/0.json",
  "func": "int picoquic_parse_header_and_decrypt(\n    picoquic_quic_t* quic,\n    uint8_t* bytes,\n    uint32_t length,\n    uint32_t packet_length,\n    struct sockaddr* addr_from,\n    uint64_t current_time,\n    picoquic_packet_header* ph,\n    picoquic_cnx_t** pcnx,\n    uint32_t * consumed,\n    int * new_context_created)\n{\n    /* Parse the clear text header. Ret == 0 means an incorrect packet that could not be parsed */\n    int already_received = 0;\n    size_t decoded_length = 0;\n    int ret = picoquic_parse_packet_header(quic, bytes, length, addr_from, ph, pcnx, 1);\n\n    if (ret == 0) {\n        /* TODO: clarify length, payload length, packet length -- special case of initial packet */\n        length = ph->offset + ph->payload_length;\n        *consumed = length;\n\n\n        if (ph->ptype == picoquic_packet_initial) {\n            if ((*pcnx == NULL || !(*pcnx)->client_mode)) {\n                /* Create a connection context if the CI is acceptable */\n                if (packet_length < PICOQUIC_ENFORCED_INITIAL_MTU) {\n                    /* Unexpected packet. Reject, drop and log. */\n                    ret = PICOQUIC_ERROR_INITIAL_TOO_SHORT;\n                }\n            }\n            if (ret == 0 && *pcnx == NULL) {\n                /* if listening is OK, listen */\n                *pcnx = picoquic_create_cnx(quic, ph->dest_cnx_id, ph->srce_cnx_id, addr_from, current_time, ph->vn,\n                                            NULL, NULL, 0);\n                *new_context_created = (*pcnx == NULL) ? 0 : 1;\n            }\n        }\n\n        /* TODO: replace switch by reference to epoch */\n\n        if (*pcnx != NULL) {\n            picoquic_path_t* path_from = picoquic_get_incoming_path(*pcnx, ph);\n            switch (ph->ptype) {\n            case picoquic_packet_version_negotiation:\n                /* Packet is not encrypted */\n                break;\n            case picoquic_packet_initial:\n                if((*pcnx)->crypto_context[0].aead_decrypt != NULL){\n                    decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,\n                        (*pcnx)->crypto_context[0].hp_dec,\n                        (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);\n                    length = ph->offset + ph->payload_length;\n                    *consumed = length;\n                }\n                break;\n            case picoquic_packet_retry:\n                /* packet is not encrypted, no sequence number. */\n                ph->pn = 0;\n                ph->pn64 = 0;\n                ph->pnmask = 0;\n                decoded_length = ph->payload_length;\n                break;\n            case picoquic_packet_handshake:\n                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, length, ph,\n                    (*pcnx)->crypto_context[2].hp_dec,\n                    (*pcnx)->crypto_context[2].aead_decrypt, &already_received, path_from);\n                break;\n            case picoquic_packet_0rtt_protected:\n                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, length, ph,\n                    (*pcnx)->crypto_context[1].hp_dec,\n                    (*pcnx)->crypto_context[1].aead_decrypt, &already_received, path_from);\n                break;\n            case picoquic_packet_1rtt_protected_phi0:\n            case picoquic_packet_1rtt_protected_phi1:\n                /* TODO : roll key based on PHI */\n                /* AEAD Decrypt, in place */\n                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, length, ph,\n                    (*pcnx)->crypto_context[3].hp_dec,\n                    (*pcnx)->crypto_context[3].aead_decrypt, &already_received, path_from);\n                break;\n            default:\n                /* Packet type error. Log and ignore */\n                ret = PICOQUIC_ERROR_DETECTED;\n                break;\n            }\n\n            /* TODO: consider the error \"too soon\" */\n            if (decoded_length > (length - ph->offset)) {\n                ret = PICOQUIC_ERROR_AEAD_CHECK;\n                if (*new_context_created) {\n                    picoquic_delete_cnx(*pcnx);\n                    *pcnx = NULL;\n                    *new_context_created = 0;\n                }\n            }\n            else if (already_received != 0) {\n                ret = PICOQUIC_ERROR_DUPLICATE;\n            }\n            else {\n                ph->payload_length = (uint16_t)decoded_length;\n            }\n        }\n        else if (ph->ptype == picoquic_packet_1rtt_protected_phi0 ||\n            ph->ptype == picoquic_packet_1rtt_protected_phi1)\n        {\n            /* This may be a stateles reset */\n            *pcnx = picoquic_cnx_by_net(quic, addr_from);\n\n            if (*pcnx != NULL && length >= PICOQUIC_RESET_PACKET_MIN_SIZE &&\n                memcmp(bytes + length - PICOQUIC_RESET_SECRET_SIZE,\n                (*pcnx)->path[0]->reset_secret, PICOQUIC_RESET_SECRET_SIZE) == 0) {\n                ret = PICOQUIC_ERROR_STATELESS_RESET;\n            }\n            else {\n                *pcnx = NULL;\n            }\n        }\n    }\n\n    return ret;\n}",
  "abstract_func": "int picoquic_parse_header_and_decrypt(\n    picoquic_quic_t* VAR_0,\n    uint8_t* VAR_1,\n    uint32_t VAR_2,\n    uint32_t VAR_3,\n    struct sockaddr* VAR_4,\n    uint64_t VAR_5,\n    picoquic_packet_header* VAR_6,\n    picoquic_cnx_t** VAR_7,\n    uint32_t * VAR_8,\n    int * VAR_9)\n{\n    /* COMMENT_0 */\n    int VAR_10 = 0;\n    size_t VAR_11 = 0;\n    int VAR_12 = picoquic_parse_packet_header(VAR_0, VAR_1, VAR_2, VAR_4, VAR_6, VAR_7, 1);\n\n    if (VAR_12 == 0) {\n        /* COMMENT_1 */\n        VAR_2 = VAR_6->offset + VAR_6->payload_length;\n        *VAR_8 = VAR_2;\n\n\n        if (VAR_6->ptype == VAR_13) {\n            if ((*VAR_7 == NULL || !(*VAR_7)->client_mode)) {\n                /* COMMENT_2 */\n                if (VAR_3 < VAR_14) {\n                    /* COMMENT_3 */\n                    VAR_12 = VAR_15;\n                }\n            }\n            if (VAR_12 == 0 && *VAR_7 == NULL) {\n                /* COMMENT_4 */\n                *VAR_7 = picoquic_create_cnx(VAR_0, VAR_6->dest_cnx_id, VAR_6->srce_cnx_id, VAR_4, VAR_5, VAR_6->vn,\n                                            NULL, NULL, 0);\n                *VAR_9 = (*VAR_7 == NULL) ? 0 : 1;\n            }\n        }\n\n        /* COMMENT_5 */\n\n        if (*VAR_7 != NULL) {\n            picoquic_path_t* VAR_16 = picoquic_get_incoming_path(*VAR_7, VAR_6);\n            switch (VAR_6->ptype) {\n            case VAR_17:\n                /* COMMENT_6 */\n                break;\n            case VAR_13:\n                if((*VAR_7)->crypto_context[0].aead_decrypt != NULL){\n                    VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_3, VAR_6,\n                        (*VAR_7)->crypto_context[0].hp_dec,\n                        (*VAR_7)->crypto_context[0].aead_decrypt, &VAR_10, VAR_16);\n                    VAR_2 = VAR_6->offset + VAR_6->payload_length;\n                    *VAR_8 = VAR_2;\n                }\n                break;\n            case VAR_18:\n                /* COMMENT_7 */\n                VAR_6->pn = 0;\n                VAR_6->pn64 = 0;\n                VAR_6->pnmask = 0;\n                VAR_11 = VAR_6->payload_length;\n                break;\n            case VAR_19:\n                VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_2, VAR_6,\n                    (*VAR_7)->crypto_context[2].hp_dec,\n                    (*VAR_7)->crypto_context[2].aead_decrypt, &VAR_10, VAR_16);\n                break;\n            case VAR_20:\n                VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_2, VAR_6,\n                    (*VAR_7)->crypto_context[1].hp_dec,\n                    (*VAR_7)->crypto_context[1].aead_decrypt, &VAR_10, VAR_16);\n                break;\n            case VAR_21:\n            case VAR_22:\n                /* COMMENT_8 */\n                /* COMMENT_9 */\n                VAR_11 = picoquic_decrypt_packet(*VAR_7, VAR_1, VAR_2, VAR_6,\n                    (*VAR_7)->crypto_context[3].hp_dec,\n                    (*VAR_7)->crypto_context[3].aead_decrypt, &VAR_10, VAR_16);\n                break;\n            default:\n                /* COMMENT_10 */\n                VAR_12 = VAR_23;\n                break;\n            }\n\n            /* COMMENT_11 */\n            if (VAR_11 > (VAR_2 - VAR_6->offset)) {\n                VAR_12 = VAR_24;\n                if (*VAR_9) {\n                    picoquic_delete_cnx(*VAR_7);\n                    *VAR_7 = NULL;\n                    *VAR_9 = 0;\n                }\n            }\n            else if (VAR_10 != 0) {\n                VAR_12 = VAR_25;\n            }\n            else {\n                VAR_6->payload_length = (uint16_t)VAR_11;\n            }\n        }\n        else if (VAR_6->ptype == VAR_21 ||\n            VAR_6->ptype == VAR_22)\n        {\n            /* COMMENT_12 */\n            *VAR_7 = picoquic_cnx_by_net(VAR_0, VAR_4);\n\n            if (*VAR_7 != NULL && VAR_2 >= VAR_26 &&\n                memcmp(VAR_1 + VAR_2 - VAR_27,\n                (*VAR_7)->path[0]->reset_secret, VAR_27) == 0) {\n                VAR_12 = VAR_28;\n            }\n            else {\n                *VAR_7 = NULL;\n            }\n        }\n    }\n\n    return VAR_12;\n}",
  "func_graph_path": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/packet.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -46,11 +46,13 @@\n                 /* Packet is not encrypted */\n                 break;\n             case picoquic_packet_initial:\n-                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,\n-                    (*pcnx)->crypto_context[0].hp_dec,\n-                    (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);\n-                length = ph->offset + ph->payload_length;\n-                *consumed = length;\n+                if((*pcnx)->crypto_context[0].aead_decrypt != NULL){\n+                    decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,\n+                        (*pcnx)->crypto_context[0].hp_dec,\n+                        (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);\n+                    length = ph->offset + ph->payload_length;\n+                    *consumed = length;\n+                }\n                 break;\n             case picoquic_packet_retry:\n                 /* packet is not encrypted, no sequence number. */",
  "diff_line_info": {
    "deleted_lines": [
      "                decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,",
      "                    (*pcnx)->crypto_context[0].hp_dec,",
      "                    (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);",
      "                length = ph->offset + ph->payload_length;",
      "                *consumed = length;"
    ],
    "added_lines": [
      "                if((*pcnx)->crypto_context[0].aead_decrypt != NULL){",
      "                    decoded_length = picoquic_decrypt_packet(*pcnx, bytes, packet_length, ph,",
      "                        (*pcnx)->crypto_context[0].hp_dec,",
      "                        (*pcnx)->crypto_context[0].aead_decrypt, &already_received, path_from);",
      "                    length = ph->offset + ph->payload_length;",
      "                    *consumed = length;",
      "                }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/p-quic/pquic/pull/39",
  "description": {
    "pr_info": {
      "title": "Minor Fix",
      "number": 39
    },
    "comment": [
      "Hi, I try to fix the bugs in #34 #35 #36 and #38.\r\n\r\nCan you validate these fixes please.\r\n",
      "The code looks good. Have you done any test to ensure it fixes these issues ?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}