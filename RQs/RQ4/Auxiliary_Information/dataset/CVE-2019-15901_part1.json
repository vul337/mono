{
  "cve_id": "CVE-2019-15901",
  "cwe_ids": [
    "CWE-269"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "slicer69/doas",
  "commit_msg": "fix the setusercontext(3) workaround\n\nSeeing this being used on even more system like Illumos with this ugly\nand security critical bug open makes me cringe every time I check if it\nwas finally fixed.\n\nI reported it directly to the maintainer in 2017. I reported it to\npkgsrc-security@netbsd.org without a response.",
  "commit_hash": "6cf0236184ff6304bf5e267ccf7ef02874069697",
  "git_url": "https://github.com/slicer69/doas/commit/6cf0236184ff6304bf5e267ccf7ef02874069697",
  "file_path": "doas.c",
  "func_name": "main",
  "func_before": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"a:C:nsu:\")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \"a:C:Lnsu:\")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \"pw_name too long\");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* #endif */\n\n\t\tpam_err = pam_start(\"doas\", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(LOG_ERR, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \"failed auth for %s\", myname);\n                                errx(EXIT_FAILURE, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \"failed auth for %s\", myname);\n                        errx(EXIT_FAILURE, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#endif\n        /*\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n#ifndef HAVE_LOGIN_CAP_H\n        /* If we effectively are root, set the UID to actually be root to avoid\n           permission errors. */\n        if (target != 0)\n           setuid(target);\n        if ( geteuid() == ROOT_UID )\n           setuid(ROOT_UID);\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
  "abstract_func_before": "int\nmain(int VAR_0, char **VAR_1)\n{\n\tconst char *VAR_2 = VAR_3;\n\tconst char *VAR_4 = NULL;\n\tchar *VAR_5[] = { NULL, NULL };\n\tchar *VAR_6;\n\tconst char *VAR_7;\n\tchar VAR_8[VAR_9];\n\tchar VAR_10[VAR_11 + 1];\n\tstruct passwd *VAR_12, *VAR_13;\n\tstruct rule *rule;\n\tuid_t VAR_14;\n\tuid_t VAR_15 = 0;\n\tgid_t VAR_16[VAR_17 + 1];\n\tint VAR_18;\n\tint VAR_19, VAR_20;\n\tint VAR_21 = 0;\n\tint VAR_22 = 0;\n\tchar VAR_23[VAR_24];\n\tconst char *VAR_25;\n\tchar *VAR_26 = NULL;\n\tchar **VAR_27;\n\n\t#ifndef VAR_28\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef VAR_28\n\tclosefrom(VAR_29 + 1);\n\t#endif\n\n\tVAR_14 = getuid();\n\n\twhile ((VAR_20 = getopt(VAR_0, VAR_1, \"a:C:nsu:\")) != -1) {\n/* COMMENT_0 */\n\t\tswitch (VAR_20) {\n\t\tcase 'a':\n\t\t\tVAR_26 = VAR_30;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tVAR_4 = VAR_30;\n\t\t\tbreak;\n/* COMMENT_1 */\n                                \n               \n                             \n                 \n  \n\t\tcase 'u':\n\t\t\tif (parseuid(VAR_30, &VAR_15) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tVAR_22 = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tVAR_21 = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\tVAR_1 += VAR_31;\n\tVAR_0 -= VAR_31;\n\n\tif (VAR_4) {\n\t\tif (VAR_21)\n\t\t\tusage();\n\t} else if ((!VAR_21 && !VAR_0) || (VAR_21 && VAR_0))\n\t\tusage();\n\n\tVAR_12 = getpwuid(VAR_14);\n\tif (! VAR_12)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(VAR_10, VAR_12->pw_name, sizeof(VAR_10)) >= sizeof(VAR_10))\n\t\terrx(1, \"pw_name too long\");\n\n\tVAR_18 = getgroups(VAR_17, VAR_16);\n\tif (VAR_18 == -1)\n\t\terr(1, \"can't get groups\");\n\tVAR_16[VAR_18++] = getgid();\n\n\tif (VAR_21) {\n\t\tVAR_6 = getenv(\"SHELL\");\n\t\tif (VAR_6 == NULL || *VAR_6 == '\\0') {\n\t\t\tVAR_5[0] = strdup(VAR_12->pw_shell);\n\t\t\tif (VAR_5[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tVAR_5[0] = VAR_6;\n\t\tVAR_1 = VAR_5;\n\t\tVAR_0 = 1;\n\t}\n\n\tif (VAR_4) {\n\t\tcheckconfig(VAR_4, VAR_0, VAR_1, VAR_14, VAR_16, VAR_18,\n\t\t    VAR_15);\n\t\texit(1);\t/* COMMENT_7 */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(VAR_32, 1);\n\n\t/* COMMENT_8 */\n\t(void)strlcpy(VAR_8, VAR_1[0], sizeof(VAR_8));\n\tfor (VAR_19 = 1; VAR_19 < VAR_0; VAR_19++) {\n\t\tif (strlcat(VAR_8, \" \", sizeof(VAR_8)) >= sizeof(VAR_8))\n\t\t\tbreak;\n\t\tif (strlcat(VAR_8, VAR_1[VAR_19], sizeof(VAR_8)) >= sizeof(VAR_8))\n\t\t\tbreak;\n\t}\n\n\tVAR_7 = VAR_1[0];\n\tif (!permit(VAR_14, VAR_16, VAR_18, &rule, VAR_15, VAR_7,\n\t    (const char **)VAR_1 + 1)) {\n\t\tsyslog(VAR_33 | VAR_34,\n\t\t    \"failed command for %s: %s\", VAR_10, VAR_8);\n\t\terrc(1, VAR_35, NULL);\n\t}\n\n\tif (!(rule->options & VAR_36)) {\n\t\tif (VAR_22)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(VAR_37) \n\t\tauthuser(VAR_10, VAR_26, rule->options & VAR_38);\n#elif defined(VAR_39)\n#define PAM_END(VAR_40) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *VAR_41 = NULL;\n\t\tint VAR_42;\n\n/* COMMENT_9 */\n\t\tint VAR_43;\n\n\t\t/* COMMENT_10 */\n                                                    \n                                                      \n                                                       \n                                                 \n                                                     \n                                                        \n                                                       \n                                                     \n                             \n\t\tVAR_43 = dup(VAR_44);\n\t\tif (VAR_43 == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(VAR_44);\n/* COMMENT_20 */\n\t\t/* COMMENT_21 */\n\t\tint VAR_45 = dup(1);\n\t\tif (VAR_45 == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* COMMENT_22 */\n\n\t\tVAR_42 = pam_start(\"doas\", VAR_10, &VAR_46, &VAR_41);\n\t\tif (VAR_42 != VAR_47) {\n\t\t\tif (VAR_41 != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(VAR_48, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(VAR_41, VAR_42));\n\t\t\terrx(VAR_49, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (VAR_42 = pam_authenticate(VAR_41, VAR_50)) {\n\t\tcase VAR_47:\n\t\t\tswitch (VAR_42 = pam_acct_mgmt(VAR_41, VAR_50)) {\n\t\t\tcase VAR_47:\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_51:\n\t\t\t\tVAR_42 = pam_chauthtok(VAR_41,\n\t\t\t\t    VAR_50|VAR_52);\n\t\t\t\tif (VAR_42 != VAR_47)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_53:\n\t\t\tcase VAR_54:\n\t\t\tcase VAR_55:\n\t\t\t\tsyslog(VAR_33 | VAR_34,\n\t\t\t\t    \"failed auth for %s\", VAR_10);\n                                errx(VAR_49, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_53:\n\t\tcase VAR_54:\n\t\tcase VAR_55:\n\t\t\tsyslog(VAR_33 | VAR_34,\n\t\t\t    \"failed auth for %s\", VAR_10);\n                        errx(VAR_49, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(VAR_41, VAR_42);\n\n#ifndef VAR_28\n\t\t/* COMMENT_23 */\n\t\tif (dup2(VAR_43, VAR_44) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(VAR_43);\n#else \n\t\t/* COMMENT_24 */\n\t\tclose(1);\n\t\tif (dup2(VAR_45, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /* COMMENT_25 */\n                                                     \n                   \n          \n\tVAR_13 = getpwuid(VAR_15);\n\tif (! VAR_13)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(VAR_56)\n\tif (setusercontext(NULL, VAR_13, VAR_15, VAR_57 |\n\t    VAR_58 | VAR_59 | VAR_60 |\n\t    VAR_61) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#endif\n        /* COMMENT_29 */\n                                            \n                   \n          \n\n\tif (getcwd(VAR_23, sizeof(VAR_23)) == NULL)\n\t\tVAR_25 = \"(failed)\";\n\telse\n\t\tVAR_25 = VAR_23;\n\n\t/* COMMENT_33 */\n                                             \n                   \n          \n#ifndef VAR_56\n        /* COMMENT_37 */\n                                \n        if (VAR_15 != 0)\n           setuid(VAR_15);\n        if ( geteuid() == VAR_62 )\n           setuid(VAR_62);\n#endif\n\n\tsyslog(VAR_33 | VAR_63, \"%s ran command %s as %s from %s\",\n\t    VAR_10, VAR_8, VAR_13->pw_name, VAR_25);\n\n\tVAR_27 = prepenv(rule, VAR_12, VAR_13);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", VAR_2, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", VAR_2);\n\t}\n\texecvpe(VAR_7, VAR_1, VAR_27);\n\tif (VAR_64 == VAR_65)\n\t\terrx(1, \"%s: command not found\", VAR_7);\n\terr(1, \"%s\", VAR_7);\n}",
  "func_graph_path_before": "slicer69/doas/6cf0236184ff6304bf5e267ccf7ef02874069697/doas.c/vul/before/0.json",
  "func": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"a:C:nsu:\")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \"a:C:Lnsu:\")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \"pw_name too long\");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* #endif */\n\n\t\tpam_err = pam_start(\"doas\", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(LOG_ERR, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \"failed auth for %s\", myname);\n                                errx(EXIT_FAILURE, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \"failed auth for %s\", myname);\n                        errx(EXIT_FAILURE, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setresgid\");\n\t#else\n\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setregid\");\n\t#endif\n\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n\t\terr(1, \"initgroups\");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, \"setresuid\");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, \"setreuid\");\n\t#endif\n#endif\n        /*\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
  "abstract_func": "int\nmain(int VAR_0, char **VAR_1)\n{\n\tconst char *VAR_2 = VAR_3;\n\tconst char *VAR_4 = NULL;\n\tchar *VAR_5[] = { NULL, NULL };\n\tchar *VAR_6;\n\tconst char *VAR_7;\n\tchar VAR_8[VAR_9];\n\tchar VAR_10[VAR_11 + 1];\n\tstruct passwd *VAR_12, *VAR_13;\n\tstruct rule *rule;\n\tuid_t VAR_14;\n\tuid_t VAR_15 = 0;\n\tgid_t VAR_16[VAR_17 + 1];\n\tint VAR_18;\n\tint VAR_19, VAR_20;\n\tint VAR_21 = 0;\n\tint VAR_22 = 0;\n\tchar VAR_23[VAR_24];\n\tconst char *VAR_25;\n\tchar *VAR_26 = NULL;\n\tchar **VAR_27;\n\n\t#ifndef VAR_28\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef VAR_28\n\tclosefrom(VAR_29 + 1);\n\t#endif\n\n\tVAR_14 = getuid();\n\n\twhile ((VAR_20 = getopt(VAR_0, VAR_1, \"a:C:nsu:\")) != -1) {\n/* COMMENT_0 */\n\t\tswitch (VAR_20) {\n\t\tcase 'a':\n\t\t\tVAR_26 = VAR_30;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tVAR_4 = VAR_30;\n\t\t\tbreak;\n/* COMMENT_1 */\n                                \n               \n                             \n                 \n  \n\t\tcase 'u':\n\t\t\tif (parseuid(VAR_30, &VAR_15) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tVAR_22 = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tVAR_21 = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\tVAR_1 += VAR_31;\n\tVAR_0 -= VAR_31;\n\n\tif (VAR_4) {\n\t\tif (VAR_21)\n\t\t\tusage();\n\t} else if ((!VAR_21 && !VAR_0) || (VAR_21 && VAR_0))\n\t\tusage();\n\n\tVAR_12 = getpwuid(VAR_14);\n\tif (! VAR_12)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(VAR_10, VAR_12->pw_name, sizeof(VAR_10)) >= sizeof(VAR_10))\n\t\terrx(1, \"pw_name too long\");\n\n\tVAR_18 = getgroups(VAR_17, VAR_16);\n\tif (VAR_18 == -1)\n\t\terr(1, \"can't get groups\");\n\tVAR_16[VAR_18++] = getgid();\n\n\tif (VAR_21) {\n\t\tVAR_6 = getenv(\"SHELL\");\n\t\tif (VAR_6 == NULL || *VAR_6 == '\\0') {\n\t\t\tVAR_5[0] = strdup(VAR_12->pw_shell);\n\t\t\tif (VAR_5[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tVAR_5[0] = VAR_6;\n\t\tVAR_1 = VAR_5;\n\t\tVAR_0 = 1;\n\t}\n\n\tif (VAR_4) {\n\t\tcheckconfig(VAR_4, VAR_0, VAR_1, VAR_14, VAR_16, VAR_18,\n\t\t    VAR_15);\n\t\texit(1);\t/* COMMENT_7 */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(VAR_32, 1);\n\n\t/* COMMENT_8 */\n\t(void)strlcpy(VAR_8, VAR_1[0], sizeof(VAR_8));\n\tfor (VAR_19 = 1; VAR_19 < VAR_0; VAR_19++) {\n\t\tif (strlcat(VAR_8, \" \", sizeof(VAR_8)) >= sizeof(VAR_8))\n\t\t\tbreak;\n\t\tif (strlcat(VAR_8, VAR_1[VAR_19], sizeof(VAR_8)) >= sizeof(VAR_8))\n\t\t\tbreak;\n\t}\n\n\tVAR_7 = VAR_1[0];\n\tif (!permit(VAR_14, VAR_16, VAR_18, &rule, VAR_15, VAR_7,\n\t    (const char **)VAR_1 + 1)) {\n\t\tsyslog(VAR_33 | VAR_34,\n\t\t    \"failed command for %s: %s\", VAR_10, VAR_8);\n\t\terrc(1, VAR_35, NULL);\n\t}\n\n\tif (!(rule->options & VAR_36)) {\n\t\tif (VAR_22)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(VAR_37) \n\t\tauthuser(VAR_10, VAR_26, rule->options & VAR_38);\n#elif defined(VAR_39)\n#define PAM_END(VAR_40) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *VAR_41 = NULL;\n\t\tint VAR_42;\n\n/* COMMENT_9 */\n\t\tint VAR_43;\n\n\t\t/* COMMENT_10 */\n                                                    \n                                                      \n                                                       \n                                                 \n                                                     \n                                                        \n                                                       \n                                                     \n                             \n\t\tVAR_43 = dup(VAR_44);\n\t\tif (VAR_43 == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(VAR_44);\n/* COMMENT_20 */\n\t\t/* COMMENT_21 */\n\t\tint VAR_45 = dup(1);\n\t\tif (VAR_45 == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* COMMENT_22 */\n\n\t\tVAR_42 = pam_start(\"doas\", VAR_10, &VAR_46, &VAR_41);\n\t\tif (VAR_42 != VAR_47) {\n\t\t\tif (VAR_41 != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(VAR_48, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(VAR_41, VAR_42));\n\t\t\terrx(VAR_49, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (VAR_42 = pam_authenticate(VAR_41, VAR_50)) {\n\t\tcase VAR_47:\n\t\t\tswitch (VAR_42 = pam_acct_mgmt(VAR_41, VAR_50)) {\n\t\t\tcase VAR_47:\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_51:\n\t\t\t\tVAR_42 = pam_chauthtok(VAR_41,\n\t\t\t\t    VAR_50|VAR_52);\n\t\t\t\tif (VAR_42 != VAR_47)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_53:\n\t\t\tcase VAR_54:\n\t\t\tcase VAR_55:\n\t\t\t\tsyslog(VAR_33 | VAR_34,\n\t\t\t\t    \"failed auth for %s\", VAR_10);\n                                errx(VAR_49, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_53:\n\t\tcase VAR_54:\n\t\tcase VAR_55:\n\t\t\tsyslog(VAR_33 | VAR_34,\n\t\t\t    \"failed auth for %s\", VAR_10);\n                        errx(VAR_49, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(VAR_41, VAR_42);\n\n#ifndef VAR_28\n\t\t/* COMMENT_23 */\n\t\tif (dup2(VAR_43, VAR_44) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(VAR_43);\n#else \n\t\t/* COMMENT_24 */\n\t\tclose(1);\n\t\tif (dup2(VAR_45, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /* COMMENT_25 */\n                                                     \n                   \n          \n\tVAR_13 = getpwuid(VAR_15);\n\tif (! VAR_13)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(VAR_56)\n\tif (setusercontext(NULL, VAR_13, VAR_15, VAR_57 |\n\t    VAR_58 | VAR_59 | VAR_60 |\n\t    VAR_61) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\t#if defined(VAR_62) || defined(VAR_63) || defined(VAR_64)\n\tif (setresgid(VAR_13->pw_gid, VAR_13->pw_gid, VAR_13->pw_gid) == -1)\n\t\terr(1, \"setresgid\");\n\t#else\n\tif (setregid(VAR_13->pw_gid, VAR_13->pw_gid) == -1)\n\t\terr(1, \"setregid\");\n\t#endif\n\tif (initgroups(VAR_13->pw_name, VAR_13->pw_gid) == -1)\n\t\terr(1, \"initgroups\");\n\t#if defined(VAR_62) || defined(VAR_63) || defined(VAR_64)\n\tif (setresuid(VAR_15, VAR_15, VAR_15) == -1)\n\t\terr(1, \"setresuid\");\n\t#else\n\tif (setreuid(VAR_15, VAR_15) == -1)\n\t\terr(1, \"setreuid\");\n\t#endif\n#endif\n        /* COMMENT_29 */\n                                            \n                   \n          \n\n\tif (getcwd(VAR_23, sizeof(VAR_23)) == NULL)\n\t\tVAR_25 = \"(failed)\";\n\telse\n\t\tVAR_25 = VAR_23;\n\n\t/* COMMENT_33 */\n                                             \n                   \n          \n\n\tsyslog(VAR_33 | VAR_65, \"%s ran command %s as %s from %s\",\n\t    VAR_10, VAR_8, VAR_13->pw_name, VAR_25);\n\n\tVAR_27 = prepenv(rule, VAR_12, VAR_13);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", VAR_2, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", VAR_2);\n\t}\n\texecvpe(VAR_7, VAR_1, VAR_27);\n\tif (VAR_66 == VAR_67)\n\t\terrx(1, \"%s: command not found\", VAR_7);\n\terr(1, \"%s\", VAR_7);\n}",
  "func_graph_path": "slicer69/doas/6cf0236184ff6304bf5e267ccf7ef02874069697/doas.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -244,6 +244,23 @@\n \t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n \t    LOGIN_SETUSER) != 0)\n \t\terrx(1, \"failed to set user context for target\");\n+#else\n+\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n+\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n+\t\terr(1, \"setresgid\");\n+\t#else\n+\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n+\t\terr(1, \"setregid\");\n+\t#endif\n+\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n+\t\terr(1, \"initgroups\");\n+\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n+\tif (setresuid(target, target, target) == -1)\n+\t\terr(1, \"setresuid\");\n+\t#else\n+\tif (setreuid(target, target) == -1)\n+\t\terr(1, \"setreuid\");\n+\t#endif\n #endif\n         /*\n \tif (pledge(\"stdio rpath exec\", NULL) == -1)\n@@ -259,14 +276,6 @@\n         if (pledge(\"stdio exec\", NULL) == -1)\n \t\terr(1, \"pledge\");\n         */\n-#ifndef HAVE_LOGIN_CAP_H\n-        /* If we effectively are root, set the UID to actually be root to avoid\n-           permission errors. */\n-        if (target != 0)\n-           setuid(target);\n-        if ( geteuid() == ROOT_UID )\n-           setuid(ROOT_UID);\n-#endif\n \n \tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n \t    myname, cmdline, target_pw->pw_name, cwd);",
  "diff_line_info": {
    "deleted_lines": [
      "#ifndef HAVE_LOGIN_CAP_H",
      "        /* If we effectively are root, set the UID to actually be root to avoid",
      "           permission errors. */",
      "        if (target != 0)",
      "           setuid(target);",
      "        if ( geteuid() == ROOT_UID )",
      "           setuid(ROOT_UID);",
      "#endif"
    ],
    "added_lines": [
      "#else",
      "\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)",
      "\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)",
      "\t\terr(1, \"setresgid\");",
      "\t#else",
      "\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)",
      "\t\terr(1, \"setregid\");",
      "\t#endif",
      "\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)",
      "\t\terr(1, \"initgroups\");",
      "\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)",
      "\tif (setresuid(target, target, target) == -1)",
      "\t\terr(1, \"setresuid\");",
      "\t#else",
      "\tif (setreuid(target, target) == -1)",
      "\t\terr(1, \"setreuid\");",
      "\t#endif"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/slicer69/doas/pull/23",
  "description": {
    "pr_info": {
      "title": "fix the setusercontext(3) workaround",
      "number": 23
    },
    "comment": [
      "Seeing this being used on even more system like Illumos with this ugly\r\nand security critical bug open makes me cringe every time I check if it\r\nwas finally fixed.\r\n\r\nI reported it directly to the maintainer in 2017. I reported it to\r\npkgsrc-security@netbsd.org without a response.",
      "Thanks for submitting the patch. Would you care to explain what it is you are trying to fix and why you feel it is a security issue? How is this an improvement over existing behaviour?",
      "doas uses [setusercontext(3)](http://man.openbsd.org/setusercontext.3) with the `LOGIN_SETUSER` flag which does `setresuid(3)` and the `LOGIN_SETGROUP` flag which does `initgroups(3)` and `setresgid(2)`.\r\nThe codepath that is used when `HAVE_LOGIN_CAP_H` is not set, only does `setuid(2)` which only sets the uid, the `LOGIN_SETGROUP` path is completely left out.\r\n\r\nThis means your doas port does not drop the groups of the executing user.\r\n\r\n1. This is a big problem if you use doas to run a command with less privileges, which is very security critical, this is not the intended behavior as it is on openbsd, this drastically changes what doas actually does in those cases. (Last time I used a crontab entry to switch from root to a different user as example for such a use case.)\r\n1. If you run a script or program which creates files or directory user and group editable, it will use the executing users group id, which could lead to unintended user writable files. \r\n1. When you have a umask set that would make it group writable, its not as expected root:root, its root:user.\r\n\r\nThe whole point I make is that this is wrong. Both openbsd doas and sudo change the group ids and making this port differ from this behavior without documenting and warning users is very very bad.",
      "I have a point of contention with the overall view. One being that I'm not sure this qualifies as a security concern. Having the group of the calling user is arguably expected, or at least certainly useful. However, I can see why, in some cases it would also be dangerous. I'm going to commit this patch and test it. Thank you for putting it together.\r\n\r\nOn a side note, I'd like to point out that my testing shows this issue, keeping the group of the original user, appears to only affect Linux. On FreeBSD group permissions were already dropped, as they were on OpenBSD, and (I think) NetBSD. Linux was the odd one out for keeping the calling user's groups. And I think this patch is worthwhile to bring Linux into the fold so it is no longer an exception."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch addresses a known security critical bug related to setusercontext by updating how user and group IDs are set across different platforms, mitigating potential privilege escalation risks. The commit message explicitly refers to this as a security fix."
}