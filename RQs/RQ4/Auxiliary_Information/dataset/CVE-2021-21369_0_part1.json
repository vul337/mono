{
  "cve_id": "CVE-2021-21369",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "hyperledger/besu",
  "commit_msg": "Improvements to authenticated JSON-RPC permissions checking (#1144)\n\n* exit early if matching permission found; add test for *:* permission\r\n\r\nSigned-off-by: Sally MacFarlane <sally.macfarlane@consensys.net>",
  "commit_hash": "06e35a58c07a30c0fbdc0aae45a3e8b06b53c022",
  "git_url": "https://github.com/hyperledger/besu/commit/06e35a58c07a30c0fbdc0aae45a3e8b06b53c022",
  "file_path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/authentication/AuthenticationUtils.java",
  "func_name": "isPermitted",
  "func_before": "@VisibleForTesting\n  public static boolean isPermitted(\n      final Optional<AuthenticationService> authenticationService,\n      final Optional<User> optionalUser,\n      final JsonRpcMethod jsonRpcMethod) {\n\n    AtomicBoolean foundMatchingPermission = new AtomicBoolean();\n\n    if (authenticationService.isPresent()) {\n      if (optionalUser.isPresent()) {\n        User user = optionalUser.get();\n        for (String perm : jsonRpcMethod.getPermissions()) {\n          user.isAuthorized(\n              perm,\n              (authed) -> {\n                if (authed.result()) {\n                  LOG.trace(\n                      \"user {} authorized : {} via permission {}\",\n                      user,\n                      jsonRpcMethod.getName(),\n                      perm);\n                  foundMatchingPermission.set(true);\n                }\n              });\n        }\n      }\n    } else {\n      // no auth provider configured thus anything is permitted\n      foundMatchingPermission.set(true);\n    }\n\n    if (!foundMatchingPermission.get()) {\n      LOG.trace(\"user NOT authorized : {}\", jsonRpcMethod.getName());\n    }\n    return foundMatchingPermission.get();\n  }",
  "abstract_func_before": "@VisibleForTesting\n  public static boolean isPermitted(\n      final Optional<AuthenticationService> VAR_0,\n      final Optional<User> VAR_1,\n      final JsonRpcMethod VAR_2) {\n\n    AtomicBoolean VAR_3 = new AtomicBoolean();\n\n    if (VAR_0.isPresent()) {\n      if (VAR_1.isPresent()) {\n        User VAR_4 = VAR_1.get();\n        for (String VAR_5 : VAR_2.getPermissions()) {\n          VAR_4.isAuthorized(\n              VAR_5,\n              (VAR_6) -> {\n                if (VAR_6.result()) {\n                  VAR_7.trace(\n                      \"user {} authorized : {} via permission {}\",\n                      VAR_4,\n                      VAR_2.getName(),\n                      VAR_5);\n                  VAR_3.set(true);\n                }\n              });\n        }\n      }\n    } else {\n      /* COMMENT_0 */\n      VAR_3.set(true);\n    }\n\n    if (!VAR_3.get()) {\n      VAR_7.trace(\"user NOT authorized : {}\", VAR_2.getName());\n    }\n    return VAR_3.get();\n  }",
  "func_graph_path_before": "hyperledger/besu/06e35a58c07a30c0fbdc0aae45a3e8b06b53c022/AuthenticationUtils.java/vul/before/0.json",
  "func": "@VisibleForTesting\n  public static boolean isPermitted(\n      final Optional<AuthenticationService> authenticationService,\n      final Optional<User> optionalUser,\n      final JsonRpcMethod jsonRpcMethod) {\n\n    AtomicBoolean foundMatchingPermission = new AtomicBoolean();\n\n    if (authenticationService.isEmpty()) {\n      // no auth provider configured thus anything is permitted\n      return true;\n    }\n\n    if (optionalUser.isPresent()) {\n      User user = optionalUser.get();\n      for (String perm : jsonRpcMethod.getPermissions()) {\n        user.isAuthorized(\n            perm,\n            (authed) -> {\n              if (authed.result()) {\n                LOG.trace(\n                    \"user {} authorized : {} via permission {}\",\n                    user,\n                    jsonRpcMethod.getName(),\n                    perm);\n                foundMatchingPermission.set(true);\n              }\n            });\n        // exit if a matching permission was found, no need to keep checking\n        if (foundMatchingPermission.get()) {\n          return foundMatchingPermission.get();\n        }\n      }\n    }\n\n    if (!foundMatchingPermission.get()) {\n      LOG.trace(\"user NOT authorized : {}\", jsonRpcMethod.getName());\n    }\n    return foundMatchingPermission.get();\n  }",
  "abstract_func": "@VisibleForTesting\n  public static boolean isPermitted(\n      final Optional<AuthenticationService> VAR_0,\n      final Optional<User> VAR_1,\n      final JsonRpcMethod VAR_2) {\n\n    AtomicBoolean VAR_3 = new AtomicBoolean();\n\n    if (VAR_0.isEmpty()) {\n      /* COMMENT_0 */\n      return true;\n    }\n\n    if (VAR_1.isPresent()) {\n      User VAR_4 = VAR_1.get();\n      for (String VAR_5 : VAR_2.getPermissions()) {\n        VAR_4.isAuthorized(\n            VAR_5,\n            (VAR_6) -> {\n              if (VAR_6.result()) {\n                VAR_7.trace(\n                    \"user {} authorized : {} via permission {}\",\n                    VAR_4,\n                    VAR_2.getName(),\n                    VAR_5);\n                VAR_3.set(true);\n              }\n            });\n        /* COMMENT_1 */\n        if (VAR_3.get()) {\n          return VAR_3.get();\n        }\n      }\n    }\n\n    if (!VAR_3.get()) {\n      VAR_7.trace(\"user NOT authorized : {}\", VAR_2.getName());\n    }\n    return VAR_3.get();\n  }",
  "func_graph_path": "hyperledger/besu/06e35a58c07a30c0fbdc0aae45a3e8b06b53c022/AuthenticationUtils.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,27 +6,31 @@\n \n     AtomicBoolean foundMatchingPermission = new AtomicBoolean();\n \n-    if (authenticationService.isPresent()) {\n-      if (optionalUser.isPresent()) {\n-        User user = optionalUser.get();\n-        for (String perm : jsonRpcMethod.getPermissions()) {\n-          user.isAuthorized(\n-              perm,\n-              (authed) -> {\n-                if (authed.result()) {\n-                  LOG.trace(\n-                      \"user {} authorized : {} via permission {}\",\n-                      user,\n-                      jsonRpcMethod.getName(),\n-                      perm);\n-                  foundMatchingPermission.set(true);\n-                }\n-              });\n+    if (authenticationService.isEmpty()) {\n+      // no auth provider configured thus anything is permitted\n+      return true;\n+    }\n+\n+    if (optionalUser.isPresent()) {\n+      User user = optionalUser.get();\n+      for (String perm : jsonRpcMethod.getPermissions()) {\n+        user.isAuthorized(\n+            perm,\n+            (authed) -> {\n+              if (authed.result()) {\n+                LOG.trace(\n+                    \"user {} authorized : {} via permission {}\",\n+                    user,\n+                    jsonRpcMethod.getName(),\n+                    perm);\n+                foundMatchingPermission.set(true);\n+              }\n+            });\n+        // exit if a matching permission was found, no need to keep checking\n+        if (foundMatchingPermission.get()) {\n+          return foundMatchingPermission.get();\n         }\n       }\n-    } else {\n-      // no auth provider configured thus anything is permitted\n-      foundMatchingPermission.set(true);\n     }\n \n     if (!foundMatchingPermission.get()) {",
  "diff_line_info": {
    "deleted_lines": [
      "    if (authenticationService.isPresent()) {",
      "      if (optionalUser.isPresent()) {",
      "        User user = optionalUser.get();",
      "        for (String perm : jsonRpcMethod.getPermissions()) {",
      "          user.isAuthorized(",
      "              perm,",
      "              (authed) -> {",
      "                if (authed.result()) {",
      "                  LOG.trace(",
      "                      \"user {} authorized : {} via permission {}\",",
      "                      user,",
      "                      jsonRpcMethod.getName(),",
      "                      perm);",
      "                  foundMatchingPermission.set(true);",
      "                }",
      "              });",
      "    } else {",
      "      // no auth provider configured thus anything is permitted",
      "      foundMatchingPermission.set(true);"
    ],
    "added_lines": [
      "    if (authenticationService.isEmpty()) {",
      "      // no auth provider configured thus anything is permitted",
      "      return true;",
      "    }",
      "",
      "    if (optionalUser.isPresent()) {",
      "      User user = optionalUser.get();",
      "      for (String perm : jsonRpcMethod.getPermissions()) {",
      "        user.isAuthorized(",
      "            perm,",
      "            (authed) -> {",
      "              if (authed.result()) {",
      "                LOG.trace(",
      "                    \"user {} authorized : {} via permission {}\",",
      "                    user,",
      "                    jsonRpcMethod.getName(),",
      "                    perm);",
      "                foundMatchingPermission.set(true);",
      "              }",
      "            });",
      "        // exit if a matching permission was found, no need to keep checking",
      "        if (foundMatchingPermission.get()) {",
      "          return foundMatchingPermission.get();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/hyperledger/besu/pull/1144",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/hyperledger/besu/pull/1144: 403 Client Error: Forbidden for url: https://api.github.com/repos/hyperledger/besu/pulls/1144",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch modifies the permissions checking in the JSON-RPC handling to exit early when a matching permission is found and reorders permissions for correct authorization. It includes tests for wildcard permissions, indicating a fix for a security issue. The changes directly address how permissions are evaluated, suggesting the correction of a security flaw."
}