{
  "cve_id": "CVE-2022-40138",
  "cwe_ids": [
    "CWE-681"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#822)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "6aa825e480d48127b480b08d13adf70033237097",
  "git_url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
  "file_path": "lib/VM/Callable.cpp",
  "func_name": "GeneratorInnerFunction::callInnerFunction",
  "func_before": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> selfHandle,\n    Runtime &runtime,\n    Handle<> arg,\n    Action action) {\n  auto self = Handle<GeneratorInnerFunction>::vmcast(selfHandle);\n\n  SmallHermesValue shv =\n      SmallHermesValue::encodeHermesValue(arg.getHermesValue(), runtime);\n  self->result_.set(shv, runtime.getHeap());\n  self->action_ = action;\n\n  auto ctx = runtime.makeMutableHandle(selfHandle->savedContext_);\n  // Account for the `this` argument stored as the first element of ctx.\n  const uint32_t argCount = self->argCount_;\n  // Generators cannot be used as constructors, so newTarget is always\n  // undefined.\n  HermesValue newTarget = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame frame{\n      runtime,\n      argCount, // Account for `this`.\n      selfHandle.getHermesValue(),\n      newTarget,\n      ctx->at(0)};\n  if (LLVM_UNLIKELY(frame.overflowed()))\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type i = 0, e = argCount; i < e; ++i) {\n    frame->getArgRef(i) = ctx->at(i + 1);\n  }\n\n  // Force lazy compilation immediately in order to size the context properly.\n  // We're about to call the function anyway, so this doesn't reduce laziness.\n  // Note that this will do nothing after the very first time a lazy function\n  // is called, so we only resize before we save any registers at all.\n  if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                ctx,\n                runtime,\n                getContextSize(\n                    selfHandle->getCodeBlock(runtime),\n                    selfHandle->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    selfHandle->savedContext_.set(runtime, ctx.get(), runtime.getHeap());\n  }\n\n  return JSFunction::_callImpl(selfHandle, runtime);\n}",
  "abstract_func_before": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> VAR_0,\n    Runtime &VAR_1,\n    Handle<> VAR_2,\n    Action VAR_3) {\n  auto VAR_4 = Handle<GeneratorInnerFunction>::vmcast(VAR_0);\n\n  SmallHermesValue VAR_5 =\n      SmallHermesValue::encodeHermesValue(VAR_2.getHermesValue(), VAR_1);\n  VAR_4->result_.set(VAR_5, VAR_1.getHeap());\n  VAR_4->action_ = VAR_3;\n\n  auto VAR_6 = VAR_1.makeMutableHandle(VAR_0->savedContext_);\n  /* COMMENT_0 */\n  const uint32_t VAR_7 = VAR_4->argCount_;\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  HermesValue VAR_8 = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame VAR_9{\n      VAR_1,\n      VAR_7, /* COMMENT_3 */\n      VAR_0.getHermesValue(),\n      VAR_8,\n      VAR_6->at(0)};\n  if (LLVM_UNLIKELY(VAR_9.overflowed()))\n    return VAR_1.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type VAR_10 = 0, VAR_11 = VAR_7; VAR_10 < VAR_11; ++VAR_10) {\n    VAR_9->getArgRef(VAR_10) = VAR_6->at(VAR_10 + 1);\n  }\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  if (LLVM_UNLIKELY(VAR_0->getCodeBlock(VAR_1)->isLazy())) {\n    VAR_0->getCodeBlock(VAR_1)->lazyCompile(VAR_1);\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                VAR_6,\n                VAR_1,\n                getContextSize(\n                    VAR_0->getCodeBlock(VAR_1),\n                    VAR_0->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    VAR_0->savedContext_.set(VAR_1, VAR_6.get(), VAR_1.getHeap());\n  }\n\n  return JSFunction::_callImpl(VAR_0, VAR_1);\n}",
  "func_graph_path_before": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Callable.cpp/vul/before/0.json",
  "func": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> selfHandle,\n    Runtime &runtime,\n    Handle<> arg,\n    Action action) {\n  auto self = Handle<GeneratorInnerFunction>::vmcast(selfHandle);\n\n  SmallHermesValue shv =\n      SmallHermesValue::encodeHermesValue(arg.getHermesValue(), runtime);\n  self->result_.set(shv, runtime.getHeap());\n  self->action_ = action;\n\n  auto ctx = runtime.makeMutableHandle(selfHandle->savedContext_);\n  // Account for the `this` argument stored as the first element of ctx.\n  const uint32_t argCount = self->argCount_;\n  // Generators cannot be used as constructors, so newTarget is always\n  // undefined.\n  HermesValue newTarget = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame frame{\n      runtime,\n      argCount, // Account for `this`.\n      selfHandle.getHermesValue(),\n      newTarget,\n      ctx->at(0)};\n  if (LLVM_UNLIKELY(frame.overflowed()))\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type i = 0, e = argCount; i < e; ++i) {\n    frame->getArgRef(i) = ctx->at(i + 1);\n  }\n\n  // Force lazy compilation immediately in order to size the context properly.\n  // We're about to call the function anyway, so this doesn't reduce laziness.\n  // Note that this will do nothing after the very first time a lazy function\n  // is called, so we only resize before we save any registers at all.\n  if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n    if (LLVM_UNLIKELY(\n            selfHandle->getCodeBlock(runtime)->lazyCompile(runtime) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                ctx,\n                runtime,\n                getContextSize(\n                    selfHandle->getCodeBlock(runtime),\n                    selfHandle->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    selfHandle->savedContext_.set(runtime, ctx.get(), runtime.getHeap());\n  }\n\n  return JSFunction::_callImpl(selfHandle, runtime);\n}",
  "abstract_func": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> VAR_0,\n    Runtime &VAR_1,\n    Handle<> VAR_2,\n    Action VAR_3) {\n  auto VAR_4 = Handle<GeneratorInnerFunction>::vmcast(VAR_0);\n\n  SmallHermesValue VAR_5 =\n      SmallHermesValue::encodeHermesValue(VAR_2.getHermesValue(), VAR_1);\n  VAR_4->result_.set(VAR_5, VAR_1.getHeap());\n  VAR_4->action_ = VAR_3;\n\n  auto VAR_6 = VAR_1.makeMutableHandle(VAR_0->savedContext_);\n  /* COMMENT_0 */\n  const uint32_t VAR_7 = VAR_4->argCount_;\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  HermesValue VAR_8 = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame VAR_9{\n      VAR_1,\n      VAR_7, /* COMMENT_3 */\n      VAR_0.getHermesValue(),\n      VAR_8,\n      VAR_6->at(0)};\n  if (LLVM_UNLIKELY(VAR_9.overflowed()))\n    return VAR_1.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type VAR_10 = 0, VAR_11 = VAR_7; VAR_10 < VAR_11; ++VAR_10) {\n    VAR_9->getArgRef(VAR_10) = VAR_6->at(VAR_10 + 1);\n  }\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  if (LLVM_UNLIKELY(VAR_0->getCodeBlock(VAR_1)->isLazy())) {\n    if (LLVM_UNLIKELY(\n            VAR_0->getCodeBlock(VAR_1)->lazyCompile(VAR_1) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                VAR_6,\n                VAR_1,\n                getContextSize(\n                    VAR_0->getCodeBlock(VAR_1),\n                    VAR_0->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    VAR_0->savedContext_.set(VAR_1, VAR_6.get(), VAR_1.getHeap());\n  }\n\n  return JSFunction::_callImpl(VAR_0, VAR_1);\n}",
  "func_graph_path": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Callable.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,11 @@\n   // Note that this will do nothing after the very first time a lazy function\n   // is called, so we only resize before we save any registers at all.\n   if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n-    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n+    if (LLVM_UNLIKELY(\n+            selfHandle->getCodeBlock(runtime)->lazyCompile(runtime) ==\n+            ExecutionStatus::EXCEPTION)) {\n+      return ExecutionStatus::EXCEPTION;\n+    }\n     if (LLVM_UNLIKELY(\n             ArrayStorage::resize(\n                 ctx,",
  "diff_line_info": {
    "deleted_lines": [
      "    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);"
    ],
    "added_lines": [
      "    if (LLVM_UNLIKELY(",
      "            selfHandle->getCodeBlock(runtime)->lazyCompile(runtime) ==",
      "            ExecutionStatus::EXCEPTION)) {",
      "      return ExecutionStatus::EXCEPTION;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/822",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/hermes/pull/822: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/hermes/pulls/822",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8\n\nThe patch introduces error handling for a lazy compilation process, enhancing code stability without addressing a security issue."
}