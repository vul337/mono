{
  "cve_id": "CVE-2021-3751",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "bfabiszewski/libmobi",
  "commit_msg": "fix oob write bug inside libmobi",
  "commit_hash": "ab5bf0e37e540eac682a14e628853b918626e72b",
  "git_url": "https://github.com/bfabiszewski/libmobi/commit/ab5bf0e37e540eac682a14e628853b918626e72b",
  "file_path": "src/buffer.c",
  "func_name": "mobi_buffer_move",
  "func_before": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
  "abstract_func_before": "void mobi_buffer_move(MOBIBuffer *VAR_0, const int VAR_1, const size_t VAR_2) {\n    size_t VAR_3 = (size_t) abs(VAR_1);\n    unsigned char *VAR_4 = VAR_0->data + VAR_0->offset;\n    if (VAR_1 >= 0) {\n        if (VAR_0->offset + VAR_3 + VAR_2 > VAR_0->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            VAR_0->error = VAR_5;\n            return;\n        }\n        VAR_4 += VAR_3;\n    } else {\n        if (VAR_0->offset < VAR_3) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            VAR_0->error = VAR_5;\n            return;\n        }\n        VAR_4 -= VAR_3;\n    }\n    memmove(VAR_0->data + VAR_0->offset, VAR_4, VAR_2);\n    VAR_0->offset += VAR_2;\n}",
  "func_graph_path_before": "bfabiszewski/libmobi/ab5bf0e37e540eac682a14e628853b918626e72b/buffer.c/vul/before/0.json",
  "func": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {\n            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
  "abstract_func": "void mobi_buffer_move(MOBIBuffer *VAR_0, const int VAR_1, const size_t VAR_2) {\n    size_t VAR_3 = (size_t) abs(VAR_1);\n    unsigned char *VAR_4 = VAR_0->data + VAR_0->offset;\n    if (VAR_1 >= 0) {\n        if (VAR_0->offset + VAR_3 + VAR_2 > VAR_0->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            VAR_0->error = VAR_5;\n            return;\n        }\n        VAR_4 += VAR_3;\n    } else {\n        if ( (VAR_0->offset < VAR_3) || (VAR_0->offset + VAR_2 > VAR_0->maxlen) ) {\n            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");\n            VAR_0->error = VAR_5;\n            return;\n        }\n        VAR_4 -= VAR_3;\n    }\n    memmove(VAR_0->data + VAR_0->offset, VAR_4, VAR_2);\n    VAR_0->offset += VAR_2;\n}",
  "func_graph_path": "bfabiszewski/libmobi/ab5bf0e37e540eac682a14e628853b918626e72b/buffer.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,8 @@\n         }\n         source += aoffset;\n     } else {\n-        if (buf->offset < aoffset) {\n-            debug_print(\"%s\", \"End of buffer\\n\");\n+        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {\n+            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");\n             buf->error = MOBI_BUFFER_END;\n             return;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "        if (buf->offset < aoffset) {",
      "            debug_print(\"%s\", \"End of buffer\\n\");"
    ],
    "added_lines": [
      "        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {",
      "            debug_print(\"%s\", \"Beyond start/end of buffer\\n\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/bfabiszewski/libmobi/pull/33",
  "description": {
    "pr_info": {
      "title": "fix oob write vulnerabilities inside libmobi",
      "number": 33
    },
    "comment": [
      "Hey, guys, recently I found an OOB write bug inside libmobi, I made a fix for it and hope you are happy to receive this fix.\r\n\r\nHere is the detail of this vulnerability:\r\n\r\n# ‚úçÔ∏è Description\r\n## Overview\r\nThis vulnerability is of writing user controlled values out of the buffer. The buffer is of `MOBIBuffer` type which is allocated using `malloc`. It is possible for the attacker to finally accomplish RCE (Remote Code Execution) using this out-of-bound write vulnerability to overwrite control-flow critical memory values.\r\n\r\n## Root Cause & Fix Suggestion\r\nThis vulnerability is introduced by incomplete check of buffer boundaries in `mobi_buffer_move` (`src/buffer.c`). In that function,  when `offset < 0`, the condition `buf->offset + len <= buf->maxlen` doesn't be checked. Currently, that function only checks whether `buf->offset >= abs(offset)` when `offset < 0`.\r\n\r\nThe following code shows the vulnerable point and possible fix.\r\n\r\n```c\r\n// src/buffer.c\r\nvoid mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\r\n    size_t aoffset = (size_t) abs(offset);\r\n    unsigned char *source = buf->data + buf->offset;\r\n    if (offset >= 0) {\r\n        if (buf->offset + aoffset + len > buf->maxlen) {\r\n            debug_print(\"%s\", \"End of buffer\\n\");\r\n            buf->error = MOBI_BUFFER_END;\r\n            return;\r\n        }\r\n        source += aoffset;\r\n    } else {\r\n        // INCOMPLETE CHECK HERE:\r\n        // should also check buf->offset + len <= buf->maxlen\r\n        // POSSIBLE FIX:\r\n        // if ( (buf->offset < aoffset) || (buf->offset + len <= buf->maxlen) )\r\n        if (buf->offset < aoffset) {\r\n            debug_print(\"%s\", \"End of buffer\\n\");\r\n            buf->error = MOBI_BUFFER_END;\r\n            return;\r\n        }\r\n        source -= aoffset;\r\n    }\r\n    // due to the incomplete check, the memmove can out-of-bound write\r\n    memmove(buf->data + buf->offset, source, len);\r\n    buf->offset += len;\r\n}\r\n```\r\n\r\n\r\n\r\n # üïµÔ∏è‚Äç‚ôÇÔ∏è Proof of Concept\r\n- Download latest `libmobi` and compile it with Address Sanitizer: `CFLAGS=\" -fsanitize=address \" CXXFLAGS=\" -fsanitize=address \"`\r\n- Use the following command and this [POC-FILE](https://drive.google.com/file/d/1Y3mYZthjlhq4iXOQzWzUYvDouWOnXk53/view?usp=sharing) to reproduce the crash:\r\n\r\n```bash\r\n# enable address sanitizer\r\nexport ASAN_OPTIONS=abort_on_error=1:disable_coredump=0:unmap_shadow_on_exit=1\r\n# reproduce the crash\r\n./mobitool -cdeimsrux7 -o any-tmp-dir-path POC-FILE\r\n```\r\n\r\nYou should get similar crash information as follows:\r\n```bash\r\n=================================================================\r\n==14492==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x621000009d00 at pc 0x7ffff762917a bp 0x7fffffffbef0 sp 0x7fffffffb698\r\nWRITE of size 1 at 0x621000009d00 thread T0\r\n    #0 0x7ffff7629179 in memmove (/lib/x86_64-linux-gnu/libasan.so.6+0x3a179)\r\n    #1 0x7ffff75857c9 in mobi_buffer_move /src/libmobi/libmobi-git/src/buffer.c:520\r\n    #2 0x7ffff7585d83 in mobi_decompress_lz77 /src/libmobi/libmobi-git/src/compression.c:59\r\n    #3 0x7ffff75ad161 in mobi_decompress_content /src/libmobi/libmobi-git/src/util.c:1774\r\n    #4 0x7ffff75ad677 in mobi_dump_rawml /src/libmobi/libmobi-git/src/util.c:1856\r\n    #5 0x5555555630e4 in dump_rawml /src/libmobi/libmobi-git/tools/mobitool.c:333\r\n    #6 0x5555555661e3 in loadfilename /src/libmobi/libmobi-git/tools/mobitool.c:775\r\n    #7 0x555555566e46 in main /src/libmobi/libmobi-git/tools/mobitool.c:962\r\n    #8 0x7ffff73a90b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\r\n    #9 0x55555555dead in _start (/src/libmobi/libmobi-git/install/bin/mobitool+0x9ead)\r\n\r\n0x621000009d00 is located 0 bytes to the right of 4096-byte region [0x621000008d00,0x621000009d00)\r\nallocated by thread T0 here:\r\n    #0 0x7ffff769f517 in malloc (/lib/x86_64-linux-gnu/libasan.so.6+0xb0517)\r\n    #1 0x7ffff75acb85 in mobi_decompress_content /src/libmobi/libmobi-git/src/util.c:1702\r\n    #2 0x7ffff75ad677 in mobi_dump_rawml /src/libmobi/libmobi-git/src/util.c:1856\r\n    #3 0x5555555630e4 in dump_rawml /src/libmobi/libmobi-git/tools/mobitool.c:333\r\n    #4 0x5555555661e3 in loadfilename /src/libmobi/libmobi-git/tools/mobitool.c:775\r\n    #5 0x555555566e46 in main /src/libmobi/libmobi-git/tools/mobitool.c:962\r\n    #6 0x7ffff73a90b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\r\n```\r\n\r\n# üí• Impact\r\nThis vulnerability is capable of overwriting memory content with user given values. For all applications using `libmobi` (commits `983b89820e1c592d9d7c8c438af46e75be1f96e1 ` in Jun 8th, 2021 or release version 0.6 (2020 Aug 1st))\r\nIt is possible for the attacker to finally accomplish RCE (Remote Code Execution) using this out-of-bound write vulnerability to overwrite control-flow critical memory values.\r\n",
      "Thanks for catching this!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit message and code changes clearly address an out-of-bounds write vulnerability that could lead to remote code execution, making it a clear security fix with high confidence.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}