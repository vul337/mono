{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/record/rec_layer_s3.c",
  "func_name": "ssl3_write_bytes",
  "func_before": "int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)\n{\n    const unsigned char *buf = buf_;\n    int tot;\n    unsigned int n, split_send_fragment, maxpipes;\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n    unsigned int max_send_fragment, nw;\n    unsigned int u_len = (unsigned int)len;\n#endif\n    SSL3_BUFFER *wb = &s->rlayer.wbuf[0];\n    int i;\n\n    if (len < 0) {\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_NEGATIVE_LENGTH);\n        return -1;\n    }\n\n    s->rwstate = SSL_NOTHING;\n    tot = s->rlayer.wnum;\n    /*\n     * ensure that if we end up with a smaller value of data to write out\n     * than the the original len from a write which didn't complete for\n     * non-blocking I/O and also somehow ended up avoiding the check for\n     * this in ssl3_write_pending/SSL_R_BAD_WRITE_RETRY as it must never be\n     * possible to end up with (len-tot) as a large number that will then\n     * promptly send beyond the end of the users buffer ... so we trap and\n     * report the error in a way the user will notice\n     */\n    if ((unsigned int)len < s->rlayer.wnum) {\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);\n        return -1;\n    }\n\n    s->rlayer.wnum = 0;\n\n    if (SSL_in_init(s) && !ossl_statem_get_in_handshake(s)) {\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return -1;\n        }\n    }\n\n    /*\n     * first check if there is a SSL3_BUFFER still being written out.  This\n     * will happen with non blocking IO\n     */\n    if (wb->left != 0) {\n        i = ssl3_write_pending(s, type, &buf[tot], s->rlayer.wpend_tot);\n        if (i <= 0) {\n            /* XXX should we ssl3_release_write_buffer if i<0? */\n            s->rlayer.wnum = tot;\n            return i;\n        }\n        tot += i;               /* this might be last fragment */\n    }\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n    /*\n     * Depending on platform multi-block can deliver several *times*\n     * better performance. Downside is that it has to allocate\n     * jumbo buffer to accommodate up to 8 records, but the\n     * compromise is considered worthy.\n     */\n    if (type == SSL3_RT_APPLICATION_DATA &&\n        u_len >= 4 * (max_send_fragment = s->max_send_fragment) &&\n        s->compress == NULL && s->msg_callback == NULL &&\n        !SSL_USE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n        EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &\n        EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {\n        unsigned char aad[13];\n        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;\n        int packlen;\n\n        /* minimize address aliasing conflicts */\n        if ((max_send_fragment & 0xfff) == 0)\n            max_send_fragment -= 512;\n\n        if (tot == 0 || wb->buf == NULL) { /* allocate jumbo buffer */\n            ssl3_release_write_buffer(s);\n\n            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                          EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE,\n                                          max_send_fragment, NULL);\n\n            if (u_len >= 8 * max_send_fragment)\n                packlen *= 8;\n            else\n                packlen *= 4;\n\n            if (!ssl3_setup_write_buffer(s, 1, packlen)) {\n                SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_MALLOC_FAILURE);\n                return -1;\n            }\n        } else if (tot == len) { /* done? */\n            /* free jumbo buffer */\n            ssl3_release_write_buffer(s);\n            return tot;\n        }\n\n        n = (len - tot);\n        for (;;) {\n            if (n < 4 * max_send_fragment) {\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                break;\n            }\n\n            if (s->s3->alert_dispatch) {\n                i = s->method->ssl_dispatch_alert(s);\n                if (i <= 0) {\n                    s->rlayer.wnum = tot;\n                    return i;\n                }\n            }\n\n            if (n >= 8 * max_send_fragment)\n                nw = max_send_fragment * (mb_param.interleave = 8);\n            else\n                nw = max_send_fragment * (mb_param.interleave = 4);\n\n            memcpy(aad, s->rlayer.write_sequence, 8);\n            aad[8] = type;\n            aad[9] = (unsigned char)(s->version >> 8);\n            aad[10] = (unsigned char)(s->version);\n            aad[11] = 0;\n            aad[12] = 0;\n            mb_param.out = NULL;\n            mb_param.inp = aad;\n            mb_param.len = nw;\n\n            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                          EVP_CTRL_TLS1_1_MULTIBLOCK_AAD,\n                                          sizeof(mb_param), &mb_param);\n\n            if (packlen <= 0 || packlen > (int)wb->len) { /* never happens */\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                break;\n            }\n\n            mb_param.out = wb->buf;\n            mb_param.inp = &buf[tot];\n            mb_param.len = nw;\n\n            if (EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                    EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT,\n                                    sizeof(mb_param), &mb_param) <= 0)\n                return -1;\n\n            s->rlayer.write_sequence[7] += mb_param.interleave;\n            if (s->rlayer.write_sequence[7] < mb_param.interleave) {\n                int j = 6;\n                while (j >= 0 && (++s->rlayer.write_sequence[j--]) == 0) ;\n            }\n\n            wb->offset = 0;\n            wb->left = packlen;\n\n            s->rlayer.wpend_tot = nw;\n            s->rlayer.wpend_buf = &buf[tot];\n            s->rlayer.wpend_type = type;\n            s->rlayer.wpend_ret = nw;\n\n            i = ssl3_write_pending(s, type, &buf[tot], nw);\n            if (i <= 0) {\n                if (i < 0 && (!s->wbio || !BIO_should_retry(s->wbio))) {\n                    /* free jumbo buffer */\n                    ssl3_release_write_buffer(s);\n                }\n                s->rlayer.wnum = tot;\n                return i;\n            }\n            if (i == (int)n) {\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                return tot + i;\n            }\n            n -= i;\n            tot += i;\n        }\n    } else\n#endif\n    if (tot == len) {           /* done? */\n        if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))\n            ssl3_release_write_buffer(s);\n\n        return tot;\n    }\n\n    n = (len - tot);\n\n    split_send_fragment = s->split_send_fragment;\n    /*\n     * If max_pipelines is 0 then this means \"undefined\" and we default to\n     * 1 pipeline. Similarly if the cipher does not support pipelined\n     * processing then we also only use 1 pipeline, or if we're not using\n     * explicit IVs\n     */\n    maxpipes = s->max_pipelines;\n    if (maxpipes > SSL_MAX_PIPELINES) {\n        /*\n         * We should have prevented this when we set max_pipelines so we\n         * shouldn't get here\n         */\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n    if (maxpipes == 0\n        || s->enc_write_ctx == NULL\n        || !(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx))\n             & EVP_CIPH_FLAG_PIPELINE)\n        || !SSL_USE_EXPLICIT_IV(s))\n        maxpipes = 1;\n    if (s->max_send_fragment == 0 || split_send_fragment > s->max_send_fragment\n        || split_send_fragment == 0) {\n        /*\n         * We should have prevented this when we set the split and max send\n         * fragments so we shouldn't get here\n         */\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    for (;;) {\n        unsigned int pipelens[SSL_MAX_PIPELINES], tmppipelen, remain;\n        unsigned int numpipes, j;\n\n        if (n == 0)\n            numpipes = 1;\n        else\n            numpipes = ((n - 1) / split_send_fragment) + 1;\n        if (numpipes > maxpipes)\n            numpipes = maxpipes;\n\n        if (n / numpipes >= s->max_send_fragment) {\n            /*\n             * We have enough data to completely fill all available\n             * pipelines\n             */\n            for (j = 0; j < numpipes; j++) {\n                pipelens[j] = s->max_send_fragment;\n            }\n        } else {\n            /* We can partially fill all available pipelines */\n            tmppipelen = n / numpipes;\n            remain = n % numpipes;\n            for (j = 0; j < numpipes; j++) {\n                pipelens[j] = tmppipelen;\n                if (j < remain)\n                    pipelens[j]++;\n            }\n        }\n\n        i = do_ssl3_write(s, type, &(buf[tot]), pipelens, numpipes, 0);\n        if (i <= 0) {\n            /* XXX should we ssl3_release_write_buffer if i<0? */\n            s->rlayer.wnum = tot;\n            return i;\n        }\n\n        if ((i == (int)n) ||\n            (type == SSL3_RT_APPLICATION_DATA &&\n             (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {\n            /*\n             * next chunk of data should get another prepended empty fragment\n             * in ciphersuites with known-IV weakness:\n             */\n            s->s3->empty_fragment_done = 0;\n\n            if ((i == (int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&\n                !SSL_IS_DTLS(s))\n                ssl3_release_write_buffer(s);\n\n            return tot + i;\n        }\n\n        n -= i;\n        tot += i;\n    }\n}",
  "abstract_func_before": "int ssl3_write_bytes(SSL *VAR_0, int VAR_1, const void *VAR_2, int VAR_3)\n{\n    const unsigned char *VAR_4 = VAR_2;\n    int VAR_5;\n    unsigned int VAR_6, VAR_7, VAR_8;\n#if !defined(VAR_9) && VAR_10\n    unsigned int VAR_11, VAR_12;\n    unsigned int VAR_13 = (unsigned int)VAR_3;\n#endif\n    SSL3_BUFFER *VAR_14 = &VAR_0->rlayer.wbuf[0];\n    int VAR_15;\n\n    if (VAR_3 < 0) {\n        SSLerr(VAR_16, VAR_17);\n        return -1;\n    }\n\n    VAR_0->rwstate = VAR_18;\n    VAR_5 = VAR_0->rlayer.wnum;\n    /* COMMENT_0 */\n                                                                         \n                                                                       \n                                                                        \n                                                                           \n                                                                         \n                                                                          \n                                                     \n       \n    if ((unsigned int)VAR_3 < VAR_0->rlayer.wnum) {\n        SSLerr(VAR_16, VAR_19);\n        return -1;\n    }\n\n    VAR_0->rlayer.wnum = 0;\n\n    if (SSL_in_init(VAR_0) && !ossl_statem_get_in_handshake(VAR_0)) {\n        VAR_15 = VAR_0->handshake_func(VAR_0);\n        if (VAR_15 < 0)\n            return (VAR_15);\n        if (VAR_15 == 0) {\n            SSLerr(VAR_16, VAR_20);\n            return -1;\n        }\n    }\n\n    /* COMMENT_9 */\n                                                                           \n                                       \n       \n    if (VAR_14->left != 0) {\n        VAR_15 = ssl3_write_pending(VAR_0, VAR_1, &VAR_4[VAR_5], VAR_0->rlayer.wpend_tot);\n        if (VAR_15 <= 0) {\n            /* COMMENT_13 */\n            VAR_0->rlayer.wnum = VAR_5;\n            return VAR_15;\n        }\n        VAR_5 += VAR_15;               /* COMMENT_14 */\n    }\n#if !defined(VAR_9) && VAR_10\n    /* COMMENT_15 */\n                                                                    \n                                                              \n                                                           \n                                       \n       \n    if (VAR_1 == VAR_21 &&\n        VAR_13 >= 4 * (VAR_11 = VAR_0->max_send_fragment) &&\n        VAR_0->compress == NULL && VAR_0->msg_callback == NULL &&\n        !SSL_USE_ETM(VAR_0) && SSL_USE_EXPLICIT_IV(VAR_0) &&\n        EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_0->enc_write_ctx)) &\n        VAR_10) {\n        unsigned char VAR_22[13];\n        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM VAR_23;\n        int VAR_24;\n\n        /* COMMENT_21 */\n        if ((VAR_11 & 0xfff) == 0)\n            VAR_11 -= 512;\n\n        if (VAR_5 == 0 || VAR_14->buf == NULL) { /* COMMENT_22 */\n            ssl3_release_write_buffer(VAR_0);\n\n            VAR_24 = EVP_CIPHER_CTX_ctrl(VAR_0->enc_write_ctx,\n                                          VAR_25,\n                                          VAR_11, NULL);\n\n            if (VAR_13 >= 8 * VAR_11)\n                VAR_24 *= 8;\n            else\n                VAR_24 *= 4;\n\n            if (!ssl3_setup_write_buffer(VAR_0, 1, VAR_24)) {\n                SSLerr(VAR_16, VAR_26);\n                return -1;\n            }\n        } else if (VAR_5 == VAR_3) { /* COMMENT_23 */\n            /* COMMENT_24 */\n            ssl3_release_write_buffer(VAR_0);\n            return VAR_5;\n        }\n\n        VAR_6 = (VAR_3 - VAR_5);\n        for (;;) {\n            if (VAR_6 < 4 * VAR_11) {\n                /* COMMENT_24 */\n                ssl3_release_write_buffer(VAR_0);\n                break;\n            }\n\n            if (VAR_0->s3->alert_dispatch) {\n                VAR_15 = VAR_0->method->ssl_dispatch_alert(VAR_0);\n                if (VAR_15 <= 0) {\n                    VAR_0->rlayer.wnum = VAR_5;\n                    return VAR_15;\n                }\n            }\n\n            if (VAR_6 >= 8 * VAR_11)\n                VAR_12 = VAR_11 * (VAR_23.interleave = 8);\n            else\n                VAR_12 = VAR_11 * (VAR_23.interleave = 4);\n\n            memcpy(VAR_22, VAR_0->rlayer.write_sequence, 8);\n            VAR_22[8] = VAR_1;\n            VAR_22[9] = (unsigned char)(VAR_0->version >> 8);\n            VAR_22[10] = (unsigned char)(VAR_0->version);\n            VAR_22[11] = 0;\n            VAR_22[12] = 0;\n            VAR_23.out = NULL;\n            VAR_23.inp = VAR_22;\n            VAR_23.len = VAR_12;\n\n            VAR_24 = EVP_CIPHER_CTX_ctrl(VAR_0->enc_write_ctx,\n                                          VAR_27,\n                                          sizeof(VAR_23), &VAR_23);\n\n            if (VAR_24 <= 0 || VAR_24 > (int)VAR_14->len) { /* COMMENT_25 */\n                /* COMMENT_24 */\n                ssl3_release_write_buffer(VAR_0);\n                break;\n            }\n\n            VAR_23.out = VAR_14->buf;\n            VAR_23.inp = &VAR_4[VAR_5];\n            VAR_23.len = VAR_12;\n\n            if (EVP_CIPHER_CTX_ctrl(VAR_0->enc_write_ctx,\n                                    VAR_28,\n                                    sizeof(VAR_23), &VAR_23) <= 0)\n                return -1;\n\n            VAR_0->rlayer.write_sequence[7] += VAR_23.interleave;\n            if (VAR_0->rlayer.write_sequence[7] < VAR_23.interleave) {\n                int VAR_29 = 6;\n                while (VAR_29 >= 0 && (++VAR_0->rlayer.write_sequence[VAR_29--]) == 0) ;\n            }\n\n            VAR_14->offset = 0;\n            VAR_14->left = VAR_24;\n\n            VAR_0->rlayer.wpend_tot = VAR_12;\n            VAR_0->rlayer.wpend_buf = &VAR_4[VAR_5];\n            VAR_0->rlayer.wpend_type = VAR_1;\n            VAR_0->rlayer.wpend_ret = VAR_12;\n\n            VAR_15 = ssl3_write_pending(VAR_0, VAR_1, &VAR_4[VAR_5], VAR_12);\n            if (VAR_15 <= 0) {\n                if (VAR_15 < 0 && (!VAR_0->wbio || !BIO_should_retry(VAR_0->wbio))) {\n                    /* COMMENT_24 */\n                    ssl3_release_write_buffer(VAR_0);\n                }\n                VAR_0->rlayer.wnum = VAR_5;\n                return VAR_15;\n            }\n            if (VAR_15 == (int)VAR_6) {\n                /* COMMENT_24 */\n                ssl3_release_write_buffer(VAR_0);\n                return VAR_5 + VAR_15;\n            }\n            VAR_6 -= VAR_15;\n            VAR_5 += VAR_15;\n        }\n    } else\n#endif\n    if (VAR_5 == VAR_3) {           /* COMMENT_23 */\n        if (VAR_0->mode & VAR_30 && !SSL_IS_DTLS(VAR_0))\n            ssl3_release_write_buffer(VAR_0);\n\n        return VAR_5;\n    }\n\n    VAR_6 = (VAR_3 - VAR_5);\n\n    VAR_7 = VAR_0->split_send_fragment;\n    /* COMMENT_26 */\n                                                                          \n                                                                     \n                                                                         \n                   \n       \n    VAR_8 = VAR_0->max_pipelines;\n    if (VAR_8 > VAR_31) {\n        /* COMMENT_32 */\n                                                                        \n                             \n           \n        SSLerr(VAR_16, VAR_32);\n        return -1;\n    }\n    if (VAR_8 == 0\n        || VAR_0->enc_write_ctx == NULL\n        || !(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_0->enc_write_ctx))\n             & VAR_33)\n        || !SSL_USE_EXPLICIT_IV(VAR_0))\n        VAR_8 = 1;\n    if (VAR_0->max_send_fragment == 0 || VAR_7 > VAR_0->max_send_fragment\n        || VAR_7 == 0) {\n        /* COMMENT_36 */\n                                                                           \n                                             \n           \n        SSLerr(VAR_16, VAR_32);\n        return -1;\n    }\n\n    for (;;) {\n        unsigned int VAR_34[VAR_31], VAR_35, VAR_36;\n        unsigned int VAR_37, VAR_29;\n\n        if (VAR_6 == 0)\n            VAR_37 = 1;\n        else\n            VAR_37 = ((VAR_6 - 1) / VAR_7) + 1;\n        if (VAR_37 > VAR_8)\n            VAR_37 = VAR_8;\n\n        if (VAR_6 / VAR_37 >= VAR_0->max_send_fragment) {\n            /* COMMENT_40 */\n                                                                   \n                        \n               \n            for (VAR_29 = 0; VAR_29 < VAR_37; VAR_29++) {\n                VAR_34[VAR_29] = VAR_0->max_send_fragment;\n            }\n        } else {\n            /* COMMENT_44 */\n            VAR_35 = VAR_6 / VAR_37;\n            VAR_36 = VAR_6 % VAR_37;\n            for (VAR_29 = 0; VAR_29 < VAR_37; VAR_29++) {\n                VAR_34[VAR_29] = VAR_35;\n                if (VAR_29 < VAR_36)\n                    VAR_34[VAR_29]++;\n            }\n        }\n\n        VAR_15 = do_ssl3_write(VAR_0, VAR_1, &(VAR_4[VAR_5]), VAR_34, VAR_37, 0);\n        if (VAR_15 <= 0) {\n            /* COMMENT_13 */\n            VAR_0->rlayer.wnum = VAR_5;\n            return VAR_15;\n        }\n\n        if ((VAR_15 == (int)VAR_6) ||\n            (VAR_1 == VAR_21 &&\n             (VAR_0->mode & VAR_38))) {\n            /* COMMENT_45 */\n                                                                             \n                                                      \n               \n            VAR_0->s3->empty_fragment_done = 0;\n\n            if ((VAR_15 == (int)VAR_6) && VAR_0->mode & VAR_30 &&\n                !SSL_IS_DTLS(VAR_0))\n                ssl3_release_write_buffer(VAR_0);\n\n            return VAR_5 + VAR_15;\n        }\n\n        VAR_6 -= VAR_15;\n        VAR_5 += VAR_15;\n    }\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/rec_layer_s3.c/vul/before/1.json",
  "func": "int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)\n{\n    const unsigned char *buf = buf_;\n    int tot;\n    unsigned int n, split_send_fragment, maxpipes;\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n    unsigned int max_send_fragment, nw;\n    unsigned int u_len = (unsigned int)len;\n#endif\n    SSL3_BUFFER *wb = &s->rlayer.wbuf[0];\n    int i;\n\n    if (len < 0) {\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_NEGATIVE_LENGTH);\n        return -1;\n    }\n\n    s->rwstate = SSL_NOTHING;\n    tot = s->rlayer.wnum;\n    /*\n     * ensure that if we end up with a smaller value of data to write out\n     * than the the original len from a write which didn't complete for\n     * non-blocking I/O and also somehow ended up avoiding the check for\n     * this in ssl3_write_pending/SSL_R_BAD_WRITE_RETRY as it must never be\n     * possible to end up with (len-tot) as a large number that will then\n     * promptly send beyond the end of the users buffer ... so we trap and\n     * report the error in a way the user will notice\n     */\n    if ((unsigned int)len < s->rlayer.wnum) {\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);\n        return -1;\n    }\n\n    s->rlayer.wnum = 0;\n\n    if (SSL_in_init(s) && !ossl_statem_get_in_handshake(s)) {\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return -1;\n        }\n    }\n\n    /*\n     * first check if there is a SSL3_BUFFER still being written out.  This\n     * will happen with non blocking IO\n     */\n    if (wb->left != 0) {\n        i = ssl3_write_pending(s, type, &buf[tot], s->rlayer.wpend_tot);\n        if (i <= 0) {\n            /* XXX should we ssl3_release_write_buffer if i<0? */\n            s->rlayer.wnum = tot;\n            return i;\n        }\n        tot += i;               /* this might be last fragment */\n    }\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n    /*\n     * Depending on platform multi-block can deliver several *times*\n     * better performance. Downside is that it has to allocate\n     * jumbo buffer to accommodate up to 8 records, but the\n     * compromise is considered worthy.\n     */\n    if (type == SSL3_RT_APPLICATION_DATA &&\n        u_len >= 4 * (max_send_fragment = s->max_send_fragment) &&\n        s->compress == NULL && s->msg_callback == NULL &&\n        !SSL_WRITE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n        EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &\n        EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {\n        unsigned char aad[13];\n        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;\n        int packlen;\n\n        /* minimize address aliasing conflicts */\n        if ((max_send_fragment & 0xfff) == 0)\n            max_send_fragment -= 512;\n\n        if (tot == 0 || wb->buf == NULL) { /* allocate jumbo buffer */\n            ssl3_release_write_buffer(s);\n\n            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                          EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE,\n                                          max_send_fragment, NULL);\n\n            if (u_len >= 8 * max_send_fragment)\n                packlen *= 8;\n            else\n                packlen *= 4;\n\n            if (!ssl3_setup_write_buffer(s, 1, packlen)) {\n                SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_MALLOC_FAILURE);\n                return -1;\n            }\n        } else if (tot == len) { /* done? */\n            /* free jumbo buffer */\n            ssl3_release_write_buffer(s);\n            return tot;\n        }\n\n        n = (len - tot);\n        for (;;) {\n            if (n < 4 * max_send_fragment) {\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                break;\n            }\n\n            if (s->s3->alert_dispatch) {\n                i = s->method->ssl_dispatch_alert(s);\n                if (i <= 0) {\n                    s->rlayer.wnum = tot;\n                    return i;\n                }\n            }\n\n            if (n >= 8 * max_send_fragment)\n                nw = max_send_fragment * (mb_param.interleave = 8);\n            else\n                nw = max_send_fragment * (mb_param.interleave = 4);\n\n            memcpy(aad, s->rlayer.write_sequence, 8);\n            aad[8] = type;\n            aad[9] = (unsigned char)(s->version >> 8);\n            aad[10] = (unsigned char)(s->version);\n            aad[11] = 0;\n            aad[12] = 0;\n            mb_param.out = NULL;\n            mb_param.inp = aad;\n            mb_param.len = nw;\n\n            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                          EVP_CTRL_TLS1_1_MULTIBLOCK_AAD,\n                                          sizeof(mb_param), &mb_param);\n\n            if (packlen <= 0 || packlen > (int)wb->len) { /* never happens */\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                break;\n            }\n\n            mb_param.out = wb->buf;\n            mb_param.inp = &buf[tot];\n            mb_param.len = nw;\n\n            if (EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                    EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT,\n                                    sizeof(mb_param), &mb_param) <= 0)\n                return -1;\n\n            s->rlayer.write_sequence[7] += mb_param.interleave;\n            if (s->rlayer.write_sequence[7] < mb_param.interleave) {\n                int j = 6;\n                while (j >= 0 && (++s->rlayer.write_sequence[j--]) == 0) ;\n            }\n\n            wb->offset = 0;\n            wb->left = packlen;\n\n            s->rlayer.wpend_tot = nw;\n            s->rlayer.wpend_buf = &buf[tot];\n            s->rlayer.wpend_type = type;\n            s->rlayer.wpend_ret = nw;\n\n            i = ssl3_write_pending(s, type, &buf[tot], nw);\n            if (i <= 0) {\n                if (i < 0 && (!s->wbio || !BIO_should_retry(s->wbio))) {\n                    /* free jumbo buffer */\n                    ssl3_release_write_buffer(s);\n                }\n                s->rlayer.wnum = tot;\n                return i;\n            }\n            if (i == (int)n) {\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                return tot + i;\n            }\n            n -= i;\n            tot += i;\n        }\n    } else\n#endif\n    if (tot == len) {           /* done? */\n        if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))\n            ssl3_release_write_buffer(s);\n\n        return tot;\n    }\n\n    n = (len - tot);\n\n    split_send_fragment = s->split_send_fragment;\n    /*\n     * If max_pipelines is 0 then this means \"undefined\" and we default to\n     * 1 pipeline. Similarly if the cipher does not support pipelined\n     * processing then we also only use 1 pipeline, or if we're not using\n     * explicit IVs\n     */\n    maxpipes = s->max_pipelines;\n    if (maxpipes > SSL_MAX_PIPELINES) {\n        /*\n         * We should have prevented this when we set max_pipelines so we\n         * shouldn't get here\n         */\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n    if (maxpipes == 0\n        || s->enc_write_ctx == NULL\n        || !(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx))\n             & EVP_CIPH_FLAG_PIPELINE)\n        || !SSL_USE_EXPLICIT_IV(s))\n        maxpipes = 1;\n    if (s->max_send_fragment == 0 || split_send_fragment > s->max_send_fragment\n        || split_send_fragment == 0) {\n        /*\n         * We should have prevented this when we set the split and max send\n         * fragments so we shouldn't get here\n         */\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    for (;;) {\n        unsigned int pipelens[SSL_MAX_PIPELINES], tmppipelen, remain;\n        unsigned int numpipes, j;\n\n        if (n == 0)\n            numpipes = 1;\n        else\n            numpipes = ((n - 1) / split_send_fragment) + 1;\n        if (numpipes > maxpipes)\n            numpipes = maxpipes;\n\n        if (n / numpipes >= s->max_send_fragment) {\n            /*\n             * We have enough data to completely fill all available\n             * pipelines\n             */\n            for (j = 0; j < numpipes; j++) {\n                pipelens[j] = s->max_send_fragment;\n            }\n        } else {\n            /* We can partially fill all available pipelines */\n            tmppipelen = n / numpipes;\n            remain = n % numpipes;\n            for (j = 0; j < numpipes; j++) {\n                pipelens[j] = tmppipelen;\n                if (j < remain)\n                    pipelens[j]++;\n            }\n        }\n\n        i = do_ssl3_write(s, type, &(buf[tot]), pipelens, numpipes, 0);\n        if (i <= 0) {\n            /* XXX should we ssl3_release_write_buffer if i<0? */\n            s->rlayer.wnum = tot;\n            return i;\n        }\n\n        if ((i == (int)n) ||\n            (type == SSL3_RT_APPLICATION_DATA &&\n             (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {\n            /*\n             * next chunk of data should get another prepended empty fragment\n             * in ciphersuites with known-IV weakness:\n             */\n            s->s3->empty_fragment_done = 0;\n\n            if ((i == (int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&\n                !SSL_IS_DTLS(s))\n                ssl3_release_write_buffer(s);\n\n            return tot + i;\n        }\n\n        n -= i;\n        tot += i;\n    }\n}",
  "abstract_func": "int ssl3_write_bytes(SSL *VAR_0, int VAR_1, const void *VAR_2, int VAR_3)\n{\n    const unsigned char *VAR_4 = VAR_2;\n    int VAR_5;\n    unsigned int VAR_6, VAR_7, VAR_8;\n#if !defined(VAR_9) && VAR_10\n    unsigned int VAR_11, VAR_12;\n    unsigned int VAR_13 = (unsigned int)VAR_3;\n#endif\n    SSL3_BUFFER *VAR_14 = &VAR_0->rlayer.wbuf[0];\n    int VAR_15;\n\n    if (VAR_3 < 0) {\n        SSLerr(VAR_16, VAR_17);\n        return -1;\n    }\n\n    VAR_0->rwstate = VAR_18;\n    VAR_5 = VAR_0->rlayer.wnum;\n    /* COMMENT_0 */\n                                                                         \n                                                                       \n                                                                        \n                                                                           \n                                                                         \n                                                                          \n                                                     \n       \n    if ((unsigned int)VAR_3 < VAR_0->rlayer.wnum) {\n        SSLerr(VAR_16, VAR_19);\n        return -1;\n    }\n\n    VAR_0->rlayer.wnum = 0;\n\n    if (SSL_in_init(VAR_0) && !ossl_statem_get_in_handshake(VAR_0)) {\n        VAR_15 = VAR_0->handshake_func(VAR_0);\n        if (VAR_15 < 0)\n            return (VAR_15);\n        if (VAR_15 == 0) {\n            SSLerr(VAR_16, VAR_20);\n            return -1;\n        }\n    }\n\n    /* COMMENT_9 */\n                                                                           \n                                       \n       \n    if (VAR_14->left != 0) {\n        VAR_15 = ssl3_write_pending(VAR_0, VAR_1, &VAR_4[VAR_5], VAR_0->rlayer.wpend_tot);\n        if (VAR_15 <= 0) {\n            /* COMMENT_13 */\n            VAR_0->rlayer.wnum = VAR_5;\n            return VAR_15;\n        }\n        VAR_5 += VAR_15;               /* COMMENT_14 */\n    }\n#if !defined(VAR_9) && VAR_10\n    /* COMMENT_15 */\n                                                                    \n                                                              \n                                                           \n                                       \n       \n    if (VAR_1 == VAR_21 &&\n        VAR_13 >= 4 * (VAR_11 = VAR_0->max_send_fragment) &&\n        VAR_0->compress == NULL && VAR_0->msg_callback == NULL &&\n        !SSL_WRITE_ETM(VAR_0) && SSL_USE_EXPLICIT_IV(VAR_0) &&\n        EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_0->enc_write_ctx)) &\n        VAR_10) {\n        unsigned char VAR_22[13];\n        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM VAR_23;\n        int VAR_24;\n\n        /* COMMENT_21 */\n        if ((VAR_11 & 0xfff) == 0)\n            VAR_11 -= 512;\n\n        if (VAR_5 == 0 || VAR_14->buf == NULL) { /* COMMENT_22 */\n            ssl3_release_write_buffer(VAR_0);\n\n            VAR_24 = EVP_CIPHER_CTX_ctrl(VAR_0->enc_write_ctx,\n                                          VAR_25,\n                                          VAR_11, NULL);\n\n            if (VAR_13 >= 8 * VAR_11)\n                VAR_24 *= 8;\n            else\n                VAR_24 *= 4;\n\n            if (!ssl3_setup_write_buffer(VAR_0, 1, VAR_24)) {\n                SSLerr(VAR_16, VAR_26);\n                return -1;\n            }\n        } else if (VAR_5 == VAR_3) { /* COMMENT_23 */\n            /* COMMENT_24 */\n            ssl3_release_write_buffer(VAR_0);\n            return VAR_5;\n        }\n\n        VAR_6 = (VAR_3 - VAR_5);\n        for (;;) {\n            if (VAR_6 < 4 * VAR_11) {\n                /* COMMENT_24 */\n                ssl3_release_write_buffer(VAR_0);\n                break;\n            }\n\n            if (VAR_0->s3->alert_dispatch) {\n                VAR_15 = VAR_0->method->ssl_dispatch_alert(VAR_0);\n                if (VAR_15 <= 0) {\n                    VAR_0->rlayer.wnum = VAR_5;\n                    return VAR_15;\n                }\n            }\n\n            if (VAR_6 >= 8 * VAR_11)\n                VAR_12 = VAR_11 * (VAR_23.interleave = 8);\n            else\n                VAR_12 = VAR_11 * (VAR_23.interleave = 4);\n\n            memcpy(VAR_22, VAR_0->rlayer.write_sequence, 8);\n            VAR_22[8] = VAR_1;\n            VAR_22[9] = (unsigned char)(VAR_0->version >> 8);\n            VAR_22[10] = (unsigned char)(VAR_0->version);\n            VAR_22[11] = 0;\n            VAR_22[12] = 0;\n            VAR_23.out = NULL;\n            VAR_23.inp = VAR_22;\n            VAR_23.len = VAR_12;\n\n            VAR_24 = EVP_CIPHER_CTX_ctrl(VAR_0->enc_write_ctx,\n                                          VAR_27,\n                                          sizeof(VAR_23), &VAR_23);\n\n            if (VAR_24 <= 0 || VAR_24 > (int)VAR_14->len) { /* COMMENT_25 */\n                /* COMMENT_24 */\n                ssl3_release_write_buffer(VAR_0);\n                break;\n            }\n\n            VAR_23.out = VAR_14->buf;\n            VAR_23.inp = &VAR_4[VAR_5];\n            VAR_23.len = VAR_12;\n\n            if (EVP_CIPHER_CTX_ctrl(VAR_0->enc_write_ctx,\n                                    VAR_28,\n                                    sizeof(VAR_23), &VAR_23) <= 0)\n                return -1;\n\n            VAR_0->rlayer.write_sequence[7] += VAR_23.interleave;\n            if (VAR_0->rlayer.write_sequence[7] < VAR_23.interleave) {\n                int VAR_29 = 6;\n                while (VAR_29 >= 0 && (++VAR_0->rlayer.write_sequence[VAR_29--]) == 0) ;\n            }\n\n            VAR_14->offset = 0;\n            VAR_14->left = VAR_24;\n\n            VAR_0->rlayer.wpend_tot = VAR_12;\n            VAR_0->rlayer.wpend_buf = &VAR_4[VAR_5];\n            VAR_0->rlayer.wpend_type = VAR_1;\n            VAR_0->rlayer.wpend_ret = VAR_12;\n\n            VAR_15 = ssl3_write_pending(VAR_0, VAR_1, &VAR_4[VAR_5], VAR_12);\n            if (VAR_15 <= 0) {\n                if (VAR_15 < 0 && (!VAR_0->wbio || !BIO_should_retry(VAR_0->wbio))) {\n                    /* COMMENT_24 */\n                    ssl3_release_write_buffer(VAR_0);\n                }\n                VAR_0->rlayer.wnum = VAR_5;\n                return VAR_15;\n            }\n            if (VAR_15 == (int)VAR_6) {\n                /* COMMENT_24 */\n                ssl3_release_write_buffer(VAR_0);\n                return VAR_5 + VAR_15;\n            }\n            VAR_6 -= VAR_15;\n            VAR_5 += VAR_15;\n        }\n    } else\n#endif\n    if (VAR_5 == VAR_3) {           /* COMMENT_23 */\n        if (VAR_0->mode & VAR_30 && !SSL_IS_DTLS(VAR_0))\n            ssl3_release_write_buffer(VAR_0);\n\n        return VAR_5;\n    }\n\n    VAR_6 = (VAR_3 - VAR_5);\n\n    VAR_7 = VAR_0->split_send_fragment;\n    /* COMMENT_26 */\n                                                                          \n                                                                     \n                                                                         \n                   \n       \n    VAR_8 = VAR_0->max_pipelines;\n    if (VAR_8 > VAR_31) {\n        /* COMMENT_32 */\n                                                                        \n                             \n           \n        SSLerr(VAR_16, VAR_32);\n        return -1;\n    }\n    if (VAR_8 == 0\n        || VAR_0->enc_write_ctx == NULL\n        || !(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_0->enc_write_ctx))\n             & VAR_33)\n        || !SSL_USE_EXPLICIT_IV(VAR_0))\n        VAR_8 = 1;\n    if (VAR_0->max_send_fragment == 0 || VAR_7 > VAR_0->max_send_fragment\n        || VAR_7 == 0) {\n        /* COMMENT_36 */\n                                                                           \n                                             \n           \n        SSLerr(VAR_16, VAR_32);\n        return -1;\n    }\n\n    for (;;) {\n        unsigned int VAR_34[VAR_31], VAR_35, VAR_36;\n        unsigned int VAR_37, VAR_29;\n\n        if (VAR_6 == 0)\n            VAR_37 = 1;\n        else\n            VAR_37 = ((VAR_6 - 1) / VAR_7) + 1;\n        if (VAR_37 > VAR_8)\n            VAR_37 = VAR_8;\n\n        if (VAR_6 / VAR_37 >= VAR_0->max_send_fragment) {\n            /* COMMENT_40 */\n                                                                   \n                        \n               \n            for (VAR_29 = 0; VAR_29 < VAR_37; VAR_29++) {\n                VAR_34[VAR_29] = VAR_0->max_send_fragment;\n            }\n        } else {\n            /* COMMENT_44 */\n            VAR_35 = VAR_6 / VAR_37;\n            VAR_36 = VAR_6 % VAR_37;\n            for (VAR_29 = 0; VAR_29 < VAR_37; VAR_29++) {\n                VAR_34[VAR_29] = VAR_35;\n                if (VAR_29 < VAR_36)\n                    VAR_34[VAR_29]++;\n            }\n        }\n\n        VAR_15 = do_ssl3_write(VAR_0, VAR_1, &(VAR_4[VAR_5]), VAR_34, VAR_37, 0);\n        if (VAR_15 <= 0) {\n            /* COMMENT_13 */\n            VAR_0->rlayer.wnum = VAR_5;\n            return VAR_15;\n        }\n\n        if ((VAR_15 == (int)VAR_6) ||\n            (VAR_1 == VAR_21 &&\n             (VAR_0->mode & VAR_38))) {\n            /* COMMENT_45 */\n                                                                             \n                                                      \n               \n            VAR_0->s3->empty_fragment_done = 0;\n\n            if ((VAR_15 == (int)VAR_6) && VAR_0->mode & VAR_30 &&\n                !SSL_IS_DTLS(VAR_0))\n                ssl3_release_write_buffer(VAR_0);\n\n            return VAR_5 + VAR_15;\n        }\n\n        VAR_6 -= VAR_15;\n        VAR_5 += VAR_15;\n    }\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/rec_layer_s3.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n     if (type == SSL3_RT_APPLICATION_DATA &&\n         u_len >= 4 * (max_send_fragment = s->max_send_fragment) &&\n         s->compress == NULL && s->msg_callback == NULL &&\n-        !SSL_USE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n+        !SSL_WRITE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n         EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &\n         EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {\n         unsigned char aad[13];",
  "diff_line_info": {
    "deleted_lines": [
      "        !SSL_USE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&"
    ],
    "added_lines": [
      "        !SSL_WRITE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}