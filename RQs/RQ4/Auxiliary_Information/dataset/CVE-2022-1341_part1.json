{
  "cve_id": "CVE-2022-1341",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "vgropp/bwm-ng",
  "commit_msg": "Fix https://github.com/vgropp/bwm-ng/issues/26",
  "commit_hash": "9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17",
  "git_url": "https://github.com/vgropp/bwm-ng/commit/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17",
  "file_path": "src/options.c",
  "func_name": "get_cmdln_options",
  "func_before": "void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}",
  "abstract_func_before": "void get_cmdln_options(int VAR_0, char *VAR_1[]) {\n\tint VAR_2;\n#if VAR_3 && VAR_4\n    static struct passwd *VAR_5;\n    char *VAR_6;\n#endif\n#ifdef VAR_7\n    int VAR_8 = 0;\n    static struct option VAR_9[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef VAR_10\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef VAR_11\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if VAR_12 && VAR_13\n        {\"netstat\",1,0,'n'},\n#endif\n#if VAR_14\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if VAR_15        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef VAR_16\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef VAR_17\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef VAR_3\n    /* COMMENT_0 */\n    VAR_18=0;\n    while (1) {\n#ifdef VAR_7\n        VAR_2=getopt_long (VAR_0,VAR_1,VAR_19,VAR_9, &VAR_8);\n#else\n        VAR_2=getopt (VAR_0,VAR_1,VAR_19);\n#endif\n        if (VAR_2==-1) break;\n    }\n    VAR_18=1;\n    if (VAR_20 < VAR_0) {\n        read_config(VAR_1[VAR_20]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef VAR_4    \n        VAR_5=getpwuid(getuid());\n        if (VAR_5!=NULL) {\n            VAR_6=(char*)malloc(strlen(VAR_5->pw_dir)+14);\n            snprintf(VAR_6,strlen(VAR_5->pw_dir)+14,\"%s/.bwm-ng.conf\",VAR_5->pw_dir);\n            read_config(VAR_6);\n            free(VAR_6);\n        }\n#endif    \n    }\n    /* COMMENT_1 */\n    VAR_20=1;\n#endif\n    /* COMMENT_2 */\n    while (1) {\n#ifdef VAR_7\n\t\tVAR_2=getopt_long (VAR_0,VAR_1,VAR_19,VAR_9, &VAR_8);\n#else\n\t\tVAR_2=getopt (VAR_0,VAR_1,VAR_19);\n#endif\t\t\n        if (VAR_2==-1) break;\n        switch (VAR_2) {\n            case '?': printf(\"unknown option: %s\\n\",VAR_1[VAR_20-1]);\n                      exit(VAR_21);\n                      break;\n            /* COMMENT_3 */                      \n            case ':': if (!strcmp(VAR_1[VAR_20-1],\"-a\") || !strcasecmp(VAR_1[VAR_20-1],\"--allif\")) \n                            VAR_22=1;\n                      else if (!strcmp(VAR_1[VAR_20-1],\"-d\") || !strcasecmp(VAR_1[VAR_20-1],\"--dynamic\"))\n                            VAR_23=1;\n                      else if (!strcmp(VAR_1[VAR_20-1],\"-D\") || !strcasecmp(VAR_1[VAR_20-1],\"--daemon\"))\n                            VAR_24=1;\n#ifdef VAR_17                      \n                      else if (!strcmp(argv[VAR_20-1],\"-VAR_25\") || !strcasecmp(argv[VAR_20-1],\"--VAR_26\"))\n                            VAR_27=1;\n#endif                      \n                      else if (!strcmp(argv[VAR_20-1],\"-VAR_28\") || !strcasecmp(argv[VAR_20-1],\"--VAR_29\"))\n                            VAR_29=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[VAR_20-1]);\n                              exit(VAR_21);\n                          }\n                      break;\n#ifdef VAR_11\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(VAR_30)<VAR_31) \n\t\t\t\t\tstrcpy(VAR_32,VAR_30);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(VAR_30)<VAR_31)\n               strcpy(VAR_33,VAR_30);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if VAR_14\n\t\t\tcase 1002:\n\t\t\t\tVAR_34=!VAR_34;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (VAR_30) VAR_24=atoi(VAR_30);\n\t\t\t\tbreak;\n#ifdef VAR_17\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { VAR_35=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) VAR_27=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) VAR_36=atol(optarg);\n\t\t\t\tbreak;\n#if VAR_16 || VAR_17\n            case 'F':\n                if (optarg) { \n                    if (VAR_37) fclose(VAR_37);\n                    VAR_37=fopen(optarg,\"a\"); \n                    if (!VAR_37) deinit(1, \"failed to open outfile\\n\");\n                    if (VAR_38) free(VAR_38);\n                    VAR_38=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef VAR_16\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) VAR_39=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef VAR_10\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<VAR_31)) strcpy(VAR_40,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    VAR_41=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) VAR_42=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) VAR_29=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    VAR_43=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t VAR_44=!VAR_44;\n            case 'a':\n                if (optarg) VAR_22=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { VAR_45=atol(optarg); }\n                break;\n#if VAR_15                \n            case 'T':\n                VAR_46=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) VAR_47=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) VAR_23=atoi(optarg);\n                break;\n            case 'u':\n                VAR_48=str2output_unit(optarg);\n                break;\n#if VAR_12 && VAR_13\n            case 'n':\n                if (optarg && (strlen(optarg)<VAR_31)) strcpy(VAR_49,optarg);\n                break;\n#endif                \n            case 'V':\n                VAR_50;\n                exit(VAR_51);\n                break;\n        }\n    }\n    if (VAR_42==NULL && VAR_22==1) VAR_22=2;\n#if VAR_15    \n    /* COMMENT_4 */\n    if (VAR_47==0) {\n        if (VAR_45<VAR_52/2) \n            VAR_47=VAR_52; \n        else  \n            VAR_47=(VAR_45*2)+1;\n    } else /* COMMENT_5 */\n        if (VAR_45*2>=VAR_47) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((VAR_48==VAR_53 && !net_input_method(VAR_41)) || \n\t\t\t (VAR_48==VAR_54 && VAR_41==VAR_55)) \n\t\tVAR_48=VAR_56;\n    return;\n}",
  "func_graph_path_before": "vgropp/bwm-ng/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17/options.c/vul/before/0.json",
  "func": "void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\"netstat\",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if EXTENDED_STATS        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef CSV\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef HTML\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            if(!str) {\n              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(pwd_entry->pw_dir)+14);\n              exit(EXIT_FAILURE);\n            }\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                            sumhidden=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\"a\"); \n                    if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}",
  "abstract_func": "void get_cmdln_options(int VAR_0, char *VAR_1[]) {\n\tint VAR_2;\n#if VAR_3 && VAR_4\n    static struct passwd *VAR_5;\n    char *VAR_6;\n#endif\n#ifdef VAR_7\n    int VAR_8 = 0;\n    static struct option VAR_9[] = {\n        {\"timeout\", 1, 0, 't'},\n#ifdef VAR_10\n        {\"procfile\",1,0,'f'},\n#endif\n#ifdef VAR_11\n\t\t\t{\"diskstatsfile\",1,0,1000},\n\t\t\t{\"partitionsfile\",1,0,1001},\n#endif\t\t  \n#if VAR_12 && VAR_13\n        {\"netstat\",1,0,'n'},\n#endif\n#if VAR_14\n\t\t  {\"longdisknames\",0,0,1002},\n#endif\n        {\"input\",1,0,'i'},\n        {\"dynamic\",1,0,'d'},\n        {\"help\", 0, 0, 'h'},\n        {\"version\",0,0,'V'},\n        {\"allif\",1,0,'a'},\n        {\"unit\",1,0,'u'},\n\t\t  {\"ansiout\",0,0,'N'},\n#if VAR_15        \n        {\"type\",1,0,'T'},\n        {\"avglength\",1,0,'A'},\n#endif        \n        {\"interfaces\",1,0,'I'},\n        {\"sumhidden\",1,0,'S'},\n        {\"output\",1,0,'o'},\n#ifdef VAR_16\n        {\"csvchar\",1,0,'C'},\n        {\"csvfile\",1,0,'F'},\n#endif\n        {\"count\",1,0,'c'},\n        {\"daemon\",1,0,'D'},\n#ifdef VAR_17\n        {\"htmlrefresh\",1,0,'R'},\n        {\"htmlheader\",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef VAR_3\n    /* COMMENT_0 */\n    VAR_18=0;\n    while (1) {\n#ifdef VAR_7\n        VAR_2=getopt_long (VAR_0,VAR_1,VAR_19,VAR_9, &VAR_8);\n#else\n        VAR_2=getopt (VAR_0,VAR_1,VAR_19);\n#endif\n        if (VAR_2==-1) break;\n    }\n    VAR_18=1;\n    if (VAR_20 < VAR_0) {\n        read_config(VAR_1[VAR_20]);\n    } else {\n        read_config(\"/etc/bwm-ng.conf\");\n#ifdef VAR_4    \n        VAR_5=getpwuid(getuid());\n        if (VAR_5!=NULL) {\n            VAR_6=(char*)malloc(strlen(VAR_5->pw_dir)+14);\n            if(!VAR_6) {\n              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(VAR_5->pw_dir)+14);\n              exit(VAR_21);\n            }\n            snprintf(VAR_6,strlen(VAR_5->pw_dir)+14,\"%s/.bwm-ng.conf\",VAR_5->pw_dir);\n            read_config(VAR_6);\n            free(VAR_6);\n        }\n#endif    \n    }\n    /* COMMENT_1 */\n    VAR_20=1;\n#endif\n    /* COMMENT_2 */\n    while (1) {\n#ifdef VAR_7\n\t\tVAR_2=getopt_long (VAR_0,VAR_1,VAR_19,VAR_9, &VAR_8);\n#else\n\t\tVAR_2=getopt (VAR_0,VAR_1,VAR_19);\n#endif\t\t\n        if (VAR_2==-1) break;\n        switch (VAR_2) {\n            case '?': printf(\"unknown option: %s\\n\",VAR_1[VAR_20-1]);\n                      exit(VAR_21);\n                      break;\n            /* COMMENT_3 */                      \n            case ':': if (!strcmp(VAR_1[VAR_20-1],\"-a\") || !strcasecmp(VAR_1[VAR_20-1],\"--allif\")) \n                            VAR_22=1;\n                      else if (!strcmp(VAR_1[VAR_20-1],\"-d\") || !strcasecmp(VAR_1[VAR_20-1],\"--dynamic\"))\n                            VAR_23=1;\n                      else if (!strcmp(VAR_1[VAR_20-1],\"-D\") || !strcasecmp(VAR_1[VAR_20-1],\"--daemon\"))\n                            VAR_24=1;\n#ifdef VAR_17                      \n                      else if (!strcmp(argv[VAR_20-1],\"-VAR_25\") || !strcasecmp(argv[VAR_20-1],\"--VAR_26\"))\n                            VAR_27=1;\n#endif                      \n                      else if (!strcmp(argv[VAR_20-1],\"-VAR_28\") || !strcasecmp(argv[VAR_20-1],\"--VAR_29\"))\n                            VAR_29=1;    \n                          else {\n                              printf(\"%s requires an argument!\\n\",argv[VAR_20-1]);\n                              exit(VAR_21);\n                          }\n                      break;\n#ifdef VAR_11\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(VAR_30)<VAR_31) \n\t\t\t\t\tstrcpy(VAR_32,VAR_30);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(VAR_30)<VAR_31)\n               strcpy(VAR_33,VAR_30);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if VAR_14\n\t\t\tcase 1002:\n\t\t\t\tVAR_34=!VAR_34;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (VAR_30) VAR_24=atoi(VAR_30);\n\t\t\t\tbreak;\n#ifdef VAR_17\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { VAR_35=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) VAR_27=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) VAR_36=atol(optarg);\n\t\t\t\tbreak;\n#if VAR_16 || VAR_17\n            case 'F':\n                if (optarg) { \n                    if (VAR_37) fclose(VAR_37);\n                    VAR_37=fopen(optarg,\"a\"); \n                    if (!VAR_37) deinit(1, \"failed to open outfile\\n\");\n                    if (VAR_38) free(VAR_38);\n                    VAR_38=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef VAR_16\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) VAR_39=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef VAR_10\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<VAR_31)) strcpy(VAR_40,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    VAR_41=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) VAR_42=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) VAR_29=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    VAR_43=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t VAR_44=!VAR_44;\n            case 'a':\n                if (optarg) VAR_22=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { VAR_45=atol(optarg); }\n                break;\n#if VAR_15                \n            case 'T':\n                VAR_46=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) VAR_47=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) VAR_23=atoi(optarg);\n                break;\n            case 'u':\n                VAR_48=str2output_unit(optarg);\n                break;\n#if VAR_12 && VAR_13\n            case 'n':\n                if (optarg && (strlen(optarg)<VAR_31)) strcpy(VAR_49,optarg);\n                break;\n#endif                \n            case 'V':\n                VAR_50;\n                exit(VAR_51);\n                break;\n        }\n    }\n    if (VAR_42==NULL && VAR_22==1) VAR_22=2;\n#if VAR_15    \n    /* COMMENT_4 */\n    if (VAR_47==0) {\n        if (VAR_45<VAR_52/2) \n            VAR_47=VAR_52; \n        else  \n            VAR_47=(VAR_45*2)+1;\n    } else /* COMMENT_5 */\n        if (VAR_45*2>=VAR_47) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n#endif    \n\t if ((VAR_48==VAR_53 && !net_input_method(VAR_41)) || \n\t\t\t (VAR_48==VAR_54 && VAR_41==VAR_55)) \n\t\tVAR_48=VAR_56;\n    return;\n}",
  "func_graph_path": "vgropp/bwm-ng/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17/options.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -68,6 +68,10 @@\n         pwd_entry=getpwuid(getuid());\n         if (pwd_entry!=NULL) {\n             str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n+            if(!str) {\n+              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(pwd_entry->pw_dir)+14);\n+              exit(EXIT_FAILURE);\n+            }\n             snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n             read_config(str);\n             free(str);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            if(!str) {",
      "              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(pwd_entry->pw_dir)+14);",
      "              exit(EXIT_FAILURE);",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/vgropp/bwm-ng/pull/27",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/vgropp/bwm-ng/pull/27: 403 Client Error: Forbidden for url: https://api.github.com/repos/vgropp/bwm-ng/pulls/27",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}