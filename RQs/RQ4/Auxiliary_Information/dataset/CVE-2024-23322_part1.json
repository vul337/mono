{
  "cve_id": "CVE-2024-23322",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Fix crash when idle and request per try timeouts occur within backoff interval\n\nFix [CVE-2024-23322](https://github.com/envoyproxy/envoy/security/advisories/GHSA-6p83-mfmh-qv38)\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>\n\nSigned-off-by: yanavlasov <yavlasov@google.com>",
  "commit_hash": "843f9e6a123ed47ce139b421c14e7126f2ac685e",
  "git_url": "https://github.com/envoyproxy/envoy/commit/843f9e6a123ed47ce139b421c14e7126f2ac685e",
  "file_path": "source/common/router/router.cc",
  "func_name": "Filter::onSoftPerTryTimeout",
  "func_before": "void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  // Track this as a timeout for outlier detection purposes even though we didn't\n  // cancel the request yet and might get a 2xx later.\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          // Without any knowledge about what's going on in the connection pool, retry the request\n          // with the safest settings which is no early data but keep using or not using alt-svc as\n          // before. In this way, QUIC won't be falsely marked as broken.\n          doRetry(/*can_send_early_data*/ false, can_use_http3, TimeoutRetry::Yes);\n        });\n\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n\n      // Don't increment upstream_host->stats().rq_error_ here, we'll do that\n      // later if 1) we hit global timeout or 2) we get bad response headers\n      // back.\n      upstream_request.retried(true);\n\n      // TODO: cluster stat for hedge attempted.\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}",
  "abstract_func_before": "void Filter::onSoftPerTryTimeout(UpstreamRequest& VAR_0) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, VAR_0,\n                         absl::VAR_1<uint64_t>(enumToInt(VAR_2)));\n  VAR_0.outlierDetectionTimeoutRecorded(true);\n\n  if (!VAR_3 && VAR_4) {\n    RetryStatus VAR_5 = VAR_4->shouldHedgeRetryPerTryTimeout(\n        [this, VAR_6 = VAR_0.upstreamStreamOptions().can_use_http3_]() -> void {\n          /* COMMENT_2 */\n          /* COMMENT_3 */\n          /* COMMENT_4 */\n          doRetry(/* COMMENT_5 */ false, VAR_6, TimeoutRetry::Yes);\n        });\n\n    if (VAR_5 == RetryStatus::Yes) {\n      runRetryOptionsPredicates(VAR_0);\n      VAR_7++;\n\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      /* COMMENT_8 */\n      VAR_0.retried(true);\n\n      /* COMMENT_9 */\n    } else if (VAR_5 == RetryStatus::NoOverflow) {\n      VAR_8->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (VAR_5 == RetryStatus::NoRetryLimitExceeded) {\n      VAR_8->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}",
  "func_graph_path_before": "envoyproxy/envoy/843f9e6a123ed47ce139b421c14e7126f2ac685e/router.cc/vul/before/0.json",
  "func": "void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  ASSERT(!upstream_request.retried());\n  // Track this as a timeout for outlier detection purposes even though we didn't\n  // cancel the request yet and might get a 2xx later.\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          // Without any knowledge about what's going on in the connection pool, retry the request\n          // with the safest settings which is no early data but keep using or not using alt-svc as\n          // before. In this way, QUIC won't be falsely marked as broken.\n          doRetry(/*can_send_early_data*/ false, can_use_http3, TimeoutRetry::Yes);\n        });\n\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n\n      // Don't increment upstream_host->stats().rq_error_ here, we'll do that\n      // later if 1) we hit global timeout or 2) we get bad response headers\n      // back.\n      upstream_request.retried(true);\n\n      // TODO: cluster stat for hedge attempted.\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}",
  "abstract_func": "void Filter::onSoftPerTryTimeout(UpstreamRequest& VAR_0) {\n  ASSERT(!VAR_0.retried());\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, VAR_0,\n                         absl::VAR_1<uint64_t>(enumToInt(VAR_2)));\n  VAR_0.outlierDetectionTimeoutRecorded(true);\n\n  if (!VAR_3 && VAR_4) {\n    RetryStatus VAR_5 = VAR_4->shouldHedgeRetryPerTryTimeout(\n        [this, VAR_6 = VAR_0.upstreamStreamOptions().can_use_http3_]() -> void {\n          /* COMMENT_2 */\n          /* COMMENT_3 */\n          /* COMMENT_4 */\n          doRetry(/* COMMENT_5 */ false, VAR_6, TimeoutRetry::Yes);\n        });\n\n    if (VAR_5 == RetryStatus::Yes) {\n      runRetryOptionsPredicates(VAR_0);\n      VAR_7++;\n\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      /* COMMENT_8 */\n      VAR_0.retried(true);\n\n      /* COMMENT_9 */\n    } else if (VAR_5 == RetryStatus::NoOverflow) {\n      VAR_8->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (VAR_5 == RetryStatus::NoRetryLimitExceeded) {\n      VAR_8->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}",
  "func_graph_path": "envoyproxy/envoy/843f9e6a123ed47ce139b421c14e7126f2ac685e/router.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n+  ASSERT(!upstream_request.retried());\n   // Track this as a timeout for outlier detection purposes even though we didn't\n   // cancel the request yet and might get a 2xx later.\n   updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  ASSERT(!upstream_request.retried());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/32300",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/envoyproxy/envoy/pull/32300: 403 Client Error: Forbidden for url: https://api.github.com/repos/envoyproxy/envoy/pulls/32300",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}