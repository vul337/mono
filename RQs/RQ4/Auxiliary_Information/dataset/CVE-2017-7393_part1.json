{
  "cve_id": "CVE-2017-7393",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "TigerVNC/tigervnc",
  "commit_msg": "Prevent double free by crafted fences.\n\nIf client sent fence with some data, followed by fence with no data (length 0), the original fence data were freed, but the pointer kept pointing at them. Sending one more fence would attempt to free them again.",
  "commit_hash": "f3afa24da144409a3c3a0e35913112583d987671",
  "git_url": "https://github.com/TigerVNC/tigervnc/commit/f3afa24da144409a3c3a0e35913112583d987671",
  "file_path": "common/rfb/VNCSConnectionST.cxx",
  "func_name": "VNCSConnectionST::fence",
  "func_before": "void VNCSConnectionST::fence(rdr::U32 flags, unsigned len, const char data[])\n{\n  if (flags & fenceFlagRequest) {\n    if (flags & fenceFlagSyncNext) {\n      pendingSyncFence = true;\n\n      fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);\n      fenceDataLen = len;\n      delete [] fenceData;\n      if (len > 0) {\n        fenceData = new char[len];\n        memcpy(fenceData, data, len);\n      }\n\n      return;\n    }\n\n    // We handle everything synchronously so we trivially honor these modes\n    flags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter);\n\n    writer()->writeFence(flags, len, data);\n    return;\n  }\n\n  struct RTTInfo rttInfo;\n\n  switch (len) {\n  case 0:\n    // Initial dummy fence;\n    break;\n  case sizeof(struct RTTInfo):\n    memcpy(&rttInfo, data, sizeof(struct RTTInfo));\n    handleRTTPong(rttInfo);\n    break;\n  default:\n    vlog.error(\"Fence response of unexpected size received\");\n  }\n}",
  "abstract_func_before": "void VNCSConnectionST::fence(rdr::U32 VAR_0, unsigned VAR_1, const char VAR_2[])\n{\n  if (VAR_0 & VAR_3) {\n    if (VAR_0 & VAR_4) {\n      VAR_5 = true;\n\n      VAR_6 = VAR_0 & (VAR_7 | VAR_8 | VAR_4);\n      VAR_9 = VAR_1;\n      delete [] VAR_10;\n      if (VAR_1 > 0) {\n        VAR_10 = new char[VAR_1];\n        memcpy(VAR_10, VAR_2, VAR_1);\n      }\n\n      return;\n    }\n\n    /* COMMENT_0 */\n    VAR_0 = VAR_0 & (VAR_7 | VAR_8);\n\n    writer()->writeFence(VAR_0, VAR_1, VAR_2);\n    return;\n  }\n\n  struct RTTInfo VAR_11;\n\n  switch (VAR_1) {\n  case 0:\n    /* COMMENT_1 */\n    break;\n  case sizeof(struct RTTInfo):\n    memcpy(&VAR_11, VAR_2, sizeof(struct RTTInfo));\n    handleRTTPong(VAR_11);\n    break;\n  default:\n    VAR_12.error(\"Fence response of unexpected size received\");\n  }\n}",
  "func_graph_path_before": "TigerVNC/tigervnc/f3afa24da144409a3c3a0e35913112583d987671/VNCSConnectionST.cxx/vul/before/0.json",
  "func": "void VNCSConnectionST::fence(rdr::U32 flags, unsigned len, const char data[])\n{\n  if (flags & fenceFlagRequest) {\n    if (flags & fenceFlagSyncNext) {\n      pendingSyncFence = true;\n\n      fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);\n      fenceDataLen = len;\n      delete [] fenceData;\n      fenceData = NULL;\n      if (len > 0) {\n        fenceData = new char[len];\n        memcpy(fenceData, data, len);\n      }\n\n      return;\n    }\n\n    // We handle everything synchronously so we trivially honor these modes\n    flags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter);\n\n    writer()->writeFence(flags, len, data);\n    return;\n  }\n\n  struct RTTInfo rttInfo;\n\n  switch (len) {\n  case 0:\n    // Initial dummy fence;\n    break;\n  case sizeof(struct RTTInfo):\n    memcpy(&rttInfo, data, sizeof(struct RTTInfo));\n    handleRTTPong(rttInfo);\n    break;\n  default:\n    vlog.error(\"Fence response of unexpected size received\");\n  }\n}",
  "abstract_func": "void VNCSConnectionST::fence(rdr::U32 VAR_0, unsigned VAR_1, const char VAR_2[])\n{\n  if (VAR_0 & VAR_3) {\n    if (VAR_0 & VAR_4) {\n      VAR_5 = true;\n\n      VAR_6 = VAR_0 & (VAR_7 | VAR_8 | VAR_4);\n      VAR_9 = VAR_1;\n      delete [] VAR_10;\n      VAR_10 = NULL;\n      if (VAR_1 > 0) {\n        VAR_10 = new char[VAR_1];\n        memcpy(VAR_10, VAR_2, VAR_1);\n      }\n\n      return;\n    }\n\n    /* COMMENT_0 */\n    VAR_0 = VAR_0 & (VAR_7 | VAR_8);\n\n    writer()->writeFence(VAR_0, VAR_1, VAR_2);\n    return;\n  }\n\n  struct RTTInfo VAR_11;\n\n  switch (VAR_1) {\n  case 0:\n    /* COMMENT_1 */\n    break;\n  case sizeof(struct RTTInfo):\n    memcpy(&VAR_11, VAR_2, sizeof(struct RTTInfo));\n    handleRTTPong(VAR_11);\n    break;\n  default:\n    VAR_12.error(\"Fence response of unexpected size received\");\n  }\n}",
  "func_graph_path": "TigerVNC/tigervnc/f3afa24da144409a3c3a0e35913112583d987671/VNCSConnectionST.cxx/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n       fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);\n       fenceDataLen = len;\n       delete [] fenceData;\n+      fenceData = NULL;\n       if (len > 0) {\n         fenceData = new char[len];\n         memcpy(fenceData, data, len);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      fenceData = NULL;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/TigerVNC/tigervnc/pull/438",
  "description": {
    "pr_info": {
      "title": "Prevent double free by crafted fences.",
      "number": 438
    },
    "comment": [
      "If client sent fence with some data, followed by fence with no data (length 0), the original fence data were freed, but the pointer kept pointing at them. Sending one more fence would attempt to free them again.\r\n\r\nfixes #437 ",
      "This has been assigned CVE-2017-7393"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}