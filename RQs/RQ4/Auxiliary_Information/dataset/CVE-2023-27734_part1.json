{
  "cve_id": "CVE-2023-27734",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "eteran/edb-debugger",
  "commit_msg": "BinaryInfo: ensure sh_name lies within file\n\nThis fixes segfault on ELFs with malformed section headers (sh_name),\nsuch as one from https://github.com/eliben/pyelftools/issues/367",
  "commit_hash": "32f325f4016e0090f76934320173581860f090be",
  "git_url": "https://github.com/eteran/edb-debugger/commit/32f325f4016e0090f76934320173581860f090be",
  "file_path": "plugins/BinaryInfo/symbols.cpp",
  "func_name": "collect_symbols",
  "func_before": "void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) {\n\tQ_UNUSED(size)\n\n\tusing elf_addr   = typename M::elf_addr;\n\tusing elf_header = typename M::elf_header;\n\tusing elf_shdr   = typename M::elf_shdr;\n\tusing elf_sym    = typename M::elf_sym;\n\tusing elf_rela   = typename M::elf_rela;\n\tusing elf_rel    = typename M::elf_rel;\n\tusing symbol     = typename M::symbol;\n\n\tconst auto base = reinterpret_cast<uintptr_t>(p);\n\n\tconst auto header = static_cast<const elf_header *>(p);\n\tif (header->e_shnum == 0 || header->e_shentsize == 0) {\n\t\treturn;\n\t}\n\tconst auto sections_begin          = reinterpret_cast<elf_shdr *>(base + header->e_shoff);\n\tconst elf_shdr *const sections_end = sections_begin + header->e_shnum;\n\tauto section_strings               = reinterpret_cast<const char *>(base + sections_begin[header->e_shstrndx].sh_offset);\n\n\telf_addr plt_address = 0;\n\telf_addr got_address = 0;\n\tstd::set<elf_addr> plt_addresses;\n\n\t// collect special section addresses\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\t\tif (strcmp(&section_strings[section->sh_name], \".plt\") == 0) {\n\t\t\tplt_address = section->sh_addr;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".got\") == 0) {\n\t\t\tgot_address = section->sh_addr;\n\t\t}\n\t}\n\n\t// print out relocated symbols for special sections\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\t\telf_addr base_address = 0;\n\t\tif (strcmp(&section_strings[section->sh_name], \".rela.plt\") == 0) {\n\t\t\tbase_address = plt_address;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".rel.plt\") == 0) {\n\t\t\tbase_address = plt_address;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".rela.got\") == 0) {\n\t\t\tbase_address = got_address;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".rel.got\") == 0) {\n\t\t\tbase_address = got_address;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (section->sh_type) {\n\t\tcase SHT_RELA: {\n\t\t\telf_addr n      = 0;\n\t\t\tauto relocation = reinterpret_cast<elf_rela *>(base + section->sh_offset);\n\n\t\t\tif (section->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst size_t sym_index = M::elf_r_sym(relocation[i].r_info);\n\t\t\t\tconst elf_shdr *linked = &sections_begin[section->sh_link];\n\t\t\t\tauto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);\n\t\t\t\tauto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr symbol_address = base_address + ++n * M::plt_entry_size;\n\n\t\t\t\tconst char *sym_name = &section_strings[section->sh_name];\n\t\t\t\tif (strlen(sym_name) > (sizeof(\".rela.\") - 1) && memcmp(sym_name, \".rela.\", (sizeof(\".rela.\") - 1)) == 0) {\n\t\t\t\t\tsym_name += 6;\n\t\t\t\t}\n\n\t\t\t\tplt_addresses.insert(symbol_address);\n\n\t\t\t\tsymbol sym;\n\t\t\t\tsym.address = symbol_address;\n\t\t\t\tsym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);\n\t\t\t\tsym.name    = &string_tab[symbol_tab[sym_index].st_name];\n\t\t\t\tsym.name += \"@\";\n\t\t\t\tsym.name += sym_name;\n\t\t\t\tsym.type = 'P';\n\t\t\t\tsymbols.push_back(sym);\n\t\t\t}\n\t\t} break;\n\t\tcase SHT_REL: {\n\t\t\telf_addr n      = 0;\n\t\t\tauto relocation = reinterpret_cast<elf_rel *>(base + section->sh_offset);\n\n\t\t\tif (section->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst size_t sym_index = M::elf_r_sym(relocation[i].r_info);\n\t\t\t\tconst elf_shdr *linked = &sections_begin[section->sh_link];\n\t\t\t\tauto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);\n\t\t\t\tauto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr symbol_address = base_address + ++n * M::plt_entry_size;\n\n\t\t\t\tconst char *sym_name = &section_strings[section->sh_name];\n\t\t\t\tif (strlen(sym_name) > (sizeof(\".rel.\") - 1) && memcmp(sym_name, \".rel.\", (sizeof(\".rel.\") - 1)) == 0) {\n\t\t\t\t\tsym_name += 5;\n\t\t\t\t}\n\n\t\t\t\tplt_addresses.insert(symbol_address);\n\n\t\t\t\tsymbol sym;\n\t\t\t\tsym.address = symbol_address;\n\t\t\t\tsym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);\n\t\t\t\tsym.name    = &string_tab[symbol_tab[sym_index].st_name];\n\t\t\t\tsym.name += \"@\";\n\t\t\t\tsym.name += sym_name;\n\t\t\t\tsym.type = 'P';\n\t\t\t\tsymbols.push_back(sym);\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t// collect regular symbols\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\n\t\tswitch (section->sh_type) {\n\t\tcase SHT_SYMTAB:\n\t\tcase SHT_DYNSYM: {\n\t\t\tauto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);\n\t\t\tauto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst elf_shdr *related_section = nullptr;\n\n\t\t\t\tif (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {\n\t\t\t\t\trelated_section = &sections_begin[symbol_tab[i].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(related_section)\n\n\t\t\t\tif (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {\n\n\t\t\t\t\tif (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) > 0) {\n\n\t\t\t\t\t\tsymbol sym;\n\t\t\t\t\t\tsym.address = symbol_tab[i].st_value;\n\t\t\t\t\t\tsym.size    = symbol_tab[i].st_size;\n\t\t\t\t\t\tsym.name    = &string_tab[symbol_tab[i].st_name];\n\t\t\t\t\t\tsym.type    = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');\n\t\t\t\t\t\tsymbols.push_back(sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t// collect unnamed symbols\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\n\t\tswitch (section->sh_type) {\n\t\tcase SHT_SYMTAB:\n\t\tcase SHT_DYNSYM: {\n\t\t\tauto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);\n\t\t\tauto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst elf_shdr *related_section = nullptr;\n\n\t\t\t\tif (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {\n\t\t\t\t\trelated_section = &sections_begin[symbol_tab[i].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(related_section)\n\n\t\t\t\tif (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {\n\n\t\t\t\t\tif (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) == 0) {\n\t\t\t\t\t\tsymbol sym;\n\t\t\t\t\t\tsym.address = symbol_tab[i].st_value;\n\t\t\t\t\t\tsym.size    = symbol_tab[i].st_size;\n\n\t\t\t\t\t\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\t\t\t\t\t\t\tif (sym.address >= section->sh_addr && sym.address + sym.size <= section->sh_addr + section->sh_size) {\n\t\t\t\t\t\t\t\tconst std::int64_t offset = sym.address - section->sh_addr;\n\t\t\t\t\t\t\t\tconst QString hexPrefix   = std::abs(offset) > 9 ? \"0x\" : \"\";\n\t\t\t\t\t\t\t\tconst QString offsetStr   = offset ? \"+\" + hexPrefix + QString::number(offset, 16) : \"\";\n\t\t\t\t\t\t\t\tconst QString sectionName(&section_strings[section->sh_name]);\n\t\t\t\t\t\t\t\tif (!sectionName.isEmpty()) {\n\t\t\t\t\t\t\t\t\tsym.name = QString(sectionName + offsetStr);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (sym.name.isEmpty()) {\n\t\t\t\t\t\t\tsym.name = QString(\"$sym_%1\").arg(edb::v1::format_pointer(symbol_tab[i].st_value));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsym.type = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');\n\t\t\t\t\t\tsymbols.push_back(sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n}",
  "abstract_func_before": "void collect_symbols(const void *VAR_0, Size VAR_1, std::vector<typename M::symbol> &VAR_2) {\n\tQ_UNUSED(VAR_1)\n\n\tusing elf_addr   = typename M::elf_addr;\n\tusing elf_header = typename M::elf_header;\n\tusing elf_shdr   = typename M::elf_shdr;\n\tusing elf_sym    = typename M::elf_sym;\n\tusing elf_rela   = typename M::elf_rela;\n\tusing elf_rel    = typename M::elf_rel;\n\tusing symbol     = typename M::symbol;\n\n\tconst auto VAR_3 = VAR_4<uintptr_t>(VAR_0);\n\n\tconst auto VAR_5 = VAR_6<const elf_header *>(VAR_0);\n\tif (VAR_5->e_shnum == 0 || VAR_5->e_shentsize == 0) {\n\t\treturn;\n\t}\n\tconst auto VAR_7          = VAR_4<elf_shdr *>(VAR_3 + VAR_5->e_shoff);\n\tconst elf_shdr *const VAR_8 = VAR_7 + VAR_5->e_shnum;\n\tauto VAR_9               = VAR_4<const char *>(VAR_3 + VAR_7[VAR_5->e_shstrndx].sh_offset);\n\n\telf_addr VAR_10 = 0;\n\telf_addr VAR_11 = 0;\n\tstd::set<elf_addr> VAR_12;\n\n\t/* COMMENT_0 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\t\tif (strcmp(&VAR_9[VAR_13->sh_name], \".plt\") == 0) {\n\t\t\tVAR_10 = VAR_13->sh_addr;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".got\") == 0) {\n\t\t\tVAR_11 = VAR_13->sh_addr;\n\t\t}\n\t}\n\n\t/* COMMENT_1 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\t\telf_addr VAR_14 = 0;\n\t\tif (strcmp(&VAR_9[VAR_13->sh_name], \".rela.plt\") == 0) {\n\t\t\tVAR_14 = VAR_10;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".rel.plt\") == 0) {\n\t\t\tVAR_14 = VAR_10;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".rela.got\") == 0) {\n\t\t\tVAR_14 = VAR_11;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".rel.got\") == 0) {\n\t\t\tVAR_14 = VAR_11;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (VAR_13->sh_type) {\n\t\tcase VAR_15: {\n\t\t\telf_addr VAR_16      = 0;\n\t\t\tauto VAR_17 = VAR_4<elf_rela *>(VAR_3 + VAR_13->sh_offset);\n\n\t\t\tif (VAR_13->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst size_t VAR_19 = M::elf_r_sym(VAR_17[VAR_18].r_info);\n\t\t\t\tconst elf_shdr *VAR_20 = &VAR_7[VAR_13->sh_link];\n\t\t\t\tauto VAR_21        = VAR_4<elf_sym *>(VAR_3 + VAR_20->sh_offset);\n\t\t\t\tauto VAR_22        = VAR_4<const char *>(VAR_3 + VAR_7[VAR_20->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr VAR_23 = VAR_14 + ++VAR_16 * M::plt_entry_size;\n\n\t\t\t\tconst char *VAR_24 = &VAR_9[VAR_13->sh_name];\n\t\t\t\tif (strlen(VAR_24) > (sizeof(\".rela.\") - 1) && memcmp(VAR_24, \".rela.\", (sizeof(\".rela.\") - 1)) == 0) {\n\t\t\t\t\tVAR_24 += 6;\n\t\t\t\t}\n\n\t\t\t\tVAR_12.insert(VAR_23);\n\n\t\t\t\tsymbol VAR_25;\n\t\t\t\tVAR_25.address = VAR_23;\n\t\t\t\tVAR_25.size    = (VAR_21[VAR_19].st_size ? VAR_21[VAR_19].st_size : 0x10);\n\t\t\t\tVAR_25.name    = &VAR_22[VAR_21[VAR_19].st_name];\n\t\t\t\tVAR_25.name += \"@\";\n\t\t\t\tVAR_25.name += VAR_24;\n\t\t\t\tVAR_25.type = 'P';\n\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t}\n\t\t} break;\n\t\tcase VAR_26: {\n\t\t\telf_addr VAR_16      = 0;\n\t\t\tauto VAR_17 = VAR_4<elf_rel *>(VAR_3 + VAR_13->sh_offset);\n\n\t\t\tif (VAR_13->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst size_t VAR_19 = M::elf_r_sym(VAR_17[VAR_18].r_info);\n\t\t\t\tconst elf_shdr *VAR_20 = &VAR_7[VAR_13->sh_link];\n\t\t\t\tauto VAR_21        = VAR_4<elf_sym *>(VAR_3 + VAR_20->sh_offset);\n\t\t\t\tauto VAR_22        = VAR_4<const char *>(VAR_3 + VAR_7[VAR_20->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr VAR_23 = VAR_14 + ++VAR_16 * M::plt_entry_size;\n\n\t\t\t\tconst char *VAR_24 = &VAR_9[VAR_13->sh_name];\n\t\t\t\tif (strlen(VAR_24) > (sizeof(\".rel.\") - 1) && memcmp(VAR_24, \".rel.\", (sizeof(\".rel.\") - 1)) == 0) {\n\t\t\t\t\tVAR_24 += 5;\n\t\t\t\t}\n\n\t\t\t\tVAR_12.insert(VAR_23);\n\n\t\t\t\tsymbol VAR_25;\n\t\t\t\tVAR_25.address = VAR_23;\n\t\t\t\tVAR_25.size    = (VAR_21[VAR_19].st_size ? VAR_21[VAR_19].st_size : 0x10);\n\t\t\t\tVAR_25.name    = &VAR_22[VAR_21[VAR_19].st_name];\n\t\t\t\tVAR_25.name += \"@\";\n\t\t\t\tVAR_25.name += VAR_24;\n\t\t\t\tVAR_25.type = 'P';\n\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t/* COMMENT_2 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\n\t\tswitch (VAR_13->sh_type) {\n\t\tcase VAR_27:\n\t\tcase VAR_28: {\n\t\t\tauto VAR_21 = VAR_4<elf_sym *>(VAR_3 + VAR_13->sh_offset);\n\t\t\tauto VAR_22 = VAR_4<const char *>(VAR_3 + VAR_7[VAR_13->sh_link].sh_offset);\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst elf_shdr *VAR_29 = nullptr;\n\n\t\t\t\tif (VAR_21[VAR_18].st_shndx != VAR_30 && VAR_21[VAR_18].st_shndx < VAR_31) {\n\t\t\t\t\tVAR_29 = &VAR_7[VAR_21[VAR_18].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(VAR_29)\n\n\t\t\t\tif (VAR_12.find(VAR_21[VAR_18].st_value) == VAR_12.end()) {\n\n\t\t\t\t\tif (VAR_21[VAR_18].st_value && strlen(&VAR_22[VAR_21[VAR_18].st_name]) > 0) {\n\n\t\t\t\t\t\tsymbol VAR_25;\n\t\t\t\t\t\tVAR_25.address = VAR_21[VAR_18].st_value;\n\t\t\t\t\t\tVAR_25.size    = VAR_21[VAR_18].st_size;\n\t\t\t\t\t\tVAR_25.name    = &VAR_22[VAR_21[VAR_18].st_name];\n\t\t\t\t\t\tVAR_25.type    = (M::elf_st_type(VAR_21[VAR_18].st_info) == VAR_32 ? 'T' : 'D');\n\t\t\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t/* COMMENT_3 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\n\t\tswitch (VAR_13->sh_type) {\n\t\tcase VAR_27:\n\t\tcase VAR_28: {\n\t\t\tauto VAR_21 = VAR_4<elf_sym *>(VAR_3 + VAR_13->sh_offset);\n\t\t\tauto VAR_22 = VAR_4<const char *>(VAR_3 + VAR_7[VAR_13->sh_link].sh_offset);\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst elf_shdr *VAR_29 = nullptr;\n\n\t\t\t\tif (VAR_21[VAR_18].st_shndx != VAR_30 && VAR_21[VAR_18].st_shndx < VAR_31) {\n\t\t\t\t\tVAR_29 = &VAR_7[VAR_21[VAR_18].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(VAR_29)\n\n\t\t\t\tif (VAR_12.find(VAR_21[VAR_18].st_value) == VAR_12.end()) {\n\n\t\t\t\t\tif (VAR_21[VAR_18].st_value && strlen(&VAR_22[VAR_21[VAR_18].st_name]) == 0) {\n\t\t\t\t\t\tsymbol VAR_25;\n\t\t\t\t\t\tVAR_25.address = VAR_21[VAR_18].st_value;\n\t\t\t\t\t\tVAR_25.size    = VAR_21[VAR_18].st_size;\n\n\t\t\t\t\t\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\t\t\t\t\t\t\tif (VAR_25.address >= VAR_13->sh_addr && VAR_25.address + VAR_25.size <= VAR_13->sh_addr + VAR_13->sh_size) {\n\t\t\t\t\t\t\t\tconst std::int64_t VAR_33 = VAR_25.address - VAR_13->sh_addr;\n\t\t\t\t\t\t\t\tconst QString VAR_34   = std::abs(VAR_33) > 9 ? \"0x\" : \"\";\n\t\t\t\t\t\t\t\tconst QString VAR_35   = VAR_33 ? \"+\" + VAR_34 + QString::number(VAR_33, 16) : \"\";\n\t\t\t\t\t\t\t\tconst QString VAR_36(&VAR_9[VAR_13->sh_name]);\n\t\t\t\t\t\t\t\tif (!VAR_36.isEmpty()) {\n\t\t\t\t\t\t\t\t\tVAR_25.name = QString(VAR_36 + VAR_35);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (VAR_25.name.isEmpty()) {\n\t\t\t\t\t\t\tVAR_25.name = QString(\"$sym_%1\").arg(edb::v1::format_pointer(VAR_21[VAR_18].st_value));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVAR_25.type = (M::elf_st_type(VAR_21[VAR_18].st_info) == VAR_32 ? 'T' : 'D');\n\t\t\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n}",
  "func_graph_path_before": "eteran/edb-debugger/32f325f4016e0090f76934320173581860f090be/symbols.cpp/vul/before/0.json",
  "func": "void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) {\n\n\tusing elf_addr   = typename M::elf_addr;\n\tusing elf_header = typename M::elf_header;\n\tusing elf_shdr   = typename M::elf_shdr;\n\tusing elf_sym    = typename M::elf_sym;\n\tusing elf_rela   = typename M::elf_rela;\n\tusing elf_rel    = typename M::elf_rel;\n\tusing symbol     = typename M::symbol;\n\n\tconst auto base = reinterpret_cast<uintptr_t>(p);\n\n\tconst auto header = static_cast<const elf_header *>(p);\n\tif (header->e_shnum == 0 || header->e_shentsize == 0) {\n\t\treturn;\n\t}\n\tconst auto sections_begin          = reinterpret_cast<elf_shdr *>(base + header->e_shoff);\n\tconst elf_shdr *const sections_end = sections_begin + header->e_shnum;\n\tauto section_strings               = reinterpret_cast<const char *>(base + sections_begin[header->e_shstrndx].sh_offset);\n\n\telf_addr plt_address = 0;\n\telf_addr got_address = 0;\n\tstd::set<elf_addr> plt_addresses;\n\n\t// collect special section addresses\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\t\tif (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(&section_strings[section->sh_name], \".plt\") == 0) {\n\t\t\tplt_address = section->sh_addr;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".got\") == 0) {\n\t\t\tgot_address = section->sh_addr;\n\t\t}\n\t}\n\n\t// print out relocated symbols for special sections\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\t\tif (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\telf_addr base_address = 0;\n\t\tif (strcmp(&section_strings[section->sh_name], \".rela.plt\") == 0) {\n\t\t\tbase_address = plt_address;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".rel.plt\") == 0) {\n\t\t\tbase_address = plt_address;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".rela.got\") == 0) {\n\t\t\tbase_address = got_address;\n\t\t} else if (strcmp(&section_strings[section->sh_name], \".rel.got\") == 0) {\n\t\t\tbase_address = got_address;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (section->sh_type) {\n\t\tcase SHT_RELA: {\n\t\t\telf_addr n      = 0;\n\t\t\tauto relocation = reinterpret_cast<elf_rela *>(base + section->sh_offset);\n\n\t\t\tif (section->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst size_t sym_index = M::elf_r_sym(relocation[i].r_info);\n\t\t\t\tconst elf_shdr *linked = &sections_begin[section->sh_link];\n\t\t\t\tauto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);\n\t\t\t\tauto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr symbol_address = base_address + ++n * M::plt_entry_size;\n\n\t\t\t\tconst char *sym_name = &section_strings[section->sh_name];\n\t\t\t\tif (strlen(sym_name) > (sizeof(\".rela.\") - 1) && memcmp(sym_name, \".rela.\", (sizeof(\".rela.\") - 1)) == 0) {\n\t\t\t\t\tsym_name += 6;\n\t\t\t\t}\n\n\t\t\t\tplt_addresses.insert(symbol_address);\n\n\t\t\t\tsymbol sym;\n\t\t\t\tsym.address = symbol_address;\n\t\t\t\tsym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);\n\t\t\t\tsym.name    = &string_tab[symbol_tab[sym_index].st_name];\n\t\t\t\tsym.name += \"@\";\n\t\t\t\tsym.name += sym_name;\n\t\t\t\tsym.type = 'P';\n\t\t\t\tsymbols.push_back(sym);\n\t\t\t}\n\t\t} break;\n\t\tcase SHT_REL: {\n\t\t\telf_addr n      = 0;\n\t\t\tauto relocation = reinterpret_cast<elf_rel *>(base + section->sh_offset);\n\n\t\t\tif (section->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst size_t sym_index = M::elf_r_sym(relocation[i].r_info);\n\t\t\t\tconst elf_shdr *linked = &sections_begin[section->sh_link];\n\t\t\t\tauto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);\n\t\t\t\tauto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr symbol_address = base_address + ++n * M::plt_entry_size;\n\n\t\t\t\tconst char *sym_name = &section_strings[section->sh_name];\n\t\t\t\tif (strlen(sym_name) > (sizeof(\".rel.\") - 1) && memcmp(sym_name, \".rel.\", (sizeof(\".rel.\") - 1)) == 0) {\n\t\t\t\t\tsym_name += 5;\n\t\t\t\t}\n\n\t\t\t\tplt_addresses.insert(symbol_address);\n\n\t\t\t\tsymbol sym;\n\t\t\t\tsym.address = symbol_address;\n\t\t\t\tsym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);\n\t\t\t\tsym.name    = &string_tab[symbol_tab[sym_index].st_name];\n\t\t\t\tsym.name += \"@\";\n\t\t\t\tsym.name += sym_name;\n\t\t\t\tsym.type = 'P';\n\t\t\t\tsymbols.push_back(sym);\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t// collect regular symbols\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\n\t\tswitch (section->sh_type) {\n\t\tcase SHT_SYMTAB:\n\t\tcase SHT_DYNSYM: {\n\t\t\tauto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);\n\t\t\tauto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst elf_shdr *related_section = nullptr;\n\n\t\t\t\tif (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {\n\t\t\t\t\trelated_section = &sections_begin[symbol_tab[i].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(related_section)\n\n\t\t\t\tif (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {\n\n\t\t\t\t\tif (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) > 0) {\n\n\t\t\t\t\t\tsymbol sym;\n\t\t\t\t\t\tsym.address = symbol_tab[i].st_value;\n\t\t\t\t\t\tsym.size    = symbol_tab[i].st_size;\n\t\t\t\t\t\tsym.name    = &string_tab[symbol_tab[i].st_name];\n\t\t\t\t\t\tsym.type    = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');\n\t\t\t\t\t\tsymbols.push_back(sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t// collect unnamed symbols\n\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\n\t\tswitch (section->sh_type) {\n\t\tcase SHT_SYMTAB:\n\t\tcase SHT_DYNSYM: {\n\t\t\tauto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);\n\t\t\tauto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);\n\n\t\t\tfor (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {\n\n\t\t\t\tconst elf_shdr *related_section = nullptr;\n\n\t\t\t\tif (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {\n\t\t\t\t\trelated_section = &sections_begin[symbol_tab[i].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(related_section)\n\n\t\t\t\tif (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {\n\n\t\t\t\t\tif (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) == 0) {\n\t\t\t\t\t\tsymbol sym;\n\t\t\t\t\t\tsym.address = symbol_tab[i].st_value;\n\t\t\t\t\t\tsym.size    = symbol_tab[i].st_size;\n\n\t\t\t\t\t\tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n\t\t\t\t\t\t\tif (sym.address >= section->sh_addr && sym.address + sym.size <= section->sh_addr + section->sh_size) {\n\t\t\t\t\t\t\t\tconst std::int64_t offset = sym.address - section->sh_addr;\n\t\t\t\t\t\t\t\tconst QString hexPrefix   = std::abs(offset) > 9 ? \"0x\" : \"\";\n\t\t\t\t\t\t\t\tconst QString offsetStr   = offset ? \"+\" + hexPrefix + QString::number(offset, 16) : \"\";\n\t\t\t\t\t\t\t\tconst QString sectionName(&section_strings[section->sh_name]);\n\t\t\t\t\t\t\t\tif (!sectionName.isEmpty()) {\n\t\t\t\t\t\t\t\t\tsym.name = QString(sectionName + offsetStr);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (sym.name.isEmpty()) {\n\t\t\t\t\t\t\tsym.name = QString(\"$sym_%1\").arg(edb::v1::format_pointer(symbol_tab[i].st_value));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsym.type = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');\n\t\t\t\t\t\tsymbols.push_back(sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n}",
  "abstract_func": "void collect_symbols(const void *VAR_0, Size VAR_1, std::vector<typename M::symbol> &VAR_2) {\n\n\tusing elf_addr   = typename M::elf_addr;\n\tusing elf_header = typename M::elf_header;\n\tusing elf_shdr   = typename M::elf_shdr;\n\tusing elf_sym    = typename M::elf_sym;\n\tusing elf_rela   = typename M::elf_rela;\n\tusing elf_rel    = typename M::elf_rel;\n\tusing symbol     = typename M::symbol;\n\n\tconst auto VAR_3 = VAR_4<uintptr_t>(VAR_0);\n\n\tconst auto VAR_5 = VAR_6<const elf_header *>(VAR_0);\n\tif (VAR_5->e_shnum == 0 || VAR_5->e_shentsize == 0) {\n\t\treturn;\n\t}\n\tconst auto VAR_7          = VAR_4<elf_shdr *>(VAR_3 + VAR_5->e_shoff);\n\tconst elf_shdr *const VAR_8 = VAR_7 + VAR_5->e_shnum;\n\tauto VAR_9               = VAR_4<const char *>(VAR_3 + VAR_7[VAR_5->e_shstrndx].sh_offset);\n\n\telf_addr VAR_10 = 0;\n\telf_addr VAR_11 = 0;\n\tstd::set<elf_addr> VAR_12;\n\n\t/* COMMENT_0 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\t\tif (VAR_9 + VAR_13->sh_name < (void *)VAR_3 || VAR_9 + VAR_13->sh_name > (void *)(VAR_3 + VAR_1)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(&VAR_9[VAR_13->sh_name], \".plt\") == 0) {\n\t\t\tVAR_10 = VAR_13->sh_addr;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".got\") == 0) {\n\t\t\tVAR_11 = VAR_13->sh_addr;\n\t\t}\n\t}\n\n\t/* COMMENT_1 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\t\tif (VAR_9 + VAR_13->sh_name < (void *)VAR_3 || VAR_9 + VAR_13->sh_name > (void *)(VAR_3 + VAR_1)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\telf_addr VAR_14 = 0;\n\t\tif (strcmp(&VAR_9[VAR_13->sh_name], \".rela.plt\") == 0) {\n\t\t\tVAR_14 = VAR_10;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".rel.plt\") == 0) {\n\t\t\tVAR_14 = VAR_10;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".rela.got\") == 0) {\n\t\t\tVAR_14 = VAR_11;\n\t\t} else if (strcmp(&VAR_9[VAR_13->sh_name], \".rel.got\") == 0) {\n\t\t\tVAR_14 = VAR_11;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (VAR_13->sh_type) {\n\t\tcase VAR_15: {\n\t\t\telf_addr VAR_16      = 0;\n\t\t\tauto VAR_17 = VAR_4<elf_rela *>(VAR_3 + VAR_13->sh_offset);\n\n\t\t\tif (VAR_13->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst size_t VAR_19 = M::elf_r_sym(VAR_17[VAR_18].r_info);\n\t\t\t\tconst elf_shdr *VAR_20 = &VAR_7[VAR_13->sh_link];\n\t\t\t\tauto VAR_21        = VAR_4<elf_sym *>(VAR_3 + VAR_20->sh_offset);\n\t\t\t\tauto VAR_22        = VAR_4<const char *>(VAR_3 + VAR_7[VAR_20->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr VAR_23 = VAR_14 + ++VAR_16 * M::plt_entry_size;\n\n\t\t\t\tconst char *VAR_24 = &VAR_9[VAR_13->sh_name];\n\t\t\t\tif (strlen(VAR_24) > (sizeof(\".rela.\") - 1) && memcmp(VAR_24, \".rela.\", (sizeof(\".rela.\") - 1)) == 0) {\n\t\t\t\t\tVAR_24 += 6;\n\t\t\t\t}\n\n\t\t\t\tVAR_12.insert(VAR_23);\n\n\t\t\t\tsymbol VAR_25;\n\t\t\t\tVAR_25.address = VAR_23;\n\t\t\t\tVAR_25.size    = (VAR_21[VAR_19].st_size ? VAR_21[VAR_19].st_size : 0x10);\n\t\t\t\tVAR_25.name    = &VAR_22[VAR_21[VAR_19].st_name];\n\t\t\t\tVAR_25.name += \"@\";\n\t\t\t\tVAR_25.name += VAR_24;\n\t\t\t\tVAR_25.type = 'P';\n\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t}\n\t\t} break;\n\t\tcase VAR_26: {\n\t\t\telf_addr VAR_16      = 0;\n\t\t\tauto VAR_17 = VAR_4<elf_rel *>(VAR_3 + VAR_13->sh_offset);\n\n\t\t\tif (VAR_13->sh_link == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst size_t VAR_19 = M::elf_r_sym(VAR_17[VAR_18].r_info);\n\t\t\t\tconst elf_shdr *VAR_20 = &VAR_7[VAR_13->sh_link];\n\t\t\t\tauto VAR_21        = VAR_4<elf_sym *>(VAR_3 + VAR_20->sh_offset);\n\t\t\t\tauto VAR_22        = VAR_4<const char *>(VAR_3 + VAR_7[VAR_20->sh_link].sh_offset);\n\n\t\t\t\tconst elf_addr VAR_23 = VAR_14 + ++VAR_16 * M::plt_entry_size;\n\n\t\t\t\tconst char *VAR_24 = &VAR_9[VAR_13->sh_name];\n\t\t\t\tif (strlen(VAR_24) > (sizeof(\".rel.\") - 1) && memcmp(VAR_24, \".rel.\", (sizeof(\".rel.\") - 1)) == 0) {\n\t\t\t\t\tVAR_24 += 5;\n\t\t\t\t}\n\n\t\t\t\tVAR_12.insert(VAR_23);\n\n\t\t\t\tsymbol VAR_25;\n\t\t\t\tVAR_25.address = VAR_23;\n\t\t\t\tVAR_25.size    = (VAR_21[VAR_19].st_size ? VAR_21[VAR_19].st_size : 0x10);\n\t\t\t\tVAR_25.name    = &VAR_22[VAR_21[VAR_19].st_name];\n\t\t\t\tVAR_25.name += \"@\";\n\t\t\t\tVAR_25.name += VAR_24;\n\t\t\t\tVAR_25.type = 'P';\n\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t/* COMMENT_2 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\n\t\tswitch (VAR_13->sh_type) {\n\t\tcase VAR_27:\n\t\tcase VAR_28: {\n\t\t\tauto VAR_21 = VAR_4<elf_sym *>(VAR_3 + VAR_13->sh_offset);\n\t\t\tauto VAR_22 = VAR_4<const char *>(VAR_3 + VAR_7[VAR_13->sh_link].sh_offset);\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst elf_shdr *VAR_29 = nullptr;\n\n\t\t\t\tif (VAR_21[VAR_18].st_shndx != VAR_30 && VAR_21[VAR_18].st_shndx < VAR_31) {\n\t\t\t\t\tVAR_29 = &VAR_7[VAR_21[VAR_18].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(VAR_29)\n\n\t\t\t\tif (VAR_12.find(VAR_21[VAR_18].st_value) == VAR_12.end()) {\n\n\t\t\t\t\tif (VAR_21[VAR_18].st_value && strlen(&VAR_22[VAR_21[VAR_18].st_name]) > 0) {\n\n\t\t\t\t\t\tsymbol VAR_25;\n\t\t\t\t\t\tVAR_25.address = VAR_21[VAR_18].st_value;\n\t\t\t\t\t\tVAR_25.size    = VAR_21[VAR_18].st_size;\n\t\t\t\t\t\tVAR_25.name    = &VAR_22[VAR_21[VAR_18].st_name];\n\t\t\t\t\t\tVAR_25.type    = (M::elf_st_type(VAR_21[VAR_18].st_info) == VAR_32 ? 'T' : 'D');\n\t\t\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\t/* COMMENT_3 */\n\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\n\t\tswitch (VAR_13->sh_type) {\n\t\tcase VAR_27:\n\t\tcase VAR_28: {\n\t\t\tauto VAR_21 = VAR_4<elf_sym *>(VAR_3 + VAR_13->sh_offset);\n\t\t\tauto VAR_22 = VAR_4<const char *>(VAR_3 + VAR_7[VAR_13->sh_link].sh_offset);\n\n\t\t\tfor (size_t VAR_18 = 0; VAR_18 < VAR_13->sh_size / VAR_13->sh_entsize; ++VAR_18) {\n\n\t\t\t\tconst elf_shdr *VAR_29 = nullptr;\n\n\t\t\t\tif (VAR_21[VAR_18].st_shndx != VAR_30 && VAR_21[VAR_18].st_shndx < VAR_31) {\n\t\t\t\t\tVAR_29 = &VAR_7[VAR_21[VAR_18].st_shndx];\n\t\t\t\t}\n\n\t\t\t\tQ_UNUSED(VAR_29)\n\n\t\t\t\tif (VAR_12.find(VAR_21[VAR_18].st_value) == VAR_12.end()) {\n\n\t\t\t\t\tif (VAR_21[VAR_18].st_value && strlen(&VAR_22[VAR_21[VAR_18].st_name]) == 0) {\n\t\t\t\t\t\tsymbol VAR_25;\n\t\t\t\t\t\tVAR_25.address = VAR_21[VAR_18].st_value;\n\t\t\t\t\t\tVAR_25.size    = VAR_21[VAR_18].st_size;\n\n\t\t\t\t\t\tfor (const elf_shdr *VAR_13 = VAR_7; VAR_13 != VAR_8; ++VAR_13) {\n\t\t\t\t\t\t\tif (VAR_25.address >= VAR_13->sh_addr && VAR_25.address + VAR_25.size <= VAR_13->sh_addr + VAR_13->sh_size) {\n\t\t\t\t\t\t\t\tconst std::int64_t VAR_33 = VAR_25.address - VAR_13->sh_addr;\n\t\t\t\t\t\t\t\tconst QString VAR_34   = std::abs(VAR_33) > 9 ? \"0x\" : \"\";\n\t\t\t\t\t\t\t\tconst QString VAR_35   = VAR_33 ? \"+\" + VAR_34 + QString::number(VAR_33, 16) : \"\";\n\t\t\t\t\t\t\t\tconst QString VAR_36(&VAR_9[VAR_13->sh_name]);\n\t\t\t\t\t\t\t\tif (!VAR_36.isEmpty()) {\n\t\t\t\t\t\t\t\t\tVAR_25.name = QString(VAR_36 + VAR_35);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (VAR_25.name.isEmpty()) {\n\t\t\t\t\t\t\tVAR_25.name = QString(\"$sym_%1\").arg(edb::v1::format_pointer(VAR_21[VAR_18].st_value));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVAR_25.type = (M::elf_st_type(VAR_21[VAR_18].st_info) == VAR_32 ? 'T' : 'D');\n\t\t\t\t\t\tVAR_2.push_back(VAR_25);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n}",
  "func_graph_path": "eteran/edb-debugger/32f325f4016e0090f76934320173581860f090be/symbols.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,4 @@\n void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) {\n-\tQ_UNUSED(size)\n \n \tusing elf_addr   = typename M::elf_addr;\n \tusing elf_header = typename M::elf_header;\n@@ -25,6 +24,10 @@\n \n \t// collect special section addresses\n \tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n+\t\tif (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tif (strcmp(&section_strings[section->sh_name], \".plt\") == 0) {\n \t\t\tplt_address = section->sh_addr;\n \t\t} else if (strcmp(&section_strings[section->sh_name], \".got\") == 0) {\n@@ -34,6 +37,10 @@\n \n \t// print out relocated symbols for special sections\n \tfor (const elf_shdr *section = sections_begin; section != sections_end; ++section) {\n+\t\tif (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {\n+\t\t\tcontinue;\n+\t\t}\n+\t\t\t\n \t\telf_addr base_address = 0;\n \t\tif (strcmp(&section_strings[section->sh_name], \".rela.plt\") == 0) {\n \t\t\tbase_address = plt_address;",
  "diff_line_info": {
    "deleted_lines": [
      "\tQ_UNUSED(size)"
    ],
    "added_lines": [
      "\t\tif (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {",
      "\t\t\tcontinue;",
      "\t\t}",
      "",
      "\t\tif (section_strings + section->sh_name < (void *)base || section_strings + section->sh_name > (void *)(base + size)) {",
      "\t\t\tcontinue;",
      "\t\t}",
      "\t\t\t"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eteran/edb-debugger/pull/834",
  "description": {
    "pr_info": {
      "title": "Fix some BinaryInfo crashes",
      "number": 834
    },
    "comment": [
      "Hello! been playing with SHT fuzzing and found a couple of crashes on broken sections.\r\n\r\nThe first crash happens when `section_strings[section->sh_name]` is not a valid address, the second one happens when trying to iterate over entries in some sections with `sh_entsize` set to 0. \r\nMeanwhile, those malformed files run happily in the OS itself."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\n**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis**: The commit fixes a segfault caused by malformed section headers in ELFs, referencing an issue that causes crashes.\n2. **Vulnerability Description**: Points out crashes due to invalid memory accesses from malformed sections, indicating a potential security issue.\n3. **Code Diff Details**: Added bounds checking to prevent accessing invalid memory, a security fix.\n4. **Consistency**: All elements (message, issue, code) align to address a security exploit.\n\n**Conclusion**: The patch is a security fix, with high confidence."
}