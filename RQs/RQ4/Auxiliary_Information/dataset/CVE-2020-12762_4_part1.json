{
  "cve_id": "CVE-2020-12762",
  "cwe_ids": [
    "CWE-190",
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "json-c",
  "commit_msg": "Fix integer overflows.\n\nThe data structures linkhash and printbuf are limited to 2 GB in size\ndue to a signed integer being used to track their current size.\n\nIf too much data is added, then size variable can overflow, which is\nan undefined behaviour in C programming language.\n\nAssuming that a signed int overflow just leads to a negative value,\nlike it happens on many sytems (Linux i686/amd64 with gcc), then\nprintbuf is vulnerable to an out of boundary write on 64 bit systems.",
  "commit_hash": "d07b91014986900a3a75f306d302e13e005e9d67",
  "git_url": "https://github.com/json-c/json-c/commit/d07b91014986900a3a75f306d302e13e005e9d67",
  "file_path": "printbuf.c",
  "func_name": "printbuf_extend",
  "func_before": "static int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\n\tnew_size = p->size * 2;\n\tif (new_size < min_size + 8)\n\t\tnew_size = min_size + 8;\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\"printbuf_memappend: realloc \"\n\t         \"bpos=%d min_size=%d old_size=%d new_size=%d\\n\",\n\t         p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif (!(t = (char *)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}",
  "abstract_func_before": "static int printbuf_extend(struct printbuf *VAR_0, int VAR_1)\n{\n\tchar *VAR_2;\n\tint VAR_3;\n\n\tif (VAR_0->size >= VAR_1)\n\t\treturn 0;\n\n\tVAR_3 = VAR_0->size * 2;\n\tif (VAR_3 < VAR_1 + 8)\n\t\tVAR_3 = VAR_1 + 8;\n#ifdef VAR_4\n\tMC_DEBUG(\"printbuf_memappend: realloc \"\n\t         \"bpos=%d min_size=%d old_size=%d new_size=%d\\n\",\n\t         VAR_0->bpos, VAR_1, VAR_0->size, VAR_3);\n#endif /* COMMENT_0 */\n\tif (!(VAR_2 = (char *)realloc(VAR_0->buf, VAR_3)))\n\t\treturn -1;\n\tVAR_0->size = VAR_3;\n\tVAR_0->buf = VAR_2;\n\treturn 0;\n}",
  "func_graph_path_before": "json-c/d07b91014986900a3a75f306d302e13e005e9d67/printbuf.c/vul/before/0.json",
  "func": "static int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (min_size > INT_MAX - 8)\n\t\treturn -1;\n\tif (p->size > INT_MAX / 2)\n\t\tnew_size = min_size + 8;\n\telse {\n\t\tnew_size = p->size * 2;\n\t\tif (new_size < min_size + 8)\n\t\t\tnew_size = min_size + 8;\n\t}\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\"printbuf_memappend: realloc \"\n\t         \"bpos=%d min_size=%d old_size=%d new_size=%d\\n\",\n\t         p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif (!(t = (char *)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}",
  "abstract_func": "static int printbuf_extend(struct printbuf *VAR_0, int VAR_1)\n{\n\tchar *VAR_2;\n\tint VAR_3;\n\n\tif (VAR_0->size >= VAR_1)\n\t\treturn 0;\n\t/* COMMENT_0 */\n\tif (VAR_1 > VAR_4 - 8)\n\t\treturn -1;\n\tif (VAR_0->size > VAR_4 / 2)\n\t\tVAR_3 = VAR_1 + 8;\n\telse {\n\t\tVAR_3 = VAR_0->size * 2;\n\t\tif (VAR_3 < VAR_1 + 8)\n\t\t\tVAR_3 = VAR_1 + 8;\n\t}\n#ifdef VAR_5\n\tMC_DEBUG(\"printbuf_memappend: realloc \"\n\t         \"bpos=%d min_size=%d old_size=%d new_size=%d\\n\",\n\t         VAR_0->bpos, VAR_1, VAR_0->size, VAR_3);\n#endif /* COMMENT_1 */\n\tif (!(VAR_2 = (char *)realloc(VAR_0->buf, VAR_3)))\n\t\treturn -1;\n\tVAR_0->size = VAR_3;\n\tVAR_0->buf = VAR_2;\n\treturn 0;\n}",
  "func_graph_path": "json-c/d07b91014986900a3a75f306d302e13e005e9d67/printbuf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,10 +5,16 @@\n \n \tif (p->size >= min_size)\n \t\treturn 0;\n-\n-\tnew_size = p->size * 2;\n-\tif (new_size < min_size + 8)\n+\t/* Prevent signed integer overflows with large buffers. */\n+\tif (min_size > INT_MAX - 8)\n+\t\treturn -1;\n+\tif (p->size > INT_MAX / 2)\n \t\tnew_size = min_size + 8;\n+\telse {\n+\t\tnew_size = p->size * 2;\n+\t\tif (new_size < min_size + 8)\n+\t\t\tnew_size = min_size + 8;\n+\t}\n #ifdef PRINTBUF_DEBUG\n \tMC_DEBUG(\"printbuf_memappend: realloc \"\n \t         \"bpos=%d min_size=%d old_size=%d new_size=%d\\n\",",
  "diff_line_info": {
    "deleted_lines": [
      "",
      "\tnew_size = p->size * 2;",
      "\tif (new_size < min_size + 8)"
    ],
    "added_lines": [
      "\t/* Prevent signed integer overflows with large buffers. */",
      "\tif (min_size > INT_MAX - 8)",
      "\t\treturn -1;",
      "\tif (p->size > INT_MAX / 2)",
      "\telse {",
      "\t\tnew_size = p->size * 2;",
      "\t\tif (new_size < min_size + 8)",
      "\t\t\tnew_size = min_size + 8;",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/json-c/json-c/pull/592",
  "description": {
    "pr_info": {
      "title": "Prevent out of boundary write on malicious input",
      "number": 592
    },
    "comment": [
      "I have discovered a way to trigger an out of boundary write while parsing a huge json file through a malicious input source. It can be triggered if an attacker has control over the input stream or if a huge load during filesystem operations can be triggered.\r\n\r\nPreparation:\r\n``$ dd if=/dev/zero of=poc.json bs=1 count=1 seek=2147483647``\r\n\r\nCode to exploit:\r\n```\r\n#include <json-c/json_util.h>\r\n#include <unistd.h>\r\nint main() {\r\n  json_object_from_fd(STDIN_FILENO);\r\n  return 0;\r\n}\r\n```\r\n\r\nProof of Concept:\r\n``(dd if=poc.json bs=4096; sleep 1; dd if=test.json bs=10) 2>/dev/null | ./test``\r\n\r\nExplanation:\r\nThe problem manifests itself in printbuf_memappend. On properly crafted values, p->bpos + size + 1 can overflow, which leads to the assumption that p->size is still large enough. In normal circumstances, this does not happen with json_object_from_fd due to its buffer size leading to proper detection. But if the parsed buffer chunk length is not a power of 2 (sleep 1 and bs=10 triggers this in my proof of concept), this overflow can be abused by an attacker to write past the memory boundary of p->buf.\r\n\r\nMy example simply crashes the program eventually. A proper attack can be controled in a way to not crash the system but simply write a few attacker controlled bytes outside the allocated area, allowing more sophisticated attacks against real world programs.",
      "\n[![Coverage Status](https://coveralls.io/builds/30606764/badge)](https://coveralls.io/builds/30606764)\n\nCoverage decreased (-0.2%) to 85.768% when pulling **d07b91014986900a3a75f306d302e13e005e9d67 on stoeckmann:oob** into **8e3d3d55449a358c662e73ce6f539d44c8053e2c on json-c:master**.\n",
      "The changes look good, thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses integer overflows that cause an out-of-bound write vulnerability, as confirmed by the commit message and code changes.\n\n**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}