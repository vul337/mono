{
  "cve_id": "CVE-2021-46340",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Fix scanning bracketed expressions\n\nScan 'async' literal with different depth of brackets\n\nThis patch fixes #4924.\nThis patch fixes #4748.\n\nJerryScript-DCO-1.0-Signed-off-by: Martin Negyokru negyokru@inf.u-szeged.hu",
  "commit_hash": "338bf4ffb4efdfe0e58b63fbbeeb6630b2057c83",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/338bf4ffb4efdfe0e58b63fbbeeb6630b2057c83",
  "file_path": "jerry-core/parser/js/js-scanner-ops.c",
  "func_name": "scanner_scan_bracket",
  "func_before": "void\nscanner_scan_bracket (parser_context_t *context_p, /**< context */\n                      scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  size_t depth = 0;\n#if JERRY_ESNEXT\n  const uint8_t *arrow_source_p;\n  const uint8_t *async_source_p = NULL;\n  scanner_scan_bracket_arrow_type_t arrow_type = SCANNER_SCAN_BRACKET_NO_ARROW;\n#endif /* JERRY_ESNEXT */\n\n  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_PAREN);\n\n  do\n  {\n#if JERRY_ESNEXT\n    arrow_source_p = context_p->source_p;\n#endif /* JERRY_ESNEXT */\n    depth++;\n    lexer_next_token (context_p);\n  } while (context_p->token.type == LEXER_LEFT_PAREN);\n\n  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n  switch (context_p->token.type)\n  {\n    case LEXER_LITERAL:\n    {\n      if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n#if JERRY_ESNEXT\n        arrow_source_p = NULL;\n#endif /* JERRY_ESNEXT */\n        break;\n      }\n\n#if JERRY_ESNEXT\n      const uint8_t *source_p = context_p->source_p;\n\n      if (lexer_check_arrow (context_p))\n      {\n        arrow_source_p = source_p;\n        arrow_type = SCANNER_SCAN_BRACKET_SIMPLE_ARROW;\n        break;\n      }\n\n      size_t total_depth = depth;\n#endif /* JERRY_ESNEXT */\n\n      while (depth > 0 && lexer_check_next_character (context_p, LIT_CHAR_RIGHT_PAREN))\n      {\n        lexer_consume_next_character (context_p);\n        depth--;\n      }\n\n      if (context_p->token.keyword_type == LEXER_KEYW_EVAL\n          && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))\n      {\n#if JERRY_ESNEXT\n        /* A function call cannot be an eval function. */\n        arrow_source_p = NULL;\n        const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);\n#else /* !JERRY_ESNEXT */\n        const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;\n#endif /* JERRY_ESNEXT */\n\n        scanner_context_p->active_literal_pool_p->status_flags |= flags;\n        break;\n      }\n\n#if JERRY_ESNEXT\n      if (total_depth == depth)\n      {\n        if (lexer_check_arrow_param (context_p))\n        {\n          JERRY_ASSERT (depth > 0);\n          depth--;\n          break;\n        }\n\n        if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n        {\n          async_source_p = source_p;\n        }\n      }\n      else if (depth == total_depth - 1)\n      {\n        if (lexer_check_arrow (context_p))\n        {\n          arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;\n          break;\n        }\n\n        if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n        {\n          scanner_add_async_literal (context_p, scanner_context_p);\n        }\n      }\n\n      arrow_source_p = NULL;\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n#if JERRY_ESNEXT\n    case LEXER_THREE_DOTS:\n    case LEXER_LEFT_SQUARE:\n    case LEXER_LEFT_BRACE:\n    case LEXER_RIGHT_PAREN:\n    {\n      JERRY_ASSERT (depth > 0);\n      depth--;\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n#if JERRY_ESNEXT\n      arrow_source_p = NULL;\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n  }\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL) && (arrow_source_p == NULL || depth > 0))\n  {\n    scanner_context_p->async_source_p = NULL;\n  }\n#endif /* JERRY_ESNEXT */\n\n  while (depth > 0)\n  {\n    parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);\n    depth--;\n  }\n\n#if JERRY_ESNEXT\n  if (arrow_source_p != NULL)\n  {\n    JERRY_ASSERT (async_source_p == NULL);\n\n    if (arrow_type == SCANNER_SCAN_BRACKET_SIMPLE_ARROW)\n    {\n      scanner_scan_simple_arrow (context_p, scanner_context_p, arrow_source_p);\n      return;\n    }\n\n    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_ARGUMENTS);\n\n    uint16_t status_flags = 0;\n\n    if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL))\n    {\n      status_flags |= SCANNER_LITERAL_POOL_MAY_ASYNC_ARROW;\n      arrow_source_p = scanner_context_p->async_source_p;\n      scanner_context_p->async_source_p = NULL;\n    }\n\n    scanner_literal_pool_t *literal_pool_p;\n    literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n    literal_pool_p->source_p = arrow_source_p;\n\n    if (arrow_type == SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG)\n    {\n      scanner_append_argument (context_p, scanner_context_p);\n      scanner_detect_eval_call (context_p, scanner_context_p);\n\n      context_p->token.type = LEXER_RIGHT_PAREN;\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n    }\n    else if (context_p->token.type == LEXER_RIGHT_PAREN)\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n    }\n    else\n    {\n      scanner_check_arrow_arg (context_p, scanner_context_p);\n    }\n  }\n  else if (JERRY_UNLIKELY (async_source_p != NULL))\n  {\n    scanner_context_p->async_source_p = async_source_p;\n    scanner_check_async_function (context_p, scanner_context_p);\n  }\n#endif /* JERRY_ESNEXT */\n}",
  "abstract_func_before": "void\nscanner_scan_bracket (parser_context_t *VAR_0, /* COMMENT_0 */\n                      scanner_context_t *VAR_1) /* COMMENT_1 */\n{\n  size_t VAR_2 = 0;\n#if VAR_3\n  const uint8_t *VAR_4;\n  const uint8_t *VAR_5 = NULL;\n  scanner_scan_bracket_arrow_type_t VAR_6 = VAR_7;\n#endif /* COMMENT_2 */\n\n  JERRY_ASSERT (VAR_0->token.type == VAR_8);\n\n  do\n  {\n#if VAR_3\n    VAR_4 = VAR_0->source_p;\n#endif /* COMMENT_2 */\n    VAR_2++;\n    lexer_next_token (VAR_0);\n  } while (VAR_0->token.type == VAR_8);\n\n  VAR_1->mode = VAR_9;\n\n  switch (VAR_0->token.type)\n  {\n    case VAR_10:\n    {\n      if (VAR_0->token.lit_location.type != VAR_11)\n      {\n#if VAR_3\n        VAR_4 = NULL;\n#endif /* COMMENT_2 */\n        break;\n      }\n\n#if VAR_3\n      const uint8_t *VAR_12 = VAR_0->source_p;\n\n      if (lexer_check_arrow (VAR_0))\n      {\n        VAR_4 = VAR_12;\n        VAR_6 = VAR_13;\n        break;\n      }\n\n      size_t VAR_14 = VAR_2;\n#endif /* COMMENT_2 */\n\n      while (VAR_2 > 0 && lexer_check_next_character (VAR_0, VAR_15))\n      {\n        lexer_consume_next_character (VAR_0);\n        VAR_2--;\n      }\n\n      if (VAR_0->token.keyword_type == VAR_16\n          && lexer_check_next_character (VAR_0, VAR_17))\n      {\n#if VAR_3\n        /* COMMENT_3 */\n        VAR_4 = NULL;\n        const uint16_t VAR_18 = (uint16_t) (VAR_19 | VAR_20);\n#else /* COMMENT_4 */\n        const uint16_t VAR_18 = VAR_19;\n#endif /* COMMENT_2 */\n\n        VAR_1->active_literal_pool_p->status_flags |= VAR_18;\n        break;\n      }\n\n#if VAR_3\n      if (VAR_14 == VAR_2)\n      {\n        if (lexer_check_arrow_param (VAR_0))\n        {\n          JERRY_ASSERT (VAR_2 > 0);\n          VAR_2--;\n          break;\n        }\n\n        if (JERRY_UNLIKELY (lexer_token_is_async (VAR_0)))\n        {\n          VAR_5 = VAR_12;\n        }\n      }\n      else if (VAR_2 == VAR_14 - 1)\n      {\n        if (lexer_check_arrow (VAR_0))\n        {\n          VAR_6 = VAR_21;\n          break;\n        }\n\n        if (VAR_0->stack_top_uint8 == VAR_22)\n        {\n          scanner_add_async_literal (VAR_0, VAR_1);\n        }\n      }\n\n      VAR_4 = NULL;\n#endif /* COMMENT_2 */\n      break;\n    }\n#if VAR_3\n    case VAR_23:\n    case VAR_24:\n    case VAR_25:\n    case VAR_26:\n    {\n      JERRY_ASSERT (VAR_2 > 0);\n      VAR_2--;\n      break;\n    }\n#endif /* COMMENT_2 */\n    default:\n    {\n#if VAR_3\n      VAR_4 = NULL;\n#endif /* COMMENT_2 */\n      break;\n    }\n  }\n\n#if VAR_3\n  if (JERRY_UNLIKELY (VAR_1->async_source_p != NULL) && (VAR_4 == NULL || VAR_2 > 0))\n  {\n    VAR_1->async_source_p = NULL;\n  }\n#endif /* COMMENT_2 */\n\n  while (VAR_2 > 0)\n  {\n    parser_stack_push_uint8 (VAR_0, VAR_27);\n    VAR_2--;\n  }\n\n#if VAR_3\n  if (VAR_4 != NULL)\n  {\n    JERRY_ASSERT (VAR_5 == NULL);\n\n    if (VAR_6 == VAR_13)\n    {\n      scanner_scan_simple_arrow (VAR_0, VAR_1, VAR_4);\n      return;\n    }\n\n    parser_stack_push_uint8 (VAR_0, VAR_28);\n\n    uint16_t VAR_29 = 0;\n\n    if (JERRY_UNLIKELY (VAR_1->async_source_p != NULL))\n    {\n      VAR_29 |= VAR_30;\n      VAR_4 = VAR_1->async_source_p;\n      VAR_1->async_source_p = NULL;\n    }\n\n    scanner_literal_pool_t *VAR_31;\n    VAR_31 = scanner_push_literal_pool (VAR_0, VAR_1, VAR_29);\n    VAR_31->source_p = VAR_4;\n\n    if (VAR_6 == VAR_21)\n    {\n      scanner_append_argument (VAR_0, VAR_1);\n      scanner_detect_eval_call (VAR_0, VAR_1);\n\n      VAR_0->token.type = VAR_26;\n      VAR_1->mode = VAR_32;\n    }\n    else if (VAR_0->token.type == VAR_26)\n    {\n      VAR_1->mode = VAR_32;\n    }\n    else\n    {\n      scanner_check_arrow_arg (VAR_0, VAR_1);\n    }\n  }\n  else if (JERRY_UNLIKELY (VAR_5 != NULL))\n  {\n    VAR_1->async_source_p = VAR_5;\n    scanner_check_async_function (VAR_0, VAR_1);\n  }\n#endif /* COMMENT_2 */\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/338bf4ffb4efdfe0e58b63fbbeeb6630b2057c83/js-scanner-ops.c/vul/before/0.json",
  "func": "void\nscanner_scan_bracket (parser_context_t *context_p, /**< context */\n                      scanner_context_t *scanner_context_p) /**< scanner context */\n{\n  size_t depth = 0;\n#if JERRY_ESNEXT\n  const uint8_t *arrow_source_p;\n  const uint8_t *async_source_p = NULL;\n  scanner_scan_bracket_arrow_type_t arrow_type = SCANNER_SCAN_BRACKET_NO_ARROW;\n#endif /* JERRY_ESNEXT */\n\n  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_PAREN);\n\n  do\n  {\n#if JERRY_ESNEXT\n    arrow_source_p = context_p->source_p;\n#endif /* JERRY_ESNEXT */\n    depth++;\n    lexer_next_token (context_p);\n  } while (context_p->token.type == LEXER_LEFT_PAREN);\n\n  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n  switch (context_p->token.type)\n  {\n    case LEXER_LITERAL:\n    {\n      if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n#if JERRY_ESNEXT\n        arrow_source_p = NULL;\n#endif /* JERRY_ESNEXT */\n        break;\n      }\n\n#if JERRY_ESNEXT\n      const uint8_t *source_p = context_p->source_p;\n\n      if (lexer_check_arrow (context_p))\n      {\n        arrow_source_p = source_p;\n        arrow_type = SCANNER_SCAN_BRACKET_SIMPLE_ARROW;\n        break;\n      }\n\n      size_t total_depth = depth;\n#endif /* JERRY_ESNEXT */\n\n      while (depth > 0 && lexer_check_next_character (context_p, LIT_CHAR_RIGHT_PAREN))\n      {\n        lexer_consume_next_character (context_p);\n        depth--;\n      }\n\n      if (context_p->token.keyword_type == LEXER_KEYW_EVAL\n          && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))\n      {\n#if JERRY_ESNEXT\n        /* A function call cannot be an eval function. */\n        arrow_source_p = NULL;\n        const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);\n#else /* !JERRY_ESNEXT */\n        const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;\n#endif /* JERRY_ESNEXT */\n\n        scanner_context_p->active_literal_pool_p->status_flags |= flags;\n        break;\n      }\n\n#if JERRY_ESNEXT\n      if (total_depth == depth)\n      {\n        if (lexer_check_arrow_param (context_p))\n        {\n          JERRY_ASSERT (depth > 0);\n          depth--;\n          break;\n        }\n\n        if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n        {\n          async_source_p = source_p;\n        }\n      }\n\n      if (depth == total_depth - 1 && lexer_check_arrow (context_p))\n      {\n        arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;\n        break;\n      }\n\n      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n      {\n        scanner_add_async_literal (context_p, scanner_context_p);\n      }\n\n      arrow_source_p = NULL;\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n#if JERRY_ESNEXT\n    case LEXER_THREE_DOTS:\n    case LEXER_LEFT_SQUARE:\n    case LEXER_LEFT_BRACE:\n    case LEXER_RIGHT_PAREN:\n    {\n      JERRY_ASSERT (depth > 0);\n      depth--;\n      break;\n    }\n#endif /* JERRY_ESNEXT */\n    default:\n    {\n#if JERRY_ESNEXT\n      arrow_source_p = NULL;\n#endif /* JERRY_ESNEXT */\n      break;\n    }\n  }\n\n#if JERRY_ESNEXT\n  if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL) && (arrow_source_p == NULL || depth > 0))\n  {\n    scanner_context_p->async_source_p = NULL;\n  }\n#endif /* JERRY_ESNEXT */\n\n  while (depth > 0)\n  {\n    parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);\n    depth--;\n  }\n\n#if JERRY_ESNEXT\n  if (arrow_source_p != NULL)\n  {\n    JERRY_ASSERT (async_source_p == NULL);\n\n    if (arrow_type == SCANNER_SCAN_BRACKET_SIMPLE_ARROW)\n    {\n      scanner_scan_simple_arrow (context_p, scanner_context_p, arrow_source_p);\n      return;\n    }\n\n    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_ARGUMENTS);\n\n    uint16_t status_flags = 0;\n\n    if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL))\n    {\n      status_flags |= SCANNER_LITERAL_POOL_MAY_ASYNC_ARROW;\n      arrow_source_p = scanner_context_p->async_source_p;\n      scanner_context_p->async_source_p = NULL;\n    }\n\n    scanner_literal_pool_t *literal_pool_p;\n    literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n    literal_pool_p->source_p = arrow_source_p;\n\n    if (arrow_type == SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG)\n    {\n      scanner_append_argument (context_p, scanner_context_p);\n      scanner_detect_eval_call (context_p, scanner_context_p);\n\n      context_p->token.type = LEXER_RIGHT_PAREN;\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n    }\n    else if (context_p->token.type == LEXER_RIGHT_PAREN)\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n    }\n    else\n    {\n      scanner_check_arrow_arg (context_p, scanner_context_p);\n    }\n  }\n  else if (JERRY_UNLIKELY (async_source_p != NULL))\n  {\n    scanner_context_p->async_source_p = async_source_p;\n    scanner_check_async_function (context_p, scanner_context_p);\n  }\n#endif /* JERRY_ESNEXT */\n}",
  "abstract_func": "void\nscanner_scan_bracket (parser_context_t *VAR_0, /* COMMENT_0 */\n                      scanner_context_t *VAR_1) /* COMMENT_1 */\n{\n  size_t VAR_2 = 0;\n#if VAR_3\n  const uint8_t *VAR_4;\n  const uint8_t *VAR_5 = NULL;\n  scanner_scan_bracket_arrow_type_t VAR_6 = VAR_7;\n#endif /* COMMENT_2 */\n\n  JERRY_ASSERT (VAR_0->token.type == VAR_8);\n\n  do\n  {\n#if VAR_3\n    VAR_4 = VAR_0->source_p;\n#endif /* COMMENT_2 */\n    VAR_2++;\n    lexer_next_token (VAR_0);\n  } while (VAR_0->token.type == VAR_8);\n\n  VAR_1->mode = VAR_9;\n\n  switch (VAR_0->token.type)\n  {\n    case VAR_10:\n    {\n      if (VAR_0->token.lit_location.type != VAR_11)\n      {\n#if VAR_3\n        VAR_4 = NULL;\n#endif /* COMMENT_2 */\n        break;\n      }\n\n#if VAR_3\n      const uint8_t *VAR_12 = VAR_0->source_p;\n\n      if (lexer_check_arrow (VAR_0))\n      {\n        VAR_4 = VAR_12;\n        VAR_6 = VAR_13;\n        break;\n      }\n\n      size_t VAR_14 = VAR_2;\n#endif /* COMMENT_2 */\n\n      while (VAR_2 > 0 && lexer_check_next_character (VAR_0, VAR_15))\n      {\n        lexer_consume_next_character (VAR_0);\n        VAR_2--;\n      }\n\n      if (VAR_0->token.keyword_type == VAR_16\n          && lexer_check_next_character (VAR_0, VAR_17))\n      {\n#if VAR_3\n        /* COMMENT_3 */\n        VAR_4 = NULL;\n        const uint16_t VAR_18 = (uint16_t) (VAR_19 | VAR_20);\n#else /* COMMENT_4 */\n        const uint16_t VAR_18 = VAR_19;\n#endif /* COMMENT_2 */\n\n        VAR_1->active_literal_pool_p->status_flags |= VAR_18;\n        break;\n      }\n\n#if VAR_3\n      if (VAR_14 == VAR_2)\n      {\n        if (lexer_check_arrow_param (VAR_0))\n        {\n          JERRY_ASSERT (VAR_2 > 0);\n          VAR_2--;\n          break;\n        }\n\n        if (JERRY_UNLIKELY (lexer_token_is_async (VAR_0)))\n        {\n          VAR_5 = VAR_12;\n        }\n      }\n\n      if (VAR_2 == VAR_14 - 1 && lexer_check_arrow (VAR_0))\n      {\n        VAR_6 = VAR_21;\n        break;\n      }\n\n      if (VAR_0->stack_top_uint8 == VAR_22)\n      {\n        scanner_add_async_literal (VAR_0, VAR_1);\n      }\n\n      VAR_4 = NULL;\n#endif /* COMMENT_2 */\n      break;\n    }\n#if VAR_3\n    case VAR_23:\n    case VAR_24:\n    case VAR_25:\n    case VAR_26:\n    {\n      JERRY_ASSERT (VAR_2 > 0);\n      VAR_2--;\n      break;\n    }\n#endif /* COMMENT_2 */\n    default:\n    {\n#if VAR_3\n      VAR_4 = NULL;\n#endif /* COMMENT_2 */\n      break;\n    }\n  }\n\n#if VAR_3\n  if (JERRY_UNLIKELY (VAR_1->async_source_p != NULL) && (VAR_4 == NULL || VAR_2 > 0))\n  {\n    VAR_1->async_source_p = NULL;\n  }\n#endif /* COMMENT_2 */\n\n  while (VAR_2 > 0)\n  {\n    parser_stack_push_uint8 (VAR_0, VAR_27);\n    VAR_2--;\n  }\n\n#if VAR_3\n  if (VAR_4 != NULL)\n  {\n    JERRY_ASSERT (VAR_5 == NULL);\n\n    if (VAR_6 == VAR_13)\n    {\n      scanner_scan_simple_arrow (VAR_0, VAR_1, VAR_4);\n      return;\n    }\n\n    parser_stack_push_uint8 (VAR_0, VAR_28);\n\n    uint16_t VAR_29 = 0;\n\n    if (JERRY_UNLIKELY (VAR_1->async_source_p != NULL))\n    {\n      VAR_29 |= VAR_30;\n      VAR_4 = VAR_1->async_source_p;\n      VAR_1->async_source_p = NULL;\n    }\n\n    scanner_literal_pool_t *VAR_31;\n    VAR_31 = scanner_push_literal_pool (VAR_0, VAR_1, VAR_29);\n    VAR_31->source_p = VAR_4;\n\n    if (VAR_6 == VAR_21)\n    {\n      scanner_append_argument (VAR_0, VAR_1);\n      scanner_detect_eval_call (VAR_0, VAR_1);\n\n      VAR_0->token.type = VAR_26;\n      VAR_1->mode = VAR_32;\n    }\n    else if (VAR_0->token.type == VAR_26)\n    {\n      VAR_1->mode = VAR_32;\n    }\n    else\n    {\n      scanner_check_arrow_arg (VAR_0, VAR_1);\n    }\n  }\n  else if (JERRY_UNLIKELY (VAR_5 != NULL))\n  {\n    VAR_1->async_source_p = VAR_5;\n    scanner_check_async_function (VAR_0, VAR_1);\n  }\n#endif /* COMMENT_2 */\n}",
  "func_graph_path": "jerryscript-project/jerryscript/338bf4ffb4efdfe0e58b63fbbeeb6630b2057c83/js-scanner-ops.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -83,18 +83,16 @@\n           async_source_p = source_p;\n         }\n       }\n-      else if (depth == total_depth - 1)\n+\n+      if (depth == total_depth - 1 && lexer_check_arrow (context_p))\n       {\n-        if (lexer_check_arrow (context_p))\n-        {\n-          arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;\n-          break;\n-        }\n+        arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;\n+        break;\n+      }\n \n-        if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n-        {\n-          scanner_add_async_literal (context_p, scanner_context_p);\n-        }\n+      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n+      {\n+        scanner_add_async_literal (context_p, scanner_context_p);\n       }\n \n       arrow_source_p = NULL;",
  "diff_line_info": {
    "deleted_lines": [
      "      else if (depth == total_depth - 1)",
      "        if (lexer_check_arrow (context_p))",
      "        {",
      "          arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;",
      "          break;",
      "        }",
      "        if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)",
      "        {",
      "          scanner_add_async_literal (context_p, scanner_context_p);",
      "        }"
    ],
    "added_lines": [
      "",
      "      if (depth == total_depth - 1 && lexer_check_arrow (context_p))",
      "        arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;",
      "        break;",
      "      }",
      "      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)",
      "      {",
      "        scanner_add_async_literal (context_p, scanner_context_p);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4964",
  "description": {
    "pr_info": {
      "title": "Fix scanning bracketed expressions",
      "number": 4964
    },
    "comment": [
      "Scan 'async' literal with different depth of brackets\r\n\r\nThis patch fixes #4924.\r\nThis patch fixes #4748.\r\n\r\nJerryScript-DCO-1.0-Signed-off-by: Martin Negyokru negyokru@inf.u-szeged.hu\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}