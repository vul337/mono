{
  "cve_id": "CVE-2021-46055",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "WebAssembly/binaryen",
  "commit_msg": "Add binary format parse check for imported function types (#4423)\n\nWithout this we hit an assertion later, which is less clear.\r\n\r\nSee #4413",
  "commit_hash": "1beec37f483505db0c5152be9118b28e45b77316",
  "git_url": "https://github.com/WebAssembly/binaryen/commit/1beec37f483505db0c5152be9118b28e45b77316",
  "file_path": "src/wasm/wasm-binary.cpp",
  "func_name": "WasmBinaryBuilder::readImports",
  "func_before": "void WasmBinaryBuilder::readImports() {\n  BYN_TRACE(\"== readImports\\n\");\n  size_t num = getU32LEB();\n  BYN_TRACE(\"num: \" << num << std::endl);\n  Builder builder(wasm);\n  size_t tableCounter = 0;\n  size_t memoryCounter = 0;\n  size_t functionCounter = 0;\n  size_t globalCounter = 0;\n  size_t tagCounter = 0;\n  for (size_t i = 0; i < num; i++) {\n    BYN_TRACE(\"read one\\n\");\n    auto module = getInlineString();\n    auto base = getInlineString();\n    auto kind = (ExternalKind)getU32LEB();\n    // We set a unique prefix for the name based on the kind. This ensures no\n    // collisions between them, which can't occur here (due to the index i) but\n    // could occur later due to the names section.\n    switch (kind) {\n      case ExternalKind::Function: {\n        Name name(std::string(\"fimport$\") + std::to_string(functionCounter++));\n        auto index = getU32LEB();\n        functionTypes.push_back(getTypeByIndex(index));\n        auto curr = builder.makeFunction(name, getTypeByIndex(index), {});\n        curr->module = module;\n        curr->base = base;\n        functionImports.push_back(curr.get());\n        wasm.addFunction(std::move(curr));\n        break;\n      }\n      case ExternalKind::Table: {\n        Name name(std::string(\"timport$\") + std::to_string(tableCounter++));\n        auto table = builder.makeTable(name);\n        table->module = module;\n        table->base = base;\n        table->type = getType();\n\n        bool is_shared;\n        Type indexType;\n        getResizableLimits(table->initial,\n                           table->max,\n                           is_shared,\n                           indexType,\n                           Table::kUnlimitedSize);\n        if (is_shared) {\n          throwError(\"Tables may not be shared\");\n        }\n        if (indexType == Type::i64) {\n          throwError(\"Tables may not be 64-bit\");\n        }\n\n        tableImports.push_back(table.get());\n        wasm.addTable(std::move(table));\n        break;\n      }\n      case ExternalKind::Memory: {\n        Name name(std::string(\"mimport$\") + std::to_string(memoryCounter++));\n        wasm.memory.module = module;\n        wasm.memory.base = base;\n        wasm.memory.name = name;\n        wasm.memory.exists = true;\n        getResizableLimits(wasm.memory.initial,\n                           wasm.memory.max,\n                           wasm.memory.shared,\n                           wasm.memory.indexType,\n                           Memory::kUnlimitedSize);\n        break;\n      }\n      case ExternalKind::Global: {\n        Name name(std::string(\"gimport$\") + std::to_string(globalCounter++));\n        auto type = getConcreteType();\n        auto mutable_ = getU32LEB();\n        auto curr =\n          builder.makeGlobal(name,\n                             type,\n                             nullptr,\n                             mutable_ ? Builder::Mutable : Builder::Immutable);\n        curr->module = module;\n        curr->base = base;\n        globalImports.push_back(curr.get());\n        wasm.addGlobal(std::move(curr));\n        break;\n      }\n      case ExternalKind::Tag: {\n        Name name(std::string(\"eimport$\") + std::to_string(tagCounter++));\n        getInt8(); // Reserved 'attribute' field\n        auto index = getU32LEB();\n        auto curr = builder.makeTag(name, getSignatureByTypeIndex(index));\n        curr->module = module;\n        curr->base = base;\n        wasm.addTag(std::move(curr));\n        break;\n      }\n      default: {\n        throwError(\"bad import kind\");\n      }\n    }\n  }\n}",
  "abstract_func_before": "void WasmBinaryBuilder::readImports() {\n  BYN_TRACE(\"== readImports\\n\");\n  size_t VAR_0 = getU32LEB();\n  BYN_TRACE(\"num: \" << VAR_0 << std::endl);\n  Builder builder(wasm);\n  size_t VAR_1 = 0;\n  size_t VAR_2 = 0;\n  size_t VAR_3 = 0;\n  size_t VAR_4 = 0;\n  size_t VAR_5 = 0;\n  for (size_t VAR_6 = 0; VAR_6 < VAR_0; VAR_6++) {\n    BYN_TRACE(\"read one\\n\");\n    auto VAR_7 = getInlineString();\n    auto VAR_8 = getInlineString();\n    auto VAR_9 = (ExternalKind)getU32LEB();\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    switch (VAR_9) {\n      case ExternalKind::Function: {\n        Name VAR_10(std::string(\"fimport$\") + std::to_string(VAR_3++));\n        auto VAR_11 = getU32LEB();\n        VAR_12.push_back(getTypeByIndex(VAR_11));\n        auto VAR_13 = VAR_14.makeFunction(VAR_10, getTypeByIndex(VAR_11), {});\n        VAR_13->module = VAR_7;\n        VAR_13->base = VAR_8;\n        VAR_15.push_back(VAR_13.get());\n        wasm.addFunction(std::move(VAR_13));\n        break;\n      }\n      case ExternalKind::Table: {\n        Name VAR_10(std::string(\"timport$\") + std::to_string(VAR_1++));\n        auto VAR_16 = VAR_14.makeTable(VAR_10);\n        VAR_16->module = VAR_7;\n        VAR_16->base = VAR_8;\n        VAR_16->type = getType();\n\n        bool VAR_17;\n        Type VAR_18;\n        getResizableLimits(VAR_16->initial,\n                           VAR_16->max,\n                           VAR_17,\n                           VAR_18,\n                           Table::kUnlimitedSize);\n        if (VAR_17) {\n          throwError(\"Tables may not be shared\");\n        }\n        if (VAR_18 == Type::i64) {\n          throwError(\"Tables may not be 64-bit\");\n        }\n\n        VAR_19.push_back(VAR_16.get());\n        wasm.addTable(std::move(VAR_16));\n        break;\n      }\n      case ExternalKind::Memory: {\n        Name VAR_10(std::string(\"mimport$\") + std::to_string(VAR_2++));\n        wasm.memory.module = VAR_7;\n        wasm.memory.base = VAR_8;\n        wasm.memory.name = VAR_10;\n        wasm.memory.exists = true;\n        getResizableLimits(wasm.memory.initial,\n                           wasm.memory.max,\n                           wasm.memory.shared,\n                           wasm.memory.indexType,\n                           Memory::kUnlimitedSize);\n        break;\n      }\n      case ExternalKind::Global: {\n        Name VAR_10(std::string(\"gimport$\") + std::to_string(VAR_4++));\n        auto VAR_20 = getConcreteType();\n        auto VAR_21 = getU32LEB();\n        auto VAR_13 =\n          VAR_14.makeGlobal(VAR_10,\n                             VAR_20,\n                             nullptr,\n                             VAR_21 ? Builder::Mutable : Builder::Immutable);\n        VAR_13->module = VAR_7;\n        VAR_13->base = VAR_8;\n        VAR_22.push_back(VAR_13.get());\n        wasm.addGlobal(std::move(VAR_13));\n        break;\n      }\n      case ExternalKind::Tag: {\n        Name VAR_10(std::string(\"eimport$\") + std::to_string(VAR_5++));\n        getInt8(); /* COMMENT_3 */\n        auto VAR_11 = getU32LEB();\n        auto VAR_13 = VAR_14.makeTag(VAR_10, getSignatureByTypeIndex(VAR_11));\n        VAR_13->module = VAR_7;\n        VAR_13->base = VAR_8;\n        wasm.addTag(std::move(VAR_13));\n        break;\n      }\n      default: {\n        throwError(\"bad import kind\");\n      }\n    }\n  }\n}",
  "func_graph_path_before": "WebAssembly/binaryen/1beec37f483505db0c5152be9118b28e45b77316/wasm-binary.cpp/vul/before/0.json",
  "func": "void WasmBinaryBuilder::readImports() {\n  BYN_TRACE(\"== readImports\\n\");\n  size_t num = getU32LEB();\n  BYN_TRACE(\"num: \" << num << std::endl);\n  Builder builder(wasm);\n  size_t tableCounter = 0;\n  size_t memoryCounter = 0;\n  size_t functionCounter = 0;\n  size_t globalCounter = 0;\n  size_t tagCounter = 0;\n  for (size_t i = 0; i < num; i++) {\n    BYN_TRACE(\"read one\\n\");\n    auto module = getInlineString();\n    auto base = getInlineString();\n    auto kind = (ExternalKind)getU32LEB();\n    // We set a unique prefix for the name based on the kind. This ensures no\n    // collisions between them, which can't occur here (due to the index i) but\n    // could occur later due to the names section.\n    switch (kind) {\n      case ExternalKind::Function: {\n        Name name(std::string(\"fimport$\") + std::to_string(functionCounter++));\n        auto index = getU32LEB();\n        functionTypes.push_back(getTypeByIndex(index));\n        auto type = getTypeByIndex(index);\n        if (!type.isSignature()) {\n          throwError(std::string(\"Imported function \") + module.str + '.' +\n                     base.str +\n                     \"'s type must be a signature. Given: \" + type.toString());\n        }\n        auto curr = builder.makeFunction(name, type, {});\n        curr->module = module;\n        curr->base = base;\n        functionImports.push_back(curr.get());\n        wasm.addFunction(std::move(curr));\n        break;\n      }\n      case ExternalKind::Table: {\n        Name name(std::string(\"timport$\") + std::to_string(tableCounter++));\n        auto table = builder.makeTable(name);\n        table->module = module;\n        table->base = base;\n        table->type = getType();\n\n        bool is_shared;\n        Type indexType;\n        getResizableLimits(table->initial,\n                           table->max,\n                           is_shared,\n                           indexType,\n                           Table::kUnlimitedSize);\n        if (is_shared) {\n          throwError(\"Tables may not be shared\");\n        }\n        if (indexType == Type::i64) {\n          throwError(\"Tables may not be 64-bit\");\n        }\n\n        tableImports.push_back(table.get());\n        wasm.addTable(std::move(table));\n        break;\n      }\n      case ExternalKind::Memory: {\n        Name name(std::string(\"mimport$\") + std::to_string(memoryCounter++));\n        wasm.memory.module = module;\n        wasm.memory.base = base;\n        wasm.memory.name = name;\n        wasm.memory.exists = true;\n        getResizableLimits(wasm.memory.initial,\n                           wasm.memory.max,\n                           wasm.memory.shared,\n                           wasm.memory.indexType,\n                           Memory::kUnlimitedSize);\n        break;\n      }\n      case ExternalKind::Global: {\n        Name name(std::string(\"gimport$\") + std::to_string(globalCounter++));\n        auto type = getConcreteType();\n        auto mutable_ = getU32LEB();\n        auto curr =\n          builder.makeGlobal(name,\n                             type,\n                             nullptr,\n                             mutable_ ? Builder::Mutable : Builder::Immutable);\n        curr->module = module;\n        curr->base = base;\n        globalImports.push_back(curr.get());\n        wasm.addGlobal(std::move(curr));\n        break;\n      }\n      case ExternalKind::Tag: {\n        Name name(std::string(\"eimport$\") + std::to_string(tagCounter++));\n        getInt8(); // Reserved 'attribute' field\n        auto index = getU32LEB();\n        auto curr = builder.makeTag(name, getSignatureByTypeIndex(index));\n        curr->module = module;\n        curr->base = base;\n        wasm.addTag(std::move(curr));\n        break;\n      }\n      default: {\n        throwError(\"bad import kind\");\n      }\n    }\n  }\n}",
  "abstract_func": "void WasmBinaryBuilder::readImports() {\n  BYN_TRACE(\"== readImports\\n\");\n  size_t VAR_0 = getU32LEB();\n  BYN_TRACE(\"num: \" << VAR_0 << std::endl);\n  Builder builder(wasm);\n  size_t VAR_1 = 0;\n  size_t VAR_2 = 0;\n  size_t VAR_3 = 0;\n  size_t VAR_4 = 0;\n  size_t VAR_5 = 0;\n  for (size_t VAR_6 = 0; VAR_6 < VAR_0; VAR_6++) {\n    BYN_TRACE(\"read one\\n\");\n    auto VAR_7 = getInlineString();\n    auto VAR_8 = getInlineString();\n    auto VAR_9 = (ExternalKind)getU32LEB();\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    switch (VAR_9) {\n      case ExternalKind::Function: {\n        Name VAR_10(std::string(\"fimport$\") + std::to_string(VAR_3++));\n        auto VAR_11 = getU32LEB();\n        VAR_12.push_back(getTypeByIndex(VAR_11));\n        auto VAR_13 = getTypeByIndex(VAR_11);\n        if (!VAR_13.isSignature()) {\n          throwError(std::string(\"Imported function \") + VAR_7.str + '.' +\n                     VAR_8.str +\n                     \"'s type must be a signature. Given: \" + VAR_13.toString());\n        }\n        auto VAR_14 = VAR_15.makeFunction(VAR_10, VAR_13, {});\n        VAR_14->module = VAR_7;\n        VAR_14->base = VAR_8;\n        VAR_16.push_back(VAR_14.get());\n        wasm.addFunction(std::move(VAR_14));\n        break;\n      }\n      case ExternalKind::Table: {\n        Name VAR_10(std::string(\"timport$\") + std::to_string(VAR_1++));\n        auto VAR_17 = VAR_15.makeTable(VAR_10);\n        VAR_17->module = VAR_7;\n        VAR_17->base = VAR_8;\n        VAR_17->type = getType();\n\n        bool VAR_18;\n        Type VAR_19;\n        getResizableLimits(VAR_17->initial,\n                           VAR_17->max,\n                           VAR_18,\n                           VAR_19,\n                           Table::kUnlimitedSize);\n        if (VAR_18) {\n          throwError(\"Tables may not be shared\");\n        }\n        if (VAR_19 == Type::i64) {\n          throwError(\"Tables may not be 64-bit\");\n        }\n\n        VAR_20.push_back(VAR_17.get());\n        wasm.addTable(std::move(VAR_17));\n        break;\n      }\n      case ExternalKind::Memory: {\n        Name VAR_10(std::string(\"mimport$\") + std::to_string(VAR_2++));\n        wasm.memory.module = VAR_7;\n        wasm.memory.base = VAR_8;\n        wasm.memory.name = VAR_10;\n        wasm.memory.exists = true;\n        getResizableLimits(wasm.memory.initial,\n                           wasm.memory.max,\n                           wasm.memory.shared,\n                           wasm.memory.indexType,\n                           Memory::kUnlimitedSize);\n        break;\n      }\n      case ExternalKind::Global: {\n        Name VAR_10(std::string(\"gimport$\") + std::to_string(VAR_4++));\n        auto VAR_13 = getConcreteType();\n        auto VAR_21 = getU32LEB();\n        auto VAR_14 =\n          VAR_15.makeGlobal(VAR_10,\n                             VAR_13,\n                             nullptr,\n                             VAR_21 ? Builder::Mutable : Builder::Immutable);\n        VAR_14->module = VAR_7;\n        VAR_14->base = VAR_8;\n        VAR_22.push_back(VAR_14.get());\n        wasm.addGlobal(std::move(VAR_14));\n        break;\n      }\n      case ExternalKind::Tag: {\n        Name VAR_10(std::string(\"eimport$\") + std::to_string(VAR_5++));\n        getInt8(); /* COMMENT_3 */\n        auto VAR_11 = getU32LEB();\n        auto VAR_14 = VAR_15.makeTag(VAR_10, getSignatureByTypeIndex(VAR_11));\n        VAR_14->module = VAR_7;\n        VAR_14->base = VAR_8;\n        wasm.addTag(std::move(VAR_14));\n        break;\n      }\n      default: {\n        throwError(\"bad import kind\");\n      }\n    }\n  }\n}",
  "func_graph_path": "WebAssembly/binaryen/1beec37f483505db0c5152be9118b28e45b77316/wasm-binary.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,13 @@\n         Name name(std::string(\"fimport$\") + std::to_string(functionCounter++));\n         auto index = getU32LEB();\n         functionTypes.push_back(getTypeByIndex(index));\n-        auto curr = builder.makeFunction(name, getTypeByIndex(index), {});\n+        auto type = getTypeByIndex(index);\n+        if (!type.isSignature()) {\n+          throwError(std::string(\"Imported function \") + module.str + '.' +\n+                     base.str +\n+                     \"'s type must be a signature. Given: \" + type.toString());\n+        }\n+        auto curr = builder.makeFunction(name, type, {});\n         curr->module = module;\n         curr->base = base;\n         functionImports.push_back(curr.get());",
  "diff_line_info": {
    "deleted_lines": [
      "        auto curr = builder.makeFunction(name, getTypeByIndex(index), {});"
    ],
    "added_lines": [
      "        auto type = getTypeByIndex(index);",
      "        if (!type.isSignature()) {",
      "          throwError(std::string(\"Imported function \") + module.str + '.' +",
      "                     base.str +",
      "                     \"'s type must be a signature. Given: \" + type.toString());",
      "        }",
      "        auto curr = builder.makeFunction(name, type, {});"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/binaryen/pull/4423",
  "description": {
    "pr_info": {
      "title": "Add binary format parse check for imported function types",
      "number": 4423
    },
    "comment": [
      "Without this we hit an assertion later, which is less clear.\r\n\r\nSee #4413 "
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}