{
  "cve_id": "CVE-2020-35850",
  "cwe_ids": [
    "CWE-918"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "cockpit-project/cockpit",
  "commit_msg": "ws: Disallow direct URL logins with LoginTo=false\n\nThe current documentation of LoginTo= isn't very specific about what\nexactly happens with a \"false\" value; but it is plausible for an admin\nto assume that \"false\" would disallow logging into a remote host\ncompletely -- not merely hide the \"Connect to:\" field and then allowing\na direct URL login anyway.\n\nIt is sometimes important to disallow direct SSH logins from the login\npage on publicly exposed bastion hosts, as this functionality allows\nunauthenticated remote users to:\n\n - scan the internal network for existing hosts, which might otherwise\n   not be accessible directly from the internet\n   (Fixes #18540, https://bugzilla.redhat.com/show_bug.cgi?id=2167006)\n\n - scan the cockpit-ws host or internal network hosts for open ports\n   (Fixes #15077, https://bugzilla.redhat.com/show_bug.cgi?id=2018741)\n\nSo change ws to reject direct URL logins with `LoginTo=false`. This\nhappens most naturally in cockpit_session_launch(), as we still want to\nallow remote URLs from the shell's host switcher in already\nauthenticated sessions. This will not produce a very friendly error\nmessage, but it doesn't have to be -- at that point specifying direct\nURLs can be considered hacking anyway.\n\nClarify the documentation accordingly.",
  "commit_hash": "211c14b39b787bf817f6cd94e7e596e150fd32a7",
  "git_url": "https://github.com/cockpit-project/cockpit/commit/211c14b39b787bf817f6cd94e7e596e150fd32a7",
  "file_path": "src/ws/cockpitauth.c",
  "func_name": "cockpit_session_launch",
  "func_before": "static CockpitSession *\ncockpit_session_launch (CockpitAuth *self,\n                        CockpitWebRequest *request,\n                        const gchar *type,\n                        const gchar *authorization,\n                        const gchar *application,\n                        GError **error)\n{\n  g_return_val_if_fail (type != NULL, NULL);\n\n  const gchar *host = application_parse_host (application);\n  const gchar *action = cockpit_conf_string (type, \"action\");\n  if (g_strcmp0 (action, ACTION_NONE) == 0)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  /* These are the credentials we'll carry around for this session */\n  g_autoptr(CockpitCreds) creds = build_session_credentials (self, request, application, host, type, authorization);\n\n  const gchar *section;\n  if (host)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (self->login_loopback && g_str_equal (type, \"basic\"))\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (g_strcmp0 (action, ACTION_SSH) == 0)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else\n    section = type;\n\n  const gchar *command = cockpit_conf_string (section, \"Command\");\n  const gchar *unix_path = cockpit_conf_string (section, \"UnixPath\");\n\n  gboolean capture_stderr = FALSE;\n  if (g_str_equal (section, COCKPIT_CONF_SSH_SECTION))\n    {\n      if (!host)\n        host = cockpit_conf_string (COCKPIT_CONF_SSH_SECTION, \"host\") ?: \"127.0.0.1\";\n\n      /* We capture stderr only for Cockpit Client; we don't want to\n       * send log messages to potential remote attackers.\n       */\n      capture_stderr = cockpit_conf_bool (\"WebService\", \"X-For-CockpitClient\", FALSE);\n\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_ssh_program;\n    }\n  else if (g_str_equal (type, \"basic\") ||\n           g_str_equal (type, \"negotiate\") ||\n           g_str_equal (type, \"tls-cert\"))\n    {\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_session_program;\n    }\n\n  g_autoptr(CockpitPipe) pipe = NULL;\n  if (command != NULL)\n    {\n      g_auto(GStrv) env = g_get_environ ();\n      if (cockpit_creds_get_rhost (creds))\n        {\n          env = g_environ_setenv (env, \"COCKPIT_REMOTE_PEER\",\n                                  cockpit_creds_get_rhost (creds),\n                                  TRUE);\n        }\n      if (g_strcmp0 (cockpit_web_request_lookup_header (request, \"X-SSH-Connect-Unknown-Hosts\"), \"yes\") == 0)\n        {\n          env = g_environ_setenv (env, \"COCKPIT_SSH_CONNECT_TO_UNKNOWN_HOSTS\",\n                                  \"1\",\n                                  TRUE);\n        }\n\n      const gchar *argv[] = { command, host ?: \"localhost\", NULL };\n      pipe = session_start_process (argv, (const gchar **)env, capture_stderr);\n    }\n  else if (unix_path != NULL)\n    {\n      g_autoptr(GSocketAddress) address = g_unix_socket_address_new (unix_path);\n      pipe = cockpit_pipe_connect (unix_path, address);\n    }\n  else\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  if (!pipe)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_FAILED,\n                   \"Authentication failed to start\");\n      return NULL;\n    }\n\n  g_autoptr(CockpitTransport) transport = cockpit_pipe_transport_new (pipe);\n  CockpitSession *session = cockpit_session_create (self, cockpit_pipe_get_name (pipe), creds, transport);\n\n  /* How long to wait for the auth process to send some data */\n  session->authorize_timeout = timeout_option (\"timeout\", section, cockpit_ws_auth_process_timeout);\n\n  /* How long to wait for a response from the client to a auth prompt */\n  session->client_timeout = timeout_option (\"response-timeout\", section, cockpit_ws_auth_response_timeout);\n\n  return session;\n}",
  "abstract_func_before": "static CockpitSession *\ncockpit_session_launch (CockpitAuth *VAR_0,\n                        CockpitWebRequest *VAR_1,\n                        const gchar *VAR_2,\n                        const gchar *VAR_3,\n                        const gchar *VAR_4,\n                        GError **VAR_5)\n{\n  g_return_val_if_fail (VAR_2 != NULL, NULL);\n\n  const gchar *VAR_6 = application_parse_host (VAR_4);\n  const gchar *VAR_7 = cockpit_conf_string (VAR_2, \"action\");\n  if (g_strcmp0 (VAR_7, VAR_8) == 0)\n    {\n      g_set_error (VAR_5, VAR_9, VAR_10,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  /* COMMENT_0 */\n  VAR_11(CockpitCreds) VAR_12 = build_session_credentials (VAR_0, VAR_1, VAR_4, VAR_6, VAR_2, VAR_3);\n\n  const gchar *VAR_13;\n  if (VAR_6)\n    VAR_13 = VAR_14;\n  else if (VAR_0->login_loopback && g_str_equal (VAR_2, \"basic\"))\n    VAR_13 = VAR_14;\n  else if (g_strcmp0 (VAR_7, VAR_15) == 0)\n    VAR_13 = VAR_14;\n  else\n    VAR_13 = VAR_2;\n\n  const gchar *VAR_16 = cockpit_conf_string (VAR_13, \"Command\");\n  const gchar *VAR_17 = cockpit_conf_string (VAR_13, \"UnixPath\");\n\n  gboolean VAR_18 = FALSE;\n  if (g_str_equal (VAR_13, VAR_14))\n    {\n      if (!VAR_6)\n        VAR_6 = cockpit_conf_string (VAR_14, \"host\") ?VAR_19: \"127.0.0.1\";\n\n      /* COMMENT_1 */\n                                                         \n         \n      VAR_18 = cockpit_conf_bool (\"WebService\", \"X-For-CockpitClient\", FALSE);\n\n      if (VAR_16 == NULL && VAR_17 == NULL)\n        VAR_16 = VAR_20;\n    }\n  else if (g_str_equal (VAR_2, \"basic\") ||\n           g_str_equal (VAR_2, \"negotiate\") ||\n           g_str_equal (VAR_2, \"tls-cert\"))\n    {\n      if (VAR_16 == NULL && VAR_17 == NULL)\n        VAR_16 = VAR_21;\n    }\n\n  VAR_11(CockpitPipe) VAR_22 = NULL;\n  if (VAR_16 != NULL)\n    {\n      VAR_23(GStrv) VAR_24 = g_get_environ ();\n      if (cockpit_creds_get_rhost (VAR_12))\n        {\n          VAR_24 = g_environ_setenv (VAR_24, \"COCKPIT_REMOTE_PEER\",\n                                  cockpit_creds_get_rhost (VAR_12),\n                                  TRUE);\n        }\n      if (g_strcmp0 (cockpit_web_request_lookup_header (VAR_1, \"X-SSH-Connect-Unknown-Hosts\"), \"yes\") == 0)\n        {\n          VAR_24 = g_environ_setenv (VAR_24, \"COCKPIT_SSH_CONNECT_TO_UNKNOWN_HOSTS\",\n                                  \"1\",\n                                  TRUE);\n        }\n\n      const gchar *VAR_25[] = { VAR_16, VAR_6 ?VAR_19: \"localhost\", NULL };\n      VAR_22 = session_start_process (VAR_25, (const gchar **)VAR_24, VAR_18);\n    }\n  else if (VAR_17 != NULL)\n    {\n      VAR_11(GSocketAddress) VAR_26 = g_unix_socket_address_new (VAR_17);\n      VAR_22 = cockpit_pipe_connect (VAR_17, VAR_26);\n    }\n  else\n    {\n      g_set_error (VAR_5, VAR_9, VAR_10,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  if (!VAR_22)\n    {\n      g_set_error (VAR_5, VAR_9, VAR_27,\n                   \"Authentication failed to start\");\n      return NULL;\n    }\n\n  VAR_11(CockpitTransport) VAR_28 = cockpit_pipe_transport_new (VAR_22);\n  CockpitSession *VAR_29 = cockpit_session_create (VAR_0, cockpit_pipe_get_name (VAR_22), VAR_12, VAR_28);\n\n  /* COMMENT_4 */\n  VAR_29->authorize_timeout = timeout_option (\"timeout\", VAR_13, VAR_30);\n\n  /* COMMENT_5 */\n  VAR_29->client_timeout = timeout_option (\"response-timeout\", VAR_13, VAR_31);\n\n  return VAR_29;\n}",
  "func_graph_path_before": "cockpit-project/cockpit/211c14b39b787bf817f6cd94e7e596e150fd32a7/cockpitauth.c/vul/before/0.json",
  "func": "static CockpitSession *\ncockpit_session_launch (CockpitAuth *self,\n                        CockpitWebRequest *request,\n                        const gchar *type,\n                        const gchar *authorization,\n                        const gchar *application,\n                        GError **error)\n{\n  g_return_val_if_fail (type != NULL, NULL);\n\n  const gchar *host = application_parse_host (application);\n  const gchar *action = cockpit_conf_string (type, \"action\");\n  if (g_strcmp0 (action, ACTION_NONE) == 0)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  /* this might be unset, which means \"allow if cockpit-ssh is installed\"; if it isn't, this will fail later on */\n  if (host && !cockpit_conf_bool (\"WebService\", \"LoginTo\", TRUE)) {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Direct remote login is disabled\");\n      return NULL;\n    }\n\n  /* These are the credentials we'll carry around for this session */\n  g_autoptr(CockpitCreds) creds = build_session_credentials (self, request, application, host, type, authorization);\n\n  const gchar *section;\n  if (host)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (self->login_loopback && g_str_equal (type, \"basic\"))\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (g_strcmp0 (action, ACTION_SSH) == 0)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else\n    section = type;\n\n  const gchar *command = cockpit_conf_string (section, \"Command\");\n  const gchar *unix_path = cockpit_conf_string (section, \"UnixPath\");\n\n  gboolean capture_stderr = FALSE;\n  if (g_str_equal (section, COCKPIT_CONF_SSH_SECTION))\n    {\n      if (!host)\n        host = cockpit_conf_string (COCKPIT_CONF_SSH_SECTION, \"host\") ?: \"127.0.0.1\";\n\n      /* We capture stderr only for Cockpit Client; we don't want to\n       * send log messages to potential remote attackers.\n       */\n      capture_stderr = cockpit_conf_bool (\"WebService\", \"X-For-CockpitClient\", FALSE);\n\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_ssh_program;\n    }\n  else if (g_str_equal (type, \"basic\") ||\n           g_str_equal (type, \"negotiate\") ||\n           g_str_equal (type, \"tls-cert\"))\n    {\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_session_program;\n    }\n\n  g_autoptr(CockpitPipe) pipe = NULL;\n  if (command != NULL)\n    {\n      g_auto(GStrv) env = g_get_environ ();\n      if (cockpit_creds_get_rhost (creds))\n        {\n          env = g_environ_setenv (env, \"COCKPIT_REMOTE_PEER\",\n                                  cockpit_creds_get_rhost (creds),\n                                  TRUE);\n        }\n      if (g_strcmp0 (cockpit_web_request_lookup_header (request, \"X-SSH-Connect-Unknown-Hosts\"), \"yes\") == 0)\n        {\n          env = g_environ_setenv (env, \"COCKPIT_SSH_CONNECT_TO_UNKNOWN_HOSTS\",\n                                  \"1\",\n                                  TRUE);\n        }\n\n      const gchar *argv[] = { command, host ?: \"localhost\", NULL };\n      pipe = session_start_process (argv, (const gchar **)env, capture_stderr);\n    }\n  else if (unix_path != NULL)\n    {\n      g_autoptr(GSocketAddress) address = g_unix_socket_address_new (unix_path);\n      pipe = cockpit_pipe_connect (unix_path, address);\n    }\n  else\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  if (!pipe)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_FAILED,\n                   \"Authentication failed to start\");\n      return NULL;\n    }\n\n  g_autoptr(CockpitTransport) transport = cockpit_pipe_transport_new (pipe);\n  CockpitSession *session = cockpit_session_create (self, cockpit_pipe_get_name (pipe), creds, transport);\n\n  /* How long to wait for the auth process to send some data */\n  session->authorize_timeout = timeout_option (\"timeout\", section, cockpit_ws_auth_process_timeout);\n\n  /* How long to wait for a response from the client to a auth prompt */\n  session->client_timeout = timeout_option (\"response-timeout\", section, cockpit_ws_auth_response_timeout);\n\n  return session;\n}",
  "abstract_func": "static CockpitSession *\ncockpit_session_launch (CockpitAuth *VAR_0,\n                        CockpitWebRequest *VAR_1,\n                        const gchar *VAR_2,\n                        const gchar *VAR_3,\n                        const gchar *VAR_4,\n                        GError **VAR_5)\n{\n  g_return_val_if_fail (VAR_2 != NULL, NULL);\n\n  const gchar *VAR_6 = application_parse_host (VAR_4);\n  const gchar *VAR_7 = cockpit_conf_string (VAR_2, \"action\");\n  if (g_strcmp0 (VAR_7, VAR_8) == 0)\n    {\n      g_set_error (VAR_5, VAR_9, VAR_10,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  /* COMMENT_0 */\n  if (VAR_6 && !cockpit_conf_bool (\"WebService\", \"LoginTo\", TRUE)) {\n      g_set_error (VAR_5, VAR_9, VAR_10,\n                   \"Direct remote login is disabled\");\n      return NULL;\n    }\n\n  /* COMMENT_1 */\n  VAR_11(CockpitCreds) VAR_12 = build_session_credentials (VAR_0, VAR_1, VAR_4, VAR_6, VAR_2, VAR_3);\n\n  const gchar *VAR_13;\n  if (VAR_6)\n    VAR_13 = VAR_14;\n  else if (VAR_0->login_loopback && g_str_equal (VAR_2, \"basic\"))\n    VAR_13 = VAR_14;\n  else if (g_strcmp0 (VAR_7, VAR_15) == 0)\n    VAR_13 = VAR_14;\n  else\n    VAR_13 = VAR_2;\n\n  const gchar *VAR_16 = cockpit_conf_string (VAR_13, \"Command\");\n  const gchar *VAR_17 = cockpit_conf_string (VAR_13, \"UnixPath\");\n\n  gboolean VAR_18 = FALSE;\n  if (g_str_equal (VAR_13, VAR_14))\n    {\n      if (!VAR_6)\n        VAR_6 = cockpit_conf_string (VAR_14, \"host\") ?VAR_19: \"127.0.0.1\";\n\n      /* COMMENT_2 */\n                                                         \n         \n      VAR_18 = cockpit_conf_bool (\"WebService\", \"X-For-CockpitClient\", FALSE);\n\n      if (VAR_16 == NULL && VAR_17 == NULL)\n        VAR_16 = VAR_20;\n    }\n  else if (g_str_equal (VAR_2, \"basic\") ||\n           g_str_equal (VAR_2, \"negotiate\") ||\n           g_str_equal (VAR_2, \"tls-cert\"))\n    {\n      if (VAR_16 == NULL && VAR_17 == NULL)\n        VAR_16 = VAR_21;\n    }\n\n  VAR_11(CockpitPipe) VAR_22 = NULL;\n  if (VAR_16 != NULL)\n    {\n      VAR_23(GStrv) VAR_24 = g_get_environ ();\n      if (cockpit_creds_get_rhost (VAR_12))\n        {\n          VAR_24 = g_environ_setenv (VAR_24, \"COCKPIT_REMOTE_PEER\",\n                                  cockpit_creds_get_rhost (VAR_12),\n                                  TRUE);\n        }\n      if (g_strcmp0 (cockpit_web_request_lookup_header (VAR_1, \"X-SSH-Connect-Unknown-Hosts\"), \"yes\") == 0)\n        {\n          VAR_24 = g_environ_setenv (VAR_24, \"COCKPIT_SSH_CONNECT_TO_UNKNOWN_HOSTS\",\n                                  \"1\",\n                                  TRUE);\n        }\n\n      const gchar *VAR_25[] = { VAR_16, VAR_6 ?VAR_19: \"localhost\", NULL };\n      VAR_22 = session_start_process (VAR_25, (const gchar **)VAR_24, VAR_18);\n    }\n  else if (VAR_17 != NULL)\n    {\n      VAR_11(GSocketAddress) VAR_26 = g_unix_socket_address_new (VAR_17);\n      VAR_22 = cockpit_pipe_connect (VAR_17, VAR_26);\n    }\n  else\n    {\n      g_set_error (VAR_5, VAR_9, VAR_10,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  if (!VAR_22)\n    {\n      g_set_error (VAR_5, VAR_9, VAR_27,\n                   \"Authentication failed to start\");\n      return NULL;\n    }\n\n  VAR_11(CockpitTransport) VAR_28 = cockpit_pipe_transport_new (VAR_22);\n  CockpitSession *VAR_29 = cockpit_session_create (VAR_0, cockpit_pipe_get_name (VAR_22), VAR_12, VAR_28);\n\n  /* COMMENT_5 */\n  VAR_29->authorize_timeout = timeout_option (\"timeout\", VAR_13, VAR_30);\n\n  /* COMMENT_6 */\n  VAR_29->client_timeout = timeout_option (\"response-timeout\", VAR_13, VAR_31);\n\n  return VAR_29;\n}",
  "func_graph_path": "cockpit-project/cockpit/211c14b39b787bf817f6cd94e7e596e150fd32a7/cockpitauth.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,13 @@\n     {\n       g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                    \"Authentication disabled\");\n+      return NULL;\n+    }\n+\n+  /* this might be unset, which means \"allow if cockpit-ssh is installed\"; if it isn't, this will fail later on */\n+  if (host && !cockpit_conf_bool (\"WebService\", \"LoginTo\", TRUE)) {\n+      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n+                   \"Direct remote login is disabled\");\n       return NULL;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      return NULL;",
      "    }",
      "",
      "  /* this might be unset, which means \"allow if cockpit-ssh is installed\"; if it isn't, this will fail later on */",
      "  if (host && !cockpit_conf_bool (\"WebService\", \"LoginTo\", TRUE)) {",
      "      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,",
      "                   \"Direct remote login is disabled\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/cockpit-project/cockpit/pull/18609",
  "description": {
    "pr_info": {
      "title": "ws: Disallow direct URL logins with LoginTo=false",
      "number": 18609
    },
    "comment": [
      "The current documentation of LoginTo= isn't very specific about what exactly happens with a \"false\" value; but it is plausible for an admin to assume that \"false\" would disallow logging into a remote host completely -- not merely hide the \"Connect to:\" field and then allowing a direct URL login anyway.\r\n\r\nIt is sometimes important to disallow direct SSH logins from the login page on publicly exposed bastion hosts, as this functionality allows unauthenticated remote users to:\r\n\r\n - scan the internal network for existing hosts, which might otherwise not be accessible directly from the internet (Fixes #18540, https://bugzilla.redhat.com/show_bug.cgi?id=2167006)\r\n\r\n - scan the cockpit-ws host or internal network hosts for open ports (Fixes #15077, https://bugzilla.redhat.com/show_bug.cgi?id=2018741)\r\n\r\nSo change ws to reject direct URL logins with `LoginTo=false`. This happens most naturally in cockpit_session_launch(), as we still want to allow remote URLs from the shell's host switcher in already authenticated sessions. This will not produce a very friendly error message, but it doesn't have to be -- at that point specifying direct URLs can be considered hacking anyway.\r\n\r\nClarify the documentation accordingly.\r\n\r\n## webserver: Disallow direct URL logins with `LoginTo=false`\r\n\r\n[cockpit.conf](https://cockpit-project.org/guide/latest/cockpit.conf.5.html) has a `LoginTo=` option. This allows the admin to disable the login page's \"Connect to:\" functionality for directly logging into a remote host through SSH. Setting it to `false` previously still left the possibility of a remote login through directly specifying an appropriate URL. With this Cockpit version, `LoginTo=false` disallows logins through remote URLs as well.\r\n\r\nIf cockpit-ws is exposed to the public internet, and also has access to a private internal network, it is recommended to explicitly set `LoginTo=false`. This prevents unauthenticated remote attackers from scanning the internal network for existing machines and open ports.",
      "@allisonkarlitskaya Tests didn't finish yet (just my local run of this specific test, and interactively), but I'd appreciate a first review whether this is the right direction. Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch modifies the authentication process to prevent direct URL logins when LoginTo is set to false, addressing a security vulnerability. The changes directly impact user authentication and are aimed at preventing unauthorized access, which aligns with security concerns."
}