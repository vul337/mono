{
  "cve_id": "CVE-2022-21656",
  "cwe_ids": [
    "CWE-843"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Specify type for matching Subject Alternative Name. (#18628)\n\n\r\nSigned-off-by: Pradeep Rao <pcrao@google.com>",
  "commit_hash": "bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "file_path": "source/extensions/transport_sockets/tls/cert_validator/default_validator.cc",
  "func_name": "DefaultCertValidator::initializeSslContexts",
  "func_before": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::type::matcher::v3::StringMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}",
  "abstract_func_before": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> VAR_0,\n                                                bool VAR_1) {\n\n  int VAR_2 = VAR_3;\n  int VAR_4 = VAR_5 | VAR_6;\n\n  if (VAR_7 != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification VAR_8 = VAR_7->trustChainVerification();\n    if (VAR_8 == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      VAR_2 = VAR_5; /* COMMENT_0 */\n                                     /* COMMENT_1 */\n      VAR_4 = VAR_5;\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->caCert().empty() && !VAR_1) {\n    VAR_9 = VAR_7->caCertPath();\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->caCert().data()), VAR_7->caCert().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      bool VAR_15 = false;\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->x509) {\n          X509_STORE_add_cert(VAR_14, VAR_16->x509);\n          if (VAR_17 == nullptr) {\n            X509_up_ref(VAR_16->x509);\n            VAR_17.reset(VAR_16->x509);\n          }\n        }\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n          VAR_15 = true;\n        }\n      }\n      if (VAR_17 == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n      }\n      if (VAR_15) {\n        X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                        ? VAR_18\n                                        : VAR_18 | VAR_19);\n      }\n      VAR_2 = VAR_5;\n      VAR_20 = true;\n\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      if (VAR_7->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(VAR_14, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->certificateRevocationList().data()),\n                        VAR_7->certificateRevocationList().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", VAR_7->certificateRevocationListPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n        }\n      }\n      X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                      ? VAR_18\n                                      : VAR_18 | VAR_19);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* VAR_21 = VAR_7;\n  if (VAR_21 != nullptr) {\n    if (!VAR_21->subjectAltNameMatchers().empty()) {\n      for (const envoy::type::matcher::v3::StringMatcher& VAR_22 :\n           VAR_21->subjectAltNameMatchers()) {\n        VAR_23.push_back(Matchers::StringMatcherImpl(VAR_22));\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateHashList().empty()) {\n      for (auto VAR_24 : VAR_21->verifyCertificateHashList()) {\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_24.size() == 95) {\n          VAR_24.erase(std::remove(VAR_24.begin(), VAR_24.end(), ':'), VAR_24.end());\n        }\n        const auto& VAR_25 = Hex::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", VAR_24));\n        }\n        VAR_27.push_back(VAR_25);\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateSpkiList().empty()) {\n      for (const auto& VAR_24 : VAR_21->verifyCertificateSpkiList()) {\n        const auto VAR_25 = Base64::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", VAR_24));\n        }\n        VAR_28.emplace_back(VAR_25.begin(), VAR_25.end());\n      }\n      VAR_2 = VAR_4;\n    }\n  }\n\n  return VAR_2;\n}",
  "func_graph_path_before": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/default_validator.cc/vul/before/1.json",
  "func": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}",
  "abstract_func": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> VAR_0,\n                                                bool VAR_1) {\n\n  int VAR_2 = VAR_3;\n  int VAR_4 = VAR_5 | VAR_6;\n\n  if (VAR_7 != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification VAR_8 = VAR_7->trustChainVerification();\n    if (VAR_8 == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      VAR_2 = VAR_5; /* COMMENT_0 */\n                                     /* COMMENT_1 */\n      VAR_4 = VAR_5;\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->caCert().empty() && !VAR_1) {\n    VAR_9 = VAR_7->caCertPath();\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->caCert().data()), VAR_7->caCert().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      bool VAR_15 = false;\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->x509) {\n          X509_STORE_add_cert(VAR_14, VAR_16->x509);\n          if (VAR_17 == nullptr) {\n            X509_up_ref(VAR_16->x509);\n            VAR_17.reset(VAR_16->x509);\n          }\n        }\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n          VAR_15 = true;\n        }\n      }\n      if (VAR_17 == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", VAR_7->caCertPath()));\n      }\n      if (VAR_15) {\n        X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                        ? VAR_18\n                                        : VAR_18 | VAR_19);\n      }\n      VAR_2 = VAR_5;\n      VAR_20 = true;\n\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      if (VAR_7->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(VAR_14, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (VAR_7 != nullptr && !VAR_7->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> VAR_10(\n        BIO_new_mem_buf(VAR_11<char*>(VAR_7->certificateRevocationList().data()),\n                        VAR_7->certificateRevocationList().size()));\n    RELEASE_ASSERT(VAR_10 != nullptr, \"\");\n\n    /* COMMENT_2 */\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_12(\n        PEM_X509_INFO_read_bio(VAR_10.get(), nullptr, nullptr, nullptr));\n    if (VAR_12 == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", VAR_7->certificateRevocationListPath()));\n    }\n\n    for (auto& VAR_13 : VAR_0) {\n      X509_STORE* VAR_14 = SSL_CTX_get_cert_store(VAR_13);\n      for (const X509_INFO* VAR_16 : VAR_12.get()) {\n        if (VAR_16->crl) {\n          X509_STORE_add_crl(VAR_14, VAR_16->crl);\n        }\n      }\n      X509_STORE_set_flags(VAR_14, VAR_7->onlyVerifyLeafCertificateCrl()\n                                      ? VAR_18\n                                      : VAR_18 | VAR_19);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* VAR_21 = VAR_7;\n  if (VAR_21 != nullptr) {\n    if (!VAR_21->subjectAltNameMatchers().empty()) {\n      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& VAR_22 :\n           VAR_21->subjectAltNameMatchers()) {\n        VAR_23.emplace_back(createStringSanMatcher(VAR_22));\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateHashList().empty()) {\n      for (auto VAR_24 : VAR_21->verifyCertificateHashList()) {\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_24.size() == 95) {\n          VAR_24.erase(std::remove(VAR_24.begin(), VAR_24.end(), ':'), VAR_24.end());\n        }\n        const auto& VAR_25 = Hex::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", VAR_24));\n        }\n        VAR_27.push_back(VAR_25);\n      }\n      VAR_2 = VAR_4;\n    }\n\n    if (!VAR_21->verifyCertificateSpkiList().empty()) {\n      for (const auto& VAR_24 : VAR_21->verifyCertificateSpkiList()) {\n        const auto VAR_25 = Base64::decode(VAR_24);\n        if (VAR_25.size() != VAR_26) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", VAR_24));\n        }\n        VAR_28.emplace_back(VAR_25.begin(), VAR_25.end());\n      }\n      VAR_2 = VAR_4;\n    }\n  }\n\n  return VAR_2;\n}",
  "func_graph_path": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/default_validator.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -96,9 +96,9 @@\n   const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n   if (cert_validation_config != nullptr) {\n     if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n-      for (const envoy::type::matcher::v3::StringMatcher& matcher :\n+      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n            cert_validation_config->subjectAltNameMatchers()) {\n-        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n+        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n       }\n       verify_mode = verify_mode_validation_context;\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "      for (const envoy::type::matcher::v3::StringMatcher& matcher :",
      "        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));"
    ],
    "added_lines": [
      "      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :",
      "        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/18628",
  "description": {
    "pr_info": {
      "title": "Specify type for matching Subject Alternative Name.",
      "number": 18628
    },
    "comment": [
      "Fixes #18259 \r\n\r\nSigned-off-by: Pradeep Rao <pcrao@google.com>\r\n\r\nCommit Message:\r\nAdditional Description:\r\nRisk Level: Low\r\nTesting: Added test\r\nDocs Changes: \r\nRelease Notes:\r\nPlatform Specific Features:\r\n\r\n",
      "CC @envoyproxy/api-shepherds: Your approval is needed for changes made to `api/envoy/`.\nenvoyproxy/api-shepherds assignee is @adisuissa\nCC @envoyproxy/api-watchers: FYI only for changes made to `api/envoy/`.\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: https://github.com/envoyproxy/envoy/pull/18628 was opened by pradeepcrao.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/18628), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/43f59d30-2d01-11ec-9ba6-f409c4fc1d41).\n</details>",
      "With regards to having enum + StringMatcher, the enums would need to be one of the pound defines here: https://boringssl.googlesource.com/boringssl/+/refs/heads/master/include/openssl/x509v3.h#174 or an identifier type from here https://datatracker.ietf.org/doc/html/rfc6125#section-1.8\r\n\r\nThe issue is that a Stringmatcher would not make sense for every enum value, just the ones we support today. \r\n\r\nMy initial implementation was exactly that : enum + Stringmatcher instead of a typed config. I changed it when the above was pointed out to me.\r\n\r\nDoes that sound reasonable?",
      "> With regards to having enum + StringMatcher, the enums would need to be one of the pound defines here: https://boringssl.googlesource.com/boringssl/+/refs/heads/master/include/openssl/x509v3.h#174 or an identifier type from here https://datatracker.ietf.org/doc/html/rfc6125#section-1.8\r\n> \r\n> The issue is that a Stringmatcher would not make sense for every enum value, just the ones we support today.\r\n> \r\n> My initial implementation was exactly that : enum + Stringmatcher instead of a typed config. I changed it when the above was pointed out to me.\r\n> \r\n> Does that sound reasonable?\r\n\r\nI guess that if most use just a string matcher, then an enum + StringMatcher should be used to simplify the code, and a TypedExtension can be used to define the Other or some alternative that we don't support out of the box.\r\nSpecifically I suggest to have a generic string matcher message:\r\n```\r\nmessage StringSanMatcher {\r\n  MatcherTypeEnum type = 1;\r\n  type.matcher.v3.StringMatcher matcher = 2;\r\n}\r\n```\r\nand the wrapper message message will use either the string matcher or the TypedExtension:\r\n```\r\nmessage SubjectAltNameMatcher {\r\n  oneof {\r\n    StringSanMatcher string_matcher = 1;\r\n    core.v3.TypedExtensionConfig typed_config = 2;\r\n  }\r\n}\r\n```\r\n\r\nNote that this holds as long as we don't expect additional fields to the derived types (e.g., if `UriSanMatcher` will probably have an additional field later, then the current design may be better).\r\n",
      "CC @envoyproxy/api-shepherds: Your approval is needed for changes made to `(api/envoy/|docs/root/api-docs/)`.\nenvoyproxy/api-shepherds assignee is @adisuissa\nCC @envoyproxy/api-watchers: FYI only for changes made to `(api/envoy/|docs/root/api-docs/)`.\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: https://github.com/envoyproxy/envoy/pull/18628 was synchronize by pradeepcrao.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/18628), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/0f3a1410-3718-11ec-8595-8e0fcd532110).\n</details>",
      "Hi @ggreenway, did you have any more comments about the PR? Are the changes satisfactory?\r\n\r\nI'm investigating the test that's failing in CI. On the face of it, it seems unrelated to this PR, as I have another PR for stats that has the same failure.",
      "/retest",
      "Retrying Azure Pipelines:\nRetried failed jobs in: [envoy-presubmit](https://dev.azure.com/cncf/4684fb3d-0389-4e0b-8251-221942316e06/_build/results?buildId=94394&view=results)\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: a https://github.com/envoyproxy/envoy/pull/18628#issuecomment-967507609 was created by @pradeepcrao.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/18628#issuecomment-967507609), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/3e4962f0-43f8-11ec-9dea-a99363924994).\n</details>",
      "/retest",
      "Retrying Azure Pipelines:\nRetried failed jobs in: [envoy-presubmit](https://dev.azure.com/cncf/4684fb3d-0389-4e0b-8251-221942316e06/_build/results?buildId=94394&view=results)\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: a https://github.com/envoyproxy/envoy/pull/18628#issuecomment-969174118 was created by @adisuissa.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/18628#issuecomment-969174118), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/33998ae0-463e-11ec-8f3e-725bde3b3c41).\n</details>",
      "The CI failure is due to a flaky test (see #19005). Will restart CI once Ryan's temporary fix #19007 is merged.",
      "/retest",
      "Retrying Azure Pipelines:\nCheck [envoy-presubmit](https://dev.azure.com/cncf/4684fb3d-0389-4e0b-8251-221942316e06/_build/results?buildId=94658&view=results) didn't fail.\n\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: a https://github.com/envoyproxy/envoy/pull/18628#issuecomment-971612189 was created by @pradeepcrao.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/18628#issuecomment-971612189), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/32f15b50-47af-11ec-9c7f-1f1794953fc7).\n</details>",
      "/retest",
      "Retrying Azure Pipelines:\nRetried failed jobs in: [envoy-presubmit](https://dev.azure.com/cncf/4684fb3d-0389-4e0b-8251-221942316e06/_build/results?buildId=94835&view=results)\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: a https://github.com/envoyproxy/envoy/pull/18628#issuecomment-974107254 was created by @pradeepcrao.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/18628#issuecomment-974107254), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/d0eb1820-4942-11ec-970c-ec4654e01002).\n</details>",
      "Hi @ggreenway, does this look good now? Do you have any pending concerns?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Step-by-step explanation:\n\n1. **Commit Message Analysis**: The commit message indicates a change related to Subject Alternative Name matching, relevant to SSL/TLS certificate validation.\n2. **Code Diff Analysis**: The code changes involve enhancing how matchers are handled, suggesting an improvement in certificate validation logic.\n3. **Vulnerability Context**: The reference to a previous issue (#18259) and added testing suggest a specific bug was addressed, possibly a security flaw.\n4. **Risk Level**: The low risk level in the vulnerability description supports that this is a fix, though it's not explicitly labeled as a security issue.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}