{
  "cve_id": "CVE-2020-12762",
  "cwe_ids": [
    "CWE-190",
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "json-c",
  "commit_msg": "Fix integer overflows.\n\nThe data structures linkhash and printbuf are limited to 2 GB in size\ndue to a signed integer being used to track their current size.\n\nIf too much data is added, then size variable can overflow, which is\nan undefined behaviour in C programming language.\n\nAssuming that a signed int overflow just leads to a negative value,\nlike it happens on many sytems (Linux i686/amd64 with gcc), then\nprintbuf is vulnerable to an out of boundary write on 64 bit systems.",
  "commit_hash": "d07b91014986900a3a75f306d302e13e005e9d67",
  "git_url": "https://github.com/json-c/json-c/commit/d07b91014986900a3a75f306d302e13e005e9d67",
  "file_path": "printbuf.c",
  "func_name": "printbuf_memset",
  "func_before": "int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)\n{\n\tint size_needed;\n\n\tif (offset == -1)\n\t\toffset = pb->bpos;\n\tsize_needed = offset + len;\n\tif (pb->size < size_needed)\n\t{\n\t\tif (printbuf_extend(pb, size_needed) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(pb->buf + offset, charvalue, len);\n\tif (pb->bpos < size_needed)\n\t\tpb->bpos = size_needed;\n\n\treturn 0;\n}",
  "abstract_func_before": "int printbuf_memset(struct printbuf *VAR_0, int VAR_1, int VAR_2, int VAR_3)\n{\n\tint VAR_4;\n\n\tif (VAR_1 == -1)\n\t\tVAR_1 = VAR_0->bpos;\n\tVAR_4 = VAR_1 + VAR_3;\n\tif (VAR_0->size < VAR_4)\n\t{\n\t\tif (printbuf_extend(VAR_0, VAR_4) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(VAR_0->buf + VAR_1, VAR_2, VAR_3);\n\tif (VAR_0->bpos < VAR_4)\n\t\tVAR_0->bpos = VAR_4;\n\n\treturn 0;\n}",
  "func_graph_path_before": "json-c/d07b91014986900a3a75f306d302e13e005e9d67/printbuf.c/vul/before/2.json",
  "func": "int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)\n{\n\tint size_needed;\n\n\tif (offset == -1)\n\t\toffset = pb->bpos;\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (len > INT_MAX - offset)\n\t\treturn -1;\n\tsize_needed = offset + len;\n\tif (pb->size < size_needed)\n\t{\n\t\tif (printbuf_extend(pb, size_needed) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(pb->buf + offset, charvalue, len);\n\tif (pb->bpos < size_needed)\n\t\tpb->bpos = size_needed;\n\n\treturn 0;\n}",
  "abstract_func": "int printbuf_memset(struct printbuf *VAR_0, int VAR_1, int VAR_2, int VAR_3)\n{\n\tint VAR_4;\n\n\tif (VAR_1 == -1)\n\t\tVAR_1 = VAR_0->bpos;\n\t/* COMMENT_0 */\n\tif (VAR_3 > VAR_5 - VAR_1)\n\t\treturn -1;\n\tVAR_4 = VAR_1 + VAR_3;\n\tif (VAR_0->size < VAR_4)\n\t{\n\t\tif (printbuf_extend(VAR_0, VAR_4) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(VAR_0->buf + VAR_1, VAR_2, VAR_3);\n\tif (VAR_0->bpos < VAR_4)\n\t\tVAR_0->bpos = VAR_4;\n\n\treturn 0;\n}",
  "func_graph_path": "json-c/d07b91014986900a3a75f306d302e13e005e9d67/printbuf.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n \n \tif (offset == -1)\n \t\toffset = pb->bpos;\n+\t/* Prevent signed integer overflows with large buffers. */\n+\tif (len > INT_MAX - offset)\n+\t\treturn -1;\n \tsize_needed = offset + len;\n \tif (pb->size < size_needed)\n \t{",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t/* Prevent signed integer overflows with large buffers. */",
      "\tif (len > INT_MAX - offset)",
      "\t\treturn -1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/json-c/json-c/pull/592",
  "description": {
    "pr_info": {
      "title": "Prevent out of boundary write on malicious input",
      "number": 592
    },
    "comment": [
      "I have discovered a way to trigger an out of boundary write while parsing a huge json file through a malicious input source. It can be triggered if an attacker has control over the input stream or if a huge load during filesystem operations can be triggered.\r\n\r\nPreparation:\r\n``$ dd if=/dev/zero of=poc.json bs=1 count=1 seek=2147483647``\r\n\r\nCode to exploit:\r\n```\r\n#include <json-c/json_util.h>\r\n#include <unistd.h>\r\nint main() {\r\n  json_object_from_fd(STDIN_FILENO);\r\n  return 0;\r\n}\r\n```\r\n\r\nProof of Concept:\r\n``(dd if=poc.json bs=4096; sleep 1; dd if=test.json bs=10) 2>/dev/null | ./test``\r\n\r\nExplanation:\r\nThe problem manifests itself in printbuf_memappend. On properly crafted values, p->bpos + size + 1 can overflow, which leads to the assumption that p->size is still large enough. In normal circumstances, this does not happen with json_object_from_fd due to its buffer size leading to proper detection. But if the parsed buffer chunk length is not a power of 2 (sleep 1 and bs=10 triggers this in my proof of concept), this overflow can be abused by an attacker to write past the memory boundary of p->buf.\r\n\r\nMy example simply crashes the program eventually. A proper attack can be controled in a way to not crash the system but simply write a few attacker controlled bytes outside the allocated area, allowing more sophisticated attacks against real world programs.",
      "\n[![Coverage Status](https://coveralls.io/builds/30606764/badge)](https://coveralls.io/builds/30606764)\n\nCoverage decreased (-0.2%) to 85.768% when pulling **d07b91014986900a3a75f306d302e13e005e9d67 on stoeckmann:oob** into **8e3d3d55449a358c662e73ce6f539d44c8053e2c on json-c:master**.\n",
      "The changes look good, thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \nThe patch addresses an integer overflow that leads to an out-of-bounds write, confirming it as a security fix."
}