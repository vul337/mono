{
  "cve_id": "CVE-2021-32020",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "FreeRTOS/FreeRTOS-Kernel",
  "commit_msg": "Improve heap2 bounds checking (#224)\n\n* Improve heap bounds checking in pvPortMalloc",
  "commit_hash": "c7a9a01c94987082b223d3e59969ede64363da63",
  "git_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63",
  "file_path": "portable/MemMang/heap_1.c",
  "func_name": "pvPortMalloc",
  "func_before": "void * pvPortMalloc( size_t xWantedSize )\n{\n    void * pvReturn = NULL;\n    static uint8_t * pucAlignedHeap = NULL;\n\n    /* Ensure that blocks are always aligned to the required number of bytes. */\n    #if ( portBYTE_ALIGNMENT != 1 )\n        {\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\n            {\n                /* Byte alignment required. */\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n    #endif\n\n    vTaskSuspendAll();\n    {\n        if( pucAlignedHeap == NULL )\n        {\n            /* Ensure the heap starts on a correctly aligned boundary. */\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n        }\n\n        /* Check there is enough room left for the allocation. */\n        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\n        {\n            /* Return the next free byte then increment the index past this\n             * block. */\n            pvReturn = pucAlignedHeap + xNextFreeByte;\n            xNextFreeByte += xWantedSize;\n        }\n\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return pvReturn;\n}",
  "abstract_func_before": "void * pvPortMalloc( size_t VAR_0 )\n{\n    void * VAR_1 = NULL;\n    static uint8_t * VAR_2 = NULL;\n\n    /* COMMENT_0 */\n    #if ( VAR_3 != 1 )\n        {\n            if( VAR_0 & VAR_4 )\n            {\n                /* COMMENT_1 */\n                VAR_0 += ( VAR_3 - ( VAR_0 & VAR_4 ) );\n            }\n        }\n    #endif\n\n    vTaskSuspendAll();\n    {\n        if( VAR_2 == NULL )\n        {\n            /* COMMENT_2 */\n            VAR_2 = ( uint8_t * ) ( ( ( VAR_5 ) & VAR_6[ VAR_3 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) VAR_4 ) ) );\n        }\n\n        /* COMMENT_3 */\n        if( ( ( VAR_7 + VAR_0 ) < VAR_8 ) &&\n            ( ( VAR_7 + VAR_0 ) > VAR_7 ) ) /* COMMENT_4 */\n        {\n            /* COMMENT_5 */\n                        \n            VAR_1 = VAR_2 + VAR_7;\n            VAR_7 += VAR_0;\n        }\n\n        traceMALLOC( VAR_1, VAR_0 );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( VAR_9 == 1 )\n        {\n            if( VAR_1 == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return VAR_1;\n}",
  "func_graph_path_before": "FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_1.c/vul/before/0.json",
  "func": "void * pvPortMalloc( size_t xWantedSize )\n{\n    void * pvReturn = NULL;\n    static uint8_t * pucAlignedHeap = NULL;\n\n    /* Ensure that blocks are always aligned. */\n    #if ( portBYTE_ALIGNMENT != 1 )\n        {\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\n            {\n                /* Byte alignment required. Check for overflow. */\n                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )\n                {\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n                } \n                else \n                {\n                    xWantedSize = 0;\n                }\n            }\n        }\n    #endif\n\n    vTaskSuspendAll();\n    {\n        if( pucAlignedHeap == NULL )\n        {\n            /* Ensure the heap starts on a correctly aligned boundary. */\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n        }\n\n        /* Check there is enough room left for the allocation and. */\n        if( ( xWantedSize > 0 ) && /* valid size */\n            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\n        {\n            /* Return the next free byte then increment the index past this\n             * block. */\n            pvReturn = pucAlignedHeap + xNextFreeByte;\n            xNextFreeByte += xWantedSize;\n        }\n\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return pvReturn;\n}",
  "abstract_func": "void * pvPortMalloc( size_t VAR_0 )\n{\n    void * VAR_1 = NULL;\n    static uint8_t * VAR_2 = NULL;\n\n    /* COMMENT_0 */\n    #if ( VAR_3 != 1 )\n        {\n            if( VAR_0 & VAR_4 )\n            {\n                /* COMMENT_1 */\n                if ( (VAR_0 + ( VAR_3 - ( VAR_0 & VAR_4 ) )) > VAR_0 )\n                {\n                    VAR_0 += ( VAR_3 - ( VAR_0 & VAR_4 ) );\n                } \n                else \n                {\n                    VAR_0 = 0;\n                }\n            }\n        }\n    #endif\n\n    vTaskSuspendAll();\n    {\n        if( VAR_2 == NULL )\n        {\n            /* COMMENT_2 */\n            VAR_2 = ( uint8_t * ) ( ( ( VAR_5 ) & VAR_6[ VAR_3 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) VAR_4 ) ) );\n        }\n\n        /* COMMENT_3 */\n        if( ( VAR_0 > 0 ) && /* COMMENT_4 */\n            ( ( VAR_7 + VAR_0 ) < VAR_8 ) &&\n            ( ( VAR_7 + VAR_0 ) > VAR_7 ) ) /* COMMENT_5 */\n        {\n            /* COMMENT_6 */\n                        \n            VAR_1 = VAR_2 + VAR_7;\n            VAR_7 += VAR_0;\n        }\n\n        traceMALLOC( VAR_1, VAR_0 );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( VAR_9 == 1 )\n        {\n            if( VAR_1 == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return VAR_1;\n}",
  "func_graph_path": "FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_1.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,13 +3,20 @@\n     void * pvReturn = NULL;\n     static uint8_t * pucAlignedHeap = NULL;\n \n-    /* Ensure that blocks are always aligned to the required number of bytes. */\n+    /* Ensure that blocks are always aligned. */\n     #if ( portBYTE_ALIGNMENT != 1 )\n         {\n             if( xWantedSize & portBYTE_ALIGNMENT_MASK )\n             {\n-                /* Byte alignment required. */\n-                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n+                /* Byte alignment required. Check for overflow. */\n+                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )\n+                {\n+                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n+                } \n+                else \n+                {\n+                    xWantedSize = 0;\n+                }\n             }\n         }\n     #endif\n@@ -22,8 +29,9 @@\n             pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n         }\n \n-        /* Check there is enough room left for the allocation. */\n-        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n+        /* Check there is enough room left for the allocation and. */\n+        if( ( xWantedSize > 0 ) && /* valid size */\n+            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n             ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */\n         {\n             /* Return the next free byte then increment the index past this",
  "diff_line_info": {
    "deleted_lines": [
      "    /* Ensure that blocks are always aligned to the required number of bytes. */",
      "                /* Byte alignment required. */",
      "                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );",
      "        /* Check there is enough room left for the allocation. */",
      "        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&"
    ],
    "added_lines": [
      "    /* Ensure that blocks are always aligned. */",
      "                /* Byte alignment required. Check for overflow. */",
      "                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )",
      "                {",
      "                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );",
      "                } ",
      "                else ",
      "                {",
      "                    xWantedSize = 0;",
      "                }",
      "        /* Check there is enough room left for the allocation and. */",
      "        if( ( xWantedSize > 0 ) && /* valid size */",
      "            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/224",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/224: 403 Client Error: Forbidden for url: https://api.github.com/repos/FreeRTOS/FreeRTOS-Kernel/pulls/224",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe commit addresses overflow prevention in the memory allocation function, aligning with the mentioned security concern. The code changes clearly add checks to prevent overflow, consistent with the purpose described.\n\nStep-by-step explanation:\n1. The commit improves bounds checking in heap memory allocation, preventing overflows.\n2. The code adds overflow checks when adjusting memory block sizes.\n3. All elements (commit, description, code) are consistent and point to a security fix.\n4. The confidence is high as the fix directly targets a security risk.\n\n**Final Output:**\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}