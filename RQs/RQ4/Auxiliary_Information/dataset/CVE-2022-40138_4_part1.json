{
  "cve_id": "CVE-2022-40138",
  "cwe_ids": [
    "CWE-681"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#822)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "6aa825e480d48127b480b08d13adf70033237097",
  "git_url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
  "file_path": "lib/BCGen/HBC/BytecodeProviderFromSrc.cpp",
  "func_name": "BCProviderFromSrc::createBCProviderFromSrcImpl",
  "func_before": "std::pair<std::unique_ptr<BCProviderFromSrc>, std::string>\nBCProviderFromSrc::createBCProviderFromSrcImpl(\n    std::unique_ptr<Buffer> buffer,\n    llvh::StringRef sourceURL,\n    std::unique_ptr<SourceMap> sourceMap,\n    const CompileFlags &compileFlags,\n    const ScopeChain &scopeChain,\n    SourceErrorManager::DiagHandlerTy diagHandler,\n    void *diagContext,\n    const std::function<void(Module &)> &runOptimizationPasses) {\n  assert(\n      buffer->data()[buffer->size()] == 0 &&\n      \"The input buffer must be null terminated\");\n\n  CodeGenerationSettings codeGenOpts{};\n  codeGenOpts.unlimitedRegisters = false;\n  codeGenOpts.instrumentIR = compileFlags.instrumentIR;\n\n  OptimizationSettings optSettings;\n  // If the optional value is not set, the parser will automatically detect\n  // the 'use static builtin' directive and we will set it correctly.\n  optSettings.staticBuiltins = compileFlags.staticBuiltins.hasValue()\n      ? compileFlags.staticBuiltins.getValue()\n      : false;\n\n  auto context = std::make_shared<Context>(codeGenOpts, optSettings);\n  std::unique_ptr<SimpleDiagHandlerRAII> outputManager;\n  if (diagHandler) {\n    context->getSourceErrorManager().setDiagHandler(diagHandler, diagContext);\n  } else {\n    outputManager.reset(\n        new SimpleDiagHandlerRAII(context->getSourceErrorManager()));\n  }\n  // If a custom diagHandler was provided, it will receive the details and we\n  // just return the string \"error\" on failure.\n  auto getErrorString = [&outputManager]() {\n    return outputManager ? outputManager->getErrorString()\n                         : std::string(\"error\");\n  };\n\n  // To avoid frequent source buffer rescans, avoid emitting warnings about\n  // undefined variables.\n  context->getSourceErrorManager().setWarningStatus(\n      Warning::UndefinedVariable, false);\n\n  context->setStrictMode(compileFlags.strict);\n  context->setEnableEval(true);\n  context->setPreemptiveFunctionCompilationThreshold(\n      compileFlags.preemptiveFunctionCompilationThreshold);\n  context->setPreemptiveFileCompilationThreshold(\n      compileFlags.preemptiveFileCompilationThreshold);\n\n  if (compileFlags.lazy && !runOptimizationPasses) {\n    context->setLazyCompilation(true);\n  }\n\n  context->setGeneratorEnabled(compileFlags.enableGenerator);\n  context->setDebugInfoSetting(\n      compileFlags.debug ? DebugInfoSetting::ALL : DebugInfoSetting::THROWING);\n  context->setEmitAsyncBreakCheck(compileFlags.emitAsyncBreakCheck);\n\n  // Populate the declFileList.\n  DeclarationFileListTy declFileList;\n  if (compileFlags.includeLibHermes) {\n    auto libBuffer = llvh::MemoryBuffer::getMemBuffer(libhermes);\n    parser::JSParser libParser(*context, std::move(libBuffer));\n    auto libParsed = libParser.parse();\n    assert(libParsed && \"Libhermes failed to parse\");\n    declFileList.push_back(libParsed.getValue());\n  }\n\n  bool isLargeFile =\n      buffer->size() >= context->getPreemptiveFileCompilationThreshold();\n  int fileBufId = context->getSourceErrorManager().addNewSourceBuffer(\n      std::make_unique<HermesLLVMMemoryBuffer>(std::move(buffer), sourceURL));\n  if (sourceMap != nullptr) {\n    auto sourceMapTranslator =\n        std::make_shared<SourceMapTranslator>(context->getSourceErrorManager());\n    context->getSourceErrorManager().setTranslator(sourceMapTranslator);\n    sourceMapTranslator->addSourceMap(fileBufId, std::move(sourceMap));\n  }\n\n  auto parserMode = parser::FullParse;\n  bool useStaticBuiltinDetected = false;\n  if (context->isLazyCompilation() && isLargeFile) {\n    if (!parser::JSParser::preParseBuffer(\n            *context, fileBufId, useStaticBuiltinDetected)) {\n      return {nullptr, getErrorString()};\n    }\n    parserMode = parser::LazyParse;\n  }\n\n  sem::SemContext semCtx{};\n  parser::JSParser parser(*context, fileBufId, parserMode);\n  auto parsed = parser.parse();\n  if (!parsed || !hermes::sem::validateAST(*context, semCtx, *parsed)) {\n    return {nullptr, getErrorString()};\n  }\n  // If we are using lazy parse mode, we should have already detected the 'use\n  // static builtin' directive in the pre-parsing stage.\n  if (parserMode != parser::LazyParse) {\n    useStaticBuiltinDetected = parser.getUseStaticBuiltin();\n  }\n  // The compiler flag is not set, automatically detect 'use static builtin'\n  // from the source.\n  if (!compileFlags.staticBuiltins) {\n    context->setStaticBuiltinOptimization(useStaticBuiltinDetected);\n  }\n\n  Module M(context);\n  hermes::generateIRFromESTree(parsed.getValue(), &M, declFileList, scopeChain);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, getErrorString()};\n  }\n\n  if (runOptimizationPasses)\n    runOptimizationPasses(M);\n\n  BytecodeGenerationOptions opts{compileFlags.format};\n  opts.optimizationEnabled = !!runOptimizationPasses;\n  opts.staticBuiltinsEnabled =\n      context->getOptimizationSettings().staticBuiltins;\n  opts.verifyIR = compileFlags.verifyIR;\n  auto bytecode = createBCProviderFromSrc(\n      hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts));\n  bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue());\n  return {std::move(bytecode), std::string{}};\n}",
  "abstract_func_before": "std::pair<std::unique_ptr<BCProviderFromSrc>, std::string>\nBCProviderFromSrc::createBCProviderFromSrcImpl(\n    std::unique_ptr<Buffer> VAR_0,\n    llvh::StringRef VAR_1,\n    std::unique_ptr<SourceMap> VAR_2,\n    const CompileFlags &VAR_3,\n    const ScopeChain &VAR_4,\n    SourceErrorManager::DiagHandlerTy VAR_5,\n    void *VAR_6,\n    const std::function<void(Module &)> &VAR_7) {\n  assert(\n      VAR_0->data()[VAR_0->size()] == 0 &&\n      \"The input buffer must be null terminated\");\n\n  CodeGenerationSettings VAR_8{};\n  VAR_8.unlimitedRegisters = false;\n  VAR_8.instrumentIR = VAR_3.instrumentIR;\n\n  OptimizationSettings VAR_9;\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_9.staticBuiltins = VAR_3.staticBuiltins.hasValue()\n      ? VAR_3.staticBuiltins.getValue()\n      : false;\n\n  auto VAR_10 = std::VAR_11<Context>(VAR_8, VAR_9);\n  std::unique_ptr<SimpleDiagHandlerRAII> VAR_12;\n  if (VAR_5) {\n    VAR_10->getSourceErrorManager().setDiagHandler(VAR_5, VAR_6);\n  } else {\n    VAR_12.reset(\n        new SimpleDiagHandlerRAII(VAR_10->getSourceErrorManager()));\n  }\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  auto VAR_13 = [&VAR_12]() {\n    return VAR_12 ? VAR_12->getErrorString()\n                         : std::string(\"error\");\n  };\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  VAR_10->getSourceErrorManager().setWarningStatus(\n      Warning::UndefinedVariable, false);\n\n  VAR_10->setStrictMode(VAR_3.strict);\n  VAR_10->setEnableEval(true);\n  VAR_10->setPreemptiveFunctionCompilationThreshold(\n      VAR_3.preemptiveFunctionCompilationThreshold);\n  VAR_10->setPreemptiveFileCompilationThreshold(\n      VAR_3.preemptiveFileCompilationThreshold);\n\n  if (VAR_3.lazy && !VAR_7) {\n    VAR_10->setLazyCompilation(true);\n  }\n\n  VAR_10->setGeneratorEnabled(VAR_3.enableGenerator);\n  VAR_10->setDebugInfoSetting(\n      VAR_3.debug ? DebugInfoSetting::ALL : DebugInfoSetting::THROWING);\n  VAR_10->setEmitAsyncBreakCheck(VAR_3.emitAsyncBreakCheck);\n\n  /* COMMENT_6 */\n  DeclarationFileListTy VAR_14;\n  if (VAR_3.includeLibHermes) {\n    auto VAR_15 = llvh::MemoryBuffer::getMemBuffer(VAR_16);\n    parser::JSParser VAR_17(*VAR_10, std::move(VAR_15));\n    auto VAR_18 = VAR_17.parse();\n    assert(VAR_18 && \"Libhermes failed to parse\");\n    VAR_14.push_back(VAR_18.getValue());\n  }\n\n  bool VAR_19 =\n      VAR_0->size() >= VAR_10->getPreemptiveFileCompilationThreshold();\n  int VAR_20 = VAR_10->getSourceErrorManager().addNewSourceBuffer(\n      std::VAR_21<HermesLLVMMemoryBuffer>(std::move(VAR_0), VAR_1));\n  if (VAR_2 != nullptr) {\n    auto VAR_22 =\n        std::VAR_11<SourceMapTranslator>(VAR_10->getSourceErrorManager());\n    VAR_10->getSourceErrorManager().setTranslator(VAR_22);\n    VAR_22->addSourceMap(VAR_20, std::move(VAR_2));\n  }\n\n  auto VAR_23 = parser::FullParse;\n  bool VAR_24 = false;\n  if (VAR_10->isLazyCompilation() && VAR_19) {\n    if (!parser::JSParser::preParseBuffer(\n            *VAR_10, VAR_20, VAR_24)) {\n      return {nullptr, VAR_13()};\n    }\n    VAR_23 = parser::LazyParse;\n  }\n\n  sem::SemContext VAR_25{};\n  parser::JSParser VAR_26(*VAR_10, VAR_20, VAR_23);\n  auto VAR_27 = VAR_26.parse();\n  if (!VAR_27 || !hermes::sem::validateAST(*VAR_10, VAR_25, *VAR_27)) {\n    return {nullptr, VAR_13()};\n  }\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (VAR_23 != parser::LazyParse) {\n    VAR_24 = VAR_26.getUseStaticBuiltin();\n  }\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  if (!VAR_3.staticBuiltins) {\n    VAR_10->setStaticBuiltinOptimization(VAR_24);\n  }\n\n  Module M(context);\n  hermes::generateIRFromESTree(VAR_27.getValue(), &VAR_28, VAR_14, VAR_4);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, VAR_13()};\n  }\n\n  if (VAR_7)\n    VAR_7(VAR_28);\n\n  BytecodeGenerationOptions VAR_29{VAR_3.format};\n  VAR_29.optimizationEnabled = !!VAR_7;\n  VAR_29.staticBuiltinsEnabled =\n      context->getOptimizationSettings().staticBuiltins;\n  VAR_29.verifyIR = VAR_3.verifyIR;\n  auto VAR_30 = createBCProviderFromSrc(\n      hbc::generateBytecodeModule(&VAR_28, VAR_28.getTopLevelFunction(), VAR_29));\n  VAR_30->singleFunction_ = isSingleFunctionExpression(VAR_27.getValue());\n  return {std::move(VAR_30), std::string{}};\n}",
  "func_graph_path_before": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/BytecodeProviderFromSrc.cpp/vul/before/0.json",
  "func": "std::pair<std::unique_ptr<BCProviderFromSrc>, std::string>\nBCProviderFromSrc::createBCProviderFromSrcImpl(\n    std::unique_ptr<Buffer> buffer,\n    llvh::StringRef sourceURL,\n    std::unique_ptr<SourceMap> sourceMap,\n    const CompileFlags &compileFlags,\n    const ScopeChain &scopeChain,\n    SourceErrorManager::DiagHandlerTy diagHandler,\n    void *diagContext,\n    const std::function<void(Module &)> &runOptimizationPasses) {\n  assert(\n      buffer->data()[buffer->size()] == 0 &&\n      \"The input buffer must be null terminated\");\n\n  CodeGenerationSettings codeGenOpts{};\n  codeGenOpts.unlimitedRegisters = false;\n  codeGenOpts.instrumentIR = compileFlags.instrumentIR;\n\n  OptimizationSettings optSettings;\n  // If the optional value is not set, the parser will automatically detect\n  // the 'use static builtin' directive and we will set it correctly.\n  optSettings.staticBuiltins = compileFlags.staticBuiltins.hasValue()\n      ? compileFlags.staticBuiltins.getValue()\n      : false;\n\n  auto context = std::make_shared<Context>(codeGenOpts, optSettings);\n  std::unique_ptr<SimpleDiagHandlerRAII> outputManager;\n  if (diagHandler) {\n    context->getSourceErrorManager().setDiagHandler(diagHandler, diagContext);\n  } else {\n    outputManager.reset(\n        new SimpleDiagHandlerRAII(context->getSourceErrorManager()));\n  }\n  // If a custom diagHandler was provided, it will receive the details and we\n  // just return the string \"error\" on failure.\n  auto getErrorString = [&outputManager]() {\n    return outputManager ? outputManager->getErrorString()\n                         : std::string(\"error\");\n  };\n\n  // To avoid frequent source buffer rescans, avoid emitting warnings about\n  // undefined variables.\n  context->getSourceErrorManager().setWarningStatus(\n      Warning::UndefinedVariable, false);\n\n  context->setStrictMode(compileFlags.strict);\n  context->setEnableEval(true);\n  context->setPreemptiveFunctionCompilationThreshold(\n      compileFlags.preemptiveFunctionCompilationThreshold);\n  context->setPreemptiveFileCompilationThreshold(\n      compileFlags.preemptiveFileCompilationThreshold);\n\n  if (compileFlags.lazy && !runOptimizationPasses) {\n    context->setLazyCompilation(true);\n  }\n\n  context->setGeneratorEnabled(compileFlags.enableGenerator);\n  context->setDebugInfoSetting(\n      compileFlags.debug ? DebugInfoSetting::ALL : DebugInfoSetting::THROWING);\n  context->setEmitAsyncBreakCheck(compileFlags.emitAsyncBreakCheck);\n\n  // Populate the declFileList.\n  DeclarationFileListTy declFileList;\n  if (compileFlags.includeLibHermes) {\n    auto libBuffer = llvh::MemoryBuffer::getMemBuffer(libhermes);\n    parser::JSParser libParser(*context, std::move(libBuffer));\n    auto libParsed = libParser.parse();\n    assert(libParsed && \"Libhermes failed to parse\");\n    declFileList.push_back(libParsed.getValue());\n  }\n\n  bool isLargeFile =\n      buffer->size() >= context->getPreemptiveFileCompilationThreshold();\n  int fileBufId = context->getSourceErrorManager().addNewSourceBuffer(\n      std::make_unique<HermesLLVMMemoryBuffer>(std::move(buffer), sourceURL));\n  if (sourceMap != nullptr) {\n    auto sourceMapTranslator =\n        std::make_shared<SourceMapTranslator>(context->getSourceErrorManager());\n    context->getSourceErrorManager().setTranslator(sourceMapTranslator);\n    sourceMapTranslator->addSourceMap(fileBufId, std::move(sourceMap));\n  }\n\n  auto parserMode = parser::FullParse;\n  bool useStaticBuiltinDetected = false;\n  if (context->isLazyCompilation() && isLargeFile) {\n    if (!parser::JSParser::preParseBuffer(\n            *context, fileBufId, useStaticBuiltinDetected)) {\n      return {nullptr, getErrorString()};\n    }\n    parserMode = parser::LazyParse;\n  }\n\n  sem::SemContext semCtx{};\n  parser::JSParser parser(*context, fileBufId, parserMode);\n  auto parsed = parser.parse();\n  if (!parsed || !hermes::sem::validateAST(*context, semCtx, *parsed)) {\n    return {nullptr, getErrorString()};\n  }\n  // If we are using lazy parse mode, we should have already detected the 'use\n  // static builtin' directive in the pre-parsing stage.\n  if (parserMode != parser::LazyParse) {\n    useStaticBuiltinDetected = parser.getUseStaticBuiltin();\n  }\n  // The compiler flag is not set, automatically detect 'use static builtin'\n  // from the source.\n  if (!compileFlags.staticBuiltins) {\n    context->setStaticBuiltinOptimization(useStaticBuiltinDetected);\n  }\n\n  Module M(context);\n  hermes::generateIRFromESTree(parsed.getValue(), &M, declFileList, scopeChain);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, getErrorString()};\n  }\n\n  if (runOptimizationPasses)\n    runOptimizationPasses(M);\n\n  BytecodeGenerationOptions opts{compileFlags.format};\n  opts.optimizationEnabled = !!runOptimizationPasses;\n  opts.staticBuiltinsEnabled =\n      context->getOptimizationSettings().staticBuiltins;\n  opts.verifyIR = compileFlags.verifyIR;\n  auto BM = hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, getErrorString()};\n  }\n  auto bytecode = createBCProviderFromSrc(std::move(BM));\n  bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue());\n  return {std::move(bytecode), std::string{}};\n}",
  "abstract_func": "std::pair<std::unique_ptr<BCProviderFromSrc>, std::string>\nBCProviderFromSrc::createBCProviderFromSrcImpl(\n    std::unique_ptr<Buffer> VAR_0,\n    llvh::StringRef VAR_1,\n    std::unique_ptr<SourceMap> VAR_2,\n    const CompileFlags &VAR_3,\n    const ScopeChain &VAR_4,\n    SourceErrorManager::DiagHandlerTy VAR_5,\n    void *VAR_6,\n    const std::function<void(Module &)> &VAR_7) {\n  assert(\n      VAR_0->data()[VAR_0->size()] == 0 &&\n      \"The input buffer must be null terminated\");\n\n  CodeGenerationSettings VAR_8{};\n  VAR_8.unlimitedRegisters = false;\n  VAR_8.instrumentIR = VAR_3.instrumentIR;\n\n  OptimizationSettings VAR_9;\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_9.staticBuiltins = VAR_3.staticBuiltins.hasValue()\n      ? VAR_3.staticBuiltins.getValue()\n      : false;\n\n  auto VAR_10 = std::VAR_11<Context>(VAR_8, VAR_9);\n  std::unique_ptr<SimpleDiagHandlerRAII> VAR_12;\n  if (VAR_5) {\n    VAR_10->getSourceErrorManager().setDiagHandler(VAR_5, VAR_6);\n  } else {\n    VAR_12.reset(\n        new SimpleDiagHandlerRAII(VAR_10->getSourceErrorManager()));\n  }\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  auto VAR_13 = [&VAR_12]() {\n    return VAR_12 ? VAR_12->getErrorString()\n                         : std::string(\"error\");\n  };\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  VAR_10->getSourceErrorManager().setWarningStatus(\n      Warning::UndefinedVariable, false);\n\n  VAR_10->setStrictMode(VAR_3.strict);\n  VAR_10->setEnableEval(true);\n  VAR_10->setPreemptiveFunctionCompilationThreshold(\n      VAR_3.preemptiveFunctionCompilationThreshold);\n  VAR_10->setPreemptiveFileCompilationThreshold(\n      VAR_3.preemptiveFileCompilationThreshold);\n\n  if (VAR_3.lazy && !VAR_7) {\n    VAR_10->setLazyCompilation(true);\n  }\n\n  VAR_10->setGeneratorEnabled(VAR_3.enableGenerator);\n  VAR_10->setDebugInfoSetting(\n      VAR_3.debug ? DebugInfoSetting::ALL : DebugInfoSetting::THROWING);\n  VAR_10->setEmitAsyncBreakCheck(VAR_3.emitAsyncBreakCheck);\n\n  /* COMMENT_6 */\n  DeclarationFileListTy VAR_14;\n  if (VAR_3.includeLibHermes) {\n    auto VAR_15 = llvh::MemoryBuffer::getMemBuffer(VAR_16);\n    parser::JSParser VAR_17(*VAR_10, std::move(VAR_15));\n    auto VAR_18 = VAR_17.parse();\n    assert(VAR_18 && \"Libhermes failed to parse\");\n    VAR_14.push_back(VAR_18.getValue());\n  }\n\n  bool VAR_19 =\n      VAR_0->size() >= VAR_10->getPreemptiveFileCompilationThreshold();\n  int VAR_20 = VAR_10->getSourceErrorManager().addNewSourceBuffer(\n      std::VAR_21<HermesLLVMMemoryBuffer>(std::move(VAR_0), VAR_1));\n  if (VAR_2 != nullptr) {\n    auto VAR_22 =\n        std::VAR_11<SourceMapTranslator>(VAR_10->getSourceErrorManager());\n    VAR_10->getSourceErrorManager().setTranslator(VAR_22);\n    VAR_22->addSourceMap(VAR_20, std::move(VAR_2));\n  }\n\n  auto VAR_23 = parser::FullParse;\n  bool VAR_24 = false;\n  if (VAR_10->isLazyCompilation() && VAR_19) {\n    if (!parser::JSParser::preParseBuffer(\n            *VAR_10, VAR_20, VAR_24)) {\n      return {nullptr, VAR_13()};\n    }\n    VAR_23 = parser::LazyParse;\n  }\n\n  sem::SemContext VAR_25{};\n  parser::JSParser VAR_26(*VAR_10, VAR_20, VAR_23);\n  auto VAR_27 = VAR_26.parse();\n  if (!VAR_27 || !hermes::sem::validateAST(*VAR_10, VAR_25, *VAR_27)) {\n    return {nullptr, VAR_13()};\n  }\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (VAR_23 != parser::LazyParse) {\n    VAR_24 = VAR_26.getUseStaticBuiltin();\n  }\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  if (!VAR_3.staticBuiltins) {\n    VAR_10->setStaticBuiltinOptimization(VAR_24);\n  }\n\n  Module M(context);\n  hermes::generateIRFromESTree(VAR_27.getValue(), &VAR_28, VAR_14, VAR_4);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, VAR_13()};\n  }\n\n  if (VAR_7)\n    VAR_7(VAR_28);\n\n  BytecodeGenerationOptions VAR_29{VAR_3.format};\n  VAR_29.optimizationEnabled = !!VAR_7;\n  VAR_29.staticBuiltinsEnabled =\n      context->getOptimizationSettings().staticBuiltins;\n  VAR_29.verifyIR = VAR_3.verifyIR;\n  auto VAR_30 = hbc::generateBytecodeModule(&VAR_28, VAR_28.getTopLevelFunction(), VAR_29);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, VAR_13()};\n  }\n  auto VAR_31 = createBCProviderFromSrc(std::move(VAR_30));\n  VAR_31->singleFunction_ = isSingleFunctionExpression(VAR_27.getValue());\n  return {std::move(VAR_31), std::string{}};\n}",
  "func_graph_path": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/BytecodeProviderFromSrc.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -121,8 +121,11 @@\n   opts.staticBuiltinsEnabled =\n       context->getOptimizationSettings().staticBuiltins;\n   opts.verifyIR = compileFlags.verifyIR;\n-  auto bytecode = createBCProviderFromSrc(\n-      hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts));\n+  auto BM = hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts);\n+  if (context->getSourceErrorManager().getErrorCount() > 0) {\n+    return {nullptr, getErrorString()};\n+  }\n+  auto bytecode = createBCProviderFromSrc(std::move(BM));\n   bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue());\n   return {std::move(bytecode), std::string{}};\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  auto bytecode = createBCProviderFromSrc(",
      "      hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts));"
    ],
    "added_lines": [
      "  auto BM = hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts);",
      "  if (context->getSourceErrorManager().getErrorCount() > 0) {",
      "    return {nullptr, getErrorString()};",
      "  }",
      "  auto bytecode = createBCProviderFromSrc(std::move(BM));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/822",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/hermes/pull/822: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/hermes/pulls/822",
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 0.6  \nThe patch is primarily about re-syncing repositories, with code changes adding error handling, likely as part of the synchronization process rather than addressing a specific defect or security issue. The confidence is moderate due to the ambiguity in the commit's intent."
}