{
  "cve_id": "CVE-2023-45897",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "exfatprogs",
  "commit_msg": "fsck: fix out-of-bounds write in read_file_dentry_set\n\nif SecondaryCount is greater than (2 + the max number\nof File Name entries), writing to memory outside\nthe node->name could happen.\n\nReported-by: Maxim Suhanov <dfirblog@gmail.com>\nSigned-off-by: Hyunchul Lee <hyc.lee@gmail.com>\nReviewed-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
  "commit_hash": "ec78688e5fb5a70e13df82b4c0da1e6228d3ccdf",
  "git_url": "https://github.com/exfatprogs/exfatprogs/commit/ec78688e5fb5a70e13df82b4c0da1e6228d3ccdf",
  "file_path": "fsck/fsck.c",
  "func_name": "read_file_dentry_set",
  "func_before": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tbool need_delete = false;\n\tuint16_t checksum;\n\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_err(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchecksum = file_calc_checksum(iter);\n\tif (checksum != le16_to_cpu(file_de->file_checksum)) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_CHECKSUM,\n\t\t\t\t    \"the checksum of a file is wrong\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext < 2) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_SECONDARY_COUNT,\n\t\t\t\t    \"a file has too few secondary count. %d\",\n\t\t\t\t    file_de->file_num_ext))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_STREAM,\n\t\t\t\t    \"failed to get stream dentry\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME) {\n\t\t\tif (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(iter, 0, &file_de);\n\t\t\t\tfile_de->file_num_ext = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*skip_dentries = i + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tret = check_name_dentry_set(iter, node);\n\tif (ret) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {\n\t\tret = handle_dot_dotdot_filename(iter, dentry,\n\t\t\t\tstream_de->stream_name_len);\n\t\tif (ret < 0) {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\n\tif (node->size < le64_to_cpu(stream_de->stream_valid_size)) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tif (repair_file_ask(iter, node, ER_FILE_VALID_SIZE,\n\t\t\t\t    \"valid size %\" PRIu64 \" greater than size %\" PRIu64,\n\t\t\t\t    le64_to_cpu(stream_de->stream_valid_size),\n\t\t\t\t    node->size)) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_valid_size =\n\t\t\t\t\tstream_de->stream_size;\n\t\t} else {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\t*skip_dentries = (file_de->file_num_ext + 1);\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\tif (need_delete) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->type &= EXFAT_DELETE;\n\t}\n\tfor (i = 1; i < *skip_dentries; i++) {\n\t\texfat_de_iter_get(iter, i, &dentry);\n\t\tif (dentry->type == EXFAT_FILE)\n\t\t\tbreak;\n\t\tif (need_delete) {\n\t\t\texfat_de_iter_get_dirty(iter, i, &dentry);\n\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t}\n\t}\n\t*skip_dentries = i;\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn need_delete ? 1 : -EINVAL;\n}",
  "abstract_func_before": "static int read_file_dentry_set(struct exfat_de_iter *VAR_0,\n\t\t\t\tstruct exfat_inode **VAR_1, int *VAR_2)\n{\n\tstruct exfat_dentry *VAR_3, *VAR_4, *VAR_5;\n\tstruct exfat_inode *VAR_6 = NULL;\n\tint VAR_7, VAR_8;\n\tbool VAR_9 = false;\n\tuint16_t VAR_10;\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 0, &VAR_3);\n\tif (VAR_8 || VAR_3->type != VAR_11) {\n\t\texfat_err(\"failed to get file dentry\\n\");\n\t\treturn -VAR_12;\n\t}\n\n\tVAR_10 = file_calc_checksum(VAR_0);\n\tif (VAR_10 != le16_to_cpu(VAR_3->file_checksum)) {\n\t\tif (repair_file_ask(VAR_0, NULL, VAR_13,\n\t\t\t\t    \"the checksum of a file is wrong\"))\n\t\t\tVAR_9 = true;\n\t\t*VAR_2 = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (VAR_3->file_num_ext < 2) {\n\t\tif (repair_file_ask(VAR_0, NULL, VAR_14,\n\t\t\t\t    \"a file has too few secondary count. %d\",\n\t\t\t\t    VAR_3->file_num_ext))\n\t\t\tVAR_9 = true;\n\t\t*VAR_2 = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 1, &VAR_4);\n\tif (VAR_8 || VAR_4->type != VAR_15) {\n\t\tif (repair_file_ask(VAR_0, NULL, VAR_16,\n\t\t\t\t    \"failed to get stream dentry\"))\n\t\t\tVAR_9 = true;\n\t\t*VAR_2 = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*VAR_1 = NULL;\n\tVAR_6 = exfat_alloc_inode(le16_to_cpu(VAR_3->file_attr));\n\tif (!VAR_6)\n\t\treturn -VAR_17;\n\n\tfor (VAR_7 = 2; VAR_7 <= VAR_3->file_num_ext; VAR_7++) {\n\t\tVAR_8 = exfat_de_iter_get(VAR_0, VAR_7, &VAR_5);\n\t\tif (VAR_8 || VAR_5->type != VAR_18) {\n\t\t\tif (VAR_7 > 2 && repair_file_ask(VAR_0, NULL, VAR_19,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(VAR_0, 0, &VAR_3);\n\t\t\t\tVAR_3->file_num_ext = VAR_7 - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*VAR_2 = VAR_7 + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\n\t\tmemcpy(VAR_6->name +\n\t\t       (VAR_7 - 2) * VAR_20, VAR_5->name_unicode,\n\t\t       sizeof(VAR_5->name_unicode));\n\t}\n\n\tVAR_8 = check_name_dentry_set(VAR_0, VAR_6);\n\tif (VAR_8) {\n\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (VAR_3->file_num_ext == 2 && VAR_4->stream_name_len <= 2) {\n\t\tVAR_8 = handle_dot_dotdot_filename(VAR_0, VAR_5,\n\t\t\t\tVAR_4->stream_name_len);\n\t\tif (VAR_8 < 0) {\n\t\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\tVAR_6->first_clus = le32_to_cpu(VAR_4->stream_start_clu);\n\tVAR_6->is_contiguous =\n\t\t((VAR_4->stream_flags & VAR_21) != 0);\n\tVAR_6->size = le64_to_cpu(VAR_4->stream_size);\n\n\tif (VAR_6->size < le64_to_cpu(VAR_4->stream_valid_size)) {\n\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\tif (repair_file_ask(VAR_0, VAR_6, VAR_22,\n\t\t\t\t    \"valid size %\" VAR_23 \" greater than size %\" VAR_23,\n\t\t\t\t    le64_to_cpu(VAR_4->stream_valid_size),\n\t\t\t\t    VAR_6->size)) {\n\t\t\texfat_de_iter_get_dirty(VAR_0, 1, &VAR_4);\n\t\t\tVAR_4->stream_valid_size =\n\t\t\t\t\tVAR_4->stream_size;\n\t\t} else {\n\t\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\t*VAR_2 = (VAR_3->file_num_ext + 1);\n\t*VAR_1 = VAR_6;\n\treturn 0;\nskip_dset:\n\tif (VAR_9) {\n\t\texfat_de_iter_get_dirty(VAR_0, 0, &VAR_5);\n\t\tVAR_5->type &= VAR_24;\n\t}\n\tfor (VAR_7 = 1; VAR_7 < *VAR_2; VAR_7++) {\n\t\texfat_de_iter_get(VAR_0, VAR_7, &VAR_5);\n\t\tif (VAR_5->type == VAR_11)\n\t\t\tbreak;\n\t\tif (VAR_9) {\n\t\t\texfat_de_iter_get_dirty(VAR_0, VAR_7, &VAR_5);\n\t\t\tVAR_5->type &= VAR_24;\n\t\t}\n\t}\n\t*VAR_2 = VAR_7;\n\t*VAR_1 = NULL;\n\texfat_free_inode(VAR_6);\n\treturn VAR_9 ? 1 : -VAR_12;\n}",
  "func_graph_path_before": "exfatprogs/ec78688e5fb5a70e13df82b4c0da1e6228d3ccdf/fsck.c/vul/before/0.json",
  "func": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tbool need_delete = false;\n\tuint16_t checksum;\n\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_err(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchecksum = file_calc_checksum(iter);\n\tif (checksum != le16_to_cpu(file_de->file_checksum)) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_CHECKSUM,\n\t\t\t\t    \"the checksum of a file is wrong\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext < 2) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_SECONDARY_COUNT,\n\t\t\t\t    \"a file has too few secondary count. %d\",\n\t\t\t\t    file_de->file_num_ext))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_STREAM,\n\t\t\t\t    \"failed to get stream dentry\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME) {\n\t\t\tif (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(iter, 0, &file_de);\n\t\t\t\tfile_de->file_num_ext = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*skip_dentries = i + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tret = check_name_dentry_set(iter, node);\n\tif (ret) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {\n\t\tret = handle_dot_dotdot_filename(iter, dentry,\n\t\t\t\tstream_de->stream_name_len);\n\t\tif (ret < 0) {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\n\tif (node->size < le64_to_cpu(stream_de->stream_valid_size)) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tif (repair_file_ask(iter, node, ER_FILE_VALID_SIZE,\n\t\t\t\t    \"valid size %\" PRIu64 \" greater than size %\" PRIu64,\n\t\t\t\t    le64_to_cpu(stream_de->stream_valid_size),\n\t\t\t\t    node->size)) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_valid_size =\n\t\t\t\t\tstream_de->stream_size;\n\t\t} else {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\t*skip_dentries = (file_de->file_num_ext + 1);\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\tif (need_delete) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->type &= EXFAT_DELETE;\n\t}\n\tfor (i = 1; i < *skip_dentries; i++) {\n\t\texfat_de_iter_get(iter, i, &dentry);\n\t\tif (dentry->type == EXFAT_FILE)\n\t\t\tbreak;\n\t\tif (need_delete) {\n\t\t\texfat_de_iter_get_dirty(iter, i, &dentry);\n\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t}\n\t}\n\t*skip_dentries = i;\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn need_delete ? 1 : -EINVAL;\n}",
  "abstract_func": "static int read_file_dentry_set(struct exfat_de_iter *VAR_0,\n\t\t\t\tstruct exfat_inode **VAR_1, int *VAR_2)\n{\n\tstruct exfat_dentry *VAR_3, *VAR_4, *VAR_5;\n\tstruct exfat_inode *VAR_6 = NULL;\n\tint VAR_7, VAR_8;\n\tbool VAR_9 = false;\n\tuint16_t VAR_10;\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 0, &VAR_3);\n\tif (VAR_8 || VAR_3->type != VAR_11) {\n\t\texfat_err(\"failed to get file dentry\\n\");\n\t\treturn -VAR_12;\n\t}\n\n\tVAR_10 = file_calc_checksum(VAR_0);\n\tif (VAR_10 != le16_to_cpu(VAR_3->file_checksum)) {\n\t\tif (repair_file_ask(VAR_0, NULL, VAR_13,\n\t\t\t\t    \"the checksum of a file is wrong\"))\n\t\t\tVAR_9 = true;\n\t\t*VAR_2 = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (VAR_3->file_num_ext < 2) {\n\t\tif (repair_file_ask(VAR_0, NULL, VAR_14,\n\t\t\t\t    \"a file has too few secondary count. %d\",\n\t\t\t\t    VAR_3->file_num_ext))\n\t\t\tVAR_9 = true;\n\t\t*VAR_2 = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tVAR_8 = exfat_de_iter_get(VAR_0, 1, &VAR_4);\n\tif (VAR_8 || VAR_4->type != VAR_15) {\n\t\tif (repair_file_ask(VAR_0, NULL, VAR_16,\n\t\t\t\t    \"failed to get stream dentry\"))\n\t\t\tVAR_9 = true;\n\t\t*VAR_2 = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*VAR_1 = NULL;\n\tVAR_6 = exfat_alloc_inode(le16_to_cpu(VAR_3->file_attr));\n\tif (!VAR_6)\n\t\treturn -VAR_17;\n\n\tfor (VAR_7 = 2; VAR_7 <= MIN(VAR_3->file_num_ext, 1 + VAR_18); VAR_7++) {\n\t\tVAR_8 = exfat_de_iter_get(VAR_0, VAR_7, &VAR_5);\n\t\tif (VAR_8 || VAR_5->type != VAR_19) {\n\t\t\tif (VAR_7 > 2 && repair_file_ask(VAR_0, NULL, VAR_20,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(VAR_0, 0, &VAR_3);\n\t\t\t\tVAR_3->file_num_ext = VAR_7 - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*VAR_2 = VAR_7 + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\n\t\tmemcpy(VAR_6->name +\n\t\t       (VAR_7 - 2) * VAR_21, VAR_5->name_unicode,\n\t\t       sizeof(VAR_5->name_unicode));\n\t}\n\n\tVAR_8 = check_name_dentry_set(VAR_0, VAR_6);\n\tif (VAR_8) {\n\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (VAR_3->file_num_ext == 2 && VAR_4->stream_name_len <= 2) {\n\t\tVAR_8 = handle_dot_dotdot_filename(VAR_0, VAR_5,\n\t\t\t\tVAR_4->stream_name_len);\n\t\tif (VAR_8 < 0) {\n\t\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\tVAR_6->first_clus = le32_to_cpu(VAR_4->stream_start_clu);\n\tVAR_6->is_contiguous =\n\t\t((VAR_4->stream_flags & VAR_22) != 0);\n\tVAR_6->size = le64_to_cpu(VAR_4->stream_size);\n\n\tif (VAR_6->size < le64_to_cpu(VAR_4->stream_valid_size)) {\n\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\tif (repair_file_ask(VAR_0, VAR_6, VAR_23,\n\t\t\t\t    \"valid size %\" VAR_24 \" greater than size %\" VAR_24,\n\t\t\t\t    le64_to_cpu(VAR_4->stream_valid_size),\n\t\t\t\t    VAR_6->size)) {\n\t\t\texfat_de_iter_get_dirty(VAR_0, 1, &VAR_4);\n\t\t\tVAR_4->stream_valid_size =\n\t\t\t\t\tVAR_4->stream_size;\n\t\t} else {\n\t\t\t*VAR_2 = VAR_3->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\t*VAR_2 = (VAR_3->file_num_ext + 1);\n\t*VAR_1 = VAR_6;\n\treturn 0;\nskip_dset:\n\tif (VAR_9) {\n\t\texfat_de_iter_get_dirty(VAR_0, 0, &VAR_5);\n\t\tVAR_5->type &= VAR_25;\n\t}\n\tfor (VAR_7 = 1; VAR_7 < *VAR_2; VAR_7++) {\n\t\texfat_de_iter_get(VAR_0, VAR_7, &VAR_5);\n\t\tif (VAR_5->type == VAR_11)\n\t\t\tbreak;\n\t\tif (VAR_9) {\n\t\t\texfat_de_iter_get_dirty(VAR_0, VAR_7, &VAR_5);\n\t\t\tVAR_5->type &= VAR_25;\n\t\t}\n\t}\n\t*VAR_2 = VAR_7;\n\t*VAR_1 = NULL;\n\texfat_free_inode(VAR_6);\n\treturn VAR_9 ? 1 : -VAR_12;\n}",
  "func_graph_path": "exfatprogs/ec78688e5fb5a70e13df82b4c0da1e6228d3ccdf/fsck.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \tif (!node)\n \t\treturn -ENOMEM;\n \n-\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n+\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {\n \t\tret = exfat_de_iter_get(iter, i, &dentry);\n \t\tif (ret || dentry->type != EXFAT_NAME) {\n \t\t\tif (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,",
  "diff_line_info": {
    "deleted_lines": [
      "\tfor (i = 2; i <= file_de->file_num_ext; i++) {"
    ],
    "added_lines": [
      "\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/exfatprogs/exfatprogs/pull/239",
  "description": {
    "pr_info": {
      "title": "Merge exfat-next into mater branch",
      "number": 239
    },
    "comment": [
      "    CHANGES :\r\n     * exfat2img: Allow dumps for read-only devices.\r\n     * fsck.exfat: Revert Repairing zero size directory.\r\n    \r\n    NEW FEATURES :\r\n     * fsck.exfat: Repair duplicated filename.\r\n     * mkfs.exfat: Add the option \"q\" to print only error messages.\r\n     * mkfs.exfat: Add the option \"U\" to set volume GUID.\r\n     * tune.exfat: Add the option \"U\" / \"-u\" to set or print volume GUID.\r\n    \r\n    BUG FIXES:\r\n     * fsck.exfat: Fix some out-of-bounds memory accesses.\r\n     * fsck.exfat: Change not to delete volume GUID directory entry.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}