{
  "cve_id": "CVE-2020-16124",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ros/ros_comm",
  "commit_msg": "Trap for overly large input to XmlRPCPP which could cause problems with int <-> size_t conversions.\n\n - In XmlRpcClient, XmlRpcServerConnection and XmlRpcSocket, recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header, and generate an error if the length is invalid or too large.\n - In XmlRpcUtil, prevent attempts to parse overly large XML input.\n - Add tests where they can reasonably be inserted into existing test routines.\n\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\n\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\n\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
  "commit_hash": "3dd308911d7294bc6cff12f626b8467fe1555423",
  "git_url": "https://github.com/ros/ros_comm/commit/3dd308911d7294bc6cff12f626b8467fe1555423",
  "file_path": "utilities/xmlrpcpp/src/XmlRpcClient.cpp",
  "func_name": "XmlRpcClient::readHeader",
  "func_before": "bool\nXmlRpcClient::readHeader()\n{\n  // Read available data\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), _header, &_eof) ||\n       (_eof && _header.length() == 0)) {\n\n    // If we haven't read any data yet and this is a keep-alive connection, the server may\n    // have timed out, so we try one more time.\n    if (getKeepOpen() && _header.length() == 0 && _sendAttempts++ == 0) {\n      XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: re-trying connection\");\n      XmlRpcSource::close();\n      _connectionState = NO_CONNECTION;\n      _eof = false;\n      return setupConnection();\n    }\n\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: error while reading \"\n                      \"header (%s) on fd %d.\",\n                      XmlRpcSocket::getErrorMsg().c_str(), getfd());\n    // Read failed; this means the socket is in an unrecoverable state.\n    // Close the socket.\n    close();\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: client has read %d bytes\", _header.length());\n\n  char *hp = (char*)_header.c_str();  // Start of header\n  char *ep = hp + _header.length();   // End of string\n  char *bp = 0;                       // Start of body\n  char *lp = 0;                       // Start of content-length value\n\n  for (char *cp = hp; (bp == 0) && (cp < ep); ++cp) {\n    if ((ep - cp > 16) && (strncasecmp(cp, \"Content-length: \", 16) == 0))\n      lp = cp + 16;\n    else if ((ep - cp > 4) && (strncmp(cp, \"\\r\\n\\r\\n\", 4) == 0))\n      bp = cp + 4;\n    else if ((ep - cp > 2) && (strncmp(cp, \"\\n\\n\", 2) == 0))\n      bp = cp + 2;\n  }\n\n  // If we haven't gotten the entire header yet, return (keep reading)\n  if (bp == 0) {\n    if (_eof)          // EOF in the middle of a response is an error\n    {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: EOF while reading header\");\n      close();\n      return false;   // Close the connection\n    }\n    \n    return true;  // Keep reading\n  }\n\n  // Decode content length\n  if (lp == 0) {\n    XmlRpcUtil::error(\"Error XmlRpcClient::readHeader: No Content-length specified\");\n    // Close the socket because we can't make further use of it.\n    close();\n    return false;   // We could try to figure it out by parsing as we read, but for now...\n  }\n\n  _contentLength = atoi(lp);\n  if (_contentLength <= 0) {\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified (%d).\", _contentLength);\n    // Close the socket because we can't make further use of it.\n    close();\n    return false;\n  }\n  \t\n  XmlRpcUtil::log(4, \"client read content length: %d\", _contentLength);\n\n  // Otherwise copy non-header data to response buffer and set state to read response.\n  _response = bp;\n  _header = \"\";   // should parse out any interesting bits from the header (connection, etc)...\n  _connectionState = READ_RESPONSE;\n  return true;    // Continue monitoring this source\n}",
  "abstract_func_before": "bool\nXmlRpcClient::readHeader()\n{\n  /* COMMENT_0 */\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_0, &VAR_1) ||\n       (VAR_1 && VAR_0.length() == 0)) {\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    if (getKeepOpen() && VAR_0.length() == 0 && VAR_2++ == 0) {\n      XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: re-trying connection\");\n      XmlRpcSource::close();\n      VAR_3 = VAR_4;\n      VAR_1 = false;\n      return setupConnection();\n    }\n\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: error while reading \"\n                      \"header (%s) on fd %d.\",\n                      XmlRpcSocket::getErrorMsg().c_str(), getfd());\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    close();\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: client has read %d bytes\", VAR_0.length());\n\n  char *VAR_5 = (char*)VAR_0.c_str();  /* COMMENT_5 */\n  char *VAR_6 = VAR_5 + VAR_0.length();   /* COMMENT_6 */\n  char *VAR_7 = 0;                       /* COMMENT_7 */\n  char *VAR_8 = 0;                       /* COMMENT_8 */\n\n  for (char *VAR_9 = VAR_5; (VAR_7 == 0) && (VAR_9 < VAR_6); ++VAR_9) {\n    if ((VAR_6 - VAR_9 > 16) && (strncasecmp(VAR_9, \"Content-length: \", 16) == 0))\n      VAR_8 = VAR_9 + 16;\n    else if ((VAR_6 - VAR_9 > 4) && (strncmp(VAR_9, \"\\r\\n\\r\\n\", 4) == 0))\n      VAR_7 = VAR_9 + 4;\n    else if ((VAR_6 - VAR_9 > 2) && (strncmp(VAR_9, \"\\n\\n\", 2) == 0))\n      VAR_7 = VAR_9 + 2;\n  }\n\n  /* COMMENT_9 */\n  if (VAR_7 == 0) {\n    if (VAR_1)          /* COMMENT_10 */\n    {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: EOF while reading header\");\n      close();\n      return false;   /* COMMENT_11 */\n    }\n    \n    return true;  /* COMMENT_12 */\n  }\n\n  /* COMMENT_13 */\n  if (VAR_8 == 0) {\n    XmlRpcUtil::error(\"Error XmlRpcClient::readHeader: No Content-length specified\");\n    /* COMMENT_14 */\n    close();\n    return false;   /* COMMENT_15 */\n  }\n\n  VAR_10 = atoi(VAR_8);\n  if (VAR_10 <= 0) {\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified (%d).\", VAR_10);\n    /* COMMENT_14 */\n    close();\n    return false;\n  }\n  \t\n  XmlRpcUtil::log(4, \"client read content length: %d\", VAR_10);\n\n  /* COMMENT_16 */\n  VAR_11 = VAR_7;\n  VAR_0 = \"\";   /* COMMENT_17 */\n  VAR_3 = VAR_12;\n  return true;    /* COMMENT_18 */\n}",
  "func_graph_path_before": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcClient.cpp/vul/before/2.json",
  "func": "bool\nXmlRpcClient::readHeader()\n{\n  // Read available data\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), _header, &_eof) ||\n       (_eof && _header.length() == 0)) {\n\n    // If we haven't read any data yet and this is a keep-alive connection, the server may\n    // have timed out, so we try one more time.\n    if (getKeepOpen() && _header.length() == 0 && _sendAttempts++ == 0) {\n      XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: re-trying connection\");\n      XmlRpcSource::close();\n      _connectionState = NO_CONNECTION;\n      _eof = false;\n      return setupConnection();\n    }\n\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: error while reading \"\n                      \"header (%s) on fd %d.\",\n                      XmlRpcSocket::getErrorMsg().c_str(), getfd());\n    // Read failed; this means the socket is in an unrecoverable state.\n    // Close the socket.\n    close();\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: client has read %d bytes\", _header.length());\n\n  char *hp = (char*)_header.c_str();  // Start of header\n  char *ep = hp + _header.length();   // End of string\n  char *bp = 0;                       // Start of body\n  char *lp = 0;                       // Start of content-length value\n\n  for (char *cp = hp; (bp == 0) && (cp < ep); ++cp) {\n    if ((ep - cp > 16) && (strncasecmp(cp, \"Content-length: \", 16) == 0))\n      lp = cp + 16;\n    else if ((ep - cp > 4) && (strncmp(cp, \"\\r\\n\\r\\n\", 4) == 0))\n      bp = cp + 4;\n    else if ((ep - cp > 2) && (strncmp(cp, \"\\n\\n\", 2) == 0))\n      bp = cp + 2;\n  }\n\n  // If we haven't gotten the entire header yet, return (keep reading)\n  if (bp == 0) {\n    if (_eof)          // EOF in the middle of a response is an error\n    {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: EOF while reading header\");\n      close();\n      return false;   // Close the connection\n    }\n    \n    return true;  // Keep reading\n  }\n\n  // Decode content length\n  if (lp == 0) {\n    XmlRpcUtil::error(\"Error XmlRpcClient::readHeader: No Content-length specified\");\n    // Close the socket because we can't make further use of it.\n    close();\n    return false;   // We could try to figure it out by parsing as we read, but for now...\n  }\n\n  // avoid overly large or improperly formatted content-length\n  long int clength = 0;\n  clength = strtol(lp, nullptr, 10);\n  if ((clength <= 0) || (clength > __INT_MAX__)) {\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified.\");\n    // Close the socket because we can't make further use of it.\n    close();\n    return false;\n  }\n  _contentLength = int(clength);\n  \t\n  XmlRpcUtil::log(4, \"client read content length: %d\", _contentLength);\n\n  // Otherwise copy non-header data to response buffer and set state to read response.\n  _response = bp;\n  _header = \"\";   // should parse out any interesting bits from the header (connection, etc)...\n  _connectionState = READ_RESPONSE;\n  return true;    // Continue monitoring this source\n}",
  "abstract_func": "bool\nXmlRpcClient::readHeader()\n{\n  /* COMMENT_0 */\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_0, &VAR_1) ||\n       (VAR_1 && VAR_0.length() == 0)) {\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    if (getKeepOpen() && VAR_0.length() == 0 && VAR_2++ == 0) {\n      XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: re-trying connection\");\n      XmlRpcSource::close();\n      VAR_3 = VAR_4;\n      VAR_1 = false;\n      return setupConnection();\n    }\n\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: error while reading \"\n                      \"header (%s) on fd %d.\",\n                      XmlRpcSocket::getErrorMsg().c_str(), getfd());\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    close();\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcClient::readHeader: client has read %d bytes\", VAR_0.length());\n\n  char *VAR_5 = (char*)VAR_0.c_str();  /* COMMENT_5 */\n  char *VAR_6 = VAR_5 + VAR_0.length();   /* COMMENT_6 */\n  char *VAR_7 = 0;                       /* COMMENT_7 */\n  char *VAR_8 = 0;                       /* COMMENT_8 */\n\n  for (char *VAR_9 = VAR_5; (VAR_7 == 0) && (VAR_9 < VAR_6); ++VAR_9) {\n    if ((VAR_6 - VAR_9 > 16) && (strncasecmp(VAR_9, \"Content-length: \", 16) == 0))\n      VAR_8 = VAR_9 + 16;\n    else if ((VAR_6 - VAR_9 > 4) && (strncmp(VAR_9, \"\\r\\n\\r\\n\", 4) == 0))\n      VAR_7 = VAR_9 + 4;\n    else if ((VAR_6 - VAR_9 > 2) && (strncmp(VAR_9, \"\\n\\n\", 2) == 0))\n      VAR_7 = VAR_9 + 2;\n  }\n\n  /* COMMENT_9 */\n  if (VAR_7 == 0) {\n    if (VAR_1)          /* COMMENT_10 */\n    {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: EOF while reading header\");\n      close();\n      return false;   /* COMMENT_11 */\n    }\n    \n    return true;  /* COMMENT_12 */\n  }\n\n  /* COMMENT_13 */\n  if (VAR_8 == 0) {\n    XmlRpcUtil::error(\"Error XmlRpcClient::readHeader: No Content-length specified\");\n    /* COMMENT_14 */\n    close();\n    return false;   /* COMMENT_15 */\n  }\n\n  /* COMMENT_16 */\n  long int VAR_10 = 0;\n  VAR_10 = strtol(VAR_8, nullptr, 10);\n  if ((VAR_10 <= 0) || (VAR_10 > VAR_11)) {\n    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified.\");\n    /* COMMENT_14 */\n    close();\n    return false;\n  }\n  VAR_12 = int(VAR_10);\n  \t\n  XmlRpcUtil::log(4, \"client read content length: %d\", VAR_12);\n\n  /* COMMENT_17 */\n  VAR_13 = VAR_7;\n  VAR_0 = \"\";   /* COMMENT_18 */\n  VAR_3 = VAR_14;\n  return true;    /* COMMENT_19 */\n}",
  "func_graph_path": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcClient.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -60,13 +60,16 @@\n     return false;   // We could try to figure it out by parsing as we read, but for now...\n   }\n \n-  _contentLength = atoi(lp);\n-  if (_contentLength <= 0) {\n-    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified (%d).\", _contentLength);\n+  // avoid overly large or improperly formatted content-length\n+  long int clength = 0;\n+  clength = strtol(lp, nullptr, 10);\n+  if ((clength <= 0) || (clength > __INT_MAX__)) {\n+    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified.\");\n     // Close the socket because we can't make further use of it.\n     close();\n     return false;\n   }\n+  _contentLength = int(clength);\n   \t\n   XmlRpcUtil::log(4, \"client read content length: %d\", _contentLength);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  _contentLength = atoi(lp);",
      "  if (_contentLength <= 0) {",
      "    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified (%d).\", _contentLength);"
    ],
    "added_lines": [
      "  // avoid overly large or improperly formatted content-length",
      "  long int clength = 0;",
      "  clength = strtol(lp, nullptr, 10);",
      "  if ((clength <= 0) || (clength > __INT_MAX__)) {",
      "    XmlRpcUtil::error(\"Error in XmlRpcClient::readHeader: Invalid Content-length specified.\");",
      "  _contentLength = int(clength);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ros/ros_comm/pull/2065",
  "description": {
    "pr_info": {
      "title": "Trap for overly large input to XmlRPCPP",
      "number": 2065
    },
    "comment": [
      "Oversize input to XmlRPCPP could cause problems with int <-> size_t conversions.\r\n\r\n - Recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\r\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header and generate an error if the length is invalid or too large.\r\n - Prevent attempts to parse overly large XML input.\r\n - Add tests where they can reasonably be inserted into existing test routines.\r\n\r\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\r\n\r\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\r\n\r\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
      "> Atm CI is failing for two tests though.\r\n\r\n@dirk-thomas, thanks for the review. The overrun tests I added are causing memory allocation failures--they work on my local machine but I assume the CI tests don't expect to be handling 2Gb input values. Any suggestions on how best to handle, is it advisable to remove the overrun tests?",
      "> Any suggestions on how best to handle, is it advisable to remove the overrun tests?\r\n\r\nCan the code be written in a way that it fails gracefully if that much memory isn't available? Maybe marking the test as skipped.",
      "Debian Buster only has Googletest 1.8.1 which doesn't have `GTEST_SKIP`.\r\n\r\nThe `readResponse_oversize` test still fails in CI.",
      "I removed GTEST_SKIP, printed an error message but otherwise let the test succeed. Also I removed one test that was causing problems. The test_client routines for readResponse still run when objects are finalized; since the test object could be in an unpredictable state I couldn't find a good way to ignore the results.",
      "> I removed GTEST_SKIP, printed an error message but otherwise let the test succeed.\r\n\r\nThat sounds like a good fall backback behavior. Can you make this conditional based on if `GTEST_SKIP` is available? If it is use it to give better feedback, otherwise fall back to the error message / succeed.",
      "@dirk-thomas, I added the conditional statement in one of the tests but had to rip another one out--the Ubuntu tests started running long and got killed causing the whole module to fail. I think this is as good as I can get it unless you have any ideas on how to safely & consistently write tests for huge input strings.",
      "Sounds good to me. Thanks for the patch and for iterating on it."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses CVE-2020-16124, fixing an integer overflow vulnerability by replacing unsafe parsing with secure methods and adding checks for data size. All elements point to a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}