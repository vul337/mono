{
  "cve_id": "CVE-2017-0152",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "chakra-core/ChakraCore",
  "commit_msg": "[CVE-2017-0152] MSFT: 10592731 : Issue with Function name capturing in param scope\n\nIn a function expression with name, where the name is captured in one\nof the param scope functions, if there is a function or var declaration\nwith the same name as the function expression name we were marking the\nfunction expression name as shadowed. In non-eval case this causes\nissue because the name symbol won't get added to the body. This change is to\nfix it in such a way if the name is captured in the param scope then we\nsplit the param and body scope such that the name symbol is added to the\nparam scope not body scope.",
  "commit_hash": "9da019424601325a6e95e6be0fa03d7d21d0b517",
  "git_url": "https://github.com/chakra-core/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517",
  "file_path": "lib/Parser/Parse.cpp",
  "func_name": "Parser::ParseFncDeclHelper",
  "func_before": "bool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool *pHasName, bool fUnaryOrParen, bool noStmtContext, bool *pNeedScanRCurly, bool skipFormals)\n{\n    ParseNodePtr pnodeFncParent = GetCurrentFunctionNode();\n    // is the following correct? When buildAST is false, m_currentNodeDeferredFunc can be nullptr on transition to deferred parse from non-deferred\n    ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;\n    ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;\n    int32* pAstSizeSave = m_pCurrentAstSize;\n\n    bool fDeclaration = (flags & fFncDeclaration) != 0;\n    bool fLambda = (flags & fFncLambda) != 0;\n    bool fAsync = (flags & fFncAsync) != 0;\n    bool fModule = (flags & fFncModule) != 0;\n    bool fDeferred = false;\n    StmtNest *pstmtSave;\n    ParseNodePtr *lastNodeRef = nullptr;\n    bool fFunctionInBlock = false;\n    if (buildAST)\n    {\n        fFunctionInBlock = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&\n            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||\n             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock);\n    }\n\n    // Save the position of the scanner in case we need to inspect the name hint later\n    RestorePoint beginNameHint;\n    m_pscan->Capture(&beginNameHint);\n\n    ParseNodePtr pnodeFncExprScope = nullptr;    \n    Scope *fncExprScope = nullptr;\n    if (!fDeclaration)\n    {\n        pnodeFncExprScope = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FuncExpr);\n        fncExprScope = pnodeFncExprScope->sxBlock.scope;\n\n        // Function expression: push the new function onto the stack now so that the name (if any) will be\n        // local to the new function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    *pHasName = !fLambda && !fModule && this->ParseFncNames<buildAST>(pnodeFnc, pnodeFncSave, flags, &lastNodeRef);\n\n    if (fDeclaration)\n    {\n        // Declaration statement: push the new function now, after parsing the name, so the name is local to the\n        // enclosing function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    if (noStmtContext && pnodeFnc->sxFnc.IsGenerator())\n    {\n        // Generator decl not allowed outside stmt context. (We have to wait until we've parsed the '*' to\n        // detect generator.)\n        Error(ERRsyntax, pnodeFnc);\n    }\n\n    // switch scanner to treat 'yield' as keyword in generator functions\n    // or as an identifier in non-generator functions\n    bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());\n\n    bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync);\n\n    if (pnodeFnc && pnodeFnc->sxFnc.IsGenerator())\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Generator, m_scriptContext);\n    }\n\n    if (fncExprScope && !*pHasName)\n    {\n        FinishParseBlock(pnodeFncExprScope);\n        m_nextBlockId--;\n        Adelete(&m_nodeAllocator, fncExprScope);\n        fncExprScope = nullptr;\n        pnodeFncExprScope = nullptr;\n    }\n    if (pnodeFnc)\n    {\n        pnodeFnc->sxFnc.scope = fncExprScope;\n    }\n\n    // Start a new statement stack.\n    bool topLevelStmt =\n        buildAST &&\n        !fFunctionInBlock &&\n        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == knopBlock);\n\n    pstmtSave = m_pstmtCur;\n    SetCurrentStatement(nullptr);\n\n    // Function definition is inside the parent function's parameter scope\n    bool isEnclosedInParamScope = this->m_currentScope->GetScopeType() == ScopeType_Parameter;\n\n    if (this->m_currentScope->GetScopeType() == ScopeType_FuncExpr || this->m_currentScope->GetScopeType() == ScopeType_Block)\n    {\n        // Or this is a function expression or class enclosed in a parameter scope\n        isEnclosedInParamScope = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == ScopeType_Parameter;\n    }\n\n    Assert(!isEnclosedInParamScope || pnodeFncSave->sxFnc.HasNonSimpleParameterList());\n\n    RestorePoint beginFormals;\n    m_pscan->Capture(&beginFormals);\n    BOOL fWasAlreadyStrictMode = IsStrictMode();\n    BOOL oldStrictMode = this->m_fUseStrictMode;\n\n    if (fLambda)\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Lambda, m_scriptContext);\n    }\n\n    uint uDeferSave = m_grfscr & fscrDeferFncParse;\n    if ((!fDeclaration && m_ppnodeExprScope) ||\n        isEnclosedInParamScope ||\n        (flags & (fFncNoName | fFncLambda)))\n    {\n        // NOTE: Don't defer if this is a function expression inside a construct that induces\n        // a scope nested within the current function (like a with, or a catch in ES5 mode, or\n        // any function declared inside a nested lexical block or param scope in ES6 mode).\n        // We won't be able to reconstruct the scope chain properly when we come back and\n        // try to compile just the function expression.\n        // Also shut off deferring on getter/setter or other construct with unusual text bounds\n        // (fFncNoName|fFncLambda) as these are usually trivial, and re-parsing is problematic.\n        m_grfscr &= ~fscrDeferFncParse;\n    }\n\n    bool saveInFIB = this->m_inFIB;\n    this->m_inFIB = fFunctionInBlock || this->m_inFIB;\n\n    bool isTopLevelDeferredFunc = false;\n\n    struct AutoFastScanFlag {\n        bool savedDoingFastScan;\n        AutoFastScanFlag(Parser *parser) : m_parser(parser) { savedDoingFastScan = m_parser->m_doingFastScan; }\n        ~AutoFastScanFlag() { m_parser->m_doingFastScan = savedDoingFastScan; }\n        Parser *m_parser;\n    } flag(this);\n\n    bool doParallel = false;\n    bool parallelJobStarted = false;\n    if (buildAST)\n    {\n        bool isLikelyIIFE = !fDeclaration && pnodeFnc && fUnaryOrParen;\n\n        BOOL isDeferredFnc = IsDeferredFnc();\n        AnalysisAssert(isDeferredFnc || pnodeFnc);\n        // These are the conditions that prohibit upfront deferral *and* redeferral.\n        isTopLevelDeferredFunc =\n            (!fLambda\n             && pnodeFnc\n             && DeferredParse(pnodeFnc->sxFnc.functionId)\n             && (!pnodeFnc->sxFnc.IsNested() || CONFIG_FLAG(DeferNested))\n             && !m_InAsmMode\n            // Don't defer a module function wrapper because we need to do export resolution at parse time\n             && !fModule\n            );\n\n        if (pnodeFnc)\n        {\n            pnodeFnc->sxFnc.SetCanBeDeferred(isTopLevelDeferredFunc && PnFnc::CanBeRedeferred(pnodeFnc->sxFnc.fncFlags));\n            pnodeFnc->sxFnc.SetFIBPreventsDeferral(false);\n        }\n\n        if (this->m_inFIB)\n        {\n            if (isTopLevelDeferredFunc)\n            {\n                // Block-scoping is the only non-heuristic reason for not deferring this function up front.\n                // So on creating the full FunctionBody at byte code gen time, verify that there is no\n                // block-scoped content visible to this function so it can remain a redeferral candidate.\n                pnodeFnc->sxFnc.SetFIBPreventsDeferral(true);\n            }\n            isTopLevelDeferredFunc = false;\n        }        \n\n        // These are heuristic conditions that prohibit upfront deferral but not redeferral.\n        isTopLevelDeferredFunc = isTopLevelDeferredFunc && !isDeferredFnc && \n            (!isLikelyIIFE || !topLevelStmt || PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId));\n;\n        if (!fLambda &&\n            !isDeferredFnc &&\n            !isLikelyIIFE &&\n            !this->IsBackgroundParser() &&\n            !this->m_doingFastScan &&\n            !(pnodeFncSave && m_currDeferredStub) &&\n            !(this->m_parseType == ParseType_Deferred && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !isTopLevelDeferredFunc))\n        {\n            doParallel = DoParallelParse(pnodeFnc);\n#if ENABLE_BACKGROUND_PARSING\n            if (doParallel)\n            {\n                BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n                Assert(bgp);\n                if (bgp->HasFailedBackgroundParseItem())\n                {\n                    Error(ERRsyntax);\n                }\n                doParallel = bgp->ParseBackgroundItem(this, pnodeFnc, isTopLevelDeferredFunc);\n                if (doParallel)\n                {\n                    parallelJobStarted = true;\n                    this->m_hasParallelJob = true;\n                    this->m_doingFastScan = true;\n                    doParallel = FastScanFormalsAndBody();\n                    if (doParallel)\n                    {\n                        // Let the foreground thread take care of marking the limit on the function node,\n                        // because in some cases this function's caller will want to change that limit,\n                        // so we don't want the background thread to try and touch it.\n                        pnodeFnc->ichLim = m_pscan->IchLimTok();\n                        pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n                    }\n                }\n            }\n#endif\n        }\n    }\n\n    if (!doParallel)\n    {\n        // We don't want to, or couldn't, let the main thread scan past this function body, so parse\n        // it for real.\n        ParseNodePtr pnodeRealFnc = pnodeFnc;\n        if (parallelJobStarted)\n        {\n            // We have to deal with a failure to fast-scan the function (due to syntax error? \"/\"?) when\n            // a background thread may already have begun to work on the job. Both threads can't be allowed to\n            // operate on the same node.\n            pnodeFnc = CreateDummyFuncNode(fDeclaration);\n        }\n\n        AnalysisAssert(pnodeFnc);\n        ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);\n        AnalysisAssert(pnodeBlock != nullptr);\n        pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;\n\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ppnodeScopeSave = m_ppnodeScope;\n        if (pnodeBlock)\n        {\n            // This synthetic block scope will contain all the nested scopes.\n            m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n            pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;\n        }\n\n        // Keep nested function declarations and expressions in the same list at function scope.\n        // (Indicate this by nulling out the current function expressions list.)\n        ppnodeExprScopeSave = m_ppnodeExprScope;\n        m_ppnodeExprScope = nullptr;\n\n        if (!skipFormals)\n        {\n            bool fLambdaParamsSave = m_reparsingLambdaParams;\n            if (fLambda)\n            {\n                m_reparsingLambdaParams = true;\n            }\n            this->ParseFncFormals<buildAST>(pnodeFnc, pnodeFncParent, flags);\n            m_reparsingLambdaParams = fLambdaParamsSave;\n        }\n\n        // Create function body scope\n        ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);\n        // Set the parameter block's child to the function body block.\n        // The pnodeFnc->sxFnc.pnodeScopes list is constructed in such a way that it includes all the scopes in this list.\n        // For example if the param scope has one function and body scope has one function then the list will look like below,\n        // param scope block -> function decl from param scope -> body socpe block -> function decl from body scope.\n        *m_ppnodeScope = pnodeInnerBlock;\n        pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n\n        // This synthetic block scope will contain all the nested scopes.\n        m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;\n        pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n        // DEFER: Begin deferral here (after names are parsed and name nodes created).\n        // Create no more AST nodes until we're done.\n\n        // Try to defer this func if all these are true:\n        //  0. We are not already in deferred parsing (i.e. buildAST is true)\n        //  1. We are not re-parsing a deferred func which is being invoked.\n        //  2. Dynamic profile suggests this func can be deferred (and deferred parse is on).\n        //  3. This func is top level or defer nested func is on.\n        //  4. Optionally, the function is non-nested and not in eval, or the deferral decision was based on cached profile info,\n        //     or the function is sufficiently long. (I.e., don't defer little nested functions unless we're\n        //     confident they'll never be executed, because un-deferring nested functions is more expensive.)\n        //     NOTE: I'm disabling #4 by default, because we've found other ways to reduce the cost of un-deferral,\n        //           and we don't want to create function bodies aggressively for little functions.\n\n        // We will also temporarily defer all asm.js functions, except for the asm.js\n        // module itself, which we will never defer\n        bool strictModeTurnedOn = false;\n\n        if (isTopLevelDeferredFunc &&\n            !(this->m_grfscr & fscrEvalCode) &&\n            pnodeFnc->sxFnc.IsNested() &&\n#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE\n            m_sourceContextInfo->sourceDynamicProfileManager == nullptr &&\n#endif\n            PHASE_ON_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) &&\n            (\n                !PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) ||\n                PHASE_FORCE_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId)\n            ))\n        {\n            // Try to scan ahead to the end of the function. If we get there before we've scanned a minimum\n            // number of tokens, don't bother deferring, because it's too small.\n            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(MinDeferredFuncTokenCount)))\n            {\n                isTopLevelDeferredFunc = false;\n            }\n        }\n\n        Scope* paramScope = pnodeFnc->sxFnc.pnodeScopes ? pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope : nullptr;\n        if (paramScope != nullptr)\n        {\n            if (CONFIG_FLAG(ForceSplitScope))\n            {\n                paramScope->SetCannotMergeWithBodyScope();\n            }\n            else if (pnodeFnc->sxFnc.HasNonSimpleParameterList())\n            {\n                if (paramScope->GetCanMergeWithBodyScope())\n                {\n                    paramScope->ForEachSymbolUntil([this, paramScope, pnodeFnc](Symbol* sym) {\n                        if (sym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                        {\n                            // One of the symbol has non local reference. Mark the param scope as we can't merge it with body scope.\n                            paramScope->SetCannotMergeWithBodyScope();\n                            return true;\n                        }\n                        return false;\n                    });\n\n                    if (wellKnownPropertyPids.arguments->GetTopRef() && wellKnownPropertyPids.arguments->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                    {\n                        Assert(pnodeFnc->sxFnc.UsesArguments());\n                        // Arguments symbol is captured in the param scope\n                        paramScope->SetCannotMergeWithBodyScope();\n                    }\n                }\n            }\n        }\n\n        if (!fLambda && paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope()\n            && (pnodeFnc->sxFnc.UsesArguments() || pnodeFnc->grfpn & fpnArguments_overriddenByDecl))\n        {\n            Error(ERRNonSimpleParamListArgumentsUse);\n        }\n\n        // If the param scope is merged with the body scope we want to use the param scope symbols in the body scope.\n        // So add a pid ref for the body using the param scope symbol. Note that in this case the same symbol will occur twice\n        // in the same pid ref stack.\n        if (paramScope != nullptr && paramScope->GetCanMergeWithBodyScope())\n        {\n            paramScope->ForEachSymbol([this](Symbol* paramSym)\n            {\n                PidRefStack* ref = PushPidRef(paramSym->GetPid());\n                ref->SetSym(paramSym);\n            });\n        }\n\n        if (isTopLevelDeferredFunc || (m_InAsmMode && m_deferAsmJs))\n        {\n            AssertMsg(!fLambda, \"Deferring function parsing of a function does not handle lambda syntax\");\n            fDeferred = true;\n\n            this->ParseTopLevelDeferredFunc(pnodeFnc, pnodeFncSave, pNameHint);\n        }\n        else\n        {\n            if (m_token.tk == tkRParen) // This might be false due to error recovery or lambda.\n            {\n                m_pscan->Scan();\n            }\n\n            if (fLambda)\n            {\n                BOOL hadNewLine = m_pscan->FHadNewLine();\n\n                // it can be the case we do not have a fat arrow here if there is a valid expression on the left hand side\n                // of the fat arrow, but that expression does not parse as a parameter list.  E.g.\n                //    a.x => { }\n                // Therefore check for it and error if not found.\n                // LS Mode : since this is a lambda we supposed to get the fat arrow, if not we will skip till we get that fat arrow.\n                ChkCurTok(tkDArrow, ERRnoDArrow);\n\n                // Newline character between arrow parameters and fat arrow is a syntax error but we want to check for\n                // this after verifying there was a => token. Otherwise we would throw the wrong error.\n                if (hadNewLine)\n                {\n                    Error(ERRsyntax);\n                }\n            }\n\n            AnalysisAssert(pnodeFnc);\n\n            // Shouldn't be any temps in the arg list.\n            Assert(*m_ppnodeVar == nullptr);\n\n            // Start the var list.\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n            if (paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope())\n            {\n                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                // Add a new symbol reference for each formal in the param scope to the body scope.\n                // While inserting symbols into the symbol list we always insert at the front, so while traversing the list we will be visiting the last added\n                // formals first. Normal insertion of those into the body will reverse the order of symbols, which will eventually result in different order\n                // for scope slots allocation for the corresponding symbol in both param and body scope. Inserting them in the opposite order will help us\n                // have the same sequence for scope slots allocation in both scopes. This makes it easy to read the bytecode and may help in some optimization\n                // later.\n                paramScope->ForEachSymbol([this, pnodeFnc](Symbol* param) {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), param->GetPid()->Psz());\n\n                    ParseNodePtr paramNode = nullptr;\n                    if (this->m_ppnodeVar != &pnodeFnc->sxFnc.pnodeVars)\n                    {\n                        ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n                        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                        m_ppnodeVar = ppnodeVarSave;\n                    }\n                    else\n                    {\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                    }\n\n                    Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                    paramNode->sxVar.sym->SetHasInit(true);\n                });\n\n                if (!fLambda)\n                {\n                    // In split scope case ideally the arguments object should be in the param scope.\n                    // Right now referring to arguments in the param scope is a SyntaxError, so we have to\n                    // add a duplicate symbol in the body scope and copy over the value in BeginBodySope.\n                    ParseNodePtr argumentsNode = this->CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, nullptr, false);\n                    Assert(argumentsNode && argumentsNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                }\n            }\n\n            // Keep nested function declarations and expressions in the same list at function scope.\n            // (Indicate this by nulling out the current function expressions list.)\n            m_ppnodeExprScope = nullptr;\n\n            if (buildAST)\n            {\n                DeferredFunctionStub *saveCurrentStub = m_currDeferredStub;\n                if (isEnclosedInParamScope)\n                {\n                    // if the enclosed scope is the param scope we would not have created the deferred stub.\n                    m_currDeferredStub = nullptr;\n                }\n                else if (pnodeFncSave && m_currDeferredStub)\n                {\n                    // the Deferred stub will not match for the function which are defined on lambda formals.\n                    // Since this is not determined upfront that the current function is a part of outer function or part of lambda formal until we have seen the Arrow token.\n                    // Due to that the current function may be fetching stubs from the outer function (outer of the lambda) - rather then the lambda function. The way to fix is to match\n                    // the function start with the stub. Because they should match. We need to have previous sibling concept as the lambda formals can have more than one\n                    // functions and we want to avoid getting wrong stub.\n\n                    if (pnodeFncSave->sxFnc.nestedCount == 1)\n                    {\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n\n                    if (m_prevSiblingDeferredStub == nullptr)\n                    {\n                        m_prevSiblingDeferredStub = (m_currDeferredStub + (pnodeFncSave->sxFnc.nestedCount - 1));\n                    }\n\n                    if (m_prevSiblingDeferredStub->ichMin == pnodeFnc->ichMin)\n                    {\n                        m_currDeferredStub = m_prevSiblingDeferredStub->deferredStubs;\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n                    else\n                    {\n                        m_currDeferredStub = nullptr;\n                    }\n                }\n\n                if (m_token.tk != tkLCurly && fLambda)\n                {\n                    ParseExpressionLambdaBody<true>(pnodeFnc);\n                    *pNeedScanRCurly = false;\n                }\n                else\n                {\n                    this->FinishFncDecl(pnodeFnc, pNameHint, lastNodeRef, skipFormals);\n                }\n                m_currDeferredStub = saveCurrentStub;\n            }\n            else\n            {\n                this->ParseNestedDeferredFunc(pnodeFnc, fLambda, pNeedScanRCurly, &strictModeTurnedOn);\n            }\n        }\n\n        if (pnodeInnerBlock)\n        {\n            FinishParseBlock(pnodeInnerBlock, *pNeedScanRCurly);\n        }\n\n        if (!fModule && (m_token.tk == tkLCurly || !fLambda))\n        {\n            this->AddArgumentsNodeToVars(pnodeFnc);\n        }\n\n        // Restore the lists of scopes that contain function expressions.\n\n        Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);\n        m_ppnodeExprScope = ppnodeExprScopeSave;\n\n        AssertMem(m_ppnodeScope);\n        Assert(nullptr == *m_ppnodeScope);\n        m_ppnodeScope = ppnodeScopeSave;\n\n        if (pnodeBlock)\n        {\n            FinishParseBlock(pnodeBlock, *pNeedScanRCurly);\n        }\n\n        if (IsStrictMode() || strictModeTurnedOn)\n        {\n            this->m_fUseStrictMode = TRUE; // Now we know this function is in strict mode\n\n            if (!fWasAlreadyStrictMode)\n            {\n                // If this function turned on strict mode then we didn't check the formal\n                // parameters or function name hint for future reserved word usage. So do that now.\n                RestorePoint afterFnc;\n                m_pscan->Capture(&afterFnc);\n\n                if (*pHasName)\n                {\n                    // Rewind to the function name hint and check if the token is a reserved word.\n                    m_pscan->SeekTo(beginNameHint);\n                    m_pscan->Scan();\n                    if (pnodeFnc->sxFnc.IsGenerator())\n                    {\n                        Assert(m_token.tk == tkStar);\n                        Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());\n                        Assert(!(flags & fFncClassMember));\n                        m_pscan->Scan();\n                    }\n                    if (m_token.IsReservedWord())\n                    {\n                        IdentifierExpectedError(m_token);\n                    }\n                    CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));\n                }\n\n                // Fast forward to formal parameter list, check for future reserved words,\n                // then restore scanner as it was.\n                m_pscan->SeekToForcingPid(beginFormals);\n                CheckStrictFormalParameters();\n                m_pscan->SeekTo(afterFnc);\n            }\n\n            if (buildAST)\n            {\n                if (pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnodeFnc->sxFnc.pnodeName->sxVar.pid, pnodeFnc->sxFnc.pnodeName);\n                }\n            }\n\n            this->m_fUseStrictMode = oldStrictMode;\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StrictModeFunction, m_scriptContext);\n        }\n\n        if (fDeferred)\n        {\n            AnalysisAssert(pnodeFnc);\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n        }\n\n        if (parallelJobStarted)\n        {\n            pnodeFnc = pnodeRealFnc;\n            m_currentNodeFunc = pnodeRealFnc;\n\n            // Let the foreground thread take care of marking the limit on the function node,\n            // because in some cases this function's caller will want to change that limit,\n            // so we don't want the background thread to try and touch it.\n            pnodeFnc->ichLim = m_pscan->IchLimTok();\n            pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n        }\n    }\n\n    // after parsing asm.js module, we want to reset asm.js state before continuing\n    AnalysisAssert(pnodeFnc);\n    if (pnodeFnc->sxFnc.GetAsmjsMode())\n    {\n        m_InAsmMode = false;\n    }\n\n    // Restore the statement stack.\n    Assert(nullptr == m_pstmtCur);\n    SetCurrentStatement(pstmtSave);\n\n    if (pnodeFncExprScope)\n    {\n        FinishParseFncExprScope(pnodeFnc, pnodeFncExprScope);\n    }\n    if (!m_stoppedDeferredParse)\n    {\n        m_grfscr |= uDeferSave;\n    }\n    m_inFIB = saveInFIB;\n\n    m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n    m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n\n    // Restore the current function.\n    if (buildAST)\n    {\n        Assert(pnodeFnc == m_currentNodeFunc);\n\n        m_currentNodeFunc = pnodeFncSave;\n        m_pCurrentAstSize = pAstSizeSave;\n\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaFunc);\n            m_currentNodeNonLambdaFunc = pnodeFncSaveNonLambda;\n        }\n    }\n    else\n    {\n        Assert(pnodeFnc == m_currentNodeDeferredFunc);\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaDeferredFunc);\n            m_currentNodeNonLambdaDeferredFunc = pnodeFncSaveNonLambda;\n        }\n        m_currentNodeDeferredFunc = pnodeFncSave;\n    }\n\n    if (m_currentNodeFunc && pnodeFnc->sxFnc.HasWithStmt())\n    {\n        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);\n    }\n\n    return true;\n}",
  "abstract_func_before": "bool Parser::ParseFncDeclHelper(ParseNodePtr VAR_0, LPCOLESTR VAR_1, ushort VAR_2, bool *VAR_3, bool VAR_4, bool VAR_5, bool *VAR_6, bool VAR_7)\n{\n    ParseNodePtr VAR_8 = GetCurrentFunctionNode();\n    /* COMMENT_0 */\n    ParseNodePtr VAR_9 = VAR_10 ? VAR_11 : VAR_12;\n    ParseNodePtr VAR_13 = VAR_10 ? VAR_14 : VAR_15;\n    int32* VAR_16 = VAR_17;\n\n    bool VAR_18 = (VAR_2 & VAR_19) != 0;\n    bool VAR_20 = (VAR_2 & VAR_21) != 0;\n    bool VAR_22 = (VAR_2 & VAR_23) != 0;\n    bool VAR_24 = (VAR_2 & VAR_25) != 0;\n    bool VAR_26 = false;\n    StmtNest *VAR_27;\n    ParseNodePtr *VAR_28 = nullptr;\n    bool VAR_29 = false;\n    if (VAR_10)\n    {\n        VAR_29 = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&\n            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||\n             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != VAR_30);\n    }\n\n    /* COMMENT_1 */\n    RestorePoint VAR_31;\n    VAR_32->Capture(&VAR_31);\n\n    ParseNodePtr VAR_33 = nullptr;    \n    Scope *VAR_34 = nullptr;\n    if (!VAR_18)\n    {\n        VAR_33 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_36);\n        VAR_34 = VAR_33->sxBlock.scope;\n\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n\n        this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);\n    }\n\n    *VAR_3 = !VAR_20 && !VAR_24 && this->ParseFncNames<buildAST>(VAR_0, VAR_9, VAR_2, &VAR_28);\n\n    if (VAR_18)\n    {\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n\n        this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);\n    }\n\n    if (VAR_5 && VAR_0->sxFnc.IsGenerator())\n    {\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        Error(VAR_37, VAR_0);\n    }\n\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    bool VAR_38 = VAR_32->SetYieldIsKeyword(VAR_0 && VAR_0->sxFnc.IsGenerator());\n\n    bool VAR_39 = VAR_32->SetAwaitIsKeyword(VAR_22);\n\n    if (VAR_0 && VAR_0->sxFnc.IsGenerator())\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_40, VAR_41);\n    }\n\n    if (VAR_34 && !*VAR_3)\n    {\n        FinishParseBlock(VAR_33);\n        VAR_42--;\n        Adelete(&VAR_43, VAR_34);\n        VAR_34 = nullptr;\n        VAR_33 = nullptr;\n    }\n    if (VAR_0)\n    {\n        VAR_0->sxFnc.scope = VAR_34;\n    }\n\n    /* COMMENT_10 */\n    bool VAR_44 =\n        buildAST &&\n        !VAR_29 &&\n        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == VAR_45);\n\n    VAR_27 = VAR_46;\n    SetCurrentStatement(nullptr);\n\n    /* COMMENT_11 */\n    bool VAR_47 = this->m_currentScope->GetScopeType() == VAR_48;\n\n    if (this->m_currentScope->GetScopeType() == VAR_36 || this->m_currentScope->GetScopeType() == VAR_49)\n    {\n        /* COMMENT_12 */\n        VAR_47 = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == VAR_48;\n    }\n\n    Assert(!VAR_47 || VAR_9->sxFnc.HasNonSimpleParameterList());\n\n    RestorePoint VAR_50;\n    VAR_32->Capture(&VAR_50);\n    BOOL VAR_51 = IsStrictMode();\n    BOOL VAR_52 = this->m_fUseStrictMode;\n\n    if (VAR_20)\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_53, VAR_41);\n    }\n\n    uint VAR_54 = VAR_55 & VAR_56;\n    if ((!VAR_18 && VAR_57) ||\n        VAR_47 ||\n        (VAR_2 & (VAR_58 | VAR_21)))\n    {\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        VAR_55 &= ~VAR_56;\n    }\n\n    bool VAR_59 = this->m_inFIB;\n    this->m_inFIB = VAR_29 || this->m_inFIB;\n\n    bool VAR_60 = false;\n\n    struct AutoFastScanFlag {\n        bool savedDoingFastScan;\n        AutoFastScanFlag(Parser *VAR_61) : m_parser(VAR_61) { VAR_62 = VAR_63->m_doingFastScan; }\n        ~AutoFastScanFlag() { VAR_63->m_doingFastScan = VAR_62; }\n        Parser *m_parser;\n    } VAR_64(this);\n\n    bool VAR_65 = false;\n    bool VAR_66 = false;\n    if (buildAST)\n    {\n        bool VAR_67 = !VAR_18 && VAR_0 && VAR_4;\n\n        BOOL VAR_68 = IsDeferredFnc();\n        AnalysisAssert(VAR_68 || VAR_0);\n        /* COMMENT_20 */\n        VAR_60 =\n            (!VAR_20\n             && VAR_0\n             && DeferredParse(VAR_0->sxFnc.functionId)\n             && (!VAR_0->sxFnc.IsNested() || CONFIG_FLAG(VAR_69))\n             && !VAR_70\n            /* COMMENT_21 */\n             && !VAR_24\n            );\n\n        if (VAR_0)\n        {\n            VAR_0->sxFnc.SetCanBeDeferred(VAR_60 && PnFnc::CanBeRedeferred(VAR_0->sxFnc.fncFlags));\n            VAR_0->sxFnc.SetFIBPreventsDeferral(false);\n        }\n\n        if (this->m_inFIB)\n        {\n            if (VAR_60)\n            {\n                /* COMMENT_22 */\n                /* COMMENT_23 */\n                /* COMMENT_24 */\n                VAR_0->sxFnc.SetFIBPreventsDeferral(true);\n            }\n            VAR_60 = false;\n        }        \n\n        /* COMMENT_25 */\n        VAR_60 = VAR_60 && !VAR_68 && \n            (!VAR_67 || !VAR_44 || PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId));\n;\n        if (!VAR_20 &&\n            !VAR_68 &&\n            !VAR_67 &&\n            !this->IsBackgroundParser() &&\n            !this->m_doingFastScan &&\n            !(VAR_9 && VAR_72) &&\n            !(this->m_parseType == VAR_73 && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !VAR_60))\n        {\n            VAR_65 = DoParallelParse(VAR_0);\n#if VAR_74\n            if (VAR_65)\n            {\n                BackgroundParser *VAR_75 = VAR_41->GetBackgroundParser();\n                Assert(VAR_75);\n                if (VAR_75->HasFailedBackgroundParseItem())\n                {\n                    Error(VAR_37);\n                }\n                VAR_65 = VAR_75->ParseBackgroundItem(this, VAR_0, VAR_60);\n                if (VAR_65)\n                {\n                    VAR_66 = true;\n                    this->m_hasParallelJob = true;\n                    this->m_doingFastScan = true;\n                    VAR_65 = FastScanFormalsAndBody();\n                    if (VAR_65)\n                    {\n                        /* COMMENT_26 */\n                        /* COMMENT_27 */\n                        /* COMMENT_28 */\n                        VAR_0->ichLim = VAR_32->IchLimTok();\n                        VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();\n                    }\n                }\n            }\n#endif\n        }\n    }\n\n    if (!VAR_65)\n    {\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        ParseNodePtr VAR_76 = VAR_0;\n        if (VAR_66)\n        {\n            /* COMMENT_31 */\n            /* COMMENT_32 */\n            /* COMMENT_33 */\n            VAR_0 = CreateDummyFuncNode(VAR_18);\n        }\n\n        AnalysisAssert(VAR_0);\n        ParseNodePtr VAR_77 = VAR_35<buildAST>(PnodeBlockType::Parameter, VAR_48);\n        AnalysisAssert(VAR_77 != nullptr);\n        VAR_0->sxFnc.pnodeScopes = VAR_77;\n        VAR_78 = &VAR_0->sxFnc.pnodeParams;\n\n        ParseNodePtr *VAR_79 = nullptr;\n        ParseNodePtr *VAR_80 = nullptr;\n\n        VAR_79 = VAR_81;\n        if (VAR_77)\n        {\n            /* COMMENT_34 */\n            VAR_81 = &VAR_77->sxBlock.pnodeScopes;\n            VAR_77->sxBlock.pnodeStmt = VAR_0;\n        }\n\n        /* COMMENT_35 */\n        /* COMMENT_36 */\n        VAR_80 = VAR_57;\n        VAR_57 = nullptr;\n\n        if (!VAR_7)\n        {\n            bool VAR_82 = VAR_83;\n            if (VAR_20)\n            {\n                VAR_83 = true;\n            }\n            this->ParseFncFormals<buildAST>(VAR_0, VAR_8, VAR_2);\n            VAR_83 = VAR_82;\n        }\n\n        /* COMMENT_37 */\n        ParseNodePtr VAR_84 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_85);\n        /* COMMENT_38 */\n        /* COMMENT_39 */\n        /* COMMENT_40 */\n        /* COMMENT_41 */\n        *VAR_81 = VAR_84;\n        VAR_0->sxFnc.pnodeBodyScope = VAR_84;\n\n        /* COMMENT_34 */\n        VAR_81 = &VAR_84->sxBlock.pnodeScopes;\n        VAR_84->sxBlock.pnodeStmt = VAR_0;\n\n        /* COMMENT_42 */\n        /* COMMENT_43 */\n\n        /* COMMENT_44 */\n        /* COMMENT_45 */\n        /* COMMENT_46 */\n        /* COMMENT_47 */\n        /* COMMENT_48 */\n        /* COMMENT_49 */\n        /* COMMENT_50 */\n        /* COMMENT_51 */\n        /* COMMENT_52 */\n        /* COMMENT_53 */\n\n        /* COMMENT_54 */\n        /* COMMENT_55 */\n        bool VAR_86 = false;\n\n        if (VAR_60 &&\n            !(this->m_grfscr & VAR_87) &&\n            VAR_0->sxFnc.IsNested() &&\n#ifndef VAR_88\n            VAR_71->sourceDynamicProfileManager == nullptr &&\n#endif\n            PHASE_ON_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) &&\n            (\n                !PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) ||\n                PHASE_FORCE_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId)\n            ))\n        {\n            /* COMMENT_56 */\n            /* COMMENT_57 */\n            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(VAR_89)))\n            {\n                VAR_60 = false;\n            }\n        }\n\n        Scope* VAR_90 = VAR_0->sxFnc.pnodeScopes ? VAR_0->sxFnc.pnodeScopes->sxBlock.scope : nullptr;\n        if (VAR_90 != nullptr)\n        {\n            if (CONFIG_FLAG(VAR_91))\n            {\n                VAR_90->SetCannotMergeWithBodyScope();\n            }\n            else if (VAR_0->sxFnc.HasNonSimpleParameterList())\n            {\n                if (VAR_90->GetCanMergeWithBodyScope())\n                {\n                    VAR_90->ForEachSymbolUntil([this, VAR_90, VAR_0](Symbol* VAR_92) {\n                        if (VAR_92->GetPid()->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)\n                        {\n                            /* COMMENT_58 */\n                            VAR_90->SetCannotMergeWithBodyScope();\n                            return true;\n                        }\n                        return false;\n                    });\n\n                    if (VAR_93.arguments->GetTopRef() && VAR_93.arguments->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)\n                    {\n                        Assert(VAR_0->sxFnc.UsesArguments());\n                        /* COMMENT_59 */\n                        VAR_90->SetCannotMergeWithBodyScope();\n                    }\n                }\n            }\n        }\n\n        if (!VAR_20 && VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope()\n            && (VAR_0->sxFnc.UsesArguments() || VAR_0->grfpn & VAR_94))\n        {\n            Error(VAR_95);\n        }\n\n        /* COMMENT_60 */\n        /* COMMENT_61 */\n        /* COMMENT_62 */\n        if (VAR_90 != nullptr && VAR_90->GetCanMergeWithBodyScope())\n        {\n            VAR_90->ForEachSymbol([this](Symbol* VAR_96)\n            {\n                PidRefStack* VAR_97 = PushPidRef(VAR_96->GetPid());\n                VAR_97->SetSym(VAR_96);\n            });\n        }\n\n        if (VAR_60 || (VAR_70 && VAR_98))\n        {\n            AssertMsg(!VAR_20, \"Deferring function parsing of a function does not handle lambda syntax\");\n            VAR_26 = true;\n\n            this->ParseTopLevelDeferredFunc(VAR_0, VAR_9, VAR_1);\n        }\n        else\n        {\n            if (VAR_99.tk == VAR_100) /* COMMENT_63 */\n            {\n                VAR_32->Scan();\n            }\n\n            if (VAR_20)\n            {\n                BOOL VAR_101 = VAR_32->FHadNewLine();\n\n                /* COMMENT_64 */\n                /* COMMENT_65 */\n                /* COMMENT_66 */\n                /* COMMENT_67 */\n                /* COMMENT_68 */\n                ChkCurTok(VAR_102, VAR_103);\n\n                /* COMMENT_69 */\n                /* COMMENT_70 */\n                if (VAR_101)\n                {\n                    Error(VAR_37);\n                }\n            }\n\n            AnalysisAssert(VAR_0);\n\n            /* COMMENT_71 */\n            Assert(*VAR_78 == nullptr);\n\n            /* COMMENT_72 */\n            VAR_0->sxFnc.pnodeVars = nullptr;\n            VAR_78 = &VAR_0->sxFnc.pnodeVars;\n\n            if (VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope())\n            {\n                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), VAR_0->sxFnc.pnodeName ? VAR_0->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                /* COMMENT_73 */\n                /* COMMENT_74 */\n                /* COMMENT_75 */\n                /* COMMENT_76 */\n                /* COMMENT_77 */\n                /* COMMENT_78 */\n                VAR_90->ForEachSymbol([this, VAR_0](Symbol* VAR_104) {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), VAR_104->GetPid()->Psz());\n\n                    ParseNodePtr VAR_105 = nullptr;\n                    if (this->m_ppnodeVar != &VAR_0->sxFnc.pnodeVars)\n                    {\n                        ParseNodePtr *const VAR_106 = VAR_78;\n                        VAR_78 = &VAR_0->sxFnc.pnodeVars;\n                        VAR_105 = this->CreateVarDeclNode(VAR_104->GetPid(), VAR_107, false, nullptr, false);\n                        VAR_78 = VAR_106;\n                    }\n                    else\n                    {\n                        VAR_105 = this->CreateVarDeclNode(VAR_104->GetPid(), VAR_107, false, nullptr, false);\n                    }\n\n                    Assert(VAR_105 && VAR_105->sxVar.sym->GetScope()->GetScopeType() == VAR_85);\n                    VAR_105->sxVar.sym->SetHasInit(true);\n                });\n\n                if (!VAR_20)\n                {\n                    /* COMMENT_79 */\n                    /* COMMENT_80 */\n                    /* COMMENT_81 */\n                    ParseNodePtr VAR_108 = this->CreateVarDeclNode(VAR_93.arguments, VAR_107, true, nullptr, false);\n                    Assert(VAR_108 && VAR_108->sxVar.sym->GetScope()->GetScopeType() == VAR_85);\n                }\n            }\n\n            /* COMMENT_35 */\n            /* COMMENT_36 */\n            VAR_57 = nullptr;\n\n            if (buildAST)\n            {\n                DeferredFunctionStub *VAR_109 = VAR_72;\n                if (VAR_47)\n                {\n                    /* COMMENT_82 */\n                    VAR_72 = nullptr;\n                }\n                else if (VAR_9 && VAR_72)\n                {\n                    /* COMMENT_83 */\n                    /* COMMENT_84 */\n                    /* COMMENT_85 */\n                    /* COMMENT_86 */\n                    /* COMMENT_87 */\n\n                    if (VAR_9->sxFnc.nestedCount == 1)\n                    {\n                        VAR_110 = nullptr;\n                    }\n\n                    if (VAR_110 == nullptr)\n                    {\n                        VAR_110 = (VAR_72 + (VAR_9->sxFnc.nestedCount - 1));\n                    }\n\n                    if (VAR_110->ichMin == VAR_0->ichMin)\n                    {\n                        VAR_72 = VAR_110->deferredStubs;\n                        VAR_110 = nullptr;\n                    }\n                    else\n                    {\n                        VAR_72 = nullptr;\n                    }\n                }\n\n                if (VAR_99.tk != VAR_111 && VAR_20)\n                {\n                    VAR_112<true>(VAR_0);\n                    *VAR_6 = false;\n                }\n                else\n                {\n                    this->FinishFncDecl(VAR_0, VAR_1, VAR_28, VAR_7);\n                }\n                VAR_72 = VAR_109;\n            }\n            else\n            {\n                this->ParseNestedDeferredFunc(VAR_0, VAR_20, VAR_6, &VAR_86);\n            }\n        }\n\n        if (VAR_84)\n        {\n            FinishParseBlock(VAR_84, *VAR_6);\n        }\n\n        if (!VAR_24 && (VAR_99.tk == VAR_111 || !VAR_20))\n        {\n            this->AddArgumentsNodeToVars(VAR_0);\n        }\n\n        /* COMMENT_88 */\n\n        Assert(VAR_57 == nullptr || *VAR_57 == nullptr);\n        VAR_57 = VAR_80;\n\n        AssertMem(VAR_81);\n        Assert(nullptr == *VAR_81);\n        VAR_81 = VAR_79;\n\n        if (VAR_77)\n        {\n            FinishParseBlock(VAR_77, *VAR_6);\n        }\n\n        if (IsStrictMode() || VAR_86)\n        {\n            this->m_fUseStrictMode = TRUE; /* COMMENT_89 */\n\n            if (!VAR_51)\n            {\n                /* COMMENT_90 */\n                /* COMMENT_91 */\n                RestorePoint VAR_113;\n                VAR_32->Capture(&VAR_113);\n\n                if (*VAR_3)\n                {\n                    /* COMMENT_92 */\n                    VAR_32->SeekTo(VAR_31);\n                    VAR_32->Scan();\n                    if (VAR_0->sxFnc.IsGenerator())\n                    {\n                        Assert(VAR_99.tk == VAR_114);\n                        Assert(VAR_41->GetConfig()->IsES6GeneratorsEnabled());\n                        Assert(!(VAR_2 & VAR_115));\n                        VAR_32->Scan();\n                    }\n                    if (VAR_99.IsReservedWord())\n                    {\n                        IdentifierExpectedError(VAR_99);\n                    }\n                    CheckStrictModeEvalArgumentsUsage(VAR_99.GetIdentifier(VAR_116));\n                }\n\n                /* COMMENT_93 */\n                /* COMMENT_94 */\n                VAR_32->SeekToForcingPid(VAR_50);\n                CheckStrictFormalParameters();\n                VAR_32->SeekTo(VAR_113);\n            }\n\n            if (buildAST)\n            {\n                if (VAR_0->sxFnc.pnodeName != nullptr && VAR_117 == VAR_0->sxFnc.pnodeName->nop)\n                {\n                    CheckStrictModeEvalArgumentsUsage(VAR_0->sxFnc.pnodeName->sxVar.pid, VAR_0->sxFnc.pnodeName);\n                }\n            }\n\n            this->m_fUseStrictMode = VAR_52;\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_118, VAR_41);\n        }\n\n        if (VAR_26)\n        {\n            AnalysisAssert(VAR_0);\n            VAR_0->sxFnc.pnodeVars = nullptr;\n        }\n\n        if (VAR_66)\n        {\n            VAR_0 = VAR_76;\n            VAR_11 = VAR_76;\n\n            /* COMMENT_26 */\n            /* COMMENT_27 */\n            /* COMMENT_28 */\n            VAR_0->ichLim = VAR_32->IchLimTok();\n            VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();\n        }\n    }\n\n    /* COMMENT_95 */\n    AnalysisAssert(VAR_0);\n    if (VAR_0->sxFnc.GetAsmjsMode())\n    {\n        VAR_70 = false;\n    }\n\n    /* COMMENT_96 */\n    Assert(nullptr == VAR_46);\n    SetCurrentStatement(VAR_27);\n\n    if (VAR_33)\n    {\n        FinishParseFncExprScope(VAR_0, VAR_33);\n    }\n    if (!VAR_119)\n    {\n        VAR_55 |= VAR_54;\n    }\n    VAR_120 = VAR_59;\n\n    VAR_32->SetYieldIsKeyword(VAR_38);\n    VAR_32->SetAwaitIsKeyword(VAR_39);\n\n    /* COMMENT_97 */\n    if (buildAST)\n    {\n        Assert(VAR_0 == VAR_11);\n\n        VAR_11 = VAR_9;\n        VAR_17 = VAR_16;\n\n        if (!VAR_20)\n        {\n            Assert(VAR_0 == VAR_14);\n            VAR_14 = VAR_13;\n        }\n    }\n    else\n    {\n        Assert(VAR_0 == VAR_12);\n        if (!VAR_20)\n        {\n            Assert(VAR_0 == VAR_15);\n            VAR_15 = VAR_13;\n        }\n        VAR_12 = VAR_9;\n    }\n\n    if (VAR_11 && VAR_0->sxFnc.HasWithStmt())\n    {\n        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);\n    }\n\n    return true;\n}",
  "func_graph_path_before": "chakra-core/ChakraCore/9da019424601325a6e95e6be0fa03d7d21d0b517/Parse.cpp/vul/before/0.json",
  "func": "bool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool *pHasName, bool fUnaryOrParen, bool noStmtContext, bool *pNeedScanRCurly, bool skipFormals)\n{\n    ParseNodePtr pnodeFncParent = GetCurrentFunctionNode();\n    // is the following correct? When buildAST is false, m_currentNodeDeferredFunc can be nullptr on transition to deferred parse from non-deferred\n    ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;\n    ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;\n    int32* pAstSizeSave = m_pCurrentAstSize;\n\n    bool fDeclaration = (flags & fFncDeclaration) != 0;\n    bool fLambda = (flags & fFncLambda) != 0;\n    bool fAsync = (flags & fFncAsync) != 0;\n    bool fModule = (flags & fFncModule) != 0;\n    bool fDeferred = false;\n    StmtNest *pstmtSave;\n    ParseNodePtr *lastNodeRef = nullptr;\n    bool fFunctionInBlock = false;\n    if (buildAST)\n    {\n        fFunctionInBlock = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&\n            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||\n             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock);\n    }\n\n    // Save the position of the scanner in case we need to inspect the name hint later\n    RestorePoint beginNameHint;\n    m_pscan->Capture(&beginNameHint);\n\n    ParseNodePtr pnodeFncExprScope = nullptr;    \n    Scope *fncExprScope = nullptr;\n    if (!fDeclaration)\n    {\n        pnodeFncExprScope = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FuncExpr);\n        fncExprScope = pnodeFncExprScope->sxBlock.scope;\n\n        // Function expression: push the new function onto the stack now so that the name (if any) will be\n        // local to the new function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    *pHasName = !fLambda && !fModule && this->ParseFncNames<buildAST>(pnodeFnc, pnodeFncSave, flags, &lastNodeRef);\n\n    if (fDeclaration)\n    {\n        // Declaration statement: push the new function now, after parsing the name, so the name is local to the\n        // enclosing function.\n\n        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);\n    }\n\n    if (noStmtContext && pnodeFnc->sxFnc.IsGenerator())\n    {\n        // Generator decl not allowed outside stmt context. (We have to wait until we've parsed the '*' to\n        // detect generator.)\n        Error(ERRsyntax, pnodeFnc);\n    }\n\n    // switch scanner to treat 'yield' as keyword in generator functions\n    // or as an identifier in non-generator functions\n    bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());\n\n    bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync);\n\n    if (pnodeFnc && pnodeFnc->sxFnc.IsGenerator())\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Generator, m_scriptContext);\n    }\n\n    if (fncExprScope && !*pHasName)\n    {\n        FinishParseBlock(pnodeFncExprScope);\n        m_nextBlockId--;\n        Adelete(&m_nodeAllocator, fncExprScope);\n        fncExprScope = nullptr;\n        pnodeFncExprScope = nullptr;\n    }\n    if (pnodeFnc)\n    {\n        pnodeFnc->sxFnc.scope = fncExprScope;\n    }\n\n    // Start a new statement stack.\n    bool topLevelStmt =\n        buildAST &&\n        !fFunctionInBlock &&\n        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == knopBlock);\n\n    pstmtSave = m_pstmtCur;\n    SetCurrentStatement(nullptr);\n\n    // Function definition is inside the parent function's parameter scope\n    bool isEnclosedInParamScope = this->m_currentScope->GetScopeType() == ScopeType_Parameter;\n\n    if (this->m_currentScope->GetScopeType() == ScopeType_FuncExpr || this->m_currentScope->GetScopeType() == ScopeType_Block)\n    {\n        // Or this is a function expression or class enclosed in a parameter scope\n        isEnclosedInParamScope = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == ScopeType_Parameter;\n    }\n\n    Assert(!isEnclosedInParamScope || pnodeFncSave->sxFnc.HasNonSimpleParameterList());\n\n    RestorePoint beginFormals;\n    m_pscan->Capture(&beginFormals);\n    BOOL fWasAlreadyStrictMode = IsStrictMode();\n    BOOL oldStrictMode = this->m_fUseStrictMode;\n\n    if (fLambda)\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Lambda, m_scriptContext);\n    }\n\n    uint uDeferSave = m_grfscr & fscrDeferFncParse;\n    if ((!fDeclaration && m_ppnodeExprScope) ||\n        isEnclosedInParamScope ||\n        (flags & (fFncNoName | fFncLambda)))\n    {\n        // NOTE: Don't defer if this is a function expression inside a construct that induces\n        // a scope nested within the current function (like a with, or a catch in ES5 mode, or\n        // any function declared inside a nested lexical block or param scope in ES6 mode).\n        // We won't be able to reconstruct the scope chain properly when we come back and\n        // try to compile just the function expression.\n        // Also shut off deferring on getter/setter or other construct with unusual text bounds\n        // (fFncNoName|fFncLambda) as these are usually trivial, and re-parsing is problematic.\n        m_grfscr &= ~fscrDeferFncParse;\n    }\n\n    bool saveInFIB = this->m_inFIB;\n    this->m_inFIB = fFunctionInBlock || this->m_inFIB;\n\n    bool isTopLevelDeferredFunc = false;\n\n    struct AutoFastScanFlag {\n        bool savedDoingFastScan;\n        AutoFastScanFlag(Parser *parser) : m_parser(parser) { savedDoingFastScan = m_parser->m_doingFastScan; }\n        ~AutoFastScanFlag() { m_parser->m_doingFastScan = savedDoingFastScan; }\n        Parser *m_parser;\n    } flag(this);\n\n    bool doParallel = false;\n    bool parallelJobStarted = false;\n    if (buildAST)\n    {\n        bool isLikelyIIFE = !fDeclaration && pnodeFnc && fUnaryOrParen;\n\n        BOOL isDeferredFnc = IsDeferredFnc();\n        AnalysisAssert(isDeferredFnc || pnodeFnc);\n        // These are the conditions that prohibit upfront deferral *and* redeferral.\n        isTopLevelDeferredFunc =\n            (!fLambda\n             && pnodeFnc\n             && DeferredParse(pnodeFnc->sxFnc.functionId)\n             && (!pnodeFnc->sxFnc.IsNested() || CONFIG_FLAG(DeferNested))\n             && !m_InAsmMode\n            // Don't defer a module function wrapper because we need to do export resolution at parse time\n             && !fModule\n            );\n\n        if (pnodeFnc)\n        {\n            pnodeFnc->sxFnc.SetCanBeDeferred(isTopLevelDeferredFunc && PnFnc::CanBeRedeferred(pnodeFnc->sxFnc.fncFlags));\n            pnodeFnc->sxFnc.SetFIBPreventsDeferral(false);\n        }\n\n        if (this->m_inFIB)\n        {\n            if (isTopLevelDeferredFunc)\n            {\n                // Block-scoping is the only non-heuristic reason for not deferring this function up front.\n                // So on creating the full FunctionBody at byte code gen time, verify that there is no\n                // block-scoped content visible to this function so it can remain a redeferral candidate.\n                pnodeFnc->sxFnc.SetFIBPreventsDeferral(true);\n            }\n            isTopLevelDeferredFunc = false;\n        }        \n\n        // These are heuristic conditions that prohibit upfront deferral but not redeferral.\n        isTopLevelDeferredFunc = isTopLevelDeferredFunc && !isDeferredFnc && \n            (!isLikelyIIFE || !topLevelStmt || PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId));\n;\n        if (!fLambda &&\n            !isDeferredFnc &&\n            !isLikelyIIFE &&\n            !this->IsBackgroundParser() &&\n            !this->m_doingFastScan &&\n            !(pnodeFncSave && m_currDeferredStub) &&\n            !(this->m_parseType == ParseType_Deferred && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !isTopLevelDeferredFunc))\n        {\n            doParallel = DoParallelParse(pnodeFnc);\n#if ENABLE_BACKGROUND_PARSING\n            if (doParallel)\n            {\n                BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();\n                Assert(bgp);\n                if (bgp->HasFailedBackgroundParseItem())\n                {\n                    Error(ERRsyntax);\n                }\n                doParallel = bgp->ParseBackgroundItem(this, pnodeFnc, isTopLevelDeferredFunc);\n                if (doParallel)\n                {\n                    parallelJobStarted = true;\n                    this->m_hasParallelJob = true;\n                    this->m_doingFastScan = true;\n                    doParallel = FastScanFormalsAndBody();\n                    if (doParallel)\n                    {\n                        // Let the foreground thread take care of marking the limit on the function node,\n                        // because in some cases this function's caller will want to change that limit,\n                        // so we don't want the background thread to try and touch it.\n                        pnodeFnc->ichLim = m_pscan->IchLimTok();\n                        pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n                    }\n                }\n            }\n#endif\n        }\n    }\n\n    if (!doParallel)\n    {\n        // We don't want to, or couldn't, let the main thread scan past this function body, so parse\n        // it for real.\n        ParseNodePtr pnodeRealFnc = pnodeFnc;\n        if (parallelJobStarted)\n        {\n            // We have to deal with a failure to fast-scan the function (due to syntax error? \"/\"?) when\n            // a background thread may already have begun to work on the job. Both threads can't be allowed to\n            // operate on the same node.\n            pnodeFnc = CreateDummyFuncNode(fDeclaration);\n        }\n\n        AnalysisAssert(pnodeFnc);\n        ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);\n        AnalysisAssert(pnodeBlock != nullptr);\n        pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;\n        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;\n\n        ParseNodePtr *ppnodeScopeSave = nullptr;\n        ParseNodePtr *ppnodeExprScopeSave = nullptr;\n\n        ppnodeScopeSave = m_ppnodeScope;\n        if (pnodeBlock)\n        {\n            // This synthetic block scope will contain all the nested scopes.\n            m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;\n            pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;\n        }\n\n        // Keep nested function declarations and expressions in the same list at function scope.\n        // (Indicate this by nulling out the current function expressions list.)\n        ppnodeExprScopeSave = m_ppnodeExprScope;\n        m_ppnodeExprScope = nullptr;\n\n        if (!skipFormals)\n        {\n            bool fLambdaParamsSave = m_reparsingLambdaParams;\n            if (fLambda)\n            {\n                m_reparsingLambdaParams = true;\n            }\n            this->ParseFncFormals<buildAST>(pnodeFnc, pnodeFncParent, flags);\n            m_reparsingLambdaParams = fLambdaParamsSave;\n        }\n\n        // Create function body scope\n        ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);\n        // Set the parameter block's child to the function body block.\n        // The pnodeFnc->sxFnc.pnodeScopes list is constructed in such a way that it includes all the scopes in this list.\n        // For example if the param scope has one function and body scope has one function then the list will look like below,\n        // param scope block -> function decl from param scope -> body socpe block -> function decl from body scope.\n        *m_ppnodeScope = pnodeInnerBlock;\n        pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;\n\n        // This synthetic block scope will contain all the nested scopes.\n        m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;\n        pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;\n\n        // DEFER: Begin deferral here (after names are parsed and name nodes created).\n        // Create no more AST nodes until we're done.\n\n        // Try to defer this func if all these are true:\n        //  0. We are not already in deferred parsing (i.e. buildAST is true)\n        //  1. We are not re-parsing a deferred func which is being invoked.\n        //  2. Dynamic profile suggests this func can be deferred (and deferred parse is on).\n        //  3. This func is top level or defer nested func is on.\n        //  4. Optionally, the function is non-nested and not in eval, or the deferral decision was based on cached profile info,\n        //     or the function is sufficiently long. (I.e., don't defer little nested functions unless we're\n        //     confident they'll never be executed, because un-deferring nested functions is more expensive.)\n        //     NOTE: I'm disabling #4 by default, because we've found other ways to reduce the cost of un-deferral,\n        //           and we don't want to create function bodies aggressively for little functions.\n\n        // We will also temporarily defer all asm.js functions, except for the asm.js\n        // module itself, which we will never defer\n        bool strictModeTurnedOn = false;\n\n        if (isTopLevelDeferredFunc &&\n            !(this->m_grfscr & fscrEvalCode) &&\n            pnodeFnc->sxFnc.IsNested() &&\n#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE\n            m_sourceContextInfo->sourceDynamicProfileManager == nullptr &&\n#endif\n            PHASE_ON_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) &&\n            (\n                !PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) ||\n                PHASE_FORCE_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId)\n            ))\n        {\n            // Try to scan ahead to the end of the function. If we get there before we've scanned a minimum\n            // number of tokens, don't bother deferring, because it's too small.\n            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(MinDeferredFuncTokenCount)))\n            {\n                isTopLevelDeferredFunc = false;\n            }\n        }\n\n        Scope* paramScope = pnodeFnc->sxFnc.pnodeScopes ? pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope : nullptr;\n        if (paramScope != nullptr)\n        {\n            if (CONFIG_FLAG(ForceSplitScope))\n            {\n                paramScope->SetCannotMergeWithBodyScope();\n            }\n            else if (pnodeFnc->sxFnc.HasNonSimpleParameterList())\n            {\n                if (paramScope->GetCanMergeWithBodyScope())\n                {\n                    paramScope->ForEachSymbolUntil([this, paramScope, pnodeFnc](Symbol* sym) {\n                        if (sym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                        {\n                            // One of the symbol has non local reference. Mark the param scope as we can't merge it with body scope.\n                            paramScope->SetCannotMergeWithBodyScope();\n                            return true;\n                        }\n                        return false;\n                    });\n\n                    if (wellKnownPropertyPids.arguments->GetTopRef() && wellKnownPropertyPids.arguments->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                    {\n                        Assert(pnodeFnc->sxFnc.UsesArguments());\n                        // Arguments symbol is captured in the param scope\n                        paramScope->SetCannotMergeWithBodyScope();\n                    }\n                }\n                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)\n                {\n                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n                    {\n                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function\n                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var\n                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add\n                        // the name symbol to the param scope by splitting it.\n                        paramScope->SetCannotMergeWithBodyScope();\n                    }\n                }\n\n            }\n        }\n\n        if (!fLambda && paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope()\n            && (pnodeFnc->sxFnc.UsesArguments() || pnodeFnc->grfpn & fpnArguments_overriddenByDecl))\n        {\n            Error(ERRNonSimpleParamListArgumentsUse);\n        }\n\n        // If the param scope is merged with the body scope we want to use the param scope symbols in the body scope.\n        // So add a pid ref for the body using the param scope symbol. Note that in this case the same symbol will occur twice\n        // in the same pid ref stack.\n        if (paramScope != nullptr && paramScope->GetCanMergeWithBodyScope())\n        {\n            paramScope->ForEachSymbol([this](Symbol* paramSym)\n            {\n                PidRefStack* ref = PushPidRef(paramSym->GetPid());\n                ref->SetSym(paramSym);\n            });\n        }\n\n        if (isTopLevelDeferredFunc || (m_InAsmMode && m_deferAsmJs))\n        {\n            AssertMsg(!fLambda, \"Deferring function parsing of a function does not handle lambda syntax\");\n            fDeferred = true;\n\n            this->ParseTopLevelDeferredFunc(pnodeFnc, pnodeFncSave, pNameHint);\n        }\n        else\n        {\n            if (m_token.tk == tkRParen) // This might be false due to error recovery or lambda.\n            {\n                m_pscan->Scan();\n            }\n\n            if (fLambda)\n            {\n                BOOL hadNewLine = m_pscan->FHadNewLine();\n\n                // it can be the case we do not have a fat arrow here if there is a valid expression on the left hand side\n                // of the fat arrow, but that expression does not parse as a parameter list.  E.g.\n                //    a.x => { }\n                // Therefore check for it and error if not found.\n                // LS Mode : since this is a lambda we supposed to get the fat arrow, if not we will skip till we get that fat arrow.\n                ChkCurTok(tkDArrow, ERRnoDArrow);\n\n                // Newline character between arrow parameters and fat arrow is a syntax error but we want to check for\n                // this after verifying there was a => token. Otherwise we would throw the wrong error.\n                if (hadNewLine)\n                {\n                    Error(ERRsyntax);\n                }\n            }\n\n            AnalysisAssert(pnodeFnc);\n\n            // Shouldn't be any temps in the arg list.\n            Assert(*m_ppnodeVar == nullptr);\n\n            // Start the var list.\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n\n            if (paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope())\n            {\n                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                // Add a new symbol reference for each formal in the param scope to the body scope.\n                // While inserting symbols into the symbol list we always insert at the front, so while traversing the list we will be visiting the last added\n                // formals first. Normal insertion of those into the body will reverse the order of symbols, which will eventually result in different order\n                // for scope slots allocation for the corresponding symbol in both param and body scope. Inserting them in the opposite order will help us\n                // have the same sequence for scope slots allocation in both scopes. This makes it easy to read the bytecode and may help in some optimization\n                // later.\n                paramScope->ForEachSymbol([this, pnodeFnc](Symbol* param) {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), param->GetPid()->Psz());\n\n                    ParseNodePtr paramNode = nullptr;\n                    if (this->m_ppnodeVar != &pnodeFnc->sxFnc.pnodeVars)\n                    {\n                        ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;\n                        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                        m_ppnodeVar = ppnodeVarSave;\n                    }\n                    else\n                    {\n                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);\n                    }\n\n                    Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                    paramNode->sxVar.sym->SetHasInit(true);\n                });\n\n                if (!fLambda)\n                {\n                    // In split scope case ideally the arguments object should be in the param scope.\n                    // Right now referring to arguments in the param scope is a SyntaxError, so we have to\n                    // add a duplicate symbol in the body scope and copy over the value in BeginBodySope.\n                    ParseNodePtr argumentsNode = this->CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, nullptr, false);\n                    Assert(argumentsNode && argumentsNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);\n                }\n            }\n\n            // Keep nested function declarations and expressions in the same list at function scope.\n            // (Indicate this by nulling out the current function expressions list.)\n            m_ppnodeExprScope = nullptr;\n\n            if (buildAST)\n            {\n                DeferredFunctionStub *saveCurrentStub = m_currDeferredStub;\n                if (isEnclosedInParamScope)\n                {\n                    // if the enclosed scope is the param scope we would not have created the deferred stub.\n                    m_currDeferredStub = nullptr;\n                }\n                else if (pnodeFncSave && m_currDeferredStub)\n                {\n                    // the Deferred stub will not match for the function which are defined on lambda formals.\n                    // Since this is not determined upfront that the current function is a part of outer function or part of lambda formal until we have seen the Arrow token.\n                    // Due to that the current function may be fetching stubs from the outer function (outer of the lambda) - rather then the lambda function. The way to fix is to match\n                    // the function start with the stub. Because they should match. We need to have previous sibling concept as the lambda formals can have more than one\n                    // functions and we want to avoid getting wrong stub.\n\n                    if (pnodeFncSave->sxFnc.nestedCount == 1)\n                    {\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n\n                    if (m_prevSiblingDeferredStub == nullptr)\n                    {\n                        m_prevSiblingDeferredStub = (m_currDeferredStub + (pnodeFncSave->sxFnc.nestedCount - 1));\n                    }\n\n                    if (m_prevSiblingDeferredStub->ichMin == pnodeFnc->ichMin)\n                    {\n                        m_currDeferredStub = m_prevSiblingDeferredStub->deferredStubs;\n                        m_prevSiblingDeferredStub = nullptr;\n                    }\n                    else\n                    {\n                        m_currDeferredStub = nullptr;\n                    }\n                }\n\n                if (m_token.tk != tkLCurly && fLambda)\n                {\n                    ParseExpressionLambdaBody<true>(pnodeFnc);\n                    *pNeedScanRCurly = false;\n                }\n                else\n                {\n                    this->FinishFncDecl(pnodeFnc, pNameHint, lastNodeRef, skipFormals);\n                }\n                m_currDeferredStub = saveCurrentStub;\n            }\n            else\n            {\n                this->ParseNestedDeferredFunc(pnodeFnc, fLambda, pNeedScanRCurly, &strictModeTurnedOn);\n            }\n        }\n\n        if (pnodeInnerBlock)\n        {\n            FinishParseBlock(pnodeInnerBlock, *pNeedScanRCurly);\n        }\n\n        if (!fModule && (m_token.tk == tkLCurly || !fLambda))\n        {\n            this->AddArgumentsNodeToVars(pnodeFnc);\n        }\n\n        // Restore the lists of scopes that contain function expressions.\n\n        Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);\n        m_ppnodeExprScope = ppnodeExprScopeSave;\n\n        AssertMem(m_ppnodeScope);\n        Assert(nullptr == *m_ppnodeScope);\n        m_ppnodeScope = ppnodeScopeSave;\n\n        if (pnodeBlock)\n        {\n            FinishParseBlock(pnodeBlock, *pNeedScanRCurly);\n        }\n\n        if (IsStrictMode() || strictModeTurnedOn)\n        {\n            this->m_fUseStrictMode = TRUE; // Now we know this function is in strict mode\n\n            if (!fWasAlreadyStrictMode)\n            {\n                // If this function turned on strict mode then we didn't check the formal\n                // parameters or function name hint for future reserved word usage. So do that now.\n                RestorePoint afterFnc;\n                m_pscan->Capture(&afterFnc);\n\n                if (*pHasName)\n                {\n                    // Rewind to the function name hint and check if the token is a reserved word.\n                    m_pscan->SeekTo(beginNameHint);\n                    m_pscan->Scan();\n                    if (pnodeFnc->sxFnc.IsGenerator())\n                    {\n                        Assert(m_token.tk == tkStar);\n                        Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());\n                        Assert(!(flags & fFncClassMember));\n                        m_pscan->Scan();\n                    }\n                    if (m_token.IsReservedWord())\n                    {\n                        IdentifierExpectedError(m_token);\n                    }\n                    CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));\n                }\n\n                // Fast forward to formal parameter list, check for future reserved words,\n                // then restore scanner as it was.\n                m_pscan->SeekToForcingPid(beginFormals);\n                CheckStrictFormalParameters();\n                m_pscan->SeekTo(afterFnc);\n            }\n\n            if (buildAST)\n            {\n                if (pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)\n                {\n                    CheckStrictModeEvalArgumentsUsage(pnodeFnc->sxFnc.pnodeName->sxVar.pid, pnodeFnc->sxFnc.pnodeName);\n                }\n            }\n\n            this->m_fUseStrictMode = oldStrictMode;\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StrictModeFunction, m_scriptContext);\n        }\n\n        if (fDeferred)\n        {\n            AnalysisAssert(pnodeFnc);\n            pnodeFnc->sxFnc.pnodeVars = nullptr;\n        }\n\n        if (parallelJobStarted)\n        {\n            pnodeFnc = pnodeRealFnc;\n            m_currentNodeFunc = pnodeRealFnc;\n\n            // Let the foreground thread take care of marking the limit on the function node,\n            // because in some cases this function's caller will want to change that limit,\n            // so we don't want the background thread to try and touch it.\n            pnodeFnc->ichLim = m_pscan->IchLimTok();\n            pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();\n        }\n    }\n\n    // after parsing asm.js module, we want to reset asm.js state before continuing\n    AnalysisAssert(pnodeFnc);\n    if (pnodeFnc->sxFnc.GetAsmjsMode())\n    {\n        m_InAsmMode = false;\n    }\n\n    // Restore the statement stack.\n    Assert(nullptr == m_pstmtCur);\n    SetCurrentStatement(pstmtSave);\n\n    if (pnodeFncExprScope)\n    {\n        FinishParseFncExprScope(pnodeFnc, pnodeFncExprScope);\n    }\n    if (!m_stoppedDeferredParse)\n    {\n        m_grfscr |= uDeferSave;\n    }\n    m_inFIB = saveInFIB;\n\n    m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);\n    m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);\n\n    // Restore the current function.\n    if (buildAST)\n    {\n        Assert(pnodeFnc == m_currentNodeFunc);\n\n        m_currentNodeFunc = pnodeFncSave;\n        m_pCurrentAstSize = pAstSizeSave;\n\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaFunc);\n            m_currentNodeNonLambdaFunc = pnodeFncSaveNonLambda;\n        }\n    }\n    else\n    {\n        Assert(pnodeFnc == m_currentNodeDeferredFunc);\n        if (!fLambda)\n        {\n            Assert(pnodeFnc == m_currentNodeNonLambdaDeferredFunc);\n            m_currentNodeNonLambdaDeferredFunc = pnodeFncSaveNonLambda;\n        }\n        m_currentNodeDeferredFunc = pnodeFncSave;\n    }\n\n    if (m_currentNodeFunc && pnodeFnc->sxFnc.HasWithStmt())\n    {\n        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);\n    }\n\n    return true;\n}",
  "abstract_func": "bool Parser::ParseFncDeclHelper(ParseNodePtr VAR_0, LPCOLESTR VAR_1, ushort VAR_2, bool *VAR_3, bool VAR_4, bool VAR_5, bool *VAR_6, bool VAR_7)\n{\n    ParseNodePtr VAR_8 = GetCurrentFunctionNode();\n    /* COMMENT_0 */\n    ParseNodePtr VAR_9 = VAR_10 ? VAR_11 : VAR_12;\n    ParseNodePtr VAR_13 = VAR_10 ? VAR_14 : VAR_15;\n    int32* VAR_16 = VAR_17;\n\n    bool VAR_18 = (VAR_2 & VAR_19) != 0;\n    bool VAR_20 = (VAR_2 & VAR_21) != 0;\n    bool VAR_22 = (VAR_2 & VAR_23) != 0;\n    bool VAR_24 = (VAR_2 & VAR_25) != 0;\n    bool VAR_26 = false;\n    StmtNest *VAR_27;\n    ParseNodePtr *VAR_28 = nullptr;\n    bool VAR_29 = false;\n    if (VAR_10)\n    {\n        VAR_29 = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&\n            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||\n             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != VAR_30);\n    }\n\n    /* COMMENT_1 */\n    RestorePoint VAR_31;\n    VAR_32->Capture(&VAR_31);\n\n    ParseNodePtr VAR_33 = nullptr;    \n    Scope *VAR_34 = nullptr;\n    if (!VAR_18)\n    {\n        VAR_33 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_36);\n        VAR_34 = VAR_33->sxBlock.scope;\n\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n\n        this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);\n    }\n\n    *VAR_3 = !VAR_20 && !VAR_24 && this->ParseFncNames<buildAST>(VAR_0, VAR_9, VAR_2, &VAR_28);\n\n    if (VAR_18)\n    {\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n\n        this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);\n    }\n\n    if (VAR_5 && VAR_0->sxFnc.IsGenerator())\n    {\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        Error(VAR_37, VAR_0);\n    }\n\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    bool VAR_38 = VAR_32->SetYieldIsKeyword(VAR_0 && VAR_0->sxFnc.IsGenerator());\n\n    bool VAR_39 = VAR_32->SetAwaitIsKeyword(VAR_22);\n\n    if (VAR_0 && VAR_0->sxFnc.IsGenerator())\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_40, VAR_41);\n    }\n\n    if (VAR_34 && !*VAR_3)\n    {\n        FinishParseBlock(VAR_33);\n        VAR_42--;\n        Adelete(&VAR_43, VAR_34);\n        VAR_34 = nullptr;\n        VAR_33 = nullptr;\n    }\n    if (VAR_0)\n    {\n        VAR_0->sxFnc.scope = VAR_34;\n    }\n\n    /* COMMENT_10 */\n    bool VAR_44 =\n        buildAST &&\n        !VAR_29 &&\n        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == VAR_45);\n\n    VAR_27 = VAR_46;\n    SetCurrentStatement(nullptr);\n\n    /* COMMENT_11 */\n    bool VAR_47 = this->m_currentScope->GetScopeType() == VAR_48;\n\n    if (this->m_currentScope->GetScopeType() == VAR_36 || this->m_currentScope->GetScopeType() == VAR_49)\n    {\n        /* COMMENT_12 */\n        VAR_47 = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == VAR_48;\n    }\n\n    Assert(!VAR_47 || VAR_9->sxFnc.HasNonSimpleParameterList());\n\n    RestorePoint VAR_50;\n    VAR_32->Capture(&VAR_50);\n    BOOL VAR_51 = IsStrictMode();\n    BOOL VAR_52 = this->m_fUseStrictMode;\n\n    if (VAR_20)\n    {\n        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_53, VAR_41);\n    }\n\n    uint VAR_54 = VAR_55 & VAR_56;\n    if ((!VAR_18 && VAR_57) ||\n        VAR_47 ||\n        (VAR_2 & (VAR_58 | VAR_21)))\n    {\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        VAR_55 &= ~VAR_56;\n    }\n\n    bool VAR_59 = this->m_inFIB;\n    this->m_inFIB = VAR_29 || this->m_inFIB;\n\n    bool VAR_60 = false;\n\n    struct AutoFastScanFlag {\n        bool savedDoingFastScan;\n        AutoFastScanFlag(Parser *VAR_61) : m_parser(VAR_61) { VAR_62 = VAR_63->m_doingFastScan; }\n        ~AutoFastScanFlag() { VAR_63->m_doingFastScan = VAR_62; }\n        Parser *m_parser;\n    } VAR_64(this);\n\n    bool VAR_65 = false;\n    bool VAR_66 = false;\n    if (buildAST)\n    {\n        bool VAR_67 = !VAR_18 && VAR_0 && VAR_4;\n\n        BOOL VAR_68 = IsDeferredFnc();\n        AnalysisAssert(VAR_68 || VAR_0);\n        /* COMMENT_20 */\n        VAR_60 =\n            (!VAR_20\n             && VAR_0\n             && DeferredParse(VAR_0->sxFnc.functionId)\n             && (!VAR_0->sxFnc.IsNested() || CONFIG_FLAG(VAR_69))\n             && !VAR_70\n            /* COMMENT_21 */\n             && !VAR_24\n            );\n\n        if (VAR_0)\n        {\n            VAR_0->sxFnc.SetCanBeDeferred(VAR_60 && PnFnc::CanBeRedeferred(VAR_0->sxFnc.fncFlags));\n            VAR_0->sxFnc.SetFIBPreventsDeferral(false);\n        }\n\n        if (this->m_inFIB)\n        {\n            if (VAR_60)\n            {\n                /* COMMENT_22 */\n                /* COMMENT_23 */\n                /* COMMENT_24 */\n                VAR_0->sxFnc.SetFIBPreventsDeferral(true);\n            }\n            VAR_60 = false;\n        }        \n\n        /* COMMENT_25 */\n        VAR_60 = VAR_60 && !VAR_68 && \n            (!VAR_67 || !VAR_44 || PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId));\n;\n        if (!VAR_20 &&\n            !VAR_68 &&\n            !VAR_67 &&\n            !this->IsBackgroundParser() &&\n            !this->m_doingFastScan &&\n            !(VAR_9 && VAR_72) &&\n            !(this->m_parseType == VAR_73 && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !VAR_60))\n        {\n            VAR_65 = DoParallelParse(VAR_0);\n#if VAR_74\n            if (VAR_65)\n            {\n                BackgroundParser *VAR_75 = VAR_41->GetBackgroundParser();\n                Assert(VAR_75);\n                if (VAR_75->HasFailedBackgroundParseItem())\n                {\n                    Error(VAR_37);\n                }\n                VAR_65 = VAR_75->ParseBackgroundItem(this, VAR_0, VAR_60);\n                if (VAR_65)\n                {\n                    VAR_66 = true;\n                    this->m_hasParallelJob = true;\n                    this->m_doingFastScan = true;\n                    VAR_65 = FastScanFormalsAndBody();\n                    if (VAR_65)\n                    {\n                        /* COMMENT_26 */\n                        /* COMMENT_27 */\n                        /* COMMENT_28 */\n                        VAR_0->ichLim = VAR_32->IchLimTok();\n                        VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();\n                    }\n                }\n            }\n#endif\n        }\n    }\n\n    if (!VAR_65)\n    {\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        ParseNodePtr VAR_76 = VAR_0;\n        if (VAR_66)\n        {\n            /* COMMENT_31 */\n            /* COMMENT_32 */\n            /* COMMENT_33 */\n            VAR_0 = CreateDummyFuncNode(VAR_18);\n        }\n\n        AnalysisAssert(VAR_0);\n        ParseNodePtr VAR_77 = VAR_35<buildAST>(PnodeBlockType::Parameter, VAR_48);\n        AnalysisAssert(VAR_77 != nullptr);\n        VAR_0->sxFnc.pnodeScopes = VAR_77;\n        VAR_78 = &VAR_0->sxFnc.pnodeParams;\n\n        ParseNodePtr *VAR_79 = nullptr;\n        ParseNodePtr *VAR_80 = nullptr;\n\n        VAR_79 = VAR_81;\n        if (VAR_77)\n        {\n            /* COMMENT_34 */\n            VAR_81 = &VAR_77->sxBlock.pnodeScopes;\n            VAR_77->sxBlock.pnodeStmt = VAR_0;\n        }\n\n        /* COMMENT_35 */\n        /* COMMENT_36 */\n        VAR_80 = VAR_57;\n        VAR_57 = nullptr;\n\n        if (!VAR_7)\n        {\n            bool VAR_82 = VAR_83;\n            if (VAR_20)\n            {\n                VAR_83 = true;\n            }\n            this->ParseFncFormals<buildAST>(VAR_0, VAR_8, VAR_2);\n            VAR_83 = VAR_82;\n        }\n\n        /* COMMENT_37 */\n        ParseNodePtr VAR_84 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_85);\n        /* COMMENT_38 */\n        /* COMMENT_39 */\n        /* COMMENT_40 */\n        /* COMMENT_41 */\n        *VAR_81 = VAR_84;\n        VAR_0->sxFnc.pnodeBodyScope = VAR_84;\n\n        /* COMMENT_34 */\n        VAR_81 = &VAR_84->sxBlock.pnodeScopes;\n        VAR_84->sxBlock.pnodeStmt = VAR_0;\n\n        /* COMMENT_42 */\n        /* COMMENT_43 */\n\n        /* COMMENT_44 */\n        /* COMMENT_45 */\n        /* COMMENT_46 */\n        /* COMMENT_47 */\n        /* COMMENT_48 */\n        /* COMMENT_49 */\n        /* COMMENT_50 */\n        /* COMMENT_51 */\n        /* COMMENT_52 */\n        /* COMMENT_53 */\n\n        /* COMMENT_54 */\n        /* COMMENT_55 */\n        bool VAR_86 = false;\n\n        if (VAR_60 &&\n            !(this->m_grfscr & VAR_87) &&\n            VAR_0->sxFnc.IsNested() &&\n#ifndef VAR_88\n            VAR_71->sourceDynamicProfileManager == nullptr &&\n#endif\n            PHASE_ON_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) &&\n            (\n                !PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) ||\n                PHASE_FORCE_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId)\n            ))\n        {\n            /* COMMENT_56 */\n            /* COMMENT_57 */\n            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(VAR_89)))\n            {\n                VAR_60 = false;\n            }\n        }\n\n        Scope* VAR_90 = VAR_0->sxFnc.pnodeScopes ? VAR_0->sxFnc.pnodeScopes->sxBlock.scope : nullptr;\n        if (VAR_90 != nullptr)\n        {\n            if (CONFIG_FLAG(VAR_91))\n            {\n                VAR_90->SetCannotMergeWithBodyScope();\n            }\n            else if (VAR_0->sxFnc.HasNonSimpleParameterList())\n            {\n                if (VAR_90->GetCanMergeWithBodyScope())\n                {\n                    VAR_90->ForEachSymbolUntil([this, VAR_90, VAR_0](Symbol* VAR_92) {\n                        if (VAR_92->GetPid()->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)\n                        {\n                            /* COMMENT_58 */\n                            VAR_90->SetCannotMergeWithBodyScope();\n                            return true;\n                        }\n                        return false;\n                    });\n\n                    if (VAR_93.arguments->GetTopRef() && VAR_93.arguments->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)\n                    {\n                        Assert(VAR_0->sxFnc.UsesArguments());\n                        /* COMMENT_59 */\n                        VAR_90->SetCannotMergeWithBodyScope();\n                    }\n                }\n                if (VAR_90->GetCanMergeWithBodyScope() && !VAR_18 && VAR_0->sxFnc.pnodeName != nullptr)\n                {\n                    Symbol* VAR_94 = VAR_0->sxFnc.pnodeName->sxVar.sym;\n                    if (VAR_94->GetPid()->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)\n                    {\n                        /* COMMENT_60 */\n                        /* COMMENT_61 */\n                        /* COMMENT_62 */\n                        /* COMMENT_63 */\n                        VAR_90->SetCannotMergeWithBodyScope();\n                    }\n                }\n\n            }\n        }\n\n        if (!VAR_20 && VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope()\n            && (VAR_0->sxFnc.UsesArguments() || VAR_0->grfpn & VAR_95))\n        {\n            Error(VAR_96);\n        }\n\n        /* COMMENT_64 */\n        /* COMMENT_65 */\n        /* COMMENT_66 */\n        if (VAR_90 != nullptr && VAR_90->GetCanMergeWithBodyScope())\n        {\n            VAR_90->ForEachSymbol([this](Symbol* VAR_97)\n            {\n                PidRefStack* VAR_98 = PushPidRef(VAR_97->GetPid());\n                VAR_98->SetSym(VAR_97);\n            });\n        }\n\n        if (VAR_60 || (VAR_70 && VAR_99))\n        {\n            AssertMsg(!VAR_20, \"Deferring function parsing of a function does not handle lambda syntax\");\n            VAR_26 = true;\n\n            this->ParseTopLevelDeferredFunc(VAR_0, VAR_9, VAR_1);\n        }\n        else\n        {\n            if (VAR_100.tk == VAR_101) /* COMMENT_67 */\n            {\n                VAR_32->Scan();\n            }\n\n            if (VAR_20)\n            {\n                BOOL VAR_102 = VAR_32->FHadNewLine();\n\n                /* COMMENT_68 */\n                /* COMMENT_69 */\n                /* COMMENT_70 */\n                /* COMMENT_71 */\n                /* COMMENT_72 */\n                ChkCurTok(VAR_103, VAR_104);\n\n                /* COMMENT_73 */\n                /* COMMENT_74 */\n                if (VAR_102)\n                {\n                    Error(VAR_37);\n                }\n            }\n\n            AnalysisAssert(VAR_0);\n\n            /* COMMENT_75 */\n            Assert(*VAR_78 == nullptr);\n\n            /* COMMENT_76 */\n            VAR_0->sxFnc.pnodeVars = nullptr;\n            VAR_78 = &VAR_0->sxFnc.pnodeVars;\n\n            if (VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope())\n            {\n                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), VAR_0->sxFnc.pnodeName ? VAR_0->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));\n                /* COMMENT_77 */\n                /* COMMENT_78 */\n                /* COMMENT_79 */\n                /* COMMENT_80 */\n                /* COMMENT_81 */\n                /* COMMENT_82 */\n                VAR_90->ForEachSymbol([this, VAR_0](Symbol* VAR_105) {\n                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"Creating a duplicate symbol for the parameter %s in the body scope\\n\"), VAR_105->GetPid()->Psz());\n\n                    ParseNodePtr VAR_106 = nullptr;\n                    if (this->m_ppnodeVar != &VAR_0->sxFnc.pnodeVars)\n                    {\n                        ParseNodePtr *const VAR_107 = VAR_78;\n                        VAR_78 = &VAR_0->sxFnc.pnodeVars;\n                        VAR_106 = this->CreateVarDeclNode(VAR_105->GetPid(), VAR_108, false, nullptr, false);\n                        VAR_78 = VAR_107;\n                    }\n                    else\n                    {\n                        VAR_106 = this->CreateVarDeclNode(VAR_105->GetPid(), VAR_108, false, nullptr, false);\n                    }\n\n                    Assert(VAR_106 && VAR_106->sxVar.sym->GetScope()->GetScopeType() == VAR_85);\n                    VAR_106->sxVar.sym->SetHasInit(true);\n                });\n\n                if (!VAR_20)\n                {\n                    /* COMMENT_83 */\n                    /* COMMENT_84 */\n                    /* COMMENT_85 */\n                    ParseNodePtr VAR_109 = this->CreateVarDeclNode(VAR_93.arguments, VAR_108, true, nullptr, false);\n                    Assert(VAR_109 && VAR_109->sxVar.sym->GetScope()->GetScopeType() == VAR_85);\n                }\n            }\n\n            /* COMMENT_35 */\n            /* COMMENT_36 */\n            VAR_57 = nullptr;\n\n            if (buildAST)\n            {\n                DeferredFunctionStub *VAR_110 = VAR_72;\n                if (VAR_47)\n                {\n                    /* COMMENT_86 */\n                    VAR_72 = nullptr;\n                }\n                else if (VAR_9 && VAR_72)\n                {\n                    /* COMMENT_87 */\n                    /* COMMENT_88 */\n                    /* COMMENT_89 */\n                    /* COMMENT_90 */\n                    /* COMMENT_91 */\n\n                    if (VAR_9->sxFnc.nestedCount == 1)\n                    {\n                        VAR_111 = nullptr;\n                    }\n\n                    if (VAR_111 == nullptr)\n                    {\n                        VAR_111 = (VAR_72 + (VAR_9->sxFnc.nestedCount - 1));\n                    }\n\n                    if (VAR_111->ichMin == VAR_0->ichMin)\n                    {\n                        VAR_72 = VAR_111->deferredStubs;\n                        VAR_111 = nullptr;\n                    }\n                    else\n                    {\n                        VAR_72 = nullptr;\n                    }\n                }\n\n                if (VAR_100.tk != VAR_112 && VAR_20)\n                {\n                    VAR_113<true>(VAR_0);\n                    *VAR_6 = false;\n                }\n                else\n                {\n                    this->FinishFncDecl(VAR_0, VAR_1, VAR_28, VAR_7);\n                }\n                VAR_72 = VAR_110;\n            }\n            else\n            {\n                this->ParseNestedDeferredFunc(VAR_0, VAR_20, VAR_6, &VAR_86);\n            }\n        }\n\n        if (VAR_84)\n        {\n            FinishParseBlock(VAR_84, *VAR_6);\n        }\n\n        if (!VAR_24 && (VAR_100.tk == VAR_112 || !VAR_20))\n        {\n            this->AddArgumentsNodeToVars(VAR_0);\n        }\n\n        /* COMMENT_92 */\n\n        Assert(VAR_57 == nullptr || *VAR_57 == nullptr);\n        VAR_57 = VAR_80;\n\n        AssertMem(VAR_81);\n        Assert(nullptr == *VAR_81);\n        VAR_81 = VAR_79;\n\n        if (VAR_77)\n        {\n            FinishParseBlock(VAR_77, *VAR_6);\n        }\n\n        if (IsStrictMode() || VAR_86)\n        {\n            this->m_fUseStrictMode = TRUE; /* COMMENT_93 */\n\n            if (!VAR_51)\n            {\n                /* COMMENT_94 */\n                /* COMMENT_95 */\n                RestorePoint VAR_114;\n                VAR_32->Capture(&VAR_114);\n\n                if (*VAR_3)\n                {\n                    /* COMMENT_96 */\n                    VAR_32->SeekTo(VAR_31);\n                    VAR_32->Scan();\n                    if (VAR_0->sxFnc.IsGenerator())\n                    {\n                        Assert(VAR_100.tk == VAR_115);\n                        Assert(VAR_41->GetConfig()->IsES6GeneratorsEnabled());\n                        Assert(!(VAR_2 & VAR_116));\n                        VAR_32->Scan();\n                    }\n                    if (VAR_100.IsReservedWord())\n                    {\n                        IdentifierExpectedError(VAR_100);\n                    }\n                    CheckStrictModeEvalArgumentsUsage(VAR_100.GetIdentifier(VAR_117));\n                }\n\n                /* COMMENT_97 */\n                /* COMMENT_98 */\n                VAR_32->SeekToForcingPid(VAR_50);\n                CheckStrictFormalParameters();\n                VAR_32->SeekTo(VAR_114);\n            }\n\n            if (buildAST)\n            {\n                if (VAR_0->sxFnc.pnodeName != nullptr && VAR_118 == VAR_0->sxFnc.pnodeName->nop)\n                {\n                    CheckStrictModeEvalArgumentsUsage(VAR_0->sxFnc.pnodeName->sxVar.pid, VAR_0->sxFnc.pnodeName);\n                }\n            }\n\n            this->m_fUseStrictMode = VAR_52;\n            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_119, VAR_41);\n        }\n\n        if (VAR_26)\n        {\n            AnalysisAssert(VAR_0);\n            VAR_0->sxFnc.pnodeVars = nullptr;\n        }\n\n        if (VAR_66)\n        {\n            VAR_0 = VAR_76;\n            VAR_11 = VAR_76;\n\n            /* COMMENT_26 */\n            /* COMMENT_27 */\n            /* COMMENT_28 */\n            VAR_0->ichLim = VAR_32->IchLimTok();\n            VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();\n        }\n    }\n\n    /* COMMENT_99 */\n    AnalysisAssert(VAR_0);\n    if (VAR_0->sxFnc.GetAsmjsMode())\n    {\n        VAR_70 = false;\n    }\n\n    /* COMMENT_100 */\n    Assert(nullptr == VAR_46);\n    SetCurrentStatement(VAR_27);\n\n    if (VAR_33)\n    {\n        FinishParseFncExprScope(VAR_0, VAR_33);\n    }\n    if (!VAR_120)\n    {\n        VAR_55 |= VAR_54;\n    }\n    VAR_121 = VAR_59;\n\n    VAR_32->SetYieldIsKeyword(VAR_38);\n    VAR_32->SetAwaitIsKeyword(VAR_39);\n\n    /* COMMENT_101 */\n    if (buildAST)\n    {\n        Assert(VAR_0 == VAR_11);\n\n        VAR_11 = VAR_9;\n        VAR_17 = VAR_16;\n\n        if (!VAR_20)\n        {\n            Assert(VAR_0 == VAR_14);\n            VAR_14 = VAR_13;\n        }\n    }\n    else\n    {\n        Assert(VAR_0 == VAR_12);\n        if (!VAR_20)\n        {\n            Assert(VAR_0 == VAR_15);\n            VAR_15 = VAR_13;\n        }\n        VAR_12 = VAR_9;\n    }\n\n    if (VAR_11 && VAR_0->sxFnc.HasWithStmt())\n    {\n        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);\n    }\n\n    return true;\n}",
  "func_graph_path": "chakra-core/ChakraCore/9da019424601325a6e95e6be0fa03d7d21d0b517/Parse.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -341,6 +341,19 @@\n                         paramScope->SetCannotMergeWithBodyScope();\n                     }\n                 }\n+                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)\n+                {\n+                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;\n+                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)\n+                    {\n+                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function\n+                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var\n+                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add\n+                        // the name symbol to the param scope by splitting it.\n+                        paramScope->SetCannotMergeWithBodyScope();\n+                    }\n+                }\n+\n             }\n         }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)",
      "                {",
      "                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;",
      "                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)",
      "                    {",
      "                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function",
      "                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var",
      "                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add",
      "                        // the name symbol to the param scope by splitting it.",
      "                        paramScope->SetCannotMergeWithBodyScope();",
      "                    }",
      "                }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/chakra-core/ChakraCore/pull/2697",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/chakra-core/ChakraCore/pull/2697: 403 Client Error: Forbidden for url: https://api.github.com/repos/chakra-core/ChakraCore/pulls/2697",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}