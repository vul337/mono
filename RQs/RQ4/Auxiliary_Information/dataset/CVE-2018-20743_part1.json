{
  "cve_id": "CVE-2018-20743",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "mumble-voip/mumble",
  "commit_msg": "Prevent instability and crash due to message flood\n\nThis patch adds a rate limiting to selected patches. The underlying rate limiter\nused is the Leaky-Bucket algorithm. It allows for a burst of messages, but\nlimits them after a specified amount of messages within a time frame.",
  "commit_hash": "0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "git_url": "https://github.com/mumble-voip/mumble/commit/0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "file_path": "src/murmur/Messages.cpp",
  "func_name": "Server::msgUserState",
  "func_before": "void Server::msgUserState(ServerUser *uSource, MumbleProto::UserState &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tVICTIM_SETUP;\n\n\tChannel *root = qhChannels.value(0);\n\n\t/*\n\t\tFirst check all permissions involved\n\t*/\n\tif ((pDstServerUser->iId == 0) && (uSource->iId != 0)) {\n\t\tPERM_DENIED_TYPE(SuperUser);\n\t\treturn;\n\t}\n\n\tmsg.set_session(pDstServerUser->uiSession);\n\tmsg.set_actor(uSource->uiSession);\n\n\tif (msg.has_name()) {\n\t\tPERM_DENIED_TYPE(UserName);\n\t\treturn;\n\t}\n\n\tif (msg.has_channel_id()) {\n\t\tChannel *c = qhChannels.value(msg.channel_id());\n\t\tif (!c || (c == pDstServerUser->cChannel))\n\t\t\treturn;\n\n\t\tif ((uSource != pDstServerUser) && (! hasPermission(uSource, pDstServerUser->cChannel, ChanACL::Move))) {\n\t\t\tPERM_DENIED(uSource, pDstServerUser->cChannel, ChanACL::Move);\n\t\t\treturn;\n\t\t}\n\n\t\tif (! hasPermission(uSource, c, ChanACL::Move) && ! hasPermission(pDstServerUser, c, ChanACL::Enter)) {\n\t\t\tPERM_DENIED(pDstServerUser, c, ChanACL::Enter);\n\t\t\treturn;\n\t\t}\n\t\tif (isChannelFull(c, uSource)) {\n\t\t\tPERM_DENIED_FALLBACK(ChannelFull, 0x010201, QLatin1String(\"Channel is full\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (msg.has_mute() || msg.has_deaf() || msg.has_suppress() || msg.has_priority_speaker()) {\n\t\tif (pDstServerUser->iId == 0) {\n\t\t\tPERM_DENIED_TYPE(SuperUser);\n\t\t\treturn;\n\t\t}\n\t\tif (uSource->cChannel->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(TemporaryChannel);\n\t\t\treturn;\n\t\t}\n\t\tif (! hasPermission(uSource, pDstServerUser->cChannel, ChanACL::MuteDeafen) || msg.suppress()) {\n\t\t\tPERM_DENIED(uSource, pDstServerUser->cChannel, ChanACL::MuteDeafen);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tQString comment;\n\n\tif (msg.has_comment()) {\n\t\tbool changed = false;\n\t\tcomment = u8(msg.comment());\n\t\tif (uSource != pDstServerUser) {\n\t\t\tif (! hasPermission(uSource, root, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(uSource, root, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (comment.length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! isTextAllowed(comment, changed)) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (changed)\n\t\t\tmsg.set_comment(u8(comment));\n\t}\n\n\tif (msg.has_texture()) {\n\t\tif (iMaxImageMessageLength > 0 && (msg.texture().length() > static_cast<unsigned int>(iMaxImageMessageLength))) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (uSource != pDstServerUser) {\n\t\t\tif (! hasPermission(uSource, root, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(uSource, root, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (msg.texture().length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (msg.has_user_id()) {\n\t\tChanACL::Perm p = (uSource == pDstServerUser) ? ChanACL::SelfRegister : ChanACL::Register;\n\t\tif ((pDstServerUser->iId >= 0) || ! hasPermission(uSource, root, p)) {\n\t\t\tPERM_DENIED(uSource, root, p);\n\t\t\treturn;\n\t\t}\n\t\tif (pDstServerUser->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(pDstServerUser);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Prevent self-targeting state changes from being applied to others\n\tif ((pDstServerUser != uSource) && (msg.has_self_deaf() || msg.has_self_mute() || msg.has_plugin_context() || msg.has_plugin_identity() || msg.has_recording())) {\n\t\treturn;\n\t}\n\n\t/*\n\t\t-------------------- Permission checks done. Now act --------------------\n\t*/\n\tbool bBroadcast = false;\n\n\tif (msg.has_texture()) {\n\t\tQByteArray qba = blob(msg.texture());\n\t\tif (pDstServerUser->iId > 0) {\n\t\t\t// For registered users store the texture we just received in the database\n\t\t\tif (! setTexture(pDstServerUser->iId, qba)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t// For unregistered users or SuperUser only get the hash\n\t\t\thashAssign(pDstServerUser->qbaTexture, pDstServerUser->qbaTextureHash, qba);\n\t\t}\n\n\t\t// The texture will be sent out later in this function\n\t\tbBroadcast = true;\n\t}\n\n\t// Writing to bSelfMute, bSelfDeaf and ssContext\n\t// requires holding a write lock on qrwlVoiceThread.\n\t{\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tif (msg.has_self_deaf()) {\n\t\t\tuSource->bSelfDeaf = msg.self_deaf();\n\t\t\tif (uSource->bSelfDeaf)\n\t\t\t\tmsg.set_self_mute(true);\n\t\t\tbBroadcast = true;\n\t\t}\n\n\t\tif (msg.has_self_mute()) {\n\t\t\tuSource->bSelfMute = msg.self_mute();\n\t\t\tif (! uSource->bSelfMute) {\n\t\t\t\tmsg.set_self_deaf(false);\n\t\t\t\tuSource->bSelfDeaf = false;\n\t\t\t}\n\t\t\tbBroadcast = true;\n\t\t}\n\n\t\tif (msg.has_plugin_context()) {\n\t\t\tuSource->ssContext = msg.plugin_context();\n\n\t\t\t// Make sure to clear this from the packet so we don't broadcast it\n\t\t\tmsg.clear_plugin_context();\n\t\t}\n\t}\n\n\tif (msg.has_plugin_identity()) {\n\t\tuSource->qsIdentity = u8(msg.plugin_identity());\n\t\t// Make sure to clear this from the packet so we don't broadcast it\n\t\tmsg.clear_plugin_identity();\n\t}\n\n\tif (! comment.isNull()) {\n\t\thashAssign(pDstServerUser->qsComment, pDstServerUser->qbaCommentHash, comment);\n\n\t\tif (pDstServerUser->iId >= 0) {\n\t\t\tQMap<int, QString> info;\n\t\t\tinfo.insert(ServerDB::User_Comment, pDstServerUser->qsComment);\n\t\t\tsetInfo(pDstServerUser->iId, info);\n\t\t}\n\t\tbBroadcast = true;\n\t}\n\n\n\n\tif (msg.has_mute() || msg.has_deaf() || msg.has_suppress() || msg.has_priority_speaker()) {\n\t\t// Writing to bDeaf, bMute and bSuppress requires\n\t\t// holding a write lock on qrwlVoiceThread.\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tif (msg.has_deaf()) {\n\t\t\tpDstServerUser->bDeaf = msg.deaf();\n\t\t\tif (pDstServerUser->bDeaf)\n\t\t\t\tmsg.set_mute(true);\n\t\t}\n\t\tif (msg.has_mute()) {\n\t\t\tpDstServerUser->bMute = msg.mute();\n\t\t\tif (! pDstServerUser->bMute) {\n\t\t\t\tmsg.set_deaf(false);\n\t\t\t\tpDstServerUser->bDeaf = false;\n\t\t\t}\n\t\t}\n\t\tif (msg.has_suppress())\n\t\t\tpDstServerUser->bSuppress = msg.suppress();\n\n\t\tif (msg.has_priority_speaker())\n\t\t\tpDstServerUser->bPrioritySpeaker = msg.priority_speaker();\n\n\t\tlog(uSource, QString(\"Changed speak-state of %1 (%2 %3 %4 %5)\").arg(QString(*pDstServerUser),\n\t\t        QString::number(pDstServerUser->bMute),\n\t\t        QString::number(pDstServerUser->bDeaf),\n\t\t        QString::number(pDstServerUser->bSuppress),\n\t\t        QString::number(pDstServerUser->bPrioritySpeaker)));\n\n\t\tbBroadcast = true;\n\t}\n\n\tif (msg.has_recording() && (pDstServerUser->bRecording != msg.recording())) {\n\t\tpDstServerUser->bRecording = msg.recording();\n\n\t\tMumbleProto::TextMessage mptm;\n\t\tmptm.add_tree_id(0);\n\t\tif (pDstServerUser->bRecording)\n\t\t\tmptm.set_message(u8(QString(QLatin1String(\"User '%1' started recording\")).arg(pDstServerUser->qsName)));\n\t\telse\n\t\t\tmptm.set_message(u8(QString(QLatin1String(\"User '%1' stopped recording\")).arg(pDstServerUser->qsName)));\n\n\t\tsendAll(mptm, ~ 0x010203);\n\n\t\tbBroadcast = true;\n\t}\n\n\tif (msg.has_channel_id()) {\n\t\tChannel *c = qhChannels.value(msg.channel_id());\n\n\t\tuserEnterChannel(pDstServerUser, c, msg);\n\t\tlog(uSource, QString(\"Moved %1 to %2\").arg(QString(*pDstServerUser), QString(*c)));\n\t\tbBroadcast = true;\n\t}\n\n\tbool bDstAclChanged = false;\n\tif (msg.has_user_id()) {\n\t\t// Handle user (Self-)Registration\n\t\tQMap<int, QString> info;\n\n\t\tinfo.insert(ServerDB::User_Name, pDstServerUser->qsName);\n\t\tinfo.insert(ServerDB::User_Hash, pDstServerUser->qsHash);\n\t\tif (! pDstServerUser->qslEmail.isEmpty())\n\t\t\tinfo.insert(ServerDB::User_Email, pDstServerUser->qslEmail.first());\n\t\tint id = registerUser(info);\n\t\tif (id > 0) {\n\t\t\tpDstServerUser->iId = id;\n\t\t\tsetLastChannel(pDstServerUser);\n\t\t\tmsg.set_user_id(id);\n\t\t\tbDstAclChanged = true;\n\t\t} else {\n\t\t\t// Registration failed\n\t\t\tmsg.clear_user_id();\n\t\t}\n\t\tbBroadcast = true;\n\t}\n\n\tif (bBroadcast) {\n\t\t// Texture handling for clients < 1.2.2.\n\t\t// Send the texture data in the message.\n\t\tif (msg.has_texture() && (pDstServerUser->qbaTexture.length() >= 4) && (qFromBigEndian<unsigned int>(reinterpret_cast<const unsigned char *>(pDstServerUser->qbaTexture.constData())) != 600 * 60 * 4)) {\n\t\t\t// This is a new style texture, don't send it because the client doesn't handle it correctly / crashes.\n\t\t\tmsg.clear_texture();\n\t\t\tsendAll(msg, ~ 0x010202);\n\t\t\tmsg.set_texture(blob(pDstServerUser->qbaTexture));\n\t\t} else {\n\t\t\t// This is an old style texture, empty texture or there was no texture in this packet,\n\t\t\t// send the message unchanged.\n\t\t\tsendAll(msg, ~ 0x010202);\n\t\t}\n\n\t\t// Texture / comment handling for clients >= 1.2.2.\n\t\t// Send only a hash of the texture / comment text. The client will request the actual data if necessary.\n\t\tif (msg.has_texture() && ! pDstServerUser->qbaTextureHash.isEmpty()) {\n\t\t\tmsg.clear_texture();\n\t\t\tmsg.set_texture_hash(blob(pDstServerUser->qbaTextureHash));\n\t\t}\n\t\tif (msg.has_comment() && ! pDstServerUser->qbaCommentHash.isEmpty()) {\n\t\t\tmsg.clear_comment();\n\t\t\tmsg.set_comment_hash(blob(pDstServerUser->qbaCommentHash));\n\t\t}\n\n\t\tsendAll(msg, 0x010202);\n\n\t\tif (bDstAclChanged)\n\t\t\tclearACLCache(pDstServerUser);\n\t}\n\n\temit userStateChanged(pDstServerUser);\n}",
  "abstract_func_before": "void Server::msgUserState(ServerUser *VAR_0, MumbleProto::UserState &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tVAR_2;\n\n\tChannel *VAR_3 = VAR_4.value(0);\n\n\t/* COMMENT_0 */\n                                      \n   \n\tif ((VAR_5->iId == 0) && (VAR_0->iId != 0)) {\n\t\tPERM_DENIED_TYPE(VAR_6);\n\t\treturn;\n\t}\n\n\tVAR_1.set_session(VAR_5->uiSession);\n\tVAR_1.set_actor(VAR_0->uiSession);\n\n\tif (VAR_1.has_name()) {\n\t\tPERM_DENIED_TYPE(VAR_7);\n\t\treturn;\n\t}\n\n\tif (VAR_1.has_channel_id()) {\n\t\tChannel *VAR_8 = VAR_4.value(VAR_1.channel_id());\n\t\tif (!VAR_8 || (VAR_8 == VAR_5->cChannel))\n\t\t\treturn;\n\n\t\tif ((VAR_0 != VAR_5) && (! hasPermission(VAR_0, VAR_5->cChannel, ChanACL::Move))) {\n\t\t\tPERM_DENIED(VAR_0, VAR_5->cChannel, ChanACL::Move);\n\t\t\treturn;\n\t\t}\n\n\t\tif (! hasPermission(VAR_0, VAR_8, ChanACL::Move) && ! hasPermission(VAR_5, VAR_8, ChanACL::Enter)) {\n\t\t\tPERM_DENIED(VAR_5, VAR_8, ChanACL::Enter);\n\t\t\treturn;\n\t\t}\n\t\tif (isChannelFull(VAR_8, VAR_0)) {\n\t\t\tPERM_DENIED_FALLBACK(VAR_9, 0x010201, QLatin1String(\"Channel is full\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (VAR_1.has_mute() || VAR_1.has_deaf() || VAR_1.has_suppress() || VAR_1.has_priority_speaker()) {\n\t\tif (VAR_5->iId == 0) {\n\t\t\tPERM_DENIED_TYPE(VAR_6);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_0->cChannel->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(VAR_10);\n\t\t\treturn;\n\t\t}\n\t\tif (! hasPermission(VAR_0, VAR_5->cChannel, ChanACL::MuteDeafen) || VAR_1.suppress()) {\n\t\t\tPERM_DENIED(VAR_0, VAR_5->cChannel, ChanACL::MuteDeafen);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tQString VAR_11;\n\n\tif (VAR_1.has_comment()) {\n\t\tbool VAR_12 = false;\n\t\tVAR_11 = u8(VAR_1.comment());\n\t\tif (VAR_0 != VAR_5) {\n\t\t\tif (! hasPermission(VAR_0, VAR_3, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(VAR_0, VAR_3, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (VAR_11.length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! isTextAllowed(VAR_11, VAR_12)) {\n\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_12)\n\t\t\tVAR_1.set_comment(u8(VAR_11));\n\t}\n\n\tif (VAR_1.has_texture()) {\n\t\tif (VAR_14 > 0 && (VAR_1.texture().length() > VAR_15<unsigned int>(VAR_14))) {\n\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_0 != VAR_5) {\n\t\t\tif (! hasPermission(VAR_0, VAR_3, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(VAR_0, VAR_3, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (VAR_1.texture().length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (VAR_1.has_user_id()) {\n\t\tChanACL::Perm VAR_16 = (VAR_0 == VAR_5) ? ChanACL::SelfRegister : ChanACL::Register;\n\t\tif ((VAR_5->iId >= 0) || ! hasPermission(VAR_0, VAR_3, VAR_16)) {\n\t\t\tPERM_DENIED(VAR_0, VAR_3, VAR_16);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_5->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(VAR_5);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* COMMENT_3 */\n\tif ((VAR_5 != VAR_0) && (VAR_1.has_self_deaf() || VAR_1.has_self_mute() || VAR_1.has_plugin_context() || VAR_1.has_plugin_identity() || VAR_1.has_recording())) {\n\t\treturn;\n\t}\n\n\t/* COMMENT_4 */\n                                                                           \n   \n\tbool VAR_17 = false;\n\n\tif (VAR_1.has_texture()) {\n\t\tQByteArray VAR_18 = blob(VAR_1.texture());\n\t\tif (VAR_5->iId > 0) {\n\t\t\t/* COMMENT_7 */\n\t\t\tif (! setTexture(VAR_5->iId, VAR_18)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t/* COMMENT_8 */\n\t\t\thashAssign(VAR_5->qbaTexture, VAR_5->qbaTextureHash, VAR_18);\n\t\t}\n\n\t\t/* COMMENT_9 */\n\t\tVAR_17 = true;\n\t}\n\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\t{\n\t\tQWriteLocker VAR_19(&VAR_20);\n\n\t\tif (VAR_1.has_self_deaf()) {\n\t\t\tVAR_0->bSelfDeaf = VAR_1.self_deaf();\n\t\t\tif (VAR_0->bSelfDeaf)\n\t\t\t\tVAR_1.set_self_mute(true);\n\t\t\tVAR_17 = true;\n\t\t}\n\n\t\tif (VAR_1.has_self_mute()) {\n\t\t\tVAR_0->bSelfMute = VAR_1.self_mute();\n\t\t\tif (! VAR_0->bSelfMute) {\n\t\t\t\tVAR_1.set_self_deaf(false);\n\t\t\t\tVAR_0->bSelfDeaf = false;\n\t\t\t}\n\t\t\tVAR_17 = true;\n\t\t}\n\n\t\tif (VAR_1.has_plugin_context()) {\n\t\t\tVAR_0->ssContext = VAR_1.plugin_context();\n\n\t\t\t/* COMMENT_12 */\n\t\t\tVAR_1.clear_plugin_context();\n\t\t}\n\t}\n\n\tif (VAR_1.has_plugin_identity()) {\n\t\tVAR_0->qsIdentity = u8(VAR_1.plugin_identity());\n\t\t/* COMMENT_12 */\n\t\tVAR_1.clear_plugin_identity();\n\t}\n\n\tif (! VAR_11.isNull()) {\n\t\thashAssign(VAR_5->qsComment, VAR_5->qbaCommentHash, VAR_11);\n\n\t\tif (VAR_5->iId >= 0) {\n\t\t\tQMap<int, QString> VAR_21;\n\t\t\tVAR_21.insert(ServerDB::User_Comment, VAR_5->qsComment);\n\t\t\tsetInfo(VAR_5->iId, VAR_21);\n\t\t}\n\t\tVAR_17 = true;\n\t}\n\n\n\n\tif (VAR_1.has_mute() || VAR_1.has_deaf() || VAR_1.has_suppress() || VAR_1.has_priority_speaker()) {\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\tQWriteLocker VAR_19(&VAR_20);\n\n\t\tif (VAR_1.has_deaf()) {\n\t\t\tVAR_5->bDeaf = VAR_1.deaf();\n\t\t\tif (VAR_5->bDeaf)\n\t\t\t\tVAR_1.set_mute(true);\n\t\t}\n\t\tif (VAR_1.has_mute()) {\n\t\t\tVAR_5->bMute = VAR_1.mute();\n\t\t\tif (! VAR_5->bMute) {\n\t\t\t\tVAR_1.set_deaf(false);\n\t\t\t\tVAR_5->bDeaf = false;\n\t\t\t}\n\t\t}\n\t\tif (VAR_1.has_suppress())\n\t\t\tVAR_5->bSuppress = VAR_1.suppress();\n\n\t\tif (VAR_1.has_priority_speaker())\n\t\t\tVAR_5->bPrioritySpeaker = VAR_1.priority_speaker();\n\n\t\tlog(VAR_0, QString(\"Changed speak-state of %1 (%2 %3 %4 %5)\").arg(QString(*VAR_5),\n\t\t        QString::number(VAR_5->bMute),\n\t\t        QString::number(VAR_5->bDeaf),\n\t\t        QString::number(VAR_5->bSuppress),\n\t\t        QString::number(VAR_5->bPrioritySpeaker)));\n\n\t\tVAR_17 = true;\n\t}\n\n\tif (VAR_1.has_recording() && (VAR_5->bRecording != VAR_1.recording())) {\n\t\tVAR_5->bRecording = VAR_1.recording();\n\n\t\tMumbleProto::TextMessage VAR_22;\n\t\tVAR_22.add_tree_id(0);\n\t\tif (VAR_5->bRecording)\n\t\t\tVAR_22.set_message(u8(QString(QLatin1String(\"User '%1' started recording\")).arg(VAR_5->qsName)));\n\t\telse\n\t\t\tVAR_22.set_message(u8(QString(QLatin1String(\"User '%1' stopped recording\")).arg(VAR_5->qsName)));\n\n\t\tsendAll(VAR_22, ~ 0x010203);\n\n\t\tVAR_17 = true;\n\t}\n\n\tif (VAR_1.has_channel_id()) {\n\t\tChannel *VAR_8 = VAR_4.value(VAR_1.channel_id());\n\n\t\tuserEnterChannel(VAR_5, VAR_8, VAR_1);\n\t\tlog(VAR_0, QString(\"Moved %1 to %2\").arg(QString(*VAR_5), QString(*VAR_8)));\n\t\tVAR_17 = true;\n\t}\n\n\tbool VAR_23 = false;\n\tif (VAR_1.has_user_id()) {\n\t\t/* COMMENT_15 */\n\t\tQMap<int, QString> VAR_21;\n\n\t\tVAR_21.insert(ServerDB::User_Name, VAR_5->qsName);\n\t\tVAR_21.insert(ServerDB::User_Hash, VAR_5->qsHash);\n\t\tif (! VAR_5->qslEmail.isEmpty())\n\t\t\tVAR_21.insert(ServerDB::User_Email, VAR_5->qslEmail.first());\n\t\tint VAR_24 = registerUser(VAR_21);\n\t\tif (VAR_24 > 0) {\n\t\t\tVAR_5->iId = VAR_24;\n\t\t\tsetLastChannel(VAR_5);\n\t\t\tVAR_1.set_user_id(VAR_24);\n\t\t\tVAR_23 = true;\n\t\t} else {\n\t\t\t/* COMMENT_16 */\n\t\t\tVAR_1.clear_user_id();\n\t\t}\n\t\tVAR_17 = true;\n\t}\n\n\tif (VAR_17) {\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\tif (VAR_1.has_texture() && (VAR_5->qbaTexture.length() >= 4) && (VAR_25<unsigned int>(VAR_26<const unsigned char *>(VAR_5->qbaTexture.constData())) != 600 * 60 * 4)) {\n\t\t\t/* COMMENT_19 */\n\t\t\tVAR_1.clear_texture();\n\t\t\tsendAll(VAR_1, ~ 0x010202);\n\t\t\tVAR_1.set_texture(blob(VAR_5->qbaTexture));\n\t\t} else {\n\t\t\t/* COMMENT_20 */\n\t\t\t/* COMMENT_21 */\n\t\t\tsendAll(VAR_1, ~ 0x010202);\n\t\t}\n\n\t\t/* COMMENT_22 */\n\t\t/* COMMENT_23 */\n\t\tif (VAR_1.has_texture() && ! VAR_5->qbaTextureHash.isEmpty()) {\n\t\t\tVAR_1.clear_texture();\n\t\t\tVAR_1.set_texture_hash(blob(VAR_5->qbaTextureHash));\n\t\t}\n\t\tif (VAR_1.has_comment() && ! VAR_5->qbaCommentHash.isEmpty()) {\n\t\t\tVAR_1.clear_comment();\n\t\t\tVAR_1.set_comment_hash(blob(VAR_5->qbaCommentHash));\n\t\t}\n\n\t\tsendAll(VAR_1, 0x010202);\n\n\t\tif (VAR_23)\n\t\t\tclearACLCache(VAR_5);\n\t}\n\n\temit userStateChanged(pDstServerUser);\n}",
  "func_graph_path_before": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/before/0.json",
  "func": "void Server::msgUserState(ServerUser *uSource, MumbleProto::UserState &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tVICTIM_SETUP;\n\n\tChannel *root = qhChannels.value(0);\n\n\t/*\n\t\tFirst check all permissions involved\n\t*/\n\tif ((pDstServerUser->iId == 0) && (uSource->iId != 0)) {\n\t\tPERM_DENIED_TYPE(SuperUser);\n\t\treturn;\n\t}\n\n\tmsg.set_session(pDstServerUser->uiSession);\n\tmsg.set_actor(uSource->uiSession);\n\n\tif (msg.has_name()) {\n\t\tPERM_DENIED_TYPE(UserName);\n\t\treturn;\n\t}\n\n\tif (uSource == pDstServerUser) {\n\t\tRATELIMIT(uSource);\n\t}\n\n\tif (msg.has_channel_id()) {\n\t\tChannel *c = qhChannels.value(msg.channel_id());\n\t\tif (!c || (c == pDstServerUser->cChannel))\n\t\t\treturn;\n\n\t\tif ((uSource != pDstServerUser) && (! hasPermission(uSource, pDstServerUser->cChannel, ChanACL::Move))) {\n\t\t\tPERM_DENIED(uSource, pDstServerUser->cChannel, ChanACL::Move);\n\t\t\treturn;\n\t\t}\n\n\t\tif (! hasPermission(uSource, c, ChanACL::Move) && ! hasPermission(pDstServerUser, c, ChanACL::Enter)) {\n\t\t\tPERM_DENIED(pDstServerUser, c, ChanACL::Enter);\n\t\t\treturn;\n\t\t}\n\t\tif (isChannelFull(c, uSource)) {\n\t\t\tPERM_DENIED_FALLBACK(ChannelFull, 0x010201, QLatin1String(\"Channel is full\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (msg.has_mute() || msg.has_deaf() || msg.has_suppress() || msg.has_priority_speaker()) {\n\t\tif (pDstServerUser->iId == 0) {\n\t\t\tPERM_DENIED_TYPE(SuperUser);\n\t\t\treturn;\n\t\t}\n\t\tif (uSource->cChannel->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(TemporaryChannel);\n\t\t\treturn;\n\t\t}\n\t\tif (! hasPermission(uSource, pDstServerUser->cChannel, ChanACL::MuteDeafen) || msg.suppress()) {\n\t\t\tPERM_DENIED(uSource, pDstServerUser->cChannel, ChanACL::MuteDeafen);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tQString comment;\n\n\tif (msg.has_comment()) {\n\t\tbool changed = false;\n\t\tcomment = u8(msg.comment());\n\t\tif (uSource != pDstServerUser) {\n\t\t\tif (! hasPermission(uSource, root, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(uSource, root, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (comment.length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! isTextAllowed(comment, changed)) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (changed)\n\t\t\tmsg.set_comment(u8(comment));\n\t}\n\n\tif (msg.has_texture()) {\n\t\tif (iMaxImageMessageLength > 0 && (msg.texture().length() > static_cast<unsigned int>(iMaxImageMessageLength))) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (uSource != pDstServerUser) {\n\t\t\tif (! hasPermission(uSource, root, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(uSource, root, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (msg.texture().length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (msg.has_user_id()) {\n\t\tChanACL::Perm p = (uSource == pDstServerUser) ? ChanACL::SelfRegister : ChanACL::Register;\n\t\tif ((pDstServerUser->iId >= 0) || ! hasPermission(uSource, root, p)) {\n\t\t\tPERM_DENIED(uSource, root, p);\n\t\t\treturn;\n\t\t}\n\t\tif (pDstServerUser->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(pDstServerUser);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Prevent self-targeting state changes from being applied to others\n\tif ((pDstServerUser != uSource) && (msg.has_self_deaf() || msg.has_self_mute() || msg.has_plugin_context() || msg.has_plugin_identity() || msg.has_recording())) {\n\t\treturn;\n\t}\n\n\t/*\n\t\t-------------------- Permission checks done. Now act --------------------\n\t*/\n\tbool bBroadcast = false;\n\n\tif (msg.has_texture()) {\n\t\tQByteArray qba = blob(msg.texture());\n\t\tif (pDstServerUser->iId > 0) {\n\t\t\t// For registered users store the texture we just received in the database\n\t\t\tif (! setTexture(pDstServerUser->iId, qba)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t// For unregistered users or SuperUser only get the hash\n\t\t\thashAssign(pDstServerUser->qbaTexture, pDstServerUser->qbaTextureHash, qba);\n\t\t}\n\n\t\t// The texture will be sent out later in this function\n\t\tbBroadcast = true;\n\t}\n\n\t// Writing to bSelfMute, bSelfDeaf and ssContext\n\t// requires holding a write lock on qrwlVoiceThread.\n\t{\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tif (msg.has_self_deaf()) {\n\t\t\tuSource->bSelfDeaf = msg.self_deaf();\n\t\t\tif (uSource->bSelfDeaf)\n\t\t\t\tmsg.set_self_mute(true);\n\t\t\tbBroadcast = true;\n\t\t}\n\n\t\tif (msg.has_self_mute()) {\n\t\t\tuSource->bSelfMute = msg.self_mute();\n\t\t\tif (! uSource->bSelfMute) {\n\t\t\t\tmsg.set_self_deaf(false);\n\t\t\t\tuSource->bSelfDeaf = false;\n\t\t\t}\n\t\t\tbBroadcast = true;\n\t\t}\n\n\t\tif (msg.has_plugin_context()) {\n\t\t\tuSource->ssContext = msg.plugin_context();\n\n\t\t\t// Make sure to clear this from the packet so we don't broadcast it\n\t\t\tmsg.clear_plugin_context();\n\t\t}\n\t}\n\n\tif (msg.has_plugin_identity()) {\n\t\tuSource->qsIdentity = u8(msg.plugin_identity());\n\t\t// Make sure to clear this from the packet so we don't broadcast it\n\t\tmsg.clear_plugin_identity();\n\t}\n\n\tif (! comment.isNull()) {\n\t\thashAssign(pDstServerUser->qsComment, pDstServerUser->qbaCommentHash, comment);\n\n\t\tif (pDstServerUser->iId >= 0) {\n\t\t\tQMap<int, QString> info;\n\t\t\tinfo.insert(ServerDB::User_Comment, pDstServerUser->qsComment);\n\t\t\tsetInfo(pDstServerUser->iId, info);\n\t\t}\n\t\tbBroadcast = true;\n\t}\n\n\n\n\tif (msg.has_mute() || msg.has_deaf() || msg.has_suppress() || msg.has_priority_speaker()) {\n\t\t// Writing to bDeaf, bMute and bSuppress requires\n\t\t// holding a write lock on qrwlVoiceThread.\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tif (msg.has_deaf()) {\n\t\t\tpDstServerUser->bDeaf = msg.deaf();\n\t\t\tif (pDstServerUser->bDeaf)\n\t\t\t\tmsg.set_mute(true);\n\t\t}\n\t\tif (msg.has_mute()) {\n\t\t\tpDstServerUser->bMute = msg.mute();\n\t\t\tif (! pDstServerUser->bMute) {\n\t\t\t\tmsg.set_deaf(false);\n\t\t\t\tpDstServerUser->bDeaf = false;\n\t\t\t}\n\t\t}\n\t\tif (msg.has_suppress())\n\t\t\tpDstServerUser->bSuppress = msg.suppress();\n\n\t\tif (msg.has_priority_speaker())\n\t\t\tpDstServerUser->bPrioritySpeaker = msg.priority_speaker();\n\n\t\tlog(uSource, QString(\"Changed speak-state of %1 (%2 %3 %4 %5)\").arg(QString(*pDstServerUser),\n\t\t        QString::number(pDstServerUser->bMute),\n\t\t        QString::number(pDstServerUser->bDeaf),\n\t\t        QString::number(pDstServerUser->bSuppress),\n\t\t        QString::number(pDstServerUser->bPrioritySpeaker)));\n\n\t\tbBroadcast = true;\n\t}\n\n\tif (msg.has_recording() && (pDstServerUser->bRecording != msg.recording())) {\n\t\tpDstServerUser->bRecording = msg.recording();\n\n\t\tMumbleProto::TextMessage mptm;\n\t\tmptm.add_tree_id(0);\n\t\tif (pDstServerUser->bRecording)\n\t\t\tmptm.set_message(u8(QString(QLatin1String(\"User '%1' started recording\")).arg(pDstServerUser->qsName)));\n\t\telse\n\t\t\tmptm.set_message(u8(QString(QLatin1String(\"User '%1' stopped recording\")).arg(pDstServerUser->qsName)));\n\n\t\tsendAll(mptm, ~ 0x010203);\n\n\t\tbBroadcast = true;\n\t}\n\n\tif (msg.has_channel_id()) {\n\t\tChannel *c = qhChannels.value(msg.channel_id());\n\n\t\tuserEnterChannel(pDstServerUser, c, msg);\n\t\tlog(uSource, QString(\"Moved %1 to %2\").arg(QString(*pDstServerUser), QString(*c)));\n\t\tbBroadcast = true;\n\t}\n\n\tbool bDstAclChanged = false;\n\tif (msg.has_user_id()) {\n\t\t// Handle user (Self-)Registration\n\t\tQMap<int, QString> info;\n\n\t\tinfo.insert(ServerDB::User_Name, pDstServerUser->qsName);\n\t\tinfo.insert(ServerDB::User_Hash, pDstServerUser->qsHash);\n\t\tif (! pDstServerUser->qslEmail.isEmpty())\n\t\t\tinfo.insert(ServerDB::User_Email, pDstServerUser->qslEmail.first());\n\t\tint id = registerUser(info);\n\t\tif (id > 0) {\n\t\t\tpDstServerUser->iId = id;\n\t\t\tsetLastChannel(pDstServerUser);\n\t\t\tmsg.set_user_id(id);\n\t\t\tbDstAclChanged = true;\n\t\t} else {\n\t\t\t// Registration failed\n\t\t\tmsg.clear_user_id();\n\t\t}\n\t\tbBroadcast = true;\n\t}\n\n\tif (bBroadcast) {\n\t\t// Texture handling for clients < 1.2.2.\n\t\t// Send the texture data in the message.\n\t\tif (msg.has_texture() && (pDstServerUser->qbaTexture.length() >= 4) && (qFromBigEndian<unsigned int>(reinterpret_cast<const unsigned char *>(pDstServerUser->qbaTexture.constData())) != 600 * 60 * 4)) {\n\t\t\t// This is a new style texture, don't send it because the client doesn't handle it correctly / crashes.\n\t\t\tmsg.clear_texture();\n\t\t\tsendAll(msg, ~ 0x010202);\n\t\t\tmsg.set_texture(blob(pDstServerUser->qbaTexture));\n\t\t} else {\n\t\t\t// This is an old style texture, empty texture or there was no texture in this packet,\n\t\t\t// send the message unchanged.\n\t\t\tsendAll(msg, ~ 0x010202);\n\t\t}\n\n\t\t// Texture / comment handling for clients >= 1.2.2.\n\t\t// Send only a hash of the texture / comment text. The client will request the actual data if necessary.\n\t\tif (msg.has_texture() && ! pDstServerUser->qbaTextureHash.isEmpty()) {\n\t\t\tmsg.clear_texture();\n\t\t\tmsg.set_texture_hash(blob(pDstServerUser->qbaTextureHash));\n\t\t}\n\t\tif (msg.has_comment() && ! pDstServerUser->qbaCommentHash.isEmpty()) {\n\t\t\tmsg.clear_comment();\n\t\t\tmsg.set_comment_hash(blob(pDstServerUser->qbaCommentHash));\n\t\t}\n\n\t\tsendAll(msg, 0x010202);\n\n\t\tif (bDstAclChanged)\n\t\t\tclearACLCache(pDstServerUser);\n\t}\n\n\temit userStateChanged(pDstServerUser);\n}",
  "abstract_func": "void Server::msgUserState(ServerUser *VAR_0, MumbleProto::UserState &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tVAR_2;\n\n\tChannel *VAR_3 = VAR_4.value(0);\n\n\t/* COMMENT_0 */\n                                      \n   \n\tif ((VAR_5->iId == 0) && (VAR_0->iId != 0)) {\n\t\tPERM_DENIED_TYPE(VAR_6);\n\t\treturn;\n\t}\n\n\tVAR_1.set_session(VAR_5->uiSession);\n\tVAR_1.set_actor(VAR_0->uiSession);\n\n\tif (VAR_1.has_name()) {\n\t\tPERM_DENIED_TYPE(VAR_7);\n\t\treturn;\n\t}\n\n\tif (VAR_0 == VAR_5) {\n\t\tRATELIMIT(VAR_0);\n\t}\n\n\tif (VAR_1.has_channel_id()) {\n\t\tChannel *VAR_8 = VAR_4.value(VAR_1.channel_id());\n\t\tif (!VAR_8 || (VAR_8 == VAR_5->cChannel))\n\t\t\treturn;\n\n\t\tif ((VAR_0 != VAR_5) && (! hasPermission(VAR_0, VAR_5->cChannel, ChanACL::Move))) {\n\t\t\tPERM_DENIED(VAR_0, VAR_5->cChannel, ChanACL::Move);\n\t\t\treturn;\n\t\t}\n\n\t\tif (! hasPermission(VAR_0, VAR_8, ChanACL::Move) && ! hasPermission(VAR_5, VAR_8, ChanACL::Enter)) {\n\t\t\tPERM_DENIED(VAR_5, VAR_8, ChanACL::Enter);\n\t\t\treturn;\n\t\t}\n\t\tif (isChannelFull(VAR_8, VAR_0)) {\n\t\t\tPERM_DENIED_FALLBACK(VAR_9, 0x010201, QLatin1String(\"Channel is full\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (VAR_1.has_mute() || VAR_1.has_deaf() || VAR_1.has_suppress() || VAR_1.has_priority_speaker()) {\n\t\tif (VAR_5->iId == 0) {\n\t\t\tPERM_DENIED_TYPE(VAR_6);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_0->cChannel->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(VAR_10);\n\t\t\treturn;\n\t\t}\n\t\tif (! hasPermission(VAR_0, VAR_5->cChannel, ChanACL::MuteDeafen) || VAR_1.suppress()) {\n\t\t\tPERM_DENIED(VAR_0, VAR_5->cChannel, ChanACL::MuteDeafen);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tQString VAR_11;\n\n\tif (VAR_1.has_comment()) {\n\t\tbool VAR_12 = false;\n\t\tVAR_11 = u8(VAR_1.comment());\n\t\tif (VAR_0 != VAR_5) {\n\t\t\tif (! hasPermission(VAR_0, VAR_3, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(VAR_0, VAR_3, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (VAR_11.length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! isTextAllowed(VAR_11, VAR_12)) {\n\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_12)\n\t\t\tVAR_1.set_comment(u8(VAR_11));\n\t}\n\n\tif (VAR_1.has_texture()) {\n\t\tif (VAR_14 > 0 && (VAR_1.texture().length() > VAR_15<unsigned int>(VAR_14))) {\n\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_0 != VAR_5) {\n\t\t\tif (! hasPermission(VAR_0, VAR_3, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(VAR_0, VAR_3, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (VAR_1.texture().length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(VAR_13);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (VAR_1.has_user_id()) {\n\t\tChanACL::Perm VAR_16 = (VAR_0 == VAR_5) ? ChanACL::SelfRegister : ChanACL::Register;\n\t\tif ((VAR_5->iId >= 0) || ! hasPermission(VAR_0, VAR_3, VAR_16)) {\n\t\t\tPERM_DENIED(VAR_0, VAR_3, VAR_16);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_5->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(VAR_5);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* COMMENT_3 */\n\tif ((VAR_5 != VAR_0) && (VAR_1.has_self_deaf() || VAR_1.has_self_mute() || VAR_1.has_plugin_context() || VAR_1.has_plugin_identity() || VAR_1.has_recording())) {\n\t\treturn;\n\t}\n\n\t/* COMMENT_4 */\n                                                                           \n   \n\tbool VAR_17 = false;\n\n\tif (VAR_1.has_texture()) {\n\t\tQByteArray VAR_18 = blob(VAR_1.texture());\n\t\tif (VAR_5->iId > 0) {\n\t\t\t/* COMMENT_7 */\n\t\t\tif (! setTexture(VAR_5->iId, VAR_18)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t/* COMMENT_8 */\n\t\t\thashAssign(VAR_5->qbaTexture, VAR_5->qbaTextureHash, VAR_18);\n\t\t}\n\n\t\t/* COMMENT_9 */\n\t\tVAR_17 = true;\n\t}\n\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\t{\n\t\tQWriteLocker VAR_19(&VAR_20);\n\n\t\tif (VAR_1.has_self_deaf()) {\n\t\t\tVAR_0->bSelfDeaf = VAR_1.self_deaf();\n\t\t\tif (VAR_0->bSelfDeaf)\n\t\t\t\tVAR_1.set_self_mute(true);\n\t\t\tVAR_17 = true;\n\t\t}\n\n\t\tif (VAR_1.has_self_mute()) {\n\t\t\tVAR_0->bSelfMute = VAR_1.self_mute();\n\t\t\tif (! VAR_0->bSelfMute) {\n\t\t\t\tVAR_1.set_self_deaf(false);\n\t\t\t\tVAR_0->bSelfDeaf = false;\n\t\t\t}\n\t\t\tVAR_17 = true;\n\t\t}\n\n\t\tif (VAR_1.has_plugin_context()) {\n\t\t\tVAR_0->ssContext = VAR_1.plugin_context();\n\n\t\t\t/* COMMENT_12 */\n\t\t\tVAR_1.clear_plugin_context();\n\t\t}\n\t}\n\n\tif (VAR_1.has_plugin_identity()) {\n\t\tVAR_0->qsIdentity = u8(VAR_1.plugin_identity());\n\t\t/* COMMENT_12 */\n\t\tVAR_1.clear_plugin_identity();\n\t}\n\n\tif (! VAR_11.isNull()) {\n\t\thashAssign(VAR_5->qsComment, VAR_5->qbaCommentHash, VAR_11);\n\n\t\tif (VAR_5->iId >= 0) {\n\t\t\tQMap<int, QString> VAR_21;\n\t\t\tVAR_21.insert(ServerDB::User_Comment, VAR_5->qsComment);\n\t\t\tsetInfo(VAR_5->iId, VAR_21);\n\t\t}\n\t\tVAR_17 = true;\n\t}\n\n\n\n\tif (VAR_1.has_mute() || VAR_1.has_deaf() || VAR_1.has_suppress() || VAR_1.has_priority_speaker()) {\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\tQWriteLocker VAR_19(&VAR_20);\n\n\t\tif (VAR_1.has_deaf()) {\n\t\t\tVAR_5->bDeaf = VAR_1.deaf();\n\t\t\tif (VAR_5->bDeaf)\n\t\t\t\tVAR_1.set_mute(true);\n\t\t}\n\t\tif (VAR_1.has_mute()) {\n\t\t\tVAR_5->bMute = VAR_1.mute();\n\t\t\tif (! VAR_5->bMute) {\n\t\t\t\tVAR_1.set_deaf(false);\n\t\t\t\tVAR_5->bDeaf = false;\n\t\t\t}\n\t\t}\n\t\tif (VAR_1.has_suppress())\n\t\t\tVAR_5->bSuppress = VAR_1.suppress();\n\n\t\tif (VAR_1.has_priority_speaker())\n\t\t\tVAR_5->bPrioritySpeaker = VAR_1.priority_speaker();\n\n\t\tlog(VAR_0, QString(\"Changed speak-state of %1 (%2 %3 %4 %5)\").arg(QString(*VAR_5),\n\t\t        QString::number(VAR_5->bMute),\n\t\t        QString::number(VAR_5->bDeaf),\n\t\t        QString::number(VAR_5->bSuppress),\n\t\t        QString::number(VAR_5->bPrioritySpeaker)));\n\n\t\tVAR_17 = true;\n\t}\n\n\tif (VAR_1.has_recording() && (VAR_5->bRecording != VAR_1.recording())) {\n\t\tVAR_5->bRecording = VAR_1.recording();\n\n\t\tMumbleProto::TextMessage VAR_22;\n\t\tVAR_22.add_tree_id(0);\n\t\tif (VAR_5->bRecording)\n\t\t\tVAR_22.set_message(u8(QString(QLatin1String(\"User '%1' started recording\")).arg(VAR_5->qsName)));\n\t\telse\n\t\t\tVAR_22.set_message(u8(QString(QLatin1String(\"User '%1' stopped recording\")).arg(VAR_5->qsName)));\n\n\t\tsendAll(VAR_22, ~ 0x010203);\n\n\t\tVAR_17 = true;\n\t}\n\n\tif (VAR_1.has_channel_id()) {\n\t\tChannel *VAR_8 = VAR_4.value(VAR_1.channel_id());\n\n\t\tuserEnterChannel(VAR_5, VAR_8, VAR_1);\n\t\tlog(VAR_0, QString(\"Moved %1 to %2\").arg(QString(*VAR_5), QString(*VAR_8)));\n\t\tVAR_17 = true;\n\t}\n\n\tbool VAR_23 = false;\n\tif (VAR_1.has_user_id()) {\n\t\t/* COMMENT_15 */\n\t\tQMap<int, QString> VAR_21;\n\n\t\tVAR_21.insert(ServerDB::User_Name, VAR_5->qsName);\n\t\tVAR_21.insert(ServerDB::User_Hash, VAR_5->qsHash);\n\t\tif (! VAR_5->qslEmail.isEmpty())\n\t\t\tVAR_21.insert(ServerDB::User_Email, VAR_5->qslEmail.first());\n\t\tint VAR_24 = registerUser(VAR_21);\n\t\tif (VAR_24 > 0) {\n\t\t\tVAR_5->iId = VAR_24;\n\t\t\tsetLastChannel(VAR_5);\n\t\t\tVAR_1.set_user_id(VAR_24);\n\t\t\tVAR_23 = true;\n\t\t} else {\n\t\t\t/* COMMENT_16 */\n\t\t\tVAR_1.clear_user_id();\n\t\t}\n\t\tVAR_17 = true;\n\t}\n\n\tif (VAR_17) {\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\tif (VAR_1.has_texture() && (VAR_5->qbaTexture.length() >= 4) && (VAR_25<unsigned int>(VAR_26<const unsigned char *>(VAR_5->qbaTexture.constData())) != 600 * 60 * 4)) {\n\t\t\t/* COMMENT_19 */\n\t\t\tVAR_1.clear_texture();\n\t\t\tsendAll(VAR_1, ~ 0x010202);\n\t\t\tVAR_1.set_texture(blob(VAR_5->qbaTexture));\n\t\t} else {\n\t\t\t/* COMMENT_20 */\n\t\t\t/* COMMENT_21 */\n\t\t\tsendAll(VAR_1, ~ 0x010202);\n\t\t}\n\n\t\t/* COMMENT_22 */\n\t\t/* COMMENT_23 */\n\t\tif (VAR_1.has_texture() && ! VAR_5->qbaTextureHash.isEmpty()) {\n\t\t\tVAR_1.clear_texture();\n\t\t\tVAR_1.set_texture_hash(blob(VAR_5->qbaTextureHash));\n\t\t}\n\t\tif (VAR_1.has_comment() && ! VAR_5->qbaCommentHash.isEmpty()) {\n\t\t\tVAR_1.clear_comment();\n\t\t\tVAR_1.set_comment_hash(blob(VAR_5->qbaCommentHash));\n\t\t}\n\n\t\tsendAll(VAR_1, 0x010202);\n\n\t\tif (VAR_23)\n\t\t\tclearACLCache(VAR_5);\n\t}\n\n\temit userStateChanged(pDstServerUser);\n}",
  "func_graph_path": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,10 @@\n \tif (msg.has_name()) {\n \t\tPERM_DENIED_TYPE(UserName);\n \t\treturn;\n+\t}\n+\n+\tif (uSource == pDstServerUser) {\n+\t\tRATELIMIT(uSource);\n \t}\n \n \tif (msg.has_channel_id()) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t}",
      "",
      "\tif (uSource == pDstServerUser) {",
      "\t\tRATELIMIT(uSource);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mumble-voip/mumble/pull/3510",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/mumble-voip/mumble/pull/3510: 403 Client Error: Forbidden for url: https://api.github.com/repos/mumble-voip/mumble/pulls/3510",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.85\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The patch addresses a message flood issue causing instability or crashes. It introduces a rate limiter to manage message bursts, which is relevant to preventing system overload.\n\n2. **Consistency Check:** The commit message, vulnerability description, and code diff are consistent. The added code implements the rate limiter mentioned.\n\n3. **Purpose Evaluation:** The patch modifies message handling to prevent crashes, focusing on system stability rather than security.\n\n4. **Security Vulnerability Assessment:** While it mitigates a denial-of-service scenario, it's presented as a performance fix rather than a security vulnerability.\n\n5. **Non-Security Classification:** The change is a feature upgrade to enhance system resilience, falling under \"Defect Remediation & Feature Upgrades.\"\n\n6. **Confidence Scoring:** High confidence due to clear intent and alignment, scoring 0.85."
}