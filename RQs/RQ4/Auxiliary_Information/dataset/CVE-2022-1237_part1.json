{
  "cve_id": "CVE-2022-1237",
  "cwe_ids": [
    "CWE-129"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix oobread segfaults in the NE bin parser ##crash\n\n* Reported by @han0nly via huntr.dev\n* Reproducers: seed1 seed2\n* BountyID: ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40",
  "commit_hash": "2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6",
  "git_url": "https://github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6",
  "file_path": "libr/bin/format/ne/ne.c",
  "func_name": "r_bin_ne_get_relocs",
  "func_before": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off, start = off = seg->paddr + seg->size;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tNE_image_reloc_item rel;\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\t\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}",
  "abstract_func_before": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *VAR_0) {\n\tRList *VAR_1 = VAR_0->segments;\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_2 = VAR_0->entries;\n\tif (!VAR_2) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_3 = VAR_0->symbols;\n\tif (!VAR_3) {\n\t\treturn NULL;\n\t}\n\n\tut16 *VAR_4 = malloc (VAR_0->ne_header->ModRefs * sizeof (ut16));\n\tif (!VAR_4) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (VAR_0->buf, (ut64)VAR_0->ne_header->ModRefTable + VAR_0->header_offset, (ut8 *)VAR_4, VAR_0->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *VAR_5 = r_list_newf (VAR_6);\n\tif (!VAR_5) {\n\t\tVAR_6 (VAR_4);\n\t\treturn NULL;\n\t}\n\n\tRListIter *VAR_7;\n\tRBinSection *VAR_8;\n\tint VAR_9 = -1;\n\tr_list_foreach (VAR_1, VAR_7, VAR_8) {\n\t\tVAR_9++;\n\t\tif (!(VAR_0->segment_entries[VAR_9].flags & VAR_10)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 VAR_11, VAR_12 = VAR_11 = VAR_8->paddr + VAR_8->size;\n\t\tut16 VAR_13 = r_buf_read_le16_at (VAR_0->buf, VAR_11);\n\t\tif (!VAR_13) {\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_11 += 2;\n\t\twhile (VAR_11 < VAR_12 + VAR_13 * sizeof (VAR_14)) {\n\t\t\tRBinReloc *VAR_15 = R_NEW0 (RBinReloc);\n\t\t\tif (!VAR_15) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tNE_image_reloc_item VAR_16;\n\t\t\tr_buf_read_at (VAR_0->buf, VAR_11, (ut8 *)&VAR_16, sizeof (VAR_16));\n\t\t\tVAR_15->paddr = VAR_8->paddr + VAR_16.offset;\n\t\t\tswitch (VAR_16.type) {\n\t\t\tcase VAR_17:\n\t\t\t\tVAR_15->type = VAR_18;\n\t\t\t\tbreak;\n\t\t\tcase VAR_19:\n\t\t\tcase VAR_20:\n\t\t\t\tVAR_15->type = VAR_21;\n\t\t\t\tbreak;\n\t\t\tcase VAR_22:\n\t\t\tcase VAR_23:\n\t\t\t\tVAR_15->type = VAR_24;\n\t\t\t\tbreak;\n\t\t\tcase VAR_25:\n\t\t\t\tVAR_15->type = VAR_26;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 VAR_27;\n\t\t\tif (VAR_16.flags & (VAR_28 | VAR_29)) {\n\t\t\t\tRBinImport *VAR_30 = R_NEW0 (RBinImport);\n\t\t\t\tif (!VAR_30) {\n\t\t\t\t\tVAR_6 (VAR_15);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *VAR_31;\n\t\t\t\tif (VAR_16.index > VAR_0->ne_header->ModRefs) {\n\t\t\t\t\tVAR_31 = r_str_newf (\"UnknownModule%d_%x\", VAR_16.index, VAR_11); /* COMMENT_0 */\n\t\t\t\t} else {\n\t\t\t\t\tVAR_27 = VAR_4[VAR_16.index - 1] + VAR_0->header_offset + VAR_0->ne_header->ImportNameTable;\n\t\t\t\t\tVAR_31 = __read_nonnull_str_at (VAR_0->buf, VAR_27);\n\t\t\t\t}\n\t\t\t\tif (VAR_16.flags & VAR_28) {\n\t\t\t\t\tVAR_30->ordinal = VAR_16.func_ord;\n\t\t\t\t\tVAR_30->name = r_str_newf (\"%s.%s\", VAR_31, __func_name_from_ord(VAR_31, VAR_16.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\tVAR_27 = VAR_0->header_offset + VAR_0->ne_header->ImportNameTable + VAR_16.name_off;\n\t\t\t\t\tchar *VAR_32 = __read_nonnull_str_at (VAR_0->buf, VAR_27);\n\t\t\t\t\tVAR_30->name = r_str_newf (\"%s.%s\", VAR_31, VAR_32);\n\t\t\t\t\tVAR_6 (VAR_32);\n\t\t\t\t}\n\t\t\t\tVAR_6 (VAR_31);\n\t\t\t\tVAR_15->import = VAR_30;\n\t\t\t} else if (VAR_16.flags & VAR_33) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t} else {\n\t\t\t\tif (strstr (VAR_8->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *VAR_34 = r_list_get_n (VAR_1, VAR_16.segnum - 1);\n\t\t\t\t\tif (VAR_34) {\n\t\t\t\t\t\tVAR_27 = VAR_34->paddr + VAR_16.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_27 = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *VAR_35 = r_list_get_n (VAR_2, VAR_16.entry_ordinal - 1);\n\t\t\t\t\tif (VAR_35) {\n\t\t\t\t\t\tVAR_27 = VAR_35->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_27 = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_15->addend = VAR_27;\n\t\t\t\tRBinSymbol *VAR_36 = NULL;\n\t\t\t\tRListIter *VAR_37;\n\t\t\t\tr_list_foreach (VAR_3, VAR_37, VAR_36) {\n\t\t\t\t\tif (VAR_36->paddr == VAR_15->addend) {\n\t\t\t\t\t\tVAR_15->symbol = VAR_36;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_16.flags & VAR_38) {\n\t\t\t\tVAR_15->additive = 1;\n\t\t\t\tr_list_append (VAR_5, VAR_15);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tr_list_append (VAR_5, VAR_15);\n\t\t\t\t\t\n\t\t\t\t\tVAR_27 = r_buf_read_le16_at (VAR_0->buf, VAR_15->paddr);\n\t\t\t\t\tRBinReloc *VAR_39 = VAR_15;\n\t\t\t\t\tVAR_15 = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!VAR_15) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*VAR_15 = *VAR_39;\n\t\t\t\t\tVAR_15->paddr = VAR_8->paddr + VAR_27;\n\t\t\t\t} while (VAR_27 != 0xFFFF);\n\t\t\t\tVAR_6 (VAR_15);\n\t\t\t}\n\n\t\t\tVAR_11 += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tVAR_6 (VAR_4);\n\treturn VAR_5;\n}",
  "func_graph_path_before": "radareorg/radare2/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6/ne.c/vul/before/0.json",
  "func": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off, start = off = seg->paddr + seg->size;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\tsize_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tNE_image_reloc_item rel;\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\tint index = rel.index;\n\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\t\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}",
  "abstract_func": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *VAR_0) {\n\tRList *VAR_1 = VAR_0->segments;\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_2 = VAR_0->entries;\n\tif (!VAR_2) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_3 = VAR_0->symbols;\n\tif (!VAR_3) {\n\t\treturn NULL;\n\t}\n\n\tut16 *VAR_4 = calloc (VAR_0->ne_header->ModRefs, sizeof (ut16));\n\tif (!VAR_4) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (VAR_0->buf, (ut64)VAR_0->ne_header->ModRefTable + VAR_0->header_offset, (ut8 *)VAR_4, VAR_0->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *VAR_5 = r_list_newf (VAR_6);\n\tif (!VAR_5) {\n\t\tVAR_6 (VAR_4);\n\t\treturn NULL;\n\t}\n\n\tRListIter *VAR_7;\n\tRBinSection *VAR_8;\n\tint VAR_9 = -1;\n\tr_list_foreach (VAR_1, VAR_7, VAR_8) {\n\t\tVAR_9++;\n\t\tif (!(VAR_0->segment_entries[VAR_9].flags & VAR_10)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 VAR_11, VAR_12 = VAR_11 = VAR_8->paddr + VAR_8->size;\n\t\tut16 VAR_13 = r_buf_read_le16_at (VAR_0->buf, VAR_11);\n\t\tif (!VAR_13) {\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_11 += 2;\n\t\tsize_t VAR_14 = r_buf_size (VAR_0->buf);\n\t\twhile (VAR_11 < VAR_12 + VAR_13 * sizeof (VAR_15) && VAR_11 < VAR_14) {\n\t\t\tRBinReloc *VAR_16 = R_NEW0 (RBinReloc);\n\t\t\tif (!VAR_16) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tNE_image_reloc_item VAR_17;\n\t\t\tr_buf_read_at (VAR_0->buf, VAR_11, (ut8 *)&VAR_17, sizeof (VAR_17));\n\t\t\tVAR_16->paddr = VAR_8->paddr + VAR_17.offset;\n\t\t\tswitch (VAR_17.type) {\n\t\t\tcase VAR_18:\n\t\t\t\tVAR_16->type = VAR_19;\n\t\t\t\tbreak;\n\t\t\tcase VAR_20:\n\t\t\tcase VAR_21:\n\t\t\t\tVAR_16->type = VAR_22;\n\t\t\t\tbreak;\n\t\t\tcase VAR_23:\n\t\t\tcase VAR_24:\n\t\t\t\tVAR_16->type = VAR_25;\n\t\t\t\tbreak;\n\t\t\tcase VAR_26:\n\t\t\t\tVAR_16->type = VAR_27;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 VAR_28;\n\t\t\tif (VAR_17.flags & (VAR_29 | VAR_30)) {\n\t\t\t\tRBinImport *VAR_31 = R_NEW0 (RBinImport);\n\t\t\t\tif (!VAR_31) {\n\t\t\t\t\tVAR_6 (VAR_16);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *VAR_32;\n\t\t\t\tif (VAR_17.index < 1 || VAR_17.index > VAR_0->ne_header->ModRefs) {\n\t\t\t\t\tVAR_32 = r_str_newf (\"UnknownModule%d_%x\", VAR_17.index, VAR_11); /* COMMENT_0 */\n\t\t\t\t} else {\n\t\t\t\t\tint VAR_9 = VAR_17.index;\n\t\t\t\t\tVAR_28 = VAR_4[VAR_9 - 1] + VAR_0->header_offset + VAR_0->ne_header->ImportNameTable;\n\t\t\t\t\tVAR_32 = __read_nonnull_str_at (VAR_0->buf, VAR_28);\n\t\t\t\t}\n\t\t\t\tif (VAR_17.flags & VAR_29) {\n\t\t\t\t\tVAR_31->ordinal = VAR_17.func_ord;\n\t\t\t\t\tVAR_31->name = r_str_newf (\"%s.%s\", VAR_32, __func_name_from_ord(VAR_32, VAR_17.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\tVAR_28 = VAR_0->header_offset + VAR_0->ne_header->ImportNameTable + VAR_17.name_off;\n\t\t\t\t\tchar *VAR_33 = __read_nonnull_str_at (VAR_0->buf, VAR_28);\n\t\t\t\t\tVAR_31->name = r_str_newf (\"%s.%s\", VAR_32, VAR_33);\n\t\t\t\t\tVAR_6 (VAR_33);\n\t\t\t\t}\n\t\t\t\tVAR_6 (VAR_32);\n\t\t\t\tVAR_16->import = VAR_31;\n\t\t\t} else if (VAR_17.flags & VAR_34) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t} else {\n\t\t\t\tif (strstr (VAR_8->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *VAR_35 = r_list_get_n (VAR_1, VAR_17.segnum - 1);\n\t\t\t\t\tif (VAR_35) {\n\t\t\t\t\t\tVAR_28 = VAR_35->paddr + VAR_17.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_28 = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *VAR_36 = r_list_get_n (VAR_2, VAR_17.entry_ordinal - 1);\n\t\t\t\t\tif (VAR_36) {\n\t\t\t\t\t\tVAR_28 = VAR_36->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_28 = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_16->addend = VAR_28;\n\t\t\t\tRBinSymbol *VAR_37 = NULL;\n\t\t\t\tRListIter *VAR_38;\n\t\t\t\tr_list_foreach (VAR_3, VAR_38, VAR_37) {\n\t\t\t\t\tif (VAR_37->paddr == VAR_16->addend) {\n\t\t\t\t\t\tVAR_16->symbol = VAR_37;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_17.flags & VAR_39) {\n\t\t\t\tVAR_16->additive = 1;\n\t\t\t\tr_list_append (VAR_5, VAR_16);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tr_list_append (VAR_5, VAR_16);\n\t\t\t\t\t\n\t\t\t\t\tVAR_28 = r_buf_read_le16_at (VAR_0->buf, VAR_16->paddr);\n\t\t\t\t\tRBinReloc *VAR_40 = VAR_16;\n\t\t\t\t\tVAR_16 = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!VAR_16) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*VAR_16 = *VAR_40;\n\t\t\t\t\tVAR_16->paddr = VAR_8->paddr + VAR_28;\n\t\t\t\t} while (VAR_28 != 0xFFFF);\n\t\t\t\tVAR_6 (VAR_16);\n\t\t\t}\n\n\t\t\tVAR_11 += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tVAR_6 (VAR_4);\n\treturn VAR_5;\n}",
  "func_graph_path": "radareorg/radare2/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6/ne.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \t\treturn NULL;\n \t}\n \n-\tut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));\n+\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n \tif (!modref) {\n \t\treturn NULL;\n \t}\n@@ -38,7 +38,8 @@\n \t\t\tcontinue;\n \t\t}\n \t\toff += 2;\n-\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n+\t\tsize_t buf_size = r_buf_size (bin->buf);\n+\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {\n \t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n \t\t\tif (!reloc) {\n \t\t\t\treturn NULL;\n@@ -71,10 +72,11 @@\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tchar *name;\n-\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n+\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {\n \t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n \t\t\t\t} else {\n-\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n+\t\t\t\t\tint index = rel.index;\n+\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n \t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n \t\t\t\t}\n \t\t\t\tif (rel.flags & IMPORTED_ORD) {",
  "diff_line_info": {
    "deleted_lines": [
      "\tut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));",
      "\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {",
      "\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {",
      "\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;"
    ],
    "added_lines": [
      "\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));",
      "\t\tsize_t buf_size = r_buf_size (bin->buf);",
      "\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {",
      "\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {",
      "\t\t\t\t\tint index = rel.index;",
      "\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19918",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19918: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19918",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95  \nThe changes address buffer overflows and memory management issues, which are security vulnerabilities. The use of `calloc`, bounds checking, and index validation clearly mitigate the risks reported."
}