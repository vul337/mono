{
  "cve_id": "CVE-2017-16898",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "Fix global buffer overflow in printMP3Headers.\n\nThe printMP3Headers function in util/listmp3.c processes mp3 files\nwithout checking their bitrate values. This leads to bitrate_idx = 15\nbeing used as index in mp2l23_bitrate_table[bitrate_idx] while\nmp2l23_bitrate_table has only 14 elements.\n\nIn this commit we add a check rejecting mp3 files declaring invalid\nbitrates.\n\nThis commit fixes CVE-2017-16898 (fixes: #75).",
  "commit_hash": "6032557a21e4dac8bb2606bb5b58e27d85a7ff98",
  "git_url": "https://github.com/libming/libming/commit/6032557a21e4dac8bb2606bb5b58e27d85a7ff98",
  "file_path": "util/listmp3.c",
  "func_name": "printMP3Headers",
  "func_before": "void printMP3Headers(FILE *f)\n{\n  unsigned long flags;\n  int frameLen, numFrames = 0;\n  int bitrate=0, bitrate_idx, samplerate=0, samplerate_idx;\n  int version, layer, channels, padding;\n  int bitrateSum = 0;\n  int length;\n\n  for(;;)\n  {\n    int flags_char;\n    int i;\n    /* get 4-byte header, bigendian */\n    if((flags = fgetc(f)) == EOF)\n      break;\n\n    /* XXX - fix this mad hackery */\n    if(flags == 'I' && fgetc(f) == 'D' && fgetc(f) == '3')\n    {\n      do\n      {\n\tflags = fgetc(f);\n      }\n      while(flags != 0xFF && flags != EOF);\n    }\n\n    if(flags == EOF)\n      break;\n\n    flags <<= 24;\n    for (i = 2; i >= 0; --i)\n    {\n      if ((flags_char = fgetc(f)) == EOF)\n      {\n        error(\"truncated file\");\n      }\n      else\n      {\n        flags += flags_char << (i * 8);\n      }\n    }\n\n    if((flags & MP3_FRAME_SYNC) != MP3_FRAME_SYNC)\n      break;\n    /*      error(\"bad sync on MP3 block!\"); */\n\n    ++numFrames;\n\n    bitrate_idx = (flags & MP3_BITRATE) >> MP3_BITRATE_SHIFT;\n    samplerate_idx = (flags & MP3_SAMPLERATE) >> MP3_SAMPLERATE_SHIFT;\n    if (samplerate_idx < 0 || samplerate_idx > MP3_SAMPLERATE_IDX_MAX)\n    {\n      error(\"invalid samplerate index\");\n    }\n\n    channels = ((flags & MP3_CHANNEL) == MP3_CHANNEL_MONO) ? 1 : 2;\n\n    switch(flags & MP3_VERSION)\n    {\n      case MP3_VERSION_1:  version = 1; break;\n      case MP3_VERSION_2:  version = 2; break;\n      case MP3_VERSION_25: version = 25; break;\n      default: error(\"unknown MP3 version!\");\n    }\n    switch(flags & MP3_LAYER)\n    {\n      case MP3_LAYER_1: layer = 1; break;\n      case MP3_LAYER_2: layer = 2; break;\n      case MP3_LAYER_3: layer = 3; break;\n      default: error(\"unknown MP3 layer!\");\n    }\n\n    bitrateSum += bitrate;\n\n    if(version == 1)\n    {\n      samplerate = mp1_samplerate_table[samplerate_idx];\n\n      if(layer == 1)\n\tbitrate = mp1l1_bitrate_table[bitrate_idx];\n\n      else if(layer == 2)\n\tbitrate = mp1l2_bitrate_table[bitrate_idx];\n\n      else if(layer == 3)\n\tbitrate = mp1l3_bitrate_table[bitrate_idx];\n    }\n    else\n    {\n      if(version == 2)\n\tsamplerate = mp2_samplerate_table[samplerate_idx];\n      else\n\tsamplerate = mp25_samplerate_table[samplerate_idx];\n\n      if(layer == 1)\n\tbitrate = mp2l1_bitrate_table[bitrate_idx];\n      else\n\tbitrate = mp2l23_bitrate_table[bitrate_idx];\n    }\n\n    padding = (flags & MP3_PADDING) ? 1 : 0;\n\n    if(layer == 1)\n      padding <<= 2;\n\n    if(version == 1)\n      frameLen = 144 * bitrate * 1000 / samplerate + padding;\n    else\n      frameLen = 72 * bitrate * 1000 / samplerate + padding;\n\n    printf(\"frame %i: MP%i layer %i, %i Hz, %ikbps, %s, length=%i, protect %s\\n\",\n\t   numFrames, version, layer, samplerate, bitrate,\n\t   (channels==2) ? \"stereo\" : \"mono\", frameLen,\n\t   (flags&MP3_PROTECT) ? \"on\" : \"off\");\n\n    skipBytes(f, frameLen-4);\n  }\n\n  if (numFrames == 0)\n    error(\"no valid frame found\");\n\n  putchar('\\n');\n\n  length = numFrames*(samplerate > 3200 ? 1152 : 576)/samplerate;\n\n  printf(\"Number of frames: %i\\n\", numFrames);\n  printf(\"Average bitrate: %i\\n\", bitrateSum/numFrames);\n  printf(\"Length: %i:%02i\\n\", length/60, length%60);\n}",
  "abstract_func_before": "void printMP3Headers(FILE *VAR_0)\n{\n  unsigned long VAR_1;\n  int VAR_2, VAR_3 = 0;\n  int VAR_4=0, VAR_5, VAR_6=0, VAR_7;\n  int VAR_8, VAR_9, VAR_10, VAR_11;\n  int VAR_12 = 0;\n  int VAR_13;\n\n  for(;;)\n  {\n    int VAR_14;\n    int VAR_15;\n    /* COMMENT_0 */\n    if((VAR_1 = fgetc(VAR_0)) == VAR_16)\n      break;\n\n    /* COMMENT_1 */\n    if(VAR_1 == 'I' && fgetc(VAR_0) == 'D' && fgetc(VAR_0) == '3')\n    {\n      do\n      {\n\tVAR_1 = fgetc(VAR_0);\n      }\n      while(VAR_1 != 0xFF && VAR_1 != VAR_16);\n    }\n\n    if(VAR_1 == VAR_16)\n      break;\n\n    VAR_1 <<= 24;\n    for (VAR_15 = 2; VAR_15 >= 0; --VAR_15)\n    {\n      if ((VAR_14 = fgetc(VAR_0)) == VAR_16)\n      {\n        error(\"truncated file\");\n      }\n      else\n      {\n        VAR_1 += VAR_14 << (VAR_15 * 8);\n      }\n    }\n\n    if((VAR_1 & VAR_17) != VAR_17)\n      break;\n    /* COMMENT_2 */\n\n    ++VAR_3;\n\n    VAR_5 = (VAR_1 & VAR_18) >> VAR_19;\n    VAR_7 = (VAR_1 & VAR_20) >> VAR_21;\n    if (VAR_7 < 0 || VAR_7 > VAR_22)\n    {\n      error(\"invalid samplerate index\");\n    }\n\n    VAR_10 = ((VAR_1 & VAR_23) == VAR_24) ? 1 : 2;\n\n    switch(VAR_1 & VAR_25)\n    {\n      case VAR_26:  VAR_8 = 1; break;\n      case VAR_27:  VAR_8 = 2; break;\n      case VAR_28: VAR_8 = 25; break;\n      default: error(\"unknown MP3 version!\");\n    }\n    switch(VAR_1 & VAR_29)\n    {\n      case VAR_30: VAR_9 = 1; break;\n      case VAR_31: VAR_9 = 2; break;\n      case VAR_32: VAR_9 = 3; break;\n      default: error(\"unknown MP3 layer!\");\n    }\n\n    VAR_12 += VAR_4;\n\n    if(VAR_8 == 1)\n    {\n      VAR_6 = VAR_33[VAR_7];\n\n      if(VAR_9 == 1)\n\tVAR_4 = VAR_34[VAR_5];\n\n      else if(VAR_9 == 2)\n\tVAR_4 = VAR_35[VAR_5];\n\n      else if(VAR_9 == 3)\n\tVAR_4 = VAR_36[VAR_5];\n    }\n    else\n    {\n      if(VAR_8 == 2)\n\tVAR_6 = VAR_37[VAR_7];\n      else\n\tVAR_6 = VAR_38[VAR_7];\n\n      if(VAR_9 == 1)\n\tVAR_4 = VAR_39[VAR_5];\n      else\n\tVAR_4 = VAR_40[VAR_5];\n    }\n\n    VAR_11 = (VAR_1 & VAR_41) ? 1 : 0;\n\n    if(VAR_9 == 1)\n      VAR_11 <<= 2;\n\n    if(VAR_8 == 1)\n      VAR_2 = 144 * VAR_4 * 1000 / VAR_6 + VAR_11;\n    else\n      VAR_2 = 72 * VAR_4 * 1000 / VAR_6 + VAR_11;\n\n    printf(\"frame %i: MP%i layer %i, %i Hz, %ikbps, %s, length=%i, protect %s\\n\",\n\t   VAR_3, VAR_8, VAR_9, VAR_6, VAR_4,\n\t   (VAR_10==2) ? \"stereo\" : \"mono\", VAR_2,\n\t   (VAR_1&VAR_42) ? \"on\" : \"off\");\n\n    skipBytes(VAR_0, VAR_2-4);\n  }\n\n  if (VAR_3 == 0)\n    error(\"no valid frame found\");\n\n  putchar('\\n');\n\n  VAR_13 = VAR_3*(VAR_6 > 3200 ? 1152 : 576)/VAR_6;\n\n  printf(\"Number of frames: %i\\n\", VAR_3);\n  printf(\"Average bitrate: %i\\n\", VAR_12/VAR_3);\n  printf(\"Length: %i:%02i\\n\", VAR_13/60, VAR_13%60);\n}",
  "func_graph_path_before": "libming/6032557a21e4dac8bb2606bb5b58e27d85a7ff98/listmp3.c/vul/before/0.json",
  "func": "void printMP3Headers(FILE *f)\n{\n  unsigned long flags;\n  int frameLen, numFrames = 0;\n  int bitrate=0, bitrate_idx, samplerate=0, samplerate_idx;\n  int version, layer, channels, padding;\n  int bitrateSum = 0;\n  int length;\n\n  for(;;)\n  {\n    int flags_char;\n    int i;\n    /* get 4-byte header, bigendian */\n    if((flags = fgetc(f)) == EOF)\n      break;\n\n    /* XXX - fix this mad hackery */\n    if(flags == 'I' && fgetc(f) == 'D' && fgetc(f) == '3')\n    {\n      do\n      {\n\tflags = fgetc(f);\n      }\n      while(flags != 0xFF && flags != EOF);\n    }\n\n    if(flags == EOF)\n      break;\n\n    flags <<= 24;\n    for (i = 2; i >= 0; --i)\n    {\n      if ((flags_char = fgetc(f)) == EOF)\n      {\n        error(\"truncated file\");\n      }\n      else\n      {\n        flags += flags_char << (i * 8);\n      }\n    }\n\n    if((flags & MP3_FRAME_SYNC) != MP3_FRAME_SYNC)\n      break;\n    /*      error(\"bad sync on MP3 block!\"); */\n\n    ++numFrames;\n\n    bitrate_idx = (flags & MP3_BITRATE) >> MP3_BITRATE_SHIFT;\n    samplerate_idx = (flags & MP3_SAMPLERATE) >> MP3_SAMPLERATE_SHIFT;\n    if (samplerate_idx < 0 || samplerate_idx > MP3_SAMPLERATE_IDX_MAX)\n    {\n      error(\"invalid samplerate index\");\n    }\n\n    if (bitrate_idx == 15)\n    {\n      error(\"invalid bitrate 15\");\n    }\n\n    channels = ((flags & MP3_CHANNEL) == MP3_CHANNEL_MONO) ? 1 : 2;\n\n    switch(flags & MP3_VERSION)\n    {\n      case MP3_VERSION_1:  version = 1; break;\n      case MP3_VERSION_2:  version = 2; break;\n      case MP3_VERSION_25: version = 25; break;\n      default: error(\"unknown MP3 version!\");\n    }\n    switch(flags & MP3_LAYER)\n    {\n      case MP3_LAYER_1: layer = 1; break;\n      case MP3_LAYER_2: layer = 2; break;\n      case MP3_LAYER_3: layer = 3; break;\n      default: error(\"unknown MP3 layer!\");\n    }\n\n    bitrateSum += bitrate;\n\n    if(version == 1)\n    {\n      samplerate = mp1_samplerate_table[samplerate_idx];\n\n      if(layer == 1)\n\tbitrate = mp1l1_bitrate_table[bitrate_idx];\n\n      else if(layer == 2)\n\tbitrate = mp1l2_bitrate_table[bitrate_idx];\n\n      else if(layer == 3)\n\tbitrate = mp1l3_bitrate_table[bitrate_idx];\n    }\n    else\n    {\n      if(version == 2)\n\tsamplerate = mp2_samplerate_table[samplerate_idx];\n      else\n\tsamplerate = mp25_samplerate_table[samplerate_idx];\n\n      if(layer == 1)\n\tbitrate = mp2l1_bitrate_table[bitrate_idx];\n      else\n\tbitrate = mp2l23_bitrate_table[bitrate_idx];\n    }\n\n    padding = (flags & MP3_PADDING) ? 1 : 0;\n\n    if(layer == 1)\n      padding <<= 2;\n\n    if(version == 1)\n      frameLen = 144 * bitrate * 1000 / samplerate + padding;\n    else\n      frameLen = 72 * bitrate * 1000 / samplerate + padding;\n\n    printf(\"frame %i: MP%i layer %i, %i Hz, %ikbps, %s, length=%i, protect %s\\n\",\n\t   numFrames, version, layer, samplerate, bitrate,\n\t   (channels==2) ? \"stereo\" : \"mono\", frameLen,\n\t   (flags&MP3_PROTECT) ? \"on\" : \"off\");\n\n    skipBytes(f, frameLen-4);\n  }\n\n  if (numFrames == 0)\n    error(\"no valid frame found\");\n\n  putchar('\\n');\n\n  length = numFrames*(samplerate > 3200 ? 1152 : 576)/samplerate;\n\n  printf(\"Number of frames: %i\\n\", numFrames);\n  printf(\"Average bitrate: %i\\n\", bitrateSum/numFrames);\n  printf(\"Length: %i:%02i\\n\", length/60, length%60);\n}",
  "abstract_func": "void printMP3Headers(FILE *VAR_0)\n{\n  unsigned long VAR_1;\n  int VAR_2, VAR_3 = 0;\n  int VAR_4=0, VAR_5, VAR_6=0, VAR_7;\n  int VAR_8, VAR_9, VAR_10, VAR_11;\n  int VAR_12 = 0;\n  int VAR_13;\n\n  for(;;)\n  {\n    int VAR_14;\n    int VAR_15;\n    /* COMMENT_0 */\n    if((VAR_1 = fgetc(VAR_0)) == VAR_16)\n      break;\n\n    /* COMMENT_1 */\n    if(VAR_1 == 'I' && fgetc(VAR_0) == 'D' && fgetc(VAR_0) == '3')\n    {\n      do\n      {\n\tVAR_1 = fgetc(VAR_0);\n      }\n      while(VAR_1 != 0xFF && VAR_1 != VAR_16);\n    }\n\n    if(VAR_1 == VAR_16)\n      break;\n\n    VAR_1 <<= 24;\n    for (VAR_15 = 2; VAR_15 >= 0; --VAR_15)\n    {\n      if ((VAR_14 = fgetc(VAR_0)) == VAR_16)\n      {\n        error(\"truncated file\");\n      }\n      else\n      {\n        VAR_1 += VAR_14 << (VAR_15 * 8);\n      }\n    }\n\n    if((VAR_1 & VAR_17) != VAR_17)\n      break;\n    /* COMMENT_2 */\n\n    ++VAR_3;\n\n    VAR_5 = (VAR_1 & VAR_18) >> VAR_19;\n    VAR_7 = (VAR_1 & VAR_20) >> VAR_21;\n    if (VAR_7 < 0 || VAR_7 > VAR_22)\n    {\n      error(\"invalid samplerate index\");\n    }\n\n    if (VAR_5 == 15)\n    {\n      error(\"invalid bitrate 15\");\n    }\n\n    VAR_10 = ((VAR_1 & VAR_23) == VAR_24) ? 1 : 2;\n\n    switch(VAR_1 & VAR_25)\n    {\n      case VAR_26:  VAR_8 = 1; break;\n      case VAR_27:  VAR_8 = 2; break;\n      case VAR_28: VAR_8 = 25; break;\n      default: error(\"unknown MP3 version!\");\n    }\n    switch(VAR_1 & VAR_29)\n    {\n      case VAR_30: VAR_9 = 1; break;\n      case VAR_31: VAR_9 = 2; break;\n      case VAR_32: VAR_9 = 3; break;\n      default: error(\"unknown MP3 layer!\");\n    }\n\n    VAR_12 += VAR_4;\n\n    if(VAR_8 == 1)\n    {\n      VAR_6 = VAR_33[VAR_7];\n\n      if(VAR_9 == 1)\n\tVAR_4 = VAR_34[VAR_5];\n\n      else if(VAR_9 == 2)\n\tVAR_4 = VAR_35[VAR_5];\n\n      else if(VAR_9 == 3)\n\tVAR_4 = VAR_36[VAR_5];\n    }\n    else\n    {\n      if(VAR_8 == 2)\n\tVAR_6 = VAR_37[VAR_7];\n      else\n\tVAR_6 = VAR_38[VAR_7];\n\n      if(VAR_9 == 1)\n\tVAR_4 = VAR_39[VAR_5];\n      else\n\tVAR_4 = VAR_40[VAR_5];\n    }\n\n    VAR_11 = (VAR_1 & VAR_41) ? 1 : 0;\n\n    if(VAR_9 == 1)\n      VAR_11 <<= 2;\n\n    if(VAR_8 == 1)\n      VAR_2 = 144 * VAR_4 * 1000 / VAR_6 + VAR_11;\n    else\n      VAR_2 = 72 * VAR_4 * 1000 / VAR_6 + VAR_11;\n\n    printf(\"frame %i: MP%i layer %i, %i Hz, %ikbps, %s, length=%i, protect %s\\n\",\n\t   VAR_3, VAR_8, VAR_9, VAR_6, VAR_4,\n\t   (VAR_10==2) ? \"stereo\" : \"mono\", VAR_2,\n\t   (VAR_1&VAR_42) ? \"on\" : \"off\");\n\n    skipBytes(VAR_0, VAR_2-4);\n  }\n\n  if (VAR_3 == 0)\n    error(\"no valid frame found\");\n\n  putchar('\\n');\n\n  VAR_13 = VAR_3*(VAR_6 > 3200 ? 1152 : 576)/VAR_6;\n\n  printf(\"Number of frames: %i\\n\", VAR_3);\n  printf(\"Average bitrate: %i\\n\", VAR_12/VAR_3);\n  printf(\"Length: %i:%02i\\n\", VAR_13/60, VAR_13%60);\n}",
  "func_graph_path": "libming/6032557a21e4dac8bb2606bb5b58e27d85a7ff98/listmp3.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -52,6 +52,11 @@\n     if (samplerate_idx < 0 || samplerate_idx > MP3_SAMPLERATE_IDX_MAX)\n     {\n       error(\"invalid samplerate index\");\n+    }\n+\n+    if (bitrate_idx == 15)\n+    {\n+      error(\"invalid bitrate 15\");\n     }\n \n     channels = ((flags & MP3_CHANNEL) == MP3_CHANNEL_MONO) ? 1 : 2;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    }",
      "",
      "    if (bitrate_idx == 15)",
      "    {",
      "      error(\"invalid bitrate 15\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/99",
  "description": {
    "pr_info": {
      "title": "Fix global buffer overflow in printMP3Headers (CVE-2017-16898)",
      "number": 99
    },
    "comment": [
      "The printMP3Headers function in `util/listmp3.c` processes mp3 files without checking their bitrate values. This leads to `bitrate_idx` = 15 being used as index in `mp2l23_bitrate_table[bitrate_idx]` while `mp2l23_bitrate_table` has size 14.\r\n\r\nIn this PR we add a check rejecting mp3 files declaring invalid bitrates.\r\n\r\nThis PR fixes CVE-2017-16898 (fixes: #75).",
      "Merged, although I wonder if the parser is correct in interpreting\nthat number.. (why should 15 be not valid ?)\n\nmp2l23_bitrate_table has a size of 15, but ofc when used as an offset\nthe index should start at 0. Could it be it just needs to be\ndecremented by 1 before used as an index ?\n",
      "Hum, I guess the parser is perfectly correct in interpreting that number now. In fact, the MP3 specification declares bitrate = 15 as an invalid value (explained [here](https://www.mp3-tech.org/programmer/frame_header.html) for example).\r\n\r\nBut, you're right Sandro, my commit/PR messages weren't clear enough, and I even made a mistake:\r\n\r\n> mp2l23_bitrate_table has size 14\r\n\r\nshould be\r\n\r\n> mp2l23_bitrate_table has size 15\r\n\r\nAm I missing something ?",
      "nothing missing, thanks for the reference!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nStep-by-step Explanation:\n\n1. **Analysis of Input:** The commit message clearly states a buffer overflow issue, the code diff shows an added check, and there's a CVE reference.\n\n2. **Consistency Check:** All elements consistently point to a buffer overflow fix, aligning with security concerns.\n\n3. **Purpose Evaluation:** The change directly addresses a security flaw by adding input validation.\n\n4. **Security Assessment:** The fix resolves a known CVE, indicating it's a security vulnerability fix.\n\nThe classification is clear, hence the high confidence score."
}