{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/parser.c",
  "func_name": "yr_parser_reduce_rule_declaration_phase_2",
  "func_before": "int yr_parser_reduce_rule_declaration_phase_2(\n    yyscan_t yyscanner,\n    YR_ARENA_REF* rule_ref)\n{\n  uint32_t max_strings_per_rule;\n  uint32_t strings_in_rule = 0;\n\n  YR_FIXUP* fixup;\n  YR_STRING* string;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_STRINGS_PER_RULE, (void*) &max_strings_per_rule);\n\n  YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);\n\n  // Show warning if the rule is generating too many atoms. The warning is\n  // shown if the number of atoms is greater than 20 times the maximum number\n  // of strings allowed for a rule, as 20 is minimum number of atoms generated\n  // for a string using *nocase*, *ascii* and *wide* modifiers simultaneously.\n\n  if (rule->num_atoms > YR_ATOMS_PER_RULE_WARNING_THRESHOLD)\n  {\n    yywarning(yyscanner, \"rule is slowing down scanning\");\n  }\n\n  yr_rule_strings_foreach(rule, string)\n  {\n    // Only the heading fragment in a chain of strings (the one with\n    // chained_to == NULL) must be referenced. All other fragments\n    // are never marked as referenced.\n\n    if (!STRING_IS_REFERENCED(string) && string->chained_to == NULL)\n    {\n      yr_compiler_set_error_extra_info(\n          compiler, string->identifier) return ERROR_UNREFERENCED_STRING;\n    }\n\n    strings_in_rule++;\n\n    if (strings_in_rule > max_strings_per_rule)\n    {\n      yr_compiler_set_error_extra_info(\n          compiler, rule->identifier) return ERROR_TOO_MANY_STRINGS;\n    }\n  }\n\n  FAIL_ON_ERROR(yr_parser_emit_with_arg(\n      yyscanner, OP_MATCH_RULE, compiler->current_rule_idx, NULL, NULL));\n\n  fixup = compiler->fixup_stack_head;\n\n  int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(\n      compiler->arena, &fixup->ref);\n\n  int32_t jmp_offset = yr_arena_get_current_offset(\n                           compiler->arena, YR_CODE_SECTION) -\n                       fixup->ref.offset + 1;\n\n  *jmp_offset_addr = jmp_offset;\n\n  // Remove fixup from the stack.\n  compiler->fixup_stack_head = fixup->next;\n  yr_free(fixup);\n\n  // We have finished parsing the current rule set current_rule_idx to\n  // UINT32_MAX indicating that we are not currently parsing a rule.\n  compiler->current_rule_idx = UINT32_MAX;\n\n  return ERROR_SUCCESS;\n}",
  "abstract_func_before": "int yr_parser_reduce_rule_declaration_phase_2(\n    yyscan_t VAR_0,\n    YR_ARENA_REF* VAR_1)\n{\n  uint32_t VAR_2;\n  uint32_t VAR_3 = 0;\n\n  YR_FIXUP* VAR_4;\n  YR_STRING* VAR_5;\n  YR_COMPILER* VAR_6 = yyget_extra(VAR_0);\n\n  yr_get_configuration(\n      VAR_7, (void*) &VAR_2);\n\n  YR_RULE* VAR_8 = (YR_RULE*) yr_arena_ref_to_ptr(VAR_6->arena, VAR_1);\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n\n  if (VAR_8->num_atoms > VAR_9)\n  {\n    yywarning(VAR_0, \"rule is slowing down scanning\");\n  }\n\n  yr_rule_strings_foreach(VAR_8, VAR_5)\n  {\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n\n    if (!STRING_IS_REFERENCED(VAR_5) && VAR_5->chained_to == NULL)\n    {\n      yr_compiler_set_error_extra_info(\n          VAR_6, VAR_5->identifier) return VAR_10;\n    }\n\n    VAR_3++;\n\n    if (VAR_3 > VAR_2)\n    {\n      yr_compiler_set_error_extra_info(\n          VAR_6, VAR_8->identifier) return VAR_11;\n    }\n  }\n\n  FAIL_ON_ERROR(yr_parser_emit_with_arg(\n      VAR_0, VAR_12, VAR_6->current_rule_idx, NULL, NULL));\n\n  VAR_4 = VAR_6->fixup_stack_head;\n\n  int32_t* VAR_13 = (int32_t*) yr_arena_ref_to_ptr(\n      VAR_6->arena, &VAR_4->ref);\n\n  int32_t VAR_14 = yr_arena_get_current_offset(\n                           VAR_6->arena, VAR_15) -\n                       VAR_4->ref.offset + 1;\n\n  *VAR_13 = VAR_14;\n\n  /* COMMENT_7 */\n  VAR_6->fixup_stack_head = VAR_4->next;\n  yr_free(VAR_4);\n\n  /* COMMENT_8 */\n  /* COMMENT_9 */\n  VAR_6->current_rule_idx = VAR_16;\n\n  return VAR_17;\n}",
  "func_graph_path_before": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/parser.c/vul/before/0.json",
  "func": "int yr_parser_reduce_rule_declaration_phase_2(\n    yyscan_t yyscanner,\n    YR_ARENA_REF* rule_ref)\n{\n  uint32_t max_strings_per_rule;\n  uint32_t strings_in_rule = 0;\n\n  YR_FIXUP* fixup;\n  YR_STRING* string;\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n\n  yr_get_configuration_uint32(\n      YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);\n\n  YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);\n\n  // Show warning if the rule is generating too many atoms. The warning is\n  // shown if the number of atoms is greater than 20 times the maximum number\n  // of strings allowed for a rule, as 20 is minimum number of atoms generated\n  // for a string using *nocase*, *ascii* and *wide* modifiers simultaneously.\n\n  if (rule->num_atoms > YR_ATOMS_PER_RULE_WARNING_THRESHOLD)\n  {\n    yywarning(yyscanner, \"rule is slowing down scanning\");\n  }\n\n  yr_rule_strings_foreach(rule, string)\n  {\n    // Only the heading fragment in a chain of strings (the one with\n    // chained_to == NULL) must be referenced. All other fragments\n    // are never marked as referenced.\n\n    if (!STRING_IS_REFERENCED(string) && string->chained_to == NULL)\n    {\n      yr_compiler_set_error_extra_info(\n          compiler, string->identifier) return ERROR_UNREFERENCED_STRING;\n    }\n\n    strings_in_rule++;\n\n    if (strings_in_rule > max_strings_per_rule)\n    {\n      yr_compiler_set_error_extra_info(\n          compiler, rule->identifier) return ERROR_TOO_MANY_STRINGS;\n    }\n  }\n\n  FAIL_ON_ERROR(yr_parser_emit_with_arg(\n      yyscanner, OP_MATCH_RULE, compiler->current_rule_idx, NULL, NULL));\n\n  fixup = compiler->fixup_stack_head;\n\n  int32_t* jmp_offset_addr = (int32_t*) yr_arena_ref_to_ptr(\n      compiler->arena, &fixup->ref);\n\n  int32_t jmp_offset = yr_arena_get_current_offset(\n                           compiler->arena, YR_CODE_SECTION) -\n                       fixup->ref.offset + 1;\n\n  *jmp_offset_addr = jmp_offset;\n\n  // Remove fixup from the stack.\n  compiler->fixup_stack_head = fixup->next;\n  yr_free(fixup);\n\n  // We have finished parsing the current rule set current_rule_idx to\n  // UINT32_MAX indicating that we are not currently parsing a rule.\n  compiler->current_rule_idx = UINT32_MAX;\n\n  return ERROR_SUCCESS;\n}",
  "abstract_func": "int yr_parser_reduce_rule_declaration_phase_2(\n    yyscan_t VAR_0,\n    YR_ARENA_REF* VAR_1)\n{\n  uint32_t VAR_2;\n  uint32_t VAR_3 = 0;\n\n  YR_FIXUP* VAR_4;\n  YR_STRING* VAR_5;\n  YR_COMPILER* VAR_6 = yyget_extra(VAR_0);\n\n  yr_get_configuration_uint32(\n      VAR_7, &VAR_2);\n\n  YR_RULE* VAR_8 = (YR_RULE*) yr_arena_ref_to_ptr(VAR_6->arena, VAR_1);\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n\n  if (VAR_8->num_atoms > VAR_9)\n  {\n    yywarning(VAR_0, \"rule is slowing down scanning\");\n  }\n\n  yr_rule_strings_foreach(VAR_8, VAR_5)\n  {\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n\n    if (!STRING_IS_REFERENCED(VAR_5) && VAR_5->chained_to == NULL)\n    {\n      yr_compiler_set_error_extra_info(\n          VAR_6, VAR_5->identifier) return VAR_10;\n    }\n\n    VAR_3++;\n\n    if (VAR_3 > VAR_2)\n    {\n      yr_compiler_set_error_extra_info(\n          VAR_6, VAR_8->identifier) return VAR_11;\n    }\n  }\n\n  FAIL_ON_ERROR(yr_parser_emit_with_arg(\n      VAR_0, VAR_12, VAR_6->current_rule_idx, NULL, NULL));\n\n  VAR_4 = VAR_6->fixup_stack_head;\n\n  int32_t* VAR_13 = (int32_t*) yr_arena_ref_to_ptr(\n      VAR_6->arena, &VAR_4->ref);\n\n  int32_t VAR_14 = yr_arena_get_current_offset(\n                           VAR_6->arena, VAR_15) -\n                       VAR_4->ref.offset + 1;\n\n  *VAR_13 = VAR_14;\n\n  /* COMMENT_7 */\n  VAR_6->fixup_stack_head = VAR_4->next;\n  yr_free(VAR_4);\n\n  /* COMMENT_8 */\n  /* COMMENT_9 */\n  VAR_6->current_rule_idx = VAR_16;\n\n  return VAR_17;\n}",
  "func_graph_path": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/parser.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,8 @@\n   YR_STRING* string;\n   YR_COMPILER* compiler = yyget_extra(yyscanner);\n \n-  yr_get_configuration(\n-      YR_CONFIG_MAX_STRINGS_PER_RULE, (void*) &max_strings_per_rule);\n+  yr_get_configuration_uint32(\n+      YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);\n \n   YR_RULE* rule = (YR_RULE*) yr_arena_ref_to_ptr(compiler->arena, rule_ref);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  yr_get_configuration(",
      "      YR_CONFIG_MAX_STRINGS_PER_RULE, (void*) &max_strings_per_rule);"
    ],
    "added_lines": [
      "  yr_get_configuration_uint32(",
      "      YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/VirusTotal/yara/pull/1621: 403 Client Error: Forbidden for url: https://api.github.com/repos/VirusTotal/yara/pulls/1621",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.95  \nThe patch introduces new functions for uint32 and uint64 configurations, which is a feature enhancement without addressing a security issue. The changes are consistent with the description, supporting a high confidence level in classification."
}