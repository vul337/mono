{
  "cve_id": "CVE-2019-16162",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "k-takata/Onigmo",
  "commit_msg": "Fix out-of-bounds read in parse_char_class() (Close #139)\n\n/[\\x{111111}]/ causes out-of-bounds read when encoding is a single byte\nencoding. \\x{111111} is an invalid codepoint for a single byte encoding.\nCheck if it is a valid codepoint.",
  "commit_hash": "d4cf99d30bd5f6a8a4ababd0b9d7b06f3a479a24",
  "git_url": "https://github.com/k-takata/Onigmo/commit/d4cf99d30bd5f6a8a4ababd0b9d7b06f3a479a24",
  "file_path": "regenc.c",
  "func_name": "onigenc_single_byte_code_to_mbc",
  "func_before": "extern int\nonigenc_single_byte_code_to_mbc(OnigCodePoint code, UChar *buf, OnigEncoding enc ARG_UNUSED)\n{\n#ifdef RUBY\n  if (code > 0xff)\n    rb_raise(rb_eRangeError, \"%u out of char range\", code);\n#endif\n  *buf = (UChar )(code & 0xff);\n  return 1;\n}",
  "abstract_func_before": "extern int\nonigenc_single_byte_code_to_mbc(OnigCodePoint VAR_0, UChar *VAR_1, OnigEncoding VAR_2 VAR_3)\n{\n#ifdef VAR_4\n  if (VAR_0 > 0xff)\n    rb_raise(VAR_5, \"%u out of char range\", VAR_0);\n#endif\n  *VAR_1 = (UChar )(VAR_0 & 0xff);\n  return 1;\n}",
  "func_graph_path_before": null,
  "func": "extern int\nonigenc_single_byte_code_to_mbc(OnigCodePoint code, UChar *buf, OnigEncoding enc ARG_UNUSED)\n{\n  if (code > 0xff) {\n#ifdef RUBY\n    rb_raise(rb_eRangeError, \"%u out of char range\", code);\n#else\n    return ONIGERR_INVALID_CODE_POINT_VALUE;\n#endif\n  }\n  *buf = (UChar )(code & 0xff);\n  return 1;\n}",
  "abstract_func": "extern int\nonigenc_single_byte_code_to_mbc(OnigCodePoint VAR_0, UChar *VAR_1, OnigEncoding VAR_2 VAR_3)\n{\n  if (VAR_0 > 0xff) {\n#ifdef VAR_4\n    rb_raise(VAR_5, \"%u out of char range\", VAR_0);\n#else\n    return VAR_6;\n#endif\n  }\n  *VAR_1 = (UChar )(VAR_0 & 0xff);\n  return 1;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,13 @@\n extern int\n onigenc_single_byte_code_to_mbc(OnigCodePoint code, UChar *buf, OnigEncoding enc ARG_UNUSED)\n {\n+  if (code > 0xff) {\n #ifdef RUBY\n-  if (code > 0xff)\n     rb_raise(rb_eRangeError, \"%u out of char range\", code);\n+#else\n+    return ONIGERR_INVALID_CODE_POINT_VALUE;\n #endif\n+  }\n   *buf = (UChar )(code & 0xff);\n   return 1;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  if (code > 0xff)"
    ],
    "added_lines": [
      "  if (code > 0xff) {",
      "#else",
      "    return ONIGERR_INVALID_CODE_POINT_VALUE;",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/k-takata/Onigmo/pull/140",
  "description": {
    "pr_info": {
      "title": "Fix out-of-bounds read in parse_char_class()",
      "number": 140
    },
    "comment": [
      "This fixes #139.\r\n\r\n/[\\x{111111}]/ causes out-of-bounds read when encoding is a single byte\r\nencoding. \\x{111111} is an invalid codepoint for a single byte encoding.\r\nCheck if it is a valid codepoint.",
      "\n[![Coverage Status](https://coveralls.io/builds/24926247/badge)](https://coveralls.io/builds/24926247)\n\nCoverage increased (+0.1%) to 80.904% when pulling **66dbbb428b7a4ca6a7563fc04c6b70dfa64361d1 on fix-139** into **ced209d5e980cd95f86edf680372dc5c91bc6837 on master**.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses an out-of-bounds read vulnerability by adding input validation to prevent invalid codepoints from causing memory issues. This is clearly a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}