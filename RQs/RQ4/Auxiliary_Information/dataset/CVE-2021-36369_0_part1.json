{
  "cve_id": "CVE-2021-36369",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "mkj/dropbear",
  "commit_msg": "rename argument to match with other ssh clients",
  "commit_hash": "adbdb213eb0fe3e982cc57d7ae882c1915bef818",
  "git_url": "https://github.com/mkj/dropbear/commit/adbdb213eb0fe3e982cc57d7ae882c1915bef818",
  "file_path": "cli-runopts.c",
  "func_name": "cli_getopts",
  "func_before": "void cli_getopts(int argc, char ** argv) {\n\tunsigned int i, j;\n\tchar ** next = NULL;\n\tenum {\n\t\tOPT_EXTENDED_OPTIONS,\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tOPT_AUTHKEY,\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tOPT_LOCALTCPFWD,\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tOPT_REMOTETCPFWD,\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tOPT_NETCAT,\n#endif\n\t\t/* a flag (no arg) if 'next' is NULL, a string-valued option otherwise */\n\t\tOPT_OTHER\n\t} opt;\n\tunsigned int cmdlen;\n\n\tchar* recv_window_arg = NULL;\n\tchar* keepalive_arg = NULL;\n\tchar* idle_timeout_arg = NULL;\n\tchar *host_arg = NULL;\n\tchar *bind_arg = NULL;\n\tchar c;\n\n\t/* see printhelp() for options */\n\tcli_opts.progname = argv[0];\n\tcli_opts.remotehost = NULL;\n\tcli_opts.remoteport = NULL;\n\tcli_opts.username = NULL;\n\tcli_opts.cmd = NULL;\n\tcli_opts.no_cmd = 0;\n\tcli_opts.backgrounded = 0;\n\tcli_opts.wantpty = 9; /* 9 means \"it hasn't been touched\", gets set later */\n\tcli_opts.always_accept_key = 0;\n\tcli_opts.no_hostkey_check = 0;\n\tcli_opts.is_subsystem = 0;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_opts.privkeys = list_new();\n#endif\n#if DROPBEAR_CLI_ANYTCPFWD\n\tcli_opts.exit_on_fwd_failure = 0;\n#endif\n\tcli_opts.exit_on_trivial_auth = 0;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\tcli_opts.localfwds = list_new();\n\topts.listen_fwd_all = 0;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\tcli_opts.remotefwds = list_new();\n#endif\n#if DROPBEAR_CLI_AGENTFWD\n\tcli_opts.agent_fwd = 0;\n\tcli_opts.agent_fd = -1;\n\tcli_opts.agent_keys_loaded = 0;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\tcli_opts.proxycmd = NULL;\n#endif\n\tcli_opts.bind_address = NULL;\n\tcli_opts.bind_port = NULL;\n#ifndef DISABLE_ZLIB\n\topts.compress_mode = DROPBEAR_COMPRESS_ON;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\topts.cipher_list = NULL;\n\topts.mac_list = NULL;\n#endif\n#ifndef DISABLE_SYSLOG\n\topts.usingsyslog = 0;\n#endif\n\t/* not yet\n\topts.ipv4 = 1;\n\topts.ipv6 = 1;\n\t*/\n\topts.recv_window = DEFAULT_RECV_WINDOW;\n\topts.keepalive_secs = DEFAULT_KEEPALIVE;\n\topts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;\n\n\tfill_own_user();\n\n\tfor (i = 1; i < (unsigned int)argc; i++) {\n\t\t/* Handle non-flag arguments such as hostname or commands for the remote host */\n\t\tif (argv[i][0] != '-')\n\t\t{\n\t\t\tif (host_arg == NULL) {\n\t\t\t\thost_arg = argv[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Commands to pass to the remote host. No more flag handling,\n\t\t\tcommands are consumed below */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Begins with '-' */\n\t\topt = OPT_OTHER;\n\t\tfor (j = 1; (c = argv[i][j]) != '\\0' && !next && opt == OPT_OTHER; j++) {\n\t\t\tswitch (c) {\n\t\t\t\tcase 'y': /* always accept the remote hostkey */\n\t\t\t\t\tif (cli_opts.always_accept_key) {\n\t\t\t\t\t\t/* twice means no checking at all */\n\t\t\t\t\t\tcli_opts.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcli_opts.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* remoteport */\n\t\t\t\t\tnext = (char**)&cli_opts.remoteport;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\t\t\tcase 'i': /* an identityfile */\n\t\t\t\t\topt = OPT_AUTHKEY;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* we want a pty */\n\t\t\t\t\tcli_opts.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* don't want a pty */\n\t\t\t\t\tcli_opts.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tcli_opts.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tcli_opts.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcli_opts.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\topt = OPT_EXTENDED_OPTIONS;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n\t\t\t\t\topt = OPT_LOCALTCPFWD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\topts.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n\t\t\t\t\topt = OPT_REMOTETCPFWD;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\t\t\tcase 'B':\n\t\t\t\t\topt = OPT_NETCAT;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\t\t\t\tcase 'J':\n\t\t\t\t\tnext = &cli_opts.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tnext = &cli_opts.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* backwards compatibility with old urandom option */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tnext = &recv_window_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tnext = &keepalive_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tnext = &idle_timeout_arg;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_AGENTFWD\n\t\t\t\tcase 'A':\n\t\t\t\t\tcli_opts.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\t\tnext = &opts.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tnext = &opts.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if DEBUG_TRACE\n\t\t\t\tcase 'v':\n\t\t\t\t\tdebug_trace = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n#endif\n#if !DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tnext = &bind_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", c);\n\t\t\t\t\tbreak;\n\t\t\t} /* Switch */\n\t\t}\n\n\t\tif (!next && opt == OPT_OTHER) /* got a flag */\n\t\t\tcontinue;\n\n\t\tif (c == '\\0') {\n\t\t\ti++;\n\t\t\tj = 0;\n\t\t\tif (!argv[i])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (opt == OPT_EXTENDED_OPTIONS) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&argv[i][j]);\n\t\t}\n\t\telse\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tif (opt == OPT_AUTHKEY) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&argv[i][j], 1);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tif (opt == OPT_REMOTETCPFWD) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tif (opt == OPT_LOCALTCPFWD) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.localfwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tif (opt == OPT_NETCAT) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&argv[i][j]);\n\t\t}\n\t\telse\n#endif\n\t\tif (next) {\n\t\t\t/* The previous flag set a value to assign */\n\t\t\t*next = &argv[i][j];\n\t\t\tif (*next == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tnext = NULL;\n\t\t}\n\t}\n\n#if DROPBEAR_USER_ALGO_LIST\n\t/* -c help doesn't need a hostname */\n\tparse_ciphers_macs();\n#endif\n\n\t/* Done with options/flags; now handle the hostname (which may not\n\t * start with a hyphen) and optional command */\n\n\tif (host_arg == NULL) { /* missing hostname */\n\t\tprinthelp();\n\t\texit(EXIT_FAILURE);\n\t}\n\tTRACE((\"host is: %s\", host_arg))\n\n\tif (i < (unsigned int)argc) {\n\t\t/* Build the command to send */\n\t\tcmdlen = 0;\n\t\tfor (j = i; j < (unsigned int)argc; j++)\n\t\t\tcmdlen += strlen(argv[j]) + 1; /* +1 for spaces */\n\n\t\t/* Allocate the space */\n\t\tcli_opts.cmd = (char*)m_malloc(cmdlen);\n\t\tcli_opts.cmd[0] = '\\0';\n\n\t\t/* Append all the bits */\n\t\tfor (j = i; j < (unsigned int)argc; j++) {\n\t\t\tstrlcat(cli_opts.cmd, argv[j], cmdlen);\n\t\t\tstrlcat(cli_opts.cmd, \" \", cmdlen);\n\t\t}\n\t\t/* It'll be null-terminated here */\n\t\tTRACE((\"cmd is: %s\", cli_opts.cmd))\n\t}\n\n\t/* And now a few sanity checks and setup */\n\n#if DROPBEAR_CLI_PROXYCMD                                                                                                                                   \n\tif (cli_opts.proxycmd) {\n\t\t/* To match the common path of m_freeing it */\n\t\tcli_opts.proxycmd = m_strdup(cli_opts.proxycmd);\n\t}\n#endif\n\n\tif (cli_opts.remoteport == NULL) {\n\t\tcli_opts.remoteport = \"22\";\n\t}\n\n\tif (bind_arg) {\n\t\t/* split [host][:port] */\n\t\tchar *port = strrchr(bind_arg, ':');\n\t\tif (port) {\n\t\t\tcli_opts.bind_port = m_strdup(port+1);\n\t\t\t*port = '\\0';\n\t\t}\n\t\tif (strlen(bind_arg) > 0) {\n\t\t\tcli_opts.bind_address = m_strdup(bind_arg);\n\t\t}\n\t}\n\n\t/* If not explicitly specified with -t or -T, we don't want a pty if\n\t * there's a command, but we do otherwise */\n\tif (cli_opts.wantpty == 9) {\n\t\tif (cli_opts.cmd == NULL) {\n\t\t\tcli_opts.wantpty = 1;\n\t\t} else {\n\t\t\tcli_opts.wantpty = 0;\n\t\t}\n\t}\n\n\tif (cli_opts.backgrounded && cli_opts.cmd == NULL\n\t\t\t&& cli_opts.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (recv_window_arg) {\n\t\topts.recv_window = atol(recv_window_arg);\n\t\tif (opts.recv_window == 0 || opts.recv_window > MAX_RECV_WINDOW) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", recv_window_arg);\n\t\t}\n\t}\n\tif (keepalive_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", keepalive_arg);\n\t\t}\n\t\topts.keepalive_secs = val;\n\t}\n\n\tif (idle_timeout_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", idle_timeout_arg);\n\t\t}\n\t\topts.idle_timeout_secs = val;\n\t}\n\n#if DROPBEAR_CLI_NETCAT\n\tif (cli_opts.cmd && cli_opts.netcat_host) {\n\t\tdropbear_log(LOG_INFO, \"Ignoring command '%s' in netcat mode\", cli_opts.cmd);\n\t}\n#endif\n\n#if (DROPBEAR_CLI_PUBKEY_AUTH)\n\t{\n\t\tchar *expand_path = expand_homedir_path(DROPBEAR_DEFAULT_CLI_AUTHKEY);\n\t\tloadidentityfile(expand_path, 0);\n\t\tm_free(expand_path);\n\t}\n#endif\n\n\t/* The hostname gets set up last, since\n\t * in multi-hop mode it will require knowledge\n\t * of other flags such as -i */\n#if DROPBEAR_CLI_MULTIHOP\n\tparse_multihop_hostname(host_arg, argv[0]);\n#else\n\tparse_hostname(host_arg);\n#endif\n}",
  "abstract_func_before": "void cli_getopts(int VAR_0, char ** VAR_1) {\n\tunsigned int VAR_2, VAR_3;\n\tchar ** VAR_4 = NULL;\n\tenum {\n\t\tVAR_5,\n#if VAR_6\n\t\tVAR_7,\n#endif\n#if VAR_8\n\t\tVAR_9,\n#endif\n#if VAR_10\n\t\tVAR_11,\n#endif\n#if VAR_12\n\t\tVAR_13,\n#endif\n\t\t/* COMMENT_0 */\n\t\tVAR_14\n\t} VAR_15;\n\tunsigned int VAR_16;\n\n\tchar* VAR_17 = NULL;\n\tchar* VAR_18 = NULL;\n\tchar* VAR_19 = NULL;\n\tchar *VAR_20 = NULL;\n\tchar *VAR_21 = NULL;\n\tchar VAR_22;\n\n\t/* COMMENT_1 */\n\tVAR_23.progname = VAR_1[0];\n\tVAR_23.remotehost = NULL;\n\tVAR_23.remoteport = NULL;\n\tVAR_23.username = NULL;\n\tVAR_23.cmd = NULL;\n\tVAR_23.no_cmd = 0;\n\tVAR_23.backgrounded = 0;\n\tVAR_23.wantpty = 9; /* COMMENT_2 */\n\tVAR_23.always_accept_key = 0;\n\tVAR_23.no_hostkey_check = 0;\n\tVAR_23.is_subsystem = 0;\n#if VAR_6\n\tVAR_23.privkeys = list_new();\n#endif\n#if VAR_24\n\tVAR_23.exit_on_fwd_failure = 0;\n#endif\n\tVAR_23.exit_on_trivial_auth = 0;\n#if VAR_8\n\tVAR_23.localfwds = list_new();\n\tVAR_25.listen_fwd_all = 0;\n#endif\n#if VAR_10\n\tVAR_23.remotefwds = list_new();\n#endif\n#if VAR_26\n\tVAR_23.agent_fwd = 0;\n\tVAR_23.agent_fd = -1;\n\tVAR_23.agent_keys_loaded = 0;\n#endif\n#if VAR_27\n\tVAR_23.proxycmd = NULL;\n#endif\n\tVAR_23.bind_address = NULL;\n\tVAR_23.bind_port = NULL;\n#ifndef VAR_28\n\tVAR_25.compress_mode = VAR_29;\n#endif\n#if VAR_30\n\tVAR_25.cipher_list = NULL;\n\tVAR_25.mac_list = NULL;\n#endif\n#ifndef VAR_31\n\tVAR_25.usingsyslog = 0;\n#endif\n\t/* COMMENT_3 */\n               \n               \n   \n\tVAR_25.recv_window = VAR_32;\n\tVAR_25.keepalive_secs = VAR_33;\n\tVAR_25.idle_timeout_secs = VAR_34;\n\n\tfill_own_user();\n\n\tfor (VAR_2 = 1; VAR_2 < (unsigned int)VAR_0; VAR_2++) {\n\t\t/* COMMENT_7 */\n\t\tif (VAR_1[VAR_2][0] != '-')\n\t\t{\n\t\t\tif (VAR_20 == NULL) {\n\t\t\t\tVAR_20 = VAR_1[VAR_2];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n                                 \n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_10 */\n\t\tVAR_15 = VAR_14;\n\t\tfor (VAR_3 = 1; (VAR_22 = VAR_1[VAR_2][VAR_3]) != '\\0' && !VAR_4 && VAR_15 == VAR_14; VAR_3++) {\n\t\t\tswitch (VAR_22) {\n\t\t\t\tcase 'y': /* COMMENT_11 */\n\t\t\t\t\tif (VAR_23.always_accept_key) {\n\t\t\t\t\t\t/* COMMENT_12 */\n\t\t\t\t\t\tVAR_23.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_23.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* COMMENT_13 */\n\t\t\t\t\tVAR_4 = (char**)&VAR_23.remoteport;\n\t\t\t\t\tbreak;\n#if VAR_6\n\t\t\t\tcase 'i': /* COMMENT_14 */\n\t\t\t\t\tVAR_15 = VAR_7;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* COMMENT_15 */\n\t\t\t\t\tVAR_23.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* COMMENT_16 */\n\t\t\t\t\tVAR_23.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tVAR_23.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tVAR_23.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tVAR_23.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\tVAR_15 = VAR_5;\n\t\t\t\t\tbreak;\n#if VAR_8\n\t\t\t\tcase 'L':\n\t\t\t\t\tVAR_15 = VAR_9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\tVAR_25.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_10\n\t\t\t\tcase 'R':\n\t\t\t\t\tVAR_15 = VAR_11;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_12\n\t\t\t\tcase 'B':\n\t\t\t\t\tVAR_15 = VAR_13;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_27\n\t\t\t\tcase 'J':\n\t\t\t\t\tVAR_4 = &VAR_23.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tVAR_4 = &VAR_23.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(VAR_35);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* COMMENT_17 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tVAR_4 = &VAR_17;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tVAR_4 = &VAR_18;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tVAR_4 = &VAR_19;\n\t\t\t\t\tbreak;\n#if VAR_26\n\t\t\t\tcase 'A':\n\t\t\t\t\tVAR_23.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_30\n\t\t\t\tcase 'c':\n\t\t\t\t\tVAR_4 = &VAR_25.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tVAR_4 = &VAR_25.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_36\n\t\t\t\tcase 'v':\n\t\t\t\t\tVAR_37 = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !VAR_30\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !VAR_10\n\t\t\t\tcase 'R':\n#endif\n#if !VAR_8\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(VAR_35);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tVAR_4 = &VAR_21;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(VAR_38,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", VAR_22);\n\t\t\t\t\tbreak;\n\t\t\t} /* COMMENT_18 */\n\t\t}\n\n\t\tif (!VAR_4 && VAR_15 == VAR_14) /* COMMENT_19 */\n\t\t\tcontinue;\n\n\t\tif (VAR_22 == '\\0') {\n\t\t\tVAR_2++;\n\t\t\tVAR_3 = 0;\n\t\t\tif (!VAR_1[VAR_2])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (VAR_15 == VAR_5) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&VAR_1[VAR_2][VAR_3]);\n\t\t}\n\t\telse\n#if VAR_6\n\t\tif (VAR_15 == VAR_7) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&VAR_1[VAR_2][VAR_3], 1);\n\t\t}\n\t\telse\n#endif\n#if VAR_10\n\t\tif (VAR_15 == VAR_11) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&VAR_1[VAR_2][VAR_3], VAR_23.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if VAR_8\n\t\tif (VAR_15 == VAR_9) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&VAR_1[VAR_2][VAR_3], VAR_23.localfwds);\n\t\t}\n\t\telse\n#endif\n#if VAR_12\n\t\tif (VAR_15 == VAR_13) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&VAR_1[VAR_2][VAR_3]);\n\t\t}\n\t\telse\n#endif\n\t\tif (VAR_4) {\n\t\t\t/* COMMENT_20 */\n\t\t\t*VAR_4 = &VAR_1[VAR_2][VAR_3];\n\t\t\tif (*VAR_4 == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tVAR_4 = NULL;\n\t\t}\n\t}\n\n#if VAR_30\n\t/* COMMENT_21 */\n\tparse_ciphers_macs();\n#endif\n\n\t/* COMMENT_22 */\n                                                \n\n\tif (VAR_20 == NULL) { /* COMMENT_24 */\n\t\tprinthelp();\n\t\texit(VAR_39);\n\t}\n\tTRACE((\"host is: %s\", VAR_20))\n\n\tif (VAR_2 < (unsigned int)VAR_0) {\n\t\t/* COMMENT_25 */\n\t\tVAR_16 = 0;\n\t\tfor (VAR_3 = VAR_2; VAR_3 < (unsigned int)VAR_0; VAR_3++)\n\t\t\tVAR_16 += strlen(VAR_1[VAR_3]) + 1; /* COMMENT_26 */\n\n\t\t/* COMMENT_27 */\n\t\tVAR_23.cmd = (char*)m_malloc(VAR_16);\n\t\tVAR_23.cmd[0] = '\\0';\n\n\t\t/* COMMENT_28 */\n\t\tfor (VAR_3 = VAR_2; VAR_3 < (unsigned int)VAR_0; VAR_3++) {\n\t\t\tstrlcat(VAR_23.cmd, VAR_1[VAR_3], VAR_16);\n\t\t\tstrlcat(VAR_23.cmd, \" \", VAR_16);\n\t\t}\n\t\t/* COMMENT_29 */\n\t\tTRACE((\"cmd is: %s\", VAR_23.cmd))\n\t}\n\n\t/* COMMENT_30 */\n\n#if VAR_27                                                                                                                                   \n\tif (VAR_23.proxycmd) {\n\t\t/* COMMENT_31 */\n\t\tVAR_23.proxycmd = m_strdup(VAR_23.proxycmd);\n\t}\n#endif\n\n\tif (VAR_23.remoteport == NULL) {\n\t\tVAR_23.remoteport = \"22\";\n\t}\n\n\tif (VAR_21) {\n\t\t/* COMMENT_32 */\n\t\tchar *VAR_40 = strrchr(VAR_21, ':');\n\t\tif (VAR_40) {\n\t\t\tVAR_23.bind_port = m_strdup(VAR_40+1);\n\t\t\t*VAR_40 = '\\0';\n\t\t}\n\t\tif (strlen(VAR_21) > 0) {\n\t\t\tVAR_23.bind_address = m_strdup(VAR_21);\n\t\t}\n\t}\n\n\t/* COMMENT_33 */\n                                             \n\tif (VAR_23.wantpty == 9) {\n\t\tif (VAR_23.cmd == NULL) {\n\t\t\tVAR_23.wantpty = 1;\n\t\t} else {\n\t\t\tVAR_23.wantpty = 0;\n\t\t}\n\t}\n\n\tif (VAR_23.backgrounded && VAR_23.cmd == NULL\n\t\t\t&& VAR_23.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (VAR_17) {\n\t\tVAR_25.recv_window = atol(VAR_17);\n\t\tif (VAR_25.recv_window == 0 || VAR_25.recv_window > VAR_41) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", VAR_17);\n\t\t}\n\t}\n\tif (VAR_18) {\n\t\tunsigned int VAR_42;\n\t\tif (m_str_to_uint(VAR_18, &VAR_42) == VAR_43) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", VAR_18);\n\t\t}\n\t\tVAR_25.keepalive_secs = VAR_42;\n\t}\n\n\tif (VAR_19) {\n\t\tunsigned int VAR_42;\n\t\tif (m_str_to_uint(VAR_19, &VAR_42) == VAR_43) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", VAR_19);\n\t\t}\n\t\tVAR_25.idle_timeout_secs = VAR_42;\n\t}\n\n#if VAR_12\n\tif (VAR_23.cmd && VAR_23.netcat_host) {\n\t\tdropbear_log(VAR_44, \"Ignoring command '%s' in netcat mode\", VAR_23.cmd);\n\t}\n#endif\n\n#if (VAR_6)\n\t{\n\t\tchar *VAR_45 = expand_homedir_path(VAR_46);\n\t\tloadidentityfile(VAR_45, 0);\n\t\tm_free(VAR_45);\n\t}\n#endif\n\n\t/* COMMENT_35 */\n                                               \n                                \n#if VAR_47\n\tparse_multihop_hostname(VAR_20, VAR_1[0]);\n#else\n\tparse_hostname(VAR_20);\n#endif\n}",
  "func_graph_path_before": "mkj/dropbear/adbdb213eb0fe3e982cc57d7ae882c1915bef818/cli-runopts.c/vul/before/1.json",
  "func": "void cli_getopts(int argc, char ** argv) {\n\tunsigned int i, j;\n\tchar ** next = NULL;\n\tenum {\n\t\tOPT_EXTENDED_OPTIONS,\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tOPT_AUTHKEY,\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tOPT_LOCALTCPFWD,\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tOPT_REMOTETCPFWD,\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tOPT_NETCAT,\n#endif\n\t\t/* a flag (no arg) if 'next' is NULL, a string-valued option otherwise */\n\t\tOPT_OTHER\n\t} opt;\n\tunsigned int cmdlen;\n\n\tchar* recv_window_arg = NULL;\n\tchar* keepalive_arg = NULL;\n\tchar* idle_timeout_arg = NULL;\n\tchar *host_arg = NULL;\n\tchar *bind_arg = NULL;\n\tchar c;\n\n\t/* see printhelp() for options */\n\tcli_opts.progname = argv[0];\n\tcli_opts.remotehost = NULL;\n\tcli_opts.remoteport = NULL;\n\tcli_opts.username = NULL;\n\tcli_opts.cmd = NULL;\n\tcli_opts.no_cmd = 0;\n\tcli_opts.backgrounded = 0;\n\tcli_opts.wantpty = 9; /* 9 means \"it hasn't been touched\", gets set later */\n\tcli_opts.always_accept_key = 0;\n\tcli_opts.no_hostkey_check = 0;\n\tcli_opts.is_subsystem = 0;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_opts.privkeys = list_new();\n#endif\n#if DROPBEAR_CLI_ANYTCPFWD\n\tcli_opts.exit_on_fwd_failure = 0;\n#endif\n\tcli_opts.disable_trivial_auth = 0;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\tcli_opts.localfwds = list_new();\n\topts.listen_fwd_all = 0;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\tcli_opts.remotefwds = list_new();\n#endif\n#if DROPBEAR_CLI_AGENTFWD\n\tcli_opts.agent_fwd = 0;\n\tcli_opts.agent_fd = -1;\n\tcli_opts.agent_keys_loaded = 0;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\tcli_opts.proxycmd = NULL;\n#endif\n\tcli_opts.bind_address = NULL;\n\tcli_opts.bind_port = NULL;\n#ifndef DISABLE_ZLIB\n\topts.compress_mode = DROPBEAR_COMPRESS_ON;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\topts.cipher_list = NULL;\n\topts.mac_list = NULL;\n#endif\n#ifndef DISABLE_SYSLOG\n\topts.usingsyslog = 0;\n#endif\n\t/* not yet\n\topts.ipv4 = 1;\n\topts.ipv6 = 1;\n\t*/\n\topts.recv_window = DEFAULT_RECV_WINDOW;\n\topts.keepalive_secs = DEFAULT_KEEPALIVE;\n\topts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;\n\n\tfill_own_user();\n\n\tfor (i = 1; i < (unsigned int)argc; i++) {\n\t\t/* Handle non-flag arguments such as hostname or commands for the remote host */\n\t\tif (argv[i][0] != '-')\n\t\t{\n\t\t\tif (host_arg == NULL) {\n\t\t\t\thost_arg = argv[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Commands to pass to the remote host. No more flag handling,\n\t\t\tcommands are consumed below */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Begins with '-' */\n\t\topt = OPT_OTHER;\n\t\tfor (j = 1; (c = argv[i][j]) != '\\0' && !next && opt == OPT_OTHER; j++) {\n\t\t\tswitch (c) {\n\t\t\t\tcase 'y': /* always accept the remote hostkey */\n\t\t\t\t\tif (cli_opts.always_accept_key) {\n\t\t\t\t\t\t/* twice means no checking at all */\n\t\t\t\t\t\tcli_opts.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcli_opts.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* remoteport */\n\t\t\t\t\tnext = (char**)&cli_opts.remoteport;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\t\t\tcase 'i': /* an identityfile */\n\t\t\t\t\topt = OPT_AUTHKEY;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* we want a pty */\n\t\t\t\t\tcli_opts.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* don't want a pty */\n\t\t\t\t\tcli_opts.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tcli_opts.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tcli_opts.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcli_opts.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\topt = OPT_EXTENDED_OPTIONS;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n\t\t\t\t\topt = OPT_LOCALTCPFWD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\topts.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n\t\t\t\t\topt = OPT_REMOTETCPFWD;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\t\t\tcase 'B':\n\t\t\t\t\topt = OPT_NETCAT;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\t\t\t\tcase 'J':\n\t\t\t\t\tnext = &cli_opts.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tnext = &cli_opts.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* backwards compatibility with old urandom option */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tnext = &recv_window_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tnext = &keepalive_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tnext = &idle_timeout_arg;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_AGENTFWD\n\t\t\t\tcase 'A':\n\t\t\t\t\tcli_opts.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\t\tnext = &opts.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tnext = &opts.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if DEBUG_TRACE\n\t\t\t\tcase 'v':\n\t\t\t\t\tdebug_trace = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n#endif\n#if !DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tnext = &bind_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", c);\n\t\t\t\t\tbreak;\n\t\t\t} /* Switch */\n\t\t}\n\n\t\tif (!next && opt == OPT_OTHER) /* got a flag */\n\t\t\tcontinue;\n\n\t\tif (c == '\\0') {\n\t\t\ti++;\n\t\t\tj = 0;\n\t\t\tif (!argv[i])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (opt == OPT_EXTENDED_OPTIONS) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&argv[i][j]);\n\t\t}\n\t\telse\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tif (opt == OPT_AUTHKEY) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&argv[i][j], 1);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tif (opt == OPT_REMOTETCPFWD) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tif (opt == OPT_LOCALTCPFWD) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.localfwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tif (opt == OPT_NETCAT) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&argv[i][j]);\n\t\t}\n\t\telse\n#endif\n\t\tif (next) {\n\t\t\t/* The previous flag set a value to assign */\n\t\t\t*next = &argv[i][j];\n\t\t\tif (*next == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tnext = NULL;\n\t\t}\n\t}\n\n#if DROPBEAR_USER_ALGO_LIST\n\t/* -c help doesn't need a hostname */\n\tparse_ciphers_macs();\n#endif\n\n\t/* Done with options/flags; now handle the hostname (which may not\n\t * start with a hyphen) and optional command */\n\n\tif (host_arg == NULL) { /* missing hostname */\n\t\tprinthelp();\n\t\texit(EXIT_FAILURE);\n\t}\n\tTRACE((\"host is: %s\", host_arg))\n\n\tif (i < (unsigned int)argc) {\n\t\t/* Build the command to send */\n\t\tcmdlen = 0;\n\t\tfor (j = i; j < (unsigned int)argc; j++)\n\t\t\tcmdlen += strlen(argv[j]) + 1; /* +1 for spaces */\n\n\t\t/* Allocate the space */\n\t\tcli_opts.cmd = (char*)m_malloc(cmdlen);\n\t\tcli_opts.cmd[0] = '\\0';\n\n\t\t/* Append all the bits */\n\t\tfor (j = i; j < (unsigned int)argc; j++) {\n\t\t\tstrlcat(cli_opts.cmd, argv[j], cmdlen);\n\t\t\tstrlcat(cli_opts.cmd, \" \", cmdlen);\n\t\t}\n\t\t/* It'll be null-terminated here */\n\t\tTRACE((\"cmd is: %s\", cli_opts.cmd))\n\t}\n\n\t/* And now a few sanity checks and setup */\n\n#if DROPBEAR_CLI_PROXYCMD                                                                                                                                   \n\tif (cli_opts.proxycmd) {\n\t\t/* To match the common path of m_freeing it */\n\t\tcli_opts.proxycmd = m_strdup(cli_opts.proxycmd);\n\t}\n#endif\n\n\tif (cli_opts.remoteport == NULL) {\n\t\tcli_opts.remoteport = \"22\";\n\t}\n\n\tif (bind_arg) {\n\t\t/* split [host][:port] */\n\t\tchar *port = strrchr(bind_arg, ':');\n\t\tif (port) {\n\t\t\tcli_opts.bind_port = m_strdup(port+1);\n\t\t\t*port = '\\0';\n\t\t}\n\t\tif (strlen(bind_arg) > 0) {\n\t\t\tcli_opts.bind_address = m_strdup(bind_arg);\n\t\t}\n\t}\n\n\t/* If not explicitly specified with -t or -T, we don't want a pty if\n\t * there's a command, but we do otherwise */\n\tif (cli_opts.wantpty == 9) {\n\t\tif (cli_opts.cmd == NULL) {\n\t\t\tcli_opts.wantpty = 1;\n\t\t} else {\n\t\t\tcli_opts.wantpty = 0;\n\t\t}\n\t}\n\n\tif (cli_opts.backgrounded && cli_opts.cmd == NULL\n\t\t\t&& cli_opts.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (recv_window_arg) {\n\t\topts.recv_window = atol(recv_window_arg);\n\t\tif (opts.recv_window == 0 || opts.recv_window > MAX_RECV_WINDOW) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", recv_window_arg);\n\t\t}\n\t}\n\tif (keepalive_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", keepalive_arg);\n\t\t}\n\t\topts.keepalive_secs = val;\n\t}\n\n\tif (idle_timeout_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", idle_timeout_arg);\n\t\t}\n\t\topts.idle_timeout_secs = val;\n\t}\n\n#if DROPBEAR_CLI_NETCAT\n\tif (cli_opts.cmd && cli_opts.netcat_host) {\n\t\tdropbear_log(LOG_INFO, \"Ignoring command '%s' in netcat mode\", cli_opts.cmd);\n\t}\n#endif\n\n#if (DROPBEAR_CLI_PUBKEY_AUTH)\n\t{\n\t\tchar *expand_path = expand_homedir_path(DROPBEAR_DEFAULT_CLI_AUTHKEY);\n\t\tloadidentityfile(expand_path, 0);\n\t\tm_free(expand_path);\n\t}\n#endif\n\n\t/* The hostname gets set up last, since\n\t * in multi-hop mode it will require knowledge\n\t * of other flags such as -i */\n#if DROPBEAR_CLI_MULTIHOP\n\tparse_multihop_hostname(host_arg, argv[0]);\n#else\n\tparse_hostname(host_arg);\n#endif\n}",
  "abstract_func": "void cli_getopts(int VAR_0, char ** VAR_1) {\n\tunsigned int VAR_2, VAR_3;\n\tchar ** VAR_4 = NULL;\n\tenum {\n\t\tVAR_5,\n#if VAR_6\n\t\tVAR_7,\n#endif\n#if VAR_8\n\t\tVAR_9,\n#endif\n#if VAR_10\n\t\tVAR_11,\n#endif\n#if VAR_12\n\t\tVAR_13,\n#endif\n\t\t/* COMMENT_0 */\n\t\tVAR_14\n\t} VAR_15;\n\tunsigned int VAR_16;\n\n\tchar* VAR_17 = NULL;\n\tchar* VAR_18 = NULL;\n\tchar* VAR_19 = NULL;\n\tchar *VAR_20 = NULL;\n\tchar *VAR_21 = NULL;\n\tchar VAR_22;\n\n\t/* COMMENT_1 */\n\tVAR_23.progname = VAR_1[0];\n\tVAR_23.remotehost = NULL;\n\tVAR_23.remoteport = NULL;\n\tVAR_23.username = NULL;\n\tVAR_23.cmd = NULL;\n\tVAR_23.no_cmd = 0;\n\tVAR_23.backgrounded = 0;\n\tVAR_23.wantpty = 9; /* COMMENT_2 */\n\tVAR_23.always_accept_key = 0;\n\tVAR_23.no_hostkey_check = 0;\n\tVAR_23.is_subsystem = 0;\n#if VAR_6\n\tVAR_23.privkeys = list_new();\n#endif\n#if VAR_24\n\tVAR_23.exit_on_fwd_failure = 0;\n#endif\n\tVAR_23.disable_trivial_auth = 0;\n#if VAR_8\n\tVAR_23.localfwds = list_new();\n\tVAR_25.listen_fwd_all = 0;\n#endif\n#if VAR_10\n\tVAR_23.remotefwds = list_new();\n#endif\n#if VAR_26\n\tVAR_23.agent_fwd = 0;\n\tVAR_23.agent_fd = -1;\n\tVAR_23.agent_keys_loaded = 0;\n#endif\n#if VAR_27\n\tVAR_23.proxycmd = NULL;\n#endif\n\tVAR_23.bind_address = NULL;\n\tVAR_23.bind_port = NULL;\n#ifndef VAR_28\n\tVAR_25.compress_mode = VAR_29;\n#endif\n#if VAR_30\n\tVAR_25.cipher_list = NULL;\n\tVAR_25.mac_list = NULL;\n#endif\n#ifndef VAR_31\n\tVAR_25.usingsyslog = 0;\n#endif\n\t/* COMMENT_3 */\n               \n               \n   \n\tVAR_25.recv_window = VAR_32;\n\tVAR_25.keepalive_secs = VAR_33;\n\tVAR_25.idle_timeout_secs = VAR_34;\n\n\tfill_own_user();\n\n\tfor (VAR_2 = 1; VAR_2 < (unsigned int)VAR_0; VAR_2++) {\n\t\t/* COMMENT_7 */\n\t\tif (VAR_1[VAR_2][0] != '-')\n\t\t{\n\t\t\tif (VAR_20 == NULL) {\n\t\t\t\tVAR_20 = VAR_1[VAR_2];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n                                 \n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_10 */\n\t\tVAR_15 = VAR_14;\n\t\tfor (VAR_3 = 1; (VAR_22 = VAR_1[VAR_2][VAR_3]) != '\\0' && !VAR_4 && VAR_15 == VAR_14; VAR_3++) {\n\t\t\tswitch (VAR_22) {\n\t\t\t\tcase 'y': /* COMMENT_11 */\n\t\t\t\t\tif (VAR_23.always_accept_key) {\n\t\t\t\t\t\t/* COMMENT_12 */\n\t\t\t\t\t\tVAR_23.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_23.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* COMMENT_13 */\n\t\t\t\t\tVAR_4 = (char**)&VAR_23.remoteport;\n\t\t\t\t\tbreak;\n#if VAR_6\n\t\t\t\tcase 'i': /* COMMENT_14 */\n\t\t\t\t\tVAR_15 = VAR_7;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* COMMENT_15 */\n\t\t\t\t\tVAR_23.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* COMMENT_16 */\n\t\t\t\t\tVAR_23.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tVAR_23.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tVAR_23.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tVAR_23.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\tVAR_15 = VAR_5;\n\t\t\t\t\tbreak;\n#if VAR_8\n\t\t\t\tcase 'L':\n\t\t\t\t\tVAR_15 = VAR_9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\tVAR_25.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_10\n\t\t\t\tcase 'R':\n\t\t\t\t\tVAR_15 = VAR_11;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_12\n\t\t\t\tcase 'B':\n\t\t\t\t\tVAR_15 = VAR_13;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_27\n\t\t\t\tcase 'J':\n\t\t\t\t\tVAR_4 = &VAR_23.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tVAR_4 = &VAR_23.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(VAR_35);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* COMMENT_17 */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tVAR_4 = &VAR_17;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tVAR_4 = &VAR_18;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tVAR_4 = &VAR_19;\n\t\t\t\t\tbreak;\n#if VAR_26\n\t\t\t\tcase 'A':\n\t\t\t\t\tVAR_23.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_30\n\t\t\t\tcase 'c':\n\t\t\t\t\tVAR_4 = &VAR_25.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tVAR_4 = &VAR_25.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if VAR_36\n\t\t\t\tcase 'v':\n\t\t\t\t\tVAR_37 = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !VAR_30\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !VAR_10\n\t\t\t\tcase 'R':\n#endif\n#if !VAR_8\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(VAR_35);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tVAR_4 = &VAR_21;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(VAR_38,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", VAR_22);\n\t\t\t\t\tbreak;\n\t\t\t} /* COMMENT_18 */\n\t\t}\n\n\t\tif (!VAR_4 && VAR_15 == VAR_14) /* COMMENT_19 */\n\t\t\tcontinue;\n\n\t\tif (VAR_22 == '\\0') {\n\t\t\tVAR_2++;\n\t\t\tVAR_3 = 0;\n\t\t\tif (!VAR_1[VAR_2])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (VAR_15 == VAR_5) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&VAR_1[VAR_2][VAR_3]);\n\t\t}\n\t\telse\n#if VAR_6\n\t\tif (VAR_15 == VAR_7) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&VAR_1[VAR_2][VAR_3], 1);\n\t\t}\n\t\telse\n#endif\n#if VAR_10\n\t\tif (VAR_15 == VAR_11) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&VAR_1[VAR_2][VAR_3], VAR_23.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if VAR_8\n\t\tif (VAR_15 == VAR_9) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&VAR_1[VAR_2][VAR_3], VAR_23.localfwds);\n\t\t}\n\t\telse\n#endif\n#if VAR_12\n\t\tif (VAR_15 == VAR_13) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&VAR_1[VAR_2][VAR_3]);\n\t\t}\n\t\telse\n#endif\n\t\tif (VAR_4) {\n\t\t\t/* COMMENT_20 */\n\t\t\t*VAR_4 = &VAR_1[VAR_2][VAR_3];\n\t\t\tif (*VAR_4 == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tVAR_4 = NULL;\n\t\t}\n\t}\n\n#if VAR_30\n\t/* COMMENT_21 */\n\tparse_ciphers_macs();\n#endif\n\n\t/* COMMENT_22 */\n                                                \n\n\tif (VAR_20 == NULL) { /* COMMENT_24 */\n\t\tprinthelp();\n\t\texit(VAR_39);\n\t}\n\tTRACE((\"host is: %s\", VAR_20))\n\n\tif (VAR_2 < (unsigned int)VAR_0) {\n\t\t/* COMMENT_25 */\n\t\tVAR_16 = 0;\n\t\tfor (VAR_3 = VAR_2; VAR_3 < (unsigned int)VAR_0; VAR_3++)\n\t\t\tVAR_16 += strlen(VAR_1[VAR_3]) + 1; /* COMMENT_26 */\n\n\t\t/* COMMENT_27 */\n\t\tVAR_23.cmd = (char*)m_malloc(VAR_16);\n\t\tVAR_23.cmd[0] = '\\0';\n\n\t\t/* COMMENT_28 */\n\t\tfor (VAR_3 = VAR_2; VAR_3 < (unsigned int)VAR_0; VAR_3++) {\n\t\t\tstrlcat(VAR_23.cmd, VAR_1[VAR_3], VAR_16);\n\t\t\tstrlcat(VAR_23.cmd, \" \", VAR_16);\n\t\t}\n\t\t/* COMMENT_29 */\n\t\tTRACE((\"cmd is: %s\", VAR_23.cmd))\n\t}\n\n\t/* COMMENT_30 */\n\n#if VAR_27                                                                                                                                   \n\tif (VAR_23.proxycmd) {\n\t\t/* COMMENT_31 */\n\t\tVAR_23.proxycmd = m_strdup(VAR_23.proxycmd);\n\t}\n#endif\n\n\tif (VAR_23.remoteport == NULL) {\n\t\tVAR_23.remoteport = \"22\";\n\t}\n\n\tif (VAR_21) {\n\t\t/* COMMENT_32 */\n\t\tchar *VAR_40 = strrchr(VAR_21, ':');\n\t\tif (VAR_40) {\n\t\t\tVAR_23.bind_port = m_strdup(VAR_40+1);\n\t\t\t*VAR_40 = '\\0';\n\t\t}\n\t\tif (strlen(VAR_21) > 0) {\n\t\t\tVAR_23.bind_address = m_strdup(VAR_21);\n\t\t}\n\t}\n\n\t/* COMMENT_33 */\n                                             \n\tif (VAR_23.wantpty == 9) {\n\t\tif (VAR_23.cmd == NULL) {\n\t\t\tVAR_23.wantpty = 1;\n\t\t} else {\n\t\t\tVAR_23.wantpty = 0;\n\t\t}\n\t}\n\n\tif (VAR_23.backgrounded && VAR_23.cmd == NULL\n\t\t\t&& VAR_23.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (VAR_17) {\n\t\tVAR_25.recv_window = atol(VAR_17);\n\t\tif (VAR_25.recv_window == 0 || VAR_25.recv_window > VAR_41) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", VAR_17);\n\t\t}\n\t}\n\tif (VAR_18) {\n\t\tunsigned int VAR_42;\n\t\tif (m_str_to_uint(VAR_18, &VAR_42) == VAR_43) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", VAR_18);\n\t\t}\n\t\tVAR_25.keepalive_secs = VAR_42;\n\t}\n\n\tif (VAR_19) {\n\t\tunsigned int VAR_42;\n\t\tif (m_str_to_uint(VAR_19, &VAR_42) == VAR_43) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", VAR_19);\n\t\t}\n\t\tVAR_25.idle_timeout_secs = VAR_42;\n\t}\n\n#if VAR_12\n\tif (VAR_23.cmd && VAR_23.netcat_host) {\n\t\tdropbear_log(VAR_44, \"Ignoring command '%s' in netcat mode\", VAR_23.cmd);\n\t}\n#endif\n\n#if (VAR_6)\n\t{\n\t\tchar *VAR_45 = expand_homedir_path(VAR_46);\n\t\tloadidentityfile(VAR_45, 0);\n\t\tm_free(VAR_45);\n\t}\n#endif\n\n\t/* COMMENT_35 */\n                                               \n                                \n#if VAR_47\n\tparse_multihop_hostname(VAR_20, VAR_1[0]);\n#else\n\tparse_hostname(VAR_20);\n#endif\n}",
  "func_graph_path": "mkj/dropbear/adbdb213eb0fe3e982cc57d7ae882c1915bef818/cli-runopts.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n #if DROPBEAR_CLI_ANYTCPFWD\n \tcli_opts.exit_on_fwd_failure = 0;\n #endif\n-\tcli_opts.exit_on_trivial_auth = 0;\n+\tcli_opts.disable_trivial_auth = 0;\n #if DROPBEAR_CLI_LOCALTCPFWD\n \tcli_opts.localfwds = list_new();\n \topts.listen_fwd_all = 0;",
  "diff_line_info": {
    "deleted_lines": [
      "\tcli_opts.exit_on_trivial_auth = 0;"
    ],
    "added_lines": [
      "\tcli_opts.disable_trivial_auth = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mkj/dropbear/pull/128",
  "description": {
    "pr_info": {
      "title": "added option to disable trivial auth methods",
      "number": 128
    },
    "comment": [
      "I have added an option ``-o ExitOnTrivialAuth=yes`` to disable trivial authentications as discussed in our mails",
      "I have renamed to argument to ``-o DisableTrivialAuth=yes`` to match OpenSSH's parameter",
      "Would you merge this pull request, because we are planning to create a CVE and I think this should be mitigated before we publish a full disclosure. ",
      "Hello, we are planning to release information about trivial succes authentication. Do you need help with merging the pull requests and creating the new release?"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Supporting & Non-Core Improvements  \n**Confidence:** 0.85  \n\nThe change involves renaming an argument, which is a refactor for consistency rather than a security fix. The lack of code changes beyond renaming and no mention of security in the commit message support this classification."
}