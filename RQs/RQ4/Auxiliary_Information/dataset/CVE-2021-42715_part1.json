{
  "cve_id": "CVE-2021-42715",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "nothings/stb",
  "commit_msg": "Fixes two stb_image issues that could occur with specially constructed HDR and PGM files.\n\nSigned-off-by: Neil Bickford <nbickford@nvidia.com>",
  "commit_hash": "2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6",
  "git_url": "https://github.com/nothings/stb/commit/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6",
  "file_path": "stb_image.h",
  "func_name": "stbi__hdr_load",
  "func_before": "static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}",
  "abstract_func_before": "static float *stbi__hdr_load(stbi__context *VAR_0, int *VAR_1, int *VAR_2, int *VAR_3, int VAR_4, stbi__result_info *VAR_5)\n{\n   char VAR_6[VAR_7];\n   char *VAR_8;\n   int VAR_9 = 0;\n   int VAR_10, VAR_11;\n   stbi_uc *VAR_12;\n   float *VAR_13;\n   int VAR_14;\n   unsigned char VAR_15, VAR_16;\n   int VAR_17, VAR_18, VAR_19, VAR_20,VAR_21, VAR_22;\n   const char *VAR_23;\n   STBI_NOTUSED(VAR_5);\n\n   /* COMMENT_0 */\n   VAR_23 = stbi__hdr_gettoken(VAR_0,VAR_6);\n   if (strcmp(VAR_23, \"#?RADIANCE\") != 0 && strcmp(VAR_23, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   /* COMMENT_1 */\n   for(;;) {\n      VAR_8 = stbi__hdr_gettoken(VAR_0,VAR_6);\n      if (VAR_8[0] == 0) break;\n      if (strcmp(VAR_8, \"FORMAT=32-bit_rle_rgbe\") == 0) VAR_9 = 1;\n   }\n\n   if (!VAR_9)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   /* COMMENT_2 */\n   /* COMMENT_3 */\n   VAR_8 = stbi__hdr_gettoken(VAR_0,VAR_6);\n   if (strncmp(VAR_8, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   VAR_8 += 3;\n   VAR_11 = (int) strtol(VAR_8, &VAR_8, 10);\n   while (*VAR_8 == ' ') ++VAR_8;\n   if (strncmp(VAR_8, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   VAR_8 += 3;\n   VAR_10 = (int) strtol(VAR_8, NULL, 10);\n\n   if (VAR_11 > VAR_24) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (VAR_10 > VAR_24) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *VAR_1 = VAR_10;\n   *VAR_2 = VAR_11;\n\n   if (VAR_3) *VAR_3 = 3;\n   if (VAR_4 == 0) VAR_4 = 3;\n\n   if (!stbi__mad4sizes_valid(VAR_10, VAR_11, VAR_4, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   /* COMMENT_4 */\n   VAR_13 = (float *) stbi__malloc_mad4(VAR_10, VAR_11, VAR_4, sizeof(float), 0);\n   if (!VAR_13)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   /* COMMENT_5 */\n   /* COMMENT_6 */\n   if ( VAR_10 < 8 || VAR_10 >= 32768) {\n      /* COMMENT_7 */\n      for (VAR_18=0; VAR_18 < VAR_11; ++VAR_18) {\n         for (VAR_17=0; VAR_17 < VAR_10; ++VAR_17) {\n            stbi_uc VAR_25[4];\n           main_decode_loop:\n            stbi__getn(VAR_0, VAR_25, 4);\n            stbi__hdr_convert(VAR_13 + VAR_18 * VAR_10 * VAR_4 + VAR_17 * VAR_4, VAR_25, VAR_4);\n         }\n      }\n   } else {\n      /* COMMENT_8 */\n      VAR_12 = NULL;\n\n      for (VAR_18 = 0; VAR_18 < VAR_11; ++VAR_18) {\n         VAR_20 = stbi__get8(VAR_0);\n         VAR_21 = stbi__get8(VAR_0);\n         VAR_14 = stbi__get8(VAR_0);\n         if (VAR_20 != 2 || VAR_21 != 2 || (VAR_14 & 0x80)) {\n            /* COMMENT_9 */\n            /* COMMENT_10 */\n            stbi_uc VAR_25[4];\n            VAR_25[0] = (stbi_uc) VAR_20;\n            VAR_25[1] = (stbi_uc) VAR_21;\n            VAR_25[2] = (stbi_uc) VAR_14;\n            VAR_25[3] = (stbi_uc) stbi__get8(VAR_0);\n            stbi__hdr_convert(VAR_13, VAR_25, VAR_4);\n            VAR_17 = 1;\n            VAR_18 = 0;\n            STBI_FREE(VAR_12);\n            goto main_decode_loop; /* COMMENT_11 */\n         }\n         VAR_14 <<= 8;\n         VAR_14 |= stbi__get8(VAR_0);\n         if (VAR_14 != VAR_10) { STBI_FREE(VAR_13); STBI_FREE(VAR_12); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (VAR_12 == NULL) {\n            VAR_12 = (stbi_uc *) stbi__malloc_mad2(VAR_10, 4, 0);\n            if (!VAR_12) {\n               STBI_FREE(VAR_13);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (VAR_19 = 0; VAR_19 < 4; ++VAR_19) {\n            int VAR_26;\n            VAR_17 = 0;\n            while ((VAR_26 = VAR_10 - VAR_17) > 0) {\n               VAR_15 = stbi__get8(VAR_0);\n               if (VAR_15 > 128) {\n                  /* COMMENT_12 */\n                  VAR_16 = stbi__get8(VAR_0);\n                  VAR_15 -= 128;\n                  if (VAR_15 > VAR_26) { STBI_FREE(VAR_13); STBI_FREE(VAR_12); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (VAR_22 = 0; VAR_22 < VAR_15; ++VAR_22)\n                     VAR_12[VAR_17++ * 4 + VAR_19] = VAR_16;\n               } else {\n                  /* COMMENT_13 */\n                  if (VAR_15 > VAR_26) { STBI_FREE(VAR_13); STBI_FREE(VAR_12); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (VAR_22 = 0; VAR_22 < VAR_15; ++VAR_22)\n                     VAR_12[VAR_17++ * 4 + VAR_19] = stbi__get8(VAR_0);\n               }\n            }\n         }\n         for (VAR_17=0; VAR_17 < VAR_10; ++VAR_17)\n            stbi__hdr_convert(VAR_13+(VAR_18*VAR_10 + VAR_17)*VAR_4, VAR_12 + VAR_17*4, VAR_4);\n      }\n      if (VAR_12)\n         STBI_FREE(VAR_12);\n   }\n\n   return VAR_13;\n}",
  "func_graph_path_before": "nothings/stb/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6/stb_image.h/vul/before/0.json",
  "func": "static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}",
  "abstract_func": "static float *stbi__hdr_load(stbi__context *VAR_0, int *VAR_1, int *VAR_2, int *VAR_3, int VAR_4, stbi__result_info *VAR_5)\n{\n   char VAR_6[VAR_7];\n   char *VAR_8;\n   int VAR_9 = 0;\n   int VAR_10, VAR_11;\n   stbi_uc *VAR_12;\n   float *VAR_13;\n   int VAR_14;\n   unsigned char VAR_15, VAR_16;\n   int VAR_17, VAR_18, VAR_19, VAR_20,VAR_21, VAR_22;\n   const char *VAR_23;\n   STBI_NOTUSED(VAR_5);\n\n   /* COMMENT_0 */\n   VAR_23 = stbi__hdr_gettoken(VAR_0,VAR_6);\n   if (strcmp(VAR_23, \"#?RADIANCE\") != 0 && strcmp(VAR_23, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   /* COMMENT_1 */\n   for(;;) {\n      VAR_8 = stbi__hdr_gettoken(VAR_0,VAR_6);\n      if (VAR_8[0] == 0) break;\n      if (strcmp(VAR_8, \"FORMAT=32-bit_rle_rgbe\") == 0) VAR_9 = 1;\n   }\n\n   if (!VAR_9)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   /* COMMENT_2 */\n   /* COMMENT_3 */\n   VAR_8 = stbi__hdr_gettoken(VAR_0,VAR_6);\n   if (strncmp(VAR_8, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   VAR_8 += 3;\n   VAR_11 = (int) strtol(VAR_8, &VAR_8, 10);\n   while (*VAR_8 == ' ') ++VAR_8;\n   if (strncmp(VAR_8, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   VAR_8 += 3;\n   VAR_10 = (int) strtol(VAR_8, NULL, 10);\n\n   if (VAR_11 > VAR_24) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (VAR_10 > VAR_24) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *VAR_1 = VAR_10;\n   *VAR_2 = VAR_11;\n\n   if (VAR_3) *VAR_3 = 3;\n   if (VAR_4 == 0) VAR_4 = 3;\n\n   if (!stbi__mad4sizes_valid(VAR_10, VAR_11, VAR_4, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   /* COMMENT_4 */\n   VAR_13 = (float *) stbi__malloc_mad4(VAR_10, VAR_11, VAR_4, sizeof(float), 0);\n   if (!VAR_13)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   /* COMMENT_5 */\n   /* COMMENT_6 */\n   if ( VAR_10 < 8 || VAR_10 >= 32768) {\n      /* COMMENT_7 */\n      for (VAR_18=0; VAR_18 < VAR_11; ++VAR_18) {\n         for (VAR_17=0; VAR_17 < VAR_10; ++VAR_17) {\n            stbi_uc VAR_25[4];\n           main_decode_loop:\n            stbi__getn(VAR_0, VAR_25, 4);\n            stbi__hdr_convert(VAR_13 + VAR_18 * VAR_10 * VAR_4 + VAR_17 * VAR_4, VAR_25, VAR_4);\n         }\n      }\n   } else {\n      /* COMMENT_8 */\n      VAR_12 = NULL;\n\n      for (VAR_18 = 0; VAR_18 < VAR_11; ++VAR_18) {\n         VAR_20 = stbi__get8(VAR_0);\n         VAR_21 = stbi__get8(VAR_0);\n         VAR_14 = stbi__get8(VAR_0);\n         if (VAR_20 != 2 || VAR_21 != 2 || (VAR_14 & 0x80)) {\n            /* COMMENT_9 */\n            /* COMMENT_10 */\n            stbi_uc VAR_25[4];\n            VAR_25[0] = (stbi_uc) VAR_20;\n            VAR_25[1] = (stbi_uc) VAR_21;\n            VAR_25[2] = (stbi_uc) VAR_14;\n            VAR_25[3] = (stbi_uc) stbi__get8(VAR_0);\n            stbi__hdr_convert(VAR_13, VAR_25, VAR_4);\n            VAR_17 = 1;\n            VAR_18 = 0;\n            STBI_FREE(VAR_12);\n            goto main_decode_loop; /* COMMENT_11 */\n         }\n         VAR_14 <<= 8;\n         VAR_14 |= stbi__get8(VAR_0);\n         if (VAR_14 != VAR_10) { STBI_FREE(VAR_13); STBI_FREE(VAR_12); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (VAR_12 == NULL) {\n            VAR_12 = (stbi_uc *) stbi__malloc_mad2(VAR_10, 4, 0);\n            if (!VAR_12) {\n               STBI_FREE(VAR_13);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (VAR_19 = 0; VAR_19 < 4; ++VAR_19) {\n            int VAR_26;\n            VAR_17 = 0;\n            while ((VAR_26 = VAR_10 - VAR_17) > 0) {\n               VAR_15 = stbi__get8(VAR_0);\n               if (VAR_15 > 128) {\n                  /* COMMENT_12 */\n                  VAR_16 = stbi__get8(VAR_0);\n                  VAR_15 -= 128;\n                  if ((VAR_15 == 0) || (VAR_15 > VAR_26)) { STBI_FREE(VAR_13); STBI_FREE(VAR_12); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (VAR_22 = 0; VAR_22 < VAR_15; ++VAR_22)\n                     VAR_12[VAR_17++ * 4 + VAR_19] = VAR_16;\n               } else {\n                  /* COMMENT_13 */\n                  if ((VAR_15 == 0) || (VAR_15 > VAR_26)) { STBI_FREE(VAR_13); STBI_FREE(VAR_12); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (VAR_22 = 0; VAR_22 < VAR_15; ++VAR_22)\n                     VAR_12[VAR_17++ * 4 + VAR_19] = stbi__get8(VAR_0);\n               }\n            }\n         }\n         for (VAR_17=0; VAR_17 < VAR_10; ++VAR_17)\n            stbi__hdr_convert(VAR_13+(VAR_18*VAR_10 + VAR_17)*VAR_4, VAR_12 + VAR_17*4, VAR_4);\n      }\n      if (VAR_12)\n         STBI_FREE(VAR_12);\n   }\n\n   return VAR_13;\n}",
  "func_graph_path": "nothings/stb/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6/stb_image.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -108,12 +108,12 @@\n                   // Run\n                   value = stbi__get8(s);\n                   count -= 128;\n-                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n+                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                   for (z = 0; z < count; ++z)\n                      scanline[i++ * 4 + k] = value;\n                } else {\n                   // Dump\n-                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n+                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                   for (z = 0; z < count; ++z)\n                      scanline[i++ * 4 + k] = stbi__get8(s);\n                }",
  "diff_line_info": {
    "deleted_lines": [
      "                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }",
      "                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }"
    ],
    "added_lines": [
      "                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }",
      "                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nothings/stb/pull/1223",
  "description": {
    "pr_info": {
      "title": "Fixes a crash and an infinite loop in stb_image that could occur with specially constructed PGM and HDR files",
      "number": 1223
    },
    "comment": [
      "Fixes two availability issues in stb_image that could occur with specially\r\nconstructed HDR and PGM files. Please see issues #1224 and #1225 for full descriptions.\r\n\r\nHDR: In certain conditions, the RLE decoder can get stuck in the decoding loop\r\nat the end of a stream: `stbi__get8()` always returns 0 when at the end of a\r\nstream, which is interpreted as a count and results in an infinite loop.\r\nI believe the solution is to treat a run of 0 as invalid, following the\r\n`RGBE_ReadPixels_RLE()` function in Bruce Walter's\r\n[https://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c](https://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c).\r\n\r\nPGM: Loading large monochrome 16-bit PGM files would cause an access violation\r\ndue to reading out of bounds when comverting from 16-bit to 8-bit. In addition,\r\nwhen loading 16-bit PGM files, `stbi__pnm_load()` would call\r\n`stbi__convert_format()` instead of `stbi__convert_format16()` to convert from\r\nmonochrome to the required number of channels, so the buffer would be\r\ninterpreted as the wrong type. This pull request also adds an error nessage for\r\nwhen the `stbi__getn()` call fails.\r\n\r\nThanks!",
      "Following up on this - is there anything I can change to help merge this in? Thanks!",
      "stb repository is just slow for me to update",
      "Quick note from the survey of the first 10 ossfuzz issues I did: I think this pull request might resolve ossfuzz issues https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37628&q=proj%3Dstb&can=2 (this seems to be the infinite HDR reader error) and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=38394&q=proj%3Dstb&can=2 (I think this is due to the PGM issue). I'm unable to reproduce ossfuzz's crashes with these fixes on Windows with Address Sanitizer enabled.",
      "Merged into dev branch, will be in the next release.",
      "Thanks so much ryg!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}