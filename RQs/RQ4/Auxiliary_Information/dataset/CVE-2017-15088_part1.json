{
  "cve_id": "CVE-2017-15088",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Fix PKINIT cert matching data construction\n\nRewrite X509_NAME_oneline_ex() and its call sites to use dynamic\nallocation and to perform proper error checking.\n\nticket: 8617\ntarget_version: 1.16\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup",
  "commit_hash": "fbb687db1088ddd894d975996e5f6a4252b9a2b4",
  "git_url": "https://github.com/krb5/krb5/commit/fbb687db1088ddd894d975996e5f6a4252b9a2b4",
  "file_path": "src/plugins/preauth/pkinit/pkinit_crypto_openssl.c",
  "func_name": "get_matching_data",
  "func_before": "static krb5_error_code\nget_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n    char buf[DN_BUF_LEN];\n    unsigned int bufsize = sizeof(buf);\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    /* Get the subject name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->subject_dn = strdup(buf);\n    if (md->subject_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the issuer name (in rfc2253 format). */\n    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,\n                         XN_FLAG_SEP_COMMA_PLUS);\n    md->issuer_dn = strdup(buf);\n    if (md->issuer_dn == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}",
  "abstract_func_before": "static krb5_error_code\nget_matching_data(krb5_context VAR_0,\n                  pkinit_plg_crypto_context VAR_1,\n                  pkinit_req_crypto_context VAR_2, X509 *VAR_3,\n                  pkinit_cert_matching_data **VAR_4)\n{\n    krb5_error_code VAR_5 = VAR_6;\n    pkinit_cert_matching_data *VAR_7 = NULL;\n    krb5_principal *VAR_8 = NULL, *VAR_9 = NULL;\n    size_t VAR_10, VAR_11;\n    char VAR_12[VAR_13];\n    unsigned int VAR_14 = sizeof(VAR_12);\n\n    *VAR_4 = NULL;\n\n    VAR_7 = calloc(1, sizeof(*VAR_7));\n    if (VAR_7 == NULL)\n        goto cleanup;\n\n    /* COMMENT_0 */\n    X509_NAME_oneline_ex(X509_get_subject_name(VAR_3), VAR_12, &VAR_14,\n                         VAR_15);\n    VAR_7->subject_dn = strdup(VAR_12);\n    if (VAR_7->subject_dn == NULL) {\n        VAR_5 = VAR_6;\n        goto cleanup;\n    }\n\n    /* COMMENT_1 */\n    X509_NAME_oneline_ex(X509_get_issuer_name(VAR_3), VAR_12, &VAR_14,\n                         VAR_15);\n    VAR_7->issuer_dn = strdup(VAR_12);\n    if (VAR_7->issuer_dn == NULL) {\n        VAR_5 = VAR_6;\n        goto cleanup;\n    }\n\n    /* COMMENT_2 */\n    VAR_5 = crypto_retrieve_X509_sans(VAR_0, VAR_1, VAR_2,\n                                    VAR_3, &VAR_8, &VAR_9, NULL);\n    if (VAR_5)\n        goto cleanup;\n\n    VAR_11 = 0;\n    if (VAR_8 != NULL) {\n        for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)\n            VAR_11++;\n    }\n    if (VAR_9 != NULL) {\n        for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)\n            VAR_11++;\n    }\n    if (VAR_11 != 0) {\n        VAR_7->sans = calloc((size_t)VAR_11+1, sizeof(*VAR_7->sans));\n        if (VAR_7->sans == NULL) {\n            VAR_5 = VAR_6;\n            goto cleanup;\n        }\n        VAR_11 = 0;\n        if (VAR_8 != NULL) {\n            for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)\n                VAR_7->sans[VAR_11++] = VAR_8[VAR_10];\n            free(VAR_8);\n        }\n        if (VAR_9 != NULL) {\n            for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)\n                VAR_7->sans[VAR_11++] = VAR_9[VAR_10];\n            free(VAR_9);\n        }\n        VAR_7->sans[VAR_11] = NULL;\n    } else\n        VAR_7->sans = NULL;\n\n    /* COMMENT_3 */\n    VAR_5 = crypto_retrieve_X509_key_usage(VAR_0, VAR_1,\n                                         VAR_2, VAR_3, &VAR_7->ku_bits,\n                                         &VAR_7->eku_bits);\n    if (VAR_5)\n        goto cleanup;\n\n    *VAR_4 = VAR_7;\n    VAR_7 = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(VAR_0, VAR_7);\n    return VAR_5;\n}",
  "func_graph_path_before": "krb5/fbb687db1088ddd894d975996e5f6a4252b9a2b4/pkinit_crypto_openssl.c/vul/before/0.json",
  "func": "static krb5_error_code\nget_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);\n    if (ret)\n        goto cleanup;\n    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);\n    if (ret)\n        goto cleanup;\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}",
  "abstract_func": "static krb5_error_code\nget_matching_data(krb5_context VAR_0,\n                  pkinit_plg_crypto_context VAR_1,\n                  pkinit_req_crypto_context VAR_2, X509 *VAR_3,\n                  pkinit_cert_matching_data **VAR_4)\n{\n    krb5_error_code VAR_5 = VAR_6;\n    pkinit_cert_matching_data *VAR_7 = NULL;\n    krb5_principal *VAR_8 = NULL, *VAR_9 = NULL;\n    size_t VAR_10, VAR_11;\n\n    *VAR_4 = NULL;\n\n    VAR_7 = calloc(1, sizeof(*VAR_7));\n    if (VAR_7 == NULL)\n        goto cleanup;\n\n    VAR_5 = rfc2253_name(X509_get_subject_name(VAR_3), &VAR_7->subject_dn);\n    if (VAR_5)\n        goto cleanup;\n    VAR_5 = rfc2253_name(X509_get_issuer_name(VAR_3), &VAR_7->issuer_dn);\n    if (VAR_5)\n        goto cleanup;\n\n    /* COMMENT_0 */\n    VAR_5 = crypto_retrieve_X509_sans(VAR_0, VAR_1, VAR_2,\n                                    VAR_3, &VAR_8, &VAR_9, NULL);\n    if (VAR_5)\n        goto cleanup;\n\n    VAR_11 = 0;\n    if (VAR_8 != NULL) {\n        for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)\n            VAR_11++;\n    }\n    if (VAR_9 != NULL) {\n        for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)\n            VAR_11++;\n    }\n    if (VAR_11 != 0) {\n        VAR_7->sans = calloc((size_t)VAR_11+1, sizeof(*VAR_7->sans));\n        if (VAR_7->sans == NULL) {\n            VAR_5 = VAR_6;\n            goto cleanup;\n        }\n        VAR_11 = 0;\n        if (VAR_8 != NULL) {\n            for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)\n                VAR_7->sans[VAR_11++] = VAR_8[VAR_10];\n            free(VAR_8);\n        }\n        if (VAR_9 != NULL) {\n            for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)\n                VAR_7->sans[VAR_11++] = VAR_9[VAR_10];\n            free(VAR_9);\n        }\n        VAR_7->sans[VAR_11] = NULL;\n    } else\n        VAR_7->sans = NULL;\n\n    /* COMMENT_1 */\n    VAR_5 = crypto_retrieve_X509_key_usage(VAR_0, VAR_1,\n                                         VAR_2, VAR_3, &VAR_7->ku_bits,\n                                         &VAR_7->eku_bits);\n    if (VAR_5)\n        goto cleanup;\n\n    *VAR_4 = VAR_7;\n    VAR_7 = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(VAR_0, VAR_7);\n    return VAR_5;\n}",
  "func_graph_path": "krb5/fbb687db1088ddd894d975996e5f6a4252b9a2b4/pkinit_crypto_openssl.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,6 @@\n     pkinit_cert_matching_data *md = NULL;\n     krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n     size_t i, j;\n-    char buf[DN_BUF_LEN];\n-    unsigned int bufsize = sizeof(buf);\n \n     *md_out = NULL;\n \n@@ -17,23 +15,12 @@\n     if (md == NULL)\n         goto cleanup;\n \n-    /* Get the subject name (in rfc2253 format). */\n-    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,\n-                         XN_FLAG_SEP_COMMA_PLUS);\n-    md->subject_dn = strdup(buf);\n-    if (md->subject_dn == NULL) {\n-        ret = ENOMEM;\n+    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);\n+    if (ret)\n         goto cleanup;\n-    }\n-\n-    /* Get the issuer name (in rfc2253 format). */\n-    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,\n-                         XN_FLAG_SEP_COMMA_PLUS);\n-    md->issuer_dn = strdup(buf);\n-    if (md->issuer_dn == NULL) {\n-        ret = ENOMEM;\n+    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);\n+    if (ret)\n         goto cleanup;\n-    }\n \n     /* Get the SAN data. */\n     ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,",
  "diff_line_info": {
    "deleted_lines": [
      "    char buf[DN_BUF_LEN];",
      "    unsigned int bufsize = sizeof(buf);",
      "    /* Get the subject name (in rfc2253 format). */",
      "    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,",
      "                         XN_FLAG_SEP_COMMA_PLUS);",
      "    md->subject_dn = strdup(buf);",
      "    if (md->subject_dn == NULL) {",
      "        ret = ENOMEM;",
      "    }",
      "",
      "    /* Get the issuer name (in rfc2253 format). */",
      "    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,",
      "                         XN_FLAG_SEP_COMMA_PLUS);",
      "    md->issuer_dn = strdup(buf);",
      "    if (md->issuer_dn == NULL) {",
      "        ret = ENOMEM;",
      "    }"
    ],
    "added_lines": [
      "    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);",
      "    if (ret)",
      "    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);",
      "    if (ret)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/707",
  "description": {
    "pr_info": {
      "title": "Fix PKINIT cert matching data construction",
      "number": 707
    },
    "comment": [
      "Rewrite X509_NAME_oneline_ex() and its call sites to use dynamic\r\nallocation and to perform proper error checking.\r\n",
      "Red Hat has assigned this CVE-2017-15088 (in our builds only, not in upstream krb5).",
      "On self-review I noticed some minor exception-handling mistakes in the new function definition (memory leaks on error, not checking the return value of BIO_new()).  Please re-review.  I think the candidate fix should be okay for practical purposes.",
      "Right, this is better than the original, so +1.\r\n\r\n(I believe `BIO_new()` failures aren't realistic for Linux, and the BIO leak on error isn't worth the delay a respin would require, so I agree it's fine for what I'm doing with it, and I'll plan to fix that later.)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses a buffer overflow issue in certificate name handling by implementing dynamic allocation and better error checking. This resolves a potential security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe changes fix a buffer overflow vulnerability, a clear security issue, by using dynamic memory allocation to prevent buffer overflows when processing certificate names.\n\n**Confidence Explanation:** The buffer overflow issue (a security risk) is clearly addressed with dynamic allocation. There are no references to CVEs, but the code changes directly mitigate a known security concern, justifying a high confidence score."
}