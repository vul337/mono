{
  "cve_id": "CVE-2019-1000019",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "7zip: fix crash when parsing certain archives\n\nFuzzing with CRCs disabled revealed that a call to get_uncompressed_data()\nwould sometimes fail to return at least 'minimum' bytes. This can cause\nthe crc32() invocation in header_bytes to read off into invalid memory.\n\nA specially crafted archive can use this to cause a crash.\n\nAn ASAN trace is below, but ASAN is not required - an uninstrumented\nbinary will also crash.\n\n==7719==ERROR: AddressSanitizer: SEGV on unknown address 0x631000040000 (pc 0x7fbdb3b3ec1d bp 0x7ffe77a51310 sp 0x7ffe77a51150 T0)\n==7719==The signal is caused by a READ memory access.\n    #0 0x7fbdb3b3ec1c in crc32_z (/lib/x86_64-linux-gnu/libz.so.1+0x2c1c)\n    #1 0x84f5eb in header_bytes (/tmp/libarchive/bsdtar+0x84f5eb)\n    #2 0x856156 in read_Header (/tmp/libarchive/bsdtar+0x856156)\n    #3 0x84e134 in slurp_central_directory (/tmp/libarchive/bsdtar+0x84e134)\n    #4 0x849690 in archive_read_format_7zip_read_header (/tmp/libarchive/bsdtar+0x849690)\n    #5 0x5713b7 in _archive_read_next_header2 (/tmp/libarchive/bsdtar+0x5713b7)\n    #6 0x570e63 in _archive_read_next_header (/tmp/libarchive/bsdtar+0x570e63)\n    #7 0x6f08bd in archive_read_next_header (/tmp/libarchive/bsdtar+0x6f08bd)\n    #8 0x52373f in read_archive (/tmp/libarchive/bsdtar+0x52373f)\n    #9 0x5257be in tar_mode_x (/tmp/libarchive/bsdtar+0x5257be)\n    #10 0x51daeb in main (/tmp/libarchive/bsdtar+0x51daeb)\n    #11 0x7fbdb27cab96 in __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310\n    #12 0x41dd09 in _start (/tmp/libarchive/bsdtar+0x41dd09)\n\nThis was primarly done with afl and FairFuzz. Some early corpus entries\nmay have been generated by qsym.",
  "commit_hash": "65a23f5dbee4497064e9bb467f81138a62b0dae1",
  "git_url": "https://github.com/libarchive/libarchive/commit/65a23f5dbee4497064e9bb467f81138a62b0dae1",
  "file_path": "libarchive/archive_read_support_format_7zip.c",
  "func_name": "get_uncompressed_data",
  "func_before": "static ssize_t\nget_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t/* Copy mode. */\n\n\t\t/*\n\t\t * Note: '1' here is a performance optimization.\n\t\t * Recall that the decompression layer returns a count of\n\t\t * available bytes; asking for more than that forces the\n\t\t * decompressor to combine reads by copying data.\n\t\t */\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\t/* Decompression has failed. */\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\t/* Packed mode. */\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\t/*\n\t\t\t * If remaining uncompressed data size is less than\n\t\t\t * the minimum size, fill the buffer up to the\n\t\t\t * minimum size.\n\t\t\t */\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}",
  "abstract_func_before": "static ssize_t\nget_uncompressed_data(struct archive_read *VAR_0, const void **VAR_1, size_t VAR_2,\n    size_t VAR_3)\n{\n\tstruct _7zip *VAR_4 = (struct _7zip *)VAR_0->format->data;\n\tssize_t VAR_5;\n\n\tif (VAR_4->codec == VAR_6 && VAR_4->codec2 == (unsigned long)-1) {\n\t\t/* COMMENT_0 */\n\n\t\t/* COMMENT_1 */\n                                                  \n                                                           \n                                                          \n                                                   \n     \n\t\t*VAR_1 = __archive_read_ahead(VAR_0, 1, &VAR_5);\n\t\tif (VAR_5 <= 0) {\n\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t    VAR_7,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (VAR_8);\n\t\t}\n\t\tif ((size_t)VAR_5 >\n\t\t    VAR_4->uncompressed_buffer_bytes_remaining)\n\t\t\tVAR_5 = (ssize_t)\n\t\t\t    VAR_4->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)VAR_5 > VAR_2)\n\t\t\tVAR_5 = (ssize_t)VAR_2;\n\n\t\tVAR_4->pack_stream_bytes_unconsumed = VAR_5;\n\t} else if (VAR_4->uncompressed_buffer_pointer == NULL) {\n\t\t/* COMMENT_7 */\n\t\tarchive_set_error(&(VAR_0->archive),\n\t\t    VAR_9, \"Damaged 7-Zip archive\");\n\t\treturn (VAR_8);\n\t} else {\n\t\t/* COMMENT_8 */\n\t\tif (VAR_3 > VAR_4->uncompressed_buffer_bytes_remaining) {\n\t\t\t/* COMMENT_9 */\n                                                      \n                                                 \n                   \n      \n\t\t\tif (extract_pack_stream(VAR_0, VAR_3) < 0)\n\t\t\t\treturn (VAR_8);\n\t\t}\n\t\tif (VAR_2 > VAR_4->uncompressed_buffer_bytes_remaining)\n\t\t\tVAR_5 = (ssize_t)\n\t\t\t    VAR_4->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tVAR_5 = (ssize_t)VAR_2;\n\t\t*VAR_1 = VAR_4->uncompressed_buffer_pointer;\n\t\tVAR_4->uncompressed_buffer_pointer += VAR_5;\n\t}\n\tVAR_4->uncompressed_buffer_bytes_remaining -= VAR_5;\n\treturn (VAR_5);\n}",
  "func_graph_path_before": "libarchive/65a23f5dbee4497064e9bb467f81138a62b0dae1/archive_read_support_format_7zip.c/vul/before/0.json",
  "func": "static ssize_t\nget_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n\n\tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t/* Copy mode. */\n\n\t\t*buff = __archive_read_ahead(a, minimum, &bytes_avail);\n\t\tif (bytes_avail <= 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\t/* Decompression has failed. */\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\t/* Packed mode. */\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\t/*\n\t\t\t * If remaining uncompressed data size is less than\n\t\t\t * the minimum size, fill the buffer up to the\n\t\t\t * minimum size.\n\t\t\t */\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}",
  "abstract_func": "static ssize_t\nget_uncompressed_data(struct archive_read *VAR_0, const void **VAR_1, size_t VAR_2,\n    size_t VAR_3)\n{\n\tstruct _7zip *VAR_4 = (struct _7zip *)VAR_0->format->data;\n\tssize_t VAR_5;\n\n\tif (VAR_4->codec == VAR_6 && VAR_4->codec2 == (unsigned long)-1) {\n\t\t/* COMMENT_0 */\n\n\t\t*VAR_1 = __archive_read_ahead(VAR_0, VAR_3, &VAR_5);\n\t\tif (VAR_5 <= 0) {\n\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t    VAR_7,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (VAR_8);\n\t\t}\n\t\tif ((size_t)VAR_5 >\n\t\t    VAR_4->uncompressed_buffer_bytes_remaining)\n\t\t\tVAR_5 = (ssize_t)\n\t\t\t    VAR_4->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)VAR_5 > VAR_2)\n\t\t\tVAR_5 = (ssize_t)VAR_2;\n\n\t\tVAR_4->pack_stream_bytes_unconsumed = VAR_5;\n\t} else if (VAR_4->uncompressed_buffer_pointer == NULL) {\n\t\t/* COMMENT_1 */\n\t\tarchive_set_error(&(VAR_0->archive),\n\t\t    VAR_9, \"Damaged 7-Zip archive\");\n\t\treturn (VAR_8);\n\t} else {\n\t\t/* COMMENT_2 */\n\t\tif (VAR_3 > VAR_4->uncompressed_buffer_bytes_remaining) {\n\t\t\t/* COMMENT_3 */\n                                                      \n                                                 \n                   \n      \n\t\t\tif (extract_pack_stream(VAR_0, VAR_3) < 0)\n\t\t\t\treturn (VAR_8);\n\t\t}\n\t\tif (VAR_2 > VAR_4->uncompressed_buffer_bytes_remaining)\n\t\t\tVAR_5 = (ssize_t)\n\t\t\t    VAR_4->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tVAR_5 = (ssize_t)VAR_2;\n\t\t*VAR_1 = VAR_4->uncompressed_buffer_pointer;\n\t\tVAR_4->uncompressed_buffer_pointer += VAR_5;\n\t}\n\tVAR_4->uncompressed_buffer_bytes_remaining -= VAR_5;\n\treturn (VAR_5);\n}",
  "func_graph_path": "libarchive/65a23f5dbee4497064e9bb467f81138a62b0dae1/archive_read_support_format_7zip.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,13 +8,7 @@\n \tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n \t\t/* Copy mode. */\n \n-\t\t/*\n-\t\t * Note: '1' here is a performance optimization.\n-\t\t * Recall that the decompression layer returns a count of\n-\t\t * available bytes; asking for more than that forces the\n-\t\t * decompressor to combine reads by copying data.\n-\t\t */\n-\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n+\t\t*buff = __archive_read_ahead(a, minimum, &bytes_avail);\n \t\tif (bytes_avail <= 0) {\n \t\t\tarchive_set_error(&a->archive,\n \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t/*",
      "\t\t * Note: '1' here is a performance optimization.",
      "\t\t * Recall that the decompression layer returns a count of",
      "\t\t * available bytes; asking for more than that forces the",
      "\t\t * decompressor to combine reads by copying data.",
      "\t\t */",
      "\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);"
    ],
    "added_lines": [
      "\t\t*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/1120",
  "description": {
    "pr_info": {
      "title": "Fix a 7zip crash and a ISO9660 infinite loop",
      "number": 1120
    },
    "comment": [
      "Fuzzing found two further file-format specific issues - a read-only segfault in 7z, and an infinite loop in ISO9660. Full details are in the commit messages.\r\n\r\nTest cases are (tested on Ubuntu bionic and git head):\r\n - for the 7zip crash: [crash.7z.txt](https://github.com/libarchive/libarchive/files/2762797/crash.7z.txt)\r\n - for the ISO9660 infinite loop: [rrforever.iso.txt](https://github.com/libarchive/libarchive/files/2762827/rrforever.iso.txt)\r\n\r\nIn order to allow me to upload them to GitHub, I have converted them to text with `xxd`.  To replicate:\r\n\r\n ```\r\nxxd -r rrforever.iso.txt rrforever.iso\r\nbsdtar -Oxf rrforever.iso\r\n```\r\n(and likewise for `crash.7z`)\r\n\r\nFuzzing was done with AFL, FairFuzz (afl-rb) and a little bit of qsym.",
      "These have been assigned CVEs through the DWF project:\r\n - CVE-2019-1000019 for 65a23f5\r\n - CVE-2019-1000020 for 8312eaa"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95  \nThe patch addresses a security issue causing a crash when parsing crafted 7z archives. The crash is due to a buffer underflow, which is a security concern. The commit aligns with the vulnerability description and provides test cases. The code change ensures enough data is read to prevent invalid memory access, confirming it as a security fix. The confidence is high due to clear indicators and context."
}