{
  "cve_id": "CVE-2022-39310",
  "cwe_ids": [
    "CWE-284"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "gocd",
  "commit_msg": "Refactor & fix tests after RMI interface is simplified to always include `AgentRuntimeInfo`",
  "commit_hash": "a644a7e5ed75d7b9e46f164fb83445f778077cf9",
  "git_url": "https://github.com/gocd/gocd/commit/a644a7e5ed75d7b9e46f164fb83445f778077cf9",
  "file_path": "server/src/main/java/com/thoughtworks/go/remote/AgentRemoteInvokerServiceExporter.java",
  "func_name": "authorized",
  "func_before": "private boolean authorized(HttpServletRequest request, HttpServletResponse response, RemoteInvocation invocation) throws IOException {\n        final String uuid = request.getHeader(\"X-Agent-GUID\"); // should never be null since we passed the auth filter\n        final MethodSignature current = new MethodSignature(invocation);\n\n        LOG.debug(format(\"Checking authorization for agent [%s] on invocation: %s\", uuid, invocation));\n\n        if (SKIP_AUTH.contains(current)) {\n            LOG.debug(format(\"ALLOWING REQUEST: Agent [%s] does not need authorization for: %s\", uuid, invocation));\n            return true;\n        }\n\n        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.containsKey(current)) {\n            final String askingFor = KNOWN_METHODS_NEEDING_UUID_VALIDATION.get(current).apply(invocation.getArguments());\n\n            if (!uuid.equals(askingFor)) {\n                LOG.error(format(\"DENYING REQUEST: Agent [%s] is attempting a request on behalf of [%s]: %s\", uuid, askingFor, invocation));\n                reject(response, SC_FORBIDDEN, \"Not allowing request on behalf of another agent\");\n                return false;\n            }\n        } else {\n            LOG.error(format(\"DENYING REQUEST: Agent [%s] is requesting an unknown method invocation: %s\", uuid, invocation));\n            reject(response, SC_BAD_REQUEST, format(\"Unknown invocation: %s\", invocation));\n            return false;\n        }\n\n        LOG.debug(format(\"ALLOWING REQUEST: Agent [%s] is authorized to invoke: %s\", uuid, invocation));\n        return true;\n    }",
  "abstract_func_before": "private boolean authorized(HttpServletRequest VAR_0, HttpServletResponse VAR_1, RemoteInvocation VAR_2) throws IOException {\n        final String VAR_3 = VAR_0.getHeader(\"X-Agent-GUID\"); /* COMMENT_0 */\n        final MethodSignature VAR_4 = new MethodSignature(VAR_2);\n\n        VAR_5.debug(format(\"Checking authorization for agent [%s] on invocation: %s\", VAR_3, VAR_2));\n\n        if (VAR_6.contains(VAR_4)) {\n            VAR_5.debug(format(\"ALLOWING REQUEST: Agent [%s] does not need authorization for: %s\", VAR_3, VAR_2));\n            return true;\n        }\n\n        if (VAR_7.containsKey(VAR_4)) {\n            final String VAR_8 = VAR_7.get(VAR_4).apply(VAR_2.getArguments());\n\n            if (!VAR_3.equals(VAR_8)) {\n                VAR_5.error(format(\"DENYING REQUEST: Agent [%s] is attempting a request on behalf of [%s]: %s\", VAR_3, VAR_8, VAR_2));\n                reject(VAR_1, VAR_9, \"Not allowing request on behalf of another agent\");\n                return false;\n            }\n        } else {\n            VAR_5.error(format(\"DENYING REQUEST: Agent [%s] is requesting an unknown method invocation: %s\", VAR_3, VAR_2));\n            reject(VAR_1, VAR_10, format(\"Unknown invocation: %s\", VAR_2));\n            return false;\n        }\n\n        VAR_5.debug(format(\"ALLOWING REQUEST: Agent [%s] is authorized to invoke: %s\", VAR_3, VAR_2));\n        return true;\n    }",
  "func_graph_path_before": "gocd/a644a7e5ed75d7b9e46f164fb83445f778077cf9/AgentRemoteInvokerServiceExporter.java/vul/before/0.json",
  "func": "private boolean authorized(HttpServletRequest request, HttpServletResponse response, RemoteInvocation invocation) throws IOException {\n        final String uuid = request.getHeader(\"X-Agent-GUID\"); // should never be null since we passed the auth filter\n        final MethodSignature current = new MethodSignature(invocation);\n\n        LOG.debug(format(\"Checking authorization for agent [%s] on invocation: %s\", uuid, invocation));\n\n        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.contains(current)) {\n            final String askingFor = AgentUUID.fromRuntimeInfo0(invocation.getArguments());\n\n            if (!uuid.equals(askingFor)) {\n                LOG.error(format(\"DENYING REQUEST: Agent [%s] is attempting a request on behalf of [%s]: %s\", uuid, askingFor, invocation));\n                reject(response, SC_FORBIDDEN, \"Not allowing request on behalf of another agent\");\n                return false;\n            }\n        } else {\n            LOG.error(format(\"DENYING REQUEST: Agent [%s] is requesting an unknown method invocation: %s\", uuid, invocation));\n            reject(response, SC_BAD_REQUEST, format(\"Unknown invocation: %s\", invocation));\n            return false;\n        }\n\n        LOG.debug(format(\"ALLOWING REQUEST: Agent [%s] is authorized to invoke: %s\", uuid, invocation));\n        return true;\n    }",
  "abstract_func": "private boolean authorized(HttpServletRequest VAR_0, HttpServletResponse VAR_1, RemoteInvocation VAR_2) throws IOException {\n        final String VAR_3 = VAR_0.getHeader(\"X-Agent-GUID\"); /* COMMENT_0 */\n        final MethodSignature VAR_4 = new MethodSignature(VAR_2);\n\n        VAR_5.debug(format(\"Checking authorization for agent [%s] on invocation: %s\", VAR_3, VAR_2));\n\n        if (VAR_6.contains(VAR_4)) {\n            final String VAR_7 = VAR_8.fromRuntimeInfo0(VAR_2.getArguments());\n\n            if (!VAR_3.equals(VAR_7)) {\n                VAR_5.error(format(\"DENYING REQUEST: Agent [%s] is attempting a request on behalf of [%s]: %s\", VAR_3, VAR_7, VAR_2));\n                reject(VAR_1, VAR_9, \"Not allowing request on behalf of another agent\");\n                return false;\n            }\n        } else {\n            VAR_5.error(format(\"DENYING REQUEST: Agent [%s] is requesting an unknown method invocation: %s\", VAR_3, VAR_2));\n            reject(VAR_1, VAR_10, format(\"Unknown invocation: %s\", VAR_2));\n            return false;\n        }\n\n        VAR_5.debug(format(\"ALLOWING REQUEST: Agent [%s] is authorized to invoke: %s\", VAR_3, VAR_2));\n        return true;\n    }",
  "func_graph_path": "gocd/a644a7e5ed75d7b9e46f164fb83445f778077cf9/AgentRemoteInvokerServiceExporter.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,13 +4,8 @@\n \n         LOG.debug(format(\"Checking authorization for agent [%s] on invocation: %s\", uuid, invocation));\n \n-        if (SKIP_AUTH.contains(current)) {\n-            LOG.debug(format(\"ALLOWING REQUEST: Agent [%s] does not need authorization for: %s\", uuid, invocation));\n-            return true;\n-        }\n-\n-        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.containsKey(current)) {\n-            final String askingFor = KNOWN_METHODS_NEEDING_UUID_VALIDATION.get(current).apply(invocation.getArguments());\n+        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.contains(current)) {\n+            final String askingFor = AgentUUID.fromRuntimeInfo0(invocation.getArguments());\n \n             if (!uuid.equals(askingFor)) {\n                 LOG.error(format(\"DENYING REQUEST: Agent [%s] is attempting a request on behalf of [%s]: %s\", uuid, askingFor, invocation));",
  "diff_line_info": {
    "deleted_lines": [
      "        if (SKIP_AUTH.contains(current)) {",
      "            LOG.debug(format(\"ALLOWING REQUEST: Agent [%s] does not need authorization for: %s\", uuid, invocation));",
      "            return true;",
      "        }",
      "",
      "        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.containsKey(current)) {",
      "            final String askingFor = KNOWN_METHODS_NEEDING_UUID_VALIDATION.get(current).apply(invocation.getArguments());"
    ],
    "added_lines": [
      "        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.contains(current)) {",
      "            final String askingFor = AgentUUID.fromRuntimeInfo0(invocation.getArguments());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/gocd/gocd/pull/8877",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/gocd/gocd/pull/8877: 403 Client Error: Forbidden for url: https://api.github.com/repos/gocd/gocd/pulls/8877",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\nThe patch addresses a security issue by validating agent UUIDs, despite the commit message focusing on refactoring. The code changes reinforce this security fix with UUID validation, making it a clear security patch with high confidence."
}