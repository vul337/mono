{
  "cve_id": "CVE-2021-21280",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Check that there is enough room in the buffer to write an external header.",
  "commit_hash": "b88e5c303db21578799e5083bda9580922dc17b4",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/b88e5c303db21578799e5083bda9580922dc17b4",
  "file_path": "os/net/ipv6/sicslowpan.c",
  "func_name": "uncompress_hdr_iphc",
  "func_before": "static void\nuncompress_hdr_iphc(uint8_t *buf, uint16_t ip_len)\n{\n  uint8_t tmp, iphc0, iphc1, nhc;\n  struct uip_ext_hdr *exthdr;\n  uint8_t* last_nextheader;\n  uint8_t* ip_payload;\n  uint8_t ext_hdr_len = 0;\n\n  /* at least two byte will be used for the encoding */\n  hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n\n  iphc0 = PACKETBUF_IPHC_BUF[0];\n  iphc1 = PACKETBUF_IPHC_BUF[1];\n\n  /* another if the CID flag is set */\n  if(iphc1 & SICSLOWPAN_IPHC_CID) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    hc06_ptr++;\n  }\n\n  /* Traffic class and flow label */\n    if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {\n      /* Flow label are carried inline */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is carried inline */\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);\n        tmp = *hc06_ptr;\n        hc06_ptr += 4;\n        /* IPHC format of tc is ECN | DSCP , original is DSCP | ECN */\n        /* set version, pick highest DSCP bits and set in vtc */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((tmp >> 2) & 0x0f);\n        /* ECN rolled down two steps + lowest DSCP bits at top two bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |\n          (SICSLOWPAN_IP_BUF(buf)->tcflow & 0x0f);\n      } else {\n        /* Traffic class is compressed (set version and no TC)*/\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        /* highest flow label bits + ECN bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |\n          ((*hc06_ptr >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);\n        hc06_ptr += 3;\n      }\n    } else {\n      /* Version is always 6! */\n      /* Version and flow label are compressed */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is inline */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(buf)->flow = 0;\n          hc06_ptr += 1;\n      } else {\n        /* Traffic class is compressed */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(buf)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n      }\n    }\n\n  /* Next Header */\n  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n    /* Next header is carried inline */\n    SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n    hc06_ptr += 1;\n  }\n\n  /* Hop limit */\n  if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {\n    SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n    hc06_ptr += 1;\n  }\n\n  /* put the source address compression mode SAM in the tmp var */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;\n\n  /* context based compression */\n  if(iphc1 & SICSLOWPAN_IPHC_SAC) {\n    uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?\n      PACKETBUF_IPHC_BUF[2] >> 4 : 0;\n\n    /* Source address - check context != NULL only if SAM bits are != 0*/\n    if (tmp != 0) {\n      context = addr_context_lookup_by_number(sci);\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n    }\n    /* if tmp == 0 we do not have a context and therefore no prefix */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr,\n                    tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  } else {\n    /* no compression and link local */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, llprefix, unc_llconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  }\n\n  /* Destination address */\n  /* put the destination address compression mode into tmp */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;\n\n  /* multicast compression */\n  if(iphc1 & SICSLOWPAN_IPHC_M) {\n    /* context based multicast compression */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      /* TODO: implement this */\n    } else {\n      /* non-context based multicast compression - */\n      /* DAM_00: 128 bits  */\n      /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */\n      /* DAM_10:  32 bits FFXX::00XX:XXXX */\n      /* DAM_11:   8 bits FF02::00XX */\n      uint8_t prefix[] = {0xff, 0x02};\n      if(tmp > 0 && tmp < 3) {\n        prefix[1] = *hc06_ptr;\n        hc06_ptr++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, prefix,\n                      unc_mxconf[tmp], NULL);\n    }\n  } else {\n    /* no multicast */\n    /* Context based */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] & 0x0f : 0;\n      context = addr_context_lookup_by_number(dci);\n\n      /* all valid cases below need the context! */\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n                      unc_ctxconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    } else {\n      /* not context based => link local M = 0, DAC = 0 - same as SAC */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, llprefix,\n                      unc_llconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    }\n  }\n  uncomp_hdr_len += UIP_IPH_LEN;\n\n  /* Next header processing - continued */\n  nhc = iphc0 & SICSLOWPAN_IPHC_NH_C;\n  /* The next header is compressed, NHC is following */\n  last_nextheader =  &SICSLOWPAN_IP_BUF(buf)->proto;\n  ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n\n  while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {\n    uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n    /* next header compression flag */\n    uint8_t nh = (*hc06_ptr & 0x01);\n    uint8_t next = 0;\n    uint8_t len;\n    uint8_t proto;\n\n    nhc = nh;\n\n    hc06_ptr++;\n    if(!nh) {\n      next = *hc06_ptr;\n      hc06_ptr++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", next);\n    }\n    len = *hc06_ptr;\n    hc06_ptr++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", eid, next, len);\n    switch(eid) {\n    case SICSLOWPAN_NHC_ETX_HDR_HBHO:\n      proto = UIP_PROTO_HBHO;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_ROUTING:\n      proto = UIP_PROTO_ROUTING;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_FRAG:\n      proto = UIP_PROTO_FRAG;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_DESTO:\n      proto = UIP_PROTO_DESTO;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return;\n    }\n    *last_nextheader = proto;\n    /* uncompress the extension header */\n    exthdr = (struct uip_ext_hdr *)ip_payload;\n    exthdr->len = (2 + len) / 8 - 1;\n    exthdr->next = next;\n    last_nextheader = &exthdr->next;\n    if(ip_len == 0 && (uint8_t *)exthdr - uip_buf + 2 + len > sizeof(uip_buf)) {\n      LOG_DBG(\"uncompression: ext header points beyond uip buffer boundary\\n\");\n      return;\n    }\n    memcpy((uint8_t*)exthdr + 2, hc06_ptr, len);\n    hc06_ptr += len;\n    uncomp_hdr_len += (exthdr->len + 1) * 8;\n    ip_payload += (exthdr->len + 1) * 8;\n    ext_hdr_len += (exthdr->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exhdrlen: %d (calc: %d)\\n\",\n           proto, len, exthdr->len, (exthdr->len + 1) * 8);\n  }\n\n  /* The next header is compressed, NHC is following */\n  if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {\n    struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n    uint16_t udp_len;\n    uint8_t checksum_compressed;\n    *last_nextheader = UIP_PROTO_UDP;\n    checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *hc06_ptr);\n    switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {\n    case SICSLOWPAN_NHC_UDP_CS_P_00:\n      /* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport),\n             UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 5;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_01:\n      /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_10:\n      /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n      LOG_DBG(\"uncompression: source address\\n\");\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1)));\n      memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_11:\n      /* 1 byte for NHC, 1 byte for ports */\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1) >> 4));\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                    ((*(hc06_ptr + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return;\n    }\n    if(!checksum_compressed) { /* has_checksum, default  */\n      memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n      hc06_ptr += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* length field in UDP header (8 byte header + payload) */\n    udp_len = 8 + packetbuf_datalen() - (hc06_ptr - packetbuf_ptr);\n    udp_buf->udplen = UIP_HTONS(ip_len == 0 ? udp_len :\n                                ip_len - UIP_IPH_LEN - ext_hdr_len);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(udp_buf->udplen), ext_hdr_len, ip_len, udp_len);\n\n    uncomp_hdr_len += UIP_UDPH_LEN;\n  }\n\n  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;\n\n  /* IP length field. */\n  if(ip_len == 0) {\n    int len = packetbuf_datalen() - packetbuf_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", len,\n           packetbuf_datalen(), packetbuf_hdr_len, uncomp_hdr_len, UIP_IPH_LEN);\n\n    /* This is not a fragmented packet */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = len >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = len & 0x00FF;\n  } else {\n    /* This is a 1st fragment */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;\n  }\n}",
  "abstract_func_before": "static void\nuncompress_hdr_iphc(uint8_t *VAR_0, uint16_t VAR_1)\n{\n  uint8_t VAR_2, VAR_3, VAR_4, VAR_5;\n  struct uip_ext_hdr *VAR_6;\n  uint8_t* VAR_7;\n  uint8_t* VAR_8;\n  uint8_t VAR_9 = 0;\n\n  /* COMMENT_0 */\n  VAR_10 = VAR_11 + VAR_12 + 2;\n\n  VAR_3 = VAR_13[0];\n  VAR_4 = VAR_13[1];\n\n  /* COMMENT_1 */\n  if(VAR_4 & VAR_14) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    VAR_10++;\n  }\n\n  /* COMMENT_2 */\n    if((VAR_3 & VAR_15) == 0) {\n      /* COMMENT_3 */\n      if((VAR_3 & VAR_16) == 0) {\n        /* COMMENT_4 */\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->tcflow, VAR_10 + 1, 3);\n        VAR_2 = *VAR_10;\n        VAR_10 += 4;\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((VAR_2 >> 2) & 0x0f);\n        /* COMMENT_7 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((VAR_2 >> 2) & 0x30) | (VAR_2 << 6) |\n          (SICSLOWPAN_IP_BUF(VAR_0)->tcflow & 0x0f);\n      } else {\n        /* COMMENT_8 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        /* COMMENT_9 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = (*VAR_10 & 0x0F) |\n          ((*VAR_10 >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->flow, VAR_10 + 1, 2);\n        VAR_10 += 3;\n      }\n    } else {\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      if((VAR_3 & VAR_16) == 0) {\n        /* COMMENT_12 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((*VAR_10 >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((*VAR_10 << 6) & 0xC0) | ((*VAR_10 >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n          VAR_10 += 1;\n      } else {\n        /* COMMENT_13 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n      }\n    }\n\n  /* COMMENT_14 */\n  if((VAR_3 & VAR_17) == 0) {\n    /* COMMENT_15 */\n    SICSLOWPAN_IP_BUF(VAR_0)->proto = *VAR_10;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(VAR_0)->proto);\n    VAR_10 += 1;\n  }\n\n  /* COMMENT_16 */\n  if((VAR_3 & 0x03) != VAR_18) {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = VAR_19[VAR_3 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = *VAR_10;\n    VAR_10 += 1;\n  }\n\n  /* COMMENT_17 */\n  VAR_2 = ((VAR_4 & VAR_20) >> VAR_21) & 0x03;\n\n  /* COMMENT_18 */\n  if(VAR_4 & VAR_22) {\n    uint8_t VAR_23 = (VAR_4 & VAR_14) ?\n      VAR_13[2] >> 4 : 0;\n\n    /* COMMENT_19 */\n    if (VAR_2 != 0) {\n      VAR_24 = addr_context_lookup_by_number(VAR_23);\n      if(VAR_24 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n    }\n    /* COMMENT_20 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr,\n                    VAR_2 != 0 ? VAR_24->prefix : NULL, VAR_25[VAR_2],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_26));\n  } else {\n    /* COMMENT_21 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr, VAR_27, VAR_28[VAR_2],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_26));\n  }\n\n  /* COMMENT_22 */\n  /* COMMENT_23 */\n  VAR_2 = ((VAR_4 & VAR_29) >> VAR_30) & 0x03;\n\n  /* COMMENT_24 */\n  if(VAR_4 & VAR_31) {\n    /* COMMENT_25 */\n    if(VAR_4 & VAR_32) {\n      /* COMMENT_26 */\n    } else {\n      /* COMMENT_27 */\n      /* COMMENT_28 */\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      uint8_t VAR_33[] = {0xff, 0x02};\n      if(VAR_2 > 0 && VAR_2 < 3) {\n        VAR_33[1] = *VAR_10;\n        VAR_10++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_33,\n                      VAR_34[VAR_2], NULL);\n    }\n  } else {\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    if(VAR_4 & VAR_32) {\n      uint8_t VAR_35 = (VAR_4 & VAR_14) ? VAR_13[2] & 0x0f : 0;\n      VAR_24 = addr_context_lookup_by_number(VAR_35);\n\n      /* COMMENT_34 */\n      if(VAR_24 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_24->prefix,\n                      VAR_25[VAR_2],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_36));\n    } else {\n      /* COMMENT_35 */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_27,\n                      VAR_28[VAR_2],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_36));\n    }\n  }\n  VAR_37 += VAR_38;\n\n  /* COMMENT_36 */\n  VAR_5 = VAR_3 & VAR_17;\n  /* COMMENT_37 */\n  VAR_7 =  &SICSLOWPAN_IP_BUF(VAR_0)->proto;\n  VAR_8 = SICSLOWPAN_IPPAYLOAD_BUF(VAR_0);\n\n  while(VAR_5 && (*VAR_10 & VAR_39) == VAR_40) {\n    uint8_t VAR_41 = (*VAR_10 & 0x0e) >> 1;\n    /* COMMENT_38 */\n    uint8_t VAR_42 = (*VAR_10 & 0x01);\n    uint8_t VAR_43 = 0;\n    uint8_t VAR_44;\n    uint8_t VAR_45;\n\n    VAR_5 = VAR_42;\n\n    VAR_10++;\n    if(!VAR_42) {\n      VAR_43 = *VAR_10;\n      VAR_10++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", VAR_43);\n    }\n    VAR_44 = *VAR_10;\n    VAR_10++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", VAR_41, VAR_43, VAR_44);\n    switch(VAR_41) {\n    case VAR_46:\n      VAR_45 = VAR_47;\n      break;\n    case VAR_48:\n      VAR_45 = VAR_49;\n      break;\n    case VAR_50:\n      VAR_45 = VAR_51;\n      break;\n    case VAR_52:\n      VAR_45 = VAR_53;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return;\n    }\n    *VAR_7 = VAR_45;\n    /* COMMENT_39 */\n    VAR_6 = (struct uip_ext_hdr *)VAR_8;\n    VAR_6->len = (2 + VAR_44) / 8 - 1;\n    VAR_6->next = VAR_43;\n    VAR_7 = &VAR_6->next;\n    if(VAR_1 == 0 && (uint8_t *)VAR_6 - VAR_54 + 2 + VAR_44 > sizeof(VAR_54)) {\n      LOG_DBG(\"uncompression: ext header points beyond uip buffer boundary\\n\");\n      return;\n    }\n    memcpy((uint8_t*)VAR_6 + 2, VAR_10, VAR_44);\n    VAR_10 += VAR_44;\n    VAR_37 += (VAR_6->len + 1) * 8;\n    VAR_8 += (VAR_6->len + 1) * 8;\n    VAR_9 += (VAR_6->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exhdrlen: %d (calc: %d)\\n\",\n           VAR_45, VAR_44, VAR_6->len, (VAR_6->len + 1) * 8);\n  }\n\n  /* COMMENT_37 */\n  if(VAR_5 && (*VAR_10 & VAR_55) == VAR_56) {\n    struct uip_udp_hdr *VAR_57 = (struct uip_udp_hdr *)VAR_8;\n    uint16_t VAR_58;\n    uint8_t VAR_59;\n    *VAR_7 = VAR_60;\n    VAR_59 = *VAR_10 & VAR_61;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *VAR_10);\n    switch(*VAR_10 & VAR_62) {\n    case VAR_63:\n      /* COMMENT_40 */\n      memcpy(&VAR_57->srcport, VAR_10 + 1, 2);\n      memcpy(&VAR_57->destport, VAR_10 + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(VAR_57->srcport),\n             UIP_HTONS(VAR_57->destport));\n      VAR_10 += 5;\n      break;\n\n    case VAR_64:\n      /* COMMENT_41 */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&VAR_57->srcport, VAR_10 + 1, 2);\n      VAR_57->destport = UIP_HTONS(VAR_65 + (*(VAR_10 + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_57->srcport), UIP_HTONS(VAR_57->destport));\n      VAR_10 += 4;\n      break;\n\n    case VAR_66:\n      /* COMMENT_42 */\n      LOG_DBG(\"uncompression: source address\\n\");\n      VAR_57->srcport = UIP_HTONS(VAR_65 +\n                                   (*(VAR_10 + 1)));\n      memcpy(&VAR_57->destport, VAR_10 + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_57->srcport), UIP_HTONS(VAR_57->destport));\n      VAR_10 += 4;\n      break;\n\n    case VAR_62:\n      /* COMMENT_43 */\n      VAR_57->srcport = UIP_HTONS(VAR_67 +\n                                   (*(VAR_10 + 1) >> 4));\n      VAR_57->destport = UIP_HTONS(VAR_67 +\n                                    ((*(VAR_10 + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(VAR_57->srcport), UIP_HTONS(VAR_57->destport));\n      VAR_10 += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return;\n    }\n    if(!VAR_59) { /* COMMENT_44 */\n      memcpy(&VAR_57->udpchksum, VAR_10, 2);\n      VAR_10 += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* COMMENT_45 */\n    VAR_58 = 8 + packetbuf_datalen() - (VAR_10 - VAR_11);\n    VAR_57->udplen = UIP_HTONS(VAR_1 == 0 ? VAR_58 :\n                                VAR_1 - VAR_38 - VAR_9);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(VAR_57->udplen), VAR_9, VAR_1, VAR_58);\n\n    VAR_37 += VAR_68;\n  }\n\n  VAR_12 = VAR_10 - VAR_11;\n\n  /* COMMENT_46 */\n  if(VAR_1 == 0) {\n    int VAR_44 = packetbuf_datalen() - VAR_12 + VAR_37 - VAR_38;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", VAR_44,\n           packetbuf_datalen(), VAR_12, VAR_37, VAR_38);\n\n    /* COMMENT_47 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = VAR_44 >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = VAR_44 & 0x00FF;\n  } else {\n    /* COMMENT_48 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = (VAR_1 - VAR_38) >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = (VAR_1 - VAR_38) & 0x00FF;\n  }\n}",
  "func_graph_path_before": "contiki-ng/b88e5c303db21578799e5083bda9580922dc17b4/sicslowpan.c/vul/before/1.json",
  "func": "static void\nuncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n{\n  uint8_t tmp, iphc0, iphc1, nhc;\n  struct uip_ext_hdr *exthdr;\n  uint8_t* last_nextheader;\n  uint8_t* ip_payload;\n  uint8_t ext_hdr_len = 0;\n\n  /* at least two byte will be used for the encoding */\n  hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n\n  iphc0 = PACKETBUF_IPHC_BUF[0];\n  iphc1 = PACKETBUF_IPHC_BUF[1];\n\n  /* another if the CID flag is set */\n  if(iphc1 & SICSLOWPAN_IPHC_CID) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    hc06_ptr++;\n  }\n\n  /* Traffic class and flow label */\n    if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {\n      /* Flow label are carried inline */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is carried inline */\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);\n        tmp = *hc06_ptr;\n        hc06_ptr += 4;\n        /* IPHC format of tc is ECN | DSCP , original is DSCP | ECN */\n        /* set version, pick highest DSCP bits and set in vtc */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((tmp >> 2) & 0x0f);\n        /* ECN rolled down two steps + lowest DSCP bits at top two bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |\n          (SICSLOWPAN_IP_BUF(buf)->tcflow & 0x0f);\n      } else {\n        /* Traffic class is compressed (set version and no TC)*/\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        /* highest flow label bits + ECN bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |\n          ((*hc06_ptr >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);\n        hc06_ptr += 3;\n      }\n    } else {\n      /* Version is always 6! */\n      /* Version and flow label are compressed */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is inline */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(buf)->flow = 0;\n          hc06_ptr += 1;\n      } else {\n        /* Traffic class is compressed */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(buf)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n      }\n    }\n\n  /* Next Header */\n  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n    /* Next header is carried inline */\n    SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n    hc06_ptr += 1;\n  }\n\n  /* Hop limit */\n  if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {\n    SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n    hc06_ptr += 1;\n  }\n\n  /* put the source address compression mode SAM in the tmp var */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;\n\n  /* context based compression */\n  if(iphc1 & SICSLOWPAN_IPHC_SAC) {\n    uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?\n      PACKETBUF_IPHC_BUF[2] >> 4 : 0;\n\n    /* Source address - check context != NULL only if SAM bits are != 0*/\n    if (tmp != 0) {\n      context = addr_context_lookup_by_number(sci);\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n    }\n    /* if tmp == 0 we do not have a context and therefore no prefix */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr,\n                    tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  } else {\n    /* no compression and link local */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, llprefix, unc_llconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  }\n\n  /* Destination address */\n  /* put the destination address compression mode into tmp */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;\n\n  /* multicast compression */\n  if(iphc1 & SICSLOWPAN_IPHC_M) {\n    /* context based multicast compression */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      /* TODO: implement this */\n    } else {\n      /* non-context based multicast compression - */\n      /* DAM_00: 128 bits  */\n      /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */\n      /* DAM_10:  32 bits FFXX::00XX:XXXX */\n      /* DAM_11:   8 bits FF02::00XX */\n      uint8_t prefix[] = {0xff, 0x02};\n      if(tmp > 0 && tmp < 3) {\n        prefix[1] = *hc06_ptr;\n        hc06_ptr++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, prefix,\n                      unc_mxconf[tmp], NULL);\n    }\n  } else {\n    /* no multicast */\n    /* Context based */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] & 0x0f : 0;\n      context = addr_context_lookup_by_number(dci);\n\n      /* all valid cases below need the context! */\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n                      unc_ctxconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    } else {\n      /* not context based => link local M = 0, DAC = 0 - same as SAC */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, llprefix,\n                      unc_llconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    }\n  }\n  uncomp_hdr_len += UIP_IPH_LEN;\n\n  /* Next header processing - continued */\n  nhc = iphc0 & SICSLOWPAN_IPHC_NH_C;\n  /* The next header is compressed, NHC is following */\n  last_nextheader =  &SICSLOWPAN_IP_BUF(buf)->proto;\n  ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n\n  while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {\n    uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n    /* next header compression flag */\n    uint8_t nh = (*hc06_ptr & 0x01);\n    uint8_t next = 0;\n    uint8_t len;\n    uint8_t proto;\n\n    nhc = nh;\n\n    hc06_ptr++;\n    if(!nh) {\n      next = *hc06_ptr;\n      hc06_ptr++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", next);\n    }\n    len = *hc06_ptr;\n    hc06_ptr++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", eid, next, len);\n    switch(eid) {\n    case SICSLOWPAN_NHC_ETX_HDR_HBHO:\n      proto = UIP_PROTO_HBHO;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_ROUTING:\n      proto = UIP_PROTO_ROUTING;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_FRAG:\n      proto = UIP_PROTO_FRAG;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_DESTO:\n      proto = UIP_PROTO_DESTO;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return;\n    }\n    *last_nextheader = proto;\n\n    /* Check that there is enough room to write the extension header. */\n    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return;\n    }\n\n    /* uncompress the extension header */\n    exthdr = (struct uip_ext_hdr *)ip_payload;\n    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;\n    if(exthdr->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return;\n    }\n    exthdr->len--;\n    exthdr->next = next;\n    last_nextheader = &exthdr->next;\n    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n\n    hc06_ptr += len;\n    uncomp_hdr_len += (exthdr->len + 1) * 8;\n    ip_payload += (exthdr->len + 1) * 8;\n    ext_hdr_len += (exthdr->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            proto, len, exthdr->len, (exthdr->len + 1) * 8);\n  }\n\n  /* The next header is compressed, NHC is following */\n  if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {\n    struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n    uint16_t udp_len;\n    uint8_t checksum_compressed;\n    *last_nextheader = UIP_PROTO_UDP;\n    checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *hc06_ptr);\n    switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {\n    case SICSLOWPAN_NHC_UDP_CS_P_00:\n      /* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport),\n             UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 5;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_01:\n      /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_10:\n      /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n      LOG_DBG(\"uncompression: source address\\n\");\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1)));\n      memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_11:\n      /* 1 byte for NHC, 1 byte for ports */\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1) >> 4));\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                    ((*(hc06_ptr + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return;\n    }\n    if(!checksum_compressed) { /* has_checksum, default  */\n      memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n      hc06_ptr += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* length field in UDP header (8 byte header + payload) */\n    udp_len = 8 + packetbuf_datalen() - (hc06_ptr - packetbuf_ptr);\n    udp_buf->udplen = UIP_HTONS(ip_len == 0 ? udp_len :\n                                ip_len - UIP_IPH_LEN - ext_hdr_len);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(udp_buf->udplen), ext_hdr_len, ip_len, udp_len);\n\n    uncomp_hdr_len += UIP_UDPH_LEN;\n  }\n\n  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;\n\n  /* IP length field. */\n  if(ip_len == 0) {\n    int len = packetbuf_datalen() - packetbuf_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", len,\n           packetbuf_datalen(), packetbuf_hdr_len, uncomp_hdr_len, UIP_IPH_LEN);\n\n    /* This is not a fragmented packet */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = len >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = len & 0x00FF;\n  } else {\n    /* This is a 1st fragment */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;\n  }\n}",
  "abstract_func": "static void\nuncompress_hdr_iphc(uint8_t *VAR_0, uint16_t VAR_1, uint16_t VAR_2)\n{\n  uint8_t VAR_3, VAR_4, VAR_5, VAR_6;\n  struct uip_ext_hdr *VAR_7;\n  uint8_t* VAR_8;\n  uint8_t* VAR_9;\n  uint8_t VAR_10 = 0;\n\n  /* COMMENT_0 */\n  VAR_11 = VAR_12 + VAR_13 + 2;\n\n  VAR_4 = VAR_14[0];\n  VAR_5 = VAR_14[1];\n\n  /* COMMENT_1 */\n  if(VAR_5 & VAR_15) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    VAR_11++;\n  }\n\n  /* COMMENT_2 */\n    if((VAR_4 & VAR_16) == 0) {\n      /* COMMENT_3 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_4 */\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->tcflow, VAR_11 + 1, 3);\n        VAR_3 = *VAR_11;\n        VAR_11 += 4;\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((VAR_3 >> 2) & 0x0f);\n        /* COMMENT_7 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((VAR_3 >> 2) & 0x30) | (VAR_3 << 6) |\n          (SICSLOWPAN_IP_BUF(VAR_0)->tcflow & 0x0f);\n      } else {\n        /* COMMENT_8 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        /* COMMENT_9 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = (*VAR_11 & 0x0F) |\n          ((*VAR_11 >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->flow, VAR_11 + 1, 2);\n        VAR_11 += 3;\n      }\n    } else {\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_12 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((*VAR_11 >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((*VAR_11 << 6) & 0xC0) | ((*VAR_11 >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n          VAR_11 += 1;\n      } else {\n        /* COMMENT_13 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n      }\n    }\n\n  /* COMMENT_14 */\n  if((VAR_4 & VAR_18) == 0) {\n    /* COMMENT_15 */\n    SICSLOWPAN_IP_BUF(VAR_0)->proto = *VAR_11;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(VAR_0)->proto);\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_16 */\n  if((VAR_4 & 0x03) != VAR_19) {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = VAR_20[VAR_4 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = *VAR_11;\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_17 */\n  VAR_3 = ((VAR_5 & VAR_21) >> VAR_22) & 0x03;\n\n  /* COMMENT_18 */\n  if(VAR_5 & VAR_23) {\n    uint8_t VAR_24 = (VAR_5 & VAR_15) ?\n      VAR_14[2] >> 4 : 0;\n\n    /* COMMENT_19 */\n    if (VAR_3 != 0) {\n      VAR_25 = addr_context_lookup_by_number(VAR_24);\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n    }\n    /* COMMENT_20 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr,\n                    VAR_3 != 0 ? VAR_25->prefix : NULL, VAR_26[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  } else {\n    /* COMMENT_21 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr, VAR_28, VAR_29[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  }\n\n  /* COMMENT_22 */\n  /* COMMENT_23 */\n  VAR_3 = ((VAR_5 & VAR_30) >> VAR_31) & 0x03;\n\n  /* COMMENT_24 */\n  if(VAR_5 & VAR_32) {\n    /* COMMENT_25 */\n    if(VAR_5 & VAR_33) {\n      /* COMMENT_26 */\n    } else {\n      /* COMMENT_27 */\n      /* COMMENT_28 */\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      uint8_t VAR_34[] = {0xff, 0x02};\n      if(VAR_3 > 0 && VAR_3 < 3) {\n        VAR_34[1] = *VAR_11;\n        VAR_11++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_34,\n                      VAR_35[VAR_3], NULL);\n    }\n  } else {\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    if(VAR_5 & VAR_33) {\n      uint8_t VAR_36 = (VAR_5 & VAR_15) ? VAR_14[2] & 0x0f : 0;\n      VAR_25 = addr_context_lookup_by_number(VAR_36);\n\n      /* COMMENT_34 */\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_25->prefix,\n                      VAR_26[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    } else {\n      /* COMMENT_35 */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_28,\n                      VAR_29[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    }\n  }\n  VAR_38 += VAR_39;\n\n  /* COMMENT_36 */\n  VAR_6 = VAR_4 & VAR_18;\n  /* COMMENT_37 */\n  VAR_8 =  &SICSLOWPAN_IP_BUF(VAR_0)->proto;\n  VAR_9 = SICSLOWPAN_IPPAYLOAD_BUF(VAR_0);\n\n  while(VAR_6 && (*VAR_11 & VAR_40) == VAR_41) {\n    uint8_t VAR_42 = (*VAR_11 & 0x0e) >> 1;\n    /* COMMENT_38 */\n    uint8_t VAR_43 = (*VAR_11 & 0x01);\n    uint8_t VAR_44 = 0;\n    uint8_t VAR_45;\n    uint8_t VAR_46;\n\n    VAR_6 = VAR_43;\n\n    VAR_11++;\n    if(!VAR_43) {\n      VAR_44 = *VAR_11;\n      VAR_11++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", VAR_44);\n    }\n    VAR_45 = *VAR_11;\n    VAR_11++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", VAR_42, VAR_44, VAR_45);\n    switch(VAR_42) {\n    case VAR_47:\n      VAR_46 = VAR_48;\n      break;\n    case VAR_49:\n      VAR_46 = VAR_50;\n      break;\n    case VAR_51:\n      VAR_46 = VAR_52;\n      break;\n    case VAR_53:\n      VAR_46 = VAR_54;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return;\n    }\n    *VAR_8 = VAR_46;\n\n    /* COMMENT_39 */\n    if((VAR_9 - VAR_0) + VAR_55 + VAR_45 > VAR_1) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return;\n    }\n\n    /* COMMENT_40 */\n    VAR_7 = (struct uip_ext_hdr *)VAR_9;\n    VAR_7->len = (VAR_55 + VAR_45) / 8;\n    if(VAR_7->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return;\n    }\n    VAR_7->len--;\n    VAR_7->next = VAR_44;\n    VAR_8 = &VAR_7->next;\n    memcpy((uint8_t *)VAR_7 + VAR_55, VAR_11, VAR_45);\n\n    VAR_11 += VAR_45;\n    VAR_38 += (VAR_7->len + 1) * 8;\n    VAR_9 += (VAR_7->len + 1) * 8;\n    VAR_10 += (VAR_7->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            VAR_46, VAR_45, VAR_7->len, (VAR_7->len + 1) * 8);\n  }\n\n  /* COMMENT_37 */\n  if(VAR_6 && (*VAR_11 & VAR_56) == VAR_57) {\n    struct uip_udp_hdr *VAR_58 = (struct uip_udp_hdr *)VAR_9;\n    uint16_t VAR_59;\n    uint8_t VAR_60;\n    *VAR_8 = VAR_61;\n    VAR_60 = *VAR_11 & VAR_62;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *VAR_11);\n    switch(*VAR_11 & VAR_63) {\n    case VAR_64:\n      /* COMMENT_41 */\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      memcpy(&VAR_58->destport, VAR_11 + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport),\n             UIP_HTONS(VAR_58->destport));\n      VAR_11 += 5;\n      break;\n\n    case VAR_65:\n      /* COMMENT_42 */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      VAR_58->destport = UIP_HTONS(VAR_66 + (*(VAR_11 + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_67:\n      /* COMMENT_43 */\n      LOG_DBG(\"uncompression: source address\\n\");\n      VAR_58->srcport = UIP_HTONS(VAR_66 +\n                                   (*(VAR_11 + 1)));\n      memcpy(&VAR_58->destport, VAR_11 + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_63:\n      /* COMMENT_44 */\n      VAR_58->srcport = UIP_HTONS(VAR_68 +\n                                   (*(VAR_11 + 1) >> 4));\n      VAR_58->destport = UIP_HTONS(VAR_68 +\n                                    ((*(VAR_11 + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return;\n    }\n    if(!VAR_60) { /* COMMENT_45 */\n      memcpy(&VAR_58->udpchksum, VAR_11, 2);\n      VAR_11 += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* COMMENT_46 */\n    VAR_59 = 8 + packetbuf_datalen() - (VAR_11 - VAR_12);\n    VAR_58->udplen = UIP_HTONS(VAR_2 == 0 ? VAR_59 :\n                                VAR_2 - VAR_39 - VAR_10);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(VAR_58->udplen), VAR_10, VAR_2, VAR_59);\n\n    VAR_38 += VAR_69;\n  }\n\n  VAR_13 = VAR_11 - VAR_12;\n\n  /* COMMENT_47 */\n  if(VAR_2 == 0) {\n    int VAR_45 = packetbuf_datalen() - VAR_13 + VAR_38 - VAR_39;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", VAR_45,\n           packetbuf_datalen(), VAR_13, VAR_38, VAR_39);\n\n    /* COMMENT_48 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = VAR_45 >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = VAR_45 & 0x00FF;\n  } else {\n    /* COMMENT_49 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = (VAR_2 - VAR_39) >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = (VAR_2 - VAR_39) & 0x00FF;\n  }\n}",
  "func_graph_path": "contiki-ng/b88e5c303db21578799e5083bda9580922dc17b4/sicslowpan.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static void\n-uncompress_hdr_iphc(uint8_t *buf, uint16_t ip_len)\n+uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n {\n   uint8_t tmp, iphc0, iphc1, nhc;\n   struct uip_ext_hdr *exthdr;\n@@ -193,23 +193,32 @@\n       return;\n     }\n     *last_nextheader = proto;\n+\n+    /* Check that there is enough room to write the extension header. */\n+    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n+      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n+      return;\n+    }\n+\n     /* uncompress the extension header */\n     exthdr = (struct uip_ext_hdr *)ip_payload;\n-    exthdr->len = (2 + len) / 8 - 1;\n+    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;\n+    if(exthdr->len == 0) {\n+      LOG_WARN(\"Extension header length is below 8\\n\");\n+      return;\n+    }\n+    exthdr->len--;\n     exthdr->next = next;\n     last_nextheader = &exthdr->next;\n-    if(ip_len == 0 && (uint8_t *)exthdr - uip_buf + 2 + len > sizeof(uip_buf)) {\n-      LOG_DBG(\"uncompression: ext header points beyond uip buffer boundary\\n\");\n-      return;\n-    }\n-    memcpy((uint8_t*)exthdr + 2, hc06_ptr, len);\n+    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n+\n     hc06_ptr += len;\n     uncomp_hdr_len += (exthdr->len + 1) * 8;\n     ip_payload += (exthdr->len + 1) * 8;\n     ext_hdr_len += (exthdr->len + 1) * 8;\n \n-    LOG_DBG(\"uncompression: %d len: %d exhdrlen: %d (calc: %d)\\n\",\n-           proto, len, exthdr->len, (exthdr->len + 1) * 8);\n+    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n+            proto, len, exthdr->len, (exthdr->len + 1) * 8);\n   }\n \n   /* The next header is compressed, NHC is following */",
  "diff_line_info": {
    "deleted_lines": [
      "uncompress_hdr_iphc(uint8_t *buf, uint16_t ip_len)",
      "    exthdr->len = (2 + len) / 8 - 1;",
      "    if(ip_len == 0 && (uint8_t *)exthdr - uip_buf + 2 + len > sizeof(uip_buf)) {",
      "      LOG_DBG(\"uncompression: ext header points beyond uip buffer boundary\\n\");",
      "      return;",
      "    }",
      "    memcpy((uint8_t*)exthdr + 2, hc06_ptr, len);",
      "    LOG_DBG(\"uncompression: %d len: %d exhdrlen: %d (calc: %d)\\n\",",
      "           proto, len, exthdr->len, (exthdr->len + 1) * 8);"
    ],
    "added_lines": [
      "uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)",
      "",
      "    /* Check that there is enough room to write the extension header. */",
      "    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {",
      "      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");",
      "      return;",
      "    }",
      "",
      "    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;",
      "    if(exthdr->len == 0) {",
      "      LOG_WARN(\"Extension header length is below 8\\n\");",
      "      return;",
      "    }",
      "    exthdr->len--;",
      "    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);",
      "",
      "    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",",
      "            proto, len, exthdr->len, (exthdr->len + 1) * 8);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1409",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/contiki-ng/contiki-ng/pull/1409: 403 Client Error: Forbidden for url: https://api.github.com/repos/contiki-ng/contiki-ng/pulls/1409",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}