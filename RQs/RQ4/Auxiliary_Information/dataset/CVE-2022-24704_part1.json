{
  "cve_id": "CVE-2022-24704",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "accel-ppp",
  "commit_msg": "fix buffer overflow when receive radius packet\nThis patch fixes buffer overflow if radius packet contains invalid atribute length\nand attrubute type from the following list: ipv4addr, ipv6addr, ipv6prefix or ifid\n\nReported-by: Chloe Ong\nReported-by: Eugene Lim <spaceraccoon@users.noreply.github.com>\nReported-by: Kar Wei Loh\n\nSigned-off-by: Sergey V. Lobanov <sergey@lobanov.in>",
  "commit_hash": "d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615",
  "git_url": "https://github.com/accel-ppp/accel-ppp/commit/d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615",
  "file_path": "accel-pppd/radius/dict.c",
  "func_name": "dict_load",
  "func_before": "static int dict_load(const char *fname)\n{\n\tFILE *f;\n\tchar *ptr[4], *endptr;\n\tint r, n = 0;\n\tstruct rad_dict_attr_t *attr = NULL;\n\tstruct rad_dict_value_t *val;\n\tstruct rad_dict_vendor_t *vendor;\n\tstruct list_head *items;\n\tstruct list_head *parent_items = NULL;\n\n\tf = fopen(fname, \"r\");\n\tif (!f) {\n\t\tlog_emerg(\"radius: open dictionary '%s': %s\\n\", fname, strerror(errno));\n\t\treturn -1;\n\t}\n\n\titems = &dict->items;\n\n\twhile (fgets(buf, BUF_SIZE, f)) {\n\t\tn++;\n\t\tif (buf[0] == '#' || buf[0] == '\\n' || buf[0] == 0)\n\t\t\tcontinue;\n\t\tr = split(buf, ptr);\n\n\t\tif (*ptr[r - 1] == '#')\n\t\t\tr--;\n\n\t\tif (!strcmp(buf, \"VENDOR\")) {\n\t\t\tif (r < 2)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tvendor = malloc(sizeof(*vendor));\n\t\t\tif (!vendor) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tvendor->id = strtol(ptr[1], &endptr, 10);\n\t\t\tif (*endptr != 0)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tvendor->name = strdup(ptr[0]);\n\t\t\tif (!vendor->name) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tif (r == 3) {\n\t\t\t\tif (memcmp(ptr[2], \"format=\", 7))\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tvendor->tag = strtoul(ptr[2] + 7, &endptr, 10);\n\t\t\t\tif (*endptr != ',')\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tvendor->len = strtoul(endptr + 1, &endptr, 10);\n\t\t\t} else {\n\t\t\t\tvendor->tag = 1;\n\t\t\t\tvendor->len = 1;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&vendor->items);\n\t\t\tlist_add_tail(&vendor->entry, &dict->vendors);\n\t\t} else if (!strcmp(buf, \"BEGIN-VENDOR\")) {\n\t\t\t\tif (r < 1)\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tvendor = rad_dict_find_vendor_name(ptr[0]);\n\t\t\t\tif (!vendor) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: vendor not found\\n\", fname, n);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\titems = &vendor->items;\n\t\t} else if (!strcmp(buf, \"END-VENDOR\"))\n\t\t\titems = &dict->items;\n\t\telse if (!strcmp(buf, \"$INCLUDE\")) {\n\t\t\tif (r < 1)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tfor (r = strlen(path) - 1; r; r--)\n\t\t\t\tif (path[r] == '/') {\n\t\t\t\t\tpath[r + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tstrcpy(fname1, path);\n\t\t\tstrcat(fname1, ptr[0]);\n\t\t\tif (dict_load(fname1))\n\t\t\t\tgoto out_err;\n\t\t} else if (!strcmp(buf, \"BEGIN-TLV\")) {\n\t\t\tparent_items = items;\n\t\t\titems = &attr->tlv;\n\t\t} else if (!strcmp(buf, \"END-TLV\")) {\n\t\t\titems = parent_items;\n\t\t} else if (r > 2) {\n\t\t\tif (!strcmp(buf, \"ATTRIBUTE\")) {\n\t\t\t\tattr = malloc(sizeof(*attr));\n\t\t\t\tif (!attr) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\t\tINIT_LIST_HEAD(&attr->values);\n\t\t\t\tINIT_LIST_HEAD(&attr->tlv);\n\t\t\t\tlist_add_tail(&attr->entry, items);\n\t\t\t\tattr->name = strdup(ptr[0]);\n\t\t\t\tattr->id = strtol(ptr[1], &endptr, 10);\n\t\t\t\tattr->array = 0;\n\t\t\t\tattr->size = 0;\n\n\t\t\t\tif (r > 3 && !strcmp(ptr[3], \"array\"))\n\t\t\t\t\tattr->array = 1;\n\n\t\t\t\tif (!strcmp(ptr[2], \"integer\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_INTEGER;\n\t\t\t\t\tattr->size = 4;\n\t\t\t\t} else if (!strcmp(ptr[2], \"short\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_INTEGER;\n\t\t\t\t\tattr->size = 2;\n\t\t\t\t} else if (!strcmp(ptr[2], \"byte\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_INTEGER;\n\t\t\t\t\tattr->size = 1;\n\t\t\t\t} else if (!strcmp(ptr[2], \"string\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_STRING;\n\t\t\t\telse if (!strcmp(ptr[2], \"date\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_DATE;\n\t\t\t\telse if (!strcmp(ptr[2], \"ipaddr\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_IPADDR;\n\t\t\t\telse if (!strcmp(ptr[2], \"octets\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_OCTETS;\n\t\t\t\telse if (!strcmp(ptr[2], \"ifid\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_IFID;\n\t\t\t\telse if (!strcmp(ptr[2], \"ipv6addr\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_IPV6ADDR;\n\t\t\t\telse if (!strcmp(ptr[2], \"ipv6prefix\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_IPV6PREFIX;\n\t\t\t\telse if (!strcmp(ptr[2], \"ether\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_ETHER;\n\t\t\t\telse if (!strcmp(ptr[2], \"tlv\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_TLV;\n\t\t\t\telse {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute type\\n\", fname, n);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(buf, \"VALUE\")) {\n\t\t\t\tattr = find_attr(items, ptr[0]);\n\t\t\t\tif (!attr) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute\\n\", fname, n);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tval = malloc(sizeof(*val));\n\t\t\t\tif (!val) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(val, 0, sizeof(*val));\n\t\t\t\tlist_add_tail(&val->entry, &attr->values);\n\t\t\t\tval->name = strdup(ptr[1]);\n\t\t\t\tswitch (attr->type) {\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (ptr[2][0] == '0' && ptr[2][1] == 'x')\n\t\t\t\t\t\t\tval->val.integer = strtol(ptr[2] + 2, &endptr, 16);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tval->val.integer = strtol(ptr[2], &endptr, 10);\n\t\t\t\t\t\tif (*endptr != 0)\n\t\t\t\t\t\t\tgoto out_err_syntax;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tval->val.string = strdup(ptr[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'date' is not implemented yet\\n\", fname, n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'ipaddr' is not implemented yet\\n\", fname, n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tgoto out_err_syntax;\n\t\t} else\n\t\t\tgoto out_err_syntax;\n\t}\n\n\tfclose(f);\n\n\treturn 0;\n\nout_err_syntax:\n\tlog_emerg(\"radius:%s:%i: syntax error\\n\", fname, n);\nout_err:\n\tfclose(f);\n\treturn -1;\n}",
  "abstract_func_before": "static int dict_load(const char *VAR_0)\n{\n\tFILE *VAR_1;\n\tchar *VAR_2[4], *VAR_3;\n\tint VAR_4, VAR_5 = 0;\n\tstruct rad_dict_attr_t *VAR_6 = NULL;\n\tstruct rad_dict_value_t *VAR_7;\n\tstruct rad_dict_vendor_t *VAR_8;\n\tstruct list_head *VAR_9;\n\tstruct list_head *VAR_10 = NULL;\n\n\tVAR_1 = fopen(VAR_0, \"r\");\n\tif (!VAR_1) {\n\t\tlog_emerg(\"radius: open dictionary '%s': %s\\n\", VAR_0, strerror(VAR_11));\n\t\treturn -1;\n\t}\n\n\tVAR_9 = &VAR_12->items;\n\n\twhile (fgets(VAR_13, VAR_14, VAR_1)) {\n\t\tVAR_5++;\n\t\tif (VAR_13[0] == '#' || VAR_13[0] == '\\n' || VAR_13[0] == 0)\n\t\t\tcontinue;\n\t\tVAR_4 = split(VAR_13, VAR_2);\n\n\t\tif (*VAR_2[VAR_4 - 1] == '#')\n\t\t\tVAR_4--;\n\n\t\tif (!strcmp(VAR_13, \"VENDOR\")) {\n\t\t\tif (VAR_4 < 2)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tVAR_8 = malloc(sizeof(*VAR_8));\n\t\t\tif (!VAR_8) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tVAR_8->id = strtol(VAR_2[1], &VAR_3, 10);\n\t\t\tif (*VAR_3 != 0)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tVAR_8->name = strdup(VAR_2[0]);\n\t\t\tif (!VAR_8->name) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tif (VAR_4 == 3) {\n\t\t\t\tif (memcmp(VAR_2[2], \"format=\", 7))\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tVAR_8->tag = strtoul(VAR_2[2] + 7, &VAR_3, 10);\n\t\t\t\tif (*VAR_3 != ',')\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tVAR_8->len = strtoul(VAR_3 + 1, &VAR_3, 10);\n\t\t\t} else {\n\t\t\t\tVAR_8->tag = 1;\n\t\t\t\tVAR_8->len = 1;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&VAR_8->items);\n\t\t\tlist_add_tail(&VAR_8->entry, &VAR_12->vendors);\n\t\t} else if (!strcmp(VAR_13, \"BEGIN-VENDOR\")) {\n\t\t\t\tif (VAR_4 < 1)\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tVAR_8 = rad_dict_find_vendor_name(VAR_2[0]);\n\t\t\t\tif (!VAR_8) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: vendor not found\\n\", VAR_0, VAR_5);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tVAR_9 = &VAR_8->items;\n\t\t} else if (!strcmp(VAR_13, \"END-VENDOR\"))\n\t\t\tVAR_9 = &VAR_12->items;\n\t\telse if (!strcmp(VAR_13, \"$INCLUDE\")) {\n\t\t\tif (VAR_4 < 1)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tfor (VAR_4 = strlen(VAR_15) - 1; VAR_4; VAR_4--)\n\t\t\t\tif (VAR_15[VAR_4] == '/') {\n\t\t\t\t\tVAR_15[VAR_4 + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tstrcpy(VAR_16, VAR_15);\n\t\t\tstrcat(VAR_16, VAR_2[0]);\n\t\t\tif (dict_load(VAR_16))\n\t\t\t\tgoto out_err;\n\t\t} else if (!strcmp(VAR_13, \"BEGIN-TLV\")) {\n\t\t\tVAR_10 = VAR_9;\n\t\t\tVAR_9 = &VAR_6->tlv;\n\t\t} else if (!strcmp(VAR_13, \"END-TLV\")) {\n\t\t\tVAR_9 = VAR_10;\n\t\t} else if (VAR_4 > 2) {\n\t\t\tif (!strcmp(VAR_13, \"ATTRIBUTE\")) {\n\t\t\t\tVAR_6 = malloc(sizeof(*VAR_6));\n\t\t\t\tif (!VAR_6) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(VAR_6, 0, sizeof(*VAR_6));\n\t\t\t\tINIT_LIST_HEAD(&VAR_6->values);\n\t\t\t\tINIT_LIST_HEAD(&VAR_6->tlv);\n\t\t\t\tlist_add_tail(&VAR_6->entry, VAR_9);\n\t\t\t\tVAR_6->name = strdup(VAR_2[0]);\n\t\t\t\tVAR_6->id = strtol(VAR_2[1], &VAR_3, 10);\n\t\t\t\tVAR_6->array = 0;\n\t\t\t\tVAR_6->size = 0;\n\n\t\t\t\tif (VAR_4 > 3 && !strcmp(VAR_2[3], \"array\"))\n\t\t\t\t\tVAR_6->array = 1;\n\n\t\t\t\tif (!strcmp(VAR_2[2], \"integer\")) {\n\t\t\t\t\tVAR_6->type = VAR_17;\n\t\t\t\t\tVAR_6->size = 4;\n\t\t\t\t} else if (!strcmp(VAR_2[2], \"short\")) {\n\t\t\t\t\tVAR_6->type = VAR_17;\n\t\t\t\t\tVAR_6->size = 2;\n\t\t\t\t} else if (!strcmp(VAR_2[2], \"byte\")) {\n\t\t\t\t\tVAR_6->type = VAR_17;\n\t\t\t\t\tVAR_6->size = 1;\n\t\t\t\t} else if (!strcmp(VAR_2[2], \"string\"))\n\t\t\t\t\tVAR_6->type = VAR_18;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"date\"))\n\t\t\t\t\tVAR_6->type = VAR_19;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ipaddr\"))\n\t\t\t\t\tVAR_6->type = VAR_20;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"octets\"))\n\t\t\t\t\tVAR_6->type = VAR_21;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ifid\"))\n\t\t\t\t\tVAR_6->type = VAR_22;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ipv6addr\"))\n\t\t\t\t\tVAR_6->type = VAR_23;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ipv6prefix\"))\n\t\t\t\t\tVAR_6->type = VAR_24;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ether\"))\n\t\t\t\t\tVAR_6->type = VAR_25;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"tlv\"))\n\t\t\t\t\tVAR_6->type = VAR_26;\n\t\t\t\telse {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute type\\n\", VAR_0, VAR_5);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(VAR_13, \"VALUE\")) {\n\t\t\t\tVAR_6 = find_attr(VAR_9, VAR_2[0]);\n\t\t\t\tif (!VAR_6) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute\\n\", VAR_0, VAR_5);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tVAR_7 = malloc(sizeof(*VAR_7));\n\t\t\t\tif (!VAR_7) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(VAR_7, 0, sizeof(*VAR_7));\n\t\t\t\tlist_add_tail(&VAR_7->entry, &VAR_6->values);\n\t\t\t\tVAR_7->name = strdup(VAR_2[1]);\n\t\t\t\tswitch (VAR_6->type) {\n\t\t\t\t\tcase VAR_17:\n\t\t\t\t\t\tif (VAR_2[2][0] == '0' && VAR_2[2][1] == 'x')\n\t\t\t\t\t\t\tVAR_7->val.integer = strtol(VAR_2[2] + 2, &VAR_3, 16);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVAR_7->val.integer = strtol(VAR_2[2], &VAR_3, 10);\n\t\t\t\t\t\tif (*VAR_3 != 0)\n\t\t\t\t\t\t\tgoto out_err_syntax;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_18:\n\t\t\t\t\t\tVAR_7->val.string = strdup(VAR_2[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_19:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'date' is not implemented yet\\n\", VAR_0, VAR_5);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_20:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'ipaddr' is not implemented yet\\n\", VAR_0, VAR_5);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tgoto out_err_syntax;\n\t\t} else\n\t\t\tgoto out_err_syntax;\n\t}\n\n\tfclose(VAR_1);\n\n\treturn 0;\n\nout_err_syntax:\n\tlog_emerg(\"radius:%s:%i: syntax error\\n\", VAR_0, VAR_5);\nout_err:\n\tfclose(VAR_1);\n\treturn -1;\n}",
  "func_graph_path_before": "accel-ppp/d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615/dict.c/vul/before/0.json",
  "func": "static int dict_load(const char *fname)\n{\n\tFILE *f;\n\tchar *ptr[4], *endptr;\n\tint r, n = 0;\n\tstruct rad_dict_attr_t *attr = NULL;\n\tstruct rad_dict_value_t *val;\n\tstruct rad_dict_vendor_t *vendor;\n\tstruct list_head *items;\n\tstruct list_head *parent_items = NULL;\n\n\tf = fopen(fname, \"r\");\n\tif (!f) {\n\t\tlog_emerg(\"radius: open dictionary '%s': %s\\n\", fname, strerror(errno));\n\t\treturn -1;\n\t}\n\n\titems = &dict->items;\n\n\twhile (fgets(buf, BUF_SIZE, f)) {\n\t\tn++;\n\t\tif (buf[0] == '#' || buf[0] == '\\n' || buf[0] == 0)\n\t\t\tcontinue;\n\t\tr = split(buf, ptr);\n\n\t\tif (*ptr[r - 1] == '#')\n\t\t\tr--;\n\n\t\tif (!strcmp(buf, \"VENDOR\")) {\n\t\t\tif (r < 2)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tvendor = malloc(sizeof(*vendor));\n\t\t\tif (!vendor) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tvendor->id = strtol(ptr[1], &endptr, 10);\n\t\t\tif (*endptr != 0)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tvendor->name = strdup(ptr[0]);\n\t\t\tif (!vendor->name) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tif (r == 3) {\n\t\t\t\tif (memcmp(ptr[2], \"format=\", 7))\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tvendor->tag = strtoul(ptr[2] + 7, &endptr, 10);\n\t\t\t\tif (*endptr != ',')\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tvendor->len = strtoul(endptr + 1, &endptr, 10);\n\t\t\t} else {\n\t\t\t\tvendor->tag = 1;\n\t\t\t\tvendor->len = 1;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&vendor->items);\n\t\t\tlist_add_tail(&vendor->entry, &dict->vendors);\n\t\t} else if (!strcmp(buf, \"BEGIN-VENDOR\")) {\n\t\t\t\tif (r < 1)\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tvendor = rad_dict_find_vendor_name(ptr[0]);\n\t\t\t\tif (!vendor) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: vendor not found\\n\", fname, n);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\titems = &vendor->items;\n\t\t} else if (!strcmp(buf, \"END-VENDOR\"))\n\t\t\titems = &dict->items;\n\t\telse if (!strcmp(buf, \"$INCLUDE\")) {\n\t\t\tif (r < 1)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tfor (r = strlen(path) - 1; r; r--)\n\t\t\t\tif (path[r] == '/') {\n\t\t\t\t\tpath[r + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tstrcpy(fname1, path);\n\t\t\tstrcat(fname1, ptr[0]);\n\t\t\tif (dict_load(fname1))\n\t\t\t\tgoto out_err;\n\t\t} else if (!strcmp(buf, \"BEGIN-TLV\")) {\n\t\t\tparent_items = items;\n\t\t\titems = &attr->tlv;\n\t\t} else if (!strcmp(buf, \"END-TLV\")) {\n\t\t\titems = parent_items;\n\t\t} else if (r > 2) {\n\t\t\tif (!strcmp(buf, \"ATTRIBUTE\")) {\n\t\t\t\tattr = malloc(sizeof(*attr));\n\t\t\t\tif (!attr) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\t\tINIT_LIST_HEAD(&attr->values);\n\t\t\t\tINIT_LIST_HEAD(&attr->tlv);\n\t\t\t\tlist_add_tail(&attr->entry, items);\n\t\t\t\tattr->name = strdup(ptr[0]);\n\t\t\t\tattr->id = strtol(ptr[1], &endptr, 10);\n\t\t\t\tattr->array = 0;\n\t\t\t\tattr->size = 0;\n\n\t\t\t\tif (r > 3 && !strcmp(ptr[3], \"array\"))\n\t\t\t\t\tattr->array = 1;\n\n\t\t\t\tif (!strcmp(ptr[2], \"integer\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_INTEGER;\n\t\t\t\t\tattr->size = 4;\n\t\t\t\t} else if (!strcmp(ptr[2], \"short\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_INTEGER;\n\t\t\t\t\tattr->size = 2;\n\t\t\t\t} else if (!strcmp(ptr[2], \"byte\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_INTEGER;\n\t\t\t\t\tattr->size = 1;\n\t\t\t\t} else if (!strcmp(ptr[2], \"string\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_STRING;\n\t\t\t\telse if (!strcmp(ptr[2], \"date\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_DATE;\n\t\t\t\telse if (!strcmp(ptr[2], \"ipaddr\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_IPADDR;\n\t\t\t\t\tattr->size = 4; /* RFC 8044 §3.8 ipv4addr */\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(ptr[2], \"octets\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_OCTETS;\n\t\t\t\telse if (!strcmp(ptr[2], \"ifid\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_IFID;\n\t\t\t\t\tattr->size = 8; /* RFC 8044 §3.7 ifid */\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(ptr[2], \"ipv6addr\")) {\n\t\t\t\t\tattr->type = ATTR_TYPE_IPV6ADDR;\n\t\t\t\t\tattr->size = 16; /* RFC 8044 §3.9 ipv6addr */\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(ptr[2], \"ipv6prefix\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_IPV6PREFIX;\n\t\t\t\telse if (!strcmp(ptr[2], \"ether\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_ETHER;\n\t\t\t\telse if (!strcmp(ptr[2], \"tlv\"))\n\t\t\t\t\tattr->type = ATTR_TYPE_TLV;\n\t\t\t\telse {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute type\\n\", fname, n);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(buf, \"VALUE\")) {\n\t\t\t\tattr = find_attr(items, ptr[0]);\n\t\t\t\tif (!attr) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute\\n\", fname, n);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tval = malloc(sizeof(*val));\n\t\t\t\tif (!val) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(val, 0, sizeof(*val));\n\t\t\t\tlist_add_tail(&val->entry, &attr->values);\n\t\t\t\tval->name = strdup(ptr[1]);\n\t\t\t\tswitch (attr->type) {\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (ptr[2][0] == '0' && ptr[2][1] == 'x')\n\t\t\t\t\t\t\tval->val.integer = strtol(ptr[2] + 2, &endptr, 16);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tval->val.integer = strtol(ptr[2], &endptr, 10);\n\t\t\t\t\t\tif (*endptr != 0)\n\t\t\t\t\t\t\tgoto out_err_syntax;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tval->val.string = strdup(ptr[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'date' is not implemented yet\\n\", fname, n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'ipaddr' is not implemented yet\\n\", fname, n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tgoto out_err_syntax;\n\t\t} else\n\t\t\tgoto out_err_syntax;\n\t}\n\n\tfclose(f);\n\n\treturn 0;\n\nout_err_syntax:\n\tlog_emerg(\"radius:%s:%i: syntax error\\n\", fname, n);\nout_err:\n\tfclose(f);\n\treturn -1;\n}",
  "abstract_func": "static int dict_load(const char *VAR_0)\n{\n\tFILE *VAR_1;\n\tchar *VAR_2[4], *VAR_3;\n\tint VAR_4, VAR_5 = 0;\n\tstruct rad_dict_attr_t *VAR_6 = NULL;\n\tstruct rad_dict_value_t *VAR_7;\n\tstruct rad_dict_vendor_t *VAR_8;\n\tstruct list_head *VAR_9;\n\tstruct list_head *VAR_10 = NULL;\n\n\tVAR_1 = fopen(VAR_0, \"r\");\n\tif (!VAR_1) {\n\t\tlog_emerg(\"radius: open dictionary '%s': %s\\n\", VAR_0, strerror(VAR_11));\n\t\treturn -1;\n\t}\n\n\tVAR_9 = &VAR_12->items;\n\n\twhile (fgets(VAR_13, VAR_14, VAR_1)) {\n\t\tVAR_5++;\n\t\tif (VAR_13[0] == '#' || VAR_13[0] == '\\n' || VAR_13[0] == 0)\n\t\t\tcontinue;\n\t\tVAR_4 = split(VAR_13, VAR_2);\n\n\t\tif (*VAR_2[VAR_4 - 1] == '#')\n\t\t\tVAR_4--;\n\n\t\tif (!strcmp(VAR_13, \"VENDOR\")) {\n\t\t\tif (VAR_4 < 2)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tVAR_8 = malloc(sizeof(*VAR_8));\n\t\t\tif (!VAR_8) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tVAR_8->id = strtol(VAR_2[1], &VAR_3, 10);\n\t\t\tif (*VAR_3 != 0)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tVAR_8->name = strdup(VAR_2[0]);\n\t\t\tif (!VAR_8->name) {\n\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tif (VAR_4 == 3) {\n\t\t\t\tif (memcmp(VAR_2[2], \"format=\", 7))\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tVAR_8->tag = strtoul(VAR_2[2] + 7, &VAR_3, 10);\n\t\t\t\tif (*VAR_3 != ',')\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tVAR_8->len = strtoul(VAR_3 + 1, &VAR_3, 10);\n\t\t\t} else {\n\t\t\t\tVAR_8->tag = 1;\n\t\t\t\tVAR_8->len = 1;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&VAR_8->items);\n\t\t\tlist_add_tail(&VAR_8->entry, &VAR_12->vendors);\n\t\t} else if (!strcmp(VAR_13, \"BEGIN-VENDOR\")) {\n\t\t\t\tif (VAR_4 < 1)\n\t\t\t\t\tgoto out_err_syntax;\n\n\t\t\t\tVAR_8 = rad_dict_find_vendor_name(VAR_2[0]);\n\t\t\t\tif (!VAR_8) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: vendor not found\\n\", VAR_0, VAR_5);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tVAR_9 = &VAR_8->items;\n\t\t} else if (!strcmp(VAR_13, \"END-VENDOR\"))\n\t\t\tVAR_9 = &VAR_12->items;\n\t\telse if (!strcmp(VAR_13, \"$INCLUDE\")) {\n\t\t\tif (VAR_4 < 1)\n\t\t\t\tgoto out_err_syntax;\n\n\t\t\tfor (VAR_4 = strlen(VAR_15) - 1; VAR_4; VAR_4--)\n\t\t\t\tif (VAR_15[VAR_4] == '/') {\n\t\t\t\t\tVAR_15[VAR_4 + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tstrcpy(VAR_16, VAR_15);\n\t\t\tstrcat(VAR_16, VAR_2[0]);\n\t\t\tif (dict_load(VAR_16))\n\t\t\t\tgoto out_err;\n\t\t} else if (!strcmp(VAR_13, \"BEGIN-TLV\")) {\n\t\t\tVAR_10 = VAR_9;\n\t\t\tVAR_9 = &VAR_6->tlv;\n\t\t} else if (!strcmp(VAR_13, \"END-TLV\")) {\n\t\t\tVAR_9 = VAR_10;\n\t\t} else if (VAR_4 > 2) {\n\t\t\tif (!strcmp(VAR_13, \"ATTRIBUTE\")) {\n\t\t\t\tVAR_6 = malloc(sizeof(*VAR_6));\n\t\t\t\tif (!VAR_6) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(VAR_6, 0, sizeof(*VAR_6));\n\t\t\t\tINIT_LIST_HEAD(&VAR_6->values);\n\t\t\t\tINIT_LIST_HEAD(&VAR_6->tlv);\n\t\t\t\tlist_add_tail(&VAR_6->entry, VAR_9);\n\t\t\t\tVAR_6->name = strdup(VAR_2[0]);\n\t\t\t\tVAR_6->id = strtol(VAR_2[1], &VAR_3, 10);\n\t\t\t\tVAR_6->array = 0;\n\t\t\t\tVAR_6->size = 0;\n\n\t\t\t\tif (VAR_4 > 3 && !strcmp(VAR_2[3], \"array\"))\n\t\t\t\t\tVAR_6->array = 1;\n\n\t\t\t\tif (!strcmp(VAR_2[2], \"integer\")) {\n\t\t\t\t\tVAR_6->type = VAR_17;\n\t\t\t\t\tVAR_6->size = 4;\n\t\t\t\t} else if (!strcmp(VAR_2[2], \"short\")) {\n\t\t\t\t\tVAR_6->type = VAR_17;\n\t\t\t\t\tVAR_6->size = 2;\n\t\t\t\t} else if (!strcmp(VAR_2[2], \"byte\")) {\n\t\t\t\t\tVAR_6->type = VAR_17;\n\t\t\t\t\tVAR_6->size = 1;\n\t\t\t\t} else if (!strcmp(VAR_2[2], \"string\"))\n\t\t\t\t\tVAR_6->type = VAR_18;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"date\"))\n\t\t\t\t\tVAR_6->type = VAR_19;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ipaddr\")) {\n\t\t\t\t\tVAR_6->type = VAR_20;\n\t\t\t\t\tVAR_6->size = 4; /* COMMENT_0 */\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(VAR_2[2], \"octets\"))\n\t\t\t\t\tVAR_6->type = VAR_21;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ifid\")) {\n\t\t\t\t\tVAR_6->type = VAR_22;\n\t\t\t\t\tVAR_6->size = 8; /* COMMENT_1 */\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ipv6addr\")) {\n\t\t\t\t\tVAR_6->type = VAR_23;\n\t\t\t\t\tVAR_6->size = 16; /* COMMENT_2 */\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ipv6prefix\"))\n\t\t\t\t\tVAR_6->type = VAR_24;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"ether\"))\n\t\t\t\t\tVAR_6->type = VAR_25;\n\t\t\t\telse if (!strcmp(VAR_2[2], \"tlv\"))\n\t\t\t\t\tVAR_6->type = VAR_26;\n\t\t\t\telse {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute type\\n\", VAR_0, VAR_5);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(VAR_13, \"VALUE\")) {\n\t\t\t\tVAR_6 = find_attr(VAR_9, VAR_2[0]);\n\t\t\t\tif (!VAR_6) {\n\t\t\t\t\tlog_emerg(\"radius:%s:%i: unknown attribute\\n\", VAR_0, VAR_5);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tVAR_7 = malloc(sizeof(*VAR_7));\n\t\t\t\tif (!VAR_7) {\n\t\t\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tmemset(VAR_7, 0, sizeof(*VAR_7));\n\t\t\t\tlist_add_tail(&VAR_7->entry, &VAR_6->values);\n\t\t\t\tVAR_7->name = strdup(VAR_2[1]);\n\t\t\t\tswitch (VAR_6->type) {\n\t\t\t\t\tcase VAR_17:\n\t\t\t\t\t\tif (VAR_2[2][0] == '0' && VAR_2[2][1] == 'x')\n\t\t\t\t\t\t\tVAR_7->val.integer = strtol(VAR_2[2] + 2, &VAR_3, 16);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVAR_7->val.integer = strtol(VAR_2[2], &VAR_3, 10);\n\t\t\t\t\t\tif (*VAR_3 != 0)\n\t\t\t\t\t\t\tgoto out_err_syntax;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_18:\n\t\t\t\t\t\tVAR_7->val.string = strdup(VAR_2[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_19:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'date' is not implemented yet\\n\", VAR_0, VAR_5);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_20:\n\t\t\t\t\t\tlog_warn(\"radius:%s:%i: VALUE of type 'ipaddr' is not implemented yet\\n\", VAR_0, VAR_5);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tgoto out_err_syntax;\n\t\t} else\n\t\t\tgoto out_err_syntax;\n\t}\n\n\tfclose(VAR_1);\n\n\treturn 0;\n\nout_err_syntax:\n\tlog_emerg(\"radius:%s:%i: syntax error\\n\", VAR_0, VAR_5);\nout_err:\n\tfclose(VAR_1);\n\treturn -1;\n}",
  "func_graph_path": "accel-ppp/d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615/dict.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -124,14 +124,20 @@\n \t\t\t\t\tattr->type = ATTR_TYPE_STRING;\n \t\t\t\telse if (!strcmp(ptr[2], \"date\"))\n \t\t\t\t\tattr->type = ATTR_TYPE_DATE;\n-\t\t\t\telse if (!strcmp(ptr[2], \"ipaddr\"))\n+\t\t\t\telse if (!strcmp(ptr[2], \"ipaddr\")) {\n \t\t\t\t\tattr->type = ATTR_TYPE_IPADDR;\n+\t\t\t\t\tattr->size = 4; /* RFC 8044 §3.8 ipv4addr */\n+\t\t\t\t}\n \t\t\t\telse if (!strcmp(ptr[2], \"octets\"))\n \t\t\t\t\tattr->type = ATTR_TYPE_OCTETS;\n-\t\t\t\telse if (!strcmp(ptr[2], \"ifid\"))\n+\t\t\t\telse if (!strcmp(ptr[2], \"ifid\")) {\n \t\t\t\t\tattr->type = ATTR_TYPE_IFID;\n-\t\t\t\telse if (!strcmp(ptr[2], \"ipv6addr\"))\n+\t\t\t\t\tattr->size = 8; /* RFC 8044 §3.7 ifid */\n+\t\t\t\t}\n+\t\t\t\telse if (!strcmp(ptr[2], \"ipv6addr\")) {\n \t\t\t\t\tattr->type = ATTR_TYPE_IPV6ADDR;\n+\t\t\t\t\tattr->size = 16; /* RFC 8044 §3.9 ipv6addr */\n+\t\t\t\t}\n \t\t\t\telse if (!strcmp(ptr[2], \"ipv6prefix\"))\n \t\t\t\t\tattr->type = ATTR_TYPE_IPV6PREFIX;\n \t\t\t\telse if (!strcmp(ptr[2], \"ether\"))",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\telse if (!strcmp(ptr[2], \"ipaddr\"))",
      "\t\t\t\telse if (!strcmp(ptr[2], \"ifid\"))",
      "\t\t\t\telse if (!strcmp(ptr[2], \"ipv6addr\"))"
    ],
    "added_lines": [
      "\t\t\t\telse if (!strcmp(ptr[2], \"ipaddr\")) {",
      "\t\t\t\t\tattr->size = 4; /* RFC 8044 §3.8 ipv4addr */",
      "\t\t\t\t}",
      "\t\t\t\telse if (!strcmp(ptr[2], \"ifid\")) {",
      "\t\t\t\t\tattr->size = 8; /* RFC 8044 §3.7 ifid */",
      "\t\t\t\t}",
      "\t\t\t\telse if (!strcmp(ptr[2], \"ipv6addr\")) {",
      "\t\t\t\t\tattr->size = 16; /* RFC 8044 §3.9 ipv6addr */",
      "\t\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/accel-ppp/accel-ppp/pull/35",
  "description": {
    "pr_info": {
      "title": "fix buffer overflow when receive radius packet",
      "number": 35
    },
    "comment": [
      "This patch fixes buffer overflow if radius packet contains invalid atribute length\r\nand attrubute type from the following list: ipv4addr, ipv6addr or ifid\r\n\r\nReported-by: Chloe Ong\r\nReported-by: Eugene Lim <spaceraccoon@users.noreply.github.com>\r\nSigned-off-by: Sergey V. Lobanov <sergey@lobanov.in>",
      "Thanks @svlobanov , could you add one more credit:\r\n\r\nReported-by: Chloe Ong\r\nReported-by: Eugene Lim spaceraccoon@users.noreply.github.com\r\nReported-by: Kar Wei Loh\r\n\r\nThe patched code looks fine.\r\n\r\nThank you!\r\n\r\n",
      "Apologies @svlobanov, we spotted one more issue, the size has not been specified for the `ipv6prefix` case. It is possible to overflow there too.",
      "@spaceraccoon  thank you, the patch has been updated",
      "Hi @svlobanov , looks great, thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix\n**Confidence:** 1.0"
}