{
  "cve_id": "CVE-2021-32617",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Fix quadratic complexity performance bug.",
  "commit_hash": "c261fbaa2567687eec6a595d3016212fd6ae648d",
  "git_url": "https://github.com/Exiv2/exiv2/commit/c261fbaa2567687eec6a595d3016212fd6ae648d",
  "file_path": "xmpsdk/src/XMPMeta-Parse.cpp",
  "func_name": "ProcessUTF8Portion",
  "func_before": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * xmlParser,\n\t\t\t\t\t const XMP_Uns8 *   buffer,\n\t\t\t\t\t size_t\t\t\t\tlength,\n\t\t\t\t\t bool\t\t\t\tlast )\n{\n\tconst XMP_Uns8 * bufEnd = buffer + length;\n\t\n\tconst XMP_Uns8 * spanStart = buffer;\n\tconst XMP_Uns8 * spanEnd;\n\t\t\n\tfor ( spanEnd = spanStart; spanEnd < bufEnd; ++spanEnd ) {\n\n\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) continue;\t// A regular ASCII character.\n\n\t\tif ( *spanEnd >= 0x80 ) {\n\t\t\n\t\t\t// See if this is a multi-byte UTF-8 sequence, or a Latin-1 character to replace.\n\n\t\t\tint uniLen = CountUTF8 ( spanEnd, bufEnd );\n\n\t\t\tif ( uniLen > 0 ) {\n\n\t\t\t\t// A valid UTF-8 character, keep it as-is.\n\t\t\t\tspanEnd += uniLen - 1;\t// ! The loop increment will put back the +1.\n\n\t\t\t} else if ( (uniLen < 0) && (! last) ) {\n\n\t\t\t\t// Have a partial UTF-8 character at the end of the buffer and more input coming.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else {\n\n\t\t\t\t// Not a valid UTF-8 sequence. Replace the first byte with the Latin-1 equivalent.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\tconst char * replacement = kReplaceLatin1 [ *spanEnd - 0x80 ];\n\t\t\t\txmlParser->ParseBuffer ( replacement, strlen ( replacement ), false );\n\t\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*spanEnd < 0x20) || (*spanEnd == 0x7F) ) {\n\n\t\t\t// Replace ASCII controls other than tab, LF, and CR with a space.\n\n\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) continue;\n\n\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n\t\t\n\t\t} else {\n\t\t\n\t\t\t// See if this is a numeric escape sequence for a prohibited ASCII control.\n\t\t\t\n\t\t\tXMP_Assert ( *spanEnd == '&' );\n\t\t\tint escLen = CountControlEscape ( spanEnd, bufEnd );\n\t\t\t\n\t\t\tif ( escLen < 0 ) {\n\n\t\t\t\t// Have a partial numeric escape in this buffer, wait for more input.\n\t\t\t\tif ( last ) continue;\t// No more buffers, not an escape, absorb as normal input.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else if ( escLen > 0 ) {\n\n\t\t\t\t// Have a complete numeric escape to replace.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n\t\t\t\tspanStart = spanEnd + escLen;\n\t\t\t\tspanEnd = spanStart - 1;\t// ! The loop continuation will increment spanEnd!\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( spanEnd == bufEnd );\n\n\tif ( spanStart < bufEnd ) xmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\tif ( last ) xmlParser->ParseBuffer ( \" \", 1, true );\n\t\n\treturn length;\n\n}",
  "abstract_func_before": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * VAR_0,\n\t\t\t\t\t const XMP_Uns8 *   VAR_1,\n\t\t\t\t\t size_t\t\t\t\tVAR_2,\n\t\t\t\t\t bool\t\t\t\tVAR_3 )\n{\n\tconst XMP_Uns8 * VAR_4 = VAR_1 + VAR_2;\n\t\n\tconst XMP_Uns8 * VAR_5 = VAR_1;\n\tconst XMP_Uns8 * VAR_6;\n\t\t\n\tfor ( VAR_6 = VAR_5; VAR_6 < VAR_4; ++VAR_6 ) {\n\n\t\tif ( (0x20 <= *VAR_6) && (*VAR_6 <= 0x7E) && (*VAR_6 != '&') ) continue;\t/* COMMENT_0 */\n\n\t\tif ( *VAR_6 >= 0x80 ) {\n\t\t\n\t\t\t/* COMMENT_1 */\n\n\t\t\tint VAR_7 = CountUTF8 ( VAR_6, VAR_4 );\n\n\t\t\tif ( VAR_7 > 0 ) {\n\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tVAR_6 += VAR_7 - 1;\t/* COMMENT_3 */\n\n\t\t\t} else if ( (VAR_7 < 0) && (! VAR_3) ) {\n\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tVAR_0->ParseBuffer ( VAR_5, (VAR_6 - VAR_5), false );\n\t\t\t\treturn (VAR_6 - VAR_1);\n\n\t\t\t} else {\n\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tVAR_0->ParseBuffer ( VAR_5, (VAR_6 - VAR_5), false );\n\t\t\t\tconst char * VAR_8 = VAR_9 [ *VAR_6 - 0x80 ];\n\t\t\t\tVAR_0->ParseBuffer ( VAR_8, strlen ( VAR_8 ), false );\n\t\t\t\tVAR_5 = VAR_6 + 1;\t/* COMMENT_6 */\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*VAR_6 < 0x20) || (*VAR_6 == 0x7F) ) {\n\n\t\t\t/* COMMENT_7 */\n\n\t\t\tif ( (*VAR_6 == VAR_10) || (*VAR_6 == VAR_11) || (*VAR_6 == VAR_12) ) continue;\n\n\t\t\tVAR_0->ParseBuffer ( VAR_5, (VAR_6 - VAR_5), false );\n\t\t\tVAR_0->ParseBuffer ( \" \", 1, false );\n\t\t\tVAR_5 = VAR_6 + 1;\t/* COMMENT_6 */\n\t\t\n\t\t} else {\n\t\t\n\t\t\t/* COMMENT_8 */\n\t\t\t\n\t\t\tXMP_Assert ( *VAR_6 == '&' );\n\t\t\tint VAR_13 = CountControlEscape ( VAR_6, VAR_4 );\n\t\t\t\n\t\t\tif ( VAR_13 < 0 ) {\n\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\tif ( VAR_3 ) continue;\t/* COMMENT_10 */\n\t\t\t\tVAR_0->ParseBuffer ( VAR_5, (VAR_6 - VAR_5), false );\n\t\t\t\treturn (VAR_6 - VAR_1);\n\n\t\t\t} else if ( VAR_13 > 0 ) {\n\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\tVAR_0->ParseBuffer ( VAR_5, (VAR_6 - VAR_5), false );\n\t\t\t\tVAR_0->ParseBuffer ( \" \", 1, false );\n\t\t\t\tVAR_5 = VAR_6 + VAR_13;\n\t\t\t\tVAR_6 = VAR_5 - 1;\t/* COMMENT_12 */\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( VAR_6 == VAR_4 );\n\n\tif ( VAR_5 < VAR_4 ) VAR_0->ParseBuffer ( VAR_5, (VAR_6 - VAR_5), false );\n\tif ( VAR_3 ) VAR_0->ParseBuffer ( \" \", 1, true );\n\t\n\treturn VAR_2;\n\n}",
  "func_graph_path_before": "Exiv2/exiv2/c261fbaa2567687eec6a595d3016212fd6ae648d/XMPMeta-Parse.cpp/vul/before/0.json",
  "func": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * xmlParser,\n\t\t\t\t\t const XMP_Uns8 *   buffer,\n\t\t\t\t\t size_t\t\t\t\tlength,\n\t\t\t\t\t bool\t\t\t\tlast )\n{\n\tconst XMP_Uns8 * bufEnd = buffer + length;\n\t\n\tconst XMP_Uns8 * spanEnd;\n\n\t// `buffer` is copied into this std::string. If `buffer` only\n\t// contains valid UTF-8 and no escape characters, then the copy\n\t// will be identical to the original, but invalid characters are\n\t// replaced - usually with a space character.  This std::string was\n\t// added as a performance fix for:\n\t// https://github.com/Exiv2/exiv2/security/advisories/GHSA-w8mv-g8qq-36mj\n\t// Previously, the code was repeatedly calling\n\t// `xmlParser->ParseBuffer()`, which turned out to have quadratic\n\t// complexity, because expat kept reparsing the entire string from\n\t// the beginning.\n\tstd::string copy;\n\t\t\n\tfor ( spanEnd = buffer; spanEnd < bufEnd; ++spanEnd ) {\n\n\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) {\n\t\t\tcopy.push_back(*spanEnd);\n\t\t\tcontinue;\t// A regular ASCII character.\n\t\t}\n\n\t\tif ( *spanEnd >= 0x80 ) {\n\t\t\n\t\t\t// See if this is a multi-byte UTF-8 sequence, or a Latin-1 character to replace.\n\n\t\t\tint uniLen = CountUTF8 ( spanEnd, bufEnd );\n\n\t\t\tif ( uniLen > 0 ) {\n\n\t\t\t\t// A valid UTF-8 character, keep it as-is.\n\t\t\t\tcopy.append((const char*)spanEnd, uniLen);\n\t\t\t\tspanEnd += uniLen - 1;\t// ! The loop increment will put back the +1.\n\n\t\t\t} else if ( (uniLen < 0) && (! last) ) {\n\n\t\t\t\t// Have a partial UTF-8 character at the end of the buffer and more input coming.\n\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else {\n\n\t\t\t\t// Not a valid UTF-8 sequence. Replace the first byte with the Latin-1 equivalent.\n\t\t\t\tconst char * replacement = kReplaceLatin1 [ *spanEnd - 0x80 ];\n\t\t\t\tcopy.append ( replacement );\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*spanEnd < 0x20) || (*spanEnd == 0x7F) ) {\n\n\t\t\t// Replace ASCII controls other than tab, LF, and CR with a space.\n\n\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) {\n\t\t\t\tcopy.push_back(*spanEnd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcopy.push_back(' ');\n\t\t\n\t\t} else {\n\t\t\n\t\t\t// See if this is a numeric escape sequence for a prohibited ASCII control.\n\t\t\t\n\t\t\tXMP_Assert ( *spanEnd == '&' );\n\t\t\tint escLen = CountControlEscape ( spanEnd, bufEnd );\n\t\t\t\n\t\t\tif ( escLen < 0 ) {\n\n\t\t\t\t// Have a partial numeric escape in this buffer, wait for more input.\n\t\t\t\tif ( last ) {\n\t\t\t\t\tcopy.push_back('&');\n\t\t\t\t\tcontinue;\t// No more buffers, not an escape, absorb as normal input.\n\t\t\t\t}\n\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else if ( escLen > 0 ) {\n\n\t\t\t\t// Have a complete numeric escape to replace.\n\t\t\t\tcopy.push_back(' ');\n\t\t\t\tspanEnd = spanEnd + escLen - 1;\t// ! The loop continuation will increment spanEnd!\n\n\t\t\t} else {\n\t\t\t\tcopy.push_back('&');\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( spanEnd == bufEnd );\n\tcopy.push_back(' ');\n\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), true );\n\treturn length;\n\n}",
  "abstract_func": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * VAR_0,\n\t\t\t\t\t const XMP_Uns8 *   VAR_1,\n\t\t\t\t\t size_t\t\t\t\tVAR_2,\n\t\t\t\t\t bool\t\t\t\tVAR_3 )\n{\n\tconst XMP_Uns8 * VAR_4 = VAR_1 + VAR_2;\n\t\n\tconst XMP_Uns8 * VAR_5;\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\t/* COMMENT_7 */\n\t/* COMMENT_8 */\n\t/* COMMENT_9 */\n\tstd::string VAR_6;\n\t\t\n\tfor ( VAR_5 = VAR_1; VAR_5 < VAR_4; ++VAR_5 ) {\n\n\t\tif ( (0x20 <= *VAR_5) && (*VAR_5 <= 0x7E) && (*VAR_5 != '&') ) {\n\t\t\tVAR_6.push_back(*VAR_5);\n\t\t\tcontinue;\t/* COMMENT_10 */\n\t\t}\n\n\t\tif ( *VAR_5 >= 0x80 ) {\n\t\t\n\t\t\t/* COMMENT_11 */\n\n\t\t\tint VAR_7 = CountUTF8 ( VAR_5, VAR_4 );\n\n\t\t\tif ( VAR_7 > 0 ) {\n\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tVAR_6.append((const char*)VAR_5, VAR_7);\n\t\t\t\tVAR_5 += VAR_7 - 1;\t/* COMMENT_13 */\n\n\t\t\t} else if ( (VAR_7 < 0) && (! VAR_3) ) {\n\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tVAR_0->ParseBuffer ( VAR_6.c_str(), VAR_6.size(), false );\n\t\t\t\treturn (VAR_5 - VAR_1);\n\n\t\t\t} else {\n\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tconst char * VAR_8 = VAR_9 [ *VAR_5 - 0x80 ];\n\t\t\t\tVAR_6.append ( VAR_8 );\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*VAR_5 < 0x20) || (*VAR_5 == 0x7F) ) {\n\n\t\t\t/* COMMENT_16 */\n\n\t\t\tif ( (*VAR_5 == VAR_10) || (*VAR_5 == VAR_11) || (*VAR_5 == VAR_12) ) {\n\t\t\t\tVAR_6.push_back(*VAR_5);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tVAR_6.push_back(' ');\n\t\t\n\t\t} else {\n\t\t\n\t\t\t/* COMMENT_17 */\n\t\t\t\n\t\t\tXMP_Assert ( *VAR_5 == '&' );\n\t\t\tint VAR_13 = CountControlEscape ( VAR_5, VAR_4 );\n\t\t\t\n\t\t\tif ( VAR_13 < 0 ) {\n\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tif ( VAR_3 ) {\n\t\t\t\t\tVAR_6.push_back('&');\n\t\t\t\t\tcontinue;\t/* COMMENT_19 */\n\t\t\t\t}\n\t\t\t\tVAR_0->ParseBuffer ( VAR_6.c_str(), VAR_6.size(), false );\n\t\t\t\treturn (VAR_5 - VAR_1);\n\n\t\t\t} else if ( VAR_13 > 0 ) {\n\n\t\t\t\t/* COMMENT_20 */\n\t\t\t\tVAR_6.push_back(' ');\n\t\t\t\tVAR_5 = VAR_5 + VAR_13 - 1;\t/* COMMENT_21 */\n\n\t\t\t} else {\n\t\t\t\tVAR_6.push_back('&');\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( VAR_5 == VAR_4 );\n\tVAR_6.push_back(' ');\n\tVAR_0->ParseBuffer ( VAR_6.c_str(), VAR_6.size(), true );\n\treturn VAR_2;\n\n}",
  "func_graph_path": "Exiv2/exiv2/c261fbaa2567687eec6a595d3016212fd6ae648d/XMPMeta-Parse.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,26 @@\n {\n \tconst XMP_Uns8 * bufEnd = buffer + length;\n \t\n-\tconst XMP_Uns8 * spanStart = buffer;\n \tconst XMP_Uns8 * spanEnd;\n+\n+\t// `buffer` is copied into this std::string. If `buffer` only\n+\t// contains valid UTF-8 and no escape characters, then the copy\n+\t// will be identical to the original, but invalid characters are\n+\t// replaced - usually with a space character.  This std::string was\n+\t// added as a performance fix for:\n+\t// https://github.com/Exiv2/exiv2/security/advisories/GHSA-w8mv-g8qq-36mj\n+\t// Previously, the code was repeatedly calling\n+\t// `xmlParser->ParseBuffer()`, which turned out to have quadratic\n+\t// complexity, because expat kept reparsing the entire string from\n+\t// the beginning.\n+\tstd::string copy;\n \t\t\n-\tfor ( spanEnd = spanStart; spanEnd < bufEnd; ++spanEnd ) {\n+\tfor ( spanEnd = buffer; spanEnd < bufEnd; ++spanEnd ) {\n \n-\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) continue;\t// A regular ASCII character.\n+\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) {\n+\t\t\tcopy.push_back(*spanEnd);\n+\t\t\tcontinue;\t// A regular ASCII character.\n+\t\t}\n \n \t\tif ( *spanEnd >= 0x80 ) {\n \t\t\n@@ -22,21 +36,20 @@\n \t\t\tif ( uniLen > 0 ) {\n \n \t\t\t\t// A valid UTF-8 character, keep it as-is.\n+\t\t\t\tcopy.append((const char*)spanEnd, uniLen);\n \t\t\t\tspanEnd += uniLen - 1;\t// ! The loop increment will put back the +1.\n \n \t\t\t} else if ( (uniLen < 0) && (! last) ) {\n \n \t\t\t\t// Have a partial UTF-8 character at the end of the buffer and more input coming.\n-\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n+\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n \t\t\t\treturn (spanEnd - buffer);\n \n \t\t\t} else {\n \n \t\t\t\t// Not a valid UTF-8 sequence. Replace the first byte with the Latin-1 equivalent.\n-\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n \t\t\t\tconst char * replacement = kReplaceLatin1 [ *spanEnd - 0x80 ];\n-\t\t\t\txmlParser->ParseBuffer ( replacement, strlen ( replacement ), false );\n-\t\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n+\t\t\t\tcopy.append ( replacement );\n \n \t\t\t}\n \t\t\n@@ -44,11 +57,12 @@\n \n \t\t\t// Replace ASCII controls other than tab, LF, and CR with a space.\n \n-\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) continue;\n+\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) {\n+\t\t\t\tcopy.push_back(*spanEnd);\n+\t\t\t\tcontinue;\n+\t\t\t}\n \n-\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n-\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n-\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n+\t\t\tcopy.push_back(' ');\n \t\t\n \t\t} else {\n \t\t\n@@ -60,18 +74,21 @@\n \t\t\tif ( escLen < 0 ) {\n \n \t\t\t\t// Have a partial numeric escape in this buffer, wait for more input.\n-\t\t\t\tif ( last ) continue;\t// No more buffers, not an escape, absorb as normal input.\n-\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n+\t\t\t\tif ( last ) {\n+\t\t\t\t\tcopy.push_back('&');\n+\t\t\t\t\tcontinue;\t// No more buffers, not an escape, absorb as normal input.\n+\t\t\t\t}\n+\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n \t\t\t\treturn (spanEnd - buffer);\n \n \t\t\t} else if ( escLen > 0 ) {\n \n \t\t\t\t// Have a complete numeric escape to replace.\n-\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n-\t\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n-\t\t\t\tspanStart = spanEnd + escLen;\n-\t\t\t\tspanEnd = spanStart - 1;\t// ! The loop continuation will increment spanEnd!\n+\t\t\t\tcopy.push_back(' ');\n+\t\t\t\tspanEnd = spanEnd + escLen - 1;\t// ! The loop continuation will increment spanEnd!\n \n+\t\t\t} else {\n+\t\t\t\tcopy.push_back('&');\n \t\t\t}\n \n \t\t}\n@@ -79,10 +96,8 @@\n \t}\n \t\n \tXMP_Assert ( spanEnd == bufEnd );\n-\n-\tif ( spanStart < bufEnd ) xmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n-\tif ( last ) xmlParser->ParseBuffer ( \" \", 1, true );\n-\t\n+\tcopy.push_back(' ');\n+\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), true );\n \treturn length;\n \n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tconst XMP_Uns8 * spanStart = buffer;",
      "\tfor ( spanEnd = spanStart; spanEnd < bufEnd; ++spanEnd ) {",
      "\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) continue;\t// A regular ASCII character.",
      "\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );",
      "\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );",
      "\t\t\t\txmlParser->ParseBuffer ( replacement, strlen ( replacement ), false );",
      "\t\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".",
      "\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) continue;",
      "\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );",
      "\t\t\txmlParser->ParseBuffer ( \" \", 1, false );",
      "\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".",
      "\t\t\t\tif ( last ) continue;\t// No more buffers, not an escape, absorb as normal input.",
      "\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );",
      "\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );",
      "\t\t\t\txmlParser->ParseBuffer ( \" \", 1, false );",
      "\t\t\t\tspanStart = spanEnd + escLen;",
      "\t\t\t\tspanEnd = spanStart - 1;\t// ! The loop continuation will increment spanEnd!",
      "",
      "\tif ( spanStart < bufEnd ) xmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );",
      "\tif ( last ) xmlParser->ParseBuffer ( \" \", 1, true );",
      "\t"
    ],
    "added_lines": [
      "",
      "\t// `buffer` is copied into this std::string. If `buffer` only",
      "\t// contains valid UTF-8 and no escape characters, then the copy",
      "\t// will be identical to the original, but invalid characters are",
      "\t// replaced - usually with a space character.  This std::string was",
      "\t// added as a performance fix for:",
      "\t// https://github.com/Exiv2/exiv2/security/advisories/GHSA-w8mv-g8qq-36mj",
      "\t// Previously, the code was repeatedly calling",
      "\t// `xmlParser->ParseBuffer()`, which turned out to have quadratic",
      "\t// complexity, because expat kept reparsing the entire string from",
      "\t// the beginning.",
      "\tstd::string copy;",
      "\tfor ( spanEnd = buffer; spanEnd < bufEnd; ++spanEnd ) {",
      "\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) {",
      "\t\t\tcopy.push_back(*spanEnd);",
      "\t\t\tcontinue;\t// A regular ASCII character.",
      "\t\t}",
      "\t\t\t\tcopy.append((const char*)spanEnd, uniLen);",
      "\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );",
      "\t\t\t\tcopy.append ( replacement );",
      "\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) {",
      "\t\t\t\tcopy.push_back(*spanEnd);",
      "\t\t\t\tcontinue;",
      "\t\t\t}",
      "\t\t\tcopy.push_back(' ');",
      "\t\t\t\tif ( last ) {",
      "\t\t\t\t\tcopy.push_back('&');",
      "\t\t\t\t\tcontinue;\t// No more buffers, not an escape, absorb as normal input.",
      "\t\t\t\t}",
      "\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );",
      "\t\t\t\tcopy.push_back(' ');",
      "\t\t\t\tspanEnd = spanEnd + escLen - 1;\t// ! The loop continuation will increment spanEnd!",
      "\t\t\t} else {",
      "\t\t\t\tcopy.push_back('&');",
      "\tcopy.push_back(' ');",
      "\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), true );"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.95"
}