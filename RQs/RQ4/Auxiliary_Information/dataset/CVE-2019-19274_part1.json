{
  "cve_id": "CVE-2019-19274",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "python/typed_ast",
  "commit_msg": "Fix two out-of-bounds array reads (#99)\n\nThe patch is taken from a commit to the CPython repo with the message:\r\n\r\nbpo-36495: Fix two out-of-bounds array reads (GH-12641)\r\n\r\nResearch and fix by @bradlarsen.",
  "commit_hash": "dc317ac9cff859aa84eeabe03fb5004982545b3b",
  "git_url": "https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b",
  "file_path": "ast3/Python/ast.c",
  "func_name": "handle_keywordonly_args",
  "func_before": "static int\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; /* '=' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME ':' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}",
  "abstract_func_before": "static int\nhandle_keywordonly_args(struct compiling *VAR_0, const node *VAR_1, int VAR_2,\n                        asdl_seq *VAR_3, asdl_seq *VAR_4)\n{\n    PyObject *VAR_5;\n    node *VAR_6;\n    expr_ty VAR_7, VAR_8;\n    arg_ty VAR_9 = NULL;\n    int VAR_10 = VAR_2;\n    int VAR_11 = 0; /* COMMENT_0 */\n\n    if (VAR_3 == NULL) {\n        ast_error(VAR_0, CHILD(VAR_1, VAR_2), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(VAR_4 != NULL);\n    while (VAR_10 < NCH(VAR_1)) {\n        VAR_6 = CHILD(VAR_1, VAR_10);\n        switch (TYPE(VAR_6)) {\n            case VAR_12:\n            case VAR_13:\n                if (VAR_10 + 1 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_10 + 1)) == VAR_14) {\n                    VAR_7 = ast_for_expr(VAR_0, CHILD(VAR_1, VAR_10 + 2));\n                    if (!VAR_7)\n                        goto error;\n                    asdl_seq_SET(VAR_4, VAR_11, VAR_7);\n                    VAR_10 += 2; /* COMMENT_1 */\n                }\n                else { /* COMMENT_2 */\n                    asdl_seq_SET(VAR_4, VAR_11, NULL);\n                }\n                if (NCH(VAR_6) == 3) {\n                    /* COMMENT_3 */\n                    VAR_8 = ast_for_expr(VAR_0, CHILD(VAR_6, 2));\n                    if (!VAR_8)\n                        goto error;\n                }\n                else {\n                    VAR_8 = NULL;\n                }\n                VAR_6 = CHILD(VAR_6, 0);\n                VAR_5 = NEW_IDENTIFIER(VAR_6);\n                if (!VAR_5)\n                    goto error;\n                if (forbidden_name(VAR_0, VAR_5, VAR_6, 0))\n                    goto error;\n                VAR_9 = VAR_9(VAR_5, VAR_8, NULL, LINENO(VAR_6), VAR_6->n_col_offset,\n                          VAR_0->c_arena);\n                if (!VAR_9)\n                    goto error;\n                asdl_seq_SET(VAR_3, VAR_11++, VAR_9);\n                VAR_10 += 1; /* COMMENT_4 */\n                if (TYPE(CHILD(VAR_1, VAR_10)) == VAR_15)\n                    VAR_10 += 1; /* COMMENT_5 */\n                break;\n            case VAR_16:\n                /* COMMENT_6 */\n                VAR_9->type_comment = NEW_TYPE_COMMENT(VAR_6);\n                if (!VAR_9->type_comment)\n                    goto error;\n                VAR_10 += 1;\n                break;\n            case VAR_17:\n                return VAR_10;\n            default:\n                ast_error(VAR_0, VAR_6, \"unexpected node\");\n                goto error;\n        }\n    }\n    return VAR_10;\n error:\n    return -1;\n}",
  "func_graph_path_before": "python/typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b/ast.c/vul/before/0.json",
  "func": "static int\nhandle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg = NULL;\n    int i = start;\n    int j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; /* '=' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME ':' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    goto error;\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}",
  "abstract_func": "static int\nhandle_keywordonly_args(struct compiling *VAR_0, const node *VAR_1, int VAR_2,\n                        asdl_seq *VAR_3, asdl_seq *VAR_4)\n{\n    PyObject *VAR_5;\n    node *VAR_6;\n    expr_ty VAR_7, VAR_8;\n    arg_ty VAR_9 = NULL;\n    int VAR_10 = VAR_2;\n    int VAR_11 = 0; /* COMMENT_0 */\n\n    if (VAR_3 == NULL) {\n        ast_error(VAR_0, CHILD(VAR_1, VAR_2), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(VAR_4 != NULL);\n    while (VAR_10 < NCH(VAR_1)) {\n        VAR_6 = CHILD(VAR_1, VAR_10);\n        switch (TYPE(VAR_6)) {\n            case VAR_12:\n            case VAR_13:\n                if (VAR_10 + 1 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_10 + 1)) == VAR_14) {\n                    VAR_7 = ast_for_expr(VAR_0, CHILD(VAR_1, VAR_10 + 2));\n                    if (!VAR_7)\n                        goto error;\n                    asdl_seq_SET(VAR_4, VAR_11, VAR_7);\n                    VAR_10 += 2; /* COMMENT_1 */\n                }\n                else { /* COMMENT_2 */\n                    asdl_seq_SET(VAR_4, VAR_11, NULL);\n                }\n                if (NCH(VAR_6) == 3) {\n                    /* COMMENT_3 */\n                    VAR_8 = ast_for_expr(VAR_0, CHILD(VAR_6, 2));\n                    if (!VAR_8)\n                        goto error;\n                }\n                else {\n                    VAR_8 = NULL;\n                }\n                VAR_6 = CHILD(VAR_6, 0);\n                VAR_5 = NEW_IDENTIFIER(VAR_6);\n                if (!VAR_5)\n                    goto error;\n                if (forbidden_name(VAR_0, VAR_5, VAR_6, 0))\n                    goto error;\n                VAR_9 = VAR_9(VAR_5, VAR_8, NULL, LINENO(VAR_6), VAR_6->n_col_offset,\n                          VAR_0->c_arena);\n                if (!VAR_9)\n                    goto error;\n                asdl_seq_SET(VAR_3, VAR_11++, VAR_9);\n                VAR_10 += 1; /* COMMENT_4 */\n                if (VAR_10 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_10)) == VAR_15)\n                    VAR_10 += 1; /* COMMENT_5 */\n                break;\n            case VAR_16:\n                /* COMMENT_6 */\n                VAR_9->type_comment = NEW_TYPE_COMMENT(VAR_6);\n                if (!VAR_9->type_comment)\n                    goto error;\n                VAR_10 += 1;\n                break;\n            case VAR_17:\n                return VAR_10;\n            default:\n                ast_error(VAR_0, VAR_6, \"unexpected node\");\n                goto error;\n        }\n    }\n    return VAR_10;\n error:\n    return -1;\n}",
  "func_graph_path": "python/typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b/ast.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -50,7 +50,7 @@\n                     goto error;\n                 asdl_seq_SET(kwonlyargs, j++, arg);\n                 i += 1; /* the name */\n-                if (TYPE(CHILD(n, i)) == COMMA)\n+                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                     i += 1; /* the comma, if present */\n                 break;\n             case TYPE_COMMENT:",
  "diff_line_info": {
    "deleted_lines": [
      "                if (TYPE(CHILD(n, i)) == COMMA)"
    ],
    "added_lines": [
      "                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/typed_ast/pull/99",
  "description": {
    "pr_info": {
      "title": "Fix two out-of-bounds array reads",
      "number": 99
    },
    "comment": [
      "The patch is taken from a commit to the CPython repo with the message:\r\n\r\n> bpo-36495: Fix two out-of-bounds array reads (GH-12641)\r\n> \r\n> Research and fix by @bradlarsen.\r\n\r\nSome code I have triggered segmentation fault when I run pylint on it. With this patch, I don't get segmentation fault anylonger.\r\n\r\nBacktrace from GDB:\r\n#0  0x00001ff4e48a883b in ast_for_arguments () from $HOME/.local/lib/python3.6/site-packages/typed_ast/_ast3.so\r\n#1  0x00001ff4e48ac4c0 in ast_for_funcdef_impl () from $HOME/.local/lib/python3.6/site-packages/typed_ast/_ast3.so\r\n#2  0x00001ff4e48ac315 in ast_for_suite () from $HOME/.local/lib/python3.6/site-packages/typed_ast/_ast3.so\r\n#3  0x00001ff4e48abd1e in ast_for_classdef () from $HOME/.local/lib/python3.6/site-packages/typed_ast/_ast3.so\r\n#4  0x00001ff4e48a22c7 in Ta3AST_FromNodeObject () from $HOME/.local/lib/python3.6/site-packages/typed_ast/_ast3.so\r\n#5  0x00001ff4e48c4f93 in ast3_parse () from $HOME/.local/lib/python3.6/site-packages/typed_ast/_ast3.so\r\n#6  0x00001ff550af508a in _PyCFunction_FastCallDict () from /usr/local/lib/libpython3.6m.so.0.0\r\n#7  0x00001ff550b86798 in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#8  0x00001ff550b80c0e in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#9  0x00001ff550b87168 in _PyEval_EvalCodeWithName () from /usr/local/lib/libpython3.6m.so.0.0\r\n#10 0x00001ff550b88081 in _PyFunction_FastCallDict () from /usr/local/lib/libpython3.6m.so.0.0\r\n#11 0x00001ff550a9dd3d in _PyObject_FastCallDict () from /usr/local/lib/libpython3.6m.so.0.0\r\n#12 0x00001ff550bf8f76 in partial_call () from /usr/local/lib/libpython3.6m.so.0.0\r\n#13 0x00001ff550a9ddea in _PyObject_FastCallDict () from /usr/local/lib/libpython3.6m.so.0.0\r\n#14 0x00001ff550b86765 in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#15 0x00001ff550b80c0e in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#16 0x00001ff550b87168 in _PyEval_EvalCodeWithName () from /usr/local/lib/libpython3.6m.so.0.0\r\n#17 0x00001ff550b87cbb in fast_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#18 0x00001ff550b8676c in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#19 0x00001ff550b80c0e in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#20 0x00001ff550b87d46 in fast_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#21 0x00001ff550b8676c in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#22 0x00001ff550b80c0e in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#23 0x00001ff550b87168 in _PyEval_EvalCodeWithName () from /usr/local/lib/libpython3.6m.so.0.0\r\n#24 0x00001ff550b87cbb in fast_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#25 0x00001ff550b8676c in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#26 0x00001ff550b80c0e in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#27 0x00001ff550b87168 in _PyEval_EvalCodeWithName () from /usr/local/lib/libpython3.6m.so.0.0\r\n#28 0x00001ff550b87cbb in fast_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#29 0x00001ff550b8676c in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#30 0x00001ff550b835c9 in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#31 0x00001ff550b87168 in _PyEval_EvalCodeWithName () from /usr/local/lib/libpython3.6m.so.0.0\r\n#32 0x00001ff550b87cbb in fast_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#33 0x00001ff550b8676c in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#34 0x00001ff550b80c0e in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#35 0x00001ff550b87168 in _PyEval_EvalCodeWithName () from /usr/local/lib/libpython3.6m.so.0.0\r\n#36 0x00001ff550b87cbb in fast_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#37 0x00001ff550b8676c in call_function () from /usr/local/lib/libpython3.6m.so.0.0\r\n#38 0x00001ff550b835c9 in _PyEval_EvalFrameDefault () from /usr/local/lib/libpython3.6m.so.0.0\r\n#39 0x00001ff550b87168 in _PyEval_EvalCodeWithName () from /usr/local/lib/libpython3.6m.so.0.0\r\n",
      "Hello, and thanks for your contribution!\n\nI'm a bot set up to make sure that the project can legally accept your contribution by verifying you have signed the [PSF contributor agreement](https://www.python.org/psf/contrib/contrib-form/) (CLA).\n\nUnfortunately we couldn't find an account corresponding to your GitHub username on [bugs.python.org](https://bugs.python.org/) (b.p.o) to verify you have signed the CLA (this might be simply due to a missing \"GitHub Name\" entry in your b.p.o account settings). This is necessary for legal reasons before we can look at your contribution. Please follow [the steps outlined in the CPython devguide](https://devguide.python.org/pullrequest/#licensing) to rectify this issue.\n\n\nYou can [check yourself](https://check-python-cla.herokuapp.com/) to see if the CLA has been received.\n\nThanks again for your contribution, we look forward to reviewing it!\n",
      "Thanks! Are you planning to sign the CLA? If not, I'll treat this as a bug report and apply the fix myself.",
      "@gvanrossum I signed the agreement now, but apparently it may take one business day for it to show up on github.",
      "OK, once the CLA bot changes the label I'll merge this. Thanks for your contribution!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}