{
  "cve_id": "CVE-2023-45897",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "exfatprogs",
  "commit_msg": "fsck: fix out-of-bounds memory access\n\nThe size of utf16_name is ENTRY_NAME_MAX, we should pass\nENTRY_NAME_MAX to exfat_utf16_len(), not ENTRY_NAME_MAX*2.\n\nexfat_utf16_enc() returns the length of the utf16-encoded\nfilename, it is not needed to call exfat_utf16_len().\n\nSigned-off-by: Yuezhang Mo <Yuezhang.Mo@sony.com>\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>",
  "commit_hash": "22d0e43e8d24119cbfc6efafabb0dec6517a86c4",
  "git_url": "https://github.com/exfatprogs/exfatprogs/commit/22d0e43e8d24119cbfc6efafabb0dec6517a86c4",
  "file_path": "fsck/fsck.c",
  "func_name": "handle_dot_dotdot_filename",
  "func_before": "static int handle_dot_dotdot_filename(struct exfat_de_iter *iter,\n\t\t\t\t      struct exfat_dentry *dentry,\n\t\t\t\t      int strm_name_len)\n{\n\tchar *filename;\n\tchar error_msg[150];\n\tint num;\n\n\tif (!memcmp(dentry->name_unicode, MSDOS_DOT, strm_name_len * 2))\n\t\tfilename = \".\";\n\telse if (!memcmp(dentry->name_unicode, MSDOS_DOTDOT,\n\t\t\t strm_name_len * 2))\n\t\tfilename = \"..\";\n\telse\n\t\treturn 0;\n\n\tsprintf(error_msg, \"ERROR: '%s' filename is not allowed.\\n\"\n\t\t\t\" [1] Insert the name you want to rename.\\n\"\n\t\t\t\" [2] Automatically renames filename.\\n\"\n\t\t\t\" [3] Bypass this check(No repair)\\n\", filename);\nask_again:\n\tnum = exfat_repair_ask(&exfat_fsck, ER_DE_DOT_NAME,\n\t\t\t       error_msg);\n\tif (num) {\n\t\t__le16 utf16_name[ENTRY_NAME_MAX];\n\t\tchar *rename = NULL;\n\t\t__u16 hash;\n\t\tstruct exfat_dentry *stream_de;\n\t\tint name_len, ret;\n\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\trename = get_rename_from_user(iter);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trename = generate_rename(iter);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texfat_info(\"select 1 or 2 number instead of %d\\n\", num);\n\t\t\tgoto ask_again;\n\t\t}\n\n\t\tif (!rename)\n\t\t\treturn -EINVAL;\n\n\t\texfat_info(\"%s filename is renamed to %s\\n\", filename, rename);\n\n\t\texfat_de_iter_get_dirty(iter, 2, &dentry);\n\n\t\tmemset(utf16_name, 0, sizeof(utf16_name));\n\t\tret = exfat_utf16_enc(rename, utf16_name, sizeof(utf16_name));\n\t\tfree(rename);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmemcpy(dentry->name_unicode, utf16_name, ENTRY_NAME_MAX * 2);\n\t\tname_len = exfat_utf16_len(utf16_name, ENTRY_NAME_MAX * 2);\n\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, (int)name_len);\n\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\tstream_de->stream_name_len = (__u8)name_len;\n\t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n\t}\n\n\treturn 0;\n}",
  "abstract_func_before": "static int handle_dot_dotdot_filename(struct exfat_de_iter *VAR_0,\n\t\t\t\t      struct exfat_dentry *VAR_1,\n\t\t\t\t      int VAR_2)\n{\n\tchar *VAR_3;\n\tchar VAR_4[150];\n\tint VAR_5;\n\n\tif (!memcmp(VAR_1->name_unicode, VAR_6, VAR_2 * 2))\n\t\tVAR_3 = \".\";\n\telse if (!memcmp(VAR_1->name_unicode, VAR_7,\n\t\t\t VAR_2 * 2))\n\t\tVAR_3 = \"..\";\n\telse\n\t\treturn 0;\n\n\tsprintf(VAR_4, \"ERROR: '%s' filename is not allowed.\\n\"\n\t\t\t\" [1] Insert the name you want to rename.\\n\"\n\t\t\t\" [2] Automatically renames filename.\\n\"\n\t\t\t\" [3] Bypass this check(No repair)\\n\", VAR_3);\nask_again:\n\tVAR_5 = exfat_repair_ask(&VAR_8, VAR_9,\n\t\t\t       VAR_4);\n\tif (VAR_5) {\n\t\t__le16 VAR_10[VAR_11];\n\t\tchar *VAR_12 = NULL;\n\t\t__u16 VAR_13;\n\t\tstruct exfat_dentry *VAR_14;\n\t\tint VAR_15, VAR_16;\n\n\t\tswitch (VAR_5) {\n\t\tcase 1:\n\t\t\tVAR_12 = get_rename_from_user(VAR_0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_12 = generate_rename(VAR_0);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texfat_info(\"select 1 or 2 number instead of %d\\n\", VAR_5);\n\t\t\tgoto ask_again;\n\t\t}\n\n\t\tif (!VAR_12)\n\t\t\treturn -VAR_17;\n\n\t\texfat_info(\"%s filename is renamed to %s\\n\", VAR_3, VAR_12);\n\n\t\texfat_de_iter_get_dirty(VAR_0, 2, &VAR_1);\n\n\t\tmemset(VAR_10, 0, sizeof(VAR_10));\n\t\tVAR_16 = exfat_utf16_enc(VAR_12, VAR_10, sizeof(VAR_10));\n\t\tfree(VAR_12);\n\t\tif (VAR_16 < 0)\n\t\t\treturn VAR_16;\n\n\t\tmemcpy(VAR_1->name_unicode, VAR_10, VAR_11 * 2);\n\t\tVAR_15 = exfat_utf16_len(VAR_10, VAR_11 * 2);\n\t\tVAR_13 = exfat_calc_name_hash(VAR_0->exfat, VAR_10, (int)VAR_15);\n\t\texfat_de_iter_get_dirty(VAR_0, 1, &VAR_14);\n\t\tVAR_14->stream_name_len = (__u8)VAR_15;\n\t\tVAR_14->stream_name_hash = cpu_to_le16(VAR_13);\n\t}\n\n\treturn 0;\n}",
  "func_graph_path_before": "exfatprogs/22d0e43e8d24119cbfc6efafabb0dec6517a86c4/fsck.c/vul/before/0.json",
  "func": "static int handle_dot_dotdot_filename(struct exfat_de_iter *iter,\n\t\t\t\t      struct exfat_dentry *dentry,\n\t\t\t\t      int strm_name_len)\n{\n\tchar *filename;\n\tchar error_msg[150];\n\tint num;\n\n\tif (!memcmp(dentry->name_unicode, MSDOS_DOT, strm_name_len * 2))\n\t\tfilename = \".\";\n\telse if (!memcmp(dentry->name_unicode, MSDOS_DOTDOT,\n\t\t\t strm_name_len * 2))\n\t\tfilename = \"..\";\n\telse\n\t\treturn 0;\n\n\tsprintf(error_msg, \"ERROR: '%s' filename is not allowed.\\n\"\n\t\t\t\" [1] Insert the name you want to rename.\\n\"\n\t\t\t\" [2] Automatically renames filename.\\n\"\n\t\t\t\" [3] Bypass this check(No repair)\\n\", filename);\nask_again:\n\tnum = exfat_repair_ask(&exfat_fsck, ER_DE_DOT_NAME,\n\t\t\t       error_msg);\n\tif (num) {\n\t\t__le16 utf16_name[ENTRY_NAME_MAX];\n\t\tchar *rename = NULL;\n\t\t__u16 hash;\n\t\tstruct exfat_dentry *stream_de;\n\t\tint ret;\n\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\trename = get_rename_from_user(iter);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trename = generate_rename(iter);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texfat_info(\"select 1 or 2 number instead of %d\\n\", num);\n\t\t\tgoto ask_again;\n\t\t}\n\n\t\tif (!rename)\n\t\t\treturn -EINVAL;\n\n\t\texfat_info(\"%s filename is renamed to %s\\n\", filename, rename);\n\n\t\texfat_de_iter_get_dirty(iter, 2, &dentry);\n\n\t\tmemset(utf16_name, 0, sizeof(utf16_name));\n\t\tret = exfat_utf16_enc(rename, utf16_name, sizeof(utf16_name));\n\t\tfree(rename);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret >>= 1;\n\t\tmemcpy(dentry->name_unicode, utf16_name, ENTRY_NAME_MAX * 2);\n\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, ret);\n\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\tstream_de->stream_name_len = (__u8)ret;\n\t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n\t}\n\n\treturn 0;\n}",
  "abstract_func": "static int handle_dot_dotdot_filename(struct exfat_de_iter *VAR_0,\n\t\t\t\t      struct exfat_dentry *VAR_1,\n\t\t\t\t      int VAR_2)\n{\n\tchar *VAR_3;\n\tchar VAR_4[150];\n\tint VAR_5;\n\n\tif (!memcmp(VAR_1->name_unicode, VAR_6, VAR_2 * 2))\n\t\tVAR_3 = \".\";\n\telse if (!memcmp(VAR_1->name_unicode, VAR_7,\n\t\t\t VAR_2 * 2))\n\t\tVAR_3 = \"..\";\n\telse\n\t\treturn 0;\n\n\tsprintf(VAR_4, \"ERROR: '%s' filename is not allowed.\\n\"\n\t\t\t\" [1] Insert the name you want to rename.\\n\"\n\t\t\t\" [2] Automatically renames filename.\\n\"\n\t\t\t\" [3] Bypass this check(No repair)\\n\", VAR_3);\nask_again:\n\tVAR_5 = exfat_repair_ask(&VAR_8, VAR_9,\n\t\t\t       VAR_4);\n\tif (VAR_5) {\n\t\t__le16 VAR_10[VAR_11];\n\t\tchar *VAR_12 = NULL;\n\t\t__u16 VAR_13;\n\t\tstruct exfat_dentry *VAR_14;\n\t\tint VAR_15;\n\n\t\tswitch (VAR_5) {\n\t\tcase 1:\n\t\t\tVAR_12 = get_rename_from_user(VAR_0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_12 = generate_rename(VAR_0);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texfat_info(\"select 1 or 2 number instead of %d\\n\", VAR_5);\n\t\t\tgoto ask_again;\n\t\t}\n\n\t\tif (!VAR_12)\n\t\t\treturn -VAR_16;\n\n\t\texfat_info(\"%s filename is renamed to %s\\n\", VAR_3, VAR_12);\n\n\t\texfat_de_iter_get_dirty(VAR_0, 2, &VAR_1);\n\n\t\tmemset(VAR_10, 0, sizeof(VAR_10));\n\t\tVAR_15 = exfat_utf16_enc(VAR_12, VAR_10, sizeof(VAR_10));\n\t\tfree(VAR_12);\n\t\tif (VAR_15 < 0)\n\t\t\treturn VAR_15;\n\n\t\tVAR_15 >>= 1;\n\t\tmemcpy(VAR_1->name_unicode, VAR_10, VAR_11 * 2);\n\t\tVAR_13 = exfat_calc_name_hash(VAR_0->exfat, VAR_10, VAR_15);\n\t\texfat_de_iter_get_dirty(VAR_0, 1, &VAR_14);\n\t\tVAR_14->stream_name_len = (__u8)VAR_15;\n\t\tVAR_14->stream_name_hash = cpu_to_le16(VAR_13);\n\t}\n\n\treturn 0;\n}",
  "func_graph_path": "exfatprogs/22d0e43e8d24119cbfc6efafabb0dec6517a86c4/fsck.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n \t\tchar *rename = NULL;\n \t\t__u16 hash;\n \t\tstruct exfat_dentry *stream_de;\n-\t\tint name_len, ret;\n+\t\tint ret;\n \n \t\tswitch (num) {\n \t\tcase 1:\n@@ -55,11 +55,11 @@\n \t\tif (ret < 0)\n \t\t\treturn ret;\n \n+\t\tret >>= 1;\n \t\tmemcpy(dentry->name_unicode, utf16_name, ENTRY_NAME_MAX * 2);\n-\t\tname_len = exfat_utf16_len(utf16_name, ENTRY_NAME_MAX * 2);\n-\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, (int)name_len);\n+\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, ret);\n \t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n-\t\tstream_de->stream_name_len = (__u8)name_len;\n+\t\tstream_de->stream_name_len = (__u8)ret;\n \t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n \t}\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tint name_len, ret;",
      "\t\tname_len = exfat_utf16_len(utf16_name, ENTRY_NAME_MAX * 2);",
      "\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, (int)name_len);",
      "\t\tstream_de->stream_name_len = (__u8)name_len;"
    ],
    "added_lines": [
      "\t\tint ret;",
      "\t\tret >>= 1;",
      "\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, ret);",
      "\t\tstream_de->stream_name_len = (__u8)ret;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/exfatprogs/exfatprogs/pull/239",
  "description": {
    "pr_info": {
      "title": "Merge exfat-next into mater branch",
      "number": 239
    },
    "comment": [
      "    CHANGES :\r\n     * exfat2img: Allow dumps for read-only devices.\r\n     * fsck.exfat: Revert Repairing zero size directory.\r\n    \r\n    NEW FEATURES :\r\n     * fsck.exfat: Repair duplicated filename.\r\n     * mkfs.exfat: Add the option \"q\" to print only error messages.\r\n     * mkfs.exfat: Add the option \"U\" to set volume GUID.\r\n     * tune.exfat: Add the option \"U\" / \"-u\" to set or print volume GUID.\r\n    \r\n    BUG FIXES:\r\n     * fsck.exfat: Fix some out-of-bounds memory accesses.\r\n     * fsck.exfat: Change not to delete volume GUID directory entry.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe patch addresses an out-of-bounds memory access issue, which is a security vulnerability. The code changes correctly calculate the name length to prevent buffer overflow, as described in the commit and supported by the vulnerability description."
}