{
  "cve_id": "CVE-2019-1010297",
  "cwe_ids": [
    "CWE-190",
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "svc: check for allocation overflow in crypto calls\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0010: \"Integer overflow in crypto system calls (x2)\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
  "commit_hash": "a637243270fc1faae16de059091795c32d86e65e",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e",
  "file_path": "core/tee/tee_svc_cryp.c",
  "func_name": "syscall_cryp_derive_key",
  "func_before": "TEE_Result syscall_cryp_derive_key(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count, unsigned long derived_key)\n{\n\tTEE_Result res = TEE_ERROR_NOT_SUPPORTED;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *ko;\n\tstruct tee_obj *so;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_cryp_obj_secret *sk;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, param_count, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Get key set in operation */\n\tres = tee_obj_get(utc, cs->key1, &ko);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(derived_key), &so);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Find information needed about the object to initialize */\n\tsk = so->attr;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(so->info.objectType);\n\tif (!type_props) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {\n\t\tsize_t alloc_size;\n\t\tstruct bignum *pub;\n\t\tstruct bignum *ss;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\talloc_size = params[0].content.ref.length * 8;\n\t\tpub = crypto_bignum_allocate(alloc_size);\n\t\tss = crypto_bignum_allocate(alloc_size);\n\t\tif (pub && ss) {\n\t\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t\t     params[0].content.ref.length, pub);\n\t\t\tres = crypto_acipher_dh_shared_secret(ko->attr,\n\t\t\t\t\t\t\t      pub, ss);\n\t\t\tif (res == TEE_SUCCESS) {\n\t\t\t\tsk->key_size = crypto_bignum_num_bytes(ss);\n\t\t\t\tcrypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));\n\t\t\t\tso->info.handleFlags |=\n\t\t\t\t\t\tTEE_HANDLE_FLAG_INITIALIZED;\n\t\t\t\tset_attribute(so, type_props,\n\t\t\t\t\t      TEE_ATTR_SECRET_VALUE);\n\t\t\t}\n\t\t} else {\n\t\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcrypto_bignum_free(pub);\n\t\tcrypto_bignum_free(ss);\n\t} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {\n\t\tsize_t alloc_size;\n\t\tstruct ecc_public_key key_public;\n\t\tuint8_t *pt_secret;\n\t\tunsigned long pt_secret_len;\n\n\t\tif (param_count != 2 ||\n\t\t    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||\n\t\t    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cs->algo) {\n\t\tcase TEE_ALG_ECDH_P192:\n\t\t\talloc_size = 192;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P224:\n\t\t\talloc_size = 224;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P256:\n\t\t\talloc_size = 256;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P384:\n\t\t\talloc_size = 384;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P521:\n\t\t\talloc_size = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Create the public key */\n\t\tres = crypto_acipher_alloc_ecc_public_key(&key_public,\n\t\t\t\t\t\t\t  alloc_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tkey_public.curve = ((struct ecc_keypair *)ko->attr)->curve;\n\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t     params[0].content.ref.length,\n\t\t\t\t     key_public.x);\n\t\tcrypto_bignum_bin2bn(params[1].content.ref.buffer,\n\t\t\t\t     params[1].content.ref.length,\n\t\t\t\t     key_public.y);\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,\n\t\t\t\t\t\t       pt_secret,\n\t\t\t\t\t\t       &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\n\t\t/* free the public key */\n\t\tcrypto_acipher_free_ecc_public_key(&key_public);\n\t}\n#if defined(CFG_CRYPTO_HKDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {\n\t\tvoid *salt, *info;\n\t\tsize_t salt_len, info_len, okm_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ik = ko->attr;\n\t\tconst uint8_t *ikm = (const uint8_t *)(ik + 1);\n\n\t\tres = get_hkdf_params(params, param_count, &salt, &salt_len,\n\t\t\t\t      &info, &info_len, &okm_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (okm_len > ik->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,\n\t\t\t\t    info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t    okm_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = okm_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {\n\t\tvoid *info;\n\t\tsize_t info_len, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *shared_secret = (const uint8_t *)(ss + 1);\n\n\t\tres = get_concat_kdf_params(params, param_count, &info,\n\t\t\t\t\t    &info_len, &derived_key_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,\n\t\t\t\t\t  info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t\t  derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {\n\t\tvoid *salt;\n\t\tsize_t salt_len, iteration_count, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *password = (const uint8_t *)(ss + 1);\n\n\t\tres = get_pbkdf2_params(params, param_count, &salt, &salt_len,\n\t\t\t\t\t&derived_key_len, &iteration_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,\n\t\t\t\t      salt_len, iteration_count,\n\t\t\t\t      (uint8_t *)(sk + 1), derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n\telse\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\nout:\n\tfree(params);\n\treturn res;\n}",
  "abstract_func_before": "TEE_Result syscall_cryp_derive_key(unsigned long VAR_0,\n\t\t\tconst struct utee_attribute *VAR_1,\n\t\t\tunsigned long VAR_2, unsigned long VAR_3)\n{\n\tTEE_Result VAR_4 = VAR_5;\n\tstruct tee_ta_session *VAR_6;\n\tstruct tee_obj *VAR_7;\n\tstruct tee_obj *VAR_8;\n\tstruct tee_cryp_state *VAR_9;\n\tstruct tee_cryp_obj_secret *VAR_10;\n\tconst struct tee_cryp_obj_type_props *VAR_11;\n\tTEE_Attribute *VAR_12 = NULL;\n\tstruct user_ta_ctx *VAR_13;\n\n\tVAR_4 = tee_ta_get_current_session(&VAR_6);\n\tif (VAR_4 != VAR_14)\n\t\treturn VAR_4;\n\tVAR_13 = to_user_ta_ctx(VAR_6->ctx);\n\n\tVAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);\n\tif (VAR_4 != VAR_14)\n\t\treturn VAR_4;\n\n\tVAR_12 = malloc(sizeof(TEE_Attribute) * VAR_2);\n\tif (!VAR_12)\n\t\treturn VAR_15;\n\tVAR_4 = copy_in_attrs(VAR_13, VAR_1, VAR_2, VAR_12);\n\tif (VAR_4 != VAR_14)\n\t\tgoto out;\n\n\t/* COMMENT_0 */\n\tVAR_4 = tee_obj_get(VAR_13, VAR_9->key1, &VAR_7);\n\tif (VAR_4 != VAR_14)\n\t\tgoto out;\n\n\tVAR_4 = tee_obj_get(VAR_13, tee_svc_uref_to_vaddr(VAR_3), &VAR_8);\n\tif (VAR_4 != VAR_14)\n\t\tgoto out;\n\n\t/* COMMENT_1 */\n\tVAR_10 = VAR_8->attr;\n\n\t/* COMMENT_2 */\n\tVAR_11 = tee_svc_find_type_props(VAR_8->info.objectType);\n\tif (!VAR_11) {\n\t\tVAR_4 = VAR_5;\n\t\tgoto out;\n\t}\n\n\tif (VAR_9->algo == VAR_16) {\n\t\tsize_t VAR_17;\n\t\tstruct bignum *VAR_18;\n\t\tstruct bignum *VAR_19;\n\n\t\tif (VAR_2 != 1 ||\n\t\t    VAR_12[0].attributeID != VAR_20) {\n\t\t\tVAR_4 = VAR_21;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_17 = VAR_12[0].content.ref.length * 8;\n\t\tVAR_18 = crypto_bignum_allocate(VAR_17);\n\t\tVAR_19 = crypto_bignum_allocate(VAR_17);\n\t\tif (VAR_18 && VAR_19) {\n\t\t\tcrypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,\n\t\t\t\t\t     VAR_12[0].content.ref.length, VAR_18);\n\t\t\tVAR_4 = crypto_acipher_dh_shared_secret(VAR_7->attr,\n\t\t\t\t\t\t\t      VAR_18, VAR_19);\n\t\t\tif (VAR_4 == VAR_14) {\n\t\t\t\tVAR_10->key_size = crypto_bignum_num_bytes(VAR_19);\n\t\t\t\tcrypto_bignum_bn2bin(VAR_19, (uint8_t *)(VAR_10 + 1));\n\t\t\t\tVAR_8->info.handleFlags |=\n\t\t\t\t\t\tVAR_22;\n\t\t\t\tset_attribute(VAR_8, VAR_11,\n\t\t\t\t\t      VAR_23);\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_4 = VAR_15;\n\t\t}\n\t\tcrypto_bignum_free(VAR_18);\n\t\tcrypto_bignum_free(VAR_19);\n\t} else if (TEE_ALG_GET_MAIN_ALG(VAR_9->algo) == VAR_24) {\n\t\tsize_t VAR_17;\n\t\tstruct ecc_public_key VAR_25;\n\t\tuint8_t *VAR_26;\n\t\tunsigned long VAR_27;\n\n\t\tif (VAR_2 != 2 ||\n\t\t    VAR_12[0].attributeID != VAR_28 ||\n\t\t    VAR_12[1].attributeID != VAR_29) {\n\t\t\tVAR_4 = VAR_21;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (VAR_9->algo) {\n\t\tcase VAR_30:\n\t\t\tVAR_17 = 192;\n\t\t\tbreak;\n\t\tcase VAR_31:\n\t\t\tVAR_17 = 224;\n\t\t\tbreak;\n\t\tcase VAR_32:\n\t\t\tVAR_17 = 256;\n\t\t\tbreak;\n\t\tcase VAR_33:\n\t\t\tVAR_17 = 384;\n\t\t\tbreak;\n\t\tcase VAR_34:\n\t\t\tVAR_17 = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_4 = VAR_35;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* COMMENT_3 */\n\t\tVAR_4 = crypto_acipher_alloc_ecc_public_key(&VAR_25,\n\t\t\t\t\t\t\t  VAR_17);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\t\tVAR_25.curve = ((struct ecc_keypair *)VAR_7->attr)->curve;\n\t\tcrypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,\n\t\t\t\t     VAR_12[0].content.ref.length,\n\t\t\t\t     VAR_25.x);\n\t\tcrypto_bignum_bin2bn(VAR_12[1].content.ref.buffer,\n\t\t\t\t     VAR_12[1].content.ref.length,\n\t\t\t\t     VAR_25.y);\n\n\t\tVAR_26 = (uint8_t *)(VAR_10 + 1);\n\t\tVAR_27 = VAR_10->alloc_size;\n\t\tVAR_4 = crypto_acipher_ecc_shared_secret(VAR_7->attr, &VAR_25,\n\t\t\t\t\t\t       VAR_26,\n\t\t\t\t\t\t       &VAR_27);\n\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_27;\n\t\t\tVAR_8->info.handleFlags |= VAR_22;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_23);\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\tcrypto_acipher_free_ecc_public_key(&VAR_25);\n\t}\n#if defined(VAR_36)\n\telse if (VAR_37(cs->VAR_38) == VAR_39) {\n\t\tvoid *VAR_40, *VAR_41;\n\t\tsize_t VAR_42, VAR_43, VAR_44;\n\t\tuint32_t VAR_45 = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *VAR_46 = VAR_7->attr;\n\t\tconst uint8_t *VAR_47 = (const uint8_t *)(VAR_46 + 1);\n\n\t\tVAR_4 = get_hkdf_params(VAR_12, VAR_2, &VAR_40, &VAR_42,\n\t\t\t\t      &VAR_41, &VAR_43, &VAR_44);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_44 > VAR_46->alloc_size) {\n\t\t\tVAR_4 = VAR_21;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = tee_cryp_hkdf(VAR_45, VAR_47, VAR_46->key_size, VAR_40, VAR_42,\n\t\t\t\t    VAR_41, VAR_43, (uint8_t *)(VAR_10 + 1),\n\t\t\t\t    VAR_44);\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_44;\n\t\t\tVAR_8->info.handleFlags |= VAR_22;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_23);\n\t\t}\n\t}\n#endif\n#if defined(VAR_48)\n\telse if (VAR_37(cs->VAR_38) == VAR_49) {\n\t\tvoid *VAR_41;\n\t\tsize_t VAR_43, VAR_50;\n\t\tuint32_t VAR_45 = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *VAR_19 = VAR_7->attr;\n\t\tconst uint8_t *VAR_51 = (const uint8_t *)(VAR_19 + 1);\n\n\t\tVAR_4 = get_concat_kdf_params(VAR_12, VAR_2, &VAR_41,\n\t\t\t\t\t    &VAR_43, &VAR_50);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_50 > VAR_19->alloc_size) {\n\t\t\tVAR_4 = VAR_21;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = tee_cryp_concat_kdf(VAR_45, VAR_51, VAR_19->key_size,\n\t\t\t\t\t  VAR_41, VAR_43, (uint8_t *)(VAR_10 + 1),\n\t\t\t\t\t  VAR_50);\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_50;\n\t\t\tVAR_8->info.handleFlags |= VAR_22;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_23);\n\t\t}\n\t}\n#endif\n#if defined(VAR_52)\n\telse if (VAR_37(cs->VAR_38) == VAR_53) {\n\t\tvoid *VAR_40;\n\t\tsize_t VAR_42, VAR_54, VAR_50;\n\t\tuint32_t VAR_45 = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *VAR_19 = VAR_7->attr;\n\t\tconst uint8_t *VAR_55 = (const uint8_t *)(VAR_19 + 1);\n\n\t\tVAR_4 = get_pbkdf2_params(VAR_12, VAR_2, &VAR_40, &VAR_42,\n\t\t\t\t\t&VAR_50, &VAR_54);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_50 > VAR_19->alloc_size) {\n\t\t\tVAR_4 = VAR_21;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = tee_cryp_pbkdf2(VAR_45, VAR_55, VAR_19->key_size, VAR_40,\n\t\t\t\t      VAR_42, VAR_54,\n\t\t\t\t      (uint8_t *)(VAR_10 + 1), VAR_50);\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_50;\n\t\t\tVAR_8->info.handleFlags |= VAR_22;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_23);\n\t\t}\n\t}\n#endif\n\telse\n\t\tVAR_4 = VAR_5;\n\nout:\n\tfree(VAR_12);\n\treturn VAR_4;\n}",
  "func_graph_path_before": "OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/before/0.json",
  "func": "TEE_Result syscall_cryp_derive_key(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count, unsigned long derived_key)\n{\n\tTEE_Result res = TEE_ERROR_NOT_SUPPORTED;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *ko;\n\tstruct tee_obj *so;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_cryp_obj_secret *sk;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, param_count, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Get key set in operation */\n\tres = tee_obj_get(utc, cs->key1, &ko);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(derived_key), &so);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Find information needed about the object to initialize */\n\tsk = so->attr;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(so->info.objectType);\n\tif (!type_props) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {\n\t\tsize_t alloc_size;\n\t\tstruct bignum *pub;\n\t\tstruct bignum *ss;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\talloc_size = params[0].content.ref.length * 8;\n\t\tpub = crypto_bignum_allocate(alloc_size);\n\t\tss = crypto_bignum_allocate(alloc_size);\n\t\tif (pub && ss) {\n\t\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t\t     params[0].content.ref.length, pub);\n\t\t\tres = crypto_acipher_dh_shared_secret(ko->attr,\n\t\t\t\t\t\t\t      pub, ss);\n\t\t\tif (res == TEE_SUCCESS) {\n\t\t\t\tsk->key_size = crypto_bignum_num_bytes(ss);\n\t\t\t\tcrypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));\n\t\t\t\tso->info.handleFlags |=\n\t\t\t\t\t\tTEE_HANDLE_FLAG_INITIALIZED;\n\t\t\t\tset_attribute(so, type_props,\n\t\t\t\t\t      TEE_ATTR_SECRET_VALUE);\n\t\t\t}\n\t\t} else {\n\t\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcrypto_bignum_free(pub);\n\t\tcrypto_bignum_free(ss);\n\t} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {\n\t\tsize_t alloc_size;\n\t\tstruct ecc_public_key key_public;\n\t\tuint8_t *pt_secret;\n\t\tunsigned long pt_secret_len;\n\n\t\tif (param_count != 2 ||\n\t\t    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||\n\t\t    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cs->algo) {\n\t\tcase TEE_ALG_ECDH_P192:\n\t\t\talloc_size = 192;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P224:\n\t\t\talloc_size = 224;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P256:\n\t\t\talloc_size = 256;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P384:\n\t\t\talloc_size = 384;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P521:\n\t\t\talloc_size = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Create the public key */\n\t\tres = crypto_acipher_alloc_ecc_public_key(&key_public,\n\t\t\t\t\t\t\t  alloc_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tkey_public.curve = ((struct ecc_keypair *)ko->attr)->curve;\n\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t     params[0].content.ref.length,\n\t\t\t\t     key_public.x);\n\t\tcrypto_bignum_bin2bn(params[1].content.ref.buffer,\n\t\t\t\t     params[1].content.ref.length,\n\t\t\t\t     key_public.y);\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,\n\t\t\t\t\t\t       pt_secret,\n\t\t\t\t\t\t       &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\n\t\t/* free the public key */\n\t\tcrypto_acipher_free_ecc_public_key(&key_public);\n\t}\n#if defined(CFG_CRYPTO_HKDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {\n\t\tvoid *salt, *info;\n\t\tsize_t salt_len, info_len, okm_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ik = ko->attr;\n\t\tconst uint8_t *ikm = (const uint8_t *)(ik + 1);\n\n\t\tres = get_hkdf_params(params, param_count, &salt, &salt_len,\n\t\t\t\t      &info, &info_len, &okm_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (okm_len > ik->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,\n\t\t\t\t    info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t    okm_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = okm_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {\n\t\tvoid *info;\n\t\tsize_t info_len, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *shared_secret = (const uint8_t *)(ss + 1);\n\n\t\tres = get_concat_kdf_params(params, param_count, &info,\n\t\t\t\t\t    &info_len, &derived_key_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,\n\t\t\t\t\t  info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t\t  derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {\n\t\tvoid *salt;\n\t\tsize_t salt_len, iteration_count, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *password = (const uint8_t *)(ss + 1);\n\n\t\tres = get_pbkdf2_params(params, param_count, &salt, &salt_len,\n\t\t\t\t\t&derived_key_len, &iteration_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,\n\t\t\t\t      salt_len, iteration_count,\n\t\t\t\t      (uint8_t *)(sk + 1), derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n\telse\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\nout:\n\tfree(params);\n\treturn res;\n}",
  "abstract_func": "TEE_Result syscall_cryp_derive_key(unsigned long VAR_0,\n\t\t\tconst struct utee_attribute *VAR_1,\n\t\t\tunsigned long VAR_2, unsigned long VAR_3)\n{\n\tTEE_Result VAR_4 = VAR_5;\n\tstruct tee_ta_session *VAR_6;\n\tstruct tee_obj *VAR_7;\n\tstruct tee_obj *VAR_8;\n\tstruct tee_cryp_state *VAR_9;\n\tstruct tee_cryp_obj_secret *VAR_10;\n\tconst struct tee_cryp_obj_type_props *VAR_11;\n\tTEE_Attribute *VAR_12 = NULL;\n\tstruct user_ta_ctx *VAR_13;\n\n\tVAR_4 = tee_ta_get_current_session(&VAR_6);\n\tif (VAR_4 != VAR_14)\n\t\treturn VAR_4;\n\tVAR_13 = to_user_ta_ctx(VAR_6->ctx);\n\n\tVAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);\n\tif (VAR_4 != VAR_14)\n\t\treturn VAR_4;\n\n\tsize_t VAR_15 = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), VAR_2, &VAR_15))\n\t\treturn VAR_16;\n\n\tVAR_12 = malloc(VAR_15);\n\tif (!VAR_12)\n\t\treturn VAR_17;\n\tVAR_4 = copy_in_attrs(VAR_13, VAR_1, VAR_2, VAR_12);\n\tif (VAR_4 != VAR_14)\n\t\tgoto out;\n\n\t/* COMMENT_0 */\n\tVAR_4 = tee_obj_get(VAR_13, VAR_9->key1, &VAR_7);\n\tif (VAR_4 != VAR_14)\n\t\tgoto out;\n\n\tVAR_4 = tee_obj_get(VAR_13, tee_svc_uref_to_vaddr(VAR_3), &VAR_8);\n\tif (VAR_4 != VAR_14)\n\t\tgoto out;\n\n\t/* COMMENT_1 */\n\tVAR_10 = VAR_8->attr;\n\n\t/* COMMENT_2 */\n\tVAR_11 = tee_svc_find_type_props(VAR_8->info.objectType);\n\tif (!VAR_11) {\n\t\tVAR_4 = VAR_5;\n\t\tgoto out;\n\t}\n\n\tif (VAR_9->algo == VAR_18) {\n\t\tsize_t VAR_15;\n\t\tstruct bignum *VAR_19;\n\t\tstruct bignum *VAR_20;\n\n\t\tif (VAR_2 != 1 ||\n\t\t    VAR_12[0].attributeID != VAR_21) {\n\t\t\tVAR_4 = VAR_22;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_15 = VAR_12[0].content.ref.length * 8;\n\t\tVAR_19 = crypto_bignum_allocate(VAR_15);\n\t\tVAR_20 = crypto_bignum_allocate(VAR_15);\n\t\tif (VAR_19 && VAR_20) {\n\t\t\tcrypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,\n\t\t\t\t\t     VAR_12[0].content.ref.length, VAR_19);\n\t\t\tVAR_4 = crypto_acipher_dh_shared_secret(VAR_7->attr,\n\t\t\t\t\t\t\t      VAR_19, VAR_20);\n\t\t\tif (VAR_4 == VAR_14) {\n\t\t\t\tVAR_10->key_size = crypto_bignum_num_bytes(VAR_20);\n\t\t\t\tcrypto_bignum_bn2bin(VAR_20, (uint8_t *)(VAR_10 + 1));\n\t\t\t\tVAR_8->info.handleFlags |=\n\t\t\t\t\t\tVAR_23;\n\t\t\t\tset_attribute(VAR_8, VAR_11,\n\t\t\t\t\t      VAR_24);\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_4 = VAR_17;\n\t\t}\n\t\tcrypto_bignum_free(VAR_19);\n\t\tcrypto_bignum_free(VAR_20);\n\t} else if (TEE_ALG_GET_MAIN_ALG(VAR_9->algo) == VAR_25) {\n\t\tsize_t VAR_15;\n\t\tstruct ecc_public_key VAR_26;\n\t\tuint8_t *VAR_27;\n\t\tunsigned long VAR_28;\n\n\t\tif (VAR_2 != 2 ||\n\t\t    VAR_12[0].attributeID != VAR_29 ||\n\t\t    VAR_12[1].attributeID != VAR_30) {\n\t\t\tVAR_4 = VAR_22;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (VAR_9->algo) {\n\t\tcase VAR_31:\n\t\t\tVAR_15 = 192;\n\t\t\tbreak;\n\t\tcase VAR_32:\n\t\t\tVAR_15 = 224;\n\t\t\tbreak;\n\t\tcase VAR_33:\n\t\t\tVAR_15 = 256;\n\t\t\tbreak;\n\t\tcase VAR_34:\n\t\t\tVAR_15 = 384;\n\t\t\tbreak;\n\t\tcase VAR_35:\n\t\t\tVAR_15 = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_4 = VAR_36;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* COMMENT_3 */\n\t\tVAR_4 = crypto_acipher_alloc_ecc_public_key(&VAR_26,\n\t\t\t\t\t\t\t  VAR_15);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\t\tVAR_26.curve = ((struct ecc_keypair *)VAR_7->attr)->curve;\n\t\tcrypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,\n\t\t\t\t     VAR_12[0].content.ref.length,\n\t\t\t\t     VAR_26.x);\n\t\tcrypto_bignum_bin2bn(VAR_12[1].content.ref.buffer,\n\t\t\t\t     VAR_12[1].content.ref.length,\n\t\t\t\t     VAR_26.y);\n\n\t\tVAR_27 = (uint8_t *)(VAR_10 + 1);\n\t\tVAR_28 = VAR_10->alloc_size;\n\t\tVAR_4 = crypto_acipher_ecc_shared_secret(VAR_7->attr, &VAR_26,\n\t\t\t\t\t\t       VAR_27,\n\t\t\t\t\t\t       &VAR_28);\n\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_28;\n\t\t\tVAR_8->info.handleFlags |= VAR_23;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_24);\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\tcrypto_acipher_free_ecc_public_key(&VAR_26);\n\t}\n#if defined(VAR_37)\n\telse if (VAR_38(cs->VAR_39) == VAR_40) {\n\t\tvoid *VAR_41, *VAR_42;\n\t\tsize_t VAR_43, VAR_44, VAR_45;\n\t\tuint32_t VAR_46 = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *VAR_47 = VAR_7->attr;\n\t\tconst uint8_t *VAR_48 = (const uint8_t *)(VAR_47 + 1);\n\n\t\tVAR_4 = get_hkdf_params(VAR_12, VAR_2, &VAR_41, &VAR_43,\n\t\t\t\t      &VAR_42, &VAR_44, &VAR_45);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_45 > VAR_47->alloc_size) {\n\t\t\tVAR_4 = VAR_22;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = tee_cryp_hkdf(VAR_46, VAR_48, VAR_47->key_size, VAR_41, VAR_43,\n\t\t\t\t    VAR_42, VAR_44, (uint8_t *)(VAR_10 + 1),\n\t\t\t\t    VAR_45);\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_45;\n\t\t\tVAR_8->info.handleFlags |= VAR_23;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_24);\n\t\t}\n\t}\n#endif\n#if defined(VAR_49)\n\telse if (VAR_38(cs->VAR_39) == VAR_50) {\n\t\tvoid *VAR_42;\n\t\tsize_t VAR_44, VAR_51;\n\t\tuint32_t VAR_46 = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *VAR_20 = VAR_7->attr;\n\t\tconst uint8_t *VAR_52 = (const uint8_t *)(VAR_20 + 1);\n\n\t\tVAR_4 = get_concat_kdf_params(VAR_12, VAR_2, &VAR_42,\n\t\t\t\t\t    &VAR_44, &VAR_51);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_51 > VAR_20->alloc_size) {\n\t\t\tVAR_4 = VAR_22;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = tee_cryp_concat_kdf(VAR_46, VAR_52, VAR_20->key_size,\n\t\t\t\t\t  VAR_42, VAR_44, (uint8_t *)(VAR_10 + 1),\n\t\t\t\t\t  VAR_51);\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_51;\n\t\t\tVAR_8->info.handleFlags |= VAR_23;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_24);\n\t\t}\n\t}\n#endif\n#if defined(VAR_53)\n\telse if (VAR_38(cs->VAR_39) == VAR_54) {\n\t\tvoid *VAR_41;\n\t\tsize_t VAR_43, VAR_55, VAR_51;\n\t\tuint32_t VAR_46 = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *VAR_20 = VAR_7->attr;\n\t\tconst uint8_t *VAR_56 = (const uint8_t *)(VAR_20 + 1);\n\n\t\tVAR_4 = get_pbkdf2_params(VAR_12, VAR_2, &VAR_41, &VAR_43,\n\t\t\t\t\t&VAR_51, &VAR_55);\n\t\tif (VAR_4 != VAR_14)\n\t\t\tgoto out;\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_51 > VAR_20->alloc_size) {\n\t\t\tVAR_4 = VAR_22;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVAR_4 = tee_cryp_pbkdf2(VAR_46, VAR_56, VAR_20->key_size, VAR_41,\n\t\t\t\t      VAR_43, VAR_55,\n\t\t\t\t      (uint8_t *)(VAR_10 + 1), VAR_51);\n\t\tif (VAR_4 == VAR_14) {\n\t\t\tVAR_10->key_size = VAR_51;\n\t\t\tVAR_8->info.handleFlags |= VAR_23;\n\t\t\tset_attribute(VAR_8, VAR_11, VAR_24);\n\t\t}\n\t}\n#endif\n\telse\n\t\tVAR_4 = VAR_5;\n\nout:\n\tfree(VAR_12);\n\treturn VAR_4;\n}",
  "func_graph_path": "OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,12 @@\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n-\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n+\tsize_t alloc_size = 0;\n+\n+\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n+\t\treturn TEE_ERROR_OVERFLOW;\n+\n+\tparams = malloc(alloc_size);\n \tif (!params)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(utc, usr_params, param_count, params);",
  "diff_line_info": {
    "deleted_lines": [
      "\tparams = malloc(sizeof(TEE_Attribute) * param_count);"
    ],
    "added_lines": [
      "\tsize_t alloc_size = 0;",
      "",
      "\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))",
      "\t\treturn TEE_ERROR_OVERFLOW;",
      "",
      "\tparams = malloc(alloc_size);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/2745",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OP-TEE/optee_os/pull/2745: 403 Client Error: Forbidden for url: https://api.github.com/repos/OP-TEE/optee_os/pulls/2745",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}