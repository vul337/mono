{
  "cve_id": "CVE-2021-37621",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Defensive programming in Image::printIFDStructure",
  "commit_hash": "d9fd4c4272df172ae89c0a9c41341adc75ebba86",
  "git_url": "https://github.com/Exiv2/exiv2/commit/d9fd4c4272df172ae89c0a9c41341adc75ebba86",
  "file_path": "src/image.cpp",
  "func_name": "Image::printIFDStructure",
  "func_before": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            const int seekSuccess = !io.seek(start,BasicIo::beg);\n            const long bytesRead = io.read(dir.pData_, 2);\n            if (!seekSuccess || bytesRead == 0) {\n                throw Error(kerCorruptedMetadata);\n            }\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n            enforce(dirLength > 0, kerCorruptedMetadata);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                long long allocate = (long long) size*count + pad+20;\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                DataBuf  buf((long)allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const size_t restore = io.tell();\n                        io.seek(offset, BasicIo::beg);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        const long read_bytes = io.read(&bytes[0], count);\n                        io.seek(restore, BasicIo::beg);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
  "abstract_func_before": "void Image::printIFDStructure(BasicIo& VAR_0, std::ostream& VAR_1, Exiv2::PrintStructureOption VAR_2,uint32_t VAR_3,bool VAR_4,char VAR_5,int VAR_6)\n    {\n        VAR_6++;\n        if ( VAR_6 == 1 ) VAR_7.clear();\n        bool VAR_8  = true  ;\n\n        /* COMMENT_0 */\n        const size_t VAR_9 = 32;\n        DataBuf  dir(dirSize);\n        bool VAR_10 = VAR_2 == VAR_11 || VAR_2 == VAR_12;\n\n        do {\n            /* COMMENT_1 */\n            const int VAR_13 = !VAR_0.seek(VAR_3,BasicIo::beg);\n            const long VAR_14 = VAR_0.read(VAR_15.pData_, 2);\n            if (!VAR_13 || VAR_14 == 0) {\n                throw Error(VAR_16);\n            }\n            uint16_t   VAR_17 = byteSwap2(VAR_15,0,VAR_4);\n            /* COMMENT_2 */\n            enforce(VAR_17 > 0, VAR_16);\n\n            bool VAR_18 = VAR_17 > 500;\n            if ( VAR_18 ) throw Error(VAR_19);\n\n            if ( VAR_8 && VAR_10 ) {\n                VAR_1 << Internal::indent(VAR_6) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",VAR_5,VAR_5) << VAR_0.path() << std::endl;\n                if ( VAR_18 ) VAR_1 << Internal::indent(VAR_6) << \"dirLength = \" << VAR_17 << std::endl;\n            }\n\n            /* COMMENT_3 */\n            for ( int VAR_20 = 0 ; VAR_20 < VAR_17 ; VAR_20 ++ ) {\n                if ( VAR_7.find(VAR_0.tell()) != VAR_7.end()  ) { /* COMMENT_4 */\n                    throw Error(VAR_16);\n                }\n                VAR_7.insert(VAR_0.tell());\n                \n                if ( VAR_8 && VAR_10 ) {\n                    VAR_1 << Internal::indent(VAR_6)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                VAR_8 = false;\n\n                VAR_0.read(VAR_15.pData_, 12);\n                uint16_t VAR_21    = byteSwap2(VAR_15,0,VAR_4);\n                uint16_t VAR_22   = byteSwap2(VAR_15,2,VAR_4);\n                uint32_t VAR_23  = byteSwap4(VAR_15,4,VAR_4);\n                uint32_t VAR_24 = byteSwap4(VAR_15,8,VAR_4);\n\n                /* COMMENT_5 */\n                if ( !typeValid(VAR_22) ) {\n                    std::cerr << \"invalid type in tiff structure\" << VAR_22 << std::endl;\n                    VAR_3 = 0; /* COMMENT_6 */\n                    throw Error(VAR_25);\n                }\n\n                std::string VAR_26  = \"\" ; /* COMMENT_7 */\n\n                /* COMMENT_8 */\n                uint32_t VAR_27  = isPrintXMP(VAR_21,VAR_2) ? VAR_23 /* COMMENT_9 */\n                                : isPrintICC(VAR_21,VAR_2) ? VAR_23 /* COMMENT_10 */\n                                : isStringType(VAR_22)     ? (VAR_23 > 32 ? 32 : VAR_23) /* COMMENT_11 */\n                                : VAR_23 > 5              ? 5\n                                : VAR_23\n                                ;\n                uint32_t VAR_28    = isStringType(VAR_22) ? 1 : 0;\n                uint32_t VAR_29   = isStringType(VAR_22) ? 1\n                                : is2ByteType(VAR_22)  ? 2\n                                : is4ByteType(VAR_22)  ? 4\n                                : is8ByteType(VAR_22)  ? 8\n                                : 1\n                                ;\n\n                /* COMMENT_12 */\n\n                /* COMMENT_13 */\n                long long VAR_30 = (long long) VAR_29*VAR_23 + VAR_28+20;\n                if ( VAR_30 > (long long) VAR_0.size() ) {\n                    throw Error(VAR_31);\n                }\n                DataBuf  VAR_32((long)VAR_30);  /* COMMENT_14 */\n                std::memset(VAR_32.pData_, 0, VAR_32.size_);\n                std::memcpy(VAR_32.pData_,VAR_15.pData_+8,4);  /* COMMENT_15 */\n                const bool VAR_33 = VAR_23*VAR_29 > 4;\n\n                if ( VAR_33 ) {         /* COMMENT_16 */\n                    size_t   VAR_34 = VAR_0.tell();  /* COMMENT_17 */\n                    VAR_0.seek(VAR_24,BasicIo::beg);  /* COMMENT_18 */\n                    VAR_0.read(VAR_32.pData_,VAR_23*VAR_29);/* COMMENT_19 */\n                    VAR_0.seek(VAR_34,BasicIo::beg); /* COMMENT_20 */\n                }\n\n                if ( VAR_10 ) {\n                    const uint32_t VAR_35 = VAR_3 + 2 + VAR_20*12 ;\n                    const std::string VAR_36 = VAR_33?\n                        Internal::stringFormat(\"%10u\", VAR_24):\n                        \"\";\n\n                    VAR_1 << Internal::indent(VAR_6)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,VAR_35,VAR_21,tagName(VAR_21).c_str(),typeName(VAR_22),VAR_23,VAR_36.c_str());\n                    if ( isShortType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            VAR_1 << VAR_26 << byteSwap2(VAR_32,VAR_37*VAR_29,VAR_4);\n                            VAR_26 = \" \";\n                        }\n                    } else if ( isLongType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            VAR_1 << VAR_26 << byteSwap4(VAR_32,VAR_37*VAR_29,VAR_4);\n                            VAR_26 = \" \";\n                        }\n\n                    } else if ( isRationalType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            uint32_t VAR_38 = byteSwap4(VAR_32,VAR_37*VAR_29+0,VAR_4);\n                            uint32_t VAR_39 = byteSwap4(VAR_32,VAR_37*VAR_29+4,VAR_4);\n                            VAR_1 << VAR_26 << VAR_38 << \"/\" << VAR_39;\n                            VAR_26 = \" \";\n                        }\n                    } else if ( isStringType(VAR_22) ) {\n                        VAR_1 << VAR_26 << Internal::binaryToString(makeSlice(VAR_32, 0, VAR_27));\n                    }\n\n                    VAR_26 = VAR_27 == VAR_23 ? \"\" : \" ...\";\n                    VAR_1 << VAR_26 << std::endl;\n\n                    if ( VAR_2 == VAR_12 && (VAR_21 == 0x8769 /* COMMENT_21 */ || VAR_21 == 0x014a/* COMMENT_22 */  || VAR_22 == VAR_40) ) {\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_23 ; VAR_37++ ) {\n                            size_t   VAR_34 = VAR_0.tell();\n                            uint32_t VAR_24 = byteSwap4(VAR_32,VAR_37*VAR_29,VAR_4);\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_24,VAR_4,VAR_5,VAR_6);\n                            VAR_0.seek(VAR_34,BasicIo::beg);\n                        }\n                    } else if ( VAR_2 == VAR_12 && VAR_21 == 0x83bb /* COMMENT_23 */ ) {\n\n                        if (VAR_41<size_t>(Safe::add(VAR_23, VAR_24)) > VAR_0.size()) {\n                            throw Error(VAR_16);\n                        }\n\n                        const size_t VAR_34 = VAR_0.tell();\n                        VAR_0.seek(VAR_24, BasicIo::beg);  /* COMMENT_18 */\n                        std::vector<byte> bytes(count) ;  /* COMMENT_24 */\n                        /* COMMENT_25 */\n                        const long VAR_42 = VAR_0.read(&VAR_43[0], count);\n                        VAR_0.seek(VAR_34, BasicIo::beg);\n                        /* COMMENT_25 */\n                        IptcData::printStructure(VAR_1, makeSliceUntil(&VAR_43[0], VAR_42), VAR_6);\n\n                    }  else if ( VAR_2 == VAR_12 && VAR_21 == 0x927c /* COMMENT_26 */ && count > 10) {\n                        size_t   VAR_34 = VAR_0.tell();  /* COMMENT_17 */\n\n                        uint32_t VAR_44= 10           ;\n                        byte     VAR_43[20]          ;\n                        const char* VAR_45 = (const char*) &VAR_43[0] ;\n                        VAR_0.seek(VAR_24,BasicIo::beg);  /* COMMENT_18 */\n                        VAR_0.read(VAR_43,VAR_44    )     ;  /* COMMENT_19 */\n                        VAR_43[VAR_44]=0               ;\n                        if ( ::strcmp(\"Nikon\",VAR_45) == 0 ) {\n                            /* COMMENT_27 */\n                            byte* VAR_43=new byte[count-VAR_44] ;  /* COMMENT_24 */\n                            VAR_0.read(VAR_43,count-VAR_44)        ;  /* COMMENT_19 */\n                            MemIo VAR_46(VAR_43,count-VAR_44)    ;  /* COMMENT_28 */\n                            printTiffStructure(VAR_46,VAR_1,VAR_2,VAR_6);\n                            delete[] VAR_43                   ;  /* COMMENT_29 */\n                        } else {\n                            /* COMMENT_30 */\n                            VAR_0.seek(0,BasicIo::beg);  /* COMMENT_18 */\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_24,VAR_4,VAR_5,VAR_6);\n                        }\n\n                        VAR_0.seek(VAR_34,BasicIo::beg); /* COMMENT_20 */\n                    }\n                }\n\n                if ( isPrintXMP(VAR_21,VAR_2) ) {\n                    VAR_32.pData_[count]=0;\n                    VAR_1 << (char*) VAR_32.pData_;\n                }\n                if ( isPrintICC(VAR_21,VAR_2) ) {\n                    VAR_1.write((const char*)VAR_32.pData_,count);\n                }\n            }\n            if ( VAR_3 ) {\n                VAR_0.read(VAR_15.pData_, 4);\n                VAR_3 = VAR_18 ? 0 : byteSwap4(VAR_15,0,VAR_4);\n            }\n        } while (VAR_3) ;\n\n        if ( VAR_10 ) {\n            VAR_1 << Internal::indent(VAR_6) << \"END \" << VAR_0.path() << std::endl;\n        }\n        VAR_1.flush();\n        VAR_6--;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/d9fd4c4272df172ae89c0a9c41341adc75ebba86/image.cpp/vul/before/0.json",
  "func": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            seekOrThrow(io, start, BasicIo::beg, kerCorruptedMetadata);\n            readOrThrow(io, dir.pData_, 2, kerCorruptedMetadata);\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n            enforce(dirLength > 0, kerCorruptedMetadata);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                readOrThrow(io, dir.pData_, 12, kerCorruptedMetadata);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                const uint64_t allocate64 = static_cast<uint64_t>(size) * count + pad + 20;\n                if ( allocate64 > io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                // Overflow check\n                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()), kerCorruptedMetadata);\n                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<long>::max()), kerCorruptedMetadata);\n                const long allocate = static_cast<long>(allocate64);\n                DataBuf  buf(allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n\n                // We have already checked that this multiplication cannot overflow.\n                const uint32_t count_x_size = count*size;\n                const bool bOffsetIsPointer = count_x_size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    const long restore = io.tell(); // save\n                    seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata); // position\n                    readOrThrow(io, buf.pData_, static_cast<long>(count_x_size), kerCorruptedMetadata); // read\n                    seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            const long restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const long restore = io.tell();\n                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        readOrThrow(io, &bytes[0], count, kerCorruptedMetadata);\n                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], count), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        const long restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n                        readOrThrow(io, bytes, jump, kerCorruptedMetadata)     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            const long byteslen = count-jump;\n                            DataBuf bytes(byteslen);  // allocate a buffer\n                            readOrThrow(io, bytes.pData_, byteslen, kerCorruptedMetadata);  // read\n                            MemIo memIo(bytes.pData_, byteslen)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                        } else {\n                            // tag is an IFD\n                            seekOrThrow(io, 0, BasicIo::beg, kerCorruptedMetadata);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                readOrThrow(io, dir.pData_, 4, kerCorruptedMetadata);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
  "abstract_func": "void Image::printIFDStructure(BasicIo& VAR_0, std::ostream& VAR_1, Exiv2::PrintStructureOption VAR_2,uint32_t VAR_3,bool VAR_4,char VAR_5,int VAR_6)\n    {\n        VAR_6++;\n        if ( VAR_6 == 1 ) VAR_7.clear();\n        bool VAR_8  = true  ;\n\n        /* COMMENT_0 */\n        const size_t VAR_9 = 32;\n        DataBuf  dir(dirSize);\n        bool VAR_10 = VAR_2 == VAR_11 || VAR_2 == VAR_12;\n\n        do {\n            /* COMMENT_1 */\n            seekOrThrow(VAR_0, VAR_3, BasicIo::beg, VAR_13);\n            readOrThrow(VAR_0, VAR_14.pData_, 2, VAR_13);\n            uint16_t   VAR_15 = byteSwap2(VAR_14,0,VAR_4);\n            /* COMMENT_2 */\n            enforce(VAR_15 > 0, VAR_13);\n\n            bool VAR_16 = VAR_15 > 500;\n            if ( VAR_16 ) throw Error(VAR_17);\n\n            if ( VAR_8 && VAR_10 ) {\n                VAR_1 << Internal::indent(VAR_6) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",VAR_5,VAR_5) << VAR_0.path() << std::endl;\n                if ( VAR_16 ) VAR_1 << Internal::indent(VAR_6) << \"dirLength = \" << VAR_15 << std::endl;\n            }\n\n            /* COMMENT_3 */\n            for ( int VAR_18 = 0 ; VAR_18 < VAR_15 ; VAR_18 ++ ) {\n                if ( VAR_7.find(VAR_0.tell()) != VAR_7.end()  ) { /* COMMENT_4 */\n                    throw Error(VAR_13);\n                }\n                VAR_7.insert(VAR_0.tell());\n                \n                if ( VAR_8 && VAR_10 ) {\n                    VAR_1 << Internal::indent(VAR_6)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                VAR_8 = false;\n\n                readOrThrow(VAR_0, VAR_14.pData_, 12, VAR_13);\n                uint16_t VAR_19    = byteSwap2(VAR_14,0,VAR_4);\n                uint16_t VAR_20   = byteSwap2(VAR_14,2,VAR_4);\n                uint32_t VAR_21  = byteSwap4(VAR_14,4,VAR_4);\n                uint32_t VAR_22 = byteSwap4(VAR_14,8,VAR_4);\n\n                /* COMMENT_5 */\n                if ( !typeValid(VAR_20) ) {\n                    std::cerr << \"invalid type in tiff structure\" << VAR_20 << std::endl;\n                    VAR_3 = 0; /* COMMENT_6 */\n                    throw Error(VAR_23);\n                }\n\n                std::string VAR_24  = \"\" ; /* COMMENT_7 */\n\n                /* COMMENT_8 */\n                uint32_t VAR_25  = isPrintXMP(VAR_19,VAR_2) ? VAR_21 /* COMMENT_9 */\n                                : isPrintICC(VAR_19,VAR_2) ? VAR_21 /* COMMENT_10 */\n                                : isStringType(VAR_20)     ? (VAR_21 > 32 ? 32 : VAR_21) /* COMMENT_11 */\n                                : VAR_21 > 5              ? 5\n                                : VAR_21\n                                ;\n                uint32_t VAR_26    = isStringType(VAR_20) ? 1 : 0;\n                uint32_t VAR_27   = isStringType(VAR_20) ? 1\n                                : is2ByteType(VAR_20)  ? 2\n                                : is4ByteType(VAR_20)  ? 4\n                                : is8ByteType(VAR_20)  ? 8\n                                : 1\n                                ;\n\n                /* COMMENT_12 */\n\n                /* COMMENT_13 */\n                const uint64_t VAR_28 = VAR_29<uint64_t>(VAR_27) * VAR_21 + VAR_26 + 20;\n                if ( VAR_28 > VAR_0.size() ) {\n                    throw Error(VAR_30);\n                }\n                /* COMMENT_14 */\n                enforce(VAR_28 <= VAR_29<uint64_t>(std::numeric_limits<uint32_t>::max()), VAR_13);\n                enforce(VAR_28 <= VAR_29<uint64_t>(std::numeric_limits<long>::max()), VAR_13);\n                const long VAR_31 = VAR_29<long>(VAR_28);\n                DataBuf  buf(allocate);  /* COMMENT_15 */\n                std::memset(VAR_32.pData_, 0, VAR_32.size_);\n                std::memcpy(VAR_32.pData_,VAR_14.pData_+8,4);  /* COMMENT_16 */\n\n                /* COMMENT_17 */\n                const uint32_t VAR_33 = VAR_21*VAR_27;\n                const bool VAR_34 = VAR_33 > 4;\n\n                if ( VAR_34 ) {         /* COMMENT_18 */\n                    const long VAR_35 = VAR_0.tell(); /* COMMENT_19 */\n                    seekOrThrow(VAR_0, VAR_22, BasicIo::beg, VAR_13); /* COMMENT_20 */\n                    readOrThrow(VAR_0, VAR_32.pData_, VAR_29<long>(VAR_33), VAR_13); /* COMMENT_21 */\n                    seekOrThrow(VAR_0, VAR_35, BasicIo::beg, VAR_13); /* COMMENT_22 */\n                }\n\n                if ( VAR_10 ) {\n                    const uint32_t VAR_36 = VAR_3 + 2 + VAR_18*12 ;\n                    const std::string VAR_37 = VAR_34?\n                        Internal::stringFormat(\"%10u\", VAR_22):\n                        \"\";\n\n                    VAR_1 << Internal::indent(VAR_6)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,VAR_36,VAR_19,tagName(VAR_19).c_str(),typeName(VAR_20),VAR_21,VAR_37.c_str());\n                    if ( isShortType(VAR_20) ){\n                        for ( size_t VAR_38 = 0 ; VAR_38 < VAR_25 ; VAR_38++ ) {\n                            VAR_1 << VAR_24 << byteSwap2(VAR_32,VAR_38*VAR_27,VAR_4);\n                            VAR_24 = \" \";\n                        }\n                    } else if ( isLongType(VAR_20) ){\n                        for ( size_t VAR_38 = 0 ; VAR_38 < VAR_25 ; VAR_38++ ) {\n                            VAR_1 << VAR_24 << byteSwap4(VAR_32,VAR_38*VAR_27,VAR_4);\n                            VAR_24 = \" \";\n                        }\n\n                    } else if ( isRationalType(VAR_20) ){\n                        for ( size_t VAR_38 = 0 ; VAR_38 < VAR_25 ; VAR_38++ ) {\n                            uint32_t VAR_39 = byteSwap4(VAR_32,VAR_38*VAR_27+0,VAR_4);\n                            uint32_t VAR_40 = byteSwap4(VAR_32,VAR_38*VAR_27+4,VAR_4);\n                            VAR_1 << VAR_24 << VAR_39 << \"/\" << VAR_40;\n                            VAR_24 = \" \";\n                        }\n                    } else if ( isStringType(VAR_20) ) {\n                        VAR_1 << VAR_24 << Internal::binaryToString(makeSlice(VAR_32, 0, VAR_25));\n                    }\n\n                    VAR_24 = VAR_25 == VAR_21 ? \"\" : \" ...\";\n                    VAR_1 << VAR_24 << std::endl;\n\n                    if ( VAR_2 == VAR_12 && (VAR_19 == 0x8769 /* COMMENT_23 */ || VAR_19 == 0x014a/* COMMENT_24 */  || VAR_20 == VAR_41) ) {\n                        for ( size_t VAR_38 = 0 ; VAR_38 < VAR_21 ; VAR_38++ ) {\n                            const long VAR_35 = VAR_0.tell();\n                            uint32_t VAR_22 = byteSwap4(VAR_32,VAR_38*VAR_27,VAR_4);\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_22,VAR_4,VAR_5,VAR_6);\n                            seekOrThrow(VAR_0, VAR_35, BasicIo::beg, VAR_13);\n                        }\n                    } else if ( VAR_2 == VAR_12 && VAR_19 == 0x83bb /* COMMENT_25 */ ) {\n\n                        if (VAR_29<size_t>(Safe::add(VAR_21, VAR_22)) > VAR_0.size()) {\n                            throw Error(VAR_13);\n                        }\n\n                        const long VAR_35 = VAR_0.tell();\n                        seekOrThrow(VAR_0, VAR_22, BasicIo::beg, VAR_13);  /* COMMENT_20 */\n                        std::vector<byte> bytes(count) ;  /* COMMENT_26 */\n                        /* COMMENT_27 */\n                        readOrThrow(VAR_0, &VAR_42[0], count, VAR_13);\n                        seekOrThrow(VAR_0, VAR_35, BasicIo::beg, VAR_13);\n                        /* COMMENT_27 */\n                        IptcData::printStructure(VAR_1, makeSliceUntil(&VAR_42[0], count), VAR_6);\n\n                    }  else if ( VAR_2 == VAR_12 && VAR_19 == 0x927c /* COMMENT_28 */ && count > 10) {\n                        const long VAR_35 = VAR_0.tell();  /* COMMENT_19 */\n\n                        uint32_t VAR_43= 10           ;\n                        byte     VAR_42[20]          ;\n                        const char* VAR_44 = (const char*) &VAR_42[0] ;\n                        seekOrThrow(VAR_0, VAR_22, BasicIo::beg, VAR_13);  /* COMMENT_20 */\n                        readOrThrow(VAR_0, VAR_42, VAR_43, VAR_13)     ;  /* COMMENT_21 */\n                        VAR_42[VAR_43]=0               ;\n                        if ( ::strcmp(\"Nikon\",VAR_44) == 0 ) {\n                            /* COMMENT_29 */\n                            const long VAR_45 = count-VAR_43;\n                            DataBuf bytes(byteslen);  /* COMMENT_15 */\n                            readOrThrow(VAR_0, VAR_42.pData_, byteslen, VAR_13);  /* COMMENT_21 */\n                            MemIo VAR_46(VAR_42.pData_, byteslen)    ;  /* COMMENT_30 */\n                            printTiffStructure(VAR_46,VAR_1,VAR_2,VAR_6);\n                        } else {\n                            /* COMMENT_31 */\n                            seekOrThrow(VAR_0, 0, BasicIo::beg, VAR_13);  /* COMMENT_20 */\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_22,VAR_4,VAR_5,VAR_6);\n                        }\n\n                        seekOrThrow(VAR_0, VAR_35, BasicIo::beg, VAR_13); /* COMMENT_22 */\n                    }\n                }\n\n                if ( isPrintXMP(VAR_19,VAR_2) ) {\n                    VAR_32.pData_[count]=0;\n                    VAR_1 << (char*) VAR_32.pData_;\n                }\n                if ( isPrintICC(VAR_19,VAR_2) ) {\n                    VAR_1.write((const char*)VAR_32.pData_,count);\n                }\n            }\n            if ( VAR_3 ) {\n                readOrThrow(VAR_0, VAR_14.pData_, 4, VAR_13);\n                VAR_3 = VAR_16 ? 0 : byteSwap4(VAR_14,0,VAR_4);\n            }\n        } while (VAR_3) ;\n\n        if ( VAR_10 ) {\n            VAR_1 << Internal::indent(VAR_6) << \"END \" << VAR_0.path() << std::endl;\n        }\n        VAR_1.flush();\n        VAR_6--;\n    }",
  "func_graph_path": "Exiv2/exiv2/d9fd4c4272df172ae89c0a9c41341adc75ebba86/image.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,11 +11,8 @@\n \n         do {\n             // Read top of directory\n-            const int seekSuccess = !io.seek(start,BasicIo::beg);\n-            const long bytesRead = io.read(dir.pData_, 2);\n-            if (!seekSuccess || bytesRead == 0) {\n-                throw Error(kerCorruptedMetadata);\n-            }\n+            seekOrThrow(io, start, BasicIo::beg, kerCorruptedMetadata);\n+            readOrThrow(io, dir.pData_, 2, kerCorruptedMetadata);\n             uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n             // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n             enforce(dirLength > 0, kerCorruptedMetadata);\n@@ -42,7 +39,7 @@\n                 }\n                 bFirst = false;\n \n-                io.read(dir.pData_, 12);\n+                readOrThrow(io, dir.pData_, 12, kerCorruptedMetadata);\n                 uint16_t tag    = byteSwap2(dir,0,bSwap);\n                 uint16_t type   = byteSwap2(dir,2,bSwap);\n                 uint32_t count  = byteSwap4(dir,4,bSwap);\n@@ -75,20 +72,27 @@\n                 // if ( offset > io.size() ) offset = 0; // Denial of service?\n \n                 // #55 and #56 memory allocation crash test/data/POC8\n-                long long allocate = (long long) size*count + pad+20;\n-                if ( allocate > (long long) io.size() ) {\n+                const uint64_t allocate64 = static_cast<uint64_t>(size) * count + pad + 20;\n+                if ( allocate64 > io.size() ) {\n                     throw Error(kerInvalidMalloc);\n                 }\n-                DataBuf  buf((long)allocate);  // allocate a buffer\n+                // Overflow check\n+                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()), kerCorruptedMetadata);\n+                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<long>::max()), kerCorruptedMetadata);\n+                const long allocate = static_cast<long>(allocate64);\n+                DataBuf  buf(allocate);  // allocate a buffer\n                 std::memset(buf.pData_, 0, buf.size_);\n                 std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n-                const bool bOffsetIsPointer = count*size > 4;\n+\n+                // We have already checked that this multiplication cannot overflow.\n+                const uint32_t count_x_size = count*size;\n+                const bool bOffsetIsPointer = count_x_size > 4;\n \n                 if ( bOffsetIsPointer ) {         // read into buffer\n-                    size_t   restore = io.tell();  // save\n-                    io.seek(offset,BasicIo::beg);  // position\n-                    io.read(buf.pData_,count*size);// read\n-                    io.seek(restore,BasicIo::beg); // restore\n+                    const long restore = io.tell(); // save\n+                    seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata); // position\n+                    readOrThrow(io, buf.pData_, static_cast<long>(count_x_size), kerCorruptedMetadata); // read\n+                    seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                 }\n \n                 if ( bPrint ) {\n@@ -127,10 +131,10 @@\n \n                     if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                         for ( size_t k = 0 ; k < count ; k++ ) {\n-                            size_t   restore = io.tell();\n+                            const long restore = io.tell();\n                             uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                             printIFDStructure(io,out,option,offset,bSwap,c,depth);\n-                            io.seek(restore,BasicIo::beg);\n+                            seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                         }\n                     } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n \n@@ -138,38 +142,38 @@\n                             throw Error(kerCorruptedMetadata);\n                         }\n \n-                        const size_t restore = io.tell();\n-                        io.seek(offset, BasicIo::beg);  // position\n+                        const long restore = io.tell();\n+                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n                         std::vector<byte> bytes(count) ;  // allocate memory\n                         // TODO: once we have C++11 use bytes.data()\n-                        const long read_bytes = io.read(&bytes[0], count);\n-                        io.seek(restore, BasicIo::beg);\n+                        readOrThrow(io, &bytes[0], count, kerCorruptedMetadata);\n+                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                         // TODO: once we have C++11 use bytes.data()\n-                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n+                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], count), depth);\n \n                     }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n-                        size_t   restore = io.tell();  // save\n+                        const long restore = io.tell();  // save\n \n                         uint32_t jump= 10           ;\n                         byte     bytes[20]          ;\n                         const char* chars = (const char*) &bytes[0] ;\n-                        io.seek(offset,BasicIo::beg);  // position\n-                        io.read(bytes,jump    )     ;  // read\n+                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n+                        readOrThrow(io, bytes, jump, kerCorruptedMetadata)     ;  // read\n                         bytes[jump]=0               ;\n                         if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                             // tag is an embedded tiff\n-                            byte* bytes=new byte[count-jump] ;  // allocate memory\n-                            io.read(bytes,count-jump)        ;  // read\n-                            MemIo memIo(bytes,count-jump)    ;  // create a file\n+                            const long byteslen = count-jump;\n+                            DataBuf bytes(byteslen);  // allocate a buffer\n+                            readOrThrow(io, bytes.pData_, byteslen, kerCorruptedMetadata);  // read\n+                            MemIo memIo(bytes.pData_, byteslen)    ;  // create a file\n                             printTiffStructure(memIo,out,option,depth);\n-                            delete[] bytes                   ;  // free\n                         } else {\n                             // tag is an IFD\n-                            io.seek(0,BasicIo::beg);  // position\n+                            seekOrThrow(io, 0, BasicIo::beg, kerCorruptedMetadata);  // position\n                             printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                         }\n \n-                        io.seek(restore,BasicIo::beg); // restore\n+                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                     }\n                 }\n \n@@ -182,7 +186,7 @@\n                 }\n             }\n             if ( start ) {\n-                io.read(dir.pData_, 4);\n+                readOrThrow(io, dir.pData_, 4, kerCorruptedMetadata);\n                 start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n             }\n         } while (start) ;",
  "diff_line_info": {
    "deleted_lines": [
      "            const int seekSuccess = !io.seek(start,BasicIo::beg);",
      "            const long bytesRead = io.read(dir.pData_, 2);",
      "            if (!seekSuccess || bytesRead == 0) {",
      "                throw Error(kerCorruptedMetadata);",
      "            }",
      "                io.read(dir.pData_, 12);",
      "                long long allocate = (long long) size*count + pad+20;",
      "                if ( allocate > (long long) io.size() ) {",
      "                DataBuf  buf((long)allocate);  // allocate a buffer",
      "                const bool bOffsetIsPointer = count*size > 4;",
      "                    size_t   restore = io.tell();  // save",
      "                    io.seek(offset,BasicIo::beg);  // position",
      "                    io.read(buf.pData_,count*size);// read",
      "                    io.seek(restore,BasicIo::beg); // restore",
      "                            size_t   restore = io.tell();",
      "                            io.seek(restore,BasicIo::beg);",
      "                        const size_t restore = io.tell();",
      "                        io.seek(offset, BasicIo::beg);  // position",
      "                        const long read_bytes = io.read(&bytes[0], count);",
      "                        io.seek(restore, BasicIo::beg);",
      "                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);",
      "                        size_t   restore = io.tell();  // save",
      "                        io.seek(offset,BasicIo::beg);  // position",
      "                        io.read(bytes,jump    )     ;  // read",
      "                            byte* bytes=new byte[count-jump] ;  // allocate memory",
      "                            io.read(bytes,count-jump)        ;  // read",
      "                            MemIo memIo(bytes,count-jump)    ;  // create a file",
      "                            delete[] bytes                   ;  // free",
      "                            io.seek(0,BasicIo::beg);  // position",
      "                        io.seek(restore,BasicIo::beg); // restore",
      "                io.read(dir.pData_, 4);"
    ],
    "added_lines": [
      "            seekOrThrow(io, start, BasicIo::beg, kerCorruptedMetadata);",
      "            readOrThrow(io, dir.pData_, 2, kerCorruptedMetadata);",
      "                readOrThrow(io, dir.pData_, 12, kerCorruptedMetadata);",
      "                const uint64_t allocate64 = static_cast<uint64_t>(size) * count + pad + 20;",
      "                if ( allocate64 > io.size() ) {",
      "                // Overflow check",
      "                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()), kerCorruptedMetadata);",
      "                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<long>::max()), kerCorruptedMetadata);",
      "                const long allocate = static_cast<long>(allocate64);",
      "                DataBuf  buf(allocate);  // allocate a buffer",
      "",
      "                // We have already checked that this multiplication cannot overflow.",
      "                const uint32_t count_x_size = count*size;",
      "                const bool bOffsetIsPointer = count_x_size > 4;",
      "                    const long restore = io.tell(); // save",
      "                    seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata); // position",
      "                    readOrThrow(io, buf.pData_, static_cast<long>(count_x_size), kerCorruptedMetadata); // read",
      "                    seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore",
      "                            const long restore = io.tell();",
      "                            seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);",
      "                        const long restore = io.tell();",
      "                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position",
      "                        readOrThrow(io, &bytes[0], count, kerCorruptedMetadata);",
      "                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);",
      "                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], count), depth);",
      "                        const long restore = io.tell();  // save",
      "                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position",
      "                        readOrThrow(io, bytes, jump, kerCorruptedMetadata)     ;  // read",
      "                            const long byteslen = count-jump;",
      "                            DataBuf bytes(byteslen);  // allocate a buffer",
      "                            readOrThrow(io, bytes.pData_, byteslen, kerCorruptedMetadata);  // read",
      "                            MemIo memIo(bytes.pData_, byteslen)    ;  // create a file",
      "                            seekOrThrow(io, 0, BasicIo::beg, kerCorruptedMetadata);  // position",
      "                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore",
      "                readOrThrow(io, dir.pData_, 4, kerCorruptedMetadata);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sridharb1/exiv2/pull/4: 403 Client Error: Forbidden for url: https://api.github.com/repos/sridharb1/exiv2/pulls/4",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}