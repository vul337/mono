{
  "cve_id": "CVE-2017-13695",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "acpica",
  "commit_msg": "acpi: acpica: fix acpi operand cache leak in nseval.c\n\nI found an ACPI cache leak in ACPI early termination and boot continuing case.\n\nWhen early termination occurs due to malicious ACPI table, Linux kernel\nterminates ACPI function and continues to boot process. While kernel terminates\nACPI function, kmem_cache_destroy() reports Acpi-Operand cache leak.\n\nBoot log of ACPI operand cache leak is as follows:\n>[    0.464168] ACPI: Added _OSI(Module Device)\n>[    0.467022] ACPI: Added _OSI(Processor Device)\n>[    0.469376] ACPI: Added _OSI(3.0 _SCP Extensions)\n>[    0.471647] ACPI: Added _OSI(Processor Aggregator Device)\n>[    0.477997] ACPI Error: Null stack entry at ffff880215c0aad8 (20170303/exresop-174)\n>[    0.482706] ACPI Exception: AE_AML_INTERNAL, While resolving operands for [OpcodeName unavailable] (20170303/dswexec-461)\n>[    0.487503] ACPI Error: Method parse/execution failed [\\DBG] (Node ffff88021710ab40), AE_AML_INTERNAL (20170303/psparse-543)\n>[    0.492136] ACPI Error: Method parse/execution failed [\\_SB._INI] (Node ffff88021710a618), AE_AML_INTERNAL (20170303/psparse-543)\n>[    0.497683] ACPI: Interpreter enabled\n>[    0.499385] ACPI: (supports S0)\n>[    0.501151] ACPI: Using IOAPIC for interrupt routing\n>[    0.503342] ACPI Error: Null stack entry at ffff880215c0aad8 (20170303/exresop-174)\n>[    0.506522] ACPI Exception: AE_AML_INTERNAL, While resolving operands for [OpcodeName unavailable] (20170303/dswexec-461)\n>[    0.510463] ACPI Error: Method parse/execution failed [\\DBG] (Node ffff88021710ab40), AE_AML_INTERNAL (20170303/psparse-543)\n>[    0.514477] ACPI Error: Method parse/execution failed [\\_PIC] (Node ffff88021710ab18), AE_AML_INTERNAL (20170303/psparse-543)\n>[    0.518867] ACPI Exception: AE_AML_INTERNAL, Evaluating _PIC (20170303/bus-991)\n>[    0.522384] kmem_cache_destroy Acpi-Operand: Slab cache still has objects\n>[    0.524597] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.12.0-rc5 #26\n>[    0.526795] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006\n>[    0.529668] Call Trace:\n>[    0.530811]  ? dump_stack+0x5c/0x81\n>[    0.532240]  ? kmem_cache_destroy+0x1aa/0x1c0\n>[    0.533905]  ? acpi_os_delete_cache+0xa/0x10\n>[    0.535497]  ? acpi_ut_delete_caches+0x3f/0x7b\n>[    0.537237]  ? acpi_terminate+0xa/0x14\n>[    0.538701]  ? acpi_init+0x2af/0x34f\n>[    0.540008]  ? acpi_sleep_proc_init+0x27/0x27\n>[    0.541593]  ? do_one_initcall+0x4e/0x1a0\n>[    0.543008]  ? kernel_init_freeable+0x19e/0x21f\n>[    0.546202]  ? rest_init+0x80/0x80\n>[    0.547513]  ? kernel_init+0xa/0x100\n>[    0.548817]  ? ret_from_fork+0x25/0x30\n>[    0.550587] vgaarb: loaded\n>[    0.551716] EDAC MC: Ver: 3.0.0\n>[    0.553744] PCI: Probing PCI hardware\n>[    0.555038] PCI host bridge to bus 0000:00\n> ... Continue to boot and log is omitted ...\n\nI analyzed this memory leak in detail and found AcpiNsEvaluate() function\nonly removes Info->ReturnObject in AE_CTRL_RETURN_VALUE case. But, when errors\noccur, the status value is not AE_CTRL_RETURN_VALUE, and Info->ReturnObject is\nalso not null. Therefore, this causes acpi operand memory leak.\n\nThis cache leak causes a security threat because an old kernel (<= 4.9) shows\nmemory locations of kernel functions in stack dump. Some malicious users\ncould use this information to neutralize kernel ASLR.\n\nI made a patch to fix ACPI operand cache leak.\n\nSigned-off-by: Seunghun Han <kkamagui@gmail.com>",
  "commit_hash": "37f2c716f2c6ab14c3ba557a539c3ee3224931b5",
  "git_url": "https://github.com/acpica/acpica/commit/37f2c716f2c6ab14c3ba557a539c3ee3224931b5",
  "file_path": "source/components/namespace/nseval.c",
  "func_name": "AcpiNsEvaluate",
  "func_before": "ACPI_STATUS\nAcpiNsEvaluate (\n    ACPI_EVALUATE_INFO      *Info)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsEvaluate);\n\n\n    if (!Info)\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    if (!Info->Node)\n    {\n        /*\n         * Get the actual namespace node for the target object if we\n         * need to. Handles these cases:\n         *\n         * 1) Null node, valid pathname from root (absolute path)\n         * 2) Node and valid pathname (path relative to Node)\n         * 3) Node, Null pathname\n         */\n        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,\n            ACPI_NS_NO_UPSEARCH, &Info->Node);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n    }\n\n    /*\n     * For a method alias, we must grab the actual method node so that\n     * proper scoping context will be established before execution.\n     */\n    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)\n    {\n        Info->Node = ACPI_CAST_PTR (\n            ACPI_NAMESPACE_NODE, Info->Node->Object);\n    }\n\n    /* Complete the info block initialization */\n\n    Info->ReturnObject = NULL;\n    Info->NodeFlags = Info->Node->Flags;\n    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"%s [%p] Value %p\\n\",\n        Info->RelativePathname, Info->Node,\n        AcpiNsGetAttachedObject (Info->Node)));\n\n    /* Get info if we have a predefined name (_HID, etc.) */\n\n    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);\n\n    /* Get the full pathname to the object, for use in warning messages */\n\n    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);\n    if (!Info->FullPathname)\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    /* Count the number of arguments being passed in */\n\n    Info->ParamCount = 0;\n    if (Info->Parameters)\n    {\n        while (Info->Parameters[Info->ParamCount])\n        {\n            Info->ParamCount++;\n        }\n\n        /* Warn on impossible argument count */\n\n        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)\n        {\n            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,\n                \"Excess arguments (%u) - using only %u\",\n                Info->ParamCount, ACPI_METHOD_NUM_ARGS));\n\n            Info->ParamCount = ACPI_METHOD_NUM_ARGS;\n        }\n    }\n\n    /*\n     * For predefined names: Check that the declared argument count\n     * matches the ACPI spec -- otherwise this is a BIOS error.\n     */\n    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,\n        Info->Predefined);\n\n    /*\n     * For all names: Check that the incoming argument count for\n     * this method/object matches the actual ASL/AML definition.\n     */\n    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,\n        Info->ParamCount, Info->Predefined);\n\n    /* For predefined names: Typecheck all incoming arguments */\n\n    AcpiNsCheckArgumentTypes (Info);\n\n    /*\n     * Three major evaluation cases:\n     *\n     * 1) Object types that cannot be evaluated by definition\n     * 2) The object is a control method -- execute it\n     * 3) The object is not a method -- just return it's current value\n     */\n    switch (AcpiNsGetType (Info->Node))\n    {\n    case ACPI_TYPE_DEVICE:\n    case ACPI_TYPE_EVENT:\n    case ACPI_TYPE_MUTEX:\n    case ACPI_TYPE_REGION:\n    case ACPI_TYPE_THERMAL:\n    case ACPI_TYPE_LOCAL_SCOPE:\n        /*\n         * 1) Disallow evaluation of certain object types. For these,\n         *    object evaluation is undefined and not supported.\n         */\n        ACPI_ERROR ((AE_INFO,\n            \"%s: Evaluation of object type [%s] is not supported\",\n            Info->FullPathname,\n            AcpiUtGetTypeName (Info->Node->Type)));\n\n        Status = AE_TYPE;\n        goto Cleanup;\n\n    case ACPI_TYPE_METHOD:\n        /*\n         * 2) Object is a control method - execute it\n         */\n\n        /* Verify that there is a method object associated with this node */\n\n        if (!Info->ObjDesc)\n        {\n            ACPI_ERROR ((AE_INFO, \"%s: Method has no attached sub-object\",\n                Info->FullPathname));\n            Status = AE_NULL_OBJECT;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,\n            \"**** Execute method [%s] at AML address %p length %X\\n\",\n            Info->FullPathname,\n            Info->ObjDesc->Method.AmlStart + 1,\n            Info->ObjDesc->Method.AmlLength - 1));\n\n        /*\n         * Any namespace deletion must acquire both the namespace and\n         * interpreter locks to ensure that no thread is using the portion of\n         * the namespace that is being deleted.\n         *\n         * Execute the method via the interpreter. The interpreter is locked\n         * here before calling into the AML parser\n         */\n        AcpiExEnterInterpreter ();\n        Status = AcpiPsExecuteMethod (Info);\n        AcpiExExitInterpreter ();\n        break;\n\n    default:\n        /*\n         * 3) All other non-method objects -- get the current object value\n         */\n\n        /*\n         * Some objects require additional resolution steps (e.g., the Node\n         * may be a field that must be read, etc.) -- we can't just grab\n         * the object out of the node.\n         *\n         * Use ResolveNodeToValue() to get the associated value.\n         *\n         * NOTE: we can get away with passing in NULL for a walk state because\n         * the Node is guaranteed to not be a reference to either a method\n         * local or a method argument (because this interface is never called\n         * from a running method.)\n         *\n         * Even though we do not directly invoke the interpreter for object\n         * resolution, we must lock it because we could access an OpRegion.\n         * The OpRegion access code assumes that the interpreter is locked.\n         */\n        AcpiExEnterInterpreter ();\n\n        /* TBD: ResolveNodeToValue has a strange interface, fix */\n\n        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);\n\n        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (\n            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);\n        AcpiExExitInterpreter ();\n\n        if (ACPI_FAILURE (Status))\n        {\n            Info->ReturnObject = NULL;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"Returned object %p [%s]\\n\",\n            Info->ReturnObject,\n            AcpiUtGetObjectTypeName (Info->ReturnObject)));\n\n        Status = AE_CTRL_RETURN_VALUE; /* Always has a \"return value\" */\n        break;\n    }\n\n    /*\n     * For predefined names, check the return value against the ACPI\n     * specification. Some incorrect return value types are repaired.\n     */\n    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,\n        Status, &Info->ReturnObject);\n\n    /* Check if there is a return value that must be dealt with */\n\n    if (Status == AE_CTRL_RETURN_VALUE)\n    {\n        /* If caller does not want the return value, delete it */\n\n        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)\n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n\n        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */\n\n        Status = AE_OK;\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,\n        \"*** Completed evaluation of object %s ***\\n\",\n        Info->RelativePathname));\n\nCleanup:\n    /*\n     * Namespace was unlocked by the handling AcpiNs* function, so we\n     * just free the pathname and return\n     */\n    ACPI_FREE (Info->FullPathname);\n    Info->FullPathname = NULL;\n    return_ACPI_STATUS (Status);\n}",
  "abstract_func_before": "ACPI_STATUS\nAcpiNsEvaluate (\n    ACPI_EVALUATE_INFO      *VAR_0)\n{\n    ACPI_STATUS             VAR_1;\n\n\n    ACPI_FUNCTION_TRACE (VAR_2);\n\n\n    if (!VAR_0)\n    {\n        return_ACPI_STATUS (VAR_3);\n    }\n\n    if (!VAR_0->Node)\n    {\n        /* COMMENT_0 */\n                                                                    \n                                        \n          \n                                                                 \n                                                             \n                                 \n           \n        VAR_1 = AcpiNsGetNode (VAR_0->PrefixNode, VAR_0->RelativePathname,\n            VAR_4, &VAR_0->Node);\n        if (ACPI_FAILURE (VAR_1))\n        {\n            return_ACPI_STATUS (VAR_1);\n        }\n    }\n\n    /* COMMENT_8 */\n                                                                      \n                                                                   \n       \n    if (AcpiNsGetType (VAR_0->Node) == VAR_5)\n    {\n        VAR_0->Node = ACPI_CAST_PTR (\n            VAR_6, VAR_0->Node->Object);\n    }\n\n    /* COMMENT_12 */\n\n    VAR_0->ReturnObject = NULL;\n    VAR_0->NodeFlags = VAR_0->Node->Flags;\n    VAR_0->ObjDesc = AcpiNsGetAttachedObject (VAR_0->Node);\n\n    ACPI_DEBUG_PRINT ((VAR_7, \"%s [%p] Value %p\\n\",\n        VAR_0->RelativePathname, VAR_0->Node,\n        AcpiNsGetAttachedObject (VAR_0->Node)));\n\n    /* COMMENT_13 */\n\n    VAR_0->Predefined = AcpiUtMatchPredefinedMethod (VAR_0->Node->Name.Ascii);\n\n    /* COMMENT_14 */\n\n    VAR_0->FullPathname = AcpiNsGetNormalizedPathname (VAR_0->Node, TRUE);\n    if (!VAR_0->FullPathname)\n    {\n        return_ACPI_STATUS (VAR_8);\n    }\n\n    /* COMMENT_15 */\n\n    VAR_0->ParamCount = 0;\n    if (VAR_0->Parameters)\n    {\n        while (VAR_0->Parameters[VAR_0->ParamCount])\n        {\n            VAR_0->ParamCount++;\n        }\n\n        /* COMMENT_16 */\n\n        if (VAR_0->ParamCount > VAR_9)\n        {\n            ACPI_WARN_PREDEFINED ((VAR_10, VAR_0->FullPathname, VAR_11,\n                \"Excess arguments (%u) - using only %u\",\n                VAR_0->ParamCount, VAR_9));\n\n            VAR_0->ParamCount = VAR_9;\n        }\n    }\n\n    /* COMMENT_17 */\n                                                                   \n                                                               \n       \n    AcpiNsCheckAcpiCompliance (VAR_0->FullPathname, VAR_0->Node,\n        VAR_0->Predefined);\n\n    /* COMMENT_21 */\n                                                                \n                                                                \n       \n    AcpiNsCheckArgumentCount (VAR_0->FullPathname, VAR_0->Node,\n        VAR_0->ParamCount, VAR_0->Predefined);\n\n    /* COMMENT_25 */\n\n    AcpiNsCheckArgumentTypes (VAR_0);\n\n    /* COMMENT_26 */\n                                    \n      \n                                                             \n                                                      \n                                                                      \n       \n    switch (AcpiNsGetType (VAR_0->Node))\n    {\n    case VAR_12:\n    case VAR_13:\n    case VAR_14:\n    case VAR_15:\n    case VAR_16:\n    case VAR_17:\n        /* COMMENT_33 */\n                                                                     \n                                                               \n           \n        ACPI_ERROR ((VAR_10,\n            \"%s: Evaluation of object type [%s] is not supported\",\n            VAR_0->FullPathname,\n            AcpiUtGetTypeName (VAR_0->Node->Type)));\n\n        VAR_1 = VAR_18;\n        goto Cleanup;\n\n    case VAR_19:\n        /* COMMENT_37 */\n                                                     \n           \n\n        /* COMMENT_40 */\n\n        if (!VAR_0->ObjDesc)\n        {\n            ACPI_ERROR ((VAR_10, \"%s: Method has no attached sub-object\",\n                VAR_0->FullPathname));\n            VAR_1 = VAR_20;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((VAR_21,\n            \"**** Execute method [%s] at AML address %p length %X\\n\",\n            VAR_0->FullPathname,\n            VAR_0->ObjDesc->Method.AmlStart + 1,\n            VAR_0->ObjDesc->Method.AmlLength - 1));\n\n        /* COMMENT_41 */\n                                                                     \n                                                                             \n                                               \n          \n                                                                            \n                                                  \n           \n        AcpiExEnterInterpreter ();\n        VAR_1 = AcpiPsExecuteMethod (VAR_0);\n        AcpiExExitInterpreter ();\n        break;\n\n    default:\n        /* COMMENT_49 */\n                                                                          \n           \n\n        /* COMMENT_52 */\n                                                                           \n                                                                        \n                                      \n          \n                                                                \n          \n                                                                              \n                                                                          \n                                                                             \n                                  \n          \n                                                                           \n                                                                           \n                                                                           \n           \n        AcpiExEnterInterpreter ();\n\n        /* COMMENT_66 */\n\n        VAR_0->ReturnObject = ACPI_CAST_PTR (VAR_22, VAR_0->Node);\n\n        VAR_1 = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (\n            VAR_6, &VAR_0->ReturnObject), NULL);\n        AcpiExExitInterpreter ();\n\n        if (ACPI_FAILURE (VAR_1))\n        {\n            VAR_0->ReturnObject = NULL;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((VAR_7, \"Returned object %p [%s]\\n\",\n            VAR_0->ReturnObject,\n            AcpiUtGetObjectTypeName (VAR_0->ReturnObject)));\n\n        VAR_1 = VAR_23; /* COMMENT_67 */\n        break;\n    }\n\n    /* COMMENT_68 */\n                                                                    \n                                                                     \n       \n    (void) AcpiNsCheckReturnValue (VAR_0->Node, VAR_0, VAR_0->ParamCount,\n        VAR_1, &VAR_0->ReturnObject);\n\n    /* COMMENT_72 */\n\n    if (VAR_1 == VAR_23)\n    {\n        /* COMMENT_73 */\n\n        if (VAR_0->Flags & VAR_24)\n        {\n            AcpiUtRemoveReference (VAR_0->ReturnObject);\n            VAR_0->ReturnObject = NULL;\n        }\n\n        /* COMMENT_74 */\n\n        VAR_1 = VAR_25;\n    }\n\n    ACPI_DEBUG_PRINT ((VAR_7,\n        \"*** Completed evaluation of object %s ***\\n\",\n        VAR_0->RelativePathname));\n\nCleanup:\n    /* COMMENT_75 */\n                                                                     \n                                        \n       \n    ACPI_FREE (VAR_0->FullPathname);\n    VAR_0->FullPathname = NULL;\n    return_ACPI_STATUS (VAR_1);\n}",
  "func_graph_path_before": "acpica/37f2c716f2c6ab14c3ba557a539c3ee3224931b5/nseval.c/vul/before/0.json",
  "func": "ACPI_STATUS\nAcpiNsEvaluate (\n    ACPI_EVALUATE_INFO      *Info)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsEvaluate);\n\n\n    if (!Info)\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    if (!Info->Node)\n    {\n        /*\n         * Get the actual namespace node for the target object if we\n         * need to. Handles these cases:\n         *\n         * 1) Null node, valid pathname from root (absolute path)\n         * 2) Node and valid pathname (path relative to Node)\n         * 3) Node, Null pathname\n         */\n        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,\n            ACPI_NS_NO_UPSEARCH, &Info->Node);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n    }\n\n    /*\n     * For a method alias, we must grab the actual method node so that\n     * proper scoping context will be established before execution.\n     */\n    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)\n    {\n        Info->Node = ACPI_CAST_PTR (\n            ACPI_NAMESPACE_NODE, Info->Node->Object);\n    }\n\n    /* Complete the info block initialization */\n\n    Info->ReturnObject = NULL;\n    Info->NodeFlags = Info->Node->Flags;\n    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"%s [%p] Value %p\\n\",\n        Info->RelativePathname, Info->Node,\n        AcpiNsGetAttachedObject (Info->Node)));\n\n    /* Get info if we have a predefined name (_HID, etc.) */\n\n    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);\n\n    /* Get the full pathname to the object, for use in warning messages */\n\n    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);\n    if (!Info->FullPathname)\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    /* Count the number of arguments being passed in */\n\n    Info->ParamCount = 0;\n    if (Info->Parameters)\n    {\n        while (Info->Parameters[Info->ParamCount])\n        {\n            Info->ParamCount++;\n        }\n\n        /* Warn on impossible argument count */\n\n        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)\n        {\n            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,\n                \"Excess arguments (%u) - using only %u\",\n                Info->ParamCount, ACPI_METHOD_NUM_ARGS));\n\n            Info->ParamCount = ACPI_METHOD_NUM_ARGS;\n        }\n    }\n\n    /*\n     * For predefined names: Check that the declared argument count\n     * matches the ACPI spec -- otherwise this is a BIOS error.\n     */\n    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,\n        Info->Predefined);\n\n    /*\n     * For all names: Check that the incoming argument count for\n     * this method/object matches the actual ASL/AML definition.\n     */\n    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,\n        Info->ParamCount, Info->Predefined);\n\n    /* For predefined names: Typecheck all incoming arguments */\n\n    AcpiNsCheckArgumentTypes (Info);\n\n    /*\n     * Three major evaluation cases:\n     *\n     * 1) Object types that cannot be evaluated by definition\n     * 2) The object is a control method -- execute it\n     * 3) The object is not a method -- just return it's current value\n     */\n    switch (AcpiNsGetType (Info->Node))\n    {\n    case ACPI_TYPE_DEVICE:\n    case ACPI_TYPE_EVENT:\n    case ACPI_TYPE_MUTEX:\n    case ACPI_TYPE_REGION:\n    case ACPI_TYPE_THERMAL:\n    case ACPI_TYPE_LOCAL_SCOPE:\n        /*\n         * 1) Disallow evaluation of certain object types. For these,\n         *    object evaluation is undefined and not supported.\n         */\n        ACPI_ERROR ((AE_INFO,\n            \"%s: Evaluation of object type [%s] is not supported\",\n            Info->FullPathname,\n            AcpiUtGetTypeName (Info->Node->Type)));\n\n        Status = AE_TYPE;\n        goto Cleanup;\n\n    case ACPI_TYPE_METHOD:\n        /*\n         * 2) Object is a control method - execute it\n         */\n\n        /* Verify that there is a method object associated with this node */\n\n        if (!Info->ObjDesc)\n        {\n            ACPI_ERROR ((AE_INFO, \"%s: Method has no attached sub-object\",\n                Info->FullPathname));\n            Status = AE_NULL_OBJECT;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,\n            \"**** Execute method [%s] at AML address %p length %X\\n\",\n            Info->FullPathname,\n            Info->ObjDesc->Method.AmlStart + 1,\n            Info->ObjDesc->Method.AmlLength - 1));\n\n        /*\n         * Any namespace deletion must acquire both the namespace and\n         * interpreter locks to ensure that no thread is using the portion of\n         * the namespace that is being deleted.\n         *\n         * Execute the method via the interpreter. The interpreter is locked\n         * here before calling into the AML parser\n         */\n        AcpiExEnterInterpreter ();\n        Status = AcpiPsExecuteMethod (Info);\n        AcpiExExitInterpreter ();\n        break;\n\n    default:\n        /*\n         * 3) All other non-method objects -- get the current object value\n         */\n\n        /*\n         * Some objects require additional resolution steps (e.g., the Node\n         * may be a field that must be read, etc.) -- we can't just grab\n         * the object out of the node.\n         *\n         * Use ResolveNodeToValue() to get the associated value.\n         *\n         * NOTE: we can get away with passing in NULL for a walk state because\n         * the Node is guaranteed to not be a reference to either a method\n         * local or a method argument (because this interface is never called\n         * from a running method.)\n         *\n         * Even though we do not directly invoke the interpreter for object\n         * resolution, we must lock it because we could access an OpRegion.\n         * The OpRegion access code assumes that the interpreter is locked.\n         */\n        AcpiExEnterInterpreter ();\n\n        /* TBD: ResolveNodeToValue has a strange interface, fix */\n\n        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);\n\n        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (\n            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);\n        AcpiExExitInterpreter ();\n\n        if (ACPI_FAILURE (Status))\n        {\n            Info->ReturnObject = NULL;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"Returned object %p [%s]\\n\",\n            Info->ReturnObject,\n            AcpiUtGetObjectTypeName (Info->ReturnObject)));\n\n        Status = AE_CTRL_RETURN_VALUE; /* Always has a \"return value\" */\n        break;\n    }\n\n    /*\n     * For predefined names, check the return value against the ACPI\n     * specification. Some incorrect return value types are repaired.\n     */\n    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,\n        Status, &Info->ReturnObject);\n\n    /* Check if there is a return value that must be dealt with */\n\n    if (Status == AE_CTRL_RETURN_VALUE)\n    {\n        /* If caller does not want the return value, delete it */\n\n        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)\n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n\n        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */\n\n        Status = AE_OK;\n    }\n    else if (ACPI_FAILURE(Status)) \n    {\n        /* If ReturnObject exists, delete it */\n\n        if (Info->ReturnObject) \n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,\n        \"*** Completed evaluation of object %s ***\\n\",\n        Info->RelativePathname));\n\nCleanup:\n    /*\n     * Namespace was unlocked by the handling AcpiNs* function, so we\n     * just free the pathname and return\n     */\n    ACPI_FREE (Info->FullPathname);\n    Info->FullPathname = NULL;\n    return_ACPI_STATUS (Status);\n}",
  "abstract_func": "ACPI_STATUS\nAcpiNsEvaluate (\n    ACPI_EVALUATE_INFO      *VAR_0)\n{\n    ACPI_STATUS             VAR_1;\n\n\n    ACPI_FUNCTION_TRACE (VAR_2);\n\n\n    if (!VAR_0)\n    {\n        return_ACPI_STATUS (VAR_3);\n    }\n\n    if (!VAR_0->Node)\n    {\n        /* COMMENT_0 */\n                                                                    \n                                        \n          \n                                                                 \n                                                             \n                                 \n           \n        VAR_1 = AcpiNsGetNode (VAR_0->PrefixNode, VAR_0->RelativePathname,\n            VAR_4, &VAR_0->Node);\n        if (ACPI_FAILURE (VAR_1))\n        {\n            return_ACPI_STATUS (VAR_1);\n        }\n    }\n\n    /* COMMENT_8 */\n                                                                      \n                                                                   \n       \n    if (AcpiNsGetType (VAR_0->Node) == VAR_5)\n    {\n        VAR_0->Node = ACPI_CAST_PTR (\n            VAR_6, VAR_0->Node->Object);\n    }\n\n    /* COMMENT_12 */\n\n    VAR_0->ReturnObject = NULL;\n    VAR_0->NodeFlags = VAR_0->Node->Flags;\n    VAR_0->ObjDesc = AcpiNsGetAttachedObject (VAR_0->Node);\n\n    ACPI_DEBUG_PRINT ((VAR_7, \"%s [%p] Value %p\\n\",\n        VAR_0->RelativePathname, VAR_0->Node,\n        AcpiNsGetAttachedObject (VAR_0->Node)));\n\n    /* COMMENT_13 */\n\n    VAR_0->Predefined = AcpiUtMatchPredefinedMethod (VAR_0->Node->Name.Ascii);\n\n    /* COMMENT_14 */\n\n    VAR_0->FullPathname = AcpiNsGetNormalizedPathname (VAR_0->Node, TRUE);\n    if (!VAR_0->FullPathname)\n    {\n        return_ACPI_STATUS (VAR_8);\n    }\n\n    /* COMMENT_15 */\n\n    VAR_0->ParamCount = 0;\n    if (VAR_0->Parameters)\n    {\n        while (VAR_0->Parameters[VAR_0->ParamCount])\n        {\n            VAR_0->ParamCount++;\n        }\n\n        /* COMMENT_16 */\n\n        if (VAR_0->ParamCount > VAR_9)\n        {\n            ACPI_WARN_PREDEFINED ((VAR_10, VAR_0->FullPathname, VAR_11,\n                \"Excess arguments (%u) - using only %u\",\n                VAR_0->ParamCount, VAR_9));\n\n            VAR_0->ParamCount = VAR_9;\n        }\n    }\n\n    /* COMMENT_17 */\n                                                                   \n                                                               \n       \n    AcpiNsCheckAcpiCompliance (VAR_0->FullPathname, VAR_0->Node,\n        VAR_0->Predefined);\n\n    /* COMMENT_21 */\n                                                                \n                                                                \n       \n    AcpiNsCheckArgumentCount (VAR_0->FullPathname, VAR_0->Node,\n        VAR_0->ParamCount, VAR_0->Predefined);\n\n    /* COMMENT_25 */\n\n    AcpiNsCheckArgumentTypes (VAR_0);\n\n    /* COMMENT_26 */\n                                    \n      \n                                                             \n                                                      \n                                                                      \n       \n    switch (AcpiNsGetType (VAR_0->Node))\n    {\n    case VAR_12:\n    case VAR_13:\n    case VAR_14:\n    case VAR_15:\n    case VAR_16:\n    case VAR_17:\n        /* COMMENT_33 */\n                                                                     \n                                                               \n           \n        ACPI_ERROR ((VAR_10,\n            \"%s: Evaluation of object type [%s] is not supported\",\n            VAR_0->FullPathname,\n            AcpiUtGetTypeName (VAR_0->Node->Type)));\n\n        VAR_1 = VAR_18;\n        goto Cleanup;\n\n    case VAR_19:\n        /* COMMENT_37 */\n                                                     \n           \n\n        /* COMMENT_40 */\n\n        if (!VAR_0->ObjDesc)\n        {\n            ACPI_ERROR ((VAR_10, \"%s: Method has no attached sub-object\",\n                VAR_0->FullPathname));\n            VAR_1 = VAR_20;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((VAR_21,\n            \"**** Execute method [%s] at AML address %p length %X\\n\",\n            VAR_0->FullPathname,\n            VAR_0->ObjDesc->Method.AmlStart + 1,\n            VAR_0->ObjDesc->Method.AmlLength - 1));\n\n        /* COMMENT_41 */\n                                                                     \n                                                                             \n                                               \n          \n                                                                            \n                                                  \n           \n        AcpiExEnterInterpreter ();\n        VAR_1 = AcpiPsExecuteMethod (VAR_0);\n        AcpiExExitInterpreter ();\n        break;\n\n    default:\n        /* COMMENT_49 */\n                                                                          \n           \n\n        /* COMMENT_52 */\n                                                                           \n                                                                        \n                                      \n          \n                                                                \n          \n                                                                              \n                                                                          \n                                                                             \n                                  \n          \n                                                                           \n                                                                           \n                                                                           \n           \n        AcpiExEnterInterpreter ();\n\n        /* COMMENT_66 */\n\n        VAR_0->ReturnObject = ACPI_CAST_PTR (VAR_22, VAR_0->Node);\n\n        VAR_1 = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (\n            VAR_6, &VAR_0->ReturnObject), NULL);\n        AcpiExExitInterpreter ();\n\n        if (ACPI_FAILURE (VAR_1))\n        {\n            VAR_0->ReturnObject = NULL;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((VAR_7, \"Returned object %p [%s]\\n\",\n            VAR_0->ReturnObject,\n            AcpiUtGetObjectTypeName (VAR_0->ReturnObject)));\n\n        VAR_1 = VAR_23; /* COMMENT_67 */\n        break;\n    }\n\n    /* COMMENT_68 */\n                                                                    \n                                                                     \n       \n    (void) AcpiNsCheckReturnValue (VAR_0->Node, VAR_0, VAR_0->ParamCount,\n        VAR_1, &VAR_0->ReturnObject);\n\n    /* COMMENT_72 */\n\n    if (VAR_1 == VAR_23)\n    {\n        /* COMMENT_73 */\n\n        if (VAR_0->Flags & VAR_24)\n        {\n            AcpiUtRemoveReference (VAR_0->ReturnObject);\n            VAR_0->ReturnObject = NULL;\n        }\n\n        /* COMMENT_74 */\n\n        VAR_1 = VAR_25;\n    }\n    else if (ACPI_FAILURE(VAR_1)) \n    {\n        /* COMMENT_75 */\n\n        if (VAR_0->ReturnObject) \n        {\n            AcpiUtRemoveReference (VAR_0->ReturnObject);\n            VAR_0->ReturnObject = NULL;\n        }\n    }\n\n    ACPI_DEBUG_PRINT ((VAR_7,\n        \"*** Completed evaluation of object %s ***\\n\",\n        VAR_0->RelativePathname));\n\nCleanup:\n    /* COMMENT_76 */\n                                                                     \n                                        \n       \n    ACPI_FREE (VAR_0->FullPathname);\n    VAR_0->FullPathname = NULL;\n    return_ACPI_STATUS (VAR_1);\n}",
  "func_graph_path": "acpica/37f2c716f2c6ab14c3ba557a539c3ee3224931b5/nseval.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -232,6 +232,16 @@\n \n         Status = AE_OK;\n     }\n+    else if (ACPI_FAILURE(Status)) \n+    {\n+        /* If ReturnObject exists, delete it */\n+\n+        if (Info->ReturnObject) \n+        {\n+            AcpiUtRemoveReference (Info->ReturnObject);\n+            Info->ReturnObject = NULL;\n+        }\n+    }\n \n     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,\n         \"*** Completed evaluation of object %s ***\\n\",",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    else if (ACPI_FAILURE(Status)) ",
      "    {",
      "        /* If ReturnObject exists, delete it */",
      "",
      "        if (Info->ReturnObject) ",
      "        {",
      "            AcpiUtRemoveReference (Info->ReturnObject);",
      "            Info->ReturnObject = NULL;",
      "        }",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/acpica/acpica/pull/296",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/acpica/acpica/pull/296: 403 Client Error: Forbidden for url: https://api.github.com/repos/acpica/acpica/pulls/296",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a memory leak in the ACPI subsystem that exposes kernel addresses, posing a security threat by allowing bypass of ASLR. The code modification ensures proper cleanup of the ReturnObject in error cases, preventing the leak. The description and code changes are consistent, clearly indicating this is a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}