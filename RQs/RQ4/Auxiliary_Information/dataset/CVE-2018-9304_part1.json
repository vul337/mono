{
  "cve_id": "CVE-2018-9304",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Fix division by zero in BigTiffImage::printIFD\n\nThis fixes #262",
  "commit_hash": "b3199a072073ac6292e5bbbd5cce2167f1932ea8",
  "git_url": "https://github.com/Exiv2/exiv2/commit/b3199a072073ac6292e5bbbd5cce2167f1932ea8",
  "file_path": "src/bigtiffimage.cpp",
  "func_name": "printIFD",
  "func_before": "void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(dir_offset, BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF BIGTIFF FILE \") << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \"entries = \" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \"\" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            if (size > std::numeric_limits<uint64_t>::max() / count)\n                                throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(offset, BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n                                const std::string offsetString = usePointer?\n                                    Internal::stringFormat(\"%10u\", offset):\n                                    \"\";\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |%10s | \",\n                                        address, tag, tagName(tag).c_str(), typeName(type), count, offsetString.c_str());\n\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \"/\" << b;\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(buf, (size_t) kount);\n\n                                sp = kount == count ? \"\" : \" ...\";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    const size_t restore = io.tell();      // save\n                                    io.seek(offset, BasicIo::beg);         // position\n                                    byte* bytes=new byte[(size_t)count] ;  // allocate memory\n                                    io.read(bytes,(long)count)        ;    // read\n                                    io.seek(restore, BasicIo::beg);        // restore\n                                    IptcData::printStructure(out,bytes,(size_t)count,depth);\n                                    delete[] bytes;                        // free\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(dir_offset, BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\"Nikon\",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(count - jump);\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n\n                    depth--;\n                }",
  "abstract_func_before": "void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)\n                {\n                    BasicIo& VAR_4 = Image::io();\n\n                    VAR_3++;\n                    bool VAR_5  = true;\n\n                    /* COMMENT_0 */\n                    bool VAR_6 = true;\n\n                    do\n                    {\n                        /* COMMENT_1 */\n                        VAR_4.seek(VAR_2, BasicIo::beg);\n\n                        const uint64_t VAR_7 = readData(VAR_8.format() == Header::StandardTiff? 2: 8);\n                        const bool VAR_9 = VAR_7 > 500;\n\n                        if ( VAR_5 && VAR_6 )\n                        {\n                            VAR_0 << Internal::indent(VAR_3) << Internal::stringFormat(\"STRUCTURE OF BIGTIFF FILE \") << VAR_4.path() << std::endl;\n                            if (VAR_9)\n                                VAR_0 << Internal::indent(VAR_3) << \"entries = \" << VAR_7 << std::endl;\n                        }\n\n                        if (VAR_9)\n                            break;\n\n                        /* COMMENT_2 */\n                        for ( uint64_t VAR_10 = 0; VAR_10 < VAR_7; VAR_10 ++ )\n                        {\n                            if ( VAR_5 && VAR_6 )\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            VAR_5 = false;\n\n                            const uint16_t VAR_11   = (uint16_t) readData(2);\n                            const uint16_t VAR_12  = (uint16_t) readData(2);\n                            const uint64_t VAR_13 = readData(VAR_14);\n                            const DataBuf  VAR_15  = VAR_4.read(VAR_14);        /* COMMENT_3 */\n\n                            std::string VAR_16 = \"\" ; /* COMMENT_4 */\n\n                            /* COMMENT_5 */\n                            /* COMMENT_6 */\n                            const uint64_t VAR_17  = isStringType(VAR_12)? (VAR_13 > 32 ? 32 : VAR_13) /* COMMENT_7 */\n                                                            : VAR_13 > 5              ? 5\n                                                            : VAR_13\n                                                            ;\n                            const uint32_t VAR_18    = isStringType(VAR_12) ? 1 : 0;\n                            const uint32_t VAR_19   = isStringType(VAR_12) ? 1\n                                                  : is2ByteType(VAR_12)  ? 2\n                                                  : is4ByteType(VAR_12)  ? 4\n                                                  : is8ByteType(VAR_12)  ? 8\n                                                  : 1;\n\n                            /* COMMENT_8 */\n\n                            /* COMMENT_9 */\n                            /* COMMENT_10 */\n                            /* COMMENT_11 */\n                            if (VAR_19 > std::numeric_limits<uint64_t>::max() / VAR_13)\n                                throw Error(VAR_20);             /* COMMENT_12 */\n                                                             /* COMMENT_13 */\n\n                            if (VAR_19 * VAR_13 > std::numeric_limits<uint64_t>::max() - VAR_18)\n                                throw Error(VAR_20);             /* COMMENT_14 */\n\n                            const uint64_t VAR_21 = VAR_19*VAR_13 + VAR_18;\n                            if ( VAR_21 > VAR_4.size() ) {\n                                throw Error(VAR_20);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t VAR_22 = VAR_8.format() == Header::StandardTiff?\n                                    byteSwap4(VAR_15, 0, VAR_23):\n                                    byteSwap8(VAR_15, 0, VAR_23);\n\n                            /* COMMENT_15 */\n                            const bool VAR_24 = (size_t) VAR_13*VAR_19 > (size_t) VAR_14;\n\n                            if ( VAR_24 )                          /* COMMENT_16 */\n                            {\n                                size_t   VAR_25 = VAR_4.tell();          /* COMMENT_17 */\n                                VAR_4.seek(VAR_22, BasicIo::beg);         /* COMMENT_18 */\n                                VAR_4.read(VAR_26.pData_, (long) VAR_13 * VAR_19);     /* COMMENT_19 */\n                                VAR_4.seek(VAR_25, BasicIo::beg);        /* COMMENT_20 */\n                            }\n                            else  /* COMMENT_21 */\n                                std::memcpy(VAR_26.pData_, VAR_15.pData_, (size_t) VAR_13 * VAR_19);     /* COMMENT_22 */\n\n                            if ( VAR_6 )\n                            {\n                                const uint64_t VAR_27 = VAR_8.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t VAR_28 = VAR_2 + 2 + VAR_10 * VAR_27;\n                                const std::string VAR_29 = VAR_24?\n                                    Internal::stringFormat(\"%10u\", VAR_22):\n                                    \"\";\n\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |%10s | \",\n                                        VAR_28, VAR_11, tagName(VAR_11).c_str(), typeName(VAR_12), VAR_13, VAR_29.c_str());\n\n                                if ( isShortType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_16 << byteSwap2(VAR_26, VAR_30*VAR_19, VAR_23);\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isLongType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_16 << byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_16 << byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23);\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        uint32_t VAR_31 = byteSwap4(VAR_26, VAR_30*VAR_19+0, VAR_23);\n                                        uint32_t VAR_32 = byteSwap4(VAR_26, VAR_30*VAR_19+4, VAR_23);\n                                        VAR_0 << VAR_16 << VAR_31 << \"/\" << VAR_32;\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isStringType(VAR_12) )\n                                    VAR_0 << VAR_16 << Internal::binaryToString(VAR_26, (size_t) VAR_17);\n\n                                VAR_16 = VAR_17 == VAR_13 ? \"\" : \" ...\";\n                                VAR_0 << VAR_16 << std::endl;\n\n                                if ( VAR_1 == VAR_33 &&\n                                        (VAR_11 == 0x8769 /* COMMENT_23 */ || VAR_11 == 0x014a/* COMMENT_24 */ || VAR_12 == VAR_34 || VAR_12 == VAR_35) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_13 ; VAR_30++ )\n                                    {\n                                        const size_t VAR_25 = VAR_4.tell();\n                                        const uint64_t VAR_36 = VAR_12 == VAR_35?\n                                            byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23):\n                                            byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);\n\n                                        printIFD(VAR_0, VAR_1, VAR_36, VAR_3);\n                                        VAR_4.seek(VAR_25, BasicIo::beg);\n                                    }\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_11 == 0x83bb /* COMMENT_25 */ )\n                                {\n                                    const size_t VAR_25 = VAR_4.tell();      /* COMMENT_17 */\n                                    VAR_4.seek(VAR_22, BasicIo::beg);         /* COMMENT_18 */\n                                    byte* VAR_37=new byte[(size_t)VAR_13] ;  /* COMMENT_26 */\n                                    VAR_4.read(VAR_37,(long)VAR_13)        ;    /* COMMENT_19 */\n                                    VAR_4.seek(VAR_25, BasicIo::beg);        /* COMMENT_20 */\n                                    IptcData::printStructure(VAR_0,VAR_37,(size_t)VAR_13,VAR_3);\n                                    delete[] VAR_37;                        /* COMMENT_27 */\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_11 == 0x927c /* COMMENT_28 */ && VAR_13 > 10)\n                                {\n                                    size_t   VAR_25 = VAR_4.tell();  /* COMMENT_17 */\n\n                                    long VAR_38= 10           ;\n                                    byte     VAR_37[20]          ;\n                                    const char* VAR_39 = (const char*) &VAR_37[0] ;\n                                    VAR_4.seek(VAR_2, BasicIo::beg);  /* COMMENT_18 */\n                                    VAR_4.read(VAR_37,VAR_38    )     ;  /* COMMENT_19 */\n                                    VAR_37[VAR_38]=0               ;\n                                    if ( ::strcmp(\"Nikon\",VAR_39) == 0 )\n                                    {\n                                      /* COMMENT_29 */\n                                      std::vector<byte> VAR_40(VAR_13 - VAR_38);\n\n                                      VAR_4.read(&VAR_40.at(0), (long)VAR_40.size());\n                                      MemIo VAR_41(&VAR_40.at(0), (long)VAR_13 - VAR_38); /* COMMENT_30 */\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      /* COMMENT_31 */\n                                      /* COMMENT_32 */\n                                    }\n                                    else\n                                    {\n                                        /* COMMENT_33 */\n                                        VAR_4.seek(0, BasicIo::beg);  /* COMMENT_18 */\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(VAR_0,VAR_1,VAR_22,VAR_3);\n                                    }\n\n                                    VAR_4.seek(VAR_25,BasicIo::beg); /* COMMENT_20 */\n                                }\n                            }\n                        }\n\n                        const uint64_t VAR_42 = readData(VAR_14);\n\n                        VAR_2 = VAR_9 ? 0 : VAR_42;\n                        VAR_0.flush();\n                    } while (VAR_2 != 0);\n\n                    if ( VAR_6 )\n                        VAR_0 << Internal::indent(VAR_3) << \"END \" << VAR_4.path() << std::endl;\n\n                    VAR_3--;\n                }",
  "func_graph_path_before": "Exiv2/exiv2/b3199a072073ac6292e5bbbd5cce2167f1932ea8/bigtiffimage.cpp/vul/before/0.json",
  "func": "void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(dir_offset, BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF BIGTIFF FILE \") << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \"entries = \" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \"\" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(offset, BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n                                const std::string offsetString = usePointer?\n                                    Internal::stringFormat(\"%10u\", offset):\n                                    \"\";\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |%10s | \",\n                                        address, tag, tagName(tag).c_str(), typeName(type), count, offsetString.c_str());\n\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \"/\" << b;\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(buf, (size_t) kount);\n\n                                sp = kount == count ? \"\" : \" ...\";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    const size_t restore = io.tell();      // save\n                                    io.seek(offset, BasicIo::beg);         // position\n                                    byte* bytes=new byte[(size_t)count] ;  // allocate memory\n                                    io.read(bytes,(long)count)        ;    // read\n                                    io.seek(restore, BasicIo::beg);        // restore\n                                    IptcData::printStructure(out,bytes,(size_t)count,depth);\n                                    delete[] bytes;                        // free\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(dir_offset, BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\"Nikon\",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(count - jump);\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n\n                    depth--;\n                }",
  "abstract_func": "void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)\n                {\n                    BasicIo& VAR_4 = Image::io();\n\n                    VAR_3++;\n                    bool VAR_5  = true;\n\n                    /* COMMENT_0 */\n                    bool VAR_6 = true;\n\n                    do\n                    {\n                        /* COMMENT_1 */\n                        VAR_4.seek(VAR_2, BasicIo::beg);\n\n                        const uint64_t VAR_7 = readData(VAR_8.format() == Header::StandardTiff? 2: 8);\n                        const bool VAR_9 = VAR_7 > 500;\n\n                        if ( VAR_5 && VAR_6 )\n                        {\n                            VAR_0 << Internal::indent(VAR_3) << Internal::stringFormat(\"STRUCTURE OF BIGTIFF FILE \") << VAR_4.path() << std::endl;\n                            if (VAR_9)\n                                VAR_0 << Internal::indent(VAR_3) << \"entries = \" << VAR_7 << std::endl;\n                        }\n\n                        if (VAR_9)\n                            break;\n\n                        /* COMMENT_2 */\n                        for ( uint64_t VAR_10 = 0; VAR_10 < VAR_7; VAR_10 ++ )\n                        {\n                            if ( VAR_5 && VAR_6 )\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            VAR_5 = false;\n\n                            const uint16_t VAR_11   = (uint16_t) readData(2);\n                            const uint16_t VAR_12  = (uint16_t) readData(2);\n                            const uint64_t VAR_13 = readData(VAR_14);\n                            const DataBuf  VAR_15  = VAR_4.read(VAR_14);        /* COMMENT_3 */\n\n                            std::string VAR_16 = \"\" ; /* COMMENT_4 */\n\n                            /* COMMENT_5 */\n                            /* COMMENT_6 */\n                            const uint64_t VAR_17  = isStringType(VAR_12)? (VAR_13 > 32 ? 32 : VAR_13) /* COMMENT_7 */\n                                                            : VAR_13 > 5              ? 5\n                                                            : VAR_13\n                                                            ;\n                            const uint32_t VAR_18    = isStringType(VAR_12) ? 1 : 0;\n                            const uint32_t VAR_19   = isStringType(VAR_12) ? 1\n                                                  : is2ByteType(VAR_12)  ? 2\n                                                  : is4ByteType(VAR_12)  ? 4\n                                                  : is8ByteType(VAR_12)  ? 8\n                                                  : 1;\n\n                            /* COMMENT_8 */\n\n                            /* COMMENT_9 */\n                            /* COMMENT_10 */\n                            /* COMMENT_11 */\n                            /* COMMENT_12 */\n                            if (VAR_13 != 0) {\n                                if (VAR_19 > std::numeric_limits<uint64_t>::max() / VAR_13) {\n                                    throw Error(VAR_20);             /* COMMENT_13 */\n                                }\n                            }\n                                                             /* COMMENT_14 */\n\n                            if (VAR_19 * VAR_13 > std::numeric_limits<uint64_t>::max() - VAR_18)\n                                throw Error(VAR_20);             /* COMMENT_15 */\n\n                            const uint64_t VAR_21 = VAR_19*VAR_13 + VAR_18;\n                            if ( VAR_21 > VAR_4.size() ) {\n                                throw Error(VAR_20);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t VAR_22 = VAR_8.format() == Header::StandardTiff?\n                                    byteSwap4(VAR_15, 0, VAR_23):\n                                    byteSwap8(VAR_15, 0, VAR_23);\n\n                            /* COMMENT_16 */\n                            const bool VAR_24 = (size_t) VAR_13*VAR_19 > (size_t) VAR_14;\n\n                            if ( VAR_24 )                          /* COMMENT_17 */\n                            {\n                                size_t   VAR_25 = VAR_4.tell();          /* COMMENT_18 */\n                                VAR_4.seek(VAR_22, BasicIo::beg);         /* COMMENT_19 */\n                                VAR_4.read(VAR_26.pData_, (long) VAR_13 * VAR_19);     /* COMMENT_20 */\n                                VAR_4.seek(VAR_25, BasicIo::beg);        /* COMMENT_21 */\n                            }\n                            else  /* COMMENT_22 */\n                                std::memcpy(VAR_26.pData_, VAR_15.pData_, (size_t) VAR_13 * VAR_19);     /* COMMENT_23 */\n\n                            if ( VAR_6 )\n                            {\n                                const uint64_t VAR_27 = VAR_8.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t VAR_28 = VAR_2 + 2 + VAR_10 * VAR_27;\n                                const std::string VAR_29 = VAR_24?\n                                    Internal::stringFormat(\"%10u\", VAR_22):\n                                    \"\";\n\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |%10s | \",\n                                        VAR_28, VAR_11, tagName(VAR_11).c_str(), typeName(VAR_12), VAR_13, VAR_29.c_str());\n\n                                if ( isShortType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_16 << byteSwap2(VAR_26, VAR_30*VAR_19, VAR_23);\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isLongType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_16 << byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_16 << byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23);\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(VAR_12) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_17 ; VAR_30++ )\n                                    {\n                                        uint32_t VAR_31 = byteSwap4(VAR_26, VAR_30*VAR_19+0, VAR_23);\n                                        uint32_t VAR_32 = byteSwap4(VAR_26, VAR_30*VAR_19+4, VAR_23);\n                                        VAR_0 << VAR_16 << VAR_31 << \"/\" << VAR_32;\n                                        VAR_16 = \" \";\n                                    }\n                                }\n                                else if ( isStringType(VAR_12) )\n                                    VAR_0 << VAR_16 << Internal::binaryToString(VAR_26, (size_t) VAR_17);\n\n                                VAR_16 = VAR_17 == VAR_13 ? \"\" : \" ...\";\n                                VAR_0 << VAR_16 << std::endl;\n\n                                if ( VAR_1 == VAR_33 &&\n                                        (VAR_11 == 0x8769 /* COMMENT_24 */ || VAR_11 == 0x014a/* COMMENT_25 */ || VAR_12 == VAR_34 || VAR_12 == VAR_35) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_13 ; VAR_30++ )\n                                    {\n                                        const size_t VAR_25 = VAR_4.tell();\n                                        const uint64_t VAR_36 = VAR_12 == VAR_35?\n                                            byteSwap8(VAR_26, VAR_30*VAR_19, VAR_23):\n                                            byteSwap4(VAR_26, VAR_30*VAR_19, VAR_23);\n\n                                        printIFD(VAR_0, VAR_1, VAR_36, VAR_3);\n                                        VAR_4.seek(VAR_25, BasicIo::beg);\n                                    }\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_11 == 0x83bb /* COMMENT_26 */ )\n                                {\n                                    const size_t VAR_25 = VAR_4.tell();      /* COMMENT_18 */\n                                    VAR_4.seek(VAR_22, BasicIo::beg);         /* COMMENT_19 */\n                                    byte* VAR_37=new byte[(size_t)VAR_13] ;  /* COMMENT_27 */\n                                    VAR_4.read(VAR_37,(long)VAR_13)        ;    /* COMMENT_20 */\n                                    VAR_4.seek(VAR_25, BasicIo::beg);        /* COMMENT_21 */\n                                    IptcData::printStructure(VAR_0,VAR_37,(size_t)VAR_13,VAR_3);\n                                    delete[] VAR_37;                        /* COMMENT_28 */\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_11 == 0x927c /* COMMENT_29 */ && VAR_13 > 10)\n                                {\n                                    size_t   VAR_25 = VAR_4.tell();  /* COMMENT_18 */\n\n                                    long VAR_38= 10           ;\n                                    byte     VAR_37[20]          ;\n                                    const char* VAR_39 = (const char*) &VAR_37[0] ;\n                                    VAR_4.seek(VAR_2, BasicIo::beg);  /* COMMENT_19 */\n                                    VAR_4.read(VAR_37,VAR_38    )     ;  /* COMMENT_20 */\n                                    VAR_37[VAR_38]=0               ;\n                                    if ( ::strcmp(\"Nikon\",VAR_39) == 0 )\n                                    {\n                                      /* COMMENT_30 */\n                                      std::vector<byte> VAR_40(VAR_13 - VAR_38);\n\n                                      VAR_4.read(&VAR_40.at(0), (long)VAR_40.size());\n                                      MemIo VAR_41(&VAR_40.at(0), (long)VAR_13 - VAR_38); /* COMMENT_31 */\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      /* COMMENT_32 */\n                                      /* COMMENT_33 */\n                                    }\n                                    else\n                                    {\n                                        /* COMMENT_34 */\n                                        VAR_4.seek(0, BasicIo::beg);  /* COMMENT_19 */\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(VAR_0,VAR_1,VAR_22,VAR_3);\n                                    }\n\n                                    VAR_4.seek(VAR_25,BasicIo::beg); /* COMMENT_21 */\n                                }\n                            }\n                        }\n\n                        const uint64_t VAR_42 = readData(VAR_14);\n\n                        VAR_2 = VAR_9 ? 0 : VAR_42;\n                        VAR_0.flush();\n                    } while (VAR_2 != 0);\n\n                    if ( VAR_6 )\n                        VAR_0 << Internal::indent(VAR_3) << \"END \" << VAR_4.path() << std::endl;\n\n                    VAR_3--;\n                }",
  "func_graph_path": "Exiv2/exiv2/b3199a072073ac6292e5bbbd5cce2167f1932ea8/bigtiffimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -61,8 +61,12 @@\n                             // size * count > std::numeric_limits<uint64_t>::max()\n                             // =>\n                             // size > std::numeric_limits<uint64_t>::max() / count\n-                            if (size > std::numeric_limits<uint64_t>::max() / count)\n-                                throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n+                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n+                            if (count != 0) {\n+                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n+                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n+                                }\n+                            }\n                                                              // more than we can handle\n \n                             if (size * count > std::numeric_limits<uint64_t>::max() - pad)",
  "diff_line_info": {
    "deleted_lines": [
      "                            if (size > std::numeric_limits<uint64_t>::max() / count)",
      "                                throw Error(kerInvalidMalloc);             // we got number bigger than 2^64"
    ],
    "added_lines": [
      "                            // (don't perform that check when count == 0 => will cause a division by zero exception)",
      "                            if (count != 0) {",
      "                                if (size > std::numeric_limits<uint64_t>::max() / count) {",
      "                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64",
      "                                }",
      "                            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/180",
  "description": {
    "pr_info": {
      "title": "Disable printStructure() 2nd try",
      "number": 180
    },
    "comment": [
      "Re-submission of #165.\r\n\r\nThe testsuite should fail now due to the missing output of `printStructure()` & #134 popped up again.\r\n\r\nWe should also consider either removing `printStructure` or marking it deprecated, so that downstream code does not use it.",
      "You mentioned that the test failure is expected. What is the plan then ? Do we need to adjust the test suite ?",
      "Yes, we need to do that as the output of exiv2 is changed quite substantially by the removal of `printStructure`.\r\n\r\nHowever, as the new python test suite will also require a rewrite of the test output files, we can consider merging this in a broken state and only adapt the python test suite (and abandon the old one). However, before we do that #134 must be fixed again in this patch & the python test suite should be ready.",
      "Now that the Python test suite is merged, we should start working on this. I am afraid that the first step would be to port all regression tests from the old suite to the new one, then remove `printStructure` and then adapt the new test suite (which will be a ton easier than with the old one). And of course fix #134 along the way.",
      "I just checked the Travis log and there are further issues. The reproducers for #134, #138, #140 result in the following warning: `*** Error in '/home/travis/build/Exiv2/exiv2/build/bin/exiv2': free(): corrupted unsorted chunks: 0xsome_hex_number ***`. That might the result of a segfault or something even worse (like a subtle heap corruption).",
      "Gentlemen:\r\n\r\nI know what's the matter here.  Half a line of code!  In tiffimage.cpp#199 readMetadata(), I haven't allocated sufficient memory for the ICC profile.  The code:\r\n```\r\n            iccProfile_.alloc(pos->count());\r\n```\r\nshould be:\r\n```\r\n            iccProfile_.alloc(pos->count()*pos->typeSize());\r\n```\r\nI attach a patch which contains the removal of calls to printStructure() for several image types.  [printStructureFixes.txt](https://github.com/Exiv2/exiv2/files/1643286/printStructureFixes.txt)\r\n\r\nWhen you apply this patch, you will get lots of changes to the output of the test suite.  However it should run without crashes or exceptions.  To fix the test suite:\r\n\r\n$ make bugfixes\r\n$ cp test/tmp/bugfixes-test.out test/data/\r\n\r\nAnd submit that the modified test/data/bugfixes-test.out",
      "I have pushed your changes Robin.\r\n\r\nHowever I don't think we should update the old test suite any more. It will only further increase the size of the repository (which is already very large).",
      "Thanks for your work on the test harness and printStructure().  If you're happy that the new test harness embodies the functionality of test/bugfixes-test.sh then I'm happy to remove it.\r\n\r\nMy understand (from a conversation between you and Luis) is that the binary file test/data/bugfixes-test.out is the culprit. There's another big file: exiv2-bug922a.jpg  Is it possible to kill those files and all references so they are no longer in the depot?\r\n\r\nA few years ago, Daniel (Kaneider) complained about some EPS and VIDEO test files, so I put them into a different depot and only download them when required.  It possible to download a subpart of the depot with git, or do you always have to copy the whole she-bang?  We could put those files on the buildserver and pull them down with curl or something.",
      "Yes, the large binary files are the problem. However removing them will not actually solve the problem of the repository size, as the files will be still present in the repos history (they must be present so that you can checkout commits from the past). So not touching them is actually the best approach ;-) (We can of course remove them via `git rm`).\r\n\r\nWe were already discussing whether we should move the binary files to another repository running git lfs, but I think we deferred the idea.",
      "Hi guys. I see this PR referenced in few issues and the one that will solve many of them. Can we make a realistic plan to translate the old tests to use the new python framework so that we can finally merge this?",
      "Oh ... I just saw #250 . I think this is what we need to solve to finally merge this PR, right ? ",
      "Yes, that is correct. However to get this merged, we only need to get the tests from `bugfixes-test.sh` ported, the other ones are \"nice to have\" and can be done at some point in the future.",
      "ey @D4N , what do you think about the following approach:\r\n\r\n1. Disable the run of the old bash tests temporarily (`bugfixes-test.sh`)\r\n2. Merge this PR\r\n3. Port the tests from the old suite to the new suite progressively\r\n\r\nIn that way we could get fix many of the bug-reports that are being reported around this piece of code. I discussed this briefly with @clanmills and he also agreed. ",
      "I don't think that's a good idea, as then there will be even less incentive/motivation to port the test suite, since this PR is then gone. Currently it reminds us that we should take care of it.",
      "You're right, we will lose motivation to do it. For the moment I have created a new label, so that we can mark all the issues related with the `printStructure` function until we finish this work. ",
      "I strongly feel we should do this without further delay.  I feel very upset every time I see a bug related to printStructure().  Sure, I'm to blame.  The punishment of seeing these issue reports is painful.\r\n\r\nI have test/bugfixes-test.sh in the discussion document for May.  http://dev.exiv2.org/news/3\r\n\r\nI believe we can pull bugfixes-test.sh v0.26 from SVN on demand.  So we don't need to port everything in bugfixes-test.sh to the new test suite.  After we've discussed this, I'll undertake the tasks we agree to complete bugfixes-test for v0.27.",
      "# [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/180?src=pr&el=h1) Report\n> Merging [#180](https://codecov.io/gh/Exiv2/exiv2/pull/180?src=pr&el=desc) into [master](https://codecov.io/gh/Exiv2/exiv2/commit/3d558be1aa109e177a236431d01a96e9693805a5?src=pr&el=desc) will **increase** coverage by `0.35%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/Exiv2/exiv2/pull/180/graphs/tree.svg?width=650&token=O9G7Iswx26&height=150&src=pr)](https://codecov.io/gh/Exiv2/exiv2/pull/180?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master     #180      +/-   ##\n==========================================\n+ Coverage   62.02%   62.37%   +0.35%     \n==========================================\n  Files         149      149              \n  Lines       20456    20534      +78     \n==========================================\n+ Hits        12687    12808     +121     \n+ Misses       7769     7726      -43\n```\n\n\n| [Impacted Files](https://codecov.io/gh/Exiv2/exiv2/pull/180?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [src/cr2image.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL2NyMmltYWdlLmNwcA==) | `13.04% <ø> (+0.36%)` | :arrow_up: |\n| [src/orfimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL29yZmltYWdlLmNwcA==) | `47.29% <ø> (+9.13%)` | :arrow_up: |\n| [src/rw2image.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL3J3MmltYWdlLmNwcA==) | `47.5% <ø> (+1.15%)` | :arrow_up: |\n| [include/exiv2/types.hpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-aW5jbHVkZS9leGl2Mi90eXBlcy5ocHA=) | `96.42% <100%> (ø)` | :arrow_up: |\n| [src/crwimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL2Nyd2ltYWdlLmNwcA==) | `49.27% <100%> (-1.43%)` | :arrow_down: |\n| [src/tiffimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL3RpZmZpbWFnZS5jcHA=) | `87.85% <100%> (-0.23%)` | :arrow_down: |\n| [src/bigtiffimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL2JpZ3RpZmZpbWFnZS5jcHA=) | `48.63% <100%> (+33.87%)` | :arrow_up: |\n| [src/canonmn\\_int.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL2Nhbm9ubW5faW50LmNwcA==) | `88.3% <0%> (-4.93%)` | :arrow_down: |\n| [src/orfimage\\_int.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL29yZmltYWdlX2ludC5jcHA=) | `53.84% <0%> (-2.16%)` | :arrow_down: |\n| [src/jpgimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree#diff-c3JjL2pwZ2ltYWdlLmNwcA==) | `88.54% <0%> (-1.22%)` | :arrow_down: |\n| ... and [28 more](https://codecov.io/gh/Exiv2/exiv2/pull/180/diff?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/180?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/180?src=pr&el=footer). Last update [3d558be...ffa39aa](https://codecov.io/gh/Exiv2/exiv2/pull/180?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n",
      "Ok folks, this is going to be a lot more work. I have removed everything that uses the infamous `printIFD` and it costs us a lot: the options `-pS`, `-pR`, `-pX`, `-pC` and `-PI` are gone.\r\n\r\nUnfortunately, **a lot** of the old tests were using these options and the test suite is now **really, really** broken. The following scripts are the culprit specifically:\r\n- icc-test.sh\r\n- tiff-test.sh (this one should be removed, it is already ported to the Python test suite)\r\n- webp-test.sh\r\n\r\nI would appreciate any ideas how we should proceed.",
      "My thoughts were to remove the 'devnull' code from the image handlers and leave everything else in place.\r\n```\r\n857 rmills@rmillsmbp:~/gnu/github/exiv2/exiv2/src $ grep devnull *.cpp\r\ncr2image.cpp:        std::ofstream devnull;\r\ncr2image.cpp:        printStructure(devnull, kpsRecursive, 0);\r\ncrwimage.cpp:            std::ofstream devnull;\r\ncrwimage.cpp:            printStructure(devnull,kpsRecursive,0);\r\norfimage.cpp:        std::ofstream devnull;\r\norfimage.cpp:        printStructure(devnull, kpsRecursive, 0);\r\nrw2image.cpp:        std::ofstream devnull;\r\nrw2image.cpp:        printStructure(devnull, kpsRecursive, 0);\r\ntiffimage.cpp:        std::ofstream devnull;\r\ntiffimage.cpp:        printStructure(devnull,kpsRecursive);\r\n858 rmills@rmillsmbp:~/gnu/github/exiv2/exiv2/src $ \r\n```\r\nWith all the POC files in the test suite, I see no reason to remove lots of useful code that implements -pR, -pI and other options that you mention.  In particular, -pR is very useful indeed for debugging files.\r\n\r\nThe misery of git, printStructure() and bugfixes.sh has been very frustrating.  Stuff is broken and I can't do anything about it.  I hugely appreciate the work that you and Luis have put into Exiv2.  We'll find a way forward.  ",
      "I also don't like to remove useful functionality, but the problem is, that just removing the few function calls that you listed still makes `printIFDStructure` accessible via the `printStructure` functions which are accessible from client code (either via libexiv2 or the exiv2 binary). So our users could still call the vulnerable code.\r\n\r\nI think we should be able to reimplement `-pX`, `-pC` and `-PI` without `printStructure`. However, not in this pull request. It is already becoming too large to review.",
      "I'd like us to remove the devnull code.  That's a very positive move forward.  Re-implementing -pR, -pX and other features can be future projects.",
      "Very well, I am going to drop the commits removing `printStructure` completely and make a new branch for that, so that we can proceed forward.",
      "Are you upset?  We can talk on Skype if you like.",
      "No, I am not. I agree that removing printStructure completely is too much for now. Let's get the CI green and this thing merged."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.85"
}