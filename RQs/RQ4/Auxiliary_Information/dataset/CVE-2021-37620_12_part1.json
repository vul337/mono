{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/utils.cpp",
  "func_name": "dirname",
  "func_before": "std::string dirname(const std::string& path)\n    {\n        if (path == \"\") return \".\";\n        // Strip trailing slashes or backslashes\n        std::string p = path;\n        while (   p.length() > 1\n               && (p[p.length()-1] == '\\\\' || p[p.length()-1] == '/')) {\n            p = p.substr(0, p.length()-1);\n        }\n        if (p == \"\\\\\" || p == \"/\") return p;\n        if (p.length() == 2 && p[1] == ':') return p; // For Windows paths\n        std::string::size_type idx = p.find_last_of(\"\\\\/\");\n        if (idx == std::string::npos) return \".\";\n        if (idx == 1 && p[0] == '\\\\' && p[1] == '\\\\') return p; // For Windows paths\n        p = p.substr(0, idx == 0 ? 1 : idx);\n        while (   p.length() > 1\n               && (p[p.length()-1] == '\\\\' || p[p.length()-1] == '/')) {\n            p = p.substr(0, p.length()-1);\n        }\n        return p;\n    }",
  "abstract_func_before": "std::string dirname(const std::string& VAR_0)\n    {\n        if (VAR_0 == \"\") return \".\";\n        /* COMMENT_0 */\n        std::string VAR_1 = VAR_0;\n        while (   VAR_1.length() > 1\n               && (VAR_1[VAR_1.length()-1] == '\\\\' || VAR_1[VAR_1.length()-1] == '/')) {\n            VAR_1 = VAR_1.substr(0, VAR_1.length()-1);\n        }\n        if (VAR_1 == \"\\\\\" || VAR_1 == \"/\") return VAR_1;\n        if (VAR_1.length() == 2 && VAR_1[1] == ':') return VAR_1; /* COMMENT_1 */\n        std::string::size_type VAR_2 = VAR_1.find_last_of(\"\\\\/\");\n        if (VAR_2 == std::string::npos) return \".\";\n        if (VAR_2 == 1 && VAR_1[0] == '\\\\' && VAR_1[1] == '\\\\') return VAR_1; /* COMMENT_1 */\n        VAR_1 = VAR_1.substr(0, VAR_2 == 0 ? 1 : VAR_2);\n        while (   VAR_1.length() > 1\n               && (VAR_1[VAR_1.length()-1] == '\\\\' || VAR_1[VAR_1.length()-1] == '/')) {\n            VAR_1 = VAR_1.substr(0, VAR_1.length()-1);\n        }\n        return VAR_1;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/utils.cpp/vul/before/0.json",
  "func": "std::string dirname(const std::string& path)\n    {\n        if (path == \"\") return \".\";\n        // Strip trailing slashes or backslashes\n        std::string p = path;\n        while (   p.length() > 1\n               && (p[p.length()-1] == '\\\\' || p[p.length()-1] == '/')) {\n            p = p.substr(0, p.length()-1);\n        }\n        if (p == \"\\\\\" || p == \"/\") return p;\n        if (p.length() == 2 && p[1] == ':') return p; // For Windows paths\n        std::string::size_type idx = p.find_last_of(\"\\\\/\");\n        if (idx == std::string::npos) return \".\";\n        if (idx == 1 && p.at(0) == '\\\\' && p.at(1) == '\\\\') return p; // For Windows paths\n        p = p.substr(0, idx == 0 ? 1 : idx);\n        while (   p.length() > 1\n               && (p[p.length()-1] == '\\\\' || p[p.length()-1] == '/')) {\n            p = p.substr(0, p.length()-1);\n        }\n        return p;\n    }",
  "abstract_func": "std::string dirname(const std::string& VAR_0)\n    {\n        if (VAR_0 == \"\") return \".\";\n        /* COMMENT_0 */\n        std::string VAR_1 = VAR_0;\n        while (   VAR_1.length() > 1\n               && (VAR_1[VAR_1.length()-1] == '\\\\' || VAR_1[VAR_1.length()-1] == '/')) {\n            VAR_1 = VAR_1.substr(0, VAR_1.length()-1);\n        }\n        if (VAR_1 == \"\\\\\" || VAR_1 == \"/\") return VAR_1;\n        if (VAR_1.length() == 2 && VAR_1[1] == ':') return VAR_1; /* COMMENT_1 */\n        std::string::size_type VAR_2 = VAR_1.find_last_of(\"\\\\/\");\n        if (VAR_2 == std::string::npos) return \".\";\n        if (VAR_2 == 1 && VAR_1.at(0) == '\\\\' && VAR_1.at(1) == '\\\\') return VAR_1; /* COMMENT_1 */\n        VAR_1 = VAR_1.substr(0, VAR_2 == 0 ? 1 : VAR_2);\n        while (   VAR_1.length() > 1\n               && (VAR_1[VAR_1.length()-1] == '\\\\' || VAR_1[VAR_1.length()-1] == '/')) {\n            VAR_1 = VAR_1.substr(0, VAR_1.length()-1);\n        }\n        return VAR_1;\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/utils.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n         if (p.length() == 2 && p[1] == ':') return p; // For Windows paths\n         std::string::size_type idx = p.find_last_of(\"\\\\/\");\n         if (idx == std::string::npos) return \".\";\n-        if (idx == 1 && p[0] == '\\\\' && p[1] == '\\\\') return p; // For Windows paths\n+        if (idx == 1 && p.at(0) == '\\\\' && p.at(1) == '\\\\') return p; // For Windows paths\n         p = p.substr(0, idx == 0 ? 1 : idx);\n         while (   p.length() > 1\n                && (p[p.length()-1] == '\\\\' || p[p.length()-1] == '/')) {",
  "diff_line_info": {
    "deleted_lines": [
      "        if (idx == 1 && p[0] == '\\\\' && p[1] == '\\\\') return p; // For Windows paths"
    ],
    "added_lines": [
      "        if (idx == 1 && p.at(0) == '\\\\' && p.at(1) == '\\\\') return p; // For Windows paths"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sridharb1/exiv2/pull/4: 403 Client Error: Forbidden for url: https://api.github.com/repos/sridharb1/exiv2/pulls/4",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8\n\nThe patch modifies string indexing to prevent out-of-bounds errors, which aligns with the commit message's focus on safety and suggests a security fix. The code change is consistent with the description, and while the vulnerability description mentions file paths, the fix addresses a potential security flaw in string access."
}