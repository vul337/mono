{
  "cve_id": "CVE-2018-16149",
  "cwe_ids": [
    "CWE-347"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "igrr/axtls-8266",
  "commit_msg": "Apply CVE fixes for X509 parsing\n\nApply patches developed by Sze Yiu which correct a vulnerability in\nX509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",
  "commit_hash": "5efe2947ab45e81d84b5f707c51d1c64be52f36c",
  "git_url": "https://github.com/igrr/axtls-8266/commit/5efe2947ab45e81d84b5f707c51d1c64be52f36c",
  "file_path": "ssl/x509.c",
  "func_name": "sig_verify",
  "func_before": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; /* start at the first possible non-padded byte */\n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    /* get only the bit we want */\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
  "abstract_func_before": "static bigint *sig_verify(BI_CTX *VAR_0, const uint8_t *VAR_1, int VAR_2,\n        bigint *VAR_3, bigint *VAR_4)\n{\n    int VAR_5, VAR_6;\n    bigint *VAR_7, *VAR_8;\n    bigint *VAR_9 = NULL;\n    uint8_t *VAR_10 = (uint8_t *)malloc(VAR_2);\n\n    /* COMMENT_0 */\n    VAR_8 = bi_import(VAR_0, VAR_1, VAR_2);\n    VAR_0->mod_offset = VAR_11;\n\n    /* COMMENT_1 */\n    VAR_7 = bi_mod_power2(VAR_0, VAR_8, VAR_3, VAR_4);\n\n    bi_export(VAR_0, VAR_7, VAR_10, VAR_2);\n    VAR_0->mod_offset = VAR_11;\n\n    VAR_5 = 10; /* COMMENT_2 */\n    while (VAR_10[VAR_5++] && VAR_5 < VAR_2);\n    VAR_6 = VAR_2 - VAR_5;\n\n    /* COMMENT_3 */\n    if (VAR_6 > 0)\n    {\n        int VAR_12;\n        const uint8_t *VAR_13 = get_signature(&VAR_10[VAR_5], &VAR_12);\n\n        if (VAR_13)\n        {\n            VAR_9 = bi_import(VAR_0, VAR_13, VAR_12);\n        }\n    }\n    free(VAR_10);\n    /* COMMENT_4 */\n    bi_clear_cache(VAR_0);\n    return VAR_9;\n}",
  "func_graph_path_before": "igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/before/1.json",
  "func": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    const uint8_t *sig_prefix = NULL;\n    uint8_t sig_prefix_size = 0, hash_len = 0;\n    /* adjust our expections */\n    switch (sig_type)\n    {\n        case SIG_TYPE_MD5:\n            sig_prefix = sig_prefix_md5;\n            sig_prefix_size = sizeof(sig_prefix_md5);\n        break;\n        case SIG_TYPE_SHA1:\n            sig_prefix = sig_prefix_sha1;\n            sig_prefix_size = sizeof(sig_prefix_sha1);\n        break;\n        case SIG_TYPE_SHA256:\n            sig_prefix = sig_prefix_sha256;\n            sig_prefix_size = sizeof(sig_prefix_sha256);\n        break;\n        case SIG_TYPE_SHA384:\n            sig_prefix = sig_prefix_sha384;\n            sig_prefix_size = sizeof(sig_prefix_sha384);\n        break;\n        case SIG_TYPE_SHA512:\n            sig_prefix = sig_prefix_sha512;\n            sig_prefix_size = sizeof(sig_prefix_sha512);\n        break;\n    }\n    if (sig_prefix)\n        hash_len = sig_prefix[sig_prefix_size - 1];\n\n    /* check length (#A) */\n    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)\n        goto err;\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* check the first 2 bytes */\n    if (block[0] != 0 || block[1] != 1)\n        goto err;\n\n    /* check the padding */\n    i = 2; /* start at the first padding byte */\n    while (i < sig_len - 1 - sig_prefix_size - hash_len)\n    { /* together with (#A), we require at least 8 bytes of padding */\n        if (block[i++] != 0xFF)\n            goto err;\n    }\n\n    /* check end of padding */\n    if (block[i++] != 0)\n        goto err;\n\n    /* check the ASN.1 metadata */\n    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))\n        goto err;\n\n    /* now we can get the hash we need */\n    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);\n\nerr:\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
  "abstract_func": "static bigint *sig_verify(BI_CTX *VAR_0, const uint8_t *VAR_1, int VAR_2, uint8_t VAR_3,\n        bigint *VAR_4, bigint *VAR_5)\n{\n    int VAR_6;\n    bigint *VAR_7, *VAR_8;\n    bigint *VAR_9 = NULL;\n    uint8_t *VAR_10 = (uint8_t *)malloc(VAR_2);\n\n    const uint8_t *VAR_11 = NULL;\n    uint8_t VAR_12 = 0, VAR_13 = 0;\n    /* COMMENT_0 */\n    switch (VAR_3)\n    {\n        case VAR_14:\n            VAR_11 = VAR_15;\n            VAR_12 = sizeof(VAR_15);\n        break;\n        case VAR_16:\n            VAR_11 = VAR_17;\n            VAR_12 = sizeof(VAR_17);\n        break;\n        case VAR_18:\n            VAR_11 = VAR_19;\n            VAR_12 = sizeof(VAR_19);\n        break;\n        case VAR_20:\n            VAR_11 = VAR_21;\n            VAR_12 = sizeof(VAR_21);\n        break;\n        case VAR_22:\n            VAR_11 = VAR_23;\n            VAR_12 = sizeof(VAR_23);\n        break;\n    }\n    if (VAR_11)\n        VAR_13 = VAR_11[VAR_12 - 1];\n\n    /* COMMENT_1 */\n    if (VAR_2 < 2 + 8 + 1 + VAR_12 + VAR_13)\n        goto err;\n\n    /* COMMENT_2 */\n    VAR_8 = bi_import(VAR_0, VAR_1, VAR_2);\n    VAR_0->mod_offset = VAR_24;\n\n    /* COMMENT_3 */\n    VAR_7 = bi_mod_power2(VAR_0, VAR_8, VAR_4, VAR_5);\n\n    bi_export(VAR_0, VAR_7, VAR_10, VAR_2);\n    VAR_0->mod_offset = VAR_24;\n\n    /* COMMENT_4 */\n    if (VAR_10[0] != 0 || VAR_10[1] != 1)\n        goto err;\n\n    /* COMMENT_5 */\n    VAR_6 = 2; /* COMMENT_6 */\n    while (VAR_6 < VAR_2 - 1 - VAR_12 - VAR_13)\n    { /* COMMENT_7 */\n        if (VAR_10[VAR_6++] != 0xFF)\n            goto err;\n    }\n\n    /* COMMENT_8 */\n    if (VAR_10[VAR_6++] != 0)\n        goto err;\n\n    /* COMMENT_9 */\n    if (memcmp_P(VAR_10+VAR_6, VAR_11, VAR_12))\n        goto err;\n\n    /* COMMENT_10 */\n    VAR_9 = bi_import(VAR_0, VAR_10 + VAR_6 + VAR_12, VAR_13);\n\nerr:\n    free(VAR_10);\n    /* COMMENT_11 */\n    bi_clear_cache(VAR_0);\n    return VAR_9;\n}",
  "func_graph_path": "igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,43 @@\n-static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n+static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,\n         bigint *modulus, bigint *pub_exp)\n {\n-    int i, size;\n+    int i;\n     bigint *decrypted_bi, *dat_bi;\n     bigint *bir = NULL;\n     uint8_t *block = (uint8_t *)malloc(sig_len);\n+\n+    const uint8_t *sig_prefix = NULL;\n+    uint8_t sig_prefix_size = 0, hash_len = 0;\n+    /* adjust our expections */\n+    switch (sig_type)\n+    {\n+        case SIG_TYPE_MD5:\n+            sig_prefix = sig_prefix_md5;\n+            sig_prefix_size = sizeof(sig_prefix_md5);\n+        break;\n+        case SIG_TYPE_SHA1:\n+            sig_prefix = sig_prefix_sha1;\n+            sig_prefix_size = sizeof(sig_prefix_sha1);\n+        break;\n+        case SIG_TYPE_SHA256:\n+            sig_prefix = sig_prefix_sha256;\n+            sig_prefix_size = sizeof(sig_prefix_sha256);\n+        break;\n+        case SIG_TYPE_SHA384:\n+            sig_prefix = sig_prefix_sha384;\n+            sig_prefix_size = sizeof(sig_prefix_sha384);\n+        break;\n+        case SIG_TYPE_SHA512:\n+            sig_prefix = sig_prefix_sha512;\n+            sig_prefix_size = sizeof(sig_prefix_sha512);\n+        break;\n+    }\n+    if (sig_prefix)\n+        hash_len = sig_prefix[sig_prefix_size - 1];\n+\n+    /* check length (#A) */\n+    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)\n+        goto err;\n \n     /* decrypt */\n     dat_bi = bi_import(ctx, sig, sig_len);\n@@ -16,21 +49,30 @@\n     bi_export(ctx, decrypted_bi, block, sig_len);\n     ctx->mod_offset = BIGINT_M_OFFSET;\n \n-    i = 10; /* start at the first possible non-padded byte */\n-    while (block[i++] && i < sig_len);\n-    size = sig_len - i;\n+    /* check the first 2 bytes */\n+    if (block[0] != 0 || block[1] != 1)\n+        goto err;\n \n-    /* get only the bit we want */\n-    if (size > 0)\n-    {\n-        int len;\n-        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n+    /* check the padding */\n+    i = 2; /* start at the first padding byte */\n+    while (i < sig_len - 1 - sig_prefix_size - hash_len)\n+    { /* together with (#A), we require at least 8 bytes of padding */\n+        if (block[i++] != 0xFF)\n+            goto err;\n+    }\n \n-        if (sig_ptr)\n-        {\n-            bir = bi_import(ctx, sig_ptr, len);\n-        }\n-    }\n+    /* check end of padding */\n+    if (block[i++] != 0)\n+        goto err;\n+\n+    /* check the ASN.1 metadata */\n+    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))\n+        goto err;\n+\n+    /* now we can get the hash we need */\n+    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);\n+\n+err:\n     free(block);\n     /* save a few bytes of memory */\n     bi_clear_cache(ctx);",
  "diff_line_info": {
    "deleted_lines": [
      "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,",
      "    int i, size;",
      "    i = 10; /* start at the first possible non-padded byte */",
      "    while (block[i++] && i < sig_len);",
      "    size = sig_len - i;",
      "    /* get only the bit we want */",
      "    if (size > 0)",
      "    {",
      "        int len;",
      "        const uint8_t *sig_ptr = get_signature(&block[i], &len);",
      "        if (sig_ptr)",
      "        {",
      "            bir = bi_import(ctx, sig_ptr, len);",
      "        }",
      "    }"
    ],
    "added_lines": [
      "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,",
      "    int i;",
      "",
      "    const uint8_t *sig_prefix = NULL;",
      "    uint8_t sig_prefix_size = 0, hash_len = 0;",
      "    /* adjust our expections */",
      "    switch (sig_type)",
      "    {",
      "        case SIG_TYPE_MD5:",
      "            sig_prefix = sig_prefix_md5;",
      "            sig_prefix_size = sizeof(sig_prefix_md5);",
      "        break;",
      "        case SIG_TYPE_SHA1:",
      "            sig_prefix = sig_prefix_sha1;",
      "            sig_prefix_size = sizeof(sig_prefix_sha1);",
      "        break;",
      "        case SIG_TYPE_SHA256:",
      "            sig_prefix = sig_prefix_sha256;",
      "            sig_prefix_size = sizeof(sig_prefix_sha256);",
      "        break;",
      "        case SIG_TYPE_SHA384:",
      "            sig_prefix = sig_prefix_sha384;",
      "            sig_prefix_size = sizeof(sig_prefix_sha384);",
      "        break;",
      "        case SIG_TYPE_SHA512:",
      "            sig_prefix = sig_prefix_sha512;",
      "            sig_prefix_size = sizeof(sig_prefix_sha512);",
      "        break;",
      "    }",
      "    if (sig_prefix)",
      "        hash_len = sig_prefix[sig_prefix_size - 1];",
      "",
      "    /* check length (#A) */",
      "    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)",
      "        goto err;",
      "    /* check the first 2 bytes */",
      "    if (block[0] != 0 || block[1] != 1)",
      "        goto err;",
      "    /* check the padding */",
      "    i = 2; /* start at the first padding byte */",
      "    while (i < sig_len - 1 - sig_prefix_size - hash_len)",
      "    { /* together with (#A), we require at least 8 bytes of padding */",
      "        if (block[i++] != 0xFF)",
      "            goto err;",
      "    }",
      "    /* check end of padding */",
      "    if (block[i++] != 0)",
      "        goto err;",
      "",
      "    /* check the ASN.1 metadata */",
      "    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))",
      "        goto err;",
      "",
      "    /* now we can get the hash we need */",
      "    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);",
      "",
      "err:"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/igrr/axtls-8266/pull/60",
  "description": {
    "pr_info": {
      "title": "Apply CVE fixes for X509 parsing",
      "number": 60
    },
    "comment": [
      "Apply patches developed by Sze Yiu which correct a vulnerability in\r\nX509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",
      "Yay, more CVEs this week! Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Step-by-Step Explanation and Answer:**\n\n1. **Commit Message Analysis:** The commit message clearly states applying CVE fixes, specifically for X509 parsing, referencing two CVEs. This strongly indicates a security fix.\n\n2. **Code Diff Review:** The code changes involve adding checks for signature types, adjusting parsing logic, and increasing validation steps. These are typical measures to address parsing vulnerabilities, enhancing security.\n\n3. **Consistency Check:** The changes align with the stated purpose of fixing vulnerabilities related to X509 parsing.\n\n4. **Security Fix Confirmation:** The modifications target known security issues by improving input validation and structure checks, consistent with a vulnerability fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95 (High confidence due to clear CVE references and security-related code changes.)"
}