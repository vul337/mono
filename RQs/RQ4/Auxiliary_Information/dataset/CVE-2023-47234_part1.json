{
  "cve_id": "CVE-2023-47234",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Ignore handling NLRIs if we received MP_UNREACH_NLRI\n\nIf we receive MP_UNREACH_NLRI, we should stop handling remaining NLRIs if\nno mandatory path attributes received.\n\nIn other words, if MP_UNREACH_NLRI received, the remaining NLRIs should be handled\nas a new data, but without mandatory attributes, it's a malformed packet.\n\nIn normal case, this MUST not happen at all, but to avoid crashing bgpd, we MUST\nhandle that.\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",
  "commit_hash": "c37119df45bbf4ef713bc10475af2ee06e12f3bf",
  "git_url": "https://github.com/FRRouting/frr/commit/c37119df45bbf4ef713bc10475af2ee06e12f3bf",
  "file_path": "bgpd/bgp_packet.c",
  "func_name": "bgp_update_receive",
  "func_before": "static int bgp_update_receive(struct peer_connection *connection,\n\t\t\t      struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(connection)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(connection, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len && attribute_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(connection))\n\t\t\t\tbgp_notify_send(connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif (!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}",
  "abstract_func_before": "static int bgp_update_receive(struct peer_connection *VAR_0,\n\t\t\t      struct peer *peer, bgp_size_t VAR_1)\n{\n\tint VAR_2, VAR_3;\n\tuint8_t *VAR_4;\n\tstruct stream *VAR_5;\n\tstruct attr attr;\n\tbgp_size_t VAR_6;\n\tbgp_size_t VAR_7;\n\tbgp_size_t VAR_8;\n\tbool VAR_9 = false;\n\n\tenum NLRI_TYPES {\n\t\tVAR_10,\n\t\tVAR_11,\n\t\tVAR_12,\n\t\tVAR_13,\n\t\tVAR_14\n\t};\n\tstruct bgp_nlri VAR_15[VAR_14];\n\n\t/* COMMENT_0 */\n\tif (!peer_established(VAR_0)) {\n\t\tflog_err(VAR_16,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(VAR_17, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(VAR_0, VAR_18,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_1 */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = VAR_20;\n\tattr.label = VAR_21;\n\tmemset(&VAR_15, 0, sizeof(VAR_15));\n\tmemset(peer->rcvd_attr_str, 0, VAR_22);\n\tpeer->rcvd_attr_printed = 0;\n\n\tVAR_5 = peer->curr;\n\tVAR_4 = stream_pnt(VAR_5) + VAR_1;\n\n\t/* COMMENT_2 */\n                                                                  \n                                                                     \n                                                   \n\tif (stream_pnt(VAR_5) + 2 > VAR_4) {\n\t\tflog_err(VAR_23,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(VAR_0, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_8 = stream_getw(VAR_5);\n\n\t/* COMMENT_7 */\n\tif (stream_pnt(VAR_5) + VAR_8 > VAR_4) {\n\t\tflog_err(VAR_23,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, VAR_8);\n\t\tbgp_notify_send(VAR_0, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_8 */\n\tif (VAR_8 > 0) {\n\t\tVAR_15[VAR_11].afi = VAR_26;\n\t\tVAR_15[VAR_11].safi = VAR_27;\n\t\tVAR_15[VAR_11].nlri = stream_pnt(VAR_5);\n\t\tVAR_15[VAR_11].length = VAR_8;\n\t\tstream_forward_getp(VAR_5, VAR_8);\n\t}\n\n\t/* COMMENT_9 */\n\tif (stream_pnt(VAR_5) + 2 > VAR_4) {\n\t\tflog_warn(\n\t\t\tVAR_28,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer->connection, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_10 */\n\tVAR_6 = stream_getw(VAR_5);\n\n\t/* COMMENT_11 */\n\tif (stream_pnt(VAR_5) + VAR_6 > VAR_4) {\n\t\tflog_warn(\n\t\t\tVAR_29,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, VAR_6);\n\t\tbgp_notify_send(VAR_0, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_12 */\n                                                                    \n                                                                       \n                                                        \n   \n                                          \n    \n\tenum bgp_attr_parse_ret VAR_30 = VAR_31;\n/* COMMENT_19 */\n                                                        \n   \n#define VAR_32 (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* COMMENT_22 */\n\tif (VAR_6) {\n\t\tVAR_30 = bgp_attr_parse(peer, &attr, VAR_6,\n\t\t\t\t\t\t&VAR_15[VAR_12],\n\t\t\t\t\t\t&VAR_15[VAR_13]);\n\t\tif (VAR_30 == VAR_33) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_19;\n\t\t}\n\t}\n\n\t/* COMMENT_23 */\n\tif (VAR_30 == VAR_34\n\t    || BGP_DEBUG(VAR_35, VAR_36)\n\t    || BGP_DEBUG(VAR_35, VAR_37)) {\n\t\tVAR_2 = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (VAR_30 == VAR_34)\n\t\t\tflog_err(\n\t\t\t\tVAR_23,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (VAR_2 && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* COMMENT_24 */\n\tVAR_7 = VAR_4 - stream_pnt(VAR_5);\n\n\tif (VAR_7 && VAR_6) {\n\t\t/* COMMENT_25 */\n\t\tVAR_15[VAR_10].afi = VAR_26;\n\t\tVAR_15[VAR_10].safi = VAR_27;\n\t\tVAR_15[VAR_10].nlri = stream_pnt(VAR_5);\n\t\tVAR_15[VAR_10].length = VAR_7;\n\t\tstream_forward_getp(VAR_5, VAR_7);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(VAR_38))) {\n\t\t\t/* COMMENT_26 */\n                                                        \n                               \n      \n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn VAR_19;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(VAR_35, VAR_36))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   VAR_8, VAR_6, VAR_7);\n\n\t/* COMMENT_30 */\n\tfor (int VAR_39 = VAR_10; VAR_39 < VAR_14; VAR_39++) {\n\t\tif (!VAR_15[VAR_39].nlri)\n\t\t\tcontinue;\n\n\t\t/* COMMENT_31 */\n                \n\t\tif (!peer->afc[VAR_15[VAR_39].afi][VAR_15[VAR_39].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, VAR_15[VAR_39].afi, VAR_15[VAR_39].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* COMMENT_33 */\n\t\tif (VAR_15[VAR_39].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (VAR_39) {\n\t\tcase VAR_10:\n\t\tcase VAR_12:\n\t\t\tVAR_3 = bgp_nlri_parse(peer, VAR_32,\n\t\t\t\t\t\t  &VAR_15[VAR_39], 0);\n\t\t\tbreak;\n\t\tcase VAR_11:\n\t\tcase VAR_13:\n\t\t\tVAR_3 = bgp_nlri_parse(peer, VAR_32,\n\t\t\t\t\t\t  &VAR_15[VAR_39], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_3 = VAR_40;\n\t\t}\n\n\t\tif (VAR_3 < VAR_41\n\t\t    && VAR_3 != VAR_42) {\n\t\t\tflog_err(VAR_23,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(VAR_0))\n\t\t\t\tbgp_notify_send(VAR_0,\n\t\t\t\t\t\tVAR_24,\n\t\t\t\t\t\tVAR_39 <= VAR_11\n\t\t\t\t\t\t\t? VAR_43\n\t\t\t\t\t\t\t: VAR_44);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_19;\n\t\t}\n\t}\n\n\t/* COMMENT_34 */\n   \n                                                        \n                                                   \n    \n\tif (!VAR_7 && !VAR_8 && VAR_15[VAR_12].length == 0) {\n\t\tafi_t VAR_45 = 0;\n\t\tsafi_t VAR_46;\n\t\tstruct graceful_restart_info *VAR_47;\n\n\t\t/* COMMENT_39 */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\tVAR_9 = true;\n\n\t\t/* COMMENT_40 */\n            \n                                            \n     \n\t\tif (!VAR_6) {\n\t\t\tVAR_45 = VAR_26;\n\t\t\tVAR_46 = VAR_27;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(VAR_48)\n\t\t\t   && VAR_15[VAR_13].length == 0) {\n\t\t\tVAR_45 = VAR_15[VAR_13].afi;\n\t\t\tVAR_46 = VAR_15[VAR_13].safi;\n\t\t}\n\n\t\tif (VAR_45 && peer->afc[VAR_45][VAR_46]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* COMMENT_44 */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[VAR_45][VAR_46],\n\t\t\t\t\tVAR_49)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[VAR_45][VAR_46],\n\t\t\t\t\t VAR_49);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* COMMENT_45 */\n\t\t\t\tVAR_47 = &(peer->bgp->gr_info[VAR_45][VAR_46]);\n\t\t\t\tif (VAR_9)\n\t\t\t\t\tVAR_47->eor_received++;\n\t\t\t\t/* COMMENT_46 */\n                                                  \n                                           \n       \n\t\t\t\tif (VAR_47->eor_required\n\t\t\t\t    == VAR_47->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tVAR_47->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tVAR_47->eor_received);\n\t\t\t\t\tif (VAR_47->t_select_deferral) {\n\t\t\t\t\t\tvoid *VAR_50 = EVENT_ARG(\n\t\t\t\t\t\t\tVAR_47->t_select_deferral);\n\t\t\t\t\t\tXFREE(VAR_51, VAR_50);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(VAR_47->t_select_deferral);\n\t\t\t\t\tVAR_47->eor_required = 0;\n\t\t\t\t\tVAR_47->eor_received = 0;\n\t\t\t\t\t/* COMMENT_50 */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   VAR_45, VAR_46);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_51 */\n\t\t\tif (peer->nsf[VAR_45][VAR_46])\n\t\t\t\tbgp_clear_stale_route(peer, VAR_45, VAR_46);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\tVAR_52, get_afi_safi_str(VAR_45, VAR_46, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VAR_53);\n\t\t}\n\t}\n\n\t/* COMMENT_52 */\n                                    \n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* COMMENT_54 */\n\tpeer->advmap_table_change = true;\n\n\treturn VAR_54;\n}",
  "func_graph_path_before": "FRRouting/frr/c37119df45bbf4ef713bc10475af2ee06e12f3bf/bgp_packet.c/vul/before/0.json",
  "func": "static int bgp_update_receive(struct peer_connection *connection,\n\t\t\t      struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(connection)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(connection, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\t/* If we received MP_UNREACH_NLRI attribute, but also NLRIs, then\n\t * NLRIs should be handled as a new data. Though, if we received\n\t * NLRIs without mandatory attributes, they should be ignored.\n\t */\n\tif (update_len && attribute_len &&\n\t    attr_parse_ret != BGP_ATTR_PARSE_MISSING_MANDATORY) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(connection))\n\t\t\t\tbgp_notify_send(connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif (!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}",
  "abstract_func": "static int bgp_update_receive(struct peer_connection *VAR_0,\n\t\t\t      struct peer *peer, bgp_size_t VAR_1)\n{\n\tint VAR_2, VAR_3;\n\tuint8_t *VAR_4;\n\tstruct stream *VAR_5;\n\tstruct attr attr;\n\tbgp_size_t VAR_6;\n\tbgp_size_t VAR_7;\n\tbgp_size_t VAR_8;\n\tbool VAR_9 = false;\n\n\tenum NLRI_TYPES {\n\t\tVAR_10,\n\t\tVAR_11,\n\t\tVAR_12,\n\t\tVAR_13,\n\t\tVAR_14\n\t};\n\tstruct bgp_nlri VAR_15[VAR_14];\n\n\t/* COMMENT_0 */\n\tif (!peer_established(VAR_0)) {\n\t\tflog_err(VAR_16,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(VAR_17, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(VAR_0, VAR_18,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_1 */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = VAR_20;\n\tattr.label = VAR_21;\n\tmemset(&VAR_15, 0, sizeof(VAR_15));\n\tmemset(peer->rcvd_attr_str, 0, VAR_22);\n\tpeer->rcvd_attr_printed = 0;\n\n\tVAR_5 = peer->curr;\n\tVAR_4 = stream_pnt(VAR_5) + VAR_1;\n\n\t/* COMMENT_2 */\n                                                                  \n                                                                     \n                                                   \n\tif (stream_pnt(VAR_5) + 2 > VAR_4) {\n\t\tflog_err(VAR_23,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(VAR_0, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_8 = stream_getw(VAR_5);\n\n\t/* COMMENT_7 */\n\tif (stream_pnt(VAR_5) + VAR_8 > VAR_4) {\n\t\tflog_err(VAR_23,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, VAR_8);\n\t\tbgp_notify_send(VAR_0, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_8 */\n\tif (VAR_8 > 0) {\n\t\tVAR_15[VAR_11].afi = VAR_26;\n\t\tVAR_15[VAR_11].safi = VAR_27;\n\t\tVAR_15[VAR_11].nlri = stream_pnt(VAR_5);\n\t\tVAR_15[VAR_11].length = VAR_8;\n\t\tstream_forward_getp(VAR_5, VAR_8);\n\t}\n\n\t/* COMMENT_9 */\n\tif (stream_pnt(VAR_5) + 2 > VAR_4) {\n\t\tflog_warn(\n\t\t\tVAR_28,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer->connection, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_10 */\n\tVAR_6 = stream_getw(VAR_5);\n\n\t/* COMMENT_11 */\n\tif (stream_pnt(VAR_5) + VAR_6 > VAR_4) {\n\t\tflog_warn(\n\t\t\tVAR_29,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, VAR_6);\n\t\tbgp_notify_send(VAR_0, VAR_24,\n\t\t\t\tVAR_25);\n\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_12 */\n                                                                    \n                                                                       \n                                                        \n   \n                                          \n    \n\tenum bgp_attr_parse_ret VAR_30 = VAR_31;\n/* COMMENT_19 */\n                                                        \n   \n#define VAR_32 (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* COMMENT_22 */\n\tif (VAR_6) {\n\t\tVAR_30 = bgp_attr_parse(peer, &attr, VAR_6,\n\t\t\t\t\t\t&VAR_15[VAR_12],\n\t\t\t\t\t\t&VAR_15[VAR_13]);\n\t\tif (VAR_30 == VAR_33) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_19;\n\t\t}\n\t}\n\n\t/* COMMENT_23 */\n\tif (VAR_30 == VAR_34\n\t    || BGP_DEBUG(VAR_35, VAR_36)\n\t    || BGP_DEBUG(VAR_35, VAR_37)) {\n\t\tVAR_2 = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (VAR_30 == VAR_34)\n\t\t\tflog_err(\n\t\t\t\tVAR_23,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (VAR_2 && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* COMMENT_24 */\n\tVAR_7 = VAR_4 - stream_pnt(VAR_5);\n\n\t/* COMMENT_25 */\n                                                                 \n                                                               \n    \n\tif (VAR_7 && VAR_6 &&\n\t    VAR_30 != VAR_38) {\n\t\t/* COMMENT_29 */\n\t\tVAR_15[VAR_10].afi = VAR_26;\n\t\tVAR_15[VAR_10].safi = VAR_27;\n\t\tVAR_15[VAR_10].nlri = stream_pnt(VAR_5);\n\t\tVAR_15[VAR_10].length = VAR_7;\n\t\tstream_forward_getp(VAR_5, VAR_7);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(VAR_39))) {\n\t\t\t/* COMMENT_30 */\n                                                        \n                               \n      \n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn VAR_19;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(VAR_35, VAR_36))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   VAR_8, VAR_6, VAR_7);\n\n\t/* COMMENT_34 */\n\tfor (int VAR_40 = VAR_10; VAR_40 < VAR_14; VAR_40++) {\n\t\tif (!VAR_15[VAR_40].nlri)\n\t\t\tcontinue;\n\n\t\t/* COMMENT_35 */\n                \n\t\tif (!peer->afc[VAR_15[VAR_40].afi][VAR_15[VAR_40].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, VAR_15[VAR_40].afi, VAR_15[VAR_40].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* COMMENT_37 */\n\t\tif (VAR_15[VAR_40].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (VAR_40) {\n\t\tcase VAR_10:\n\t\tcase VAR_12:\n\t\t\tVAR_3 = bgp_nlri_parse(peer, VAR_32,\n\t\t\t\t\t\t  &VAR_15[VAR_40], 0);\n\t\t\tbreak;\n\t\tcase VAR_11:\n\t\tcase VAR_13:\n\t\t\tVAR_3 = bgp_nlri_parse(peer, VAR_32,\n\t\t\t\t\t\t  &VAR_15[VAR_40], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_3 = VAR_41;\n\t\t}\n\n\t\tif (VAR_3 < VAR_42\n\t\t    && VAR_3 != VAR_43) {\n\t\t\tflog_err(VAR_23,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(VAR_0))\n\t\t\t\tbgp_notify_send(VAR_0,\n\t\t\t\t\t\tVAR_24,\n\t\t\t\t\t\tVAR_40 <= VAR_11\n\t\t\t\t\t\t\t? VAR_44\n\t\t\t\t\t\t\t: VAR_45);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_19;\n\t\t}\n\t}\n\n\t/* COMMENT_38 */\n   \n                                                        \n                                                   \n    \n\tif (!VAR_7 && !VAR_8 && VAR_15[VAR_12].length == 0) {\n\t\tafi_t VAR_46 = 0;\n\t\tsafi_t VAR_47;\n\t\tstruct graceful_restart_info *VAR_48;\n\n\t\t/* COMMENT_43 */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\tVAR_9 = true;\n\n\t\t/* COMMENT_44 */\n            \n                                            \n     \n\t\tif (!VAR_6) {\n\t\t\tVAR_46 = VAR_26;\n\t\t\tVAR_47 = VAR_27;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(VAR_49)\n\t\t\t   && VAR_15[VAR_13].length == 0) {\n\t\t\tVAR_46 = VAR_15[VAR_13].afi;\n\t\t\tVAR_47 = VAR_15[VAR_13].safi;\n\t\t}\n\n\t\tif (VAR_46 && peer->afc[VAR_46][VAR_47]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* COMMENT_48 */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[VAR_46][VAR_47],\n\t\t\t\t\tVAR_50)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[VAR_46][VAR_47],\n\t\t\t\t\t VAR_50);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* COMMENT_49 */\n\t\t\t\tVAR_48 = &(peer->bgp->gr_info[VAR_46][VAR_47]);\n\t\t\t\tif (VAR_9)\n\t\t\t\t\tVAR_48->eor_received++;\n\t\t\t\t/* COMMENT_50 */\n                                                  \n                                           \n       \n\t\t\t\tif (VAR_48->eor_required\n\t\t\t\t    == VAR_48->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tVAR_48->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tVAR_48->eor_received);\n\t\t\t\t\tif (VAR_48->t_select_deferral) {\n\t\t\t\t\t\tvoid *VAR_51 = EVENT_ARG(\n\t\t\t\t\t\t\tVAR_48->t_select_deferral);\n\t\t\t\t\t\tXFREE(VAR_52, VAR_51);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(VAR_48->t_select_deferral);\n\t\t\t\t\tVAR_48->eor_required = 0;\n\t\t\t\t\tVAR_48->eor_received = 0;\n\t\t\t\t\t/* COMMENT_54 */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   VAR_46, VAR_47);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_55 */\n\t\t\tif (peer->nsf[VAR_46][VAR_47])\n\t\t\t\tbgp_clear_stale_route(peer, VAR_46, VAR_47);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\tVAR_53, get_afi_safi_str(VAR_46, VAR_47, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VAR_54);\n\t\t}\n\t}\n\n\t/* COMMENT_56 */\n                                    \n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* COMMENT_58 */\n\tpeer->advmap_table_change = true;\n\n\treturn VAR_55;\n}",
  "func_graph_path": "FRRouting/frr/c37119df45bbf4ef713bc10475af2ee06e12f3bf/bgp_packet.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -151,7 +151,12 @@\n \t/* Network Layer Reachability Information. */\n \tupdate_len = end - stream_pnt(s);\n \n-\tif (update_len && attribute_len) {\n+\t/* If we received MP_UNREACH_NLRI attribute, but also NLRIs, then\n+\t * NLRIs should be handled as a new data. Though, if we received\n+\t * NLRIs without mandatory attributes, they should be ignored.\n+\t */\n+\tif (update_len && attribute_len &&\n+\t    attr_parse_ret != BGP_ATTR_PARSE_MISSING_MANDATORY) {\n \t\t/* Set NLRI portion to structure. */\n \t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n \t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (update_len && attribute_len) {"
    ],
    "added_lines": [
      "\t/* If we received MP_UNREACH_NLRI attribute, but also NLRIs, then",
      "\t * NLRIs should be handled as a new data. Though, if we received",
      "\t * NLRIs without mandatory attributes, they should be ignored.",
      "\t */",
      "\tif (update_len && attribute_len &&",
      "\t    attr_parse_ret != BGP_ATTR_PARSE_MISSING_MANDATORY) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/14716",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/FRRouting/frr/pull/14716: 403 Client Error: Forbidden for url: https://api.github.com/repos/FRRouting/frr/pulls/14716",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis**: The commit message and vulnerability description suggest handling a malformed packet to prevent a crash. The code diff modifies the attribute parsing condition to skip NLRIs when mandatory attributes are missing.\n\n2. **Purpose Evaluation**: The change prevents processing of malformed data, avoiding a potential crash—indicative of a security fix.\n\n3. **Security Assessment**: The fix addresses handling of malformed packets, preventing a crash which is a security concern.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}