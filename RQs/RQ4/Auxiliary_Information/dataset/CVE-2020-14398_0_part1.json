{
  "cve_id": "CVE-2020-14398",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "libvncclient: handle half-open TCP connections\n\nWhen a connection is not reset properly at the TCP level (e.g. sudden\npower loss or process crash) the TCP connection becomes half-open and\nread() always returns -1 with errno = EAGAIN while select() always\nreturns 0. This leads to an infinite loop and can be fixed by closing\nthe connection after a certain number of retries (based on a timeout)\nhas been exceeded.",
  "commit_hash": "57433015f856cc12753378254ce4f1c78f5d9c7b",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/57433015f856cc12753378254ce4f1c78f5d9c7b",
  "file_path": "libvncclient/vncviewer.c",
  "func_name": "rfbGetClient",
  "func_before": "rfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}",
  "abstract_func_before": "rfbClient* rfbGetClient(int VAR_0,int VAR_1,\n\t\t\tint VAR_2) {\n#ifdef VAR_3\n    WSADATA VAR_4;\n#endif\n  rfbClient* VAR_5=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!VAR_5) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef VAR_3\n  if((VAR_6 = WSAStartup(MAKEWORD(2,0), &VAR_4)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(VAR_6));\n      return NULL;\n  }\n#endif\n  initAppData(&VAR_5->appData);\n  VAR_5->endianTest = 1;\n  VAR_5->programName=\"\";\n  VAR_5->serverHost=strdup(\"\");\n  VAR_5->serverPort=5900;\n\n  VAR_5->destHost = NULL;\n  VAR_5->destPort = 5900;\n  \n  VAR_5->connectTimeout = VAR_7;\n\n  VAR_5->CurrentKeyboardLedState = 0;\n  VAR_5->HandleKeyboardLedState = (HandleKeyboardLedStateProc)VAR_8;\n\n  /* COMMENT_0 */ \n  VAR_5->updateRect.x = -1;\n \n  VAR_5->frameBuffer = NULL;\n  VAR_5->outputWindow = 0;\n \n  VAR_5->format.bitsPerPixel = VAR_2*8;\n  VAR_5->format.depth = VAR_0*VAR_1;\n  VAR_5->appData.requestedDepth=VAR_5->format.depth;\n  VAR_5->format.bigEndian = *(char *)&VAR_5->endianTest?FALSE:TRUE;\n  VAR_5->format.trueColour = 1;\n\n  if (VAR_5->format.bitsPerPixel == 8) {\n    VAR_5->format.redMax = 7;\n    VAR_5->format.greenMax = 7;\n    VAR_5->format.blueMax = 3;\n    VAR_5->format.redShift = 0;\n    VAR_5->format.greenShift = 3;\n    VAR_5->format.blueShift = 6;\n  } else {\n    VAR_5->format.redMax = (1 << VAR_0) - 1;\n    VAR_5->format.greenMax = (1 << VAR_0) - 1;\n    VAR_5->format.blueMax = (1 << VAR_0) - 1;\n    if(!VAR_5->format.bigEndian) {\n      VAR_5->format.redShift = 0;\n      VAR_5->format.greenShift = VAR_0;\n      VAR_5->format.blueShift = VAR_0 * 2;\n    } else {\n      if(VAR_5->format.bitsPerPixel==8*3) {\n\tVAR_5->format.redShift = VAR_0*2;\n\tVAR_5->format.greenShift = VAR_0*1;\n\tVAR_5->format.blueShift = 0;\n      } else {\n\tVAR_5->format.redShift = VAR_0*3;\n\tVAR_5->format.greenShift = VAR_0*2;\n\tVAR_5->format.blueShift = VAR_0;\n      }\n    }\n  }\n\n  VAR_5->bufoutptr=VAR_5->buf;\n  VAR_5->buffered=0;\n\n#ifdef VAR_9\n  VAR_5->raw_buffer_size = -1;\n  VAR_5->decompStreamInited = FALSE;\n\n#ifdef VAR_10\n  memset(VAR_5->zlibStreamActive,0,sizeof(VAR_11)*4);\n#endif\n#endif\n\n  VAR_5->HandleCursorPos = VAR_8;\n  VAR_5->SoftCursorLockArea = VAR_12;\n  VAR_5->SoftCursorUnlockScreen = VAR_13;\n  VAR_5->GotFrameBufferUpdate = VAR_12;\n  VAR_5->GotCopyRect = VAR_14;\n  VAR_5->GotFillRect = VAR_15;\n  VAR_5->GotBitmap = VAR_16;\n  VAR_5->FinishedFrameBufferUpdate = NULL;\n  VAR_5->GetPassword = VAR_17;\n  VAR_5->MallocFrameBuffer = VAR_18;\n  VAR_5->Bell = VAR_13;\n  VAR_5->CurrentKeyboardLedState = 0;\n  VAR_5->HandleKeyboardLedState = (HandleKeyboardLedStateProc)VAR_8;\n  VAR_5->QoS_DSCP = 0;\n\n  VAR_5->authScheme = 0;\n  VAR_5->subAuthScheme = 0;\n  VAR_5->GetCredential = NULL;\n  VAR_5->tlsSession = NULL;\n  VAR_5->LockWriteToTLS = NULL;\n  VAR_5->UnlockWriteToTLS = NULL;\n  VAR_5->sock = VAR_19;\n  VAR_5->listenSock = VAR_19;\n  VAR_5->listenAddress = NULL;\n  VAR_5->listen6Sock = VAR_19;\n  VAR_5->listen6Address = NULL;\n  VAR_5->clientAuthSchemes = NULL;\n\n#ifdef VAR_20\n  VAR_5->GetSASLMechanism = NULL;\n  VAR_5->GetUser = NULL;\n  VAR_5->saslSecret = NULL;\n#endif /* COMMENT_1 */\n\n  return VAR_5;\n}",
  "func_graph_path_before": "LibVNC/libvncserver/57433015f856cc12753378254ce4f1c78f5d9c7b/vncviewer.c/vul/before/0.json",
  "func": "rfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n  client->readTimeout = DEFAULT_READ_TIMEOUT;\n\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}",
  "abstract_func": "rfbClient* rfbGetClient(int VAR_0,int VAR_1,\n\t\t\tint VAR_2) {\n#ifdef VAR_3\n    WSADATA VAR_4;\n#endif\n  rfbClient* VAR_5=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!VAR_5) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef VAR_3\n  if((VAR_6 = WSAStartup(MAKEWORD(2,0), &VAR_4)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(VAR_6));\n      return NULL;\n  }\n#endif\n  initAppData(&VAR_5->appData);\n  VAR_5->endianTest = 1;\n  VAR_5->programName=\"\";\n  VAR_5->serverHost=strdup(\"\");\n  VAR_5->serverPort=5900;\n\n  VAR_5->destHost = NULL;\n  VAR_5->destPort = 5900;\n  \n  VAR_5->connectTimeout = VAR_7;\n  VAR_5->readTimeout = VAR_8;\n\n  VAR_5->CurrentKeyboardLedState = 0;\n  VAR_5->HandleKeyboardLedState = (HandleKeyboardLedStateProc)VAR_9;\n\n  /* COMMENT_0 */ \n  VAR_5->updateRect.x = -1;\n \n  VAR_5->frameBuffer = NULL;\n  VAR_5->outputWindow = 0;\n \n  VAR_5->format.bitsPerPixel = VAR_2*8;\n  VAR_5->format.depth = VAR_0*VAR_1;\n  VAR_5->appData.requestedDepth=VAR_5->format.depth;\n  VAR_5->format.bigEndian = *(char *)&VAR_5->endianTest?FALSE:TRUE;\n  VAR_5->format.trueColour = 1;\n\n  if (VAR_5->format.bitsPerPixel == 8) {\n    VAR_5->format.redMax = 7;\n    VAR_5->format.greenMax = 7;\n    VAR_5->format.blueMax = 3;\n    VAR_5->format.redShift = 0;\n    VAR_5->format.greenShift = 3;\n    VAR_5->format.blueShift = 6;\n  } else {\n    VAR_5->format.redMax = (1 << VAR_0) - 1;\n    VAR_5->format.greenMax = (1 << VAR_0) - 1;\n    VAR_5->format.blueMax = (1 << VAR_0) - 1;\n    if(!VAR_5->format.bigEndian) {\n      VAR_5->format.redShift = 0;\n      VAR_5->format.greenShift = VAR_0;\n      VAR_5->format.blueShift = VAR_0 * 2;\n    } else {\n      if(VAR_5->format.bitsPerPixel==8*3) {\n\tVAR_5->format.redShift = VAR_0*2;\n\tVAR_5->format.greenShift = VAR_0*1;\n\tVAR_5->format.blueShift = 0;\n      } else {\n\tVAR_5->format.redShift = VAR_0*3;\n\tVAR_5->format.greenShift = VAR_0*2;\n\tVAR_5->format.blueShift = VAR_0;\n      }\n    }\n  }\n\n  VAR_5->bufoutptr=VAR_5->buf;\n  VAR_5->buffered=0;\n\n#ifdef VAR_10\n  VAR_5->raw_buffer_size = -1;\n  VAR_5->decompStreamInited = FALSE;\n\n#ifdef VAR_11\n  memset(VAR_5->zlibStreamActive,0,sizeof(VAR_12)*4);\n#endif\n#endif\n\n  VAR_5->HandleCursorPos = VAR_9;\n  VAR_5->SoftCursorLockArea = VAR_13;\n  VAR_5->SoftCursorUnlockScreen = VAR_14;\n  VAR_5->GotFrameBufferUpdate = VAR_13;\n  VAR_5->GotCopyRect = VAR_15;\n  VAR_5->GotFillRect = VAR_16;\n  VAR_5->GotBitmap = VAR_17;\n  VAR_5->FinishedFrameBufferUpdate = NULL;\n  VAR_5->GetPassword = VAR_18;\n  VAR_5->MallocFrameBuffer = VAR_19;\n  VAR_5->Bell = VAR_14;\n  VAR_5->CurrentKeyboardLedState = 0;\n  VAR_5->HandleKeyboardLedState = (HandleKeyboardLedStateProc)VAR_9;\n  VAR_5->QoS_DSCP = 0;\n\n  VAR_5->authScheme = 0;\n  VAR_5->subAuthScheme = 0;\n  VAR_5->GetCredential = NULL;\n  VAR_5->tlsSession = NULL;\n  VAR_5->LockWriteToTLS = NULL;\n  VAR_5->UnlockWriteToTLS = NULL;\n  VAR_5->sock = VAR_20;\n  VAR_5->listenSock = VAR_20;\n  VAR_5->listenAddress = NULL;\n  VAR_5->listen6Sock = VAR_20;\n  VAR_5->listen6Address = NULL;\n  VAR_5->clientAuthSchemes = NULL;\n\n#ifdef VAR_21\n  VAR_5->GetSASLMechanism = NULL;\n  VAR_5->GetUser = NULL;\n  VAR_5->saslSecret = NULL;\n#endif /* COMMENT_1 */\n\n  return VAR_5;\n}",
  "func_graph_path": "LibVNC/libvncserver/57433015f856cc12753378254ce4f1c78f5d9c7b/vncviewer.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,7 @@\n   client->destPort = 5900;\n   \n   client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n+  client->readTimeout = DEFAULT_READ_TIMEOUT;\n \n   client->CurrentKeyboardLedState = 0;\n   client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  client->readTimeout = DEFAULT_READ_TIMEOUT;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/400",
  "description": {
    "pr_info": {
      "title": "libvncclient: handle half-open TCP connections",
      "number": 400
    },
    "comment": [
      "When a connection is not reset properly at the TCP level (e.g. sudden power loss or process crash) the TCP connection becomes half-open and read() always returns -1 with errno = EAGAIN while select() always returns 0. This leads to an infinite loop and can be fixed by closing the connection after a certain number of retries (based on a timeout) has been exceeded.\r\n",
      "(looks like AppVeyor failed because of libpng download error/server timeout and not an actual code issue)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}