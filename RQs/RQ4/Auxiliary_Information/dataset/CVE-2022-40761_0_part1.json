{
  "cve_id": "CVE-2022-40761",
  "cwe_ids": [
    "CWE-1284"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "Samsung/mTower",
  "commit_msg": "Fixed CVE-2022-40761\n\nSigned-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",
  "commit_hash": "c5f30c70e48786e1aef8c815f35e406a6c4fb3ae",
  "git_url": "https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae",
  "file_path": "tee/tee/tee_svc_cryp.c",
  "func_name": "tee_obj_set_type",
  "func_before": "TEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,\n\t\t\t    size_t max_key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\n\t/* Can only set type for newly allocated objs */\n\tif (o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Verify that maxKeySize is supported and find out how\n\t * much should be allocated.\n\t */\n\n\tif (obj_type == TEE_TYPE_DATA) {\n\t\tif (max_key_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t} else {\n\t\t/* Find description of object */\n\t\ttype_props = tee_svc_find_type_props(obj_type);\n\t\tif (!type_props)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\t/* Check that maxKeySize follows restrictions */\n\t\tif (max_key_size % type_props->quanta != 0)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size < type_props->min_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size > type_props->max_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\to->attr = calloc(1, type_props->alloc_size);\n\t\tif (!o->attr)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t/* If we have a key structure, pre-allocate the bignums inside */\n\tswitch (obj_type) {\n//\tcase TEE_TYPE_RSA_PUBLIC_KEY:\n//\t\tres = crypto_acipher_alloc_rsa_public_key(o->attr,\n//\t\t\t\t\t\t\t  max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_RSA_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_DSA_PUBLIC_KEY:\n//\t\tres = crypto_acipher_alloc_dsa_public_key(o->attr,\n//\t\t\t\t\t\t\t  max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_DSA_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_DH_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n//\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n//\t\tres = crypto_acipher_alloc_ecc_public_key(o->attr,\n//\t\t\t\t\t\t\t  max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_ECDSA_KEYPAIR:\n//\tcase TEE_TYPE_ECDH_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_ecc_keypair(o->attr, max_key_size);\n//\t\tbreak;\n\tdefault:\n\t\tif (obj_type != TEE_TYPE_DATA) {\n\t\t\tstruct tee_cryp_obj_secret *key = o->attr;\n\n\t\t\tkey->alloc_size = type_props->alloc_size -\n\t\t\t\t\t  sizeof(*key);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to->info.objectType = obj_type;\n\to->info.maxKeySize = max_key_size;\n\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func_before": "TEE_Result tee_obj_set_type(struct tee_obj *VAR_0, uint32_t VAR_1,\n\t\t\t    size_t VAR_2)\n{\n\tTEE_Result VAR_3 = VAR_4;\n\tconst struct tee_cryp_obj_type_props *VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_0->attr)\n\t\treturn VAR_6;\n\n\t/* COMMENT_1 */\n                                                        \n                             \n    \n\n\tif (VAR_1 == VAR_7) {\n\t\tif (VAR_2)\n\t\t\treturn VAR_8;\n\t} else {\n\t\t/* COMMENT_5 */\n\t\tVAR_5 = tee_svc_find_type_props(VAR_1);\n\t\tif (!VAR_5)\n\t\t\treturn VAR_8;\n\n\t\t/* COMMENT_6 */\n\t\tif (VAR_2 % VAR_5->quanta != 0)\n\t\t\treturn VAR_8;\n\t\tif (VAR_2 < VAR_5->min_size)\n\t\t\treturn VAR_8;\n\t\tif (VAR_2 > VAR_5->max_size)\n\t\t\treturn VAR_8;\n\n\t\tVAR_0->attr = calloc(1, VAR_5->alloc_size);\n\t\tif (!VAR_0->attr)\n\t\t\treturn VAR_9;\n\t}\n\n\t/* COMMENT_7 */\n\tswitch (VAR_1) {\n/* COMMENT_8 */\n/* COMMENT_9 */\n/* COMMENT_10 */\n/* COMMENT_11 */\n/* COMMENT_12 */\n/* COMMENT_13 */\n/* COMMENT_11 */\n/* COMMENT_14 */\n/* COMMENT_15 */\n/* COMMENT_10 */\n/* COMMENT_11 */\n/* COMMENT_16 */\n/* COMMENT_17 */\n/* COMMENT_11 */\n/* COMMENT_18 */\n/* COMMENT_19 */\n/* COMMENT_11 */\n/* COMMENT_20 */\n/* COMMENT_21 */\n/* COMMENT_22 */\n/* COMMENT_10 */\n/* COMMENT_11 */\n/* COMMENT_23 */\n/* COMMENT_24 */\n/* COMMENT_25 */\n/* COMMENT_11 */\n\tdefault:\n\t\tif (VAR_1 != VAR_7) {\n\t\t\tstruct tee_cryp_obj_secret *VAR_10 = VAR_0->attr;\n\n\t\t\tVAR_10->alloc_size = VAR_5->alloc_size -\n\t\t\t\t\t  sizeof(*VAR_10);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (VAR_3 != VAR_4)\n\t\treturn VAR_3;\n\n\tVAR_0->info.objectType = VAR_1;\n\tVAR_0->info.maxKeySize = VAR_2;\n\tVAR_0->info.objectUsage = VAR_11;\n\n\treturn VAR_4;\n}",
  "func_graph_path_before": "Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/before/0.json",
  "func": "TEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,\n\t\t\t    size_t max_key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\n\t/* Can only set type for newly allocated objs */\n\tif (o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Verify that maxKeySize is supported and find out how\n\t * much should be allocated.\n\t */\n\n\tif (obj_type == TEE_TYPE_DATA) {\n\t\tif (max_key_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t} else {\n\t\t/* Find description of object */\n\t\ttype_props = tee_svc_find_type_props(obj_type);\n\t\tif (!type_props)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\t/* Check that maxKeySize follows restrictions */\n\t\tif (max_key_size % type_props->quanta != 0)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size < type_props->min_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\tif (max_key_size > type_props->max_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\to->attr = TEE_Malloc(type_props->alloc_size, TEE_MALLOC_FILL_ZERO);\n\t\t// o->attr = calloc(1, type_props->alloc_size);\n\t\tif (!o->attr)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t/* If we have a key structure, pre-allocate the bignums inside */\n\tswitch (obj_type) {\n//\tcase TEE_TYPE_RSA_PUBLIC_KEY:\n//\t\tres = crypto_acipher_alloc_rsa_public_key(o->attr,\n//\t\t\t\t\t\t\t  max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_RSA_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_DSA_PUBLIC_KEY:\n//\t\tres = crypto_acipher_alloc_dsa_public_key(o->attr,\n//\t\t\t\t\t\t\t  max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_DSA_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_DH_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n//\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n//\t\tres = crypto_acipher_alloc_ecc_public_key(o->attr,\n//\t\t\t\t\t\t\t  max_key_size);\n//\t\tbreak;\n//\tcase TEE_TYPE_ECDSA_KEYPAIR:\n//\tcase TEE_TYPE_ECDH_KEYPAIR:\n//\t\tres = crypto_acipher_alloc_ecc_keypair(o->attr, max_key_size);\n//\t\tbreak;\n\tdefault:\n\t\tif (obj_type != TEE_TYPE_DATA) {\n\t\t\tstruct tee_cryp_obj_secret *key = o->attr;\n\n\t\t\tkey->alloc_size = type_props->alloc_size -\n\t\t\t\t\t  sizeof(*key);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to->info.objectType = obj_type;\n\to->info.maxKeySize = max_key_size;\n\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func": "TEE_Result tee_obj_set_type(struct tee_obj *VAR_0, uint32_t VAR_1,\n\t\t\t    size_t VAR_2)\n{\n\tTEE_Result VAR_3 = VAR_4;\n\tconst struct tee_cryp_obj_type_props *VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_0->attr)\n\t\treturn VAR_6;\n\n\t/* COMMENT_1 */\n                                                        \n                             \n    \n\n\tif (VAR_1 == VAR_7) {\n\t\tif (VAR_2)\n\t\t\treturn VAR_8;\n\t} else {\n\t\t/* COMMENT_5 */\n\t\tVAR_5 = tee_svc_find_type_props(VAR_1);\n\t\tif (!VAR_5)\n\t\t\treturn VAR_8;\n\n\t\t/* COMMENT_6 */\n\t\tif (VAR_2 % VAR_5->quanta != 0)\n\t\t\treturn VAR_8;\n\t\tif (VAR_2 < VAR_5->min_size)\n\t\t\treturn VAR_8;\n\t\tif (VAR_2 > VAR_5->max_size)\n\t\t\treturn VAR_8;\n\n\t\tVAR_0->attr = TEE_Malloc(VAR_5->alloc_size, VAR_9);\n\t\t/* COMMENT_7 */\n\t\tif (!VAR_0->attr)\n\t\t\treturn VAR_10;\n\t}\n\n\t/* COMMENT_8 */\n\tswitch (VAR_1) {\n/* COMMENT_9 */\n/* COMMENT_10 */\n/* COMMENT_11 */\n/* COMMENT_12 */\n/* COMMENT_13 */\n/* COMMENT_14 */\n/* COMMENT_12 */\n/* COMMENT_15 */\n/* COMMENT_16 */\n/* COMMENT_11 */\n/* COMMENT_12 */\n/* COMMENT_17 */\n/* COMMENT_18 */\n/* COMMENT_12 */\n/* COMMENT_19 */\n/* COMMENT_20 */\n/* COMMENT_12 */\n/* COMMENT_21 */\n/* COMMENT_22 */\n/* COMMENT_23 */\n/* COMMENT_11 */\n/* COMMENT_12 */\n/* COMMENT_24 */\n/* COMMENT_25 */\n/* COMMENT_26 */\n/* COMMENT_12 */\n\tdefault:\n\t\tif (VAR_1 != VAR_7) {\n\t\t\tstruct tee_cryp_obj_secret *VAR_11 = VAR_0->attr;\n\n\t\t\tVAR_11->alloc_size = VAR_5->alloc_size -\n\t\t\t\t\t  sizeof(*VAR_11);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (VAR_3 != VAR_4)\n\t\treturn VAR_3;\n\n\tVAR_0->info.objectType = VAR_1;\n\tVAR_0->info.maxKeySize = VAR_2;\n\tVAR_0->info.objectUsage = VAR_12;\n\n\treturn VAR_4;\n}",
  "func_graph_path": "Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,8 @@\n \t\tif (max_key_size > type_props->max_size)\n \t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n \n-\t\to->attr = calloc(1, type_props->alloc_size);\n+\t\to->attr = TEE_Malloc(type_props->alloc_size, TEE_MALLOC_FILL_ZERO);\n+\t\t// o->attr = calloc(1, type_props->alloc_size);\n \t\tif (!o->attr)\n \t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\to->attr = calloc(1, type_props->alloc_size);"
    ],
    "added_lines": [
      "\t\to->attr = TEE_Malloc(type_props->alloc_size, TEE_MALLOC_FILL_ZERO);",
      "\t\t// o->attr = calloc(1, type_props->alloc_size);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Samsung/mTower/pull/88",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Samsung/mTower/pull/88: 403 Client Error: Forbidden for url: https://api.github.com/repos/Samsung/mTower/pulls/88",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}