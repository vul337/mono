{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveStaticFieldRef",
  "func_before": "void *   \nresolveStaticFieldRef(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField)\n{\n\t/* Bit of magic here, the resulting field must be in vmStruct->floatTemp1 in the CLINIT case\n\t * as resolveHelper expects to find it there.\n\t */\n\tJ9RAMStaticFieldRef *ramStaticFieldRef = (J9RAMStaticFieldRef *)&vmStruct->floatTemp1;\n\tvoid *staticAddress;\n\n\tstaticAddress = resolveStaticFieldRefInto(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField, ramStaticFieldRef);\n\t\n\tif (staticAddress != NULL) {\n\t\t/* Check for <clinit> case. */\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT) {\n\t\t\tJ9Class *clazz = J9RAMSTATICFIELDREF_CLASS(ramStaticFieldRef);\n\t\t\tif (clazz->initializeStatus == (UDATA)vmStruct) {\n\t\t\t\treturn (void *) -1;\n\t\t\t}\n\t\t}\n\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n\t}\n\n\treturn staticAddress;\n}",
  "abstract_func_before": "void *   \nresolveStaticFieldRef(J9VMThread *VAR_0, J9Method *VAR_1, J9ConstantPool *VAR_2, UDATA VAR_3, UDATA VAR_4, J9ROMFieldShape **VAR_5)\n{\n\t/* COMMENT_0 */\n                                              \n    \n\tJ9RAMStaticFieldRef *VAR_6 = (J9RAMStaticFieldRef *)&VAR_0->floatTemp1;\n\tvoid *VAR_7;\n\n\tVAR_7 = resolveStaticFieldRefInto(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);\n\t\n\tif (VAR_7 != NULL) {\n\t\t/* COMMENT_3 */\n\t\tif ((VAR_4 & VAR_8) == VAR_8) {\n\t\t\tJ9Class *VAR_9 = J9RAMSTATICFIELDREF_CLASS(VAR_6);\n\t\t\tif (VAR_9->initializeStatus == (UDATA)VAR_0) {\n\t\t\t\treturn (void *) -1;\n\t\t\t}\n\t\t}\n\t\t((J9RAMStaticFieldRef *)&VAR_2[VAR_3])->valueOffset = VAR_6->valueOffset;\n\t\t((J9RAMStaticFieldRef *)&VAR_2[VAR_3])->flagsAndClass = VAR_6->flagsAndClass;\n\t}\n\n\treturn VAR_7;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/8.json",
  "func": "void *   \nresolveStaticFieldRef(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField)\n{\n\t/* Bit of magic here, the resulting field must be in vmStruct->floatTemp1 in the CLINIT case\n\t * as resolveHelper expects to find it there.\n\t */\n\tJ9RAMStaticFieldRef *ramStaticFieldRef = (J9RAMStaticFieldRef *)&vmStruct->floatTemp1;\n\tvoid *staticAddress;\n\n\tstaticAddress = resolveStaticFieldRefInto(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField, ramStaticFieldRef);\n\t\n\tif (staticAddress != NULL) {\n\t\t/* Check for <clinit> case. */\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT) {\n\t\t\tJ9Class *clazz = J9RAMSTATICFIELDREF_CLASS(ramStaticFieldRef);\n\t\t\tif (clazz->initializeStatus == (UDATA)vmStruct) {\n\t\t\t\treturn (void *) -1;\n\t\t\t}\n\t\t}\n\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n\t\t}\n\t}\n\n\treturn staticAddress;\n}",
  "abstract_func": "void *   \nresolveStaticFieldRef(J9VMThread *VAR_0, J9Method *VAR_1, J9ConstantPool *VAR_2, UDATA VAR_3, UDATA VAR_4, J9ROMFieldShape **VAR_5)\n{\n\t/* COMMENT_0 */\n                                              \n    \n\tJ9RAMStaticFieldRef *VAR_6 = (J9RAMStaticFieldRef *)&VAR_0->floatTemp1;\n\tvoid *VAR_7;\n\n\tVAR_7 = resolveStaticFieldRefInto(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6);\n\t\n\tif (VAR_7 != NULL) {\n\t\t/* COMMENT_3 */\n\t\tif ((VAR_4 & VAR_8) == VAR_8) {\n\t\t\tJ9Class *VAR_9 = J9RAMSTATICFIELDREF_CLASS(VAR_6);\n\t\t\tif (VAR_9->initializeStatus == (UDATA)VAR_0) {\n\t\t\t\treturn (void *) -1;\n\t\t\t}\n\t\t}\n\t\tif (J9_ARE_NO_BITS_SET(VAR_4, VAR_10)) {\n\t\t\t((J9RAMStaticFieldRef *)&VAR_2[VAR_3])->valueOffset = VAR_6->valueOffset;\n\t\t\t((J9RAMStaticFieldRef *)&VAR_2[VAR_3])->flagsAndClass = VAR_6->flagsAndClass;\n\t\t}\n\t}\n\n\treturn VAR_7;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/8.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,10 @@\n \t\t\t\treturn (void *) -1;\n \t\t\t}\n \t\t}\n-\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n-\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n+\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n+\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n+\t\t}\n \t}\n \n \treturn staticAddress;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;",
      "\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;"
    ],
    "added_lines": [
      "\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
      "\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;",
      "\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/eclipse-openj9/openj9/pull/12148: 403 Client Error: Forbidden for url: https://api.github.com/repos/eclipse-openj9/openj9/pulls/12148",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "The patch modifies class loading and constant pool interactions, which are security-sensitive. The code adds a condition to prevent unintended updates, suggesting it's a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.8"
}