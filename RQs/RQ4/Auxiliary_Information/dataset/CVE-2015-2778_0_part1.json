{
  "cve_id": "CVE-2015-2778",
  "cwe_ids": [
    "CWE-399"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "quassel",
  "commit_msg": "Improve the message-splitting algorithm for PRIVMSG and CTCP\n\nThis introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.",
  "commit_hash": "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
  "git_url": "https://github.com/quassel/quassel/commit/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
  "file_path": "src/core/coreuserinputhandler.cpp",
  "func_name": "CoreUserInputHandler::handleSay",
  "func_before": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  // server buffer\n\n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}",
  "abstract_func_before": "void CoreUserInputHandler::handleSay(const BufferInfo &VAR_0, const QString &VAR_1)\n{\n    if (VAR_0.bufferName().isEmpty() || !VAR_0.acceptsRegularMessages())\n        return;  /* COMMENT_0 */\n\n    QByteArray VAR_2 = channelEncode(VAR_0.bufferName(), VAR_1);\n#ifdef VAR_3\n    putPrivmsg(serverEncode(VAR_0.bufferName()), VAR_2, network()->cipher(VAR_0.bufferName()));\n#else\n    putPrivmsg(serverEncode(VAR_0.bufferName()), VAR_2);\n#endif\n    emit VAR_4(Message::Plain, VAR_0.type(), VAR_0.bufferName(), VAR_1, network()->myNick(), Message::Self);\n}",
  "func_graph_path_before": "quassel/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8/coreuserinputhandler.cpp/vul/before/0.json",
  "func": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  // server buffer\n\n    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n        return channelEncode(target, message);\n    };\n\n#ifdef HAVE_QCA2\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}",
  "abstract_func": "void CoreUserInputHandler::handleSay(const BufferInfo &VAR_0, const QString &VAR_1)\n{\n    if (VAR_0.bufferName().isEmpty() || !VAR_0.acceptsRegularMessages())\n        return;  /* COMMENT_0 */\n\n    std::function<QByteArray(const QString &, const QString &)> VAR_2 = [this] (const QString &VAR_3, const QString &VAR_4) -> QByteArray {\n        return channelEncode(VAR_3, VAR_4);\n    };\n\n#ifdef VAR_5\n    putPrivmsg(VAR_0.bufferName(), VAR_1, VAR_2, network()->cipher(VAR_0.bufferName()));\n#else\n    putPrivmsg(VAR_0.bufferName(), VAR_1, VAR_2);\n#endif\n    emit VAR_6(Message::Plain, VAR_0.type(), VAR_0.bufferName(), VAR_1, network()->myNick(), Message::Self);\n}",
  "func_graph_path": "quassel/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8/coreuserinputhandler.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,11 +3,14 @@\n     if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n         return;  // server buffer\n \n-    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n+    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n+        return channelEncode(target, message);\n+    };\n+\n #ifdef HAVE_QCA2\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n #else\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n #endif\n     emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);",
      "    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));",
      "    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);"
    ],
    "added_lines": [
      "    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {",
      "        return channelEncode(target, message);",
      "    };",
      "",
      "    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));",
      "    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/quassel/quassel/pull/116",
  "description": {
    "pr_info": {
      "title": "Improve the message-splitting algorithm for PRIVMSG and CTCP",
      "number": 116
    },
    "comment": [
      "This introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9  \n\nThe patch addresses non-security bugs by fixing message splitting issues and preventing application crashes, indicating a defect remediation update. The changes are consistent with the description, and no security terms are mentioned.\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit and vulnerability description focus on message-splitting issues causing display errors and crashes, not on security exploits.\n2. **Consistency Check:** The code modifications align with fixing message handling problems, confirming the described issues.\n3. **Purpose Evaluation:** The changes resolve bugs in message processing, improving core functionality without addressing security.\n4. **Security Assessment:** No security terms or exploits are mentioned; issues are internal application errors.\n5. **Classification:** It's a non-security defect fix, categorized under Defect Remediation & Feature Upgrades.\n\nThe confidence is high (0.9) as the information is clear and the code changes align with the described fixes."
}