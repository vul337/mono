{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received {A,I}XFR, in megabytes\n\nThis prevents memory exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "db8f9152168acf5d548d4f256789eae783e01667",
  "git_url": "https://github.com/PowerDNS/pdns/commit/db8f9152168acf5d548d4f256789eae783e01667",
  "file_path": "pdns/resolver.cc",
  "func_name": "AXFRRetriever::AXFRRetriever",
  "func_before": "AXFRRetriever::AXFRRetriever(const ComboAddress& remote,\n                             const DNSName& domain,\n                             const TSIGTriplet& tt, \n                             const ComboAddress* laddr)\n  : d_tt(tt), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress local;\n  if (laddr != NULL) {\n    local = (ComboAddress) (*laddr);\n  } else {\n    if(remote.sin4.sin_family == AF_INET)\n      local=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      local=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      local=ComboAddress(\"::\");\n  }\n  d_sock = -1;\n  try {\n    d_sock = makeQuerySocket(local, false); // make a TCP socket\n    if (d_sock < 0)\n      throw ResolverException(\"Error creating socket for AXFR request to \"+d_remote.toStringWithPort());\n    d_buf = shared_array<char>(new char[65536]);\n    d_remote = remote; // mostly for error reporting\n    this->connect();\n    d_soacount = 0;\n  \n    vector<uint8_t> packet;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    pw.getHeader()->id = dns_random(0xffff);\n  \n    if(!tt.name.empty()) {\n      if (tt.algo == DNSName(\"hmac-md5\"))\n        d_trc.d_algoName = tt.algo + DNSName(\"sig-alg.reg.int\");\n      else\n        d_trc.d_algoName = tt.algo;\n      d_trc.d_time = time(0);\n      d_trc.d_fudge = 300;\n      d_trc.d_origID=ntohs(pw.getHeader()->id);\n      d_trc.d_eRcode=0;\n      addTSIG(pw, &d_trc, tt.name, tt.secret, \"\", false);\n    }\n  \n    uint16_t replen=htons(packet.size());\n    Utility::iovec iov[2];\n    iov[0].iov_base=reinterpret_cast<char*>(&replen);\n    iov[0].iov_len=2;\n    iov[1].iov_base=packet.data();\n    iov[1].iov_len=packet.size();\n  \n    int ret=Utility::writev(d_sock, iov, 2);\n    if(ret < 0)\n      throw ResolverException(\"Error sending question to \"+d_remote.toStringWithPort()+\": \"+stringerror());\n    if(ret != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+d_remote.toStringWithPort());\n    }\n  \n    int res = waitForData(d_sock, 10, 0);\n    \n    if(!res)\n      throw ResolverException(\"Timeout waiting for answer from \"+d_remote.toStringWithPort()+\" during AXFR\");\n    if(res<0)\n      throw ResolverException(\"Error waiting for answer from \"+d_remote.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(d_sock >= 0)\n      close(d_sock);\n    d_sock = -1;\n    throw;\n  }\n}",
  "abstract_func_before": "AXFRRetriever::AXFRRetriever(const ComboAddress& VAR_0,\n                             const DNSName& VAR_1,\n                             const TSIGTriplet& VAR_2, \n                             const ComboAddress* VAR_3)\n  : d_tt(VAR_2), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress VAR_4;\n  if (VAR_3 != NULL) {\n    VAR_4 = (ComboAddress) (*VAR_3);\n  } else {\n    if(VAR_0.sin4.sin_family == VAR_5)\n      VAR_4=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      VAR_4=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      VAR_4=ComboAddress(\"::\");\n  }\n  VAR_6 = -1;\n  try {\n    VAR_6 = makeQuerySocket(VAR_4, false); /* COMMENT_0 */\n    if (VAR_6 < 0)\n      throw ResolverException(\"Error creating socket for AXFR request to \"+VAR_7.toStringWithPort());\n    VAR_8 = VAR_9<char>(new char[65536]);\n    VAR_7 = VAR_0; /* COMMENT_1 */\n    this->connect();\n    VAR_10 = 0;\n  \n    vector<uint8_t> VAR_11;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    VAR_12.getHeader()->id = dns_random(0xffff);\n  \n    if(!VAR_2.name.empty()) {\n      if (VAR_2.algo == DNSName(\"hmac-md5\"))\n        VAR_13.d_algoName = VAR_2.algo + DNSName(\"sig-alg.reg.int\");\n      else\n        VAR_13.d_algoName = VAR_2.algo;\n      VAR_13.d_time = time(0);\n      VAR_13.d_fudge = 300;\n      VAR_13.d_origID=ntohs(VAR_12.getHeader()->id);\n      VAR_13.d_eRcode=0;\n      addTSIG(VAR_12, &VAR_13, VAR_2.name, VAR_2.secret, \"\", false);\n    }\n  \n    uint16_t VAR_14=htons(packet.size());\n    Utility::iovec VAR_15[2];\n    VAR_15[0].iov_base=VAR_16<char*>(&VAR_14);\n    VAR_15[0].iov_len=2;\n    VAR_15[1].iov_base=packet.data();\n    VAR_15[1].iov_len=packet.size();\n  \n    int VAR_17=Utility::writev(VAR_6, VAR_15, 2);\n    if(VAR_17 < 0)\n      throw ResolverException(\"Error sending question to \"+VAR_7.toStringWithPort()+\": \"+stringerror());\n    if(VAR_17 != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+VAR_7.toStringWithPort());\n    }\n  \n    int VAR_18 = waitForData(VAR_6, 10, 0);\n    \n    if(!VAR_18)\n      throw ResolverException(\"Timeout waiting for answer from \"+VAR_7.toStringWithPort()+\" during AXFR\");\n    if(VAR_18<0)\n      throw ResolverException(\"Error waiting for answer from \"+VAR_7.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(VAR_6 >= 0)\n      close(VAR_6);\n    VAR_6 = -1;\n    throw;\n  }\n}",
  "func_graph_path_before": null,
  "func": "AXFRRetriever::AXFRRetriever(const ComboAddress& remote,\n                             const DNSName& domain,\n                             const TSIGTriplet& tt, \n                             const ComboAddress* laddr,\n                             size_t maxReceivedBytes)\n  : d_tt(tt), d_receivedBytes(0), d_maxReceivedBytes(maxReceivedBytes), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress local;\n  if (laddr != NULL) {\n    local = (ComboAddress) (*laddr);\n  } else {\n    if(remote.sin4.sin_family == AF_INET)\n      local=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      local=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      local=ComboAddress(\"::\");\n  }\n  d_sock = -1;\n  try {\n    d_sock = makeQuerySocket(local, false); // make a TCP socket\n    if (d_sock < 0)\n      throw ResolverException(\"Error creating socket for AXFR request to \"+d_remote.toStringWithPort());\n    d_buf = shared_array<char>(new char[65536]);\n    d_remote = remote; // mostly for error reporting\n    this->connect();\n    d_soacount = 0;\n  \n    vector<uint8_t> packet;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    pw.getHeader()->id = dns_random(0xffff);\n  \n    if(!tt.name.empty()) {\n      if (tt.algo == DNSName(\"hmac-md5\"))\n        d_trc.d_algoName = tt.algo + DNSName(\"sig-alg.reg.int\");\n      else\n        d_trc.d_algoName = tt.algo;\n      d_trc.d_time = time(0);\n      d_trc.d_fudge = 300;\n      d_trc.d_origID=ntohs(pw.getHeader()->id);\n      d_trc.d_eRcode=0;\n      addTSIG(pw, &d_trc, tt.name, tt.secret, \"\", false);\n    }\n  \n    uint16_t replen=htons(packet.size());\n    Utility::iovec iov[2];\n    iov[0].iov_base=reinterpret_cast<char*>(&replen);\n    iov[0].iov_len=2;\n    iov[1].iov_base=packet.data();\n    iov[1].iov_len=packet.size();\n  \n    int ret=Utility::writev(d_sock, iov, 2);\n    if(ret < 0)\n      throw ResolverException(\"Error sending question to \"+d_remote.toStringWithPort()+\": \"+stringerror());\n    if(ret != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+d_remote.toStringWithPort());\n    }\n  \n    int res = waitForData(d_sock, 10, 0);\n    \n    if(!res)\n      throw ResolverException(\"Timeout waiting for answer from \"+d_remote.toStringWithPort()+\" during AXFR\");\n    if(res<0)\n      throw ResolverException(\"Error waiting for answer from \"+d_remote.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(d_sock >= 0)\n      close(d_sock);\n    d_sock = -1;\n    throw;\n  }\n}",
  "abstract_func": "AXFRRetriever::AXFRRetriever(const ComboAddress& VAR_0,\n                             const DNSName& VAR_1,\n                             const TSIGTriplet& VAR_2, \n                             const ComboAddress* VAR_3,\n                             size_t VAR_4)\n  : d_tt(VAR_2), d_receivedBytes(0), d_maxReceivedBytes(VAR_4), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress VAR_5;\n  if (VAR_3 != NULL) {\n    VAR_5 = (ComboAddress) (*VAR_3);\n  } else {\n    if(VAR_0.sin4.sin_family == VAR_6)\n      VAR_5=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      VAR_5=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      VAR_5=ComboAddress(\"::\");\n  }\n  VAR_7 = -1;\n  try {\n    VAR_7 = makeQuerySocket(VAR_5, false); /* COMMENT_0 */\n    if (VAR_7 < 0)\n      throw ResolverException(\"Error creating socket for AXFR request to \"+VAR_8.toStringWithPort());\n    VAR_9 = VAR_10<char>(new char[65536]);\n    VAR_8 = VAR_0; /* COMMENT_1 */\n    this->connect();\n    VAR_11 = 0;\n  \n    vector<uint8_t> VAR_12;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    VAR_13.getHeader()->id = dns_random(0xffff);\n  \n    if(!VAR_2.name.empty()) {\n      if (VAR_2.algo == DNSName(\"hmac-md5\"))\n        VAR_14.d_algoName = VAR_2.algo + DNSName(\"sig-alg.reg.int\");\n      else\n        VAR_14.d_algoName = VAR_2.algo;\n      VAR_14.d_time = time(0);\n      VAR_14.d_fudge = 300;\n      VAR_14.d_origID=ntohs(VAR_13.getHeader()->id);\n      VAR_14.d_eRcode=0;\n      addTSIG(VAR_13, &VAR_14, VAR_2.name, VAR_2.secret, \"\", false);\n    }\n  \n    uint16_t VAR_15=htons(packet.size());\n    Utility::iovec VAR_16[2];\n    VAR_16[0].iov_base=VAR_17<char*>(&VAR_15);\n    VAR_16[0].iov_len=2;\n    VAR_16[1].iov_base=packet.data();\n    VAR_16[1].iov_len=packet.size();\n  \n    int VAR_18=Utility::writev(VAR_7, VAR_16, 2);\n    if(VAR_18 < 0)\n      throw ResolverException(\"Error sending question to \"+VAR_8.toStringWithPort()+\": \"+stringerror());\n    if(VAR_18 != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+VAR_8.toStringWithPort());\n    }\n  \n    int VAR_19 = waitForData(VAR_7, 10, 0);\n    \n    if(!VAR_19)\n      throw ResolverException(\"Timeout waiting for answer from \"+VAR_8.toStringWithPort()+\" during AXFR\");\n    if(VAR_19<0)\n      throw ResolverException(\"Error waiting for answer from \"+VAR_8.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(VAR_7 >= 0)\n      close(VAR_7);\n    VAR_7 = -1;\n    throw;\n  }\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n AXFRRetriever::AXFRRetriever(const ComboAddress& remote,\n                              const DNSName& domain,\n                              const TSIGTriplet& tt, \n-                             const ComboAddress* laddr)\n-  : d_tt(tt), d_tsigPos(0), d_nonSignedMessages(0)\n+                             const ComboAddress* laddr,\n+                             size_t maxReceivedBytes)\n+  : d_tt(tt), d_receivedBytes(0), d_maxReceivedBytes(maxReceivedBytes), d_tsigPos(0), d_nonSignedMessages(0)\n {\n   ComboAddress local;\n   if (laddr != NULL) {",
  "diff_line_info": {
    "deleted_lines": [
      "                             const ComboAddress* laddr)",
      "  : d_tt(tt), d_tsigPos(0), d_nonSignedMessages(0)"
    ],
    "added_lines": [
      "                             const ComboAddress* laddr,",
      "                             size_t maxReceivedBytes)",
      "  : d_tt(tt), d_receivedBytes(0), d_maxReceivedBytes(maxReceivedBytes), d_tsigPos(0), d_nonSignedMessages(0)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4133",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/PowerDNS/pdns/pull/4133: 403 Client Error: Forbidden for url: https://api.github.com/repos/PowerDNS/pdns/pulls/4133",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}