{
  "cve_id": "CVE-2015-1828",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "ruby/openssl",
  "commit_msg": "pkey: add support for PKCS #8 key serialization\n\nOpenSSL::PKey::PKey#private_to_der, #private_to_pem are added to the\ngeneric PKey class. They serialize the private key to PKCS #8\n{Encrypted,}PrivateKeyInfo format, in DER- and PEM- encoding,\nrespectively. For symmetry, also add #public_to_der and #public_to_pem\nthat serialize the public key into X.509 SubjectPublicKeyInfo format.\n\nOpenSSL::PKey.read now reads DER-encoded PKCS #8 keys as well as the\n\"raw\" private keys. PEM-encoded PKCS #8 keys have been already handled\nby PEM_read_bio_PrivateKey().",
  "commit_hash": "90afa5f9b595876af3b6832120deb979b214c022",
  "git_url": "https://github.com/ruby/openssl/commit/90afa5f9b595876af3b6832120deb979b214c022",
  "file_path": "ext/openssl/ossl_pkey.c",
  "func_name": "ossl_pkey_new_from_data",
  "func_before": "static VALUE\nossl_pkey_new_from_data(int argc, VALUE *argv, VALUE self)\n{\n    EVP_PKEY *pkey;\n    BIO *bio;\n    VALUE data, pass;\n\n    rb_scan_args(argc, argv, \"11\", &data, &pass);\n    pass = ossl_pem_passwd_value(pass);\n\n    bio = ossl_obj2bio(&data);\n    if (!(pkey = d2i_PrivateKey_bio(bio, NULL))) {\n\tOSSL_BIO_reset(bio);\n\tif (!(pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass))) {\n\t    OSSL_BIO_reset(bio);\n\t    if (!(pkey = d2i_PUBKEY_bio(bio, NULL))) {\n\t\tOSSL_BIO_reset(bio);\n\t\tpkey = PEM_read_bio_PUBKEY(bio, NULL, ossl_pem_passwd_cb, (void *)pass);\n\t    }\n\t}\n    }\n\n    BIO_free(bio);\n    if (!pkey)\n\tossl_raise(ePKeyError, \"Could not parse PKey\");\n\n    return ossl_pkey_new(pkey);\n}",
  "abstract_func_before": "static VALUE\nossl_pkey_new_from_data(int VAR_0, VALUE *VAR_1, VALUE VAR_2)\n{\n    EVP_PKEY *VAR_3;\n    BIO *VAR_4;\n    VALUE VAR_5, VAR_6;\n\n    rb_scan_args(VAR_0, VAR_1, \"11\", &VAR_5, &VAR_6);\n    VAR_6 = ossl_pem_passwd_value(VAR_6);\n\n    VAR_4 = ossl_obj2bio(&VAR_5);\n    if (!(VAR_3 = d2i_PrivateKey_bio(VAR_4, NULL))) {\n\tOSSL_BIO_reset(VAR_4);\n\tif (!(VAR_3 = PEM_read_bio_PrivateKey(VAR_4, NULL, VAR_7, (void *)VAR_6))) {\n\t    OSSL_BIO_reset(VAR_4);\n\t    if (!(VAR_3 = d2i_PUBKEY_bio(VAR_4, NULL))) {\n\t\tOSSL_BIO_reset(VAR_4);\n\t\tVAR_3 = PEM_read_bio_PUBKEY(VAR_4, NULL, VAR_7, (void *)VAR_6);\n\t    }\n\t}\n    }\n\n    BIO_free(VAR_4);\n    if (!VAR_3)\n\tossl_raise(VAR_8, \"Could not parse PKey\");\n\n    return ossl_pkey_new(VAR_3);\n}",
  "func_graph_path_before": "ruby/openssl/90afa5f9b595876af3b6832120deb979b214c022/ossl_pkey.c/vul/before/0.json",
  "func": "static VALUE\nossl_pkey_new_from_data(int argc, VALUE *argv, VALUE self)\n{\n    EVP_PKEY *pkey;\n    BIO *bio;\n    VALUE data, pass;\n\n    rb_scan_args(argc, argv, \"11\", &data, &pass);\n    pass = ossl_pem_passwd_value(pass);\n\n    bio = ossl_obj2bio(&data);\n    if ((pkey = d2i_PrivateKey_bio(bio, NULL)))\n\tgoto ok;\n    OSSL_BIO_reset(bio);\n    if ((pkey = d2i_PKCS8PrivateKey_bio(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))\n\tgoto ok;\n    OSSL_BIO_reset(bio);\n    if ((pkey = d2i_PUBKEY_bio(bio, NULL)))\n\tgoto ok;\n    OSSL_BIO_reset(bio);\n    /* PEM_read_bio_PrivateKey() also parses PKCS #8 formats */\n    if ((pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))\n\tgoto ok;\n    OSSL_BIO_reset(bio);\n    if ((pkey = PEM_read_bio_PUBKEY(bio, NULL, NULL, NULL)))\n\tgoto ok;\n\n    BIO_free(bio);\n    ossl_raise(ePKeyError, \"Could not parse PKey\");\n\nok:\n    BIO_free(bio);\n    return ossl_pkey_new(pkey);\n}",
  "abstract_func": "static VALUE\nossl_pkey_new_from_data(int VAR_0, VALUE *VAR_1, VALUE VAR_2)\n{\n    EVP_PKEY *VAR_3;\n    BIO *VAR_4;\n    VALUE VAR_5, VAR_6;\n\n    rb_scan_args(VAR_0, VAR_1, \"11\", &VAR_5, &VAR_6);\n    VAR_6 = ossl_pem_passwd_value(VAR_6);\n\n    VAR_4 = ossl_obj2bio(&VAR_5);\n    if ((VAR_3 = d2i_PrivateKey_bio(VAR_4, NULL)))\n\tgoto ok;\n    OSSL_BIO_reset(VAR_4);\n    if ((VAR_3 = d2i_PKCS8PrivateKey_bio(VAR_4, NULL, VAR_7, (void *)VAR_6)))\n\tgoto ok;\n    OSSL_BIO_reset(VAR_4);\n    if ((VAR_3 = d2i_PUBKEY_bio(VAR_4, NULL)))\n\tgoto ok;\n    OSSL_BIO_reset(VAR_4);\n    /* COMMENT_0 */\n    if ((VAR_3 = PEM_read_bio_PrivateKey(VAR_4, NULL, VAR_7, (void *)VAR_6)))\n\tgoto ok;\n    OSSL_BIO_reset(VAR_4);\n    if ((VAR_3 = PEM_read_bio_PUBKEY(VAR_4, NULL, NULL, NULL)))\n\tgoto ok;\n\n    BIO_free(VAR_4);\n    ossl_raise(VAR_8, \"Could not parse PKey\");\n\nok:\n    BIO_free(VAR_4);\n    return ossl_pkey_new(VAR_3);\n}",
  "func_graph_path": "ruby/openssl/90afa5f9b595876af3b6832120deb979b214c022/ossl_pkey.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,20 +9,26 @@\n     pass = ossl_pem_passwd_value(pass);\n \n     bio = ossl_obj2bio(&data);\n-    if (!(pkey = d2i_PrivateKey_bio(bio, NULL))) {\n-\tOSSL_BIO_reset(bio);\n-\tif (!(pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass))) {\n-\t    OSSL_BIO_reset(bio);\n-\t    if (!(pkey = d2i_PUBKEY_bio(bio, NULL))) {\n-\t\tOSSL_BIO_reset(bio);\n-\t\tpkey = PEM_read_bio_PUBKEY(bio, NULL, ossl_pem_passwd_cb, (void *)pass);\n-\t    }\n-\t}\n-    }\n+    if ((pkey = d2i_PrivateKey_bio(bio, NULL)))\n+\tgoto ok;\n+    OSSL_BIO_reset(bio);\n+    if ((pkey = d2i_PKCS8PrivateKey_bio(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))\n+\tgoto ok;\n+    OSSL_BIO_reset(bio);\n+    if ((pkey = d2i_PUBKEY_bio(bio, NULL)))\n+\tgoto ok;\n+    OSSL_BIO_reset(bio);\n+    /* PEM_read_bio_PrivateKey() also parses PKCS #8 formats */\n+    if ((pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))\n+\tgoto ok;\n+    OSSL_BIO_reset(bio);\n+    if ((pkey = PEM_read_bio_PUBKEY(bio, NULL, NULL, NULL)))\n+\tgoto ok;\n \n     BIO_free(bio);\n-    if (!pkey)\n-\tossl_raise(ePKeyError, \"Could not parse PKey\");\n+    ossl_raise(ePKeyError, \"Could not parse PKey\");\n \n+ok:\n+    BIO_free(bio);\n     return ossl_pkey_new(pkey);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    if (!(pkey = d2i_PrivateKey_bio(bio, NULL))) {",
      "\tOSSL_BIO_reset(bio);",
      "\tif (!(pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass))) {",
      "\t    OSSL_BIO_reset(bio);",
      "\t    if (!(pkey = d2i_PUBKEY_bio(bio, NULL))) {",
      "\t\tOSSL_BIO_reset(bio);",
      "\t\tpkey = PEM_read_bio_PUBKEY(bio, NULL, ossl_pem_passwd_cb, (void *)pass);",
      "\t    }",
      "\t}",
      "    }",
      "    if (!pkey)",
      "\tossl_raise(ePKeyError, \"Could not parse PKey\");"
    ],
    "added_lines": [
      "    if ((pkey = d2i_PrivateKey_bio(bio, NULL)))",
      "\tgoto ok;",
      "    OSSL_BIO_reset(bio);",
      "    if ((pkey = d2i_PKCS8PrivateKey_bio(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))",
      "\tgoto ok;",
      "    OSSL_BIO_reset(bio);",
      "    if ((pkey = d2i_PUBKEY_bio(bio, NULL)))",
      "\tgoto ok;",
      "    OSSL_BIO_reset(bio);",
      "    /* PEM_read_bio_PrivateKey() also parses PKCS #8 formats */",
      "    if ((pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))",
      "\tgoto ok;",
      "    OSSL_BIO_reset(bio);",
      "    if ((pkey = PEM_read_bio_PUBKEY(bio, NULL, NULL, NULL)))",
      "\tgoto ok;",
      "    ossl_raise(ePKeyError, \"Could not parse PKey\");",
      "ok:",
      "    BIO_free(bio);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ruby/openssl/pull/297",
  "description": {
    "pr_info": {
      "title": "Export keys in PKCS8 format",
      "number": 297
    },
    "comment": [
      "Closes https://github.com/ruby/openssl/issues/294 by cherry-picking from https://github.com/ruby/openssl/pull/119 \r\n\r\nThe only line that needed changing to make it work on latest master was https://github.com/ruby/openssl/pull/119/files#diff-bae6e18b74ab1f890ac3e06a1aae16a2R614 to use `ossl_evp_get_cipherbyname ` as this was renamed in https://github.com/ruby/openssl/commit/679b6f490671439d1bc50ef4371d9fb3bbba0e29",
      "Great."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9\n\nStep-by-step explanation:\n\n1. The commit introduces new methods for PKCS #8 key serialization and improves key reading functionality.\n2. The code diff modifies the key parsing logic to support more formats, not addressing security flaws.\n3. The vulnerability description refers to a compatibility fix, not a security issue.\n4. The changes are feature additions and ENHANCEMENTS, fitting the Defect Remediation category.\n5. Clear evidence supports non-security classification with high confidence.\n\n**Final Output:**  \n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}