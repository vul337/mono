{
  "cve_id": "CVE-2020-24266",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #620 apply get.c functions fixed in #617\n\nAdd safety and failure reporting for packet captures with\ncaplen too small.",
  "commit_hash": "21cce6b1d63a4b431fdc5f239cd23cb7a80d514f",
  "git_url": "https://github.com/appneta/tcpreplay/commit/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f",
  "file_path": "src/send_packets.c",
  "func_name": "send_dual_packets",
  "func_before": "void\nsend_dual_packets(tcpreplay_t *ctx, pcap_t *pcap1, int cache_file_idx1, pcap_t *pcap2, int cache_file_idx2)\n{\n    struct timeval print_delta, now, last_pkt_ts;\n    tcpreplay_opt_t *options = ctx->options;\n    tcpreplay_stats_t *stats = &ctx->stats;\n    COUNTER packetnum = 0;\n    COUNTER limit_send = options->limit_send;\n    int cache_file_idx;\n    struct pcap_pkthdr pkthdr1, pkthdr2;\n    u_char *pktdata1 = NULL, *pktdata2 = NULL, *pktdata = NULL;\n    sendpacket_t *sp;\n    COUNTER pktlen;\n    packet_cache_t *cached_packet1 = NULL, *cached_packet2 = NULL;\n    packet_cache_t **prev_packet1 = NULL, **prev_packet2 = NULL;\n    struct pcap_pkthdr *pkthdr_ptr;\n    int datalink;\n    COUNTER end_us;\n    COUNTER skip_length = 0;\n    bool top_speed = (options->speed.mode == speed_topspeed ||\n            (options->speed.mode == speed_mbpsrate && options->speed.speed == 0));\n    bool now_is_now = true;\n\n    gettimeofday(&now, NULL);\n    if (!timerisset(&stats->start_time)) {\n        TIMEVAL_SET(&stats->start_time, &now);\n        if (ctx->options->stats >= 0) {\n            char buf[64];\n            if (format_date_time(&stats->start_time, buf, sizeof(buf)) > 0)\n                printf(\"Dual test start: %s ...\\n\", buf);\n        }\n    }\n\n    ctx->skip_packets = 0;\n    timerclear(&last_pkt_ts);\n    if (options->limit_time > 0)\n        end_us = TIMEVAL_TO_MICROSEC(&stats->start_time) +\n            SEC_TO_MICROSEC(options->limit_time);\n    else\n        end_us = 0;\n\n    if (options->preload_pcap) {\n        prev_packet1 = &cached_packet1;\n        prev_packet2 = &cached_packet2;\n    } else {\n        prev_packet1 = NULL;\n        prev_packet2 = NULL;\n    }\n\n    pktdata1 = get_next_packet(ctx, pcap1, &pkthdr1, cache_file_idx1, prev_packet1);\n    pktdata2 = get_next_packet(ctx, pcap2, &pkthdr2, cache_file_idx2, prev_packet2);\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while (!ctx->abort &&\n            !(pktdata1 == NULL && pktdata2 == NULL)) {\n\n        now_is_now = false;\n        packetnum++;\n\n        /* figure out which pcap file we need to process next \n         * when get_next_packet() returns null for pktdata, the pkthdr \n         * will still have the old values from the previous call.  This\n         * means we can't always trust the timestamps to tell us which\n         * file to process.\n         */\n        if (pktdata1 == NULL) {\n            /* file 2 is next */\n            sp = ctx->intf2;\n            datalink = options->file_cache[cache_file_idx2].dlt;\n            pkthdr_ptr = &pkthdr2;\n            cache_file_idx = cache_file_idx2;\n            pktdata = pktdata2;\n        } else if (pktdata2 == NULL) {\n            /* file 1 is next */\n            sp = ctx->intf1;\n            datalink = options->file_cache[cache_file_idx1].dlt;\n            pkthdr_ptr = &pkthdr1;\n            cache_file_idx = cache_file_idx1;\n            pktdata = pktdata1;\n        } else if (timercmp(&pkthdr1.ts, &pkthdr2.ts, <=)) {\n            /* file 1 is next */\n            sp = ctx->intf1;\n            datalink = options->file_cache[cache_file_idx1].dlt;\n            pkthdr_ptr = &pkthdr1;\n            cache_file_idx = cache_file_idx1;\n            pktdata = pktdata1;\n        } else {\n            /* file 2 is next */\n            sp = ctx->intf2;\n            datalink = options->file_cache[cache_file_idx2].dlt;\n            pkthdr_ptr = &pkthdr2;\n            cache_file_idx = cache_file_idx2;\n            pktdata = pktdata2;\n        }\n\n#if defined TCPREPLAY || defined TCPREPLAY_EDIT\n        /* do we use the snaplen (caplen) or the \"actual\" packet len? */\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr_ptr->len : (COUNTER)pkthdr_ptr->caplen;\n#elif TCPBRIDGE\n        pktlen = (COUNTER)pkthdr_ptr->caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen \" COUNTER_SPEC, packetnum, pktlen);\n\n#if defined TCPREPLAY && defined TCPREPLAY_EDIT\n        if (tcpedit_packet(tcpedit, &pkthdr_ptr, &pktdata, sp->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" COUNTER_SPEC \": %s\", packetnum, tcpedit_geterr(tcpedit));\n        }\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr_ptr->len : (COUNTER)pkthdr_ptr->caplen;\n#endif\n\n        if (ctx->options->unique_ip && ctx->unique_iteration &&\n                ctx->unique_iteration > ctx->last_unique_iteration) {\n            /* edit packet to ensure every pass is unique */\n            fast_edit_packet(pkthdr_ptr, &pktdata, ctx->unique_iteration - 1,\n                    options->file_cache[cache_file_idx].cached, datalink);\n        }\n\n        /* update flow stats */\n        if (options->flow_stats && !options->file_cache[cache_file_idx].cached)\n            update_flow_stats(ctx, sp, pkthdr_ptr, pktdata, datalink);\n\n        /*\n         * this accelerator improves performance by avoiding expensive\n         * time stamps during periods where we have fallen behind in our\n         * sending\n         */\n        if (skip_length && pktlen < skip_length) {\n            skip_length -= pktlen;\n        } else if (ctx->skip_packets) {\n            --ctx->skip_packets;\n        } else {\n            /*\n             * time stamping is expensive, but now is the\n             * time to do it.\n             */\n            dbgx(4, \"This packet time: \" TIMEVAL_FORMAT, pkthdr_ptr->ts.tv_sec,\n                    pkthdr_ptr->ts.tv_usec);\n            skip_length = 0;\n            ctx->skip_packets = 0;\n\n            if (options->speed.mode == speed_multiplier) {\n                if (!timerisset(&last_pkt_ts)) {\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr_ptr->ts);\n                } else if (timercmp(&pkthdr_ptr->ts, &last_pkt_ts, >)) {\n                    struct timeval delta;\n\n                    timersub(&pkthdr_ptr->ts, &last_pkt_ts, &delta);\n                    timeradd(&stats->pkt_ts_delta, &delta, &stats->pkt_ts_delta);\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr_ptr->ts);\n                }\n\n                if (!timerisset(&stats->time_delta))\n                    TIMEVAL_SET(&stats->pkt_ts_delta, &stats->pkt_ts_delta);\n            }\n\n            if (!top_speed) {\n                gettimeofday(&now, NULL);\n                now_is_now = true;\n            }\n\n            /*\n             * Only if the current packet is not late.\n             *\n             * This also sets skip_length and skip_packets which will avoid\n             * timestamping for a given number of packets.\n             */\n            calc_sleep_time(ctx, &stats->pkt_ts_delta, &stats->time_delta,\n                    pktlen, sp, packetnum, &stats->end_time,\n                    TIMEVAL_TO_MICROSEC(&stats->start_time), &skip_length);\n\n            /*\n             * Track the time of the \"last packet sent\".\n             *\n             * A number of 3rd party tools generate bad timestamps which go backwards\n             * in time.  Hence, don't update the \"last\" unless pkthdr.ts > last\n             */\n            if (timercmp(&stats->time_delta, &stats->pkt_ts_delta, <))\n                TIMEVAL_SET(&stats->time_delta, &stats->pkt_ts_delta);\n\n            /*\n             * we know how long to sleep between sends, now do it.\n             */\n            if (!top_speed)\n                tcpr_sleep(ctx, sp, &ctx->nap, &now);\n        }\n\n#ifdef ENABLE_VERBOSE\n        /* do we need to print the packet via tcpdump? */\n        if (options->verbose)\n            tcpdump_print(options->tcpdump, pkthdr_ptr, pktdata);\n#endif\n\n        dbgx(2, \"Sending packet #\" COUNTER_SPEC, packetnum);\n        /* write packet out on network */\n        if (sendpacket(sp, pktdata, pktlen, pkthdr_ptr) < (int)pktlen) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(sp));\n            break;\n        }\n\n        /*\n         * Mark the time when we sent the last packet\n         */\n        TIMEVAL_SET(&stats->end_time, &now);\n\n        stats->pkts_sent++;\n        stats->bytes_sent += pktlen;\n\n        /* print stats during the run? */\n        if (options->stats > 0) {\n            if (! timerisset(&stats->last_print)) {\n                TIMEVAL_SET(&stats->last_print, &now);\n            } else {\n                timersub(&now, &stats->last_print, &print_delta);\n                if (print_delta.tv_sec >= options->stats) {\n                    TIMEVAL_SET(&stats->end_time, &now);\n                    packet_stats(stats);\n                    TIMEVAL_SET(&stats->last_print, &now);\n                }\n            }\n        }\n\n#if defined HAVE_NETMAP\n        if (sp->first_packet || timesisset(&ctx->nap)) {\n            wake_send_queues(sp, options);\n            sp->first_packet = false;\n        }\n#endif\n\n        /* get the next packet for this file handle depending on which we last used */\n        if (sp == ctx->intf2) {\n            pktdata2 = get_next_packet(ctx, pcap2, &pkthdr2, cache_file_idx2, prev_packet2);\n        } else {\n            pktdata1 = get_next_packet(ctx, pcap1, &pkthdr1, cache_file_idx1, prev_packet1);\n        }\n\n        /* stop sending based on the duration limit... */\n        if ((end_us > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&now) > end_us) ||\n                /* ... or stop sending based on the limit -L? */\n                (limit_send > 0 && stats->pkts_sent >= limit_send)) {\n            ctx->abort = true;\n        }\n    } /* while */\n\n#ifdef HAVE_NETMAP\n    /* when completing test, wait until the last packet is sent */\n    if (options->netmap && (ctx->abort || options->loop == 1)) {\n        while (ctx->intf1 && !netmap_tx_queues_empty(ctx->intf1)) {\n            gettimeofday(&now, NULL);\n            now_is_now = true;\n        }\n\n        while (ctx->intf2 && !netmap_tx_queues_empty(ctx->intf2)) {\n            gettimeofday(&now, NULL);\n            now_is_now = true;\n        }\n    }\n#endif /* HAVE_NETMAP */\n\n    if (!now_is_now)\n        gettimeofday(&now, NULL);\n\n    TIMEVAL_SET(&stats->end_time, &now);\n\n    increment_iteration(ctx);\n}",
  "abstract_func_before": "void\nsend_dual_packets(tcpreplay_t *VAR_0, pcap_t *VAR_1, int VAR_2, pcap_t *VAR_3, int VAR_4)\n{\n    struct timeval VAR_5, VAR_6, VAR_7;\n    tcpreplay_opt_t *VAR_8 = VAR_0->options;\n    tcpreplay_stats_t *VAR_9 = &VAR_0->stats;\n    COUNTER VAR_10 = 0;\n    COUNTER VAR_11 = VAR_8->limit_send;\n    int VAR_12;\n    struct pcap_pkthdr VAR_13, VAR_14;\n    u_char *VAR_15 = NULL, *VAR_16 = NULL, *VAR_17 = NULL;\n    sendpacket_t *VAR_18;\n    COUNTER VAR_19;\n    packet_cache_t *VAR_20 = NULL, *VAR_21 = NULL;\n    packet_cache_t **VAR_22 = NULL, **VAR_23 = NULL;\n    struct pcap_pkthdr *VAR_24;\n    int VAR_25;\n    COUNTER VAR_26;\n    COUNTER VAR_27 = 0;\n    bool VAR_28 = (VAR_8->speed.mode == VAR_29 ||\n            (VAR_8->speed.mode == VAR_30 && VAR_8->speed.speed == 0));\n    bool VAR_31 = true;\n\n    gettimeofday(&VAR_6, NULL);\n    if (!timerisset(&VAR_9->start_time)) {\n        TIMEVAL_SET(&VAR_9->start_time, &VAR_6);\n        if (VAR_0->options->stats >= 0) {\n            char VAR_32[64];\n            if (format_date_time(&VAR_9->start_time, VAR_32, sizeof(VAR_32)) > 0)\n                printf(\"Dual test start: %s ...\\n\", VAR_32);\n        }\n    }\n\n    VAR_0->skip_packets = 0;\n    timerclear(&VAR_7);\n    if (VAR_8->limit_time > 0)\n        VAR_26 = TIMEVAL_TO_MICROSEC(&VAR_9->start_time) +\n            SEC_TO_MICROSEC(VAR_8->limit_time);\n    else\n        VAR_26 = 0;\n\n    if (VAR_8->preload_pcap) {\n        VAR_22 = &VAR_20;\n        VAR_23 = &VAR_21;\n    } else {\n        VAR_22 = NULL;\n        VAR_23 = NULL;\n    }\n\n    VAR_15 = get_next_packet(VAR_0, VAR_1, &VAR_13, VAR_2, VAR_22);\n    VAR_16 = get_next_packet(VAR_0, VAR_3, &VAR_14, VAR_4, VAR_23);\n\n    /* COMMENT_0 */\n                                                  \n                                \n       \n    while (!VAR_0->abort &&\n            !(VAR_15 == NULL && VAR_16 == NULL)) {\n\n        VAR_31 = false;\n        VAR_10++;\n\n        /* COMMENT_4 */\n                                                                       \n                                                                       \n                                                                      \n                           \n           \n        if (VAR_15 == NULL) {\n            /* COMMENT_10 */\n            VAR_18 = VAR_0->intf2;\n            VAR_25 = VAR_8->file_cache[VAR_4].dlt;\n            VAR_24 = &VAR_14;\n            VAR_12 = VAR_4;\n            VAR_17 = VAR_16;\n        } else if (VAR_16 == NULL) {\n            /* COMMENT_11 */\n            VAR_18 = VAR_0->intf1;\n            VAR_25 = VAR_8->file_cache[VAR_2].dlt;\n            VAR_24 = &VAR_13;\n            VAR_12 = VAR_2;\n            VAR_17 = VAR_15;\n        } else if (timercmp(&VAR_13.ts, &VAR_14.ts, <=)) {\n            /* COMMENT_11 */\n            VAR_18 = VAR_0->intf1;\n            VAR_25 = VAR_8->file_cache[VAR_2].dlt;\n            VAR_24 = &VAR_13;\n            VAR_12 = VAR_2;\n            VAR_17 = VAR_15;\n        } else {\n            /* COMMENT_10 */\n            VAR_18 = VAR_0->intf2;\n            VAR_25 = VAR_8->file_cache[VAR_4].dlt;\n            VAR_24 = &VAR_14;\n            VAR_12 = VAR_4;\n            VAR_17 = VAR_16;\n        }\n\n#if defined VAR_33 || defined VAR_34\n        /* COMMENT_12 */\n        VAR_19 = VAR_8->use_pkthdr_len ? (COUNTER)VAR_24->len : (COUNTER)VAR_24->caplen;\n#elif VAR_35\n        VAR_19 = (COUNTER)VAR_24->caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" VAR_36 \" caplen \" VAR_36, VAR_10, VAR_19);\n\n#if defined VAR_33 && defined VAR_34\n        if (tcpedit_packet(VAR_37, &VAR_24, &VAR_17, VAR_18->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" VAR_36 \": %s\", VAR_10, tcpedit_geterr(VAR_37));\n        }\n        VAR_19 = VAR_8->use_pkthdr_len ? (COUNTER)VAR_24->len : (COUNTER)VAR_24->caplen;\n#endif\n\n        if (VAR_0->options->unique_ip && VAR_0->unique_iteration &&\n                VAR_0->unique_iteration > VAR_0->last_unique_iteration) {\n            /* COMMENT_13 */\n            fast_edit_packet(VAR_24, &VAR_17, VAR_0->unique_iteration - 1,\n                    VAR_8->file_cache[VAR_12].cached, VAR_25);\n        }\n\n        /* COMMENT_14 */\n        if (VAR_8->flow_stats && !VAR_8->file_cache[VAR_12].cached)\n            update_flow_stats(VAR_0, VAR_18, VAR_24, VAR_17, VAR_25);\n\n        /* COMMENT_15 */\n                                                                      \n                                                                        \n                  \n           \n        if (VAR_27 && VAR_19 < VAR_27) {\n            VAR_27 -= VAR_19;\n        } else if (VAR_0->skip_packets) {\n            --VAR_0->skip_packets;\n        } else {\n            /* COMMENT_20 */\n                                                         \n                             \n               \n            dbgx(4, \"This packet time: \" VAR_38, VAR_24->ts.tv_sec,\n                    VAR_24->ts.tv_usec);\n            VAR_27 = 0;\n            VAR_0->skip_packets = 0;\n\n            if (VAR_8->speed.mode == VAR_39) {\n                if (!timerisset(&VAR_7)) {\n                    TIMEVAL_SET(&VAR_7, &VAR_24->ts);\n                } else if (timercmp(&VAR_24->ts, &VAR_7, >)) {\n                    struct timeval VAR_40;\n\n                    timersub(&VAR_24->ts, &VAR_7, &VAR_40);\n                    timeradd(&VAR_9->pkt_ts_delta, &VAR_40, &VAR_9->pkt_ts_delta);\n                    TIMEVAL_SET(&VAR_7, &VAR_24->ts);\n                }\n\n                if (!timerisset(&VAR_9->time_delta))\n                    TIMEVAL_SET(&VAR_9->pkt_ts_delta, &VAR_9->pkt_ts_delta);\n            }\n\n            if (!VAR_28) {\n                gettimeofday(&VAR_6, NULL);\n                VAR_31 = true;\n            }\n\n            /* COMMENT_24 */\n                                                      \n              \n                                                                           \n                                                          \n               \n            calc_sleep_time(VAR_0, &VAR_9->pkt_ts_delta, &VAR_9->time_delta,\n                    VAR_19, VAR_18, VAR_10, &VAR_9->end_time,\n                    TIMEVAL_TO_MICROSEC(&VAR_9->start_time), &VAR_27);\n\n            /* COMMENT_30 */\n                                                        \n              \n                                                                                     \n                                                                               \n               \n            if (timercmp(&VAR_9->time_delta, &VAR_9->pkt_ts_delta, <))\n                TIMEVAL_SET(&VAR_9->time_delta, &VAR_9->pkt_ts_delta);\n\n            /* COMMENT_36 */\n                                                                  \n               \n            if (!VAR_28)\n                tcpr_sleep(VAR_0, VAR_18, &VAR_0->nap, &VAR_6);\n        }\n\n#ifdef VAR_41\n        /* COMMENT_39 */\n        if (VAR_8->verbose)\n            tcpdump_print(VAR_8->tcpdump, VAR_24, VAR_17);\n#endif\n\n        dbgx(2, \"Sending packet #\" VAR_36, VAR_10);\n        /* COMMENT_40 */\n        if (sendpacket(VAR_18, VAR_17, VAR_19, VAR_24) < (int)VAR_19) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(VAR_18));\n            break;\n        }\n\n        /* COMMENT_41 */\n                                                     \n           \n        TIMEVAL_SET(&VAR_9->end_time, &VAR_6);\n\n        VAR_9->pkts_sent++;\n        VAR_9->bytes_sent += VAR_19;\n\n        /* COMMENT_44 */\n        if (VAR_8->stats > 0) {\n            if (! timerisset(&VAR_9->last_print)) {\n                TIMEVAL_SET(&VAR_9->last_print, &VAR_6);\n            } else {\n                timersub(&VAR_6, &VAR_9->last_print, &VAR_5);\n                if (VAR_5.tv_sec >= VAR_8->stats) {\n                    TIMEVAL_SET(&VAR_9->end_time, &VAR_6);\n                    packet_stats(VAR_9);\n                    TIMEVAL_SET(&VAR_9->last_print, &VAR_6);\n                }\n            }\n        }\n\n#if defined VAR_42\n        if (VAR_18->first_packet || timesisset(&VAR_0->nap)) {\n            wake_send_queues(VAR_18, VAR_8);\n            VAR_18->first_packet = false;\n        }\n#endif\n\n        /* COMMENT_45 */\n        if (VAR_18 == VAR_0->intf2) {\n            VAR_16 = get_next_packet(VAR_0, VAR_3, &VAR_14, VAR_4, VAR_23);\n        } else {\n            VAR_15 = get_next_packet(VAR_0, VAR_1, &VAR_13, VAR_2, VAR_22);\n        }\n\n        /* COMMENT_46 */\n        if ((VAR_26 > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&VAR_6) > VAR_26) ||\n                /* COMMENT_47 */\n                (VAR_11 > 0 && VAR_9->pkts_sent >= VAR_11)) {\n            VAR_0->abort = true;\n        }\n    } /* COMMENT_48 */\n\n#ifdef VAR_42\n    /* COMMENT_49 */\n    if (VAR_8->netmap && (VAR_0->abort || VAR_8->loop == 1)) {\n        while (VAR_0->intf1 && !netmap_tx_queues_empty(VAR_0->intf1)) {\n            gettimeofday(&VAR_6, NULL);\n            VAR_31 = true;\n        }\n\n        while (VAR_0->intf2 && !netmap_tx_queues_empty(VAR_0->intf2)) {\n            gettimeofday(&VAR_6, NULL);\n            VAR_31 = true;\n        }\n    }\n#endif /* COMMENT_50 */\n\n    if (!VAR_31)\n        gettimeofday(&VAR_6, NULL);\n\n    TIMEVAL_SET(&VAR_9->end_time, &VAR_6);\n\n    increment_iteration(VAR_0);\n}",
  "func_graph_path_before": "appneta/tcpreplay/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f/send_packets.c/vul/before/2.json",
  "func": "void\nsend_dual_packets(tcpreplay_t *ctx, pcap_t *pcap1, int cache_file_idx1, pcap_t *pcap2, int cache_file_idx2)\n{\n    struct timeval print_delta, now, last_pkt_ts;\n    tcpreplay_opt_t *options = ctx->options;\n    tcpreplay_stats_t *stats = &ctx->stats;\n    COUNTER packetnum = 0;\n    COUNTER limit_send = options->limit_send;\n    int cache_file_idx;\n    struct pcap_pkthdr pkthdr1, pkthdr2;\n    u_char *pktdata1 = NULL, *pktdata2 = NULL, *pktdata = NULL;\n    sendpacket_t *sp;\n    COUNTER pktlen;\n    packet_cache_t *cached_packet1 = NULL, *cached_packet2 = NULL;\n    packet_cache_t **prev_packet1 = NULL, **prev_packet2 = NULL;\n    struct pcap_pkthdr *pkthdr_ptr;\n    int datalink;\n    COUNTER end_us;\n    COUNTER skip_length = 0;\n    bool top_speed = (options->speed.mode == speed_topspeed ||\n            (options->speed.mode == speed_mbpsrate && options->speed.speed == 0));\n    bool now_is_now = true;\n\n    gettimeofday(&now, NULL);\n    if (!timerisset(&stats->start_time)) {\n        TIMEVAL_SET(&stats->start_time, &now);\n        if (ctx->options->stats >= 0) {\n            char buf[64];\n            if (format_date_time(&stats->start_time, buf, sizeof(buf)) > 0)\n                printf(\"Dual test start: %s ...\\n\", buf);\n        }\n    }\n\n    ctx->skip_packets = 0;\n    timerclear(&last_pkt_ts);\n    if (options->limit_time > 0)\n        end_us = TIMEVAL_TO_MICROSEC(&stats->start_time) +\n            SEC_TO_MICROSEC(options->limit_time);\n    else\n        end_us = 0;\n\n    if (options->preload_pcap) {\n        prev_packet1 = &cached_packet1;\n        prev_packet2 = &cached_packet2;\n    } else {\n        prev_packet1 = NULL;\n        prev_packet2 = NULL;\n    }\n\n    pktdata1 = get_next_packet(ctx, pcap1, &pkthdr1, cache_file_idx1, prev_packet1);\n    pktdata2 = get_next_packet(ctx, pcap2, &pkthdr2, cache_file_idx2, prev_packet2);\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while (!ctx->abort &&\n            !(pktdata1 == NULL && pktdata2 == NULL)) {\n\n        now_is_now = false;\n        packetnum++;\n\n        /* figure out which pcap file we need to process next \n         * when get_next_packet() returns null for pktdata, the pkthdr \n         * will still have the old values from the previous call.  This\n         * means we can't always trust the timestamps to tell us which\n         * file to process.\n         */\n        if (pktdata1 == NULL) {\n            /* file 2 is next */\n            sp = ctx->intf2;\n            datalink = options->file_cache[cache_file_idx2].dlt;\n            pkthdr_ptr = &pkthdr2;\n            cache_file_idx = cache_file_idx2;\n            pktdata = pktdata2;\n        } else if (pktdata2 == NULL) {\n            /* file 1 is next */\n            sp = ctx->intf1;\n            datalink = options->file_cache[cache_file_idx1].dlt;\n            pkthdr_ptr = &pkthdr1;\n            cache_file_idx = cache_file_idx1;\n            pktdata = pktdata1;\n        } else if (timercmp(&pkthdr1.ts, &pkthdr2.ts, <=)) {\n            /* file 1 is next */\n            sp = ctx->intf1;\n            datalink = options->file_cache[cache_file_idx1].dlt;\n            pkthdr_ptr = &pkthdr1;\n            cache_file_idx = cache_file_idx1;\n            pktdata = pktdata1;\n        } else {\n            /* file 2 is next */\n            sp = ctx->intf2;\n            datalink = options->file_cache[cache_file_idx2].dlt;\n            pkthdr_ptr = &pkthdr2;\n            cache_file_idx = cache_file_idx2;\n            pktdata = pktdata2;\n        }\n\n#if defined TCPREPLAY || defined TCPREPLAY_EDIT\n        /* do we use the snaplen (caplen) or the \"actual\" packet len? */\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr_ptr->len : (COUNTER)pkthdr_ptr->caplen;\n#elif TCPBRIDGE\n        pktlen = (COUNTER)pkthdr_ptr->caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen \" COUNTER_SPEC, packetnum, pktlen);\n\n#if defined TCPREPLAY && defined TCPREPLAY_EDIT\n        if (tcpedit_packet(tcpedit, &pkthdr_ptr, &pktdata, sp->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" COUNTER_SPEC \": %s\", packetnum, tcpedit_geterr(tcpedit));\n        }\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr_ptr->len : (COUNTER)pkthdr_ptr->caplen;\n#endif\n\n        if (ctx->options->unique_ip && ctx->unique_iteration &&\n                ctx->unique_iteration > ctx->last_unique_iteration) {\n            /* edit packet to ensure every pass is unique */\n            if (fast_edit_packet(pkthdr_ptr, &pktdata, ctx->unique_iteration - 1,\n                    options->file_cache[cache_file_idx].cached, datalink) == -1) {\n                ++stats->failed;\n                continue;\n            }\n        }\n\n        /* update flow stats */\n        if (options->flow_stats && !options->file_cache[cache_file_idx].cached)\n            update_flow_stats(ctx, sp, pkthdr_ptr, pktdata, datalink);\n\n        /*\n         * this accelerator improves performance by avoiding expensive\n         * time stamps during periods where we have fallen behind in our\n         * sending\n         */\n        if (skip_length && pktlen < skip_length) {\n            skip_length -= pktlen;\n        } else if (ctx->skip_packets) {\n            --ctx->skip_packets;\n        } else {\n            /*\n             * time stamping is expensive, but now is the\n             * time to do it.\n             */\n            dbgx(4, \"This packet time: \" TIMEVAL_FORMAT, pkthdr_ptr->ts.tv_sec,\n                    pkthdr_ptr->ts.tv_usec);\n            skip_length = 0;\n            ctx->skip_packets = 0;\n\n            if (options->speed.mode == speed_multiplier) {\n                if (!timerisset(&last_pkt_ts)) {\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr_ptr->ts);\n                } else if (timercmp(&pkthdr_ptr->ts, &last_pkt_ts, >)) {\n                    struct timeval delta;\n\n                    timersub(&pkthdr_ptr->ts, &last_pkt_ts, &delta);\n                    timeradd(&stats->pkt_ts_delta, &delta, &stats->pkt_ts_delta);\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr_ptr->ts);\n                }\n\n                if (!timerisset(&stats->time_delta))\n                    TIMEVAL_SET(&stats->pkt_ts_delta, &stats->pkt_ts_delta);\n            }\n\n            if (!top_speed) {\n                gettimeofday(&now, NULL);\n                now_is_now = true;\n            }\n\n            /*\n             * Only if the current packet is not late.\n             *\n             * This also sets skip_length and skip_packets which will avoid\n             * timestamping for a given number of packets.\n             */\n            calc_sleep_time(ctx, &stats->pkt_ts_delta, &stats->time_delta,\n                    pktlen, sp, packetnum, &stats->end_time,\n                    TIMEVAL_TO_MICROSEC(&stats->start_time), &skip_length);\n\n            /*\n             * Track the time of the \"last packet sent\".\n             *\n             * A number of 3rd party tools generate bad timestamps which go backwards\n             * in time.  Hence, don't update the \"last\" unless pkthdr.ts > last\n             */\n            if (timercmp(&stats->time_delta, &stats->pkt_ts_delta, <))\n                TIMEVAL_SET(&stats->time_delta, &stats->pkt_ts_delta);\n\n            /*\n             * we know how long to sleep between sends, now do it.\n             */\n            if (!top_speed)\n                tcpr_sleep(ctx, sp, &ctx->nap, &now);\n        }\n\n#ifdef ENABLE_VERBOSE\n        /* do we need to print the packet via tcpdump? */\n        if (options->verbose)\n            tcpdump_print(options->tcpdump, pkthdr_ptr, pktdata);\n#endif\n\n        dbgx(2, \"Sending packet #\" COUNTER_SPEC, packetnum);\n        /* write packet out on network */\n        if (sendpacket(sp, pktdata, pktlen, pkthdr_ptr) < (int)pktlen) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(sp));\n            break;\n        }\n\n        /*\n         * Mark the time when we sent the last packet\n         */\n        TIMEVAL_SET(&stats->end_time, &now);\n\n        ++stats->pkts_sent;\n        stats->bytes_sent += pktlen;\n\n        /* print stats during the run? */\n        if (options->stats > 0) {\n            if (! timerisset(&stats->last_print)) {\n                TIMEVAL_SET(&stats->last_print, &now);\n            } else {\n                timersub(&now, &stats->last_print, &print_delta);\n                if (print_delta.tv_sec >= options->stats) {\n                    TIMEVAL_SET(&stats->end_time, &now);\n                    packet_stats(stats);\n                    TIMEVAL_SET(&stats->last_print, &now);\n                }\n            }\n        }\n\n#if defined HAVE_NETMAP\n        if (sp->first_packet || timesisset(&ctx->nap)) {\n            wake_send_queues(sp, options);\n            sp->first_packet = false;\n        }\n#endif\n\n        /* get the next packet for this file handle depending on which we last used */\n        if (sp == ctx->intf2) {\n            pktdata2 = get_next_packet(ctx, pcap2, &pkthdr2, cache_file_idx2, prev_packet2);\n        } else {\n            pktdata1 = get_next_packet(ctx, pcap1, &pkthdr1, cache_file_idx1, prev_packet1);\n        }\n\n        /* stop sending based on the duration limit... */\n        if ((end_us > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&now) > end_us) ||\n                /* ... or stop sending based on the limit -L? */\n                (limit_send > 0 && stats->pkts_sent >= limit_send)) {\n            ctx->abort = true;\n        }\n    } /* while */\n\n#ifdef HAVE_NETMAP\n    /* when completing test, wait until the last packet is sent */\n    if (options->netmap && (ctx->abort || options->loop == 1)) {\n        while (ctx->intf1 && !netmap_tx_queues_empty(ctx->intf1)) {\n            gettimeofday(&now, NULL);\n            now_is_now = true;\n        }\n\n        while (ctx->intf2 && !netmap_tx_queues_empty(ctx->intf2)) {\n            gettimeofday(&now, NULL);\n            now_is_now = true;\n        }\n    }\n#endif /* HAVE_NETMAP */\n\n    if (!now_is_now)\n        gettimeofday(&now, NULL);\n\n    TIMEVAL_SET(&stats->end_time, &now);\n\n    increment_iteration(ctx);\n}",
  "abstract_func": "void\nsend_dual_packets(tcpreplay_t *VAR_0, pcap_t *VAR_1, int VAR_2, pcap_t *VAR_3, int VAR_4)\n{\n    struct timeval VAR_5, VAR_6, VAR_7;\n    tcpreplay_opt_t *VAR_8 = VAR_0->options;\n    tcpreplay_stats_t *VAR_9 = &VAR_0->stats;\n    COUNTER VAR_10 = 0;\n    COUNTER VAR_11 = VAR_8->limit_send;\n    int VAR_12;\n    struct pcap_pkthdr VAR_13, VAR_14;\n    u_char *VAR_15 = NULL, *VAR_16 = NULL, *VAR_17 = NULL;\n    sendpacket_t *VAR_18;\n    COUNTER VAR_19;\n    packet_cache_t *VAR_20 = NULL, *VAR_21 = NULL;\n    packet_cache_t **VAR_22 = NULL, **VAR_23 = NULL;\n    struct pcap_pkthdr *VAR_24;\n    int VAR_25;\n    COUNTER VAR_26;\n    COUNTER VAR_27 = 0;\n    bool VAR_28 = (VAR_8->speed.mode == VAR_29 ||\n            (VAR_8->speed.mode == VAR_30 && VAR_8->speed.speed == 0));\n    bool VAR_31 = true;\n\n    gettimeofday(&VAR_6, NULL);\n    if (!timerisset(&VAR_9->start_time)) {\n        TIMEVAL_SET(&VAR_9->start_time, &VAR_6);\n        if (VAR_0->options->stats >= 0) {\n            char VAR_32[64];\n            if (format_date_time(&VAR_9->start_time, VAR_32, sizeof(VAR_32)) > 0)\n                printf(\"Dual test start: %s ...\\n\", VAR_32);\n        }\n    }\n\n    VAR_0->skip_packets = 0;\n    timerclear(&VAR_7);\n    if (VAR_8->limit_time > 0)\n        VAR_26 = TIMEVAL_TO_MICROSEC(&VAR_9->start_time) +\n            SEC_TO_MICROSEC(VAR_8->limit_time);\n    else\n        VAR_26 = 0;\n\n    if (VAR_8->preload_pcap) {\n        VAR_22 = &VAR_20;\n        VAR_23 = &VAR_21;\n    } else {\n        VAR_22 = NULL;\n        VAR_23 = NULL;\n    }\n\n    VAR_15 = get_next_packet(VAR_0, VAR_1, &VAR_13, VAR_2, VAR_22);\n    VAR_16 = get_next_packet(VAR_0, VAR_3, &VAR_14, VAR_4, VAR_23);\n\n    /* COMMENT_0 */\n                                                  \n                                \n       \n    while (!VAR_0->abort &&\n            !(VAR_15 == NULL && VAR_16 == NULL)) {\n\n        VAR_31 = false;\n        VAR_10++;\n\n        /* COMMENT_4 */\n                                                                       \n                                                                       \n                                                                      \n                           \n           \n        if (VAR_15 == NULL) {\n            /* COMMENT_10 */\n            VAR_18 = VAR_0->intf2;\n            VAR_25 = VAR_8->file_cache[VAR_4].dlt;\n            VAR_24 = &VAR_14;\n            VAR_12 = VAR_4;\n            VAR_17 = VAR_16;\n        } else if (VAR_16 == NULL) {\n            /* COMMENT_11 */\n            VAR_18 = VAR_0->intf1;\n            VAR_25 = VAR_8->file_cache[VAR_2].dlt;\n            VAR_24 = &VAR_13;\n            VAR_12 = VAR_2;\n            VAR_17 = VAR_15;\n        } else if (timercmp(&VAR_13.ts, &VAR_14.ts, <=)) {\n            /* COMMENT_11 */\n            VAR_18 = VAR_0->intf1;\n            VAR_25 = VAR_8->file_cache[VAR_2].dlt;\n            VAR_24 = &VAR_13;\n            VAR_12 = VAR_2;\n            VAR_17 = VAR_15;\n        } else {\n            /* COMMENT_10 */\n            VAR_18 = VAR_0->intf2;\n            VAR_25 = VAR_8->file_cache[VAR_4].dlt;\n            VAR_24 = &VAR_14;\n            VAR_12 = VAR_4;\n            VAR_17 = VAR_16;\n        }\n\n#if defined VAR_33 || defined VAR_34\n        /* COMMENT_12 */\n        VAR_19 = VAR_8->use_pkthdr_len ? (COUNTER)VAR_24->len : (COUNTER)VAR_24->caplen;\n#elif VAR_35\n        VAR_19 = (COUNTER)VAR_24->caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" VAR_36 \" caplen \" VAR_36, VAR_10, VAR_19);\n\n#if defined VAR_33 && defined VAR_34\n        if (tcpedit_packet(VAR_37, &VAR_24, &VAR_17, VAR_18->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" VAR_36 \": %s\", VAR_10, tcpedit_geterr(VAR_37));\n        }\n        VAR_19 = VAR_8->use_pkthdr_len ? (COUNTER)VAR_24->len : (COUNTER)VAR_24->caplen;\n#endif\n\n        if (VAR_0->options->unique_ip && VAR_0->unique_iteration &&\n                VAR_0->unique_iteration > VAR_0->last_unique_iteration) {\n            /* COMMENT_13 */\n            if (fast_edit_packet(VAR_24, &VAR_17, VAR_0->unique_iteration - 1,\n                    VAR_8->file_cache[VAR_12].cached, VAR_25) == -1) {\n                ++VAR_9->failed;\n                continue;\n            }\n        }\n\n        /* COMMENT_14 */\n        if (VAR_8->flow_stats && !VAR_8->file_cache[VAR_12].cached)\n            update_flow_stats(VAR_0, VAR_18, VAR_24, VAR_17, VAR_25);\n\n        /* COMMENT_15 */\n                                                                      \n                                                                        \n                  \n           \n        if (VAR_27 && VAR_19 < VAR_27) {\n            VAR_27 -= VAR_19;\n        } else if (VAR_0->skip_packets) {\n            --VAR_0->skip_packets;\n        } else {\n            /* COMMENT_20 */\n                                                         \n                             \n               \n            dbgx(4, \"This packet time: \" VAR_38, VAR_24->ts.tv_sec,\n                    VAR_24->ts.tv_usec);\n            VAR_27 = 0;\n            VAR_0->skip_packets = 0;\n\n            if (VAR_8->speed.mode == VAR_39) {\n                if (!timerisset(&VAR_7)) {\n                    TIMEVAL_SET(&VAR_7, &VAR_24->ts);\n                } else if (timercmp(&VAR_24->ts, &VAR_7, >)) {\n                    struct timeval VAR_40;\n\n                    timersub(&VAR_24->ts, &VAR_7, &VAR_40);\n                    timeradd(&VAR_9->pkt_ts_delta, &VAR_40, &VAR_9->pkt_ts_delta);\n                    TIMEVAL_SET(&VAR_7, &VAR_24->ts);\n                }\n\n                if (!timerisset(&VAR_9->time_delta))\n                    TIMEVAL_SET(&VAR_9->pkt_ts_delta, &VAR_9->pkt_ts_delta);\n            }\n\n            if (!VAR_28) {\n                gettimeofday(&VAR_6, NULL);\n                VAR_31 = true;\n            }\n\n            /* COMMENT_24 */\n                                                      \n              \n                                                                           \n                                                          \n               \n            calc_sleep_time(VAR_0, &VAR_9->pkt_ts_delta, &VAR_9->time_delta,\n                    VAR_19, VAR_18, VAR_10, &VAR_9->end_time,\n                    TIMEVAL_TO_MICROSEC(&VAR_9->start_time), &VAR_27);\n\n            /* COMMENT_30 */\n                                                        \n              \n                                                                                     \n                                                                               \n               \n            if (timercmp(&VAR_9->time_delta, &VAR_9->pkt_ts_delta, <))\n                TIMEVAL_SET(&VAR_9->time_delta, &VAR_9->pkt_ts_delta);\n\n            /* COMMENT_36 */\n                                                                  \n               \n            if (!VAR_28)\n                tcpr_sleep(VAR_0, VAR_18, &VAR_0->nap, &VAR_6);\n        }\n\n#ifdef VAR_41\n        /* COMMENT_39 */\n        if (VAR_8->verbose)\n            tcpdump_print(VAR_8->tcpdump, VAR_24, VAR_17);\n#endif\n\n        dbgx(2, \"Sending packet #\" VAR_36, VAR_10);\n        /* COMMENT_40 */\n        if (sendpacket(VAR_18, VAR_17, VAR_19, VAR_24) < (int)VAR_19) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(VAR_18));\n            break;\n        }\n\n        /* COMMENT_41 */\n                                                     \n           \n        TIMEVAL_SET(&VAR_9->end_time, &VAR_6);\n\n        ++VAR_9->pkts_sent;\n        VAR_9->bytes_sent += VAR_19;\n\n        /* COMMENT_44 */\n        if (VAR_8->stats > 0) {\n            if (! timerisset(&VAR_9->last_print)) {\n                TIMEVAL_SET(&VAR_9->last_print, &VAR_6);\n            } else {\n                timersub(&VAR_6, &VAR_9->last_print, &VAR_5);\n                if (VAR_5.tv_sec >= VAR_8->stats) {\n                    TIMEVAL_SET(&VAR_9->end_time, &VAR_6);\n                    packet_stats(VAR_9);\n                    TIMEVAL_SET(&VAR_9->last_print, &VAR_6);\n                }\n            }\n        }\n\n#if defined VAR_42\n        if (VAR_18->first_packet || timesisset(&VAR_0->nap)) {\n            wake_send_queues(VAR_18, VAR_8);\n            VAR_18->first_packet = false;\n        }\n#endif\n\n        /* COMMENT_45 */\n        if (VAR_18 == VAR_0->intf2) {\n            VAR_16 = get_next_packet(VAR_0, VAR_3, &VAR_14, VAR_4, VAR_23);\n        } else {\n            VAR_15 = get_next_packet(VAR_0, VAR_1, &VAR_13, VAR_2, VAR_22);\n        }\n\n        /* COMMENT_46 */\n        if ((VAR_26 > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&VAR_6) > VAR_26) ||\n                /* COMMENT_47 */\n                (VAR_11 > 0 && VAR_9->pkts_sent >= VAR_11)) {\n            VAR_0->abort = true;\n        }\n    } /* COMMENT_48 */\n\n#ifdef VAR_42\n    /* COMMENT_49 */\n    if (VAR_8->netmap && (VAR_0->abort || VAR_8->loop == 1)) {\n        while (VAR_0->intf1 && !netmap_tx_queues_empty(VAR_0->intf1)) {\n            gettimeofday(&VAR_6, NULL);\n            VAR_31 = true;\n        }\n\n        while (VAR_0->intf2 && !netmap_tx_queues_empty(VAR_0->intf2)) {\n            gettimeofday(&VAR_6, NULL);\n            VAR_31 = true;\n        }\n    }\n#endif /* COMMENT_50 */\n\n    if (!VAR_31)\n        gettimeofday(&VAR_6, NULL);\n\n    TIMEVAL_SET(&VAR_9->end_time, &VAR_6);\n\n    increment_iteration(VAR_0);\n}",
  "func_graph_path": "appneta/tcpreplay/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f/send_packets.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -117,8 +117,11 @@\n         if (ctx->options->unique_ip && ctx->unique_iteration &&\n                 ctx->unique_iteration > ctx->last_unique_iteration) {\n             /* edit packet to ensure every pass is unique */\n-            fast_edit_packet(pkthdr_ptr, &pktdata, ctx->unique_iteration - 1,\n-                    options->file_cache[cache_file_idx].cached, datalink);\n+            if (fast_edit_packet(pkthdr_ptr, &pktdata, ctx->unique_iteration - 1,\n+                    options->file_cache[cache_file_idx].cached, datalink) == -1) {\n+                ++stats->failed;\n+                continue;\n+            }\n         }\n \n         /* update flow stats */\n@@ -208,7 +211,7 @@\n          */\n         TIMEVAL_SET(&stats->end_time, &now);\n \n-        stats->pkts_sent++;\n+        ++stats->pkts_sent;\n         stats->bytes_sent += pktlen;\n \n         /* print stats during the run? */",
  "diff_line_info": {
    "deleted_lines": [
      "            fast_edit_packet(pkthdr_ptr, &pktdata, ctx->unique_iteration - 1,",
      "                    options->file_cache[cache_file_idx].cached, datalink);",
      "        stats->pkts_sent++;"
    ],
    "added_lines": [
      "            if (fast_edit_packet(pkthdr_ptr, &pktdata, ctx->unique_iteration - 1,",
      "                    options->file_cache[cache_file_idx].cached, datalink) == -1) {",
      "                ++stats->failed;",
      "                continue;",
      "            }",
      "        ++stats->pkts_sent;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/640",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/appneta/tcpreplay/pull/640: 403 Client Error: Forbidden for url: https://api.github.com/repos/appneta/tcpreplay/pulls/640",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9"
}