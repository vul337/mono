{
  "cve_id": "CVE-2023-39949",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "eProsima/Fast-DDS",
  "commit_msg": "fix typo\n\nSigned-off-by: Seulbae Kim <squizz617@gmail.com>",
  "commit_hash": "4382b5dfd02a42ba5d1a25038c78079c24a05638",
  "git_url": "https://github.com/eProsima/Fast-DDS/commit/4382b5dfd02a42ba5d1a25038c78079c24a05638",
  "file_path": "src/cpp/rtps/messages/MessageReceiver.cpp",
  "func_name": "MessageReceiver::proc_Submsg_Heartbeat",
  "func_before": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool finalFlag = (smh->flags & BIT(1)) != 0;\n    bool livelinessFlag = (smh->flags & BIT(2)) != 0;\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    GUID_t readerGUID;\n    GUID_t writerGUID;\n    readerGUID.guidPrefix = dest_guid_prefix_;\n    CDRMessage::readEntityId(msg, &readerGUID.entityId);\n    writerGUID.guidPrefix = source_guid_prefix_;\n    CDRMessage::readEntityId(msg, &writerGUID.entityId);\n    SequenceNumber_t firstSN;\n    SequenceNumber_t lastSN;\n    CDRMessage::readSequenceNumber(msg, &firstSN);\n    CDRMessage::readSequenceNumber(msg, &lastSN);\n\n    SequenceNumber_t zeroSN;\n    if (fisrtSN <= zeroSN)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \" <= 0), ignoring\");\n        return false;\n    }\n    if (lastSN < firstSN && lastSN != firstSN - 1)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \") - (\" <<\n                lastSN << \"), ignoring\");\n        return false;\n    }\n    uint32_t HBCount;\n    if (!CDRMessage::readUInt32(msg, &HBCount))\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    //Look for the correct reader and writers:\n    findAllReaders(readerGUID.entityId,\n            [&writerGUID, &HBCount, &firstSN, &lastSN, finalFlag, livelinessFlag](RTPSReader* reader)\n            {\n                reader->processHeartbeatMsg(writerGUID, HBCount, firstSN, lastSN, finalFlag, livelinessFlag);\n            });\n\n    return true;\n}",
  "abstract_func_before": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* VAR_0,\n        SubmessageHeader_t* VAR_1) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool VAR_2 = (VAR_1->flags & BIT(0)) != 0;\n    bool VAR_3 = (VAR_1->flags & BIT(1)) != 0;\n    bool VAR_4 = (VAR_1->flags & BIT(2)) != 0;\n    /* COMMENT_0 */\n    if (VAR_2)\n    {\n        VAR_0->msg_endian = VAR_5;\n    }\n    else\n    {\n        VAR_0->msg_endian = VAR_6;\n    }\n\n    GUID_t VAR_7;\n    GUID_t VAR_8;\n    VAR_7.guidPrefix = VAR_9;\n    CDRMessage::readEntityId(VAR_0, &VAR_7.entityId);\n    VAR_8.guidPrefix = VAR_10;\n    CDRMessage::readEntityId(VAR_0, &VAR_8.entityId);\n    SequenceNumber_t VAR_11;\n    SequenceNumber_t VAR_12;\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_11);\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_12);\n\n    SequenceNumber_t VAR_13;\n    if (VAR_14 <= VAR_13)\n    {\n        EPROSIMA_LOG_WARNING(VAR_15, VAR_16 \"Invalid Heartbeat received (\" << VAR_11 << \" <= 0), ignoring\");\n        return false;\n    }\n    if (VAR_12 < VAR_11 && VAR_12 != VAR_11 - 1)\n    {\n        EPROSIMA_LOG_WARNING(VAR_15, VAR_16 \"Invalid Heartbeat received (\" << VAR_11 << \") - (\" <<\n                VAR_12 << \"), ignoring\");\n        return false;\n    }\n    uint32_t VAR_17;\n    if (!CDRMessage::readUInt32(VAR_0, &VAR_17))\n    {\n        EPROSIMA_LOG_WARNING(VAR_15, VAR_16 \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    /* COMMENT_1 */\n    findAllReaders(VAR_7.entityId,\n            [&VAR_8, &VAR_17, &VAR_11, &VAR_12, VAR_3, VAR_4](RTPSReader* VAR_18)\n            {\n                VAR_18->processHeartbeatMsg(VAR_8, VAR_17, VAR_11, VAR_12, VAR_3, VAR_4);\n            });\n\n    return true;\n}",
  "func_graph_path_before": "eProsima/Fast-DDS/4382b5dfd02a42ba5d1a25038c78079c24a05638/MessageReceiver.cpp/vul/before/0.json",
  "func": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool finalFlag = (smh->flags & BIT(1)) != 0;\n    bool livelinessFlag = (smh->flags & BIT(2)) != 0;\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    GUID_t readerGUID;\n    GUID_t writerGUID;\n    readerGUID.guidPrefix = dest_guid_prefix_;\n    CDRMessage::readEntityId(msg, &readerGUID.entityId);\n    writerGUID.guidPrefix = source_guid_prefix_;\n    CDRMessage::readEntityId(msg, &writerGUID.entityId);\n    SequenceNumber_t firstSN;\n    SequenceNumber_t lastSN;\n    CDRMessage::readSequenceNumber(msg, &firstSN);\n    CDRMessage::readSequenceNumber(msg, &lastSN);\n\n    SequenceNumber_t zeroSN;\n    if (firstSN <= zeroSN)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \" <= 0), ignoring\");\n        return false;\n    }\n    if (lastSN < firstSN && lastSN != firstSN - 1)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \") - (\" <<\n                lastSN << \"), ignoring\");\n        return false;\n    }\n    uint32_t HBCount;\n    if (!CDRMessage::readUInt32(msg, &HBCount))\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    //Look for the correct reader and writers:\n    findAllReaders(readerGUID.entityId,\n            [&writerGUID, &HBCount, &firstSN, &lastSN, finalFlag, livelinessFlag](RTPSReader* reader)\n            {\n                reader->processHeartbeatMsg(writerGUID, HBCount, firstSN, lastSN, finalFlag, livelinessFlag);\n            });\n\n    return true;\n}",
  "abstract_func": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* VAR_0,\n        SubmessageHeader_t* VAR_1) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool VAR_2 = (VAR_1->flags & BIT(0)) != 0;\n    bool VAR_3 = (VAR_1->flags & BIT(1)) != 0;\n    bool VAR_4 = (VAR_1->flags & BIT(2)) != 0;\n    /* COMMENT_0 */\n    if (VAR_2)\n    {\n        VAR_0->msg_endian = VAR_5;\n    }\n    else\n    {\n        VAR_0->msg_endian = VAR_6;\n    }\n\n    GUID_t VAR_7;\n    GUID_t VAR_8;\n    VAR_7.guidPrefix = VAR_9;\n    CDRMessage::readEntityId(VAR_0, &VAR_7.entityId);\n    VAR_8.guidPrefix = VAR_10;\n    CDRMessage::readEntityId(VAR_0, &VAR_8.entityId);\n    SequenceNumber_t VAR_11;\n    SequenceNumber_t VAR_12;\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_11);\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_12);\n\n    SequenceNumber_t VAR_13;\n    if (VAR_11 <= VAR_13)\n    {\n        EPROSIMA_LOG_WARNING(VAR_14, VAR_15 \"Invalid Heartbeat received (\" << VAR_11 << \" <= 0), ignoring\");\n        return false;\n    }\n    if (VAR_12 < VAR_11 && VAR_12 != VAR_11 - 1)\n    {\n        EPROSIMA_LOG_WARNING(VAR_14, VAR_15 \"Invalid Heartbeat received (\" << VAR_11 << \") - (\" <<\n                VAR_12 << \"), ignoring\");\n        return false;\n    }\n    uint32_t VAR_16;\n    if (!CDRMessage::readUInt32(VAR_0, &VAR_16))\n    {\n        EPROSIMA_LOG_WARNING(VAR_14, VAR_15 \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    /* COMMENT_1 */\n    findAllReaders(VAR_7.entityId,\n            [&VAR_8, &VAR_16, &VAR_11, &VAR_12, VAR_3, VAR_4](RTPSReader* VAR_17)\n            {\n                VAR_17->processHeartbeatMsg(VAR_8, VAR_16, VAR_11, VAR_12, VAR_3, VAR_4);\n            });\n\n    return true;\n}",
  "func_graph_path": "eProsima/Fast-DDS/4382b5dfd02a42ba5d1a25038c78079c24a05638/MessageReceiver.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n     CDRMessage::readSequenceNumber(msg, &lastSN);\n \n     SequenceNumber_t zeroSN;\n-    if (fisrtSN <= zeroSN)\n+    if (firstSN <= zeroSN)\n     {\n         EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \" <= 0), ignoring\");\n         return false;",
  "diff_line_info": {
    "deleted_lines": [
      "    if (fisrtSN <= zeroSN)"
    ],
    "added_lines": [
      "    if (firstSN <= zeroSN)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eProsima/Fast-DDS/pull/3274",
  "description": {
    "pr_info": {
      "title": "Implement a validity check for firstSN",
      "number": 3274
    },
    "comment": [
      "This commit suggests a fix for issue #3236.\r\n\r\n## Description\r\n\r\nAs per 8.3.8.6.3 of DDS-RTPS 2.5, \"Heartbeat submessage is invalid if firstSN.value is zero or negative\". However, a check for this property is missing. This leads to an assertion failure when an invalid firstSN is provided (see issue #3236).\r\n\r\n<!--\r\n    In case of bug fixes, please provide the list of supported branches where this fix should be also merged.\r\n    Please uncomment following line, adjusting the corresponding target branches for the backport.\r\n-->\r\n@Mergifyio backport 2.9.x\r\n\r\n<!-- If an issue is already opened, please uncomment next line with the corresponding issue number. -->\r\nFixes #3236 \r\n\r\n<!-- In case the changes are built over a previous pull request, please uncomment next line. -->\r\n<!-- This PR depends on #(PR) and must be merged after that one. -->\r\n\r\n## Contributor Checklist\r\n- [x] Commit messages follow the project guidelines. <!-- External contributors should sign the DCO. Fast DDS developers must also refer to the internal Redmine task. -->\r\n- [x] The code follows the style guidelines of this project. <!-- Please refer to the [Quality Declaration](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md#linters-and-static-analysis-4v) for more information. -->\r\n- [x] Tests that thoroughly check the new feature have been added/Regression tests checking the bug and its fix have been added; the added tests pass locally -> \r\n- (N/A) Any new/modified methods have been properly documented using Doxygen. <!-- Even internal classes, and private methods and members should be documented, not only the public API. -->\r\n- (N/A) Changes are ABI compatible. <!-- Bug fixes should be ABI compatible if possible so a backport to previous affected releases can be made. -->\r\n- (N/A) Changes are API compatible. <!-- Public API must not be broken within the same major release. -->\r\n- (N/A) Documentation builds and tests pass locally. <!-- Check there are no typos in the Doxygen documentation. -->\r\n- (N/A) New feature has been added to the `versions.md` file (if applicable).\r\n- (N/A) New feature has been documented/Current behavior is correctly described in the documentation. <!-- Please uncomment following line with the corresponding PR to the documentation project: -->\r\n<!-- Related documentation PR: eProsima/Fast-DDS-docs# (PR) -->\r\n- [x] Applicable backports have been included in the description.\r\n\r\n\r\n## Reviewer Checklist\r\n- [ ] Check contributor checklist is correct.\r\n- [x] Check CI results: changes do not issue any warning.\r\n- [x] Check CI results: failing tests are unrelated with the changes.\r\n",
      "Sorry, made a mistake while moving stuffs into the pr branch :(\r\nFixed and pushed!",
      "Hi @MiguelCompany, I'm just wondering if you've looked at the changes. Thank you.",
      "> Hi @MiguelCompany, I'm just wondering if you've looked at the changes. Thank you.\r\n\r\n@squizz617 Changes look good to me. Is it possible that you could add a regression test for this?\r\n\r\nI think that adding a new file [here](https://github.com/eProsima/Fast-DDS/tree/master/fuzz/C%2B%2B/fuzz_processCDRMsg/fuzz_processCDRMsg_seed_corpus) would be enough",
      "@MiguelCompany Done! I temporarily named the file `input_issue3236`, but please change it if needed.",
      "@richiprosima Please test this",
      "@mergifyio backport 2.9.x 2.8.x 2.6.x",
      "> backport 2.9.x 2.8.x 2.6.x\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#3382 Implement a validity check for firstSN (backport #3274)](https://github.com/eProsima/Fast-DDS/pull/3382) has been created for branch `2.9.x`\n* [#3383 Implement a validity check for firstSN (backport #3274)](https://github.com/eProsima/Fast-DDS/pull/3383) has been created for branch `2.8.x`\n* [#3384 Implement a validity check for firstSN (backport #3274)](https://github.com/eProsima/Fast-DDS/pull/3384) has been created for branch `2.6.x`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport 2.9.x 2.8.x 2.6.x\", \"conclusion\": \"success\"}\n-*- Mergify Payload End -*-\n-->"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}