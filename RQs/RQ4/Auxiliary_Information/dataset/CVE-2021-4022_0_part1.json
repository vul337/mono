{
  "cve_id": "CVE-2021-4022",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "rizinorg/rizin",
  "commit_msg": "Initialize retctx,ctx before freeing the inner elements\n\nIn rz_core_analysis_type_match retctx structure was initialized on the\nstack only after a \"goto out_function\", where a field of that structure\nwas freed. When the goto path is taken, the field is not properly\ninitialized and it cause cause a crash of Rizin or have other effects.\n\nFixes: CVE-2021-4022",
  "commit_hash": "2c110dd84a698cb77dfb30a9bc04e9915362724f",
  "git_url": "https://github.com/rizinorg/rizin/commit/2c110dd84a698cb77dfb30a9bc04e9915362724f",
  "file_path": "librz/core/analysis_tp.c",
  "func_name": "rz_core_analysis_type_match",
  "func_before": "RZ_API void rz_core_analysis_type_match(RzCore *core, RzAnalysisFunction *fcn, HtUU *loop_table) {\n\tRzListIter *it;\n\n\trz_return_if_fail(core && core->analysis && fcn);\n\n\tif (!core->analysis->esil) {\n\t\teprintf(\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRzAnalysis *analysis = core->analysis;\n\tconst int mininstrsz = rz_analysis_archinfo(analysis, RZ_ANALYSIS_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = RZ_MAX(1, mininstrsz);\n\tRzConfigHold *hc = rz_config_hold_new(core->config);\n\tif (!hc) {\n\t\treturn;\n\t}\n\tRzDebugTrace *dt = NULL;\n\tRzAnalysisEsilTrace *et = NULL;\n\tRzAnalysisRzilTrace *rt = NULL;\n\tif (!analysis_emul_init(core, hc, &dt, &et, &rt) || !fcn) {\n\t\tanalysis_emul_restore(core, hc, dt, et, rt);\n\t\treturn;\n\t}\n\n\t// Reserve bigger ht to avoid rehashing\n\tHtPPOptions opt;\n\tRzDebugTrace *dtrace = core->dbg->trace;\n\topt = dtrace->ht->opt;\n\tht_pp_free(dtrace->ht);\n\tdtrace->ht = ht_pp_new_size(fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tdtrace->ht->opt = opt;\n\n\tHtUP *op_cache = NULL;\n\tconst char *pc = rz_reg_get_name(core->dbg->reg, RZ_REG_NAME_PC);\n\tif (!pc) {\n\t\tgoto out_function;\n\t}\n\tRzRegItem *r = rz_reg_get(core->dbg->reg, pc, -1);\n\tif (!r) {\n\t\tgoto out_function;\n\t}\n\trz_cons_break_push(NULL, NULL);\n\trz_list_sort(fcn->bbs, bb_cmpaddr);\n\t// TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address\n\tRzAnalysisBlock *bb;\n\t// Create a new context to store the return type propagation state\n\tstruct ReturnTypeAnalysisCtx retctx = {\n\t\t.resolved = false,\n\t\t.ret_type = NULL,\n\t\t.ret_reg = NULL\n\t};\n\tstruct TypeAnalysisCtx ctx = {\n\t\t.retctx = &retctx,\n\t\t.cur_idx = 0,\n\t\t.prev_dest = NULL,\n\t\t.str_flag = false\n\t};\n\trz_list_foreach (fcn->bbs, it, bb) {\n\t\tut64 addr = bb->addr;\n\t\trz_reg_set_value(core->dbg->reg, r, addr);\n\t\tht_up_free(op_cache);\n\t\top_cache = ht_up_new(NULL, free_op_cache_kv, NULL);\n\t\tif (!op_cache) {\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (rz_cons_is_breaked()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tut64 pcval = rz_reg_getv(analysis->reg, pc);\n\t\t\tif ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzAnalysisOp *aop = op_cache_get(op_cache, core, addr);\n\t\t\tif (!aop) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (aop->type == RZ_ANALYSIS_OP_TYPE_ILL) {\n\t\t\t\taddr += minopcode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// CHECK_ME : why we hold a loop_count here ?\n\t\t\t//          : can we remove it ?\n\t\t\t// when set null, do not track loop count\n\t\t\tif (loop_table) {\n\t\t\t\tut64 loop_count = ht_uu_find(loop_table, addr, NULL);\n\t\t\t\tif (loop_count > LOOP_MAX || aop->type == RZ_ANALYSIS_OP_TYPE_RET) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tloop_count += 1;\n\t\t\t\tht_uu_update(loop_table, addr, loop_count);\n\t\t\t}\n\n\t\t\tif (rz_analysis_op_nonlinear(aop->type)) { // skip the instr\n\t\t\t\trz_reg_set_value(core->dbg->reg, r, addr + aop->size);\n\t\t\t} else {\n\t\t\t\trz_core_esil_step(core, UT64_MAX, NULL, NULL, false);\n\t\t\t}\n\n\t\t\tRzPVector *ins_traces = analysis->esil->trace->instructions;\n\t\t\tctx.cur_idx = rz_pvector_len(ins_traces) - 1;\n\t\t\tRzList *fcns = rz_analysis_get_functions_in(analysis, aop->addr);\n\t\t\tif (!fcns) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzListIter *it;\n\t\t\tRzAnalysisFunction *fcn;\n\t\t\trz_list_foreach (fcns, it, fcn) {\n\t\t\t\tpropagate_types_among_used_variables(core, op_cache, fcn, bb, aop, &ctx);\n\t\t\t}\n\t\t\taddr += aop->size;\n\t\t\trz_list_free(fcns);\n\t\t}\n\t}\n\t// Type propagation for register based args\n\tvoid **vit;\n\trz_pvector_foreach (&fcn->vars, vit) {\n\t\tRzAnalysisVar *rvar = *vit;\n\t\tif (rvar->kind == RZ_ANALYSIS_VAR_KIND_REG) {\n\t\t\tRzAnalysisVar *lvar = rz_analysis_var_get_dst_var(rvar);\n\t\t\tRzRegItem *i = rz_reg_index_get(analysis->reg, rvar->delta);\n\t\t\tif (!i) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Note that every `var_type_set()` call could remove some variables\n\t\t\t// due to the overlaps resolution\n\t\t\tif (lvar) {\n\t\t\t\t// Propagate local var type = to => register-based var\n\t\t\t\tvar_type_set(analysis, rvar, lvar->type, false);\n\t\t\t\t// Propagate local var type <= from = register-based var\n\t\t\t\tvar_type_set(analysis, lvar, rvar->type, false);\n\t\t\t}\n\t\t}\n\t}\nout_function:\n\tfree(retctx.ret_reg);\n\tht_up_free(op_cache);\n\trz_cons_break_pop();\n\tanalysis_emul_restore(core, hc, dt, et, rt);\n}",
  "abstract_func_before": "RZ_API VAR_0 rz_core_analysis_type_match(RzCore *VAR_1, RzAnalysisFunction *VAR_2, HtUU *VAR_3) {\n\tRzListIter *VAR_4;\n\n\trz_return_if_fail(VAR_1 && VAR_1->analysis && VAR_2);\n\n\tif (!VAR_1->analysis->esil) {\n\t\teprintf(\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRzAnalysis *VAR_5 = VAR_1->analysis;\n\tconst int VAR_6 = rz_analysis_archinfo(VAR_5, VAR_7);\n\tconst int VAR_8 = RZ_MAX(1, VAR_6);\n\tRzConfigHold *VAR_9 = rz_config_hold_new(VAR_1->config);\n\tif (!VAR_9) {\n\t\treturn;\n\t}\n\tRzDebugTrace *VAR_10 = NULL;\n\tRzAnalysisEsilTrace *VAR_11 = NULL;\n\tRzAnalysisRzilTrace *VAR_12 = NULL;\n\tif (!analysis_emul_init(VAR_1, VAR_9, &VAR_10, &VAR_11, &VAR_12) || !VAR_2) {\n\t\tanalysis_emul_restore(VAR_1, VAR_9, VAR_10, VAR_11, VAR_12);\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tHtPPOptions VAR_13;\n\tRzDebugTrace *VAR_14 = VAR_1->dbg->trace;\n\tVAR_13 = VAR_14->ht->opt;\n\tht_pp_free(VAR_14->ht);\n\tVAR_14->ht = ht_pp_new_size(VAR_2->ninstr, VAR_13.dupvalue, VAR_13.freefn, VAR_13.calcsizeV);\n\tVAR_14->ht->opt = VAR_13;\n\n\tHtUP *VAR_15 = NULL;\n\tconst char *VAR_16 = rz_reg_get_name(VAR_1->dbg->reg, VAR_17);\n\tif (!VAR_16) {\n\t\tgoto out_function;\n\t}\n\tRzRegItem *VAR_18 = rz_reg_get(VAR_1->dbg->reg, VAR_16, -1);\n\tif (!VAR_18) {\n\t\tgoto out_function;\n\t}\n\trz_cons_break_push(NULL, NULL);\n\trz_list_sort(VAR_2->bbs, VAR_19);\n\t/* COMMENT_1 */\n\tRzAnalysisBlock *VAR_20;\n\t/* COMMENT_2 */\n\tstruct ReturnTypeAnalysisCtx VAR_21 = {\n\t\t.resolved = false,\n\t\t.ret_type = NULL,\n\t\t.ret_reg = NULL\n\t};\n\tstruct TypeAnalysisCtx VAR_22 = {\n\t\t.retctx = &VAR_21,\n\t\t.cur_idx = 0,\n\t\t.prev_dest = NULL,\n\t\t.str_flag = false\n\t};\n\trz_list_foreach (VAR_2->bbs, VAR_4, VAR_20) {\n\t\tut64 VAR_23 = VAR_20->addr;\n\t\trz_reg_set_value(VAR_1->dbg->reg, VAR_18, VAR_23);\n\t\tht_up_free(VAR_15);\n\t\tVAR_15 = ht_up_new(NULL, VAR_24, NULL);\n\t\tif (!VAR_15) {\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (rz_cons_is_breaked()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tut64 VAR_25 = rz_reg_getv(VAR_5->reg, VAR_16);\n\t\t\tif ((VAR_23 >= VAR_20->addr + VAR_20->size) || (VAR_23 < VAR_20->addr) || VAR_25 != VAR_23) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzAnalysisOp *VAR_26 = op_cache_get(VAR_15, VAR_1, VAR_23);\n\t\t\tif (!VAR_26) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (VAR_26->type == VAR_27) {\n\t\t\t\tVAR_23 += VAR_8;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* COMMENT_3 */\n\t\t\t/* COMMENT_4 */\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_3) {\n\t\t\t\tut64 VAR_28 = ht_uu_find(VAR_3, VAR_23, NULL);\n\t\t\t\tif (VAR_28 > VAR_29 || VAR_26->type == VAR_30) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_28 += 1;\n\t\t\t\tht_uu_update(VAR_3, VAR_23, VAR_28);\n\t\t\t}\n\n\t\t\tif (rz_analysis_op_nonlinear(VAR_26->type)) { /* COMMENT_6 */\n\t\t\t\trz_reg_set_value(VAR_1->dbg->reg, VAR_18, VAR_23 + VAR_26->size);\n\t\t\t} else {\n\t\t\t\trz_core_esil_step(VAR_1, VAR_31, NULL, NULL, false);\n\t\t\t}\n\n\t\t\tRzPVector *VAR_32 = VAR_5->esil->trace->instructions;\n\t\t\tVAR_22.cur_idx = rz_pvector_len(VAR_32) - 1;\n\t\t\tRzList *VAR_33 = rz_analysis_get_functions_in(VAR_5, VAR_26->addr);\n\t\t\tif (!VAR_33) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzListIter *VAR_4;\n\t\t\tRzAnalysisFunction *VAR_2;\n\t\t\trz_list_foreach (VAR_33, VAR_4, VAR_2) {\n\t\t\t\tpropagate_types_among_used_variables(VAR_1, VAR_15, VAR_2, VAR_20, VAR_26, &VAR_22);\n\t\t\t}\n\t\t\tVAR_23 += VAR_26->size;\n\t\t\trz_list_free(VAR_33);\n\t\t}\n\t}\n\t/* COMMENT_7 */\n\tvoid **VAR_34;\n\trz_pvector_foreach (&VAR_2->vars, VAR_34) {\n\t\tRzAnalysisVar *VAR_35 = *VAR_34;\n\t\tif (VAR_35->kind == VAR_36) {\n\t\t\tRzAnalysisVar *VAR_37 = rz_analysis_var_get_dst_var(VAR_35);\n\t\t\tRzRegItem *VAR_38 = rz_reg_index_get(VAR_5->reg, VAR_35->delta);\n\t\t\tif (!VAR_38) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n\t\t\t/* COMMENT_9 */\n\t\t\tif (VAR_37) {\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tvar_type_set(VAR_5, VAR_35, VAR_37->type, false);\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\tvar_type_set(VAR_5, VAR_37, VAR_35->type, false);\n\t\t\t}\n\t\t}\n\t}\nout_function:\n\tfree(VAR_21.ret_reg);\n\tht_up_free(VAR_15);\n\trz_cons_break_pop();\n\tanalysis_emul_restore(VAR_1, VAR_9, VAR_10, VAR_11, VAR_12);\n}",
  "func_graph_path_before": null,
  "func": "RZ_API void rz_core_analysis_type_match(RzCore *core, RzAnalysisFunction *fcn, HtUU *loop_table) {\n\tRzListIter *it;\n\n\trz_return_if_fail(core && core->analysis && fcn);\n\n\tif (!core->analysis->esil) {\n\t\teprintf(\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRzAnalysis *analysis = core->analysis;\n\tconst int mininstrsz = rz_analysis_archinfo(analysis, RZ_ANALYSIS_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = RZ_MAX(1, mininstrsz);\n\tRzConfigHold *hc = rz_config_hold_new(core->config);\n\tif (!hc) {\n\t\treturn;\n\t}\n\tRzDebugTrace *dt = NULL;\n\tRzAnalysisEsilTrace *et = NULL;\n\tRzAnalysisRzilTrace *rt = NULL;\n\tif (!analysis_emul_init(core, hc, &dt, &et, &rt) || !fcn) {\n\t\tanalysis_emul_restore(core, hc, dt, et, rt);\n\t\treturn;\n\t}\n\n\t// Reserve bigger ht to avoid rehashing\n\tHtPPOptions opt;\n\tRzDebugTrace *dtrace = core->dbg->trace;\n\topt = dtrace->ht->opt;\n\tht_pp_free(dtrace->ht);\n\tdtrace->ht = ht_pp_new_size(fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tdtrace->ht->opt = opt;\n\n\t// Create a new context to store the return type propagation state\n\tstruct ReturnTypeAnalysisCtx retctx = {\n\t\t.resolved = false,\n\t\t.ret_type = NULL,\n\t\t.ret_reg = NULL,\n\t};\n\tstruct TypeAnalysisCtx ctx = {\n\t\t.retctx = &retctx,\n\t\t.cur_idx = 0,\n\t\t.prev_dest = NULL,\n\t\t.str_flag = false\n\t};\n\n\tHtUP *op_cache = NULL;\n\tconst char *pc = rz_reg_get_name(core->dbg->reg, RZ_REG_NAME_PC);\n\tif (!pc) {\n\t\tgoto out_function;\n\t}\n\tRzRegItem *r = rz_reg_get(core->dbg->reg, pc, -1);\n\tif (!r) {\n\t\tgoto out_function;\n\t}\n\trz_cons_break_push(NULL, NULL);\n\trz_list_sort(fcn->bbs, bb_cmpaddr);\n\t// TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address\n\tRzAnalysisBlock *bb;\n\trz_list_foreach (fcn->bbs, it, bb) {\n\t\tut64 addr = bb->addr;\n\t\trz_reg_set_value(core->dbg->reg, r, addr);\n\t\tht_up_free(op_cache);\n\t\top_cache = ht_up_new(NULL, free_op_cache_kv, NULL);\n\t\tif (!op_cache) {\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (rz_cons_is_breaked()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tut64 pcval = rz_reg_getv(analysis->reg, pc);\n\t\t\tif ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzAnalysisOp *aop = op_cache_get(op_cache, core, addr);\n\t\t\tif (!aop) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (aop->type == RZ_ANALYSIS_OP_TYPE_ILL) {\n\t\t\t\taddr += minopcode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// CHECK_ME : why we hold a loop_count here ?\n\t\t\t//          : can we remove it ?\n\t\t\t// when set null, do not track loop count\n\t\t\tif (loop_table) {\n\t\t\t\tut64 loop_count = ht_uu_find(loop_table, addr, NULL);\n\t\t\t\tif (loop_count > LOOP_MAX || aop->type == RZ_ANALYSIS_OP_TYPE_RET) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tloop_count += 1;\n\t\t\t\tht_uu_update(loop_table, addr, loop_count);\n\t\t\t}\n\n\t\t\tif (rz_analysis_op_nonlinear(aop->type)) { // skip the instr\n\t\t\t\trz_reg_set_value(core->dbg->reg, r, addr + aop->size);\n\t\t\t} else {\n\t\t\t\trz_core_esil_step(core, UT64_MAX, NULL, NULL, false);\n\t\t\t}\n\n\t\t\tRzPVector *ins_traces = analysis->esil->trace->instructions;\n\t\t\tctx.cur_idx = rz_pvector_len(ins_traces) - 1;\n\t\t\tRzList *fcns = rz_analysis_get_functions_in(analysis, aop->addr);\n\t\t\tif (!fcns) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzListIter *it;\n\t\t\tRzAnalysisFunction *fcn;\n\t\t\trz_list_foreach (fcns, it, fcn) {\n\t\t\t\tpropagate_types_among_used_variables(core, op_cache, fcn, bb, aop, &ctx);\n\t\t\t}\n\t\t\taddr += aop->size;\n\t\t\trz_list_free(fcns);\n\t\t}\n\t}\n\t// Type propagation for register based args\n\tvoid **vit;\n\trz_pvector_foreach (&fcn->vars, vit) {\n\t\tRzAnalysisVar *rvar = *vit;\n\t\tif (rvar->kind == RZ_ANALYSIS_VAR_KIND_REG) {\n\t\t\tRzAnalysisVar *lvar = rz_analysis_var_get_dst_var(rvar);\n\t\t\tRzRegItem *i = rz_reg_index_get(analysis->reg, rvar->delta);\n\t\t\tif (!i) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Note that every `var_type_set()` call could remove some variables\n\t\t\t// due to the overlaps resolution\n\t\t\tif (lvar) {\n\t\t\t\t// Propagate local var type = to => register-based var\n\t\t\t\tvar_type_set(analysis, rvar, lvar->type, false);\n\t\t\t\t// Propagate local var type <= from = register-based var\n\t\t\t\tvar_type_set(analysis, lvar, rvar->type, false);\n\t\t\t}\n\t\t}\n\t}\nout_function:\n\tfree(retctx.ret_reg);\n\tht_up_free(op_cache);\n\trz_cons_break_pop();\n\tanalysis_emul_restore(core, hc, dt, et, rt);\n}",
  "abstract_func": "RZ_API VAR_0 rz_core_analysis_type_match(RzCore *VAR_1, RzAnalysisFunction *VAR_2, HtUU *VAR_3) {\n\tRzListIter *VAR_4;\n\n\trz_return_if_fail(VAR_1 && VAR_1->analysis && VAR_2);\n\n\tif (!VAR_1->analysis->esil) {\n\t\teprintf(\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRzAnalysis *VAR_5 = VAR_1->analysis;\n\tconst int VAR_6 = rz_analysis_archinfo(VAR_5, VAR_7);\n\tconst int VAR_8 = RZ_MAX(1, VAR_6);\n\tRzConfigHold *VAR_9 = rz_config_hold_new(VAR_1->config);\n\tif (!VAR_9) {\n\t\treturn;\n\t}\n\tRzDebugTrace *VAR_10 = NULL;\n\tRzAnalysisEsilTrace *VAR_11 = NULL;\n\tRzAnalysisRzilTrace *VAR_12 = NULL;\n\tif (!analysis_emul_init(VAR_1, VAR_9, &VAR_10, &VAR_11, &VAR_12) || !VAR_2) {\n\t\tanalysis_emul_restore(VAR_1, VAR_9, VAR_10, VAR_11, VAR_12);\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tHtPPOptions VAR_13;\n\tRzDebugTrace *VAR_14 = VAR_1->dbg->trace;\n\tVAR_13 = VAR_14->ht->opt;\n\tht_pp_free(VAR_14->ht);\n\tVAR_14->ht = ht_pp_new_size(VAR_2->ninstr, VAR_13.dupvalue, VAR_13.freefn, VAR_13.calcsizeV);\n\tVAR_14->ht->opt = VAR_13;\n\n\t/* COMMENT_1 */\n\tstruct ReturnTypeAnalysisCtx VAR_15 = {\n\t\t.resolved = false,\n\t\t.ret_type = NULL,\n\t\t.ret_reg = NULL,\n\t};\n\tstruct TypeAnalysisCtx VAR_16 = {\n\t\t.retctx = &VAR_15,\n\t\t.cur_idx = 0,\n\t\t.prev_dest = NULL,\n\t\t.str_flag = false\n\t};\n\n\tHtUP *VAR_17 = NULL;\n\tconst char *VAR_18 = rz_reg_get_name(VAR_1->dbg->reg, VAR_19);\n\tif (!VAR_18) {\n\t\tgoto out_function;\n\t}\n\tRzRegItem *VAR_20 = rz_reg_get(VAR_1->dbg->reg, VAR_18, -1);\n\tif (!VAR_20) {\n\t\tgoto out_function;\n\t}\n\trz_cons_break_push(NULL, NULL);\n\trz_list_sort(VAR_2->bbs, VAR_21);\n\t/* COMMENT_2 */\n\tRzAnalysisBlock *VAR_22;\n\trz_list_foreach (VAR_2->bbs, VAR_4, VAR_22) {\n\t\tut64 VAR_23 = VAR_22->addr;\n\t\trz_reg_set_value(VAR_1->dbg->reg, VAR_20, VAR_23);\n\t\tht_up_free(VAR_17);\n\t\tVAR_17 = ht_up_new(NULL, VAR_24, NULL);\n\t\tif (!VAR_17) {\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (rz_cons_is_breaked()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tut64 VAR_25 = rz_reg_getv(VAR_5->reg, VAR_18);\n\t\t\tif ((VAR_23 >= VAR_22->addr + VAR_22->size) || (VAR_23 < VAR_22->addr) || VAR_25 != VAR_23) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzAnalysisOp *VAR_26 = op_cache_get(VAR_17, VAR_1, VAR_23);\n\t\t\tif (!VAR_26) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (VAR_26->type == VAR_27) {\n\t\t\t\tVAR_23 += VAR_8;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* COMMENT_3 */\n\t\t\t/* COMMENT_4 */\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_3) {\n\t\t\t\tut64 VAR_28 = ht_uu_find(VAR_3, VAR_23, NULL);\n\t\t\t\tif (VAR_28 > VAR_29 || VAR_26->type == VAR_30) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_28 += 1;\n\t\t\t\tht_uu_update(VAR_3, VAR_23, VAR_28);\n\t\t\t}\n\n\t\t\tif (rz_analysis_op_nonlinear(VAR_26->type)) { /* COMMENT_6 */\n\t\t\t\trz_reg_set_value(VAR_1->dbg->reg, VAR_20, VAR_23 + VAR_26->size);\n\t\t\t} else {\n\t\t\t\trz_core_esil_step(VAR_1, VAR_31, NULL, NULL, false);\n\t\t\t}\n\n\t\t\tRzPVector *VAR_32 = VAR_5->esil->trace->instructions;\n\t\t\tVAR_16.cur_idx = rz_pvector_len(VAR_32) - 1;\n\t\t\tRzList *VAR_33 = rz_analysis_get_functions_in(VAR_5, VAR_26->addr);\n\t\t\tif (!VAR_33) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRzListIter *VAR_4;\n\t\t\tRzAnalysisFunction *VAR_2;\n\t\t\trz_list_foreach (VAR_33, VAR_4, VAR_2) {\n\t\t\t\tpropagate_types_among_used_variables(VAR_1, VAR_17, VAR_2, VAR_22, VAR_26, &VAR_16);\n\t\t\t}\n\t\t\tVAR_23 += VAR_26->size;\n\t\t\trz_list_free(VAR_33);\n\t\t}\n\t}\n\t/* COMMENT_7 */\n\tvoid **VAR_34;\n\trz_pvector_foreach (&VAR_2->vars, VAR_34) {\n\t\tRzAnalysisVar *VAR_35 = *VAR_34;\n\t\tif (VAR_35->kind == VAR_36) {\n\t\t\tRzAnalysisVar *VAR_37 = rz_analysis_var_get_dst_var(VAR_35);\n\t\t\tRzRegItem *VAR_38 = rz_reg_index_get(VAR_5->reg, VAR_35->delta);\n\t\t\tif (!VAR_38) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n\t\t\t/* COMMENT_9 */\n\t\t\tif (VAR_37) {\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tvar_type_set(VAR_5, VAR_35, VAR_37->type, false);\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\tvar_type_set(VAR_5, VAR_37, VAR_35->type, false);\n\t\t\t}\n\t\t}\n\t}\nout_function:\n\tfree(VAR_15.ret_reg);\n\tht_up_free(VAR_17);\n\trz_cons_break_pop();\n\tanalysis_emul_restore(VAR_1, VAR_9, VAR_10, VAR_11, VAR_12);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,19 @@\n \tdtrace->ht = ht_pp_new_size(fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);\n \tdtrace->ht->opt = opt;\n \n+\t// Create a new context to store the return type propagation state\n+\tstruct ReturnTypeAnalysisCtx retctx = {\n+\t\t.resolved = false,\n+\t\t.ret_type = NULL,\n+\t\t.ret_reg = NULL,\n+\t};\n+\tstruct TypeAnalysisCtx ctx = {\n+\t\t.retctx = &retctx,\n+\t\t.cur_idx = 0,\n+\t\t.prev_dest = NULL,\n+\t\t.str_flag = false\n+\t};\n+\n \tHtUP *op_cache = NULL;\n \tconst char *pc = rz_reg_get_name(core->dbg->reg, RZ_REG_NAME_PC);\n \tif (!pc) {\n@@ -44,18 +57,6 @@\n \trz_list_sort(fcn->bbs, bb_cmpaddr);\n \t// TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address\n \tRzAnalysisBlock *bb;\n-\t// Create a new context to store the return type propagation state\n-\tstruct ReturnTypeAnalysisCtx retctx = {\n-\t\t.resolved = false,\n-\t\t.ret_type = NULL,\n-\t\t.ret_reg = NULL\n-\t};\n-\tstruct TypeAnalysisCtx ctx = {\n-\t\t.retctx = &retctx,\n-\t\t.cur_idx = 0,\n-\t\t.prev_dest = NULL,\n-\t\t.str_flag = false\n-\t};\n \trz_list_foreach (fcn->bbs, it, bb) {\n \t\tut64 addr = bb->addr;\n \t\trz_reg_set_value(core->dbg->reg, r, addr);",
  "diff_line_info": {
    "deleted_lines": [
      "\t// Create a new context to store the return type propagation state",
      "\tstruct ReturnTypeAnalysisCtx retctx = {",
      "\t\t.resolved = false,",
      "\t\t.ret_type = NULL,",
      "\t\t.ret_reg = NULL",
      "\t};",
      "\tstruct TypeAnalysisCtx ctx = {",
      "\t\t.retctx = &retctx,",
      "\t\t.cur_idx = 0,",
      "\t\t.prev_dest = NULL,",
      "\t\t.str_flag = false",
      "\t};"
    ],
    "added_lines": [
      "\t// Create a new context to store the return type propagation state",
      "\tstruct ReturnTypeAnalysisCtx retctx = {",
      "\t\t.resolved = false,",
      "\t\t.ret_type = NULL,",
      "\t\t.ret_reg = NULL,",
      "\t};",
      "\tstruct TypeAnalysisCtx ctx = {",
      "\t\t.retctx = &retctx,",
      "\t\t.cur_idx = 0,",
      "\t\t.prev_dest = NULL,",
      "\t\t.str_flag = false",
      "\t};",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rizinorg/rizin/pull/2031",
  "description": {
    "pr_info": {
      "title": "Initialize retctx,ctx before freeing the inner elements",
      "number": 2031
    },
    "comment": [
      "**Your checklist for this pull request**\r\n- [x] I've read the [guidelines for contributing](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md) to this repository\r\n- [x] I made sure to follow the project's [coding style](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've documented or updated the documentation of every function and struct this PR changes. If not so I've explained why.\r\n- [ ] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the [rizin book](https://github.com/rizinorg/book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\n<!-- Explain the **details** for making this change. Is a new feature implemented? What existing problem does the pull request solve? How does the pull request solve these issues? Please provide enough information so that others can review your pull request. -->\r\n\r\nIn rz_core_analysis_type_match retctx structure was initialized on the\r\nstack only after a \"goto out_function\", where a field of that structure\r\nwas freed. When the goto path is taken, the field is not properly\r\ninitialized and it cause cause a crash of Rizin or have other effects.\r\n\r\nFixes: CVE-2021-4022\r\n\r\n**Test plan**\r\n\r\n<!-- What steps should the reviewer take to test your pull request? Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots/videos. This is your time to re-check that everything works and that you covered all the edge cases -->\r\n\r\n...\r\n\r\n**Closing issues**\r\n\r\n<!-- put \"closes #XXXX\" in your comment to auto-close the issue that your PR fixes (if any). -->\r\n\r\nCloses #2015 \r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}