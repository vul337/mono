{
  "cve_id": "CVE-2022-34970",
  "cwe_ids": [
    "CWE-193"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "CrowCpp/Crow",
  "commit_msg": "Fixed issue where an index in qs_parse is incorrectly incremented beyond the maximum possible value",
  "commit_hash": "79eec91f00b5fb7df890d4e84b2f048b0841e044",
  "git_url": "https://github.com/CrowCpp/Crow/commit/79eec91f00b5fb7df890d4e84b2f048b0841e044",
  "file_path": "include/crow/query_string.h",
  "func_name": "qs_parse",
  "func_before": "inline int qs_parse(char* qs, char* qs_kv[], int qs_kv_size, bool parse_url = true)\n{\n    int i, j;\n    char * substr_ptr;\n\n    for(i=0; i<qs_kv_size; i++)  qs_kv[i] = NULL;\n\n    // find the beginning of the k/v substrings or the fragment\n    substr_ptr = parse_url ? qs + strcspn(qs, \"?#\") : qs;\n    if (parse_url)\n    {\n        if (substr_ptr[0] != '\\0')\n            substr_ptr++;\n        else\n            return 0; // no query or fragment\n    }\n\n    i=0;\n    while(i<qs_kv_size)\n    {\n        qs_kv[i] = substr_ptr;\n        j = strcspn(substr_ptr, \"&\");\n        if ( substr_ptr[j] == '\\0' ) {  break;  }\n        substr_ptr += j + 1;\n        i++;\n    }\n    i++;  // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n\n    // we only decode the values in place, the keys could have '='s in them\n    // which will hose our ability to distinguish keys from values later\n    for(j=0; j<i; j++)\n    {\n        substr_ptr = qs_kv[j] + strcspn(qs_kv[j], \"=&#\");\n        if ( substr_ptr[0] == '&' || substr_ptr[0] == '\\0')  // blank value: skip decoding\n            substr_ptr[0] = '\\0';\n        else\n            qs_decode(++substr_ptr);\n    }\n\n#ifdef _qsSORTING\n// TODO: qsort qs_kv, using qs_strncmp() for the comparison\n#endif\n\n    return i;\n    }",
  "abstract_func_before": "inline int qs_parse(char* VAR_0, char* VAR_1[], int VAR_2, bool VAR_3 = true)\n{\n    int VAR_4, VAR_5;\n    char * VAR_6;\n\n    for(VAR_4=0; VAR_4<VAR_2; VAR_4++)  VAR_1[VAR_4] = NULL;\n\n    /* COMMENT_0 */\n    VAR_6 = VAR_3 ? VAR_0 + strcspn(VAR_0, \"?#\") : VAR_0;\n    if (VAR_3)\n    {\n        if (VAR_6[0] != '\\0')\n            VAR_6++;\n        else\n            return 0; /* COMMENT_1 */\n    }\n\n    VAR_4=0;\n    while(VAR_4<VAR_2)\n    {\n        VAR_1[VAR_4] = VAR_6;\n        VAR_5 = strcspn(VAR_6, \"&\");\n        if ( VAR_6[VAR_5] == '\\0' ) {  break;  }\n        VAR_6 += VAR_5 + 1;\n        VAR_4++;\n    }\n    VAR_4++;  /* COMMENT_2 */\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    for(VAR_5=0; VAR_5<VAR_4; VAR_5++)\n    {\n        VAR_6 = VAR_1[VAR_5] + strcspn(VAR_1[VAR_5], \"=&#\");\n        if ( VAR_6[0] == '&' || VAR_6[0] == '\\0')  /* COMMENT_5 */\n            VAR_6[0] = '\\0';\n        else\n            qs_decode(++VAR_6);\n    }\n\n#ifdef VAR_7\n/* COMMENT_6 */\n#endif\n\n    return VAR_4;\n    }",
  "func_graph_path_before": "CrowCpp/Crow/79eec91f00b5fb7df890d4e84b2f048b0841e044/query_string.h/vul/before/0.json",
  "func": "inline int qs_parse(char* qs, char* qs_kv[], int qs_kv_size, bool parse_url = true)\n{\n    int i, j;\n    char * substr_ptr;\n\n    for(i=0; i<qs_kv_size; i++)  qs_kv[i] = NULL;\n\n    // find the beginning of the k/v substrings or the fragment\n    substr_ptr = parse_url ? qs + strcspn(qs, \"?#\") : qs;\n    if (parse_url)\n    {\n        if (substr_ptr[0] != '\\0')\n            substr_ptr++;\n        else\n            return 0; // no query or fragment\n    }\n\n    i=0;\n    while(i<qs_kv_size)\n    {\n        qs_kv[i] = substr_ptr;\n        j = strcspn(substr_ptr, \"&\");\n        if ( substr_ptr[j] == '\\0' ) { i++; break;  } // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n        substr_ptr += j + 1;\n        i++;\n    }\n\n    // we only decode the values in place, the keys could have '='s in them\n    // which will hose our ability to distinguish keys from values later\n    for(j=0; j<i; j++)\n    {\n        substr_ptr = qs_kv[j] + strcspn(qs_kv[j], \"=&#\");\n        if ( substr_ptr[0] == '&' || substr_ptr[0] == '\\0')  // blank value: skip decoding\n            substr_ptr[0] = '\\0';\n        else\n            qs_decode(++substr_ptr);\n    }\n\n#ifdef _qsSORTING\n// TODO: qsort qs_kv, using qs_strncmp() for the comparison\n#endif\n\n    return i;\n    }",
  "abstract_func": "inline int qs_parse(char* VAR_0, char* VAR_1[], int VAR_2, bool VAR_3 = true)\n{\n    int VAR_4, VAR_5;\n    char * VAR_6;\n\n    for(VAR_4=0; VAR_4<VAR_2; VAR_4++)  VAR_1[VAR_4] = NULL;\n\n    /* COMMENT_0 */\n    VAR_6 = VAR_3 ? VAR_0 + strcspn(VAR_0, \"?#\") : VAR_0;\n    if (VAR_3)\n    {\n        if (VAR_6[0] != '\\0')\n            VAR_6++;\n        else\n            return 0; /* COMMENT_1 */\n    }\n\n    VAR_4=0;\n    while(VAR_4<VAR_2)\n    {\n        VAR_1[VAR_4] = VAR_6;\n        VAR_5 = strcspn(VAR_6, \"&\");\n        if ( VAR_6[VAR_5] == '\\0' ) { VAR_4++; break;  } /* COMMENT_2 */\n        VAR_6 += VAR_5 + 1;\n        VAR_4++;\n    }\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    for(VAR_5=0; VAR_5<VAR_4; VAR_5++)\n    {\n        VAR_6 = VAR_1[VAR_5] + strcspn(VAR_1[VAR_5], \"=&#\");\n        if ( VAR_6[0] == '&' || VAR_6[0] == '\\0')  /* COMMENT_5 */\n            VAR_6[0] = '\\0';\n        else\n            qs_decode(++VAR_6);\n    }\n\n#ifdef VAR_7\n/* COMMENT_6 */\n#endif\n\n    return VAR_4;\n    }",
  "func_graph_path": "CrowCpp/Crow/79eec91f00b5fb7df890d4e84b2f048b0841e044/query_string.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -20,11 +20,10 @@\n     {\n         qs_kv[i] = substr_ptr;\n         j = strcspn(substr_ptr, \"&\");\n-        if ( substr_ptr[j] == '\\0' ) {  break;  }\n+        if ( substr_ptr[j] == '\\0' ) { i++; break;  } // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n         substr_ptr += j + 1;\n         i++;\n     }\n-    i++;  // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n \n     // we only decode the values in place, the keys could have '='s in them\n     // which will hose our ability to distinguish keys from values later",
  "diff_line_info": {
    "deleted_lines": [
      "        if ( substr_ptr[j] == '\\0' ) {  break;  }",
      "    i++;  // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs"
    ],
    "added_lines": [
      "        if ( substr_ptr[j] == '\\0' ) { i++; break;  } // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/CrowCpp/Crow/pull/486",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/CrowCpp/Crow/pull/486: 403 Client Error: Forbidden for url: https://api.github.com/repos/CrowCpp/Crow/pulls/486",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.8\n\nThe patch corrects an out-of-bounds index increment, which could lead to security issues, with moderate confidence as the context strongly suggests a security fix without explicit CVE reference."
}