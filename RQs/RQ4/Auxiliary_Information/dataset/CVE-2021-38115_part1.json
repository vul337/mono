{
  "cve_id": "CVE-2021-38115",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgd",
  "commit_msg": "fix read out-of-bands in reading tga header file",
  "commit_hash": "8b111b2b4a4842179be66db68d84dda91a246032",
  "git_url": "https://github.com/libgd/libgd/commit/8b111b2b4a4842179be66db68d84dda91a246032",
  "file_path": "src/gd_tga.c",
  "func_name": "read_header_tga",
  "func_before": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}",
  "abstract_func_before": "int read_header_tga(gdIOCtx *VAR_0, oTga *VAR_1)\n{\n\n\tunsigned char VAR_2[18];\n\n\tif (gdGetBuf(VAR_2, sizeof(VAR_2), VAR_0) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\tVAR_1->identsize = VAR_2[0];\n\tVAR_1->colormaptype = VAR_2[1];\n\tVAR_1->imagetype = VAR_2[2];\n\tVAR_1->colormapstart = VAR_2[3] + (VAR_2[4] << 8);\n\tVAR_1->colormaplength = VAR_2[5] + (VAR_2[6] << 8);\n\tVAR_1->colormapbits = VAR_2[7];\n\tVAR_1->xstart = VAR_2[8] + (VAR_2[9] << 8);\n\tVAR_1->ystart = VAR_2[10] + (VAR_2[11] << 8);\n\tVAR_1->width = VAR_2[12] + (VAR_2[13] << 8);\n\tVAR_1->height = VAR_2[14] + (VAR_2[15] << 8);\n\tVAR_1->bits = VAR_2[16];\n\tVAR_1->alphabits = VAR_2[17] & 0x0f;\n\tVAR_1->fliph = (VAR_2[17] & 0x10) ? 1 : 0;\n\tVAR_1->flipv = (VAR_2[17] & 0x20) ? 0 : 1;\n\n#if VAR_3\n\tprintf(\"format bps: %i\\n\", VAR_1->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", VAR_1->fliph, VAR_1->flipv);\n\tprintf(\"alpha: %i\\n\", VAR_1->alphabits);\n\tprintf(\"wxh: %i %i\\n\", VAR_1->width, VAR_1->height);\n#endif\n\n\tif (!((VAR_1->bits == VAR_4 && VAR_1->alphabits == 0)\n\t\t|| (VAR_1->bits == VAR_5 && VAR_1->alphabits == 8)))\n\t{\n\t\tgd_error_ex(VAR_6, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\tVAR_1->bits, VAR_1->alphabits);\n\t\treturn -1;\n\t}\n\n\tVAR_1->ident = NULL;\n\n\tif (VAR_1->identsize > 0) {\n\t\tVAR_1->ident = (char *) gdMalloc(VAR_1->identsize * sizeof(char));\n\t\tif(VAR_1->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(VAR_1->ident, VAR_1->identsize, VAR_0);\n\t}\n\n\treturn 1;\n}",
  "func_graph_path_before": "libgd/8b111b2b4a4842179be66db68d84dda91a246032/gd_tga.c/vul/before/0.json",
  "func": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t\n\t\tif (gdGetBuf(tga->ident, tga->identsize, ctx) != tga->identsize) {\n\t\t\tgd_error(\"fail to read header ident\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 1;\n}",
  "abstract_func": "int read_header_tga(gdIOCtx *VAR_0, oTga *VAR_1)\n{\n\n\tunsigned char VAR_2[18];\n\n\tif (gdGetBuf(VAR_2, sizeof(VAR_2), VAR_0) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\tVAR_1->identsize = VAR_2[0];\n\tVAR_1->colormaptype = VAR_2[1];\n\tVAR_1->imagetype = VAR_2[2];\n\tVAR_1->colormapstart = VAR_2[3] + (VAR_2[4] << 8);\n\tVAR_1->colormaplength = VAR_2[5] + (VAR_2[6] << 8);\n\tVAR_1->colormapbits = VAR_2[7];\n\tVAR_1->xstart = VAR_2[8] + (VAR_2[9] << 8);\n\tVAR_1->ystart = VAR_2[10] + (VAR_2[11] << 8);\n\tVAR_1->width = VAR_2[12] + (VAR_2[13] << 8);\n\tVAR_1->height = VAR_2[14] + (VAR_2[15] << 8);\n\tVAR_1->bits = VAR_2[16];\n\tVAR_1->alphabits = VAR_2[17] & 0x0f;\n\tVAR_1->fliph = (VAR_2[17] & 0x10) ? 1 : 0;\n\tVAR_1->flipv = (VAR_2[17] & 0x20) ? 0 : 1;\n\n#if VAR_3\n\tprintf(\"format bps: %i\\n\", VAR_1->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", VAR_1->fliph, VAR_1->flipv);\n\tprintf(\"alpha: %i\\n\", VAR_1->alphabits);\n\tprintf(\"wxh: %i %i\\n\", VAR_1->width, VAR_1->height);\n#endif\n\n\tif (!((VAR_1->bits == VAR_4 && VAR_1->alphabits == 0)\n\t\t|| (VAR_1->bits == VAR_5 && VAR_1->alphabits == 8)))\n\t{\n\t\tgd_error_ex(VAR_6, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\tVAR_1->bits, VAR_1->alphabits);\n\t\treturn -1;\n\t}\n\n\tVAR_1->ident = NULL;\n\n\tif (VAR_1->identsize > 0) {\n\t\tVAR_1->ident = (char *) gdMalloc(VAR_1->identsize * sizeof(char));\n\t\tif(VAR_1->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t\n\t\tif (gdGetBuf(VAR_1->ident, VAR_1->identsize, VAR_0) != VAR_1->identsize) {\n\t\t\tgd_error(\"fail to read header ident\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 1;\n}",
  "func_graph_path": "libgd/8b111b2b4a4842179be66db68d84dda91a246032/gd_tga.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,11 @@\n \t\t\treturn -1;\n \t\t}\n \n-\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n+\t\t\n+\t\tif (gdGetBuf(tga->ident, tga->identsize, ctx) != tga->identsize) {\n+\t\t\tgd_error(\"fail to read header ident\");\n+\t\t\treturn -1;\n+\t\t}\n \t}\n \n \treturn 1;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tgdGetBuf(tga->ident, tga->identsize, ctx);"
    ],
    "added_lines": [
      "\t\t",
      "\t\tif (gdGetBuf(tga->ident, tga->identsize, ctx) != tga->identsize) {",
      "\t\t\tgd_error(\"fail to read header ident\");",
      "\t\t\treturn -1;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgd/libgd/pull/711",
  "description": {
    "pr_info": {
      "title": "fix read out-of-bounds in reading tga header file",
      "number": 711
    },
    "comment": [
      "Update src/gd_tga.c file for possible read out of bound in `gdGetBuf` call site.\r\nMentioned in this issue #697.",
      "Thank you @me22bee  :)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.99,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.99"
}