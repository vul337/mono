{
  "cve_id": "CVE-2017-3731",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "crypto/evp: harden AEAD ciphers.\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory. Since hash\noperation is read-only it is not considered to be exploitable\nbeyond a DoS condition. Other ciphers were hardened.\n\nThanks to Robert Święcki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
  "commit_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
  "git_url": "https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21",
  "file_path": "crypto/evp/e_chacha20_poly1305.c",
  "func_name": "chacha20_poly1305_ctrl",
  "func_before": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr, temp[POLY1305_BLOCK_SIZE];\n\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            if (!ctx->encrypt) {\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);\n                aad = temp;\n                temp[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                temp[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per\n             * draft-ietf-tls-chacha20-poly1305-03\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n            chacha20_poly1305_cipher(ctx, NULL, aad, EVP_AEAD_TLS1_AAD_LEN);\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
  "abstract_func_before": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *VAR_0, int VAR_1, int VAR_2,\n                                  void *VAR_3)\n{\n    EVP_CHACHA_AEAD_CTX *VAR_4 = aead_data(VAR_0);\n\n    switch(VAR_1) {\n    case VAR_5:\n        if (VAR_4 == NULL)\n            VAR_4 = VAR_0->cipher_data\n                 = OPENSSL_zalloc(sizeof(*VAR_4) + Poly1305_ctx_size());\n        if (VAR_4 == NULL) {\n            EVPerr(VAR_6, VAR_7);\n            return 0;\n        }\n        VAR_4->len.aad = 0;\n        VAR_4->len.text = 0;\n        VAR_4->aad = 0;\n        VAR_4->mac_inited = 0;\n        VAR_4->tag_len = 0;\n        VAR_4->nonce_len = 12;\n        VAR_4->tls_payload_length = VAR_8;\n        return 1;\n\n    case VAR_9:\n        if (VAR_4) {\n            EVP_CIPHER_CTX *VAR_10 = (EVP_CIPHER_CTX *)VAR_3;\n\n            VAR_10->cipher_data =\n                   OPENSSL_memdup(VAR_4, sizeof(*VAR_4) + Poly1305_ctx_size());\n            if (VAR_10->cipher_data == NULL) {\n                EVPerr(VAR_6, VAR_11);\n                return 0;\n            }\n        }\n        return 1;\n\n    case VAR_12:\n        if (VAR_2 <= 0 || VAR_2 > VAR_13)\n            return 0;\n        VAR_4->nonce_len = VAR_2;\n        return 1;\n\n    case VAR_14:\n        if (VAR_2 != 12)\n            return 0;\n        VAR_4->nonce[0] = VAR_4->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)VAR_3);\n        VAR_4->nonce[1] = VAR_4->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)VAR_3+4);\n        VAR_4->nonce[2] = VAR_4->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)VAR_3+8);\n        return 1;\n\n    case VAR_15:\n        if (VAR_2 <= 0 || VAR_2 > VAR_16)\n            return 0;\n        if (VAR_3 != NULL) {\n            memcpy(VAR_4->tag, VAR_3, VAR_2);\n            VAR_4->tag_len = VAR_2;\n        }\n        return 1;\n\n    case VAR_17:\n        if (VAR_2 <= 0 || VAR_2 > VAR_16 || !VAR_0->encrypt)\n            return 0;\n        memcpy(VAR_3, VAR_4->tag, VAR_2);\n        return 1;\n\n    case VAR_18:\n        if (VAR_2 != VAR_19)\n            return 0;\n        {\n            unsigned int VAR_20;\n            unsigned char *VAR_21 = VAR_3, VAR_22[VAR_16];\n\n            VAR_20 = VAR_21[VAR_19 - 2] << 8 |\n                  VAR_21[VAR_19 - 1];\n            if (!VAR_0->encrypt) {\n                VAR_20 -= VAR_16;     /* COMMENT_0 */\n                memcpy(VAR_22, VAR_21, VAR_19 - 2);\n                VAR_21 = VAR_22;\n                VAR_22[VAR_19 - 2] = (unsigned char)(VAR_20 >> 8);\n                VAR_22[VAR_19 - 1] = (unsigned char)VAR_20;\n            }\n            VAR_4->tls_payload_length = VAR_20;\n\n            /* COMMENT_1 */\n                                                  \n                                                  \n               \n            VAR_4->key.counter[1] = VAR_4->nonce[0];\n            VAR_4->key.counter[2] = VAR_4->nonce[1] ^ CHACHA_U8TOU32(VAR_21);\n            VAR_4->key.counter[3] = VAR_4->nonce[2] ^ CHACHA_U8TOU32(VAR_21+4);\n            VAR_4->mac_inited = 0;\n            chacha20_poly1305_cipher(VAR_0, NULL, VAR_21, VAR_19);\n            return VAR_16;         /* COMMENT_5 */\n        }\n\n    case VAR_23:\n        /* COMMENT_6 */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
  "func_graph_path_before": "openssl/00d965474b22b54e4275232bc71ee0c699c5cd21/e_chacha20_poly1305.c/vul/before/0.json",
  "func": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr, temp[POLY1305_BLOCK_SIZE];\n\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);\n                aad = temp;\n                temp[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                temp[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n            chacha20_poly1305_cipher(ctx, NULL, aad, EVP_AEAD_TLS1_AAD_LEN);\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
  "abstract_func": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *VAR_0, int VAR_1, int VAR_2,\n                                  void *VAR_3)\n{\n    EVP_CHACHA_AEAD_CTX *VAR_4 = aead_data(VAR_0);\n\n    switch(VAR_1) {\n    case VAR_5:\n        if (VAR_4 == NULL)\n            VAR_4 = VAR_0->cipher_data\n                 = OPENSSL_zalloc(sizeof(*VAR_4) + Poly1305_ctx_size());\n        if (VAR_4 == NULL) {\n            EVPerr(VAR_6, VAR_7);\n            return 0;\n        }\n        VAR_4->len.aad = 0;\n        VAR_4->len.text = 0;\n        VAR_4->aad = 0;\n        VAR_4->mac_inited = 0;\n        VAR_4->tag_len = 0;\n        VAR_4->nonce_len = 12;\n        VAR_4->tls_payload_length = VAR_8;\n        return 1;\n\n    case VAR_9:\n        if (VAR_4) {\n            EVP_CIPHER_CTX *VAR_10 = (EVP_CIPHER_CTX *)VAR_3;\n\n            VAR_10->cipher_data =\n                   OPENSSL_memdup(VAR_4, sizeof(*VAR_4) + Poly1305_ctx_size());\n            if (VAR_10->cipher_data == NULL) {\n                EVPerr(VAR_6, VAR_11);\n                return 0;\n            }\n        }\n        return 1;\n\n    case VAR_12:\n        if (VAR_2 <= 0 || VAR_2 > VAR_13)\n            return 0;\n        VAR_4->nonce_len = VAR_2;\n        return 1;\n\n    case VAR_14:\n        if (VAR_2 != 12)\n            return 0;\n        VAR_4->nonce[0] = VAR_4->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)VAR_3);\n        VAR_4->nonce[1] = VAR_4->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)VAR_3+4);\n        VAR_4->nonce[2] = VAR_4->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)VAR_3+8);\n        return 1;\n\n    case VAR_15:\n        if (VAR_2 <= 0 || VAR_2 > VAR_16)\n            return 0;\n        if (VAR_3 != NULL) {\n            memcpy(VAR_4->tag, VAR_3, VAR_2);\n            VAR_4->tag_len = VAR_2;\n        }\n        return 1;\n\n    case VAR_17:\n        if (VAR_2 <= 0 || VAR_2 > VAR_16 || !VAR_0->encrypt)\n            return 0;\n        memcpy(VAR_3, VAR_4->tag, VAR_2);\n        return 1;\n\n    case VAR_18:\n        if (VAR_2 != VAR_19)\n            return 0;\n        {\n            unsigned int VAR_20;\n            unsigned char *VAR_21 = VAR_3, VAR_22[VAR_16];\n\n            VAR_20 = VAR_21[VAR_19 - 2] << 8 |\n                  VAR_21[VAR_19 - 1];\n            if (!VAR_0->encrypt) {\n                if (VAR_20 < VAR_16)\n                    return 0;\n                VAR_20 -= VAR_16;     /* COMMENT_0 */\n                memcpy(VAR_22, VAR_21, VAR_19 - 2);\n                VAR_21 = VAR_22;\n                VAR_22[VAR_19 - 2] = (unsigned char)(VAR_20 >> 8);\n                VAR_22[VAR_19 - 1] = (unsigned char)VAR_20;\n            }\n            VAR_4->tls_payload_length = VAR_20;\n\n            /* COMMENT_1 */\n                                                          \n               \n            VAR_4->key.counter[1] = VAR_4->nonce[0];\n            VAR_4->key.counter[2] = VAR_4->nonce[1] ^ CHACHA_U8TOU32(VAR_21);\n            VAR_4->key.counter[3] = VAR_4->nonce[2] ^ CHACHA_U8TOU32(VAR_21+4);\n            VAR_4->mac_inited = 0;\n            chacha20_poly1305_cipher(VAR_0, NULL, VAR_21, VAR_19);\n            return VAR_16;         /* COMMENT_4 */\n        }\n\n    case VAR_23:\n        /* COMMENT_5 */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
  "func_graph_path": "openssl/00d965474b22b54e4275232bc71ee0c699c5cd21/e_chacha20_poly1305.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -76,6 +76,8 @@\n             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n             if (!ctx->encrypt) {\n+                if (len < POLY1305_BLOCK_SIZE)\n+                    return 0;\n                 len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                 memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);\n                 aad = temp;\n@@ -85,8 +87,7 @@\n             actx->tls_payload_length = len;\n \n             /*\n-             * merge record sequence number as per\n-             * draft-ietf-tls-chacha20-poly1305-03\n+             * merge record sequence number as per RFC7905\n              */\n             actx->key.counter[1] = actx->nonce[0];\n             actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);",
  "diff_line_info": {
    "deleted_lines": [
      "             * merge record sequence number as per",
      "             * draft-ietf-tls-chacha20-poly1305-03"
    ],
    "added_lines": [
      "                if (len < POLY1305_BLOCK_SIZE)",
      "                    return 0;",
      "             * merge record sequence number as per RFC7905"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nThe patch addresses a security issue related to a crash in AEAD ciphers, specifically referencing CVE-2017-3731. The code changes include adding checks to prevent excessive hashing, which aligns with the described fix for a security vulnerability."
}