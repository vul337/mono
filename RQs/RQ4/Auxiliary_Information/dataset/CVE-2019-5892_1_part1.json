{
  "cve_id": "CVE-2019-5892",
  "cwe_ids": [
    "CWE-436"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: don't use BGP_ATTR_VNC(255) unless ENABLE_BGP_VNC_ATTR is defined\n\nSigned-off-by: Lou Berger <lberger@labn.net>",
  "commit_hash": "943d595a018e69b550db08cccba1d0778a86705a",
  "git_url": "https://github.com/FRRouting/frr/commit/943d595a018e69b550db08cccba1d0778a86705a",
  "file_path": "bgpd/bgp_attr.c",
  "func_name": "bgp_packet_mpattr_tea",
  "func_before": "static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,\n\t\t\t\t  struct stream *s, struct attr *attr,\n\t\t\t\t  uint8_t attrtype)\n{\n\tunsigned int attrlenfield = 0;\n\tunsigned int attrhdrlen = 0;\n\tstruct bgp_attr_encap_subtlv *subtlvs;\n\tstruct bgp_attr_encap_subtlv *st;\n\tconst char *attrname;\n\n\tif (!attr || (attrtype == BGP_ATTR_ENCAP\n\t\t      && (!attr->encap_tunneltype\n\t\t\t  || attr->encap_tunneltype == BGP_ENCAP_TYPE_MPLS)))\n\t\treturn;\n\n\tswitch (attrtype) {\n\tcase BGP_ATTR_ENCAP:\n\t\tattrname = \"Tunnel Encap\";\n\t\tsubtlvs = attr->encap_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\t/*\n\t\t * The tunnel encap attr has an \"outer\" tlv.\n\t\t * T = tunneltype,\n\t\t * L = total length of subtlvs,\n\t\t * V = concatenated subtlvs.\n\t\t */\n\t\tattrlenfield = 2 + 2; /* T + L */\n\t\tattrhdrlen = 1 + 1;   /* subTLV T + L */\n\t\tbreak;\n\n#if ENABLE_BGP_VNC\n\tcase BGP_ATTR_VNC:\n\t\tattrname = \"VNC\";\n\t\tsubtlvs = attr->vnc_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\tattrlenfield = 0;   /* no outer T + L */\n\t\tattrhdrlen = 2 + 2; /* subTLV T + L */\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t}\n\n\t/* compute attr length */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tattrlenfield += (attrhdrlen + st->length);\n\t}\n\n\tif (attrlenfield > 0xffff) {\n\t\tzlog_info(\"%s attribute is too long (length=%d), can't send it\",\n\t\t\t  attrname, attrlenfield);\n\t\treturn;\n\t}\n\n\tif (attrlenfield > 0xff) {\n\t\t/* 2-octet length field */\n\t\tstream_putc(s,\n\t\t\t    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putw(s, attrlenfield & 0xffff);\n\t} else {\n\t\t/* 1-octet length field */\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putc(s, attrlenfield & 0xff);\n\t}\n\n\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t/* write outer T+L */\n\t\tstream_putw(s, attr->encap_tunneltype);\n\t\tstream_putw(s, attrlenfield - 4);\n\t}\n\n\t/* write each sub-tlv */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t\tstream_putc(s, st->type);\n\t\t\tstream_putc(s, st->length);\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tstream_putw(s, st->type);\n\t\t\tstream_putw(s, st->length);\n#endif\n\t\t}\n\t\tstream_put(s, st->value, st->length);\n\t}\n}",
  "abstract_func_before": "static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,\n\t\t\t\t  struct stream *VAR_0, struct attr *attr,\n\t\t\t\t  uint8_t VAR_1)\n{\n\tunsigned int VAR_2 = 0;\n\tunsigned int VAR_3 = 0;\n\tstruct bgp_attr_encap_subtlv *VAR_4;\n\tstruct bgp_attr_encap_subtlv *VAR_5;\n\tconst char *VAR_6;\n\n\tif (!attr || (VAR_1 == VAR_7\n\t\t      && (!attr->encap_tunneltype\n\t\t\t  || attr->encap_tunneltype == VAR_8)))\n\t\treturn;\n\n\tswitch (VAR_1) {\n\tcase VAR_7:\n\t\tVAR_6 = \"Tunnel Encap\";\n\t\tVAR_4 = attr->encap_subtlvs;\n\t\tif (VAR_4 == NULL) /* COMMENT_0 */\n\t\t\treturn;\n\t\t/* COMMENT_1 */\n                                              \n                    \n                                 \n                              \n     \n\t\tVAR_2 = 2 + 2; /* COMMENT_7 */\n\t\tVAR_3 = 1 + 1;   /* COMMENT_8 */\n\t\tbreak;\n\n#if VAR_9\n\tcase VAR_10:\n\t\tVAR_6 = \"VNC\";\n\t\tVAR_4 = attr->vnc_subtlvs;\n\t\tif (VAR_4 == NULL) /* COMMENT_0 */\n\t\t\treturn;\n\t\tVAR_2 = 0;   /* COMMENT_9 */\n\t\tVAR_3 = 2 + 2; /* COMMENT_8 */\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t}\n\n\t/* COMMENT_10 */\n\tfor (VAR_5 = VAR_4; VAR_5; VAR_5 = VAR_5->next) {\n\t\tVAR_2 += (VAR_3 + VAR_5->length);\n\t}\n\n\tif (VAR_2 > 0xffff) {\n\t\tzlog_info(\"%s attribute is too long (length=%d), can't send it\",\n\t\t\t  VAR_6, VAR_2);\n\t\treturn;\n\t}\n\n\tif (VAR_2 > 0xff) {\n\t\t/* COMMENT_11 */\n\t\tstream_putc(VAR_0,\n\t\t\t    VAR_11 | VAR_12\n\t\t\t\t    | VAR_13);\n\t\tstream_putc(VAR_0, VAR_1);\n\t\tstream_putw(VAR_0, VAR_2 & 0xffff);\n\t} else {\n\t\t/* COMMENT_12 */\n\t\tstream_putc(VAR_0, VAR_11 | VAR_12);\n\t\tstream_putc(VAR_0, VAR_1);\n\t\tstream_putc(VAR_0, VAR_2 & 0xff);\n\t}\n\n\tif (VAR_1 == VAR_7) {\n\t\t/* COMMENT_13 */\n\t\tstream_putw(VAR_0, attr->encap_tunneltype);\n\t\tstream_putw(VAR_0, VAR_2 - 4);\n\t}\n\n\t/* COMMENT_14 */\n\tfor (VAR_5 = VAR_4; VAR_5; VAR_5 = VAR_5->next) {\n\t\tif (VAR_1 == VAR_7) {\n\t\t\tstream_putc(VAR_0, VAR_5->type);\n\t\t\tstream_putc(VAR_0, VAR_5->length);\n#if VAR_9\n\t\t} else {\n\t\t\tstream_putw(VAR_0, VAR_5->type);\n\t\t\tstream_putw(VAR_0, VAR_5->length);\n#endif\n\t\t}\n\t\tstream_put(VAR_0, VAR_5->value, VAR_5->length);\n\t}\n}",
  "func_graph_path_before": "FRRouting/frr/943d595a018e69b550db08cccba1d0778a86705a/bgp_attr.c/vul/before/2.json",
  "func": "static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,\n\t\t\t\t  struct stream *s, struct attr *attr,\n\t\t\t\t  uint8_t attrtype)\n{\n\tunsigned int attrlenfield = 0;\n\tunsigned int attrhdrlen = 0;\n\tstruct bgp_attr_encap_subtlv *subtlvs;\n\tstruct bgp_attr_encap_subtlv *st;\n\tconst char *attrname;\n\n\tif (!attr || (attrtype == BGP_ATTR_ENCAP\n\t\t      && (!attr->encap_tunneltype\n\t\t\t  || attr->encap_tunneltype == BGP_ENCAP_TYPE_MPLS)))\n\t\treturn;\n\n\tswitch (attrtype) {\n\tcase BGP_ATTR_ENCAP:\n\t\tattrname = \"Tunnel Encap\";\n\t\tsubtlvs = attr->encap_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\t/*\n\t\t * The tunnel encap attr has an \"outer\" tlv.\n\t\t * T = tunneltype,\n\t\t * L = total length of subtlvs,\n\t\t * V = concatenated subtlvs.\n\t\t */\n\t\tattrlenfield = 2 + 2; /* T + L */\n\t\tattrhdrlen = 1 + 1;   /* subTLV T + L */\n\t\tbreak;\n\n#if ENABLE_BGP_VNC_ATTR\n\tcase BGP_ATTR_VNC:\n\t\tattrname = \"VNC\";\n\t\tsubtlvs = attr->vnc_subtlvs;\n\t\tif (subtlvs == NULL) /* nothing to do */\n\t\t\treturn;\n\t\tattrlenfield = 0;   /* no outer T + L */\n\t\tattrhdrlen = 2 + 2; /* subTLV T + L */\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t}\n\n\t/* compute attr length */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tattrlenfield += (attrhdrlen + st->length);\n\t}\n\n\tif (attrlenfield > 0xffff) {\n\t\tzlog_info(\"%s attribute is too long (length=%d), can't send it\",\n\t\t\t  attrname, attrlenfield);\n\t\treturn;\n\t}\n\n\tif (attrlenfield > 0xff) {\n\t\t/* 2-octet length field */\n\t\tstream_putc(s,\n\t\t\t    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL\n\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putw(s, attrlenfield & 0xffff);\n\t} else {\n\t\t/* 1-octet length field */\n\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, attrtype);\n\t\tstream_putc(s, attrlenfield & 0xff);\n\t}\n\n\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t/* write outer T+L */\n\t\tstream_putw(s, attr->encap_tunneltype);\n\t\tstream_putw(s, attrlenfield - 4);\n\t}\n\n\t/* write each sub-tlv */\n\tfor (st = subtlvs; st; st = st->next) {\n\t\tif (attrtype == BGP_ATTR_ENCAP) {\n\t\t\tstream_putc(s, st->type);\n\t\t\tstream_putc(s, st->length);\n#if ENABLE_BGP_VNC\n\t\t} else {\n\t\t\tstream_putw(s, st->type);\n\t\t\tstream_putw(s, st->length);\n#endif\n\t\t}\n\t\tstream_put(s, st->value, st->length);\n\t}\n}",
  "abstract_func": "static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,\n\t\t\t\t  struct stream *VAR_0, struct attr *attr,\n\t\t\t\t  uint8_t VAR_1)\n{\n\tunsigned int VAR_2 = 0;\n\tunsigned int VAR_3 = 0;\n\tstruct bgp_attr_encap_subtlv *VAR_4;\n\tstruct bgp_attr_encap_subtlv *VAR_5;\n\tconst char *VAR_6;\n\n\tif (!attr || (VAR_1 == VAR_7\n\t\t      && (!attr->encap_tunneltype\n\t\t\t  || attr->encap_tunneltype == VAR_8)))\n\t\treturn;\n\n\tswitch (VAR_1) {\n\tcase VAR_7:\n\t\tVAR_6 = \"Tunnel Encap\";\n\t\tVAR_4 = attr->encap_subtlvs;\n\t\tif (VAR_4 == NULL) /* COMMENT_0 */\n\t\t\treturn;\n\t\t/* COMMENT_1 */\n                                              \n                    \n                                 \n                              \n     \n\t\tVAR_2 = 2 + 2; /* COMMENT_7 */\n\t\tVAR_3 = 1 + 1;   /* COMMENT_8 */\n\t\tbreak;\n\n#if VAR_9\n\tcase VAR_10:\n\t\tVAR_6 = \"VNC\";\n\t\tVAR_4 = attr->vnc_subtlvs;\n\t\tif (VAR_4 == NULL) /* COMMENT_0 */\n\t\t\treturn;\n\t\tVAR_2 = 0;   /* COMMENT_9 */\n\t\tVAR_3 = 2 + 2; /* COMMENT_8 */\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t}\n\n\t/* COMMENT_10 */\n\tfor (VAR_5 = VAR_4; VAR_5; VAR_5 = VAR_5->next) {\n\t\tVAR_2 += (VAR_3 + VAR_5->length);\n\t}\n\n\tif (VAR_2 > 0xffff) {\n\t\tzlog_info(\"%s attribute is too long (length=%d), can't send it\",\n\t\t\t  VAR_6, VAR_2);\n\t\treturn;\n\t}\n\n\tif (VAR_2 > 0xff) {\n\t\t/* COMMENT_11 */\n\t\tstream_putc(VAR_0,\n\t\t\t    VAR_11 | VAR_12\n\t\t\t\t    | VAR_13);\n\t\tstream_putc(VAR_0, VAR_1);\n\t\tstream_putw(VAR_0, VAR_2 & 0xffff);\n\t} else {\n\t\t/* COMMENT_12 */\n\t\tstream_putc(VAR_0, VAR_11 | VAR_12);\n\t\tstream_putc(VAR_0, VAR_1);\n\t\tstream_putc(VAR_0, VAR_2 & 0xff);\n\t}\n\n\tif (VAR_1 == VAR_7) {\n\t\t/* COMMENT_13 */\n\t\tstream_putw(VAR_0, attr->encap_tunneltype);\n\t\tstream_putw(VAR_0, VAR_2 - 4);\n\t}\n\n\t/* COMMENT_14 */\n\tfor (VAR_5 = VAR_4; VAR_5; VAR_5 = VAR_5->next) {\n\t\tif (VAR_1 == VAR_7) {\n\t\t\tstream_putc(VAR_0, VAR_5->type);\n\t\t\tstream_putc(VAR_0, VAR_5->length);\n#if VAR_14\n\t\t} else {\n\t\t\tstream_putw(VAR_0, VAR_5->type);\n\t\t\tstream_putw(VAR_0, VAR_5->length);\n#endif\n\t\t}\n\t\tstream_put(VAR_0, VAR_5->value, VAR_5->length);\n\t}\n}",
  "func_graph_path": "FRRouting/frr/943d595a018e69b550db08cccba1d0778a86705a/bgp_attr.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \t\tattrhdrlen = 1 + 1;   /* subTLV T + L */\n \t\tbreak;\n \n-#if ENABLE_BGP_VNC\n+#if ENABLE_BGP_VNC_ATTR\n \tcase BGP_ATTR_VNC:\n \t\tattrname = \"VNC\";\n \t\tsubtlvs = attr->vnc_subtlvs;",
  "diff_line_info": {
    "deleted_lines": [
      "#if ENABLE_BGP_VNC"
    ],
    "added_lines": [
      "#if ENABLE_BGP_VNC_ATTR"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/3575",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/FRRouting/frr/pull/3575: 403 Client Error: Forbidden for url: https://api.github.com/repos/FRRouting/frr/pulls/3575",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.7"
}