{
  "cve_id": "CVE-2018-15862",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "xkbcommon/libxkbcommon",
  "commit_msg": "xkbcomp: Don't explode on invalid virtual modifiers\n\ntestcase: 'virtualModifiers=LevelThreC'\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>",
  "commit_hash": "4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371",
  "git_url": "https://github.com/xkbcommon/libxkbcommon/commit/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371",
  "file_path": "src/xkbcomp/expr.c",
  "func_name": "LookupModMask",
  "func_before": "static bool\nLookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}",
  "abstract_func_before": "static bool\nLookupModMask(struct xkb_context *VAR_0, const void *VAR_1, xkb_atom_t VAR_2,\n              enum expr_value_type VAR_3, xkb_mod_mask_t *VAR_4)\n{\n    const char *VAR_5;\n    xkb_mod_index_t VAR_6;\n    const LookupModMaskPriv *VAR_7 = VAR_1;\n    const struct xkb_mod_set *VAR_8 = VAR_7->mods;\n    enum mod_type mod_type = VAR_7->mod_type;\n\n    if (VAR_3 != VAR_9)\n        return false;\n\n    VAR_5 = xkb_atom_text(VAR_0, VAR_2);\n\n    if (istreq(VAR_5, \"all\")) {\n        *VAR_4  = VAR_10;\n        return true;\n    }\n\n    if (istreq(VAR_5, \"none\")) {\n        *VAR_4 = 0;\n        return true;\n    }\n\n    VAR_6 = XkbModNameToIndex(VAR_8, VAR_2, mod_type);\n    if (VAR_6 == VAR_11)\n        return false;\n\n    *VAR_4 = (1u << VAR_6);\n    return true;\n}",
  "func_graph_path_before": "xkbcommon/libxkbcommon/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371/expr.c/vul/before/0.json",
  "func": "static bool\nLookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}",
  "abstract_func": "static bool\nLookupModMask(struct xkb_context *VAR_0, const void *VAR_1, xkb_atom_t VAR_2,\n              enum expr_value_type VAR_3, xkb_mod_mask_t *VAR_4)\n{\n    const char *VAR_5;\n    xkb_mod_index_t VAR_6;\n    const LookupModMaskPriv *VAR_7 = VAR_1;\n    const struct xkb_mod_set *VAR_8 = VAR_7->mods;\n    enum mod_type mod_type = VAR_7->mod_type;\n\n    if (VAR_3 != VAR_9)\n        return false;\n\n    VAR_5 = xkb_atom_text(VAR_0, VAR_2);\n    if (!VAR_5)\n        return false;\n\n    if (istreq(VAR_5, \"all\")) {\n        *VAR_4  = VAR_10;\n        return true;\n    }\n\n    if (istreq(VAR_5, \"none\")) {\n        *VAR_4 = 0;\n        return true;\n    }\n\n    VAR_6 = XkbModNameToIndex(VAR_8, VAR_2, mod_type);\n    if (VAR_6 == VAR_11)\n        return false;\n\n    *VAR_4 = (1u << VAR_6);\n    return true;\n}",
  "func_graph_path": "xkbcommon/libxkbcommon/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371/expr.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,8 @@\n         return false;\n \n     str = xkb_atom_text(ctx, field);\n+    if (!str)\n+        return false;\n \n     if (istreq(str, \"all\")) {\n         *val_rtrn  = MOD_REAL_MASK_ALL;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (!str)",
      "        return false;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xkbcommon/libxkbcommon/pull/67",
  "description": {
    "pr_info": {
      "title": "Fix more fuzz-testing fallout",
      "number": 67
    },
    "comment": [
      "Most of this was found quite a while ago but got lost.",
      "Thanks! They all look good to me. I'll make another release with these soon."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "The code change addresses a potential crash by adding a null check, but it's unclear if it's a security vulnerability fix. It's more likely a bug fix.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7\n\n**Step-by-Step Explanation:**\n\n1. **Commit Message:** Indicates fixing an issue where the program fails on invalid input, but doesn't mention security.\n2. **Code Diff:** Adds a null check, preventing crashes.\n3. **Vulnerability Description:** Lacks security context.\n4. **Conclusion:** Fix is for a bug causing crashes, not explicitly a security issue.\n\n**Confidence:** 0.7 (Reasonable to classify as a defect fix without security evidence)."
}