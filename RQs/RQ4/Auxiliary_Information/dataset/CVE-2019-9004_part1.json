{
  "cve_id": "CVE-2019-9004",
  "cwe_ids": [
    "CWE-401"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "eclipse-wakaama/wakaama",
  "commit_msg": "Fix memory leak with bad options.\n\nOption processing can allocate memory. Encountering a bad option was\nreturning and error without freeing that memory. This adds the necessary\ncalls to free the memory to fix #425.\n\nSigned-off-by: Scott Bertin <sbertin@telular.com>",
  "commit_hash": "533f285ff6fd9c2284fd290bdfbd355e302ae9a4",
  "git_url": "https://github.com/eclipse-wakaama/wakaama/commit/533f285ff6fd9c2284fd290bdfbd355e302ae9a4",
  "file_path": "core/er-coap-13/er-coap-13.c",
  "func_name": "coap_parse_message",
  "func_before": "coap_status_t\ncoap_parse_message(void *packet, uint8_t *data, uint16_t data_len)\n{\n  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;\n  uint8_t *current_option;\n  unsigned int option_number = 0;\n  unsigned int option_delta = 0;\n  size_t option_length = 0;\n  unsigned int *x;\n\n  /* Initialize packet */\n  memset(coap_pkt, 0, sizeof(coap_packet_t));\n\n  /* pointer to packet bytes */\n  coap_pkt->buffer = data;\n\n  /* parse header fields */\n  coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION;\n  coap_pkt->type = (COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION;\n  coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION);\n  coap_pkt->code = coap_pkt->buffer[1];\n  coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3];\n\n  if (coap_pkt->version != 1)\n  {\n    coap_error_message = \"CoAP version must be 1\";\n    return BAD_REQUEST_4_00;\n  }\n\n  current_option = data + COAP_HEADER_LEN;\n\n  if (coap_pkt->token_len != 0)\n  {\n      memcpy(coap_pkt->token, current_option, coap_pkt->token_len);\n      SET_OPTION(coap_pkt, COAP_OPTION_TOKEN);\n\n      PRINTF(\"Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->token_len,\n        coap_pkt->token[0],\n        coap_pkt->token[1],\n        coap_pkt->token[2],\n        coap_pkt->token[3],\n        coap_pkt->token[4],\n        coap_pkt->token[5],\n        coap_pkt->token[6],\n        coap_pkt->token[7]\n      ); /*FIXME always prints 8 bytes */\n  }\n\n  /* parse options */\n  current_option += coap_pkt->token_len;\n\n  while (current_option < data+data_len)\n  {\n    /* Payload marker 0xFF, currently only checking for 0xF* because rest is reserved */\n    if ((current_option[0] & 0xF0)==0xF0)\n    {\n      coap_pkt->payload = ++current_option;\n      coap_pkt->payload_len = data_len - (coap_pkt->payload - data);\n\n      break;\n    }\n\n    option_delta = current_option[0]>>4;\n    option_length = current_option[0] & 0x0F;\n    ++current_option;\n\n    /* avoids code duplication without function overhead */\n    x = &option_delta;\n    do\n    {\n      if (*x==13)\n      {\n        *x += current_option[0];\n        ++current_option;\n      }\n      else if (*x==14)\n      {\n        *x += 255;\n        *x += current_option[0]<<8;\n        ++current_option;\n        *x += current_option[0];\n        ++current_option;\n      }\n    }\n    while (x!=(unsigned int *)&option_length && (x=(unsigned int *)&option_length));\n\n    option_number += option_delta;\n\n    if (current_option + option_length > data + data_len)\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", option_number, option_delta, option_length);\n        return BAD_REQUEST_4_00;\n    }\n    else\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u): \", option_number, option_delta, option_length);\n    }\n\n    SET_OPTION(coap_pkt, option_number);\n\n    switch (option_number)\n    {\n      case COAP_OPTION_CONTENT_TYPE:\n        coap_pkt->content_type = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Content-Format [%u]\\n\", coap_pkt->content_type);\n        break;\n      case COAP_OPTION_MAX_AGE:\n        coap_pkt->max_age = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Max-Age [%lu]\\n\", coap_pkt->max_age);\n        break;\n      case COAP_OPTION_ETAG:\n        coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len);\n        PRINTF(\"ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->etag_len,\n          coap_pkt->etag[0],\n          coap_pkt->etag[1],\n          coap_pkt->etag[2],\n          coap_pkt->etag[3],\n          coap_pkt->etag[4],\n          coap_pkt->etag[5],\n          coap_pkt->etag[6],\n          coap_pkt->etag[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_ACCEPT:\n        if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM)\n        {\n          coap_pkt->accept[coap_pkt->accept_num] = coap_parse_int_option(current_option, option_length);\n          coap_pkt->accept_num += 1;\n          PRINTF(\"Accept [%u]\\n\", coap_pkt->content_type);\n        }\n        break;\n      case COAP_OPTION_IF_MATCH:\n        /*FIXME support multiple ETags */\n        coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len);\n        PRINTF(\"If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->if_match_len,\n          coap_pkt->if_match[0],\n          coap_pkt->if_match[1],\n          coap_pkt->if_match[2],\n          coap_pkt->if_match[3],\n          coap_pkt->if_match[4],\n          coap_pkt->if_match[5],\n          coap_pkt->if_match[6],\n          coap_pkt->if_match[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_IF_NONE_MATCH:\n        coap_pkt->if_none_match = 1;\n        PRINTF(\"If-None-Match\\n\");\n        break;\n\n      case COAP_OPTION_URI_HOST:\n        coap_pkt->uri_host = current_option;\n        coap_pkt->uri_host_len = option_length;\n        PRINTF(\"Uri-Host [%.*s]\\n\", coap_pkt->uri_host_len, coap_pkt->uri_host);\n        break;\n      case COAP_OPTION_URI_PORT:\n        coap_pkt->uri_port = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Uri-Port [%u]\\n\", coap_pkt->uri_port);\n        break;\n      case COAP_OPTION_URI_PATH:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_path), &(coap_pkt->uri_path_len), current_option, option_length, 0);\n        coap_add_multi_option( &(coap_pkt->uri_path), current_option, option_length, 1);\n        PRINTF(\"Uri-Path [%.*s]\\n\", option_length, current_option);\n        break;\n      case COAP_OPTION_URI_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_query), &(coap_pkt->uri_query_len), current_option, option_length, '&');\n        coap_add_multi_option( &(coap_pkt->uri_query), current_option, option_length, 1);\n        PRINTF(\"Uri-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_LOCATION_PATH:\n        coap_add_multi_option( &(coap_pkt->location_path), current_option, option_length, 1);\n        break;\n      case COAP_OPTION_LOCATION_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        coap_merge_multi_option( &(coap_pkt->location_query), &(coap_pkt->location_query_len), current_option, option_length, '&');\n        PRINTF(\"Location-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_PROXY_URI:\n        /*FIXME check for own end-point */\n        coap_pkt->proxy_uri = current_option;\n        coap_pkt->proxy_uri_len = option_length;\n        /*TODO length > 270 not implemented (actually not required) */\n        PRINTF(\"Proxy-Uri NOT IMPLEMENTED [%.*s]\\n\", coap_pkt->proxy_uri_len, coap_pkt->proxy_uri);\n        coap_error_message = \"This is a constrained server (Contiki)\";\n        return PROXYING_NOT_SUPPORTED_5_05;\n        break;\n\n      case COAP_OPTION_OBSERVE:\n        coap_pkt->observe = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Observe [%lu]\\n\", coap_pkt->observe);\n        break;\n      case COAP_OPTION_BLOCK2:\n        coap_pkt->block2_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block2_more = (coap_pkt->block2_num & 0x08)>>3;\n        coap_pkt->block2_size = 16 << (coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_offset = (coap_pkt->block2_num & ~0x0000000F)<<(coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_num >>= 4;\n        PRINTF(\"Block2 [%lu%s (%u B/blk)]\\n\", coap_pkt->block2_num, coap_pkt->block2_more ? \"+\" : \"\", coap_pkt->block2_size);\n        break;\n      case COAP_OPTION_BLOCK1:\n        coap_pkt->block1_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block1_more = (coap_pkt->block1_num & 0x08)>>3;\n        coap_pkt->block1_size = 16 << (coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_offset = (coap_pkt->block1_num & ~0x0000000F)<<(coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_num >>= 4;\n        PRINTF(\"Block1 [%lu%s (%u B/blk)]\\n\", coap_pkt->block1_num, coap_pkt->block1_more ? \"+\" : \"\", coap_pkt->block1_size);\n        break;\n      case COAP_OPTION_SIZE:\n        coap_pkt->size = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Size [%lu]\\n\", coap_pkt->size);\n        break;\n      default:\n        PRINTF(\"unknown (%u)\\n\", option_number);\n        /* Check if critical (odd) */\n        if (option_number & 1)\n        {\n          coap_error_message = \"Unsupported critical option\";\n          return BAD_OPTION_4_02;\n        }\n    }\n\n    current_option += option_length;\n  } /* for */\n  PRINTF(\"-Done parsing-------\\n\");\n\n\n\n  return NO_ERROR;\n}",
  "abstract_func_before": "coap_status_t\ncoap_parse_message(void *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)\n{\n  coap_packet_t *const VAR_3 = (coap_packet_t *) VAR_0;\n  uint8_t *VAR_4;\n  unsigned int VAR_5 = 0;\n  unsigned int VAR_6 = 0;\n  size_t VAR_7 = 0;\n  unsigned int *VAR_8;\n\n  /* COMMENT_0 */\n  memset(VAR_3, 0, sizeof(coap_packet_t));\n\n  /* COMMENT_1 */\n  VAR_3->buffer = VAR_1;\n\n  /* COMMENT_2 */\n  VAR_3->version = (VAR_9 & VAR_3->buffer[0])>>VAR_10;\n  VAR_3->type = (VAR_11 & VAR_3->buffer[0])>>VAR_12;\n  VAR_3->token_len = MIN(VAR_13, (VAR_14 & VAR_3->buffer[0])>>VAR_15);\n  VAR_3->code = VAR_3->buffer[1];\n  VAR_3->mid = VAR_3->buffer[2]<<8 | VAR_3->buffer[3];\n\n  if (VAR_3->version != 1)\n  {\n    VAR_16 = \"CoAP version must be 1\";\n    return VAR_17;\n  }\n\n  VAR_4 = VAR_1 + VAR_18;\n\n  if (VAR_3->token_len != 0)\n  {\n      memcpy(VAR_3->token, VAR_4, VAR_3->token_len);\n      SET_OPTION(VAR_3, VAR_19);\n\n      PRINTF(\"Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", VAR_3->token_len,\n        VAR_3->token[0],\n        VAR_3->token[1],\n        VAR_3->token[2],\n        VAR_3->token[3],\n        VAR_3->token[4],\n        VAR_3->token[5],\n        VAR_3->token[6],\n        VAR_3->token[7]\n      ); /* COMMENT_3 */\n  }\n\n  /* COMMENT_4 */\n  VAR_4 += VAR_3->token_len;\n\n  while (VAR_4 < VAR_1+VAR_2)\n  {\n    /* COMMENT_5 */\n    if ((VAR_4[0] & 0xF0)==0xF0)\n    {\n      VAR_3->payload = ++VAR_4;\n      VAR_3->payload_len = VAR_2 - (VAR_3->payload - VAR_1);\n\n      break;\n    }\n\n    VAR_6 = VAR_4[0]>>4;\n    VAR_7 = VAR_4[0] & 0x0F;\n    ++VAR_4;\n\n    /* COMMENT_6 */\n    VAR_8 = &VAR_6;\n    do\n    {\n      if (*VAR_8==13)\n      {\n        *VAR_8 += VAR_4[0];\n        ++VAR_4;\n      }\n      else if (*VAR_8==14)\n      {\n        *VAR_8 += 255;\n        *VAR_8 += VAR_4[0]<<8;\n        ++VAR_4;\n        *VAR_8 += VAR_4[0];\n        ++VAR_4;\n      }\n    }\n    while (VAR_8!=(unsigned int *)&VAR_7 && (VAR_8=(unsigned int *)&VAR_7));\n\n    VAR_5 += VAR_6;\n\n    if (VAR_4 + VAR_7 > VAR_1 + VAR_2)\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", VAR_5, VAR_6, VAR_7);\n        return VAR_17;\n    }\n    else\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u): \", VAR_5, VAR_6, VAR_7);\n    }\n\n    SET_OPTION(VAR_3, VAR_5);\n\n    switch (VAR_5)\n    {\n      case VAR_20:\n        VAR_3->content_type = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Content-Format [%u]\\n\", VAR_3->content_type);\n        break;\n      case VAR_21:\n        VAR_3->max_age = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Max-Age [%lu]\\n\", VAR_3->max_age);\n        break;\n      case VAR_22:\n        VAR_3->etag_len = (uint8_t)(MIN(VAR_23, VAR_7));\n        memcpy(VAR_3->etag, VAR_4, VAR_3->etag_len);\n        PRINTF(\"ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", VAR_3->etag_len,\n          VAR_3->etag[0],\n          VAR_3->etag[1],\n          VAR_3->etag[2],\n          VAR_3->etag[3],\n          VAR_3->etag[4],\n          VAR_3->etag[5],\n          VAR_3->etag[6],\n          VAR_3->etag[7]\n        ); /* COMMENT_3 */\n        break;\n      case VAR_24:\n        if (VAR_3->accept_num < VAR_25)\n        {\n          VAR_3->accept[VAR_3->accept_num] = coap_parse_int_option(VAR_4, VAR_7);\n          VAR_3->accept_num += 1;\n          PRINTF(\"Accept [%u]\\n\", VAR_3->content_type);\n        }\n        break;\n      case VAR_26:\n        /* COMMENT_7 */\n        VAR_3->if_match_len = (uint8_t)(MIN(VAR_23, VAR_7));\n        memcpy(VAR_3->if_match, VAR_4, VAR_3->if_match_len);\n        PRINTF(\"If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", VAR_3->if_match_len,\n          VAR_3->if_match[0],\n          VAR_3->if_match[1],\n          VAR_3->if_match[2],\n          VAR_3->if_match[3],\n          VAR_3->if_match[4],\n          VAR_3->if_match[5],\n          VAR_3->if_match[6],\n          VAR_3->if_match[7]\n        ); /* COMMENT_3 */\n        break;\n      case VAR_27:\n        VAR_3->if_none_match = 1;\n        PRINTF(\"If-None-Match\\n\");\n        break;\n\n      case VAR_28:\n        VAR_3->uri_host = VAR_4;\n        VAR_3->uri_host_len = VAR_7;\n        PRINTF(\"Uri-Host [%.*s]\\n\", VAR_3->uri_host_len, VAR_3->uri_host);\n        break;\n      case VAR_29:\n        VAR_3->uri_port = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Uri-Port [%u]\\n\", VAR_3->uri_port);\n        break;\n      case VAR_30:\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        coap_add_multi_option( &(VAR_3->uri_path), VAR_4, VAR_7, 1);\n        PRINTF(\"Uri-Path [%.*s]\\n\", VAR_7, VAR_4);\n        break;\n      case VAR_31:\n        /* COMMENT_8 */\n        /* COMMENT_10 */\n        coap_add_multi_option( &(VAR_3->uri_query), VAR_4, VAR_7, 1);\n        PRINTF(\"Uri-Query [%.*s]\\n\", VAR_7, VAR_4);\n        break;\n\n      case VAR_32:\n        coap_add_multi_option( &(VAR_3->location_path), VAR_4, VAR_7, 1);\n        break;\n      case VAR_33:\n        /* COMMENT_8 */\n        coap_merge_multi_option( &(VAR_3->location_query), &(VAR_3->location_query_len), VAR_4, VAR_7, '&');\n        PRINTF(\"Location-Query [%.*s]\\n\", VAR_7, VAR_4);\n        break;\n\n      case VAR_34:\n        /* COMMENT_11 */\n        VAR_3->proxy_uri = VAR_4;\n        VAR_3->proxy_uri_len = VAR_7;\n        /* COMMENT_12 */\n        PRINTF(\"Proxy-Uri NOT IMPLEMENTED [%.*s]\\n\", VAR_3->proxy_uri_len, VAR_3->proxy_uri);\n        VAR_16 = \"This is a constrained server (Contiki)\";\n        return VAR_35;\n        break;\n\n      case VAR_36:\n        VAR_3->observe = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Observe [%lu]\\n\", VAR_3->observe);\n        break;\n      case VAR_37:\n        VAR_3->block2_num = coap_parse_int_option(VAR_4, VAR_7);\n        VAR_3->block2_more = (VAR_3->block2_num & 0x08)>>3;\n        VAR_3->block2_size = 16 << (VAR_3->block2_num & 0x07);\n        VAR_3->block2_offset = (VAR_3->block2_num & ~0x0000000F)<<(VAR_3->block2_num & 0x07);\n        VAR_3->block2_num >>= 4;\n        PRINTF(\"Block2 [%lu%s (%u B/blk)]\\n\", VAR_3->block2_num, VAR_3->block2_more ? \"+\" : \"\", VAR_3->block2_size);\n        break;\n      case VAR_38:\n        VAR_3->block1_num = coap_parse_int_option(VAR_4, VAR_7);\n        VAR_3->block1_more = (VAR_3->block1_num & 0x08)>>3;\n        VAR_3->block1_size = 16 << (VAR_3->block1_num & 0x07);\n        VAR_3->block1_offset = (VAR_3->block1_num & ~0x0000000F)<<(VAR_3->block1_num & 0x07);\n        VAR_3->block1_num >>= 4;\n        PRINTF(\"Block1 [%lu%s (%u B/blk)]\\n\", VAR_3->block1_num, VAR_3->block1_more ? \"+\" : \"\", VAR_3->block1_size);\n        break;\n      case VAR_39:\n        VAR_3->size = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Size [%lu]\\n\", VAR_3->size);\n        break;\n      default:\n        PRINTF(\"unknown (%u)\\n\", VAR_5);\n        /* COMMENT_13 */\n        if (VAR_5 & 1)\n        {\n          VAR_16 = \"Unsupported critical option\";\n          return VAR_40;\n        }\n    }\n\n    VAR_4 += VAR_7;\n  } /* COMMENT_14 */\n  PRINTF(\"-Done parsing-------\\n\");\n\n\n\n  return VAR_41;\n}",
  "func_graph_path_before": "eclipse-wakaama/wakaama/533f285ff6fd9c2284fd290bdfbd355e302ae9a4/er-coap-13.c/vul/before/0.json",
  "func": "coap_status_t\ncoap_parse_message(void *packet, uint8_t *data, uint16_t data_len)\n{\n  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;\n  uint8_t *current_option;\n  unsigned int option_number = 0;\n  unsigned int option_delta = 0;\n  size_t option_length = 0;\n  unsigned int *x;\n\n  /* Initialize packet */\n  memset(coap_pkt, 0, sizeof(coap_packet_t));\n\n  /* pointer to packet bytes */\n  coap_pkt->buffer = data;\n\n  /* parse header fields */\n  coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION;\n  coap_pkt->type = (COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION;\n  coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION);\n  coap_pkt->code = coap_pkt->buffer[1];\n  coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3];\n\n  if (coap_pkt->version != 1)\n  {\n    coap_error_message = \"CoAP version must be 1\";\n    return BAD_REQUEST_4_00;\n  }\n\n  current_option = data + COAP_HEADER_LEN;\n\n  if (coap_pkt->token_len != 0)\n  {\n      memcpy(coap_pkt->token, current_option, coap_pkt->token_len);\n      SET_OPTION(coap_pkt, COAP_OPTION_TOKEN);\n\n      PRINTF(\"Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->token_len,\n        coap_pkt->token[0],\n        coap_pkt->token[1],\n        coap_pkt->token[2],\n        coap_pkt->token[3],\n        coap_pkt->token[4],\n        coap_pkt->token[5],\n        coap_pkt->token[6],\n        coap_pkt->token[7]\n      ); /*FIXME always prints 8 bytes */\n  }\n\n  /* parse options */\n  current_option += coap_pkt->token_len;\n\n  while (current_option < data+data_len)\n  {\n    /* Payload marker 0xFF, currently only checking for 0xF* because rest is reserved */\n    if ((current_option[0] & 0xF0)==0xF0)\n    {\n      coap_pkt->payload = ++current_option;\n      coap_pkt->payload_len = data_len - (coap_pkt->payload - data);\n\n      break;\n    }\n\n    option_delta = current_option[0]>>4;\n    option_length = current_option[0] & 0x0F;\n    ++current_option;\n\n    /* avoids code duplication without function overhead */\n    x = &option_delta;\n    do\n    {\n      if (*x==13)\n      {\n        *x += current_option[0];\n        ++current_option;\n      }\n      else if (*x==14)\n      {\n        *x += 255;\n        *x += current_option[0]<<8;\n        ++current_option;\n        *x += current_option[0];\n        ++current_option;\n      }\n    }\n    while (x!=(unsigned int *)&option_length && (x=(unsigned int *)&option_length));\n\n    option_number += option_delta;\n\n    if (current_option + option_length > data + data_len)\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", option_number, option_delta, option_length);\n        coap_free_header(coap_pkt);\n        return BAD_REQUEST_4_00;\n    }\n    else\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u): \", option_number, option_delta, option_length);\n    }\n\n    SET_OPTION(coap_pkt, option_number);\n\n    switch (option_number)\n    {\n      case COAP_OPTION_CONTENT_TYPE:\n        coap_pkt->content_type = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Content-Format [%u]\\n\", coap_pkt->content_type);\n        break;\n      case COAP_OPTION_MAX_AGE:\n        coap_pkt->max_age = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Max-Age [%lu]\\n\", coap_pkt->max_age);\n        break;\n      case COAP_OPTION_ETAG:\n        coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len);\n        PRINTF(\"ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->etag_len,\n          coap_pkt->etag[0],\n          coap_pkt->etag[1],\n          coap_pkt->etag[2],\n          coap_pkt->etag[3],\n          coap_pkt->etag[4],\n          coap_pkt->etag[5],\n          coap_pkt->etag[6],\n          coap_pkt->etag[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_ACCEPT:\n        if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM)\n        {\n          coap_pkt->accept[coap_pkt->accept_num] = coap_parse_int_option(current_option, option_length);\n          coap_pkt->accept_num += 1;\n          PRINTF(\"Accept [%u]\\n\", coap_pkt->content_type);\n        }\n        break;\n      case COAP_OPTION_IF_MATCH:\n        /*FIXME support multiple ETags */\n        coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len);\n        PRINTF(\"If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->if_match_len,\n          coap_pkt->if_match[0],\n          coap_pkt->if_match[1],\n          coap_pkt->if_match[2],\n          coap_pkt->if_match[3],\n          coap_pkt->if_match[4],\n          coap_pkt->if_match[5],\n          coap_pkt->if_match[6],\n          coap_pkt->if_match[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_IF_NONE_MATCH:\n        coap_pkt->if_none_match = 1;\n        PRINTF(\"If-None-Match\\n\");\n        break;\n\n      case COAP_OPTION_URI_HOST:\n        coap_pkt->uri_host = current_option;\n        coap_pkt->uri_host_len = option_length;\n        PRINTF(\"Uri-Host [%.*s]\\n\", coap_pkt->uri_host_len, coap_pkt->uri_host);\n        break;\n      case COAP_OPTION_URI_PORT:\n        coap_pkt->uri_port = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Uri-Port [%u]\\n\", coap_pkt->uri_port);\n        break;\n      case COAP_OPTION_URI_PATH:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_path), &(coap_pkt->uri_path_len), current_option, option_length, 0);\n        coap_add_multi_option( &(coap_pkt->uri_path), current_option, option_length, 1);\n        PRINTF(\"Uri-Path [%.*s]\\n\", option_length, current_option);\n        break;\n      case COAP_OPTION_URI_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_query), &(coap_pkt->uri_query_len), current_option, option_length, '&');\n        coap_add_multi_option( &(coap_pkt->uri_query), current_option, option_length, 1);\n        PRINTF(\"Uri-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_LOCATION_PATH:\n        coap_add_multi_option( &(coap_pkt->location_path), current_option, option_length, 1);\n        break;\n      case COAP_OPTION_LOCATION_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        coap_merge_multi_option( &(coap_pkt->location_query), &(coap_pkt->location_query_len), current_option, option_length, '&');\n        PRINTF(\"Location-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_PROXY_URI:\n        /*FIXME check for own end-point */\n        coap_pkt->proxy_uri = current_option;\n        coap_pkt->proxy_uri_len = option_length;\n        /*TODO length > 270 not implemented (actually not required) */\n        PRINTF(\"Proxy-Uri NOT IMPLEMENTED [%.*s]\\n\", coap_pkt->proxy_uri_len, coap_pkt->proxy_uri);\n        coap_error_message = \"This is a constrained server (Contiki)\";\n        return PROXYING_NOT_SUPPORTED_5_05;\n        break;\n\n      case COAP_OPTION_OBSERVE:\n        coap_pkt->observe = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Observe [%lu]\\n\", coap_pkt->observe);\n        break;\n      case COAP_OPTION_BLOCK2:\n        coap_pkt->block2_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block2_more = (coap_pkt->block2_num & 0x08)>>3;\n        coap_pkt->block2_size = 16 << (coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_offset = (coap_pkt->block2_num & ~0x0000000F)<<(coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_num >>= 4;\n        PRINTF(\"Block2 [%lu%s (%u B/blk)]\\n\", coap_pkt->block2_num, coap_pkt->block2_more ? \"+\" : \"\", coap_pkt->block2_size);\n        break;\n      case COAP_OPTION_BLOCK1:\n        coap_pkt->block1_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block1_more = (coap_pkt->block1_num & 0x08)>>3;\n        coap_pkt->block1_size = 16 << (coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_offset = (coap_pkt->block1_num & ~0x0000000F)<<(coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_num >>= 4;\n        PRINTF(\"Block1 [%lu%s (%u B/blk)]\\n\", coap_pkt->block1_num, coap_pkt->block1_more ? \"+\" : \"\", coap_pkt->block1_size);\n        break;\n      case COAP_OPTION_SIZE:\n        coap_pkt->size = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Size [%lu]\\n\", coap_pkt->size);\n        break;\n      default:\n        PRINTF(\"unknown (%u)\\n\", option_number);\n        /* Check if critical (odd) */\n        if (option_number & 1)\n        {\n          coap_error_message = \"Unsupported critical option\";\n          coap_free_header(coap_pkt);\n          return BAD_OPTION_4_02;\n        }\n    }\n\n    current_option += option_length;\n  } /* for */\n  PRINTF(\"-Done parsing-------\\n\");\n\n\n\n  return NO_ERROR;\n}",
  "abstract_func": "coap_status_t\ncoap_parse_message(void *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)\n{\n  coap_packet_t *const VAR_3 = (coap_packet_t *) VAR_0;\n  uint8_t *VAR_4;\n  unsigned int VAR_5 = 0;\n  unsigned int VAR_6 = 0;\n  size_t VAR_7 = 0;\n  unsigned int *VAR_8;\n\n  /* COMMENT_0 */\n  memset(VAR_3, 0, sizeof(coap_packet_t));\n\n  /* COMMENT_1 */\n  VAR_3->buffer = VAR_1;\n\n  /* COMMENT_2 */\n  VAR_3->version = (VAR_9 & VAR_3->buffer[0])>>VAR_10;\n  VAR_3->type = (VAR_11 & VAR_3->buffer[0])>>VAR_12;\n  VAR_3->token_len = MIN(VAR_13, (VAR_14 & VAR_3->buffer[0])>>VAR_15);\n  VAR_3->code = VAR_3->buffer[1];\n  VAR_3->mid = VAR_3->buffer[2]<<8 | VAR_3->buffer[3];\n\n  if (VAR_3->version != 1)\n  {\n    VAR_16 = \"CoAP version must be 1\";\n    return VAR_17;\n  }\n\n  VAR_4 = VAR_1 + VAR_18;\n\n  if (VAR_3->token_len != 0)\n  {\n      memcpy(VAR_3->token, VAR_4, VAR_3->token_len);\n      SET_OPTION(VAR_3, VAR_19);\n\n      PRINTF(\"Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", VAR_3->token_len,\n        VAR_3->token[0],\n        VAR_3->token[1],\n        VAR_3->token[2],\n        VAR_3->token[3],\n        VAR_3->token[4],\n        VAR_3->token[5],\n        VAR_3->token[6],\n        VAR_3->token[7]\n      ); /* COMMENT_3 */\n  }\n\n  /* COMMENT_4 */\n  VAR_4 += VAR_3->token_len;\n\n  while (VAR_4 < VAR_1+VAR_2)\n  {\n    /* COMMENT_5 */\n    if ((VAR_4[0] & 0xF0)==0xF0)\n    {\n      VAR_3->payload = ++VAR_4;\n      VAR_3->payload_len = VAR_2 - (VAR_3->payload - VAR_1);\n\n      break;\n    }\n\n    VAR_6 = VAR_4[0]>>4;\n    VAR_7 = VAR_4[0] & 0x0F;\n    ++VAR_4;\n\n    /* COMMENT_6 */\n    VAR_8 = &VAR_6;\n    do\n    {\n      if (*VAR_8==13)\n      {\n        *VAR_8 += VAR_4[0];\n        ++VAR_4;\n      }\n      else if (*VAR_8==14)\n      {\n        *VAR_8 += 255;\n        *VAR_8 += VAR_4[0]<<8;\n        ++VAR_4;\n        *VAR_8 += VAR_4[0];\n        ++VAR_4;\n      }\n    }\n    while (VAR_8!=(unsigned int *)&VAR_7 && (VAR_8=(unsigned int *)&VAR_7));\n\n    VAR_5 += VAR_6;\n\n    if (VAR_4 + VAR_7 > VAR_1 + VAR_2)\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", VAR_5, VAR_6, VAR_7);\n        coap_free_header(VAR_3);\n        return VAR_17;\n    }\n    else\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u): \", VAR_5, VAR_6, VAR_7);\n    }\n\n    SET_OPTION(VAR_3, VAR_5);\n\n    switch (VAR_5)\n    {\n      case VAR_20:\n        VAR_3->content_type = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Content-Format [%u]\\n\", VAR_3->content_type);\n        break;\n      case VAR_21:\n        VAR_3->max_age = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Max-Age [%lu]\\n\", VAR_3->max_age);\n        break;\n      case VAR_22:\n        VAR_3->etag_len = (uint8_t)(MIN(VAR_23, VAR_7));\n        memcpy(VAR_3->etag, VAR_4, VAR_3->etag_len);\n        PRINTF(\"ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", VAR_3->etag_len,\n          VAR_3->etag[0],\n          VAR_3->etag[1],\n          VAR_3->etag[2],\n          VAR_3->etag[3],\n          VAR_3->etag[4],\n          VAR_3->etag[5],\n          VAR_3->etag[6],\n          VAR_3->etag[7]\n        ); /* COMMENT_3 */\n        break;\n      case VAR_24:\n        if (VAR_3->accept_num < VAR_25)\n        {\n          VAR_3->accept[VAR_3->accept_num] = coap_parse_int_option(VAR_4, VAR_7);\n          VAR_3->accept_num += 1;\n          PRINTF(\"Accept [%u]\\n\", VAR_3->content_type);\n        }\n        break;\n      case VAR_26:\n        /* COMMENT_7 */\n        VAR_3->if_match_len = (uint8_t)(MIN(VAR_23, VAR_7));\n        memcpy(VAR_3->if_match, VAR_4, VAR_3->if_match_len);\n        PRINTF(\"If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", VAR_3->if_match_len,\n          VAR_3->if_match[0],\n          VAR_3->if_match[1],\n          VAR_3->if_match[2],\n          VAR_3->if_match[3],\n          VAR_3->if_match[4],\n          VAR_3->if_match[5],\n          VAR_3->if_match[6],\n          VAR_3->if_match[7]\n        ); /* COMMENT_3 */\n        break;\n      case VAR_27:\n        VAR_3->if_none_match = 1;\n        PRINTF(\"If-None-Match\\n\");\n        break;\n\n      case VAR_28:\n        VAR_3->uri_host = VAR_4;\n        VAR_3->uri_host_len = VAR_7;\n        PRINTF(\"Uri-Host [%.*s]\\n\", VAR_3->uri_host_len, VAR_3->uri_host);\n        break;\n      case VAR_29:\n        VAR_3->uri_port = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Uri-Port [%u]\\n\", VAR_3->uri_port);\n        break;\n      case VAR_30:\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        coap_add_multi_option( &(VAR_3->uri_path), VAR_4, VAR_7, 1);\n        PRINTF(\"Uri-Path [%.*s]\\n\", VAR_7, VAR_4);\n        break;\n      case VAR_31:\n        /* COMMENT_8 */\n        /* COMMENT_10 */\n        coap_add_multi_option( &(VAR_3->uri_query), VAR_4, VAR_7, 1);\n        PRINTF(\"Uri-Query [%.*s]\\n\", VAR_7, VAR_4);\n        break;\n\n      case VAR_32:\n        coap_add_multi_option( &(VAR_3->location_path), VAR_4, VAR_7, 1);\n        break;\n      case VAR_33:\n        /* COMMENT_8 */\n        coap_merge_multi_option( &(VAR_3->location_query), &(VAR_3->location_query_len), VAR_4, VAR_7, '&');\n        PRINTF(\"Location-Query [%.*s]\\n\", VAR_7, VAR_4);\n        break;\n\n      case VAR_34:\n        /* COMMENT_11 */\n        VAR_3->proxy_uri = VAR_4;\n        VAR_3->proxy_uri_len = VAR_7;\n        /* COMMENT_12 */\n        PRINTF(\"Proxy-Uri NOT IMPLEMENTED [%.*s]\\n\", VAR_3->proxy_uri_len, VAR_3->proxy_uri);\n        VAR_16 = \"This is a constrained server (Contiki)\";\n        return VAR_35;\n        break;\n\n      case VAR_36:\n        VAR_3->observe = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Observe [%lu]\\n\", VAR_3->observe);\n        break;\n      case VAR_37:\n        VAR_3->block2_num = coap_parse_int_option(VAR_4, VAR_7);\n        VAR_3->block2_more = (VAR_3->block2_num & 0x08)>>3;\n        VAR_3->block2_size = 16 << (VAR_3->block2_num & 0x07);\n        VAR_3->block2_offset = (VAR_3->block2_num & ~0x0000000F)<<(VAR_3->block2_num & 0x07);\n        VAR_3->block2_num >>= 4;\n        PRINTF(\"Block2 [%lu%s (%u B/blk)]\\n\", VAR_3->block2_num, VAR_3->block2_more ? \"+\" : \"\", VAR_3->block2_size);\n        break;\n      case VAR_38:\n        VAR_3->block1_num = coap_parse_int_option(VAR_4, VAR_7);\n        VAR_3->block1_more = (VAR_3->block1_num & 0x08)>>3;\n        VAR_3->block1_size = 16 << (VAR_3->block1_num & 0x07);\n        VAR_3->block1_offset = (VAR_3->block1_num & ~0x0000000F)<<(VAR_3->block1_num & 0x07);\n        VAR_3->block1_num >>= 4;\n        PRINTF(\"Block1 [%lu%s (%u B/blk)]\\n\", VAR_3->block1_num, VAR_3->block1_more ? \"+\" : \"\", VAR_3->block1_size);\n        break;\n      case VAR_39:\n        VAR_3->size = coap_parse_int_option(VAR_4, VAR_7);\n        PRINTF(\"Size [%lu]\\n\", VAR_3->size);\n        break;\n      default:\n        PRINTF(\"unknown (%u)\\n\", VAR_5);\n        /* COMMENT_13 */\n        if (VAR_5 & 1)\n        {\n          VAR_16 = \"Unsupported critical option\";\n          coap_free_header(VAR_3);\n          return VAR_40;\n        }\n    }\n\n    VAR_4 += VAR_7;\n  } /* COMMENT_14 */\n  PRINTF(\"-Done parsing-------\\n\");\n\n\n\n  return VAR_41;\n}",
  "func_graph_path": "eclipse-wakaama/wakaama/533f285ff6fd9c2284fd290bdfbd355e302ae9a4/er-coap-13.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -89,6 +89,7 @@\n     if (current_option + option_length > data + data_len)\n     {\n         PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", option_number, option_delta, option_length);\n+        coap_free_header(coap_pkt);\n         return BAD_REQUEST_4_00;\n     }\n     else\n@@ -221,6 +222,7 @@\n         if (option_number & 1)\n         {\n           coap_error_message = \"Unsupported critical option\";\n+          coap_free_header(coap_pkt);\n           return BAD_OPTION_4_02;\n         }\n     }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        coap_free_header(coap_pkt);",
      "          coap_free_header(coap_pkt);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-wakaama/wakaama/pull/426",
  "description": {
    "pr_info": {
      "title": "Fix memory leak with bad options.",
      "number": 426
    },
    "comment": [
      "Option processing can allocate memory. Encountering a bad option was\r\nreturning and error without freeing that memory. This adds the necessary\r\ncalls to free the memory to fix #425.\r\n\r\nSigned-off-by: Scott Bertin <sbertin@telular.com>"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe commit addresses a memory leak by freeing allocated memory when encountering invalid options, which prevents resource exhaustion and potential denial of service attacks."
}