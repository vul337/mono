{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveInterfaceMethodRefInto",
  "func_before": "J9Method *   \nresolveInterfaceMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMInterfaceMethodRef *ramCPEntry)\n{\n\tJ9Method *returnValue = NULL;\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *interfaceClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method;\n\tJ9Class *cpClass;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInterfaceMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tinterfaceClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If interfaceClass is NULL, the exception has already been set. */\n\tif (interfaceClass == NULL) {\n\t\tgoto done;\n\t}\n\n\tif ((interfaceClass->romClass->modifiers & J9AccInterface) != J9AccInterface) {\n\t\tif (throwException) {\n\t\t\tJ9UTF8 *className = J9ROMCLASS_CLASSNAME(interfaceClass->romClass);\n\t\t\tj9object_t detailMessage = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(className), J9UTF8_LENGTH(className), J9_STR_XLAT);\n\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)detailMessage);\n\t\t}\n\t\tgoto done;\n\t}\n\t\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\tlookupOptions |= J9_LOOK_INTERFACE;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, interfaceClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveInterfaceMethodRef_lookupMethod(vmStruct, method);\n\t\n\t/* If method is NULL, the exception has already been set. */\n\tif (method != NULL) {\n\t\tif (ramCPEntry != NULL) {\n\t\t\tJ9RAMInterfaceMethodRef *ramInterfaceMethodRef = (J9RAMInterfaceMethodRef *)&ramCP[cpIndex];\n\t\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\t\tUDATA methodIndex = 0;\n\t\t\tUDATA oldArgCount = ramInterfaceMethodRef->methodIndexAndArgCount & 255;\n\t\t\tUDATA tagBits = 0;\n\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\tif (J9_ARE_ANY_BITS_SET(methodClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Resolved method is in an interface class */\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccPrivate)) {\n\t\t\t\t\t/* Resolved method is a private interface method which does not appear in the\n\t\t\t\t\t * vTable or iTable.  Use the index into ramMethods in interfaceClass. This is\n\t\t\t\t\t * only allowed in JDK11 and beyond.\n\t\t\t\t\t */\n\t\t\t\t\tif (J2SE_VERSION(vm) < J2SE_V11) {\nnonpublic:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetIllegalAccessErrorNonPublicInvokeInterface(vmStruct, method);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is a public interface method which appears in the\n\t\t\t\t\t * vTable and iTable.  Use the iTable index in interfaceClass.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getITableIndexForMethod(method, interfaceClass);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Resolved method is in Object */\n\t\t\t\tAssert_VM_true(methodClass == J9VMJAVALANGOBJECT_OR_NULL(vm));\n\t\t\t\t/* Interfaces inherit only public methods from Object */\n\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccPublic)) {\n\t\t\t\t\tgoto nonpublic;\n\t\t\t\t}\n\t\t\t\tif (J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n\t\t\t\t\t/* Resolved method is in the vTable, so it must be invoked via the\n\t\t\t\t\t * receiver's vTable.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getVTableOffsetForMethod(method, methodClass, vmStruct);\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is not in the vTable, so invoke it directly\n\t\t\t\t\t * via the index into ramMethods in Object.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t}\n\t\t\t\ttagBits |= J9_ITABLE_INDEX_OBJECT;\n\t\t\t}\n\t\t\t/* Ensure methodIndex can be shifted without losing any bits */\n\t\t\tAssert_VM_true(methodIndex < ((UDATA)1 << ((sizeof(UDATA) * 8) - J9_ITABLE_INDEX_SHIFT)));\n\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n\t\t}\n\t\t/* indicate success */\n\t\treturnValue = method;\n\t}\n\ndone:\n\tTrc_VM_resolveInterfaceMethodRef_Exit(vmStruct, returnValue);\n\treturn returnValue;\n}",
  "abstract_func_before": "J9Method *   \nresolveInterfaceMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMInterfaceMethodRef *VAR_4)\n{\n\tJ9Method *VAR_5 = NULL;\n\tJ9ROMMethodRef *VAR_6;\n\tJ9Class *VAR_7;\n\tJ9ROMNameAndSignature *VAR_8;\n\tJ9Method *VAR_9;\n\tJ9Class *VAR_10;\n\tJ9JavaVM *VAR_11 = VAR_0->javaVM;\n\tbool VAR_12 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = !VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tbool VAR_16 = VAR_14 && J9_ARE_NO_BITS_SET(VAR_3, VAR_17);\n\tUDATA VAR_18 = 0;\n\tif (VAR_14) {\n\t\tif (!VAR_16) {\n\t\t\tVAR_18 = VAR_19;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_18 = VAR_20;\n\t}\n\n\tTrc_VM_resolveInterfaceMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\tVAR_6 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\n\tcheckForDecompile(VAR_0, VAR_6, VAR_12);\n\n\t/* COMMENT_0 */\n\tVAR_7 = resolveClassRef(VAR_0, VAR_1, VAR_6->classRefCPIndex, VAR_3);\n\t\n\t/* COMMENT_1 */\n\tif (VAR_7 == NULL) {\n\t\tgoto done;\n\t}\n\n\tif ((VAR_7->romClass->modifiers & VAR_21) != VAR_21) {\n\t\tif (VAR_16) {\n\t\t\tJ9UTF8 *VAR_22 = J9ROMCLASS_CLASSNAME(VAR_7->romClass);\n\t\t\tj9object_t VAR_23 = VAR_11->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_22), J9UTF8_LENGTH(VAR_22), VAR_24);\n\t\t\tsetCurrentException(VAR_0, VAR_25, (UDATA *)VAR_23);\n\t\t}\n\t\tgoto done;\n\t}\n\t\n\tVAR_8 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_6);\n\tVAR_18 |= VAR_26;\n\tif ((VAR_3 & VAR_27) == VAR_27) {\n\t\tVAR_10 = NULL;\n\t} else {\n\t\tVAR_10 = J9_CLASS_FROM_CP(VAR_1);\n\t\tVAR_18 |= VAR_28;\n\t}\n\tVAR_9 = (J9Method *)javaLookupMethod(VAR_0, VAR_7, VAR_8, VAR_10, VAR_18);\n\n\tTrc_VM_resolveInterfaceMethodRef_lookupMethod(VAR_0, VAR_9);\n\t\n\t/* COMMENT_2 */\n\tif (VAR_9 != NULL) {\n\t\tif (VAR_4 != NULL) {\n\t\t\tJ9RAMInterfaceMethodRef *VAR_29 = (J9RAMInterfaceMethodRef *)&VAR_1[VAR_2];\n\t\t\tJ9Class *VAR_30 = J9_CLASS_FROM_METHOD(VAR_9);\n\t\t\tUDATA VAR_31 = 0;\n\t\t\tUDATA VAR_32 = VAR_29->methodIndexAndArgCount & 255;\n\t\t\tUDATA VAR_33 = 0;\n\t\t\tJ9ROMMethod *VAR_34 = J9_ROM_METHOD_FROM_RAM_METHOD(VAR_9);\n\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_30->romClass->modifiers, VAR_21)) {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_34->modifiers, VAR_35)) {\n\t\t\t\t\t/* COMMENT_4 */\n                                                                                   \n                                         \n        \n\t\t\t\t\tif (J2SE_VERSION(VAR_11) < VAR_36) {\nnonpublic:\n\t\t\t\t\t\tif (VAR_16) {\n\t\t\t\t\t\t\tsetIllegalAccessErrorNonPublicInvokeInterface(VAR_0, VAR_9);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_31 = (VAR_9 - VAR_30->ramMethods);\n\t\t\t\t\tVAR_33 |= VAR_37;\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_8 */\n                                                                   \n        \n\t\t\t\t\tVAR_31 = getITableIndexForMethod(VAR_9, VAR_7);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\tAssert_VM_true(VAR_30 == J9VMJAVALANGOBJECT_OR_NULL(VAR_11));\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tif (J9_ARE_NO_BITS_SET(VAR_34->modifiers, VAR_38)) {\n\t\t\t\t\tgoto nonpublic;\n\t\t\t\t}\n\t\t\t\tif (J9ROMMETHOD_HAS_VTABLE(VAR_34)) {\n\t\t\t\t\t/* COMMENT_13 */\n                          \n        \n\t\t\t\t\tVAR_31 = getVTableOffsetForMethod(VAR_9, VAR_30, VAR_0);\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_16 */\n                                                \n        \n\t\t\t\t\tVAR_31 = (VAR_9 - VAR_30->ramMethods);\n\t\t\t\t\tVAR_33 |= VAR_37;\n\t\t\t\t}\n\t\t\t\tVAR_33 |= VAR_39;\n\t\t\t}\n\t\t\t/* COMMENT_19 */\n\t\t\tAssert_VM_true(VAR_31 < ((UDATA)1 << ((sizeof(UDATA) * 8) - VAR_40)));\n\t\t\tVAR_31 <<= VAR_40;\n\t\t\tVAR_31 = VAR_31 | VAR_33 | VAR_32;\n\t\t\tVAR_4->methodIndexAndArgCount = VAR_31;\n\t\t\tVAR_4->interfaceClass = (UDATA)VAR_7;\n\t\t}\n\t\t/* COMMENT_20 */\n\t\tVAR_5 = VAR_9;\n\t}\n\ndone:\n\tTrc_VM_resolveInterfaceMethodRef_Exit(VAR_0, VAR_5);\n\treturn VAR_5;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/7.json",
  "func": "J9Method *   \nresolveInterfaceMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMInterfaceMethodRef *ramCPEntry)\n{\n\tJ9Method *returnValue = NULL;\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *interfaceClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method;\n\tJ9Class *cpClass;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInterfaceMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tinterfaceClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If interfaceClass is NULL, the exception has already been set. */\n\tif (interfaceClass == NULL) {\n\t\tgoto done;\n\t}\n\n\tif ((interfaceClass->romClass->modifiers & J9AccInterface) != J9AccInterface) {\n\t\tif (throwException) {\n\t\t\tJ9UTF8 *className = J9ROMCLASS_CLASSNAME(interfaceClass->romClass);\n\t\t\tj9object_t detailMessage = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(className), J9UTF8_LENGTH(className), J9_STR_XLAT);\n\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)detailMessage);\n\t\t}\n\t\tgoto done;\n\t}\n\t\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\tlookupOptions |= J9_LOOK_INTERFACE;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, interfaceClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveInterfaceMethodRef_lookupMethod(vmStruct, method);\n\t\n\t/* If method is NULL, the exception has already been set. */\n\tif (method != NULL) {\n\t\tif (ramCPEntry != NULL) {\n\t\t\tJ9RAMInterfaceMethodRef *ramInterfaceMethodRef = (J9RAMInterfaceMethodRef *)&ramCP[cpIndex];\n\t\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\t\tUDATA methodIndex = 0;\n\t\t\tUDATA oldArgCount = ramInterfaceMethodRef->methodIndexAndArgCount & 255;\n\t\t\tUDATA tagBits = 0;\n\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\tif (J9_ARE_ANY_BITS_SET(methodClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Resolved method is in an interface class */\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccPrivate)) {\n\t\t\t\t\t/* Resolved method is a private interface method which does not appear in the\n\t\t\t\t\t * vTable or iTable.  Use the index into ramMethods in interfaceClass. This is\n\t\t\t\t\t * only allowed in JDK11 and beyond.\n\t\t\t\t\t */\n\t\t\t\t\tif (J2SE_VERSION(vm) < J2SE_V11) {\nnonpublic:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetIllegalAccessErrorNonPublicInvokeInterface(vmStruct, method);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is a public interface method which appears in the\n\t\t\t\t\t * vTable and iTable.  Use the iTable index in interfaceClass.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getITableIndexForMethod(method, interfaceClass);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Resolved method is in Object */\n\t\t\t\tAssert_VM_true(methodClass == J9VMJAVALANGOBJECT_OR_NULL(vm));\n\t\t\t\t/* Interfaces inherit only public methods from Object */\n\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccPublic)) {\n\t\t\t\t\tgoto nonpublic;\n\t\t\t\t}\n\t\t\t\tif (J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n\t\t\t\t\t/* Resolved method is in the vTable, so it must be invoked via the\n\t\t\t\t\t * receiver's vTable.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getVTableOffsetForMethod(method, methodClass, vmStruct);\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is not in the vTable, so invoke it directly\n\t\t\t\t\t * via the index into ramMethods in Object.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t}\n\t\t\t\ttagBits |= J9_ITABLE_INDEX_OBJECT;\n\t\t\t}\n\t\t\t/* Ensure methodIndex can be shifted without losing any bits */\n\t\t\tAssert_VM_true(methodIndex < ((UDATA)1 << ((sizeof(UDATA) * 8) - J9_ITABLE_INDEX_SHIFT)));\n\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n\t\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n\t\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n\t\t\t}\n\t\t}\n\t\t/* indicate success */\n\t\treturnValue = method;\n\t}\n\ndone:\n\tTrc_VM_resolveInterfaceMethodRef_Exit(vmStruct, returnValue);\n\treturn returnValue;\n}",
  "abstract_func": "J9Method *   \nresolveInterfaceMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMInterfaceMethodRef *VAR_4)\n{\n\tJ9Method *VAR_5 = NULL;\n\tJ9ROMMethodRef *VAR_6;\n\tJ9Class *VAR_7;\n\tJ9ROMNameAndSignature *VAR_8;\n\tJ9Method *VAR_9;\n\tJ9Class *VAR_10;\n\tJ9JavaVM *VAR_11 = VAR_0->javaVM;\n\tbool VAR_12 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = !VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tbool VAR_16 = VAR_14 && J9_ARE_NO_BITS_SET(VAR_3, VAR_17);\n\tUDATA VAR_18 = 0;\n\tif (VAR_14) {\n\t\tif (!VAR_16) {\n\t\t\tVAR_18 = VAR_19;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_18 = VAR_20;\n\t}\n\n\tTrc_VM_resolveInterfaceMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\tVAR_6 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\n\tcheckForDecompile(VAR_0, VAR_6, VAR_12);\n\n\t/* COMMENT_0 */\n\tVAR_7 = resolveClassRef(VAR_0, VAR_1, VAR_6->classRefCPIndex, VAR_3);\n\t\n\t/* COMMENT_1 */\n\tif (VAR_7 == NULL) {\n\t\tgoto done;\n\t}\n\n\tif ((VAR_7->romClass->modifiers & VAR_21) != VAR_21) {\n\t\tif (VAR_16) {\n\t\t\tJ9UTF8 *VAR_22 = J9ROMCLASS_CLASSNAME(VAR_7->romClass);\n\t\t\tj9object_t VAR_23 = VAR_11->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_22), J9UTF8_LENGTH(VAR_22), VAR_24);\n\t\t\tsetCurrentException(VAR_0, VAR_25, (UDATA *)VAR_23);\n\t\t}\n\t\tgoto done;\n\t}\n\t\n\tVAR_8 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_6);\n\tVAR_18 |= VAR_26;\n\tif ((VAR_3 & VAR_27) == VAR_27) {\n\t\tVAR_10 = NULL;\n\t} else {\n\t\tVAR_10 = J9_CLASS_FROM_CP(VAR_1);\n\t\tVAR_18 |= VAR_28;\n\t}\n\tVAR_9 = (J9Method *)javaLookupMethod(VAR_0, VAR_7, VAR_8, VAR_10, VAR_18);\n\n\tTrc_VM_resolveInterfaceMethodRef_lookupMethod(VAR_0, VAR_9);\n\t\n\t/* COMMENT_2 */\n\tif (VAR_9 != NULL) {\n\t\tif (VAR_4 != NULL) {\n\t\t\tJ9RAMInterfaceMethodRef *VAR_29 = (J9RAMInterfaceMethodRef *)&VAR_1[VAR_2];\n\t\t\tJ9Class *VAR_30 = J9_CLASS_FROM_METHOD(VAR_9);\n\t\t\tUDATA VAR_31 = 0;\n\t\t\tUDATA VAR_32 = VAR_29->methodIndexAndArgCount & 255;\n\t\t\tUDATA VAR_33 = 0;\n\t\t\tJ9ROMMethod *VAR_34 = J9_ROM_METHOD_FROM_RAM_METHOD(VAR_9);\n\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_30->romClass->modifiers, VAR_21)) {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_34->modifiers, VAR_35)) {\n\t\t\t\t\t/* COMMENT_4 */\n                                                                                   \n                                         \n        \n\t\t\t\t\tif (J2SE_VERSION(VAR_11) < VAR_36) {\nnonpublic:\n\t\t\t\t\t\tif (VAR_16) {\n\t\t\t\t\t\t\tsetIllegalAccessErrorNonPublicInvokeInterface(VAR_0, VAR_9);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_31 = (VAR_9 - VAR_30->ramMethods);\n\t\t\t\t\tVAR_33 |= VAR_37;\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_8 */\n                                                                   \n        \n\t\t\t\t\tVAR_31 = getITableIndexForMethod(VAR_9, VAR_7);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\tAssert_VM_true(VAR_30 == J9VMJAVALANGOBJECT_OR_NULL(VAR_11));\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tif (J9_ARE_NO_BITS_SET(VAR_34->modifiers, VAR_38)) {\n\t\t\t\t\tgoto nonpublic;\n\t\t\t\t}\n\t\t\t\tif (J9ROMMETHOD_HAS_VTABLE(VAR_34)) {\n\t\t\t\t\t/* COMMENT_13 */\n                          \n        \n\t\t\t\t\tVAR_31 = getVTableOffsetForMethod(VAR_9, VAR_30, VAR_0);\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_16 */\n                                                \n        \n\t\t\t\t\tVAR_31 = (VAR_9 - VAR_30->ramMethods);\n\t\t\t\t\tVAR_33 |= VAR_37;\n\t\t\t\t}\n\t\t\t\tVAR_33 |= VAR_39;\n\t\t\t}\n\t\t\t/* COMMENT_19 */\n\t\t\tAssert_VM_true(VAR_31 < ((UDATA)1 << ((sizeof(UDATA) * 8) - VAR_40)));\n\t\t\tif (J9_ARE_NO_BITS_SET(VAR_3, VAR_41)) {\n\t\t\t\tVAR_31 <<= VAR_40;\n\t\t\t\tVAR_31 = VAR_31 | VAR_33 | VAR_32;\n\t\t\t\tVAR_4->methodIndexAndArgCount = VAR_31;\n\t\t\t\tVAR_4->interfaceClass = (UDATA)VAR_7;\n\t\t\t}\n\t\t}\n\t\t/* COMMENT_20 */\n\t\tVAR_5 = VAR_9;\n\t}\n\ndone:\n\tTrc_VM_resolveInterfaceMethodRef_Exit(VAR_0, VAR_5);\n\treturn VAR_5;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/7.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -109,10 +109,12 @@\n \t\t\t}\n \t\t\t/* Ensure methodIndex can be shifted without losing any bits */\n \t\t\tAssert_VM_true(methodIndex < ((UDATA)1 << ((sizeof(UDATA) * 8) - J9_ITABLE_INDEX_SHIFT)));\n-\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n-\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n-\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n-\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n+\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n+\t\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n+\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n+\t\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n+\t\t\t}\n \t\t}\n \t\t/* indicate success */\n \t\treturnValue = method;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;",
      "\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;",
      "\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;",
      "\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;"
    ],
    "added_lines": [
      "\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
      "\t\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;",
      "\t\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;",
      "\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;",
      "\t\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;",
      "\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.95  \n\n**Reasoning:**  \nThe commit addresses a bug (#12016) related to class loading and constant pool management, which is a core functionality improvement rather than a security fix. The code changes are clear and correctly implemented, though class loading could sometimes relate to security without explicit indicators."
}