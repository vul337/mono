{
  "cve_id": "CVE-2017-6800",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Yeraze/ytnef",
  "commit_msg": "BugFix - data length\n\nEven tho this is a \"LONG\" type, it's actually only 4 bytes. Typecasting\nit to a long* caused a dereference beyond the end of the allocated\nregion.\n\nissues#28",
  "commit_hash": "f98f5d4adc1c4bd4033638f6167c1bb95d642f89",
  "git_url": "https://github.com/Yeraze/ytnef/commit/f98f5d4adc1c4bd4033638f6167c1bb95d642f89",
  "file_path": "lib/ytnef.c",
  "func_name": "MAPIPrint",
  "func_before": "void MAPIPrint(MAPIProps *p) {\n  int j, i, index, h, x;\n  DDWORD *ddword_ptr;\n  DDWORD ddword_tmp;\n  dtr thedate;\n  MAPIProperty *mapi;\n  variableLength *mapidata;\n  variableLength vlTemp;\n  int found;\n\n  for (j = 0; j < p->count; j++) {\n    mapi = &(p->properties[j]);\n    printf(\"   #%i: Type: [\", j);\n    switch (PROP_TYPE(mapi->id)) {\n      case PT_UNSPECIFIED:\n        printf(\"  NONE   \"); break;\n      case PT_NULL:\n        printf(\"  NULL   \"); break;\n      case PT_I2:\n        printf(\"   I2    \"); break;\n      case PT_LONG:\n        printf(\"  LONG   \"); break;\n      case PT_R4:\n        printf(\"   R4    \"); break;\n      case PT_DOUBLE:\n        printf(\" DOUBLE  \"); break;\n      case PT_CURRENCY:\n        printf(\"CURRENCY \"); break;\n      case PT_APPTIME:\n        printf(\"APP TIME \"); break;\n      case PT_ERROR:\n        printf(\"  ERROR  \"); break;\n      case PT_BOOLEAN:\n        printf(\" BOOLEAN \"); break;\n      case PT_OBJECT:\n        printf(\" OBJECT  \"); break;\n      case PT_I8:\n        printf(\"   I8    \"); break;\n      case PT_STRING8:\n        printf(\" STRING8 \"); break;\n      case PT_UNICODE:\n        printf(\" UNICODE \"); break;\n      case PT_SYSTIME:\n        printf(\"SYS TIME \"); break;\n      case PT_CLSID:\n        printf(\"OLE GUID \"); break;\n      case PT_BINARY:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(mapi->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (mapi->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(mapi->id));\n    } else {\n      found = 0;\n      for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {\n        if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {\n          printf(\"%s\", MPList[index].name);\n          found = 1;\n        }\n      }\n      if (found == 0) {\n        printf(\"0x%04x\", PROP_ID(mapi->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (mapi->namedproperty > 0) {\n      for (i = 0; i < mapi->namedproperty; i++) {\n        printf(\"    Name: %s\\n\", mapi->propnames[i].data);\n      }\n    }\n    for (i = 0; i < mapi->count; i++) {\n      mapidata = &(mapi->data[i]);\n      if (mapi->count > 1) {\n        printf(\"    [%i/%u] \", i, mapi->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", mapidata->size);\n      switch (PROP_TYPE(mapi->id)) {\n        case PT_SYSTIME:\n          MAPISysTimetoDTR(mapidata->data, &thedate);\n          printf(\"    Value: \");\n          ddword_tmp = *((DDWORD *)mapidata->data);\n          TNEFPrintDate(thedate);\n          printf(\" [HEX: \");\n          for (x = 0; x < sizeof(ddword_tmp); x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"] (%llu)\\n\", ddword_tmp);\n          break;\n        case PT_LONG:\n          printf(\"    Value: %li\\n\", *((long*)mapidata->data));\n          break;\n        case PT_I2:\n          printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));\n          break;\n        case PT_BOOLEAN:\n          if (mapi->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case PT_OBJECT:\n          printf(\"\\n\");\n          break;\n        case PT_BINARY:\n          if (IsCompressedRTF(mapidata) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {\n              printf(\"%s\\n\", vlTemp.data);\n              free(vlTemp.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_STRING8:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n          if (strlen((char*)mapidata->data) != mapidata->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_CLSID:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(x=0; x< 16; x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n      }\n    }\n  }\n}",
  "abstract_func_before": "void MAPIPrint(MAPIProps *VAR_0) {\n  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;\n  DDWORD *VAR_6;\n  DDWORD VAR_7;\n  dtr VAR_8;\n  MAPIProperty *VAR_9;\n  variableLength *VAR_10;\n  variableLength VAR_11;\n  int VAR_12;\n\n  for (VAR_1 = 0; VAR_1 < VAR_0->count; VAR_1++) {\n    VAR_9 = &(VAR_0->properties[VAR_1]);\n    printf(\"   #%i: Type: [\", VAR_1);\n    switch (PROP_TYPE(VAR_9->id)) {\n      case VAR_13:\n        printf(\"  NONE   \"); break;\n      case VAR_14:\n        printf(\"  NULL   \"); break;\n      case VAR_15:\n        printf(\"   I2    \"); break;\n      case VAR_16:\n        printf(\"  LONG   \"); break;\n      case VAR_17:\n        printf(\"   R4    \"); break;\n      case VAR_18:\n        printf(\" DOUBLE  \"); break;\n      case VAR_19:\n        printf(\"CURRENCY \"); break;\n      case VAR_20:\n        printf(\"APP TIME \"); break;\n      case VAR_21:\n        printf(\"  ERROR  \"); break;\n      case VAR_22:\n        printf(\" BOOLEAN \"); break;\n      case VAR_23:\n        printf(\" OBJECT  \"); break;\n      case VAR_24:\n        printf(\"   I8    \"); break;\n      case VAR_25:\n        printf(\" STRING8 \"); break;\n      case VAR_26:\n        printf(\" UNICODE \"); break;\n      case VAR_27:\n        printf(\"SYS TIME \"); break;\n      case VAR_28:\n        printf(\"OLE GUID \"); break;\n      case VAR_29:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(VAR_9->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (VAR_9->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(VAR_9->id));\n    } else {\n      VAR_12 = 0;\n      for (VAR_3 = 0; VAR_3 < sizeof(MPList) / sizeof(VAR_30); VAR_3++) {\n        if ((MPList[VAR_3].id == PROP_ID(VAR_9->id)) && (VAR_12 == 0)) {\n          printf(\"%s\", MPList[VAR_3].name);\n          VAR_12 = 1;\n        }\n      }\n      if (VAR_12 == 0) {\n        printf(\"0x%04x\", PROP_ID(VAR_9->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (VAR_9->namedproperty > 0) {\n      for (VAR_2 = 0; VAR_2 < VAR_9->namedproperty; VAR_2++) {\n        printf(\"    Name: %s\\n\", VAR_9->propnames[VAR_2].data);\n      }\n    }\n    for (VAR_2 = 0; VAR_2 < VAR_9->count; VAR_2++) {\n      VAR_10 = &(VAR_9->data[VAR_2]);\n      if (VAR_9->count > 1) {\n        printf(\"    [%i/%u] \", VAR_2, VAR_9->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", VAR_10->size);\n      switch (PROP_TYPE(VAR_9->id)) {\n        case VAR_27:\n          MAPISysTimetoDTR(VAR_10->data, &VAR_8);\n          printf(\"    Value: \");\n          VAR_7 = *((DDWORD *)VAR_10->data);\n          TNEFPrintDate(VAR_8);\n          printf(\" [HEX: \");\n          for (VAR_5 = 0; VAR_5 < sizeof(VAR_7); VAR_5++) {\n            printf(\" %02x\", (BYTE)VAR_10->data[VAR_5]);\n          }\n          printf(\"] (%llu)\\n\", VAR_7);\n          break;\n        case VAR_16:\n          printf(\"    Value: %li\\n\", *((long*)VAR_10->data));\n          break;\n        case VAR_15:\n          printf(\"    Value: %hi\\n\", *((short int*)VAR_10->data));\n          break;\n        case VAR_22:\n          if (VAR_9->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case VAR_23:\n          printf(\"\\n\");\n          break;\n        case VAR_29:\n          if (IsCompressedRTF(VAR_10) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((VAR_11.data = (BYTE*)DecompressRTF(VAR_10, &(VAR_11.size))) != NULL) {\n              printf(\"%s\\n\", VAR_11.data);\n              free(VAR_11.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (VAR_4 = 0; VAR_4 < VAR_10->size; VAR_4++) {\n              if (isprint(VAR_10->data[VAR_4])) {\n                printf(\"%c\", VAR_10->data[VAR_4]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case VAR_25:\n          printf(\"    Value: [%s]\\n\", VAR_10->data);\n          if (strlen((char*)VAR_10->data) != VAR_10->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (VAR_4 = 0; VAR_4 < VAR_10->size; VAR_4++) {\n              if (isprint(VAR_10->data[VAR_4])) {\n                printf(\"%c\", VAR_10->data[VAR_4]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case VAR_28:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(VAR_5=0; VAR_5< 16; VAR_5++) {\n            printf(\" %02x\", (BYTE)VAR_10->data[VAR_5]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", VAR_10->data);\n      }\n    }\n  }\n}",
  "func_graph_path_before": "Yeraze/ytnef/f98f5d4adc1c4bd4033638f6167c1bb95d642f89/ytnef.c/vul/before/0.json",
  "func": "void MAPIPrint(MAPIProps *p) {\n  int j, i, index, h, x;\n  DDWORD *ddword_ptr;\n  DDWORD ddword_tmp;\n  dtr thedate;\n  MAPIProperty *mapi;\n  variableLength *mapidata;\n  variableLength vlTemp;\n  int found;\n\n  for (j = 0; j < p->count; j++) {\n    mapi = &(p->properties[j]);\n    printf(\"   #%i: Type: [\", j);\n    switch (PROP_TYPE(mapi->id)) {\n      case PT_UNSPECIFIED:\n        printf(\"  NONE   \"); break;\n      case PT_NULL:\n        printf(\"  NULL   \"); break;\n      case PT_I2:\n        printf(\"   I2    \"); break;\n      case PT_LONG:\n        printf(\"  LONG   \"); break;\n      case PT_R4:\n        printf(\"   R4    \"); break;\n      case PT_DOUBLE:\n        printf(\" DOUBLE  \"); break;\n      case PT_CURRENCY:\n        printf(\"CURRENCY \"); break;\n      case PT_APPTIME:\n        printf(\"APP TIME \"); break;\n      case PT_ERROR:\n        printf(\"  ERROR  \"); break;\n      case PT_BOOLEAN:\n        printf(\" BOOLEAN \"); break;\n      case PT_OBJECT:\n        printf(\" OBJECT  \"); break;\n      case PT_I8:\n        printf(\"   I8    \"); break;\n      case PT_STRING8:\n        printf(\" STRING8 \"); break;\n      case PT_UNICODE:\n        printf(\" UNICODE \"); break;\n      case PT_SYSTIME:\n        printf(\"SYS TIME \"); break;\n      case PT_CLSID:\n        printf(\"OLE GUID \"); break;\n      case PT_BINARY:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(mapi->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (mapi->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(mapi->id));\n    } else {\n      found = 0;\n      for (index = 0; index < sizeof(MPList) / sizeof(MAPIPropertyTagList); index++) {\n        if ((MPList[index].id == PROP_ID(mapi->id)) && (found == 0)) {\n          printf(\"%s\", MPList[index].name);\n          found = 1;\n        }\n      }\n      if (found == 0) {\n        printf(\"0x%04x\", PROP_ID(mapi->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (mapi->namedproperty > 0) {\n      for (i = 0; i < mapi->namedproperty; i++) {\n        printf(\"    Name: %s\\n\", mapi->propnames[i].data);\n      }\n    }\n    for (i = 0; i < mapi->count; i++) {\n      mapidata = &(mapi->data[i]);\n      if (mapi->count > 1) {\n        printf(\"    [%i/%u] \", i, mapi->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", mapidata->size);\n      switch (PROP_TYPE(mapi->id)) {\n        case PT_SYSTIME:\n          MAPISysTimetoDTR(mapidata->data, &thedate);\n          printf(\"    Value: \");\n          ddword_tmp = *((DDWORD *)mapidata->data);\n          TNEFPrintDate(thedate);\n          printf(\" [HEX: \");\n          for (x = 0; x < sizeof(ddword_tmp); x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"] (%llu)\\n\", ddword_tmp);\n          break;\n        case PT_LONG:\n          printf(\"    Value: %i\\n\", *((int*)mapidata->data));\n          break;\n        case PT_I2:\n          printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));\n          break;\n        case PT_BOOLEAN:\n          if (mapi->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case PT_OBJECT:\n          printf(\"\\n\");\n          break;\n        case PT_BINARY:\n          if (IsCompressedRTF(mapidata) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((vlTemp.data = (BYTE*)DecompressRTF(mapidata, &(vlTemp.size))) != NULL) {\n              printf(\"%s\\n\", vlTemp.data);\n              free(vlTemp.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_STRING8:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n          if (strlen((char*)mapidata->data) != mapidata->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (h = 0; h < mapidata->size; h++) {\n              if (isprint(mapidata->data[h])) {\n                printf(\"%c\", mapidata->data[h]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case PT_CLSID:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(x=0; x< 16; x++) {\n            printf(\" %02x\", (BYTE)mapidata->data[x]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", mapidata->data);\n      }\n    }\n  }\n}",
  "abstract_func": "void MAPIPrint(MAPIProps *VAR_0) {\n  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;\n  DDWORD *VAR_6;\n  DDWORD VAR_7;\n  dtr VAR_8;\n  MAPIProperty *VAR_9;\n  variableLength *VAR_10;\n  variableLength VAR_11;\n  int VAR_12;\n\n  for (VAR_1 = 0; VAR_1 < VAR_0->count; VAR_1++) {\n    VAR_9 = &(VAR_0->properties[VAR_1]);\n    printf(\"   #%i: Type: [\", VAR_1);\n    switch (PROP_TYPE(VAR_9->id)) {\n      case VAR_13:\n        printf(\"  NONE   \"); break;\n      case VAR_14:\n        printf(\"  NULL   \"); break;\n      case VAR_15:\n        printf(\"   I2    \"); break;\n      case VAR_16:\n        printf(\"  LONG   \"); break;\n      case VAR_17:\n        printf(\"   R4    \"); break;\n      case VAR_18:\n        printf(\" DOUBLE  \"); break;\n      case VAR_19:\n        printf(\"CURRENCY \"); break;\n      case VAR_20:\n        printf(\"APP TIME \"); break;\n      case VAR_21:\n        printf(\"  ERROR  \"); break;\n      case VAR_22:\n        printf(\" BOOLEAN \"); break;\n      case VAR_23:\n        printf(\" OBJECT  \"); break;\n      case VAR_24:\n        printf(\"   I8    \"); break;\n      case VAR_25:\n        printf(\" STRING8 \"); break;\n      case VAR_26:\n        printf(\" UNICODE \"); break;\n      case VAR_27:\n        printf(\"SYS TIME \"); break;\n      case VAR_28:\n        printf(\"OLE GUID \"); break;\n      case VAR_29:\n        printf(\" BINARY  \"); break;\n      default:\n        printf(\"<%x>\", PROP_TYPE(VAR_9->id)); break;\n    }\n\n    printf(\"]  Code: [\");\n    if (VAR_9->custom == 1) {\n      printf(\"UD:x%04x\", PROP_ID(VAR_9->id));\n    } else {\n      VAR_12 = 0;\n      for (VAR_3 = 0; VAR_3 < sizeof(MPList) / sizeof(VAR_30); VAR_3++) {\n        if ((MPList[VAR_3].id == PROP_ID(VAR_9->id)) && (VAR_12 == 0)) {\n          printf(\"%s\", MPList[VAR_3].name);\n          VAR_12 = 1;\n        }\n      }\n      if (VAR_12 == 0) {\n        printf(\"0x%04x\", PROP_ID(VAR_9->id));\n      }\n    }\n    printf(\"]\\n\");\n    if (VAR_9->namedproperty > 0) {\n      for (VAR_2 = 0; VAR_2 < VAR_9->namedproperty; VAR_2++) {\n        printf(\"    Name: %s\\n\", VAR_9->propnames[VAR_2].data);\n      }\n    }\n    for (VAR_2 = 0; VAR_2 < VAR_9->count; VAR_2++) {\n      VAR_10 = &(VAR_9->data[VAR_2]);\n      if (VAR_9->count > 1) {\n        printf(\"    [%i/%u] \", VAR_2, VAR_9->count);\n      } else {\n        printf(\"    \");\n      }\n      printf(\"Size: %i\", VAR_10->size);\n      switch (PROP_TYPE(VAR_9->id)) {\n        case VAR_27:\n          MAPISysTimetoDTR(VAR_10->data, &VAR_8);\n          printf(\"    Value: \");\n          VAR_7 = *((DDWORD *)VAR_10->data);\n          TNEFPrintDate(VAR_8);\n          printf(\" [HEX: \");\n          for (VAR_5 = 0; VAR_5 < sizeof(VAR_7); VAR_5++) {\n            printf(\" %02x\", (BYTE)VAR_10->data[VAR_5]);\n          }\n          printf(\"] (%llu)\\n\", VAR_7);\n          break;\n        case VAR_16:\n          printf(\"    Value: %i\\n\", *((int*)VAR_10->data));\n          break;\n        case VAR_15:\n          printf(\"    Value: %hi\\n\", *((short int*)VAR_10->data));\n          break;\n        case VAR_22:\n          if (VAR_9->data->data[0] != 0) {\n            printf(\"    Value: True\\n\");\n          } else {\n            printf(\"    Value: False\\n\");\n          }\n          break;\n        case VAR_23:\n          printf(\"\\n\");\n          break;\n        case VAR_29:\n          if (IsCompressedRTF(VAR_10) == 1) {\n            printf(\"    Detected Compressed RTF. \");\n            printf(\"Decompressed text follows\\n\");\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n            if ((VAR_11.data = (BYTE*)DecompressRTF(VAR_10, &(VAR_11.size))) != NULL) {\n              printf(\"%s\\n\", VAR_11.data);\n              free(VAR_11.data);\n            }\n            printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n          } else {\n            printf(\"    Value: [\");\n            for (VAR_4 = 0; VAR_4 < VAR_10->size; VAR_4++) {\n              if (isprint(VAR_10->data[VAR_4])) {\n                printf(\"%c\", VAR_10->data[VAR_4]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case VAR_25:\n          printf(\"    Value: [%s]\\n\", VAR_10->data);\n          if (strlen((char*)VAR_10->data) != VAR_10->size - 1) {\n            printf(\"Detected Hidden data: [\");\n            for (VAR_4 = 0; VAR_4 < VAR_10->size; VAR_4++) {\n              if (isprint(VAR_10->data[VAR_4])) {\n                printf(\"%c\", VAR_10->data[VAR_4]);\n              } else {\n                printf(\".\");\n              }\n\n            }\n            printf(\"]\\n\");\n          }\n          break;\n        case VAR_28:\n          printf(\"    Value: \");\n          printf(\"[HEX: \");\n          for(VAR_5=0; VAR_5< 16; VAR_5++) {\n            printf(\" %02x\", (BYTE)VAR_10->data[VAR_5]);\n          }\n          printf(\"]\\n\");\n          break;\n        default:\n          printf(\"    Value: [%s]\\n\", VAR_10->data);\n      }\n    }\n  }\n}",
  "func_graph_path": "Yeraze/ytnef/f98f5d4adc1c4bd4033638f6167c1bb95d642f89/ytnef.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -92,7 +92,7 @@\n           printf(\"] (%llu)\\n\", ddword_tmp);\n           break;\n         case PT_LONG:\n-          printf(\"    Value: %li\\n\", *((long*)mapidata->data));\n+          printf(\"    Value: %i\\n\", *((int*)mapidata->data));\n           break;\n         case PT_I2:\n           printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));",
  "diff_line_info": {
    "deleted_lines": [
      "          printf(\"    Value: %li\\n\", *((long*)mapidata->data));"
    ],
    "added_lines": [
      "          printf(\"    Value: %i\\n\", *((int*)mapidata->data));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Yeraze/ytnef/pull/32",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Yeraze/ytnef/pull/32: 403 Client Error: Forbidden for url: https://api.github.com/repos/Yeraze/ytnef/pulls/32",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}