{
  "cve_id": "CVE-2021-34071",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "justdan96/tsMuxer",
  "commit_msg": "[bug] heap buffer overflow when last byte of SEI = 0xFF (#425)\n\nFixes #423\r\nFixes #427\r\nFixes #430\r\nFixes #433",
  "commit_hash": "ea879f3b915baa4f9d145ce44229f7b3b1952c30",
  "git_url": "https://github.com/justdan96/tsMuxer/commit/ea879f3b915baa4f9d145ce44229f7b3b1952c30",
  "file_path": "tsMuxer/nalUnits.cpp",
  "func_name": "SEIUnit::deserialize",
  "func_before": "void SEIUnit::deserialize(SPSUnit& sps, int orig_hrd_parameters_present_flag)\n{\n    pic_struct = -1;\n\n    uint8_t* nalEnd = m_nalBuffer + m_nalBufferLen;\n    try\n    {\n        int rez = NALUnit::deserialize(m_nalBuffer, nalEnd);\n        if (rez != 0)\n            return;\n        uint8_t* curBuff = m_nalBuffer + 1;\n        while (curBuff < nalEnd - 1)\n        {\n            int payloadType = 0;\n            for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadType += 0xFF;\n            if (curBuff >= nalEnd)\n                return;\n            payloadType += *curBuff++;\n            if (curBuff >= nalEnd)\n                return;\n\n            int payloadSize = 0;\n            for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadSize += 0xFF;\n            if (curBuff >= nalEnd)\n                return;\n            payloadSize += *curBuff++;\n            if (curBuff >= nalEnd)\n                return;\n            sei_payload(sps, payloadType, curBuff, payloadSize, orig_hrd_parameters_present_flag);\n            m_processedMessages.insert(payloadType);\n            curBuff += payloadSize;\n        }\n    }\n    catch (BitStreamException)\n    {\n        LTRACE(LT_WARN, 2, \"Bad SEI detected. SEI too short\");\n    }\n    return;\n}",
  "abstract_func_before": "void SEIUnit::deserialize(SPSUnit& VAR_0, int VAR_1)\n{\n    VAR_2 = -1;\n\n    uint8_t* VAR_3 = VAR_4 + VAR_5;\n    try\n    {\n        int VAR_6 = NALUnit::deserialize(VAR_4, VAR_3);\n        if (VAR_6 != 0)\n            return;\n        uint8_t* VAR_7 = VAR_4 + 1;\n        while (VAR_7 < VAR_3 - 1)\n        {\n            int VAR_8 = 0;\n            for (; *VAR_7 == 0xFF && VAR_7 < VAR_3; VAR_7++) VAR_8 += 0xFF;\n            if (VAR_7 >= VAR_3)\n                return;\n            VAR_8 += *VAR_7++;\n            if (VAR_7 >= VAR_3)\n                return;\n\n            int VAR_9 = 0;\n            for (; *VAR_7 == 0xFF && VAR_7 < VAR_3; VAR_7++) VAR_9 += 0xFF;\n            if (VAR_7 >= VAR_3)\n                return;\n            VAR_9 += *VAR_7++;\n            if (VAR_7 >= VAR_3)\n                return;\n            sei_payload(VAR_0, VAR_8, VAR_7, VAR_9, VAR_1);\n            VAR_10.insert(VAR_8);\n            VAR_7 += VAR_9;\n        }\n    }\n    catch (BitStreamException)\n    {\n        LTRACE(VAR_11, 2, \"Bad SEI detected. SEI too short\");\n    }\n    return;\n}",
  "func_graph_path_before": "justdan96/tsMuxer/ea879f3b915baa4f9d145ce44229f7b3b1952c30/nalUnits.cpp/vul/before/2.json",
  "func": "void SEIUnit::deserialize(SPSUnit& sps, int orig_hrd_parameters_present_flag)\n{\n    pic_struct = -1;\n\n    uint8_t* nalEnd = m_nalBuffer + m_nalBufferLen;\n    try\n    {\n        int rez = NALUnit::deserialize(m_nalBuffer, nalEnd);\n        if (rez != 0)\n            return;\n        uint8_t* curBuff = m_nalBuffer + 1;\n        while (curBuff < nalEnd - 1)\n        {\n            int payloadType = 0;\n            for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++) payloadType += 0xFF;\n            if (curBuff >= nalEnd)\n                return;\n            payloadType += *curBuff++;\n            if (curBuff >= nalEnd)\n                return;\n\n            int payloadSize = 0;\n            for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++) payloadSize += 0xFF;\n            if (curBuff >= nalEnd)\n                return;\n            payloadSize += *curBuff++;\n            if (nalEnd - curBuff < payloadSize - 1)\n            {\n                LTRACE(LT_WARN, 2, \"Bad SEI detected. SEI too short\");\n                return;\n            }\n            sei_payload(sps, payloadType, curBuff, payloadSize, orig_hrd_parameters_present_flag);\n            m_processedMessages.insert(payloadType);\n            curBuff += payloadSize;\n        }\n    }\n    catch (BitStreamException)\n    {\n        LTRACE(LT_WARN, 2, \"Bad SEI detected. SEI too short\");\n    }\n    return;\n}",
  "abstract_func": "void SEIUnit::deserialize(SPSUnit& VAR_0, int VAR_1)\n{\n    VAR_2 = -1;\n\n    uint8_t* VAR_3 = VAR_4 + VAR_5;\n    try\n    {\n        int VAR_6 = NALUnit::deserialize(VAR_4, VAR_3);\n        if (VAR_6 != 0)\n            return;\n        uint8_t* VAR_7 = VAR_4 + 1;\n        while (VAR_7 < VAR_3 - 1)\n        {\n            int VAR_8 = 0;\n            for (; VAR_7 < VAR_3 && *VAR_7 == 0xFF; VAR_7++) VAR_8 += 0xFF;\n            if (VAR_7 >= VAR_3)\n                return;\n            VAR_8 += *VAR_7++;\n            if (VAR_7 >= VAR_3)\n                return;\n\n            int VAR_9 = 0;\n            for (; VAR_7 < VAR_3 && *VAR_7 == 0xFF; VAR_7++) VAR_9 += 0xFF;\n            if (VAR_7 >= VAR_3)\n                return;\n            VAR_9 += *VAR_7++;\n            if (VAR_3 - VAR_7 < VAR_9 - 1)\n            {\n                LTRACE(VAR_10, 2, \"Bad SEI detected. SEI too short\");\n                return;\n            }\n            sei_payload(VAR_0, VAR_8, VAR_7, VAR_9, VAR_1);\n            VAR_11.insert(VAR_8);\n            VAR_7 += VAR_9;\n        }\n    }\n    catch (BitStreamException)\n    {\n        LTRACE(VAR_10, 2, \"Bad SEI detected. SEI too short\");\n    }\n    return;\n}",
  "func_graph_path": "justdan96/tsMuxer/ea879f3b915baa4f9d145ce44229f7b3b1952c30/nalUnits.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n         while (curBuff < nalEnd - 1)\n         {\n             int payloadType = 0;\n-            for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadType += 0xFF;\n+            for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++) payloadType += 0xFF;\n             if (curBuff >= nalEnd)\n                 return;\n             payloadType += *curBuff++;\n@@ -20,12 +20,15 @@\n                 return;\n \n             int payloadSize = 0;\n-            for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadSize += 0xFF;\n+            for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++) payloadSize += 0xFF;\n             if (curBuff >= nalEnd)\n                 return;\n             payloadSize += *curBuff++;\n-            if (curBuff >= nalEnd)\n+            if (nalEnd - curBuff < payloadSize - 1)\n+            {\n+                LTRACE(LT_WARN, 2, \"Bad SEI detected. SEI too short\");\n                 return;\n+            }\n             sei_payload(sps, payloadType, curBuff, payloadSize, orig_hrd_parameters_present_flag);\n             m_processedMessages.insert(payloadType);\n             curBuff += payloadSize;",
  "diff_line_info": {
    "deleted_lines": [
      "            for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadType += 0xFF;",
      "            for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadSize += 0xFF;",
      "            if (curBuff >= nalEnd)"
    ],
    "added_lines": [
      "            for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++) payloadType += 0xFF;",
      "            for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++) payloadSize += 0xFF;",
      "            if (nalEnd - curBuff < payloadSize - 1)",
      "            {",
      "                LTRACE(LT_WARN, 2, \"Bad SEI detected. SEI too short\");",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/justdan96/tsMuxer/pull/425",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/justdan96/tsMuxer/pull/425: 403 Client Error: Forbidden for url: https://api.github.com/repos/justdan96/tsMuxer/pulls/425",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}