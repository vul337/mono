{
  "cve_id": "CVE-2020-16124",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ros/ros_comm",
  "commit_msg": "Trap for overly large input to XmlRPCPP which could cause problems with int <-> size_t conversions.\n\n - In XmlRpcClient, XmlRpcServerConnection and XmlRpcSocket, recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header, and generate an error if the length is invalid or too large.\n - In XmlRpcUtil, prevent attempts to parse overly large XML input.\n - Add tests where they can reasonably be inserted into existing test routines.\n\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\n\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\n\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
  "commit_hash": "3dd308911d7294bc6cff12f626b8467fe1555423",
  "git_url": "https://github.com/ros/ros_comm/commit/3dd308911d7294bc6cff12f626b8467fe1555423",
  "file_path": "utilities/xmlrpcpp/src/XmlRpcSocket.cpp",
  "func_name": "XmlRpcSocket::nbRead",
  "func_before": "bool\nXmlRpcSocket::nbRead(int fd, std::string& s, bool *eof)\n{\n  const int READ_SIZE = 4096;   // Number of bytes to attempt to read at a time\n  char readBuf[READ_SIZE];\n\n  bool wouldBlock = false;\n  *eof = false;\n\n  while ( ! wouldBlock && ! *eof) {\n#if defined(_WINDOWS)\n    int n = recv(fd, readBuf, READ_SIZE-1, 0);\n#else\n    int n = read(fd, readBuf, READ_SIZE-1);\n#endif\n    XmlRpcUtil::log(5, \"XmlRpcSocket::nbRead: read/recv returned %d.\", n);\n\n    if (n > 0) {\n      readBuf[n] = 0;\n      s.append(readBuf, n);\n    } else if (n == 0) {\n      *eof = true;\n    } else if (nonFatalError()) {\n      wouldBlock = true;\n    } else {\n      return false;   // Error\n    }\n  }\n  return true;\n}",
  "abstract_func_before": "bool\nXmlRpcSocket::nbRead(int VAR_0, std::string& VAR_1, bool *VAR_2)\n{\n  const int VAR_3 = 4096;   /* COMMENT_0 */\n  char VAR_4[VAR_3];\n\n  bool VAR_5 = false;\n  *VAR_2 = false;\n\n  while ( ! VAR_5 && ! *VAR_2) {\n#if defined(VAR_6)\n    int VAR_7 = recv(VAR_0, VAR_4, VAR_3-1, 0);\n#else\n    int VAR_7 = read(VAR_0, VAR_4, VAR_3-1);\n#endif\n    XmlRpcUtil::log(5, \"XmlRpcSocket::nbRead: read/recv returned %d.\", VAR_7);\n\n    if (VAR_7 > 0) {\n      VAR_4[VAR_7] = 0;\n      VAR_1.append(VAR_4, VAR_7);\n    } else if (VAR_7 == 0) {\n      *VAR_2 = true;\n    } else if (nonFatalError()) {\n      VAR_5 = true;\n    } else {\n      return false;   /* COMMENT_1 */\n    }\n  }\n  return true;\n}",
  "func_graph_path_before": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcSocket.cpp/vul/before/0.json",
  "func": "bool\nXmlRpcSocket::nbRead(int fd, std::string& s, bool *eof)\n{\n  const int READ_SIZE = 4096;   // Number of bytes to attempt to read at a time\n  char readBuf[READ_SIZE];\n\n  bool wouldBlock = false;\n  *eof = false;\n\n  while ( ! wouldBlock && ! *eof) {\n#if defined(_WINDOWS)\n    int n = recv(fd, readBuf, READ_SIZE-1, 0);\n#else\n    int n = read(fd, readBuf, READ_SIZE-1);\n#endif\n    XmlRpcUtil::log(5, \"XmlRpcSocket::nbRead: read/recv returned %d.\", n);\n\n    if (n > 0) {\n      readBuf[n] = 0;\n      s.append(readBuf, n);\n    } else if (n == 0) {\n      *eof = true;\n    } else if (nonFatalError()) {\n      wouldBlock = true;\n    } else {\n      return false;   // Error\n    }\n  }\n  // Watch for integer overrun\n  if (s.length() > size_t(__INT_MAX__)) {\n    XmlRpcUtil::error(\"XmlRpcSocket::nbRead: text size (%u) exceeds the maximum allowed size (%s).\",\n                      s.length(), __INT_MAX__);\n    s.clear();\n    return false;\n  }\n  return true;\n}",
  "abstract_func": "bool\nXmlRpcSocket::nbRead(int VAR_0, std::string& VAR_1, bool *VAR_2)\n{\n  const int VAR_3 = 4096;   /* COMMENT_0 */\n  char VAR_4[VAR_3];\n\n  bool VAR_5 = false;\n  *VAR_2 = false;\n\n  while ( ! VAR_5 && ! *VAR_2) {\n#if defined(VAR_6)\n    int VAR_7 = recv(VAR_0, VAR_4, VAR_3-1, 0);\n#else\n    int VAR_7 = read(VAR_0, VAR_4, VAR_3-1);\n#endif\n    XmlRpcUtil::log(5, \"XmlRpcSocket::nbRead: read/recv returned %d.\", VAR_7);\n\n    if (VAR_7 > 0) {\n      VAR_4[VAR_7] = 0;\n      VAR_1.append(VAR_4, VAR_7);\n    } else if (VAR_7 == 0) {\n      *VAR_2 = true;\n    } else if (nonFatalError()) {\n      VAR_5 = true;\n    } else {\n      return false;   /* COMMENT_1 */\n    }\n  }\n  /* COMMENT_2 */\n  if (VAR_1.length() > size_t(VAR_8)) {\n    XmlRpcUtil::error(\"XmlRpcSocket::nbRead: text size (%u) exceeds the maximum allowed size (%s).\",\n                      VAR_1.length(), VAR_8);\n    VAR_1.clear();\n    return false;\n  }\n  return true;\n}",
  "func_graph_path": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcSocket.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,5 +26,12 @@\n       return false;   // Error\n     }\n   }\n+  // Watch for integer overrun\n+  if (s.length() > size_t(__INT_MAX__)) {\n+    XmlRpcUtil::error(\"XmlRpcSocket::nbRead: text size (%u) exceeds the maximum allowed size (%s).\",\n+                      s.length(), __INT_MAX__);\n+    s.clear();\n+    return false;\n+  }\n   return true;\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  // Watch for integer overrun",
      "  if (s.length() > size_t(__INT_MAX__)) {",
      "    XmlRpcUtil::error(\"XmlRpcSocket::nbRead: text size (%u) exceeds the maximum allowed size (%s).\",",
      "                      s.length(), __INT_MAX__);",
      "    s.clear();",
      "    return false;",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ros/ros_comm/pull/2065",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/ros/ros_comm/pull/2065: 403 Client Error: Forbidden for url: https://api.github.com/repos/ros/ros_comm/pulls/2065",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:**  \n   - The commit message mentions \"Trap for overly large input,\" \"CVE-2020-16124,\" and refers to security-related fixes.\n   - The code diff shows modifications to handle integer overflows in XmlRpcSocket, checking for overly large inputs and using safer functions.\n\n2. **Consistency Check:**  \n   - The commit message aligns perfectly with the code changes, indicating a focused security fix.\n\n3. **Purpose Evaluation:**  \n   - The changes directly address integer overflow issues, which are critical security flaws.\n\n4. **Security Vulnerability Assessment:**  \n   - The patch explicitly references a known CVE and implements fixes to prevent integer overflow attacks, a clear security risk.\n\n5. **Confidence Scoring:**  \n   - All elements confirm the patch is a security fix with no ambiguities.\n\n**Conclusion:**  \nThe patch is a clear security fix addressing a known vulnerability (CVE-2020-16124) with high confidence."
}