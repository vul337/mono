{
  "cve_id": "CVE-2023-26253",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "gluster/glusterfs",
  "commit_msg": "fuse: Resolve asan bug in during receive event notification\n\nThe fuse xlator notify function tries to assign data object\nto graph object without checking an event. In case of upcall\nevent data object represents upcall object so during access\nof graph object the process is crashed for asan build.\n\nSolution: Access the graph->id only while event is associated\n          specific to fuse xlator\n\nFixes: #3954\nChange-Id: I6b2869256b26d22163879737dcf163510d1cd8bf\nSigned-off-by: Mohit Agrawal <moagrawa@redhat.com>",
  "commit_hash": "9c7718a316427923ef00e02c886e48683f34a726",
  "git_url": "https://github.com/gluster/glusterfs/commit/9c7718a316427923ef00e02c886e48683f34a726",
  "file_path": "xlators/mount/fuse/src/fuse-bridge.c",
  "func_name": "notify",
  "func_before": "int\nnotify(xlator_t *this, int32_t event, void *data, ...)\n{\n    int i = 0;\n    int32_t ret = 0;\n    fuse_private_t *private = NULL;\n    gf_boolean_t start_thread = _gf_false;\n    glusterfs_graph_t *graph = NULL;\n    struct pollfd pfd = {0};\n\n    private = this->private;\n\n    graph = data;\n\n    gf_log(\"fuse\", GF_LOG_DEBUG, \"got event %d on graph %d\", event,\n           ((graph) ? graph->id : 0));\n\n    switch (event) {\n        case GF_EVENT_GRAPH_NEW:\n            break;\n\n        case GF_EVENT_CHILD_UP:\n        case GF_EVENT_CHILD_DOWN:\n        case GF_EVENT_CHILD_CONNECTING: {\n            if (graph) {\n                ret = fuse_graph_setup(this, graph);\n                if (ret)\n                    gf_log(this->name, GF_LOG_WARNING,\n                           \"failed to setup the graph\");\n            }\n\n            if ((event == GF_EVENT_CHILD_UP) ||\n                (event == GF_EVENT_CHILD_DOWN)) {\n                pthread_mutex_lock(&private->sync_mutex);\n                {\n                    private->event_recvd = 1;\n                    pthread_cond_broadcast(&private->sync_cond);\n                }\n                pthread_mutex_unlock(&private->sync_mutex);\n            }\n\n            pthread_mutex_lock(&private->sync_mutex);\n            {\n                if (!private->fuse_thread_started) {\n                    private->fuse_thread_started = 1;\n                    start_thread = _gf_true;\n                }\n            }\n            pthread_mutex_unlock(&private->sync_mutex);\n\n            if (start_thread) {\n                private->fuse_thread = GF_CALLOC(private->reader_thread_count,\n                                                 sizeof(pthread_t),\n                                                 gf_fuse_mt_pthread_t);\n                for (i = 0; i < private->reader_thread_count; i++) {\n                    ret = gf_thread_create(&private->fuse_thread[i], NULL,\n                                           fuse_thread_proc, this, \"fuseproc\");\n                    if (ret != 0) {\n                        gf_log(this->name, GF_LOG_DEBUG,\n                               \"pthread_create() failed (%s)\", strerror(errno));\n                        break;\n                    }\n                }\n            }\n\n            break;\n        }\n\n        case GF_EVENT_AUTH_FAILED: {\n            /* Authentication failure is an error and glusterfs should stop */\n            gf_log(this->name, GF_LOG_ERROR,\n                   \"Server authentication failed. Shutting down.\");\n            pthread_mutex_lock(&private->sync_mutex);\n            {\n                /*Wait for mount to finish*/\n                if (!private->mount_finished) {\n                    pfd.fd = private->status_pipe[0];\n                    pfd.events = POLLIN | POLLHUP | POLLERR;\n                    if (poll(&pfd, 1, -1) < 0) {\n                        gf_log(this->name, GF_LOG_ERROR, \"poll error %s\",\n                               strerror(errno));\n                        goto auth_fail_unlock;\n                    }\n                    if (pfd.revents & POLLIN) {\n                        if (fuse_get_mount_status(this) != 0) {\n                            goto auth_fail_unlock;\n                        }\n                        private->mount_finished = _gf_true;\n                    } else if (pfd.revents) {\n                        gf_log(this->name, GF_LOG_ERROR,\n                               \"mount pipe closed without status\");\n                        goto auth_fail_unlock;\n                    }\n                }\n            }\n        auth_fail_unlock:\n            pthread_mutex_unlock(&private->sync_mutex);\n            fini(this);\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    return ret;\n}",
  "abstract_func_before": "int\nnotify(xlator_t *VAR_0, int32_t VAR_1, void *VAR_2, ...)\n{\n    int VAR_3 = 0;\n    int32_t VAR_4 = 0;\n    fuse_private_t *VAR_5 = NULL;\n    gf_boolean_t VAR_6 = VAR_7;\n    glusterfs_graph_t *VAR_8 = NULL;\n    struct pollfd VAR_9 = {0};\n\n    VAR_5 = VAR_0->private;\n\n    VAR_8 = VAR_2;\n\n    gf_log(\"fuse\", VAR_10, \"got event %d on graph %d\", VAR_1,\n           ((VAR_8) ? VAR_8->id : 0));\n\n    switch (VAR_1) {\n        case VAR_11:\n            break;\n\n        case VAR_12:\n        case VAR_13:\n        case VAR_14: {\n            if (VAR_8) {\n                VAR_4 = fuse_graph_setup(VAR_0, VAR_8);\n                if (VAR_4)\n                    gf_log(VAR_0->name, VAR_15,\n                           \"failed to setup the graph\");\n            }\n\n            if ((VAR_1 == VAR_12) ||\n                (VAR_1 == VAR_13)) {\n                pthread_mutex_lock(&VAR_5->sync_mutex);\n                {\n                    VAR_5->event_recvd = 1;\n                    pthread_cond_broadcast(&VAR_5->sync_cond);\n                }\n                pthread_mutex_unlock(&VAR_5->sync_mutex);\n            }\n\n            pthread_mutex_lock(&VAR_5->sync_mutex);\n            {\n                if (!VAR_5->fuse_thread_started) {\n                    VAR_5->fuse_thread_started = 1;\n                    VAR_6 = VAR_16;\n                }\n            }\n            pthread_mutex_unlock(&VAR_5->sync_mutex);\n\n            if (VAR_6) {\n                VAR_5->fuse_thread = GF_CALLOC(VAR_5->reader_thread_count,\n                                                 sizeof(VAR_17),\n                                                 VAR_18);\n                for (VAR_3 = 0; VAR_3 < VAR_5->reader_thread_count; VAR_3++) {\n                    VAR_4 = gf_thread_create(&VAR_5->fuse_thread[VAR_3], NULL,\n                                           VAR_19, VAR_0, \"fuseproc\");\n                    if (VAR_4 != 0) {\n                        gf_log(VAR_0->name, VAR_10,\n                               \"pthread_create() failed (%s)\", strerror(VAR_20));\n                        break;\n                    }\n                }\n            }\n\n            break;\n        }\n\n        case VAR_21: {\n            /* COMMENT_0 */\n            gf_log(VAR_0->name, VAR_22,\n                   \"Server authentication failed. Shutting down.\");\n            pthread_mutex_lock(&VAR_5->sync_mutex);\n            {\n                /* COMMENT_1 */\n                if (!VAR_5->mount_finished) {\n                    VAR_9.fd = VAR_5->status_pipe[0];\n                    VAR_9.events = VAR_23 | VAR_24 | VAR_25;\n                    if (poll(&VAR_9, 1, -1) < 0) {\n                        gf_log(VAR_0->name, VAR_22, \"poll error %s\",\n                               strerror(VAR_20));\n                        goto auth_fail_unlock;\n                    }\n                    if (VAR_9.revents & VAR_23) {\n                        if (fuse_get_mount_status(VAR_0) != 0) {\n                            goto auth_fail_unlock;\n                        }\n                        VAR_5->mount_finished = VAR_16;\n                    } else if (VAR_9.revents) {\n                        gf_log(VAR_0->name, VAR_22,\n                               \"mount pipe closed without status\");\n                        goto auth_fail_unlock;\n                    }\n                }\n            }\n        auth_fail_unlock:\n            pthread_mutex_unlock(&VAR_5->sync_mutex);\n            fini(VAR_0);\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    return VAR_4;\n}",
  "func_graph_path_before": "gluster/glusterfs/9c7718a316427923ef00e02c886e48683f34a726/fuse-bridge.c/vul/before/0.json",
  "func": "int\nnotify(xlator_t *this, int32_t event, void *data, ...)\n{\n    int i = 0;\n    int32_t ret = 0;\n    fuse_private_t *private = NULL;\n    gf_boolean_t start_thread = _gf_false;\n    gf_boolean_t event_graph = _gf_true;\n    glusterfs_graph_t *graph = NULL;\n    struct pollfd pfd = {0};\n\n    private = this->private;\n\n    graph = data;\n\n    switch (event) {\n        case GF_EVENT_GRAPH_NEW:\n            break;\n\n        case GF_EVENT_CHILD_UP:\n        case GF_EVENT_CHILD_DOWN:\n        case GF_EVENT_CHILD_CONNECTING: {\n            if (graph) {\n                ret = fuse_graph_setup(this, graph);\n                if (ret)\n                    gf_log(this->name, GF_LOG_WARNING,\n                           \"failed to setup the graph\");\n            }\n\n            if ((event == GF_EVENT_CHILD_UP) ||\n                (event == GF_EVENT_CHILD_DOWN)) {\n                pthread_mutex_lock(&private->sync_mutex);\n                {\n                    private->event_recvd = 1;\n                    pthread_cond_broadcast(&private->sync_cond);\n                }\n                pthread_mutex_unlock(&private->sync_mutex);\n            }\n\n            pthread_mutex_lock(&private->sync_mutex);\n            {\n                if (!private->fuse_thread_started) {\n                    private->fuse_thread_started = 1;\n                    start_thread = _gf_true;\n                }\n            }\n            pthread_mutex_unlock(&private->sync_mutex);\n\n            if (start_thread) {\n                private->fuse_thread = GF_CALLOC(private->reader_thread_count,\n                                                 sizeof(pthread_t),\n                                                 gf_fuse_mt_pthread_t);\n                for (i = 0; i < private->reader_thread_count; i++) {\n                    ret = gf_thread_create(&private->fuse_thread[i], NULL,\n                                           fuse_thread_proc, this, \"fuseproc\");\n                    if (ret != 0) {\n                        gf_log(this->name, GF_LOG_DEBUG,\n                               \"pthread_create() failed (%s)\", strerror(errno));\n                        break;\n                    }\n                }\n            }\n\n            break;\n        }\n\n        case GF_EVENT_AUTH_FAILED: {\n            /* Authentication failure is an error and glusterfs should stop */\n            gf_log(this->name, GF_LOG_ERROR,\n                   \"Server authentication failed. Shutting down.\");\n            pthread_mutex_lock(&private->sync_mutex);\n            {\n                /*Wait for mount to finish*/\n                if (!private->mount_finished) {\n                    pfd.fd = private->status_pipe[0];\n                    pfd.events = POLLIN | POLLHUP | POLLERR;\n                    if (poll(&pfd, 1, -1) < 0) {\n                        gf_log(this->name, GF_LOG_ERROR, \"poll error %s\",\n                               strerror(errno));\n                        goto auth_fail_unlock;\n                    }\n                    if (pfd.revents & POLLIN) {\n                        if (fuse_get_mount_status(this) != 0) {\n                            goto auth_fail_unlock;\n                        }\n                        private->mount_finished = _gf_true;\n                    } else if (pfd.revents) {\n                        gf_log(this->name, GF_LOG_ERROR,\n                               \"mount pipe closed without status\");\n                        goto auth_fail_unlock;\n                    }\n                }\n            }\n        auth_fail_unlock:\n            pthread_mutex_unlock(&private->sync_mutex);\n            fini(this);\n            break;\n        }\n\n        default:\n            /* Set the event_graph to false so that event\n               debug msg would not try to access invalid graph->id\n               while data object is not matched to graph object\n               for ex in case of upcall event data object represents\n               gf_upcall object\n            */\n            event_graph = _gf_false;\n            break;\n    }\n\n    gf_log(\"fuse\", GF_LOG_DEBUG, \"got event %d on graph %d\", event,\n           ((graph && event_graph) ? graph->id : 0));\n    return ret;\n}",
  "abstract_func": "int\nnotify(xlator_t *VAR_0, int32_t VAR_1, void *VAR_2, ...)\n{\n    int VAR_3 = 0;\n    int32_t VAR_4 = 0;\n    fuse_private_t *VAR_5 = NULL;\n    gf_boolean_t VAR_6 = VAR_7;\n    gf_boolean_t VAR_8 = VAR_9;\n    glusterfs_graph_t *VAR_10 = NULL;\n    struct pollfd VAR_11 = {0};\n\n    VAR_5 = VAR_0->private;\n\n    VAR_10 = VAR_2;\n\n    switch (VAR_1) {\n        case VAR_12:\n            break;\n\n        case VAR_13:\n        case VAR_14:\n        case VAR_15: {\n            if (VAR_10) {\n                VAR_4 = fuse_graph_setup(VAR_0, VAR_10);\n                if (VAR_4)\n                    gf_log(VAR_0->name, VAR_16,\n                           \"failed to setup the graph\");\n            }\n\n            if ((VAR_1 == VAR_13) ||\n                (VAR_1 == VAR_14)) {\n                pthread_mutex_lock(&VAR_5->sync_mutex);\n                {\n                    VAR_5->event_recvd = 1;\n                    pthread_cond_broadcast(&VAR_5->sync_cond);\n                }\n                pthread_mutex_unlock(&VAR_5->sync_mutex);\n            }\n\n            pthread_mutex_lock(&VAR_5->sync_mutex);\n            {\n                if (!VAR_5->fuse_thread_started) {\n                    VAR_5->fuse_thread_started = 1;\n                    VAR_6 = VAR_9;\n                }\n            }\n            pthread_mutex_unlock(&VAR_5->sync_mutex);\n\n            if (VAR_6) {\n                VAR_5->fuse_thread = GF_CALLOC(VAR_5->reader_thread_count,\n                                                 sizeof(VAR_17),\n                                                 VAR_18);\n                for (VAR_3 = 0; VAR_3 < VAR_5->reader_thread_count; VAR_3++) {\n                    VAR_4 = gf_thread_create(&VAR_5->fuse_thread[VAR_3], NULL,\n                                           VAR_19, VAR_0, \"fuseproc\");\n                    if (VAR_4 != 0) {\n                        gf_log(VAR_0->name, VAR_20,\n                               \"pthread_create() failed (%s)\", strerror(VAR_21));\n                        break;\n                    }\n                }\n            }\n\n            break;\n        }\n\n        case VAR_22: {\n            /* COMMENT_0 */\n            gf_log(VAR_0->name, VAR_23,\n                   \"Server authentication failed. Shutting down.\");\n            pthread_mutex_lock(&VAR_5->sync_mutex);\n            {\n                /* COMMENT_1 */\n                if (!VAR_5->mount_finished) {\n                    VAR_11.fd = VAR_5->status_pipe[0];\n                    VAR_11.events = VAR_24 | VAR_25 | VAR_26;\n                    if (poll(&VAR_11, 1, -1) < 0) {\n                        gf_log(VAR_0->name, VAR_23, \"poll error %s\",\n                               strerror(VAR_21));\n                        goto auth_fail_unlock;\n                    }\n                    if (VAR_11.revents & VAR_24) {\n                        if (fuse_get_mount_status(VAR_0) != 0) {\n                            goto auth_fail_unlock;\n                        }\n                        VAR_5->mount_finished = VAR_9;\n                    } else if (VAR_11.revents) {\n                        gf_log(VAR_0->name, VAR_23,\n                               \"mount pipe closed without status\");\n                        goto auth_fail_unlock;\n                    }\n                }\n            }\n        auth_fail_unlock:\n            pthread_mutex_unlock(&VAR_5->sync_mutex);\n            fini(VAR_0);\n            break;\n        }\n\n        default:\n            /* COMMENT_2 */\n                                                                  \n                                                               \n                                                                    \n                               \n              \n            VAR_8 = VAR_7;\n            break;\n    }\n\n    gf_log(\"fuse\", VAR_20, \"got event %d on graph %d\", VAR_1,\n           ((VAR_10 && VAR_8) ? VAR_10->id : 0));\n    return VAR_4;\n}",
  "func_graph_path": "gluster/glusterfs/9c7718a316427923ef00e02c886e48683f34a726/fuse-bridge.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,15 +5,13 @@\n     int32_t ret = 0;\n     fuse_private_t *private = NULL;\n     gf_boolean_t start_thread = _gf_false;\n+    gf_boolean_t event_graph = _gf_true;\n     glusterfs_graph_t *graph = NULL;\n     struct pollfd pfd = {0};\n \n     private = this->private;\n \n     graph = data;\n-\n-    gf_log(\"fuse\", GF_LOG_DEBUG, \"got event %d on graph %d\", event,\n-           ((graph) ? graph->id : 0));\n \n     switch (event) {\n         case GF_EVENT_GRAPH_NEW:\n@@ -100,8 +98,17 @@\n         }\n \n         default:\n+            /* Set the event_graph to false so that event\n+               debug msg would not try to access invalid graph->id\n+               while data object is not matched to graph object\n+               for ex in case of upcall event data object represents\n+               gf_upcall object\n+            */\n+            event_graph = _gf_false;\n             break;\n     }\n \n+    gf_log(\"fuse\", GF_LOG_DEBUG, \"got event %d on graph %d\", event,\n+           ((graph && event_graph) ? graph->id : 0));\n     return ret;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "",
      "    gf_log(\"fuse\", GF_LOG_DEBUG, \"got event %d on graph %d\", event,",
      "           ((graph) ? graph->id : 0));"
    ],
    "added_lines": [
      "    gf_boolean_t event_graph = _gf_true;",
      "            /* Set the event_graph to false so that event",
      "               debug msg would not try to access invalid graph->id",
      "               while data object is not matched to graph object",
      "               for ex in case of upcall event data object represents",
      "               gf_upcall object",
      "            */",
      "            event_graph = _gf_false;",
      "    gf_log(\"fuse\", GF_LOG_DEBUG, \"got event %d on graph %d\", event,",
      "           ((graph && event_graph) ? graph->id : 0));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/gluster/glusterfs/pull/4019",
  "description": {
    "pr_info": {
      "title": "fuse: Resolve asan bug in during receive event notification",
      "number": 4019
    },
    "comment": [
      "The fuse xlator notify function tries to assign data object to graph object without checking an event. \r\nIn case of upcall event data object represents upcall object so during access of graph object the \r\nprocess crashed for asan build.\r\n\r\nSolution: Access the graph->id only while an event is associated specifically to fuse xlator\r\n\r\nFixes: #3954\r\nChange-Id: I6b2869256b26d22163879737dcf163510d1cd8bf\r\n\r\n",
      "/run regression",
      "CLANG-FORMAT FAILURE:\nBefore merging the patch, this diff needs to be considered for passing clang-format\n\n```diff --git a/xlators/mount/fuse/src/fuse-bridge.c b/xlators/mount/fuse/src/fuse-bridge.c\nindex a9ffbc06e..c88e0087e 100644\n--- a/xlators/mount/fuse/src/fuse-bridge.c\n+++ b/xlators/mount/fuse/src/fuse-bridge.c\n@@ -6352,7 +6352,8 @@ fuse_priv_dump(xlator_t *this)\n     if (!this)\n         return -1;\n \n-    private = this->private;\n+   private\n+    = this->private;\n \n     if (!private)\n         return -1;\n@@ -6506,7 +6507,8 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n     glusterfs_graph_t *graph = NULL;\n     struct pollfd pfd = {0};\n \n-    private = this->private;\n+   private\n+    = this->private;\n \n     graph = data;\n \n@@ -6528,7 +6530,8 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n                 (event == GF_EVENT_CHILD_DOWN)) {\n                 pthread_mutex_lock(&private->sync_mutex);\n                 {\n-                    private->event_recvd = 1;\n+                   private\n+                    ->event_recvd = 1;\n                     pthread_cond_broadcast(&private->sync_cond);\n                 }\n                 pthread_mutex_unlock(&private->sync_mutex);\n@@ -6537,16 +6540,18 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n             pthread_mutex_lock(&private->sync_mutex);\n             {\n                 if (!private->fuse_thread_started) {\n-                    private->fuse_thread_started = 1;\n+                   private\n+                    ->fuse_thread_started = 1;\n                     start_thread = _gf_true;\n                 }\n             }\n             pthread_mutex_unlock(&private->sync_mutex);\n \n             if (start_thread) {\n-                private->fuse_thread = GF_CALLOC(private->reader_thread_count,\n-                                                 sizeof(pthread_t),\n-                                                 gf_fuse_mt_pthread_t);\n+               private\n+                ->fuse_thread = GF_CALLOC(private->reader_thread_count,\n+                                          sizeof(pthread_t),\n+                                          gf_fuse_mt_pthread_t);\n                 for (i = 0; i < private->reader_thread_count; i++) {\n                     ret = gf_thread_create(&private->fuse_thread[i], NULL,\n                                            fuse_thread_proc, this, \"fuseproc\");\n@@ -6580,7 +6585,8 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n                         if (fuse_get_mount_status(this) != 0) {\n                             goto auth_fail_unlock;\n                         }\n-                        private->mount_finished = _gf_true;\n+                       private\n+                        ->mount_finished = _gf_true;\n                     } else if (pfd.revents) {\n                         gf_log(this->name, GF_LOG_ERROR,\n                                \"mount pipe closed without status\");\n```",
      "/run regression",
      "CLANG-FORMAT FAILURE:\nBefore merging the patch, this diff needs to be considered for passing clang-format\n\n```diff --git a/xlators/mount/fuse/src/fuse-bridge.c b/xlators/mount/fuse/src/fuse-bridge.c\nindex 2dc9b4f42..c96b85c45 100644\n--- a/xlators/mount/fuse/src/fuse-bridge.c\n+++ b/xlators/mount/fuse/src/fuse-bridge.c\n@@ -6352,7 +6352,8 @@ fuse_priv_dump(xlator_t *this)\n     if (!this)\n         return -1;\n \n-    private = this->private;\n+   private\n+    = this->private;\n \n     if (!private)\n         return -1;\n@@ -6506,7 +6507,8 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n     glusterfs_graph_t *graph = NULL;\n     struct pollfd pfd = {0};\n \n-    private = this->private;\n+   private\n+    = this->private;\n \n     graph = data;\n \n@@ -6528,7 +6530,8 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n                 (event == GF_EVENT_CHILD_DOWN)) {\n                 pthread_mutex_lock(&private->sync_mutex);\n                 {\n-                    private->event_recvd = 1;\n+                   private\n+                    ->event_recvd = 1;\n                     pthread_cond_broadcast(&private->sync_cond);\n                 }\n                 pthread_mutex_unlock(&private->sync_mutex);\n@@ -6537,16 +6540,18 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n             pthread_mutex_lock(&private->sync_mutex);\n             {\n                 if (!private->fuse_thread_started) {\n-                    private->fuse_thread_started = 1;\n+                   private\n+                    ->fuse_thread_started = 1;\n                     start_thread = _gf_true;\n                 }\n             }\n             pthread_mutex_unlock(&private->sync_mutex);\n \n             if (start_thread) {\n-                private->fuse_thread = GF_CALLOC(private->reader_thread_count,\n-                                                 sizeof(pthread_t),\n-                                                 gf_fuse_mt_pthread_t);\n+               private\n+                ->fuse_thread = GF_CALLOC(private->reader_thread_count,\n+                                          sizeof(pthread_t),\n+                                          gf_fuse_mt_pthread_t);\n                 for (i = 0; i < private->reader_thread_count; i++) {\n                     ret = gf_thread_create(&private->fuse_thread[i], NULL,\n                                            fuse_thread_proc, this, \"fuseproc\");\n@@ -6580,7 +6585,8 @@ notify(xlator_t *this, int32_t event, void *data, ...)\n                         if (fuse_get_mount_status(this) != 0) {\n                             goto auth_fail_unlock;\n                         }\n-                        private->mount_finished = _gf_true;\n+                       private\n+                        ->mount_finished = _gf_true;\n                     } else if (pfd.revents) {\n                         gf_log(this->name, GF_LOG_ERROR,\n                                \"mount pipe closed without status\");\n```"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}