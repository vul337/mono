{
  "cve_id": "CVE-2021-44975",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix #19476 - heap overflow in aao ##crash",
  "commit_hash": "fdc9f4c36ca94dc3351efd3a5a6d4810416faf31",
  "git_url": "https://github.com/radareorg/radare2/commit/fdc9f4c36ca94dc3351efd3a5a6d4810416faf31",
  "file_path": "libr/core/anal_objc.c",
  "func_name": "objc_build_refs",
  "func_before": "static bool objc_build_refs(RCoreObjc *objc) {\n\tut64 off;\n\tif (!objc->_const || !objc->_selrefs) {\n\t\treturn false;\n\t}\n\n\tconst ut64 va_const = objc->_const->vaddr;\n\tsize_t ss_const = objc->_const->vsize;\n\tconst ut64 va_selrefs = objc->_selrefs->vaddr;\n\tsize_t ss_selrefs = objc->_selrefs->vsize;\n\n\t// TODO: check if ss_const or ss_selrefs are too big before going further\n\tsize_t maxsize = R_MAX (ss_const, ss_selrefs);\n\tmaxsize = R_MIN (maxsize, objc->file_size);\n\n\tut8 *buf = calloc (1, maxsize);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\tconst size_t word_size = objc->word_size; // assuming 8 because of the read_le64\n\tif (!r_io_read_at (objc->core->io, objc->_const->vaddr, buf, ss_const)) {\n\t\teprintf (\"aao: Cannot read the whole const section %zu\\n\", ss_const);\n\t\treturn false;\n\t}\n\tfor (off = 0; off + word_size < ss_const && off + word_size < maxsize; off += word_size) {\n\t\tut64 va = va_const + off;\n\t\tut64 xrefs_to = r_read_le64 (buf + off);\n\t\tif (isValid (xrefs_to)) {\n\t\t\tarray_add (objc, va, xrefs_to);\n\t\t}\n\t}\n\tif (!r_io_read_at (objc->core->io, va_selrefs, buf, ss_selrefs)) {\n\t\teprintf (\"aao: Cannot read the whole selrefs section\\n\");\n\t\treturn false;\n\t}\n\tfor (off = 0; off + word_size < ss_selrefs && off + word_size < maxsize; off += word_size) {\n\t\tut64 va = va_selrefs + off;\n\t\tut64 xrefs_to = r_read_le64 (buf + off);\n\t\tif (isValid (xrefs_to)) {\n\t\t\tarray_add (objc, xrefs_to, va);\n\t\t}\n\t}\n\tfree (buf);\n\treturn true;\n}",
  "abstract_func_before": "static bool objc_build_refs(RCoreObjc *VAR_0) {\n\tut64 VAR_1;\n\tif (!VAR_0->_const || !VAR_0->_selrefs) {\n\t\treturn false;\n\t}\n\n\tconst ut64 VAR_2 = VAR_0->_const->vaddr;\n\tsize_t VAR_3 = VAR_0->_const->vsize;\n\tconst ut64 VAR_4 = VAR_0->_selrefs->vaddr;\n\tsize_t VAR_5 = VAR_0->_selrefs->vsize;\n\n\t/* COMMENT_0 */\n\tsize_t VAR_6 = R_MAX (VAR_3, VAR_5);\n\tVAR_6 = R_MIN (VAR_6, VAR_0->file_size);\n\n\tut8 *VAR_7 = calloc (1, VAR_6);\n\tif (!VAR_7) {\n\t\treturn false;\n\t}\n\tconst size_t VAR_8 = VAR_0->word_size; /* COMMENT_1 */\n\tif (!r_io_read_at (VAR_0->core->io, VAR_0->_const->vaddr, VAR_7, VAR_3)) {\n\t\teprintf (\"aao: Cannot read the whole const section %zu\\n\", VAR_3);\n\t\treturn false;\n\t}\n\tfor (VAR_1 = 0; VAR_1 + VAR_8 < VAR_3 && VAR_1 + VAR_8 < VAR_6; VAR_1 += VAR_8) {\n\t\tut64 VAR_9 = VAR_2 + VAR_1;\n\t\tut64 VAR_10 = r_read_le64 (VAR_7 + VAR_1);\n\t\tif (isValid (VAR_10)) {\n\t\t\tarray_add (VAR_0, VAR_9, VAR_10);\n\t\t}\n\t}\n\tif (!r_io_read_at (VAR_0->core->io, VAR_4, VAR_7, VAR_5)) {\n\t\teprintf (\"aao: Cannot read the whole selrefs section\\n\");\n\t\treturn false;\n\t}\n\tfor (VAR_1 = 0; VAR_1 + VAR_8 < VAR_5 && VAR_1 + VAR_8 < VAR_6; VAR_1 += VAR_8) {\n\t\tut64 VAR_9 = VAR_4 + VAR_1;\n\t\tut64 VAR_10 = r_read_le64 (VAR_7 + VAR_1);\n\t\tif (isValid (VAR_10)) {\n\t\t\tarray_add (VAR_0, VAR_10, VAR_9);\n\t\t}\n\t}\n\tfree (VAR_7);\n\treturn true;\n}",
  "func_graph_path_before": "radareorg/radare2/fdc9f4c36ca94dc3351efd3a5a6d4810416faf31/anal_objc.c/vul/before/0.json",
  "func": "static bool objc_build_refs(RCoreObjc *objc) {\n\tut64 off;\n\tif (!objc->_const || !objc->_selrefs) {\n\t\treturn false;\n\t}\n\n\tconst ut64 va_const = objc->_const->vaddr;\n\tsize_t ss_const = objc->_const->vsize;\n\tconst ut64 va_selrefs = objc->_selrefs->vaddr;\n\tsize_t ss_selrefs = objc->_selrefs->vsize;\n\t// TODO: check if ss_const or ss_selrefs are too big before going further\n\tsize_t maxsize = R_MAX (ss_const, ss_selrefs);\n\tmaxsize = R_MIN (maxsize, objc->file_size);\n\tif (ss_const > maxsize) {\n\t\tif (objc->core->bin->verbose) {\n\t\t\teprintf (\"aao: Truncating ss_const from %zu to %zu\\n\", ss_const, maxsize);\n\t\t}\n\t\tss_selrefs = maxsize;\n\t}\n\tif (ss_selrefs > maxsize) {\n\t\tif (objc->core->bin->verbose) {\n\t\t\teprintf (\"aao: Truncating ss_selrefs from %zu to %zu\\n\", ss_selrefs, maxsize);\n\t\t}\n\t\tss_selrefs = maxsize;\n\t}\n\tut8 *buf = calloc (1, maxsize);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\tconst size_t word_size = objc->word_size; // assuming 8 because of the read_le64\n\tif (!r_io_read_at (objc->core->io, objc->_const->vaddr, buf, ss_const)) {\n\t\teprintf (\"aao: Cannot read the whole const section %zu\\n\", ss_const);\n\t\treturn false;\n\t}\n\tfor (off = 0; off + word_size < ss_const && off + word_size < maxsize; off += word_size) {\n\t\tut64 va = va_const + off;\n\t\tut64 xrefs_to = r_read_le64 (buf + off);\n\t\tif (isValid (xrefs_to)) {\n\t\t\tarray_add (objc, va, xrefs_to);\n\t\t}\n\t}\n\tif (!r_io_read_at (objc->core->io, va_selrefs, buf, ss_selrefs)) {\n\t\teprintf (\"aao: Cannot read the whole selrefs section\\n\");\n\t\treturn false;\n\t}\n\tfor (off = 0; off + word_size < ss_selrefs && off + word_size < maxsize; off += word_size) {\n\t\tut64 va = va_selrefs + off;\n\t\tut64 xrefs_to = r_read_le64 (buf + off);\n\t\tif (isValid (xrefs_to)) {\n\t\t\tarray_add (objc, xrefs_to, va);\n\t\t}\n\t}\n\tfree (buf);\n\treturn true;\n}",
  "abstract_func": "static bool objc_build_refs(RCoreObjc *VAR_0) {\n\tut64 VAR_1;\n\tif (!VAR_0->_const || !VAR_0->_selrefs) {\n\t\treturn false;\n\t}\n\n\tconst ut64 VAR_2 = VAR_0->_const->vaddr;\n\tsize_t VAR_3 = VAR_0->_const->vsize;\n\tconst ut64 VAR_4 = VAR_0->_selrefs->vaddr;\n\tsize_t VAR_5 = VAR_0->_selrefs->vsize;\n\t/* COMMENT_0 */\n\tsize_t VAR_6 = R_MAX (VAR_3, VAR_5);\n\tVAR_6 = R_MIN (VAR_6, VAR_0->file_size);\n\tif (VAR_3 > VAR_6) {\n\t\tif (VAR_0->core->bin->verbose) {\n\t\t\teprintf (\"aao: Truncating ss_const from %zu to %zu\\n\", VAR_3, VAR_6);\n\t\t}\n\t\tVAR_5 = VAR_6;\n\t}\n\tif (VAR_5 > VAR_6) {\n\t\tif (VAR_0->core->bin->verbose) {\n\t\t\teprintf (\"aao: Truncating ss_selrefs from %zu to %zu\\n\", VAR_5, VAR_6);\n\t\t}\n\t\tVAR_5 = VAR_6;\n\t}\n\tut8 *VAR_7 = calloc (1, VAR_6);\n\tif (!VAR_7) {\n\t\treturn false;\n\t}\n\tconst size_t VAR_8 = VAR_0->word_size; /* COMMENT_1 */\n\tif (!r_io_read_at (VAR_0->core->io, VAR_0->_const->vaddr, VAR_7, VAR_3)) {\n\t\teprintf (\"aao: Cannot read the whole const section %zu\\n\", VAR_3);\n\t\treturn false;\n\t}\n\tfor (VAR_1 = 0; VAR_1 + VAR_8 < VAR_3 && VAR_1 + VAR_8 < VAR_6; VAR_1 += VAR_8) {\n\t\tut64 VAR_9 = VAR_2 + VAR_1;\n\t\tut64 VAR_10 = r_read_le64 (VAR_7 + VAR_1);\n\t\tif (isValid (VAR_10)) {\n\t\t\tarray_add (VAR_0, VAR_9, VAR_10);\n\t\t}\n\t}\n\tif (!r_io_read_at (VAR_0->core->io, VAR_4, VAR_7, VAR_5)) {\n\t\teprintf (\"aao: Cannot read the whole selrefs section\\n\");\n\t\treturn false;\n\t}\n\tfor (VAR_1 = 0; VAR_1 + VAR_8 < VAR_5 && VAR_1 + VAR_8 < VAR_6; VAR_1 += VAR_8) {\n\t\tut64 VAR_9 = VAR_4 + VAR_1;\n\t\tut64 VAR_10 = r_read_le64 (VAR_7 + VAR_1);\n\t\tif (isValid (VAR_10)) {\n\t\t\tarray_add (VAR_0, VAR_10, VAR_9);\n\t\t}\n\t}\n\tfree (VAR_7);\n\treturn true;\n}",
  "func_graph_path": "radareorg/radare2/fdc9f4c36ca94dc3351efd3a5a6d4810416faf31/anal_objc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,11 +8,21 @@\n \tsize_t ss_const = objc->_const->vsize;\n \tconst ut64 va_selrefs = objc->_selrefs->vaddr;\n \tsize_t ss_selrefs = objc->_selrefs->vsize;\n-\n \t// TODO: check if ss_const or ss_selrefs are too big before going further\n \tsize_t maxsize = R_MAX (ss_const, ss_selrefs);\n \tmaxsize = R_MIN (maxsize, objc->file_size);\n-\n+\tif (ss_const > maxsize) {\n+\t\tif (objc->core->bin->verbose) {\n+\t\t\teprintf (\"aao: Truncating ss_const from %zu to %zu\\n\", ss_const, maxsize);\n+\t\t}\n+\t\tss_selrefs = maxsize;\n+\t}\n+\tif (ss_selrefs > maxsize) {\n+\t\tif (objc->core->bin->verbose) {\n+\t\t\teprintf (\"aao: Truncating ss_selrefs from %zu to %zu\\n\", ss_selrefs, maxsize);\n+\t\t}\n+\t\tss_selrefs = maxsize;\n+\t}\n \tut8 *buf = calloc (1, maxsize);\n \tif (!buf) {\n \t\treturn false;",
  "diff_line_info": {
    "deleted_lines": [
      "",
      ""
    ],
    "added_lines": [
      "\tif (ss_const > maxsize) {",
      "\t\tif (objc->core->bin->verbose) {",
      "\t\t\teprintf (\"aao: Truncating ss_const from %zu to %zu\\n\", ss_const, maxsize);",
      "\t\t}",
      "\t\tss_selrefs = maxsize;",
      "\t}",
      "\tif (ss_selrefs > maxsize) {",
      "\t\tif (objc->core->bin->verbose) {",
      "\t\t\teprintf (\"aao: Truncating ss_selrefs from %zu to %zu\\n\", ss_selrefs, maxsize);",
      "\t\t}",
      "\t\tss_selrefs = maxsize;",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19483",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19483: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19483",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:**\n   - **Commit Message:** Mentions \"Fix #19476\" and \"heap overflow,\" indicating a security issue.\n   - **Code Diff:** Adds checks to truncate sizes if they exceed maxsize, preventing buffer overflow.\n\n2. **Consistency Check:**\n   - The commit details align with the code changes; both address heap overflow by adding bounds checks.\n\n3. **Purpose Evaluation:**\n   - Modifies core logic to fix a bug related to buffer overflow, a critical security issue.\n\n4. **Security Vulnerability Assessment:**\n   - Addresses a heap overflow, a known security vulnerability, by enforcing size constraints.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}