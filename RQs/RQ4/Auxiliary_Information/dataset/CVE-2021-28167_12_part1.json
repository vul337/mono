{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveStaticMethodRefInto",
  "func_before": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif (NULL != ramCPEntry)\n\t{\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
  "abstract_func_before": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMStaticMethodRef *VAR_4)\n{\n\tJ9ROMMethodRef *VAR_5;\n\tJ9Class *VAR_6;\n\tJ9Method *VAR_7 = NULL;\n\tJ9Class *VAR_8;\n\tJ9Class *VAR_9 = NULL;\n\tBOOLEAN VAR_10 = FALSE;\n\tJ9ROMNameAndSignature *VAR_11 = NULL;\n\tbool VAR_12 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = !VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tbool VAR_16 = VAR_14 && J9_ARE_NO_BITS_SET(VAR_3, VAR_17);\n\tUDATA VAR_18 = 0;\n\tif (VAR_14) {\n\t\tif (!VAR_16) {\n\t\t\tVAR_18 = VAR_19;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_18 = VAR_20;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\ntryAgain:\n\tVAR_5 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\tVAR_11 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_5);\n\n\tcheckForDecompile(VAR_0, VAR_5, VAR_12);\n\n#if defined(VAR_21)\n\t/* COMMENT_0 */\n\tJ9NameAndSignature VAR_22 = {NULL, NULL};\n\tJ9UTF8 VAR_23 = {0};\n#endif /* COMMENT_1 */\n\n\t/* COMMENT_2 */\n\tVAR_6 = resolveClassRef(VAR_0, VAR_1, VAR_5->classRefCPIndex, VAR_3);\n\tif (VAR_6 == NULL) {\n\t\tgoto done;\n\t}\n\tVAR_10 = (VAR_24 == (VAR_6->romClass->modifiers & VAR_24));\n\n\t/* COMMENT_3 */\n\tVAR_18 |= VAR_25;\n\tif ((VAR_3 & VAR_26) == VAR_26) {\n\t\tVAR_8 = NULL;\n\t} else {\n\t\tVAR_8 = J9_CLASS_FROM_CP(VAR_1);\n\t\tVAR_18 |= VAR_27;\n\n\t\tif (J2SE_VERSION(VAR_0->javaVM) >= VAR_28) {\n\t\t\t/* COMMENT_4 */\n                                               \n      \n\t\t\tif ((VAR_8 != NULL) && (VAR_8->romClass != NULL)) {\n\t\t\t\tUDATA VAR_29 = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(VAR_8->romClass), VAR_2);\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tif ((VAR_30 != VAR_29)\n\t\t\t\t\t&& (VAR_31 != VAR_29)\n\t\t\t\t\t&& (VAR_32 != VAR_29)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((VAR_30 == VAR_29)\n\t\t\t\t\t|| (VAR_31 == VAR_29)\n\t\t\t\t\t|| (VAR_32 == VAR_29)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (VAR_10) {\n\t\tVAR_18 |= VAR_33;\n\t}\n\n#if defined(VAR_21)\n\tif (VAR_6 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_0->javaVM)) {\n\t\tJ9UTF8 *VAR_34 = J9ROMNAMEANDSIGNATURE_NAME(VAR_11);\n\t\t/* COMMENT_7 */\n                                   \n    \n                                                                    \n                                                \n     \n\t\tU_8* VAR_35 = J9UTF8_DATA(VAR_34);\n\t\tU_16 VAR_36 = J9UTF8_LENGTH(VAR_34);\n\n\t\tif (isMethodHandleINL(VAR_35, VAR_36)) {\n\t\t\t/* COMMENT_13 */\n\t\t\tVAR_22.name = VAR_34;\n\t\t\tVAR_22.signature = &VAR_23;\n\t\t\tVAR_11 = (J9ROMNameAndSignature *)(&VAR_22);\n\n\t\t\t/* COMMENT_14 */\n\t\t\tVAR_18 |= (VAR_37 | VAR_38);\n\t\t}\n\t}\n#endif /* COMMENT_1 */\n\tVAR_7 = (J9Method *)javaLookupMethod(VAR_0, VAR_6, VAR_11, VAR_8, VAR_18);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(VAR_0, VAR_7);\n\n\tif (VAR_7 == NULL) {\n\t\tgoto done;\n\t}\n\n\tVAR_9 = J9_CLASS_FROM_METHOD(VAR_7);\n\tif (VAR_9 != VAR_6) {\n\t\tif (VAR_10) {\nincompat:\n\t\t\tif (VAR_16) {\n\t\t\t\tsetCurrentException(VAR_0, VAR_39, NULL);\n\t\t\t}\n\t\t\tVAR_7 = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_15 */\n\t\n\tif (J9_ARE_NO_BITS_SET(VAR_3, VAR_40)) {\n\t\tJ9Class *VAR_9 = J9_CLASS_FROM_METHOD(VAR_7);\n\t\tUDATA VAR_41 = VAR_9->initializeStatus;\n\t\tif (VAR_12 && (VAR_42 != VAR_41)) {\n\t\t\tVAR_7 = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (VAR_41 != VAR_42 && VAR_41 != (UDATA)VAR_0) {\n\t\t\t/* COMMENT_16 */\n\t\t\tif (VAR_14) {\n\t\t\t\tUDATA VAR_43 = VAR_0->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(VAR_0, VAR_9);\n\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (VAR_43 != VAR_0->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_7 = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif (NULL != VAR_4)\n\t{\n\t\tVAR_4->method = VAR_7;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(VAR_0, VAR_7);\n\treturn VAR_7;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/4.json",
  "func": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
  "abstract_func": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMStaticMethodRef *VAR_4)\n{\n\tJ9ROMMethodRef *VAR_5;\n\tJ9Class *VAR_6;\n\tJ9Method *VAR_7 = NULL;\n\tJ9Class *VAR_8;\n\tJ9Class *VAR_9 = NULL;\n\tBOOLEAN VAR_10 = FALSE;\n\tJ9ROMNameAndSignature *VAR_11 = NULL;\n\tbool VAR_12 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = !VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tbool VAR_16 = VAR_14 && J9_ARE_NO_BITS_SET(VAR_3, VAR_17);\n\tUDATA VAR_18 = 0;\n\tif (VAR_14) {\n\t\tif (!VAR_16) {\n\t\t\tVAR_18 = VAR_19;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_18 = VAR_20;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\ntryAgain:\n\tVAR_5 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\tVAR_11 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_5);\n\n\tcheckForDecompile(VAR_0, VAR_5, VAR_12);\n\n#if defined(VAR_21)\n\t/* COMMENT_0 */\n\tJ9NameAndSignature VAR_22 = {NULL, NULL};\n\tJ9UTF8 VAR_23 = {0};\n#endif /* COMMENT_1 */\n\n\t/* COMMENT_2 */\n\tVAR_6 = resolveClassRef(VAR_0, VAR_1, VAR_5->classRefCPIndex, VAR_3);\n\tif (VAR_6 == NULL) {\n\t\tgoto done;\n\t}\n\tVAR_10 = (VAR_24 == (VAR_6->romClass->modifiers & VAR_24));\n\n\t/* COMMENT_3 */\n\tVAR_18 |= VAR_25;\n\tif ((VAR_3 & VAR_26) == VAR_26) {\n\t\tVAR_8 = NULL;\n\t} else {\n\t\tVAR_8 = J9_CLASS_FROM_CP(VAR_1);\n\t\tVAR_18 |= VAR_27;\n\n\t\tif (J2SE_VERSION(VAR_0->javaVM) >= VAR_28) {\n\t\t\t/* COMMENT_4 */\n                                               \n      \n\t\t\tif ((VAR_8 != NULL) && (VAR_8->romClass != NULL)) {\n\t\t\t\tUDATA VAR_29 = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(VAR_8->romClass), VAR_2);\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tif ((VAR_30 != VAR_29)\n\t\t\t\t\t&& (VAR_31 != VAR_29)\n\t\t\t\t\t&& (VAR_32 != VAR_29)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((VAR_30 == VAR_29)\n\t\t\t\t\t|| (VAR_31 == VAR_29)\n\t\t\t\t\t|| (VAR_32 == VAR_29)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (VAR_10) {\n\t\tVAR_18 |= VAR_33;\n\t}\n\n#if defined(VAR_21)\n\tif (VAR_6 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_0->javaVM)) {\n\t\tJ9UTF8 *VAR_34 = J9ROMNAMEANDSIGNATURE_NAME(VAR_11);\n\t\t/* COMMENT_7 */\n                                   \n    \n                                                                    \n                                                \n     \n\t\tU_8* VAR_35 = J9UTF8_DATA(VAR_34);\n\t\tU_16 VAR_36 = J9UTF8_LENGTH(VAR_34);\n\n\t\tif (isMethodHandleINL(VAR_35, VAR_36)) {\n\t\t\t/* COMMENT_13 */\n\t\t\tVAR_22.name = VAR_34;\n\t\t\tVAR_22.signature = &VAR_23;\n\t\t\tVAR_11 = (J9ROMNameAndSignature *)(&VAR_22);\n\n\t\t\t/* COMMENT_14 */\n\t\t\tVAR_18 |= (VAR_37 | VAR_38);\n\t\t}\n\t}\n#endif /* COMMENT_1 */\n\tVAR_7 = (J9Method *)javaLookupMethod(VAR_0, VAR_6, VAR_11, VAR_8, VAR_18);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(VAR_0, VAR_7);\n\n\tif (VAR_7 == NULL) {\n\t\tgoto done;\n\t}\n\n\tVAR_9 = J9_CLASS_FROM_METHOD(VAR_7);\n\tif (VAR_9 != VAR_6) {\n\t\tif (VAR_10) {\nincompat:\n\t\t\tif (VAR_16) {\n\t\t\t\tsetCurrentException(VAR_0, VAR_39, NULL);\n\t\t\t}\n\t\t\tVAR_7 = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_15 */\n\t\n\tif (J9_ARE_NO_BITS_SET(VAR_3, VAR_40)) {\n\t\tJ9Class *VAR_9 = J9_CLASS_FROM_METHOD(VAR_7);\n\t\tUDATA VAR_41 = VAR_9->initializeStatus;\n\t\tif (VAR_12 && (VAR_42 != VAR_41)) {\n\t\t\tVAR_7 = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (VAR_41 != VAR_42 && VAR_41 != (UDATA)VAR_0) {\n\t\t\t/* COMMENT_16 */\n\t\t\tif (VAR_14) {\n\t\t\t\tUDATA VAR_43 = VAR_0->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(VAR_0, VAR_9);\n\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (VAR_43 != VAR_0->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_7 = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif ((NULL != VAR_4) && J9_ARE_NO_BITS_SET(VAR_3, VAR_44)) {\n\t\tVAR_4->method = VAR_7;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(VAR_0, VAR_7);\n\treturn VAR_7;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -149,8 +149,7 @@\n \t\t\t}\n \t\t}\n \t}\n-\tif (NULL != ramCPEntry)\n-\t{\n+\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tramCPEntry->method = method;\n \t}\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (NULL != ramCPEntry)",
      "\t{"
    ],
    "added_lines": [
      "\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch is a fix for an issue in class loading and constant pool handling. It modifies the code to prevent certain updates and initializations, which is a functional fix rather than a security one. The changes are clear and consistent with the commit message.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}