{
  "cve_id": "CVE-2020-35518",
  "cwe_ids": [
    "CWE-203"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "389ds/389-ds-base",
  "commit_msg": "Issue 4480 - Unexpected info returned to ldap request (#4491)\n\nBug description:\r\n\tIf the bind entry does not exist, the bind result info\r\n        reports that 'No such entry'. It should not give any\r\n        information if the target entry exists or not\r\n\r\nFix description:\r\n\tDoes not return any additional information during a bind\r\n\r\nrelates: https://github.com/389ds/389-ds-base/issues/4480\r\n\r\nReviewed by: William Brown, Viktor Ashirov, Mark Reynolds (thank you all)\r\n\r\nPlatforms tested:  F31",
  "commit_hash": "cc0f69283abc082488824702dae485b8eae938bc",
  "git_url": "https://github.com/389ds/389-ds-base/commit/cc0f69283abc082488824702dae485b8eae938bc",
  "file_path": "ldap/servers/slapd/result.c",
  "func_name": "send_ldap_result_ext",
  "func_before": "void\nsend_ldap_result_ext(\n    Slapi_PBlock *pb,\n    int err,\n    char *matched,\n    char *text,\n    int nentries,\n    struct berval **urls,\n    BerElement *ber)\n{\n    Slapi_Operation *operation;\n    passwdPolicy *pwpolicy = NULL;\n    Connection *conn = NULL;\n    Slapi_DN *sdn = NULL;\n    const char *dn = NULL;\n    ber_tag_t tag;\n    int flush_ber_element = 1;\n    ber_tag_t bind_method = 0;\n    int internal_op;\n    int i, rc, logit = 0;\n    char *pbtext;\n\n    slapi_pblock_get(pb, SLAPI_BIND_METHOD, &bind_method);\n    slapi_pblock_get(pb, SLAPI_OPERATION, &operation);\n    slapi_pblock_get(pb, SLAPI_CONNECTION, &conn);\n\n    if (text) {\n        pbtext = text;\n    } else {\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtext);\n    }\n\n    if (operation == NULL) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\\n\");\n        return;\n    }\n\n    if (operation->o_status == SLAPI_OP_STATUS_RESULT_SENT) {\n        return; /* result already sent */\n    }\n\n    if (ber != NULL) {\n        flush_ber_element = 0;\n    }\n\n    if (err != LDAP_SUCCESS) {\n        /* count the error for snmp */\n        /* first check for security errors */\n        if (err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN) {\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);\n        } else if (err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS) {\n            /*madman man spec says not to count as normal errors\n                --security errors\n                --referrals\n                -- partially seviced operations will not be conted as an error\n                      */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);\n        }\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"=> %d:%s:%s\\n\", err,\n                  matched ? matched : \"\", text ? text : \"\");\n\n    switch (operation->o_tag) {\n    case LBER_DEFAULT:\n        tag = LBER_SEQUENCE;\n        break;\n\n    case LDAP_REQ_SEARCH:\n        tag = LDAP_RES_SEARCH_RESULT;\n        break;\n\n    case LDAP_REQ_DELETE:\n        tag = LDAP_RES_DELETE;\n        break;\n\n    case LDAP_REFERRAL:\n        if (conn && conn->c_ldapversion > LDAP_VERSION2) {\n            tag = LDAP_TAG_REFERRAL;\n            break;\n        }\n    /* FALLTHROUGH */\n\n    default:\n        tag = operation->o_tag + 1;\n        break;\n    }\n\n    internal_op = operation_is_flag_set(operation, OP_FLAG_INTERNAL);\n    if ((conn == NULL) || (internal_op)) {\n        if (operation->o_result_handler != NULL) {\n            operation->o_result_handler(conn, operation, err,\n                                        matched, text, nentries, urls);\n            logit = 1;\n        }\n        goto log_and_return;\n    }\n\n    /* invalid password.  Update the password retry here */\n    /* put this here for now.  It could be a send_result pre-op plugin. */\n    if ((err == LDAP_INVALID_CREDENTIALS) && (bind_method != LDAP_AUTH_SASL)) {\n        slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);\n        dn = slapi_sdn_get_dn(sdn);\n        pwpolicy = new_passwdPolicy(pb, dn);\n        if (pwpolicy && (pwpolicy->pw_lockout == 1)) {\n            if (update_pw_retry(pb) == LDAP_CONSTRAINT_VIOLATION && !pwpolicy->pw_is_legacy) {\n                /*\n                 * If we are not using the legacy pw policy behavior,\n                 * convert the error 49 to 19 (constraint violation)\n                 * and log a message\n                 */\n                err = LDAP_CONSTRAINT_VIOLATION;\n                text = \"Invalid credentials, you now have exceeded the password retry limit.\";\n            }\n        }\n    }\n\n    if (ber == NULL) {\n        if ((ber = der_alloc()) == NULL) {\n            slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_alloc failed\\n\");\n            goto log_and_return;\n        }\n    }\n\n    /* there is no admin limit exceeded in v2 - change to size limit XXX */\n    if (err == LDAP_ADMINLIMIT_EXCEEDED &&\n        conn->c_ldapversion < LDAP_VERSION3) {\n        err = LDAP_SIZELIMIT_EXCEEDED;\n    }\n\n    if (conn->c_ldapversion < LDAP_VERSION3 || urls == NULL) {\n        char *save, *buf = NULL;\n\n        /*\n         * if there are v2 referrals to send, construct\n         * the v2 referral string.\n         */\n        if (urls != NULL) {\n            int len;\n\n            /* count the referral */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n\n            /*\n             * figure out how much space we need\n             */\n            len = 10; /* strlen(\"Referral:\") + NULL */\n            for (i = 0; urls[i] != NULL; i++) {\n                len += urls[i]->bv_len + 1; /* newline + ref */\n            }\n            if (text != NULL) {\n                len += strlen(text) + 1; /* text + newline */\n            }\n            /*\n             * allocate buffer and fill it in with the error\n             * message plus v2-style referrals.\n             */\n            buf = slapi_ch_malloc(len);\n            *buf = '\\0';\n            if (text != NULL) {\n                strcpy(buf, text);\n                strcat(buf, \"\\n\");\n            }\n            strcat(buf, \"Referral:\");\n            for (i = 0; urls[i] != NULL; i++) {\n                strcat(buf, \"\\n\");\n                strcat(buf, urls[i]->bv_val);\n            }\n            save = text;\n            text = buf;\n        }\n\n        if ((conn->c_ldapversion < LDAP_VERSION3 &&\n             err == LDAP_REFERRAL) ||\n            urls != NULL) {\n            err = LDAP_PARTIAL_RESULTS;\n        }\n        rc = ber_printf(ber, \"{it{ess\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", pbtext ? pbtext : \"\");\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n            /* XXXmcs: should we also check for a missing auth response control? */\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n\n        if (buf != NULL) {\n            text = save;\n            slapi_ch_free((void **)&buf);\n        }\n    } else {\n        /*\n         * there are v3 referrals to add to the result\n         */\n        /* count the referral */\n        if (!config_check_referral_mode())\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n        rc = ber_printf(ber, \"{it{esst{s\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", text ? text : \"\", LDAP_TAG_REFERRAL,\n                        urls[0]->bv_val);\n        for (i = 1; urls[i] != NULL && rc != LBER_ERROR; i++) {\n            rc = ber_printf(ber, \"s\", urls[i]->bv_val);\n        }\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* two more } to come */\n        }\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n    }\n    if (err == LDAP_SUCCESS) {\n        /*\n         * Process the Read Entry Controls (if any)\n         */\n        if (process_read_entry_controls(pb, LDAP_CONTROL_PRE_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n        if (process_read_entry_controls(pb, LDAP_CONTROL_POST_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n    }\n    if (operation->o_results.result_controls != NULL && conn->c_ldapversion >= LDAP_VERSION3 && write_controls(ber, operation->o_results.result_controls) != 0) {\n        rc = (int)LBER_ERROR;\n    }\n\n    if (rc != LBER_ERROR) { /* end the LDAPMessage sequence */\n        rc = ber_put_seq(ber);\n    }\n\n    if (rc == LBER_ERROR) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_printf failed 1\\n\");\n        if (flush_ber_element == 1) {\n            /* we alloced the ber */\n            ber_free(ber, 1 /* freebuf */);\n        }\n        goto log_and_return;\n    }\n\n    if (flush_ber_element) {\n        /* write only one pdu at a time - wait til it's our turn */\n        if (flush_ber(pb, conn, operation, ber, _LDAP_SEND_RESULT) == 0) {\n            logit = 1;\n        }\n    }\n\nlog_and_return:\n    operation->o_status = SLAPI_OP_STATUS_RESULT_SENT; /* in case this has not yet been set */\n\n    if (logit && (operation_is_flag_set(operation, OP_FLAG_ACTION_LOG_ACCESS) ||\n                  (internal_op && config_get_plugin_logging()))) {\n        log_result(pb, operation, err, tag, nentries);\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"<= %d\\n\", err);\n}",
  "abstract_func_before": "void\nsend_ldap_result_ext(\n    Slapi_PBlock *VAR_0,\n    int VAR_1,\n    char *VAR_2,\n    char *VAR_3,\n    int VAR_4,\n    struct berval **VAR_5,\n    BerElement *VAR_6)\n{\n    Slapi_Operation *VAR_7;\n    passwdPolicy *VAR_8 = NULL;\n    Connection *VAR_9 = NULL;\n    Slapi_DN *VAR_10 = NULL;\n    const char *VAR_11 = NULL;\n    ber_tag_t VAR_12;\n    int VAR_13 = 1;\n    ber_tag_t VAR_14 = 0;\n    int VAR_15;\n    int VAR_16, VAR_17, VAR_18 = 0;\n    char *VAR_19;\n\n    slapi_pblock_get(VAR_0, VAR_20, &VAR_14);\n    slapi_pblock_get(VAR_0, VAR_21, &VAR_7);\n    slapi_pblock_get(VAR_0, VAR_22, &VAR_9);\n\n    if (VAR_3) {\n        VAR_19 = VAR_3;\n    } else {\n        slapi_pblock_get(VAR_0, VAR_23, &VAR_19);\n    }\n\n    if (VAR_7 == NULL) {\n        slapi_log_err(VAR_24, \"send_ldap_result_ext\", \"No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\\n\");\n        return;\n    }\n\n    if (VAR_7->o_status == VAR_25) {\n        return; /* COMMENT_0 */\n    }\n\n    if (VAR_6 != NULL) {\n        VAR_13 = 0;\n    }\n\n    if (VAR_1 != VAR_26) {\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        if (VAR_1 == VAR_27 || VAR_1 == VAR_28 || VAR_1 == VAR_29 || VAR_1 == VAR_30 || VAR_1 == VAR_31 || VAR_1 == VAR_32 || VAR_1 == VAR_33 || VAR_1 == VAR_34) {\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);\n        } else if (VAR_1 != VAR_35 && VAR_1 != VAR_36 && VAR_1 != VAR_37) {\n            /* COMMENT_3 */\n                                 \n                           \n                                                                              \n                        \n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);\n        }\n    }\n\n    slapi_log_err(VAR_38, \"send_ldap_result_ext\", \"=> %d:%s:%s\\n\", VAR_1,\n                  VAR_2 ? VAR_2 : \"\", VAR_3 ? VAR_3 : \"\");\n\n    switch (VAR_7->o_tag) {\n    case VAR_39:\n        VAR_12 = VAR_40;\n        break;\n\n    case VAR_41:\n        VAR_12 = VAR_42;\n        break;\n\n    case VAR_43:\n        VAR_12 = VAR_44;\n        break;\n\n    case VAR_35:\n        if (VAR_9 && VAR_9->c_ldapversion > VAR_45) {\n            VAR_12 = VAR_46;\n            break;\n        }\n    /* COMMENT_8 */\n\n    default:\n        VAR_12 = VAR_7->o_tag + 1;\n        break;\n    }\n\n    VAR_15 = operation_is_flag_set(VAR_7, VAR_47);\n    if ((VAR_9 == NULL) || (VAR_15)) {\n        if (VAR_7->o_result_handler != NULL) {\n            VAR_7->o_result_handler(VAR_9, VAR_7, VAR_1,\n                                        VAR_2, VAR_3, VAR_4, VAR_5);\n            VAR_18 = 1;\n        }\n        goto log_and_return;\n    }\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if ((VAR_1 == VAR_27) && (VAR_14 != VAR_48)) {\n        slapi_pblock_get(VAR_0, VAR_49, &VAR_10);\n        VAR_11 = slapi_sdn_get_dn(VAR_10);\n        VAR_8 = new_passwdPolicy(VAR_0, VAR_11);\n        if (VAR_8 && (VAR_8->pw_lockout == 1)) {\n            if (update_pw_retry(VAR_0) == VAR_50 && !VAR_8->pw_is_legacy) {\n                /* COMMENT_11 */\n                                                                     \n                                                                    \n                                    \n                   \n                VAR_1 = VAR_50;\n                VAR_3 = \"Invalid credentials, you now have exceeded the password retry limit.\";\n            }\n        }\n    }\n\n    if (VAR_6 == NULL) {\n        if ((VAR_6 = der_alloc()) == NULL) {\n            slapi_log_err(VAR_24, \"send_ldap_result_ext\", \"ber_alloc failed\\n\");\n            goto log_and_return;\n        }\n    }\n\n    /* COMMENT_16 */\n    if (VAR_1 == VAR_51 &&\n        VAR_9->c_ldapversion < VAR_52) {\n        VAR_1 = VAR_53;\n    }\n\n    if (VAR_9->c_ldapversion < VAR_52 || VAR_5 == NULL) {\n        char *VAR_54, *VAR_55 = NULL;\n\n        /* COMMENT_17 */\n                                                       \n                                  \n           \n        if (VAR_5 != NULL) {\n            int VAR_56;\n\n            /* COMMENT_21 */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n\n            /* COMMENT_22 */\n                                                \n               \n            VAR_56 = 10; /* COMMENT_25 */\n            for (VAR_16 = 0; VAR_5[VAR_16] != NULL; VAR_16++) {\n                VAR_56 += VAR_5[VAR_16]->bv_len + 1; /* COMMENT_26 */\n            }\n            if (VAR_3 != NULL) {\n                VAR_56 += strlen(VAR_3) + 1; /* COMMENT_27 */\n            }\n            /* COMMENT_28 */\n                                                            \n                                               \n               \n            VAR_55 = slapi_ch_malloc(VAR_56);\n            *VAR_55 = '\\0';\n            if (VAR_3 != NULL) {\n                strcpy(VAR_55, VAR_3);\n                strcat(VAR_55, \"\\n\");\n            }\n            strcat(VAR_55, \"Referral:\");\n            for (VAR_16 = 0; VAR_5[VAR_16] != NULL; VAR_16++) {\n                strcat(VAR_55, \"\\n\");\n                strcat(VAR_55, VAR_5[VAR_16]->bv_val);\n            }\n            VAR_54 = VAR_3;\n            VAR_3 = VAR_55;\n        }\n\n        if ((VAR_9->c_ldapversion < VAR_52 &&\n             VAR_1 == VAR_35) ||\n            VAR_5 != NULL) {\n            VAR_1 = VAR_37;\n        }\n        VAR_17 = ber_printf(VAR_6, \"{it{ess\", VAR_7->o_msgid, VAR_12, VAR_1,\n                        VAR_2 ? VAR_2 : \"\", VAR_19 ? VAR_19 : \"\");\n\n        /* COMMENT_32 */\n                                                                       \n                                                                       \n                                      \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_extended_result(VAR_0, VAR_12, VAR_6);\n        }\n\n        /* COMMENT_37 */\n                                                                 \n                                                                     \n                          \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_SASL_response(VAR_0, VAR_12, VAR_6, VAR_9);\n            /* COMMENT_42 */\n        }\n\n        if (VAR_17 != VAR_57) {\n            VAR_17 = ber_printf(VAR_6, \"}\"); /* COMMENT_43 */\n        }\n\n        if (VAR_55 != NULL) {\n            VAR_3 = VAR_54;\n            slapi_ch_free((void **)&VAR_55);\n        }\n    } else {\n        /* COMMENT_44 */\n                                                      \n           \n        /* COMMENT_21 */\n        if (!config_check_referral_mode())\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n        VAR_17 = ber_printf(VAR_6, \"{it{esst{s\", VAR_7->o_msgid, VAR_12, VAR_1,\n                        VAR_2 ? VAR_2 : \"\", VAR_3 ? VAR_3 : \"\", VAR_46,\n                        VAR_5[0]->bv_val);\n        for (VAR_16 = 1; VAR_5[VAR_16] != NULL && VAR_17 != VAR_57; VAR_16++) {\n            VAR_17 = ber_printf(VAR_6, \"s\", VAR_5[VAR_16]->bv_val);\n        }\n        if (VAR_17 != VAR_57) {\n            VAR_17 = ber_printf(VAR_6, \"}\"); /* COMMENT_47 */\n        }\n\n        /* COMMENT_48 */\n                                                                       \n                                                                       \n                                      \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_extended_result(VAR_0, VAR_12, VAR_6);\n        }\n\n        /* COMMENT_53 */\n                                                                 \n                                                                     \n                          \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_SASL_response(VAR_0, VAR_12, VAR_6, VAR_9);\n        }\n\n        if (VAR_17 != VAR_57) {\n            VAR_17 = ber_printf(VAR_6, \"}\"); /* COMMENT_43 */\n        }\n    }\n    if (VAR_1 == VAR_26) {\n        /* COMMENT_58 */\n                                                   \n           \n        if (process_read_entry_controls(VAR_0, VAR_58)) {\n            VAR_1 = VAR_59;\n            goto log_and_return;\n        }\n        if (process_read_entry_controls(VAR_0, VAR_60)) {\n            VAR_1 = VAR_59;\n            goto log_and_return;\n        }\n    }\n    if (VAR_7->o_results.result_controls != NULL && VAR_9->c_ldapversion >= VAR_52 && write_controls(VAR_6, VAR_7->o_results.result_controls) != 0) {\n        VAR_17 = (int)VAR_57;\n    }\n\n    if (VAR_17 != VAR_57) { /* COMMENT_61 */\n        VAR_17 = ber_put_seq(VAR_6);\n    }\n\n    if (VAR_17 == VAR_57) {\n        slapi_log_err(VAR_24, \"send_ldap_result_ext\", \"ber_printf failed 1\\n\");\n        if (VAR_13 == 1) {\n            /* COMMENT_62 */\n            ber_free(VAR_6, 1 /* COMMENT_63 */);\n        }\n        goto log_and_return;\n    }\n\n    if (VAR_13) {\n        /* COMMENT_64 */\n        if (flush_ber(VAR_0, VAR_9, VAR_7, VAR_6, VAR_61) == 0) {\n            VAR_18 = 1;\n        }\n    }\n\nlog_and_return:\n    VAR_7->o_status = VAR_25; /* COMMENT_65 */\n\n    if (VAR_18 && (operation_is_flag_set(VAR_7, VAR_62) ||\n                  (VAR_15 && config_get_plugin_logging()))) {\n        log_result(VAR_0, VAR_7, VAR_1, VAR_12, VAR_4);\n    }\n\n    slapi_log_err(VAR_38, \"send_ldap_result_ext\", \"<= %d\\n\", VAR_1);\n}",
  "func_graph_path_before": "389ds/389-ds-base/cc0f69283abc082488824702dae485b8eae938bc/result.c/vul/before/0.json",
  "func": "void\nsend_ldap_result_ext(\n    Slapi_PBlock *pb,\n    int err,\n    char *matched,\n    char *text,\n    int nentries,\n    struct berval **urls,\n    BerElement *ber)\n{\n    Slapi_Operation *operation;\n    passwdPolicy *pwpolicy = NULL;\n    Connection *conn = NULL;\n    Slapi_DN *sdn = NULL;\n    const char *dn = NULL;\n    ber_tag_t tag;\n    int flush_ber_element = 1;\n    ber_tag_t bind_method = 0;\n    int internal_op;\n    int i, rc, logit = 0;\n    char *pbtext;\n\n    slapi_pblock_get(pb, SLAPI_BIND_METHOD, &bind_method);\n    slapi_pblock_get(pb, SLAPI_OPERATION, &operation);\n    slapi_pblock_get(pb, SLAPI_CONNECTION, &conn);\n\n    if (text) {\n        pbtext = text;\n    } else {\n        slapi_pblock_get(pb, SLAPI_RESULT_TEXT, &pbtext);\n    }\n\n    if (operation == NULL) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\\n\");\n        return;\n    }\n\n    if (operation->o_status == SLAPI_OP_STATUS_RESULT_SENT) {\n        return; /* result already sent */\n    }\n\n    if (ber != NULL) {\n        flush_ber_element = 0;\n    }\n\n    if (err != LDAP_SUCCESS) {\n        /* count the error for snmp */\n        /* first check for security errors */\n        if (err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN) {\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);\n        } else if (err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS) {\n            /*madman man spec says not to count as normal errors\n                --security errors\n                --referrals\n                -- partially seviced operations will not be conted as an error\n                      */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);\n        }\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"=> %d:%s:%s\\n\", err,\n                  matched ? matched : \"\", text ? text : \"\");\n\n    switch (operation->o_tag) {\n    case LBER_DEFAULT:\n        tag = LBER_SEQUENCE;\n        break;\n\n    case LDAP_REQ_SEARCH:\n        tag = LDAP_RES_SEARCH_RESULT;\n        break;\n\n    case LDAP_REQ_DELETE:\n        tag = LDAP_RES_DELETE;\n        break;\n\n    case LDAP_REFERRAL:\n        if (conn && conn->c_ldapversion > LDAP_VERSION2) {\n            tag = LDAP_TAG_REFERRAL;\n            break;\n        }\n    /* FALLTHROUGH */\n\n    default:\n        tag = operation->o_tag + 1;\n        break;\n    }\n\n    internal_op = operation_is_flag_set(operation, OP_FLAG_INTERNAL);\n    if ((conn == NULL) || (internal_op)) {\n        if (operation->o_result_handler != NULL) {\n            operation->o_result_handler(conn, operation, err,\n                                        matched, text, nentries, urls);\n            logit = 1;\n        }\n        goto log_and_return;\n    }\n\n    /* invalid password.  Update the password retry here */\n    /* put this here for now.  It could be a send_result pre-op plugin. */\n    if ((err == LDAP_INVALID_CREDENTIALS) && (bind_method != LDAP_AUTH_SASL)) {\n        slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);\n        dn = slapi_sdn_get_dn(sdn);\n        pwpolicy = new_passwdPolicy(pb, dn);\n        if (pwpolicy && (pwpolicy->pw_lockout == 1)) {\n            if (update_pw_retry(pb) == LDAP_CONSTRAINT_VIOLATION && !pwpolicy->pw_is_legacy) {\n                /*\n                 * If we are not using the legacy pw policy behavior,\n                 * convert the error 49 to 19 (constraint violation)\n                 * and log a message\n                 */\n                err = LDAP_CONSTRAINT_VIOLATION;\n                text = \"Invalid credentials, you now have exceeded the password retry limit.\";\n            }\n        }\n    }\n\n    if (ber == NULL) {\n        if ((ber = der_alloc()) == NULL) {\n            slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_alloc failed\\n\");\n            goto log_and_return;\n        }\n    }\n\n    /* there is no admin limit exceeded in v2 - change to size limit XXX */\n    if (err == LDAP_ADMINLIMIT_EXCEEDED &&\n        conn->c_ldapversion < LDAP_VERSION3) {\n        err = LDAP_SIZELIMIT_EXCEEDED;\n    }\n\n    if (conn->c_ldapversion < LDAP_VERSION3 || urls == NULL) {\n        char *save, *buf = NULL;\n\n        /*\n         * if there are v2 referrals to send, construct\n         * the v2 referral string.\n         */\n        if (urls != NULL) {\n            int len;\n\n            /* count the referral */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n\n            /*\n             * figure out how much space we need\n             */\n            len = 10; /* strlen(\"Referral:\") + NULL */\n            for (i = 0; urls[i] != NULL; i++) {\n                len += urls[i]->bv_len + 1; /* newline + ref */\n            }\n            if (text != NULL) {\n                len += strlen(text) + 1; /* text + newline */\n            }\n            /*\n             * allocate buffer and fill it in with the error\n             * message plus v2-style referrals.\n             */\n            buf = slapi_ch_malloc(len);\n            *buf = '\\0';\n            if (text != NULL) {\n                strcpy(buf, text);\n                strcat(buf, \"\\n\");\n            }\n            strcat(buf, \"Referral:\");\n            for (i = 0; urls[i] != NULL; i++) {\n                strcat(buf, \"\\n\");\n                strcat(buf, urls[i]->bv_val);\n            }\n            save = text;\n            text = buf;\n        }\n\n        if ((conn->c_ldapversion < LDAP_VERSION3 &&\n             err == LDAP_REFERRAL) ||\n            urls != NULL) {\n            err = LDAP_PARTIAL_RESULTS;\n        }\n        rc = ber_printf(ber, \"{it{ess\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", pbtext ? pbtext : \"\");\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n            /* XXXmcs: should we also check for a missing auth response control? */\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n\n        if (buf != NULL) {\n            text = save;\n            slapi_ch_free((void **)&buf);\n        }\n    } else {\n        /*\n         * there are v3 referrals to add to the result\n         */\n        /* count the referral */\n        if (!config_check_referral_mode())\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n        rc = ber_printf(ber, \"{it{esst{s\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", text ? text : \"\", LDAP_TAG_REFERRAL,\n                        urls[0]->bv_val);\n        for (i = 1; urls[i] != NULL && rc != LBER_ERROR; i++) {\n            rc = ber_printf(ber, \"s\", urls[i]->bv_val);\n        }\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* two more } to come */\n        }\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n    }\n    if (err == LDAP_SUCCESS) {\n        /*\n         * Process the Read Entry Controls (if any)\n         */\n        if (process_read_entry_controls(pb, LDAP_CONTROL_PRE_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n        if (process_read_entry_controls(pb, LDAP_CONTROL_POST_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n    }\n    if (operation->o_results.result_controls != NULL && conn->c_ldapversion >= LDAP_VERSION3 && write_controls(ber, operation->o_results.result_controls) != 0) {\n        rc = (int)LBER_ERROR;\n    }\n\n    if (rc != LBER_ERROR) { /* end the LDAPMessage sequence */\n        rc = ber_put_seq(ber);\n    }\n\n    if (rc == LBER_ERROR) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_printf failed 1\\n\");\n        if (flush_ber_element == 1) {\n            /* we alloced the ber */\n            ber_free(ber, 1 /* freebuf */);\n        }\n        goto log_and_return;\n    }\n\n    if (flush_ber_element) {\n        /* write only one pdu at a time - wait til it's our turn */\n        if (flush_ber(pb, conn, operation, ber, _LDAP_SEND_RESULT) == 0) {\n            logit = 1;\n        }\n    }\n\nlog_and_return:\n    operation->o_status = SLAPI_OP_STATUS_RESULT_SENT; /* in case this has not yet been set */\n\n    if (logit && (operation_is_flag_set(operation, OP_FLAG_ACTION_LOG_ACCESS) ||\n                  (internal_op && config_get_plugin_logging()))) {\n        log_result(pb, operation, err, tag, nentries);\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"<= %d\\n\", err);\n}",
  "abstract_func": "void\nsend_ldap_result_ext(\n    Slapi_PBlock *VAR_0,\n    int VAR_1,\n    char *VAR_2,\n    char *VAR_3,\n    int VAR_4,\n    struct berval **VAR_5,\n    BerElement *VAR_6)\n{\n    Slapi_Operation *VAR_7;\n    passwdPolicy *VAR_8 = NULL;\n    Connection *VAR_9 = NULL;\n    Slapi_DN *VAR_10 = NULL;\n    const char *VAR_11 = NULL;\n    ber_tag_t VAR_12;\n    int VAR_13 = 1;\n    ber_tag_t VAR_14 = 0;\n    int VAR_15;\n    int VAR_16, VAR_17, VAR_18 = 0;\n    char *VAR_19;\n\n    slapi_pblock_get(VAR_0, VAR_20, &VAR_14);\n    slapi_pblock_get(VAR_0, VAR_21, &VAR_7);\n    slapi_pblock_get(VAR_0, VAR_22, &VAR_9);\n\n    if (VAR_3) {\n        VAR_19 = VAR_3;\n    } else {\n        slapi_pblock_get(VAR_0, VAR_23, &VAR_19);\n    }\n\n    if (VAR_7 == NULL) {\n        slapi_log_err(VAR_24, \"send_ldap_result_ext\", \"No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\\n\");\n        return;\n    }\n\n    if (VAR_7->o_status == VAR_25) {\n        return; /* COMMENT_0 */\n    }\n\n    if (VAR_6 != NULL) {\n        VAR_13 = 0;\n    }\n\n    if (VAR_1 != VAR_26) {\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        if (VAR_1 == VAR_27 || VAR_1 == VAR_28 || VAR_1 == VAR_29 || VAR_1 == VAR_30 || VAR_1 == VAR_31 || VAR_1 == VAR_32 || VAR_1 == VAR_33 || VAR_1 == VAR_34) {\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);\n        } else if (VAR_1 != VAR_35 && VAR_1 != VAR_36 && VAR_1 != VAR_37) {\n            /* COMMENT_3 */\n                                 \n                           \n                                                                              \n                        \n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);\n        }\n    }\n\n    slapi_log_err(VAR_38, \"send_ldap_result_ext\", \"=> %d:%s:%s\\n\", VAR_1,\n                  VAR_2 ? VAR_2 : \"\", VAR_3 ? VAR_3 : \"\");\n\n    switch (VAR_7->o_tag) {\n    case VAR_39:\n        VAR_12 = VAR_40;\n        break;\n\n    case VAR_41:\n        VAR_12 = VAR_42;\n        break;\n\n    case VAR_43:\n        VAR_12 = VAR_44;\n        break;\n\n    case VAR_35:\n        if (VAR_9 && VAR_9->c_ldapversion > VAR_45) {\n            VAR_12 = VAR_46;\n            break;\n        }\n    /* COMMENT_8 */\n\n    default:\n        VAR_12 = VAR_7->o_tag + 1;\n        break;\n    }\n\n    VAR_15 = operation_is_flag_set(VAR_7, VAR_47);\n    if ((VAR_9 == NULL) || (VAR_15)) {\n        if (VAR_7->o_result_handler != NULL) {\n            VAR_7->o_result_handler(VAR_9, VAR_7, VAR_1,\n                                        VAR_2, VAR_3, VAR_4, VAR_5);\n            VAR_18 = 1;\n        }\n        goto log_and_return;\n    }\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if ((VAR_1 == VAR_27) && (VAR_14 != VAR_48)) {\n        slapi_pblock_get(VAR_0, VAR_49, &VAR_10);\n        VAR_11 = slapi_sdn_get_dn(VAR_10);\n        VAR_8 = new_passwdPolicy(VAR_0, VAR_11);\n        if (VAR_8 && (VAR_8->pw_lockout == 1)) {\n            if (update_pw_retry(VAR_0) == VAR_50 && !VAR_8->pw_is_legacy) {\n                /* COMMENT_11 */\n                                                                     \n                                                                    \n                                    \n                   \n                VAR_1 = VAR_50;\n                VAR_3 = \"Invalid credentials, you now have exceeded the password retry limit.\";\n            }\n        }\n    }\n\n    if (VAR_6 == NULL) {\n        if ((VAR_6 = der_alloc()) == NULL) {\n            slapi_log_err(VAR_24, \"send_ldap_result_ext\", \"ber_alloc failed\\n\");\n            goto log_and_return;\n        }\n    }\n\n    /* COMMENT_16 */\n    if (VAR_1 == VAR_51 &&\n        VAR_9->c_ldapversion < VAR_52) {\n        VAR_1 = VAR_53;\n    }\n\n    if (VAR_9->c_ldapversion < VAR_52 || VAR_5 == NULL) {\n        char *VAR_54, *VAR_55 = NULL;\n\n        /* COMMENT_17 */\n                                                       \n                                  \n           \n        if (VAR_5 != NULL) {\n            int VAR_56;\n\n            /* COMMENT_21 */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n\n            /* COMMENT_22 */\n                                                \n               \n            VAR_56 = 10; /* COMMENT_25 */\n            for (VAR_16 = 0; VAR_5[VAR_16] != NULL; VAR_16++) {\n                VAR_56 += VAR_5[VAR_16]->bv_len + 1; /* COMMENT_26 */\n            }\n            if (VAR_3 != NULL) {\n                VAR_56 += strlen(VAR_3) + 1; /* COMMENT_27 */\n            }\n            /* COMMENT_28 */\n                                                            \n                                               \n               \n            VAR_55 = slapi_ch_malloc(VAR_56);\n            *VAR_55 = '\\0';\n            if (VAR_3 != NULL) {\n                strcpy(VAR_55, VAR_3);\n                strcat(VAR_55, \"\\n\");\n            }\n            strcat(VAR_55, \"Referral:\");\n            for (VAR_16 = 0; VAR_5[VAR_16] != NULL; VAR_16++) {\n                strcat(VAR_55, \"\\n\");\n                strcat(VAR_55, VAR_5[VAR_16]->bv_val);\n            }\n            VAR_54 = VAR_3;\n            VAR_3 = VAR_55;\n        }\n\n        if ((VAR_9->c_ldapversion < VAR_52 &&\n             VAR_1 == VAR_35) ||\n            VAR_5 != NULL) {\n            VAR_1 = VAR_37;\n        }\n        VAR_17 = ber_printf(VAR_6, \"{it{ess\", VAR_7->o_msgid, VAR_12, VAR_1,\n                        VAR_2 ? VAR_2 : \"\", VAR_19 ? VAR_19 : \"\");\n\n        /* COMMENT_32 */\n                                                                       \n                                                                       \n                                      \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_extended_result(VAR_0, VAR_12, VAR_6);\n        }\n\n        /* COMMENT_37 */\n                                                                 \n                                                                     \n                          \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_SASL_response(VAR_0, VAR_12, VAR_6, VAR_9);\n            /* COMMENT_42 */\n        }\n\n        if (VAR_17 != VAR_57) {\n            VAR_17 = ber_printf(VAR_6, \"}\"); /* COMMENT_43 */\n        }\n\n        if (VAR_55 != NULL) {\n            VAR_3 = VAR_54;\n            slapi_ch_free((void **)&VAR_55);\n        }\n    } else {\n        /* COMMENT_44 */\n                                                      \n           \n        /* COMMENT_21 */\n        if (!config_check_referral_mode())\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n        VAR_17 = ber_printf(VAR_6, \"{it{esst{s\", VAR_7->o_msgid, VAR_12, VAR_1,\n                        VAR_2 ? VAR_2 : \"\", VAR_3 ? VAR_3 : \"\", VAR_46,\n                        VAR_5[0]->bv_val);\n        for (VAR_16 = 1; VAR_5[VAR_16] != NULL && VAR_17 != VAR_57; VAR_16++) {\n            VAR_17 = ber_printf(VAR_6, \"s\", VAR_5[VAR_16]->bv_val);\n        }\n        if (VAR_17 != VAR_57) {\n            VAR_17 = ber_printf(VAR_6, \"}\"); /* COMMENT_47 */\n        }\n\n        /* COMMENT_48 */\n                                                                       \n                                                                       \n                                      \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_extended_result(VAR_0, VAR_12, VAR_6);\n        }\n\n        /* COMMENT_53 */\n                                                                 \n                                                                     \n                          \n           \n        if (VAR_17 != VAR_57) {\n            VAR_17 = check_and_send_SASL_response(VAR_0, VAR_12, VAR_6, VAR_9);\n        }\n\n        if (VAR_17 != VAR_57) {\n            VAR_17 = ber_printf(VAR_6, \"}\"); /* COMMENT_43 */\n        }\n    }\n    if (VAR_1 == VAR_26) {\n        /* COMMENT_58 */\n                                                   \n           \n        if (process_read_entry_controls(VAR_0, VAR_58)) {\n            VAR_1 = VAR_59;\n            goto log_and_return;\n        }\n        if (process_read_entry_controls(VAR_0, VAR_60)) {\n            VAR_1 = VAR_59;\n            goto log_and_return;\n        }\n    }\n    if (VAR_7->o_results.result_controls != NULL && VAR_9->c_ldapversion >= VAR_52 && write_controls(VAR_6, VAR_7->o_results.result_controls) != 0) {\n        VAR_17 = (int)VAR_57;\n    }\n\n    if (VAR_17 != VAR_57) { /* COMMENT_61 */\n        VAR_17 = ber_put_seq(VAR_6);\n    }\n\n    if (VAR_17 == VAR_57) {\n        slapi_log_err(VAR_24, \"send_ldap_result_ext\", \"ber_printf failed 1\\n\");\n        if (VAR_13 == 1) {\n            /* COMMENT_62 */\n            ber_free(VAR_6, 1 /* COMMENT_63 */);\n        }\n        goto log_and_return;\n    }\n\n    if (VAR_13) {\n        /* COMMENT_64 */\n        if (flush_ber(VAR_0, VAR_9, VAR_7, VAR_6, VAR_61) == 0) {\n            VAR_18 = 1;\n        }\n    }\n\nlog_and_return:\n    VAR_7->o_status = VAR_25; /* COMMENT_65 */\n\n    if (VAR_18 && (operation_is_flag_set(VAR_7, VAR_62) ||\n                  (VAR_15 && config_get_plugin_logging()))) {\n        log_result(VAR_0, VAR_7, VAR_1, VAR_12, VAR_4);\n    }\n\n    slapi_log_err(VAR_38, \"send_ldap_result_ext\", \"<= %d\\n\", VAR_1);\n}",
  "func_graph_path": "389ds/389-ds-base/cc0f69283abc082488824702dae485b8eae938bc/result.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n     if (text) {\n         pbtext = text;\n     } else {\n-        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtext);\n+        slapi_pblock_get(pb, SLAPI_RESULT_TEXT, &pbtext);\n     }\n \n     if (operation == NULL) {",
  "diff_line_info": {
    "deleted_lines": [
      "        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtext);"
    ],
    "added_lines": [
      "        slapi_pblock_get(pb, SLAPI_RESULT_TEXT, &pbtext);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/389ds/389-ds-base/pull/4491",
  "description": {
    "pr_info": {
      "title": "Issue 4480 - Unexpected info returned to ldap request",
      "number": 4491
    },
    "comment": [
      "Bug description:\r\n\tIf the bind entry does not exist, the bind result info\r\n        reports that 'No such entry'. It should not give any\r\n        information if the target entry exists or not\r\n\r\nFix description:\r\n\tDoes not return any additional information during a bind\r\n\r\nrelates: https://github.com/389ds/389-ds-base/issues/4480\r\n\r\nReviewed by:\r\n\r\nPlatforms tested:  F31",
      "I see nothing wrong with the code and the patch here, that's all good to me. I just thing this is solving a problem that doesn't exist, and in exchange makes it harder for an admin or user to identify if they have made a mistake in their command by removing the difference between \"wrong pw\" and \"no such dn\".\r\n\r\nKnowledge of if an entry/dn exists or not, does *not* create a risk, as in most deployments anonymous bind and read is enabled by default. If you really wanted to be pedantic you could even do timing attacks to work out if this existed or not, because it's effectively impossible to do constant time search/responses. \r\n\r\nNow, to prove this, here is redhats login page showing the difference between \"account does not exist\" and \"attempt the pw\". \r\n\r\nI think that we should reject this issue, because it's not a security risk, and this pattern is accepted the world over in many authentication systems. \r\n\r\n![Screen Shot 2020-12-11 at 10 50 56](https://user-images.githubusercontent.com/271005/101847413-eb17a900-3b9e-11eb-8206-163891d6bd9a.png)\r\n\r\n![Screen Shot 2020-12-11 at 10 51 07](https://user-images.githubusercontent.com/271005/101847408-e94de580-3b9e-11eb-853f-bbdd586ef3a7.png)\r\n",
      "Just to really nail this one shut, here is google exhibiting the same behaviour - google who is a huge security target, and hires some of the best security people in the world, and they have a ui that says if the account exists or does not.\r\n\r\nAs a result, I really firmly believe this is a non issue and should be closed/rejected. \r\n\r\n![Screen Shot 2020-12-11 at 10 56 04](https://user-images.githubusercontent.com/271005/101847712-958fcc00-3b9f-11eb-9a37-61aba332d715.png)\r\n",
      "There was a [CVE](https://bugzilla.redhat.com/show_bug.cgi?id=1347760) that was fixed 4 years ago. Recently it was reintroduced. So this PR fixes this regression. \r\n\r\n> Now, to prove this, here is redhats login page showing the difference between \"account does not exist\" and \"attempt the pw\".\r\n\r\nHere's a SUSE login page that **doesn't show** a difference between \"account does not exist\" and \"attempt the pw\"\r\n\r\n(yes, I actually went and created an account)\r\n![image](https://user-images.githubusercontent.com/1745018/101887202-d0dccb80-3b9c-11eb-83f4-f0775fed79d7.png)\r\n![image](https://user-images.githubusercontent.com/1745018/101887362-0aadd200-3b9d-11eb-97bf-8c13d8c70f87.png)\r\n\r\n\r\n> google who is a huge security target, and hires some of the best security people in the world, and they have a ui that says if the account exists or does not.\r\n\r\nI think it is a faulty generalization and this argument should be rejected :)",
      "I have not strong opinion whether it is security concern or not to return some internal information.\r\nBut [CVE-2016-4992](https://bugzilla.redhat.com/show_bug.cgi?id=1347760) resulted into a big investigation and [fix](https://github.com/389ds/389-ds-base/commit/0b932d4b926d46ac5060f02617330dc444e06da1).\r\nPart of that fix was to send \"generic\" ldap result and log \"specific\" info in access logs when the information can be sensitive.\r\n\r\nThis part of the fix got broken by a recent [change](https://github.com/389ds/389-ds-base/commit/94c74015e529c08d59cc3e856199888867bd6449). I think it got broken by mistake. The intention was to return notification to a client that a [ldbm tuning moved to bdb](https://github.com/389ds/389-ds-base/blob/master/ldap/servers/slapd/back-ldbm/ldbm_config.c#L1246). For this it uses SLAPI_PB_RESULT_TEXT in the pblock and send it back during result. \r\n\r\nThe problem being that CVE-2016-4992 used that field to **only** record info in access logs.\r\nThe my original patch is too limited. #49476 changed CVE fix regarding all operations (ADD,DEL, BIND...).\r\nI will rework the patch",
      "\r\n> > google who is a huge security target, and hires some of the best security people in the world, and they have a ui that says if the account exists or does not.\r\n> \r\n> I think it is a faulty generalization and this argument should be rejected :)\r\n\r\nIt should never have been a CVE in the first place because there is provably *zero risk* in this behaviour existing. Just because SUSE \"agrees\" with the behaviour, does not discount that both rh/google allow it. It's not a faulty generalisation. \r\n\r\n\r\n> \r\n> This part of the fix got broken by a recent [change](https://github.com/389ds/389-ds-base/commit/94c74015e529c08d59cc3e856199888867bd6449). I think it got broken by mistake. The intention was to return notification to a client that a [ldbm tuning moved to bdb](https://github.com/389ds/389-ds-base/blob/master/ldap/servers/slapd/back-ldbm/ldbm_config.c#L1246). For this it uses SLAPI_PB_RESULT_TEXT in the pblock and send it back during result.\r\n> \r\n> The problem being that CVE-2016-4992 used that field to **only** record info in access logs.\r\n> The my original patch is too limited. #49476 changed CVE fix regarding all operations (ADD,DEL, BIND...).\r\n> I will rework the patch\r\n\r\nI think it should be a tunable setting, and off by default - if customers want to \"believe\" this is a security risk and lower usability at the same time, they should have to enable it. ",
      "Updated patch to cover all operations"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}