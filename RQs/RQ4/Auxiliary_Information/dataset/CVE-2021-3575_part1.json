{
  "cve_id": "CVE-2021-3575",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "opj_decompress: fix off-by-one read heap-buffer-overflow in sycc420_to_rgb() when x0 and y0 are odd (CVE-2021-3575, fixes #1347)",
  "commit_hash": "7bd884f8750892de4f50bf4642fcfbe7011c6bdf",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/7bd884f8750892de4f50bf4642fcfbe7011c6bdf",
  "file_path": "src/bin/common/color.c",
  "func_name": "sycc420_to_rgb",
  "func_before": "static void sycc420_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n    const int *y, *cb, *cr, *ny;\n    size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n    int offset, upb;\n    size_t i;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    /* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n    offx = img->x0 & 1U;\n    loopmaxw = maxw - offx;\n    /* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n    offy = img->y0 & 1U;\n    loopmaxh = maxh - offy;\n\n    if (offy > 0U) {\n        size_t j;\n\n        for (j = 0; j < maxw; ++j) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n        }\n    }\n\n    for (i = 0U; i < (loopmaxh & ~(size_t)1U); i += 2U) {\n        size_t j;\n\n        ny = y + maxw;\n        nr = r + maxw;\n        ng = g + maxw;\n        nb = b + maxw;\n\n        if (offx > 0U) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n        }\n\n        for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        if (j < loopmaxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        y += maxw;\n        r += maxw;\n        g += maxw;\n        b += maxw;\n    }\n    if (i < loopmaxh) {\n        size_t j;\n\n        for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n        if (j < maxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n        }\n    }\n\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n\n    img->comps[1].w = img->comps[2].w = img->comps[0].w;\n    img->comps[1].h = img->comps[2].h = img->comps[0].h;\n    img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n    img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}",
  "abstract_func_before": "static void sycc420_to_rgb(opj_image_t *VAR_0)\n{\n    int *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;\n    const int *VAR_10, *VAR_11, *VAR_12, *VAR_13;\n    size_t VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;\n    int VAR_21, VAR_22;\n    size_t VAR_23;\n\n    VAR_22 = (int)VAR_0->comps[0].prec;\n    VAR_21 = 1 << (VAR_22 - 1);\n    VAR_22 = (1 << VAR_22) - 1;\n\n    VAR_14 = (size_t)VAR_0->comps[0].w;\n    VAR_15 = (size_t)VAR_0->comps[0].h;\n    VAR_16 = VAR_14 * VAR_15;\n\n    VAR_10 = VAR_0->comps[0].data;\n    VAR_11 = VAR_0->comps[1].data;\n    VAR_12 = VAR_0->comps[2].data;\n\n    VAR_1 = VAR_4 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);\n    VAR_2 = VAR_5 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);\n    VAR_3 = VAR_6 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);\n\n    if (VAR_4 == NULL || VAR_5 == NULL || VAR_6 == NULL) {\n        goto fails;\n    }\n\n    /* COMMENT_0 */\n    VAR_17 = VAR_0->x0 & 1U;\n    VAR_18 = VAR_14 - VAR_17;\n    /* COMMENT_1 */\n    VAR_19 = VAR_0->y0 & 1U;\n    VAR_20 = VAR_15 - VAR_19;\n\n    if (VAR_19 > 0U) {\n        size_t VAR_24;\n\n        for (VAR_24 = 0; VAR_24 < VAR_14; ++VAR_24) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n        }\n    }\n\n    for (VAR_23 = 0U; VAR_23 < (VAR_20 & ~(size_t)1U); VAR_23 += 2U) {\n        size_t VAR_24;\n\n        VAR_13 = VAR_10 + VAR_14;\n        VAR_7 = VAR_4 + VAR_14;\n        VAR_8 = VAR_5 + VAR_14;\n        VAR_9 = VAR_6 + VAR_14;\n\n        if (VAR_17 > 0U) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n        }\n\n        for (VAR_24 = 0; VAR_24 < (VAR_18 & ~(size_t)1U); VAR_24 += 2U) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n            ++VAR_11;\n            ++VAR_12;\n        }\n        if (VAR_24 < VAR_18) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n            ++VAR_11;\n            ++VAR_12;\n        }\n        VAR_10 += VAR_14;\n        VAR_4 += VAR_14;\n        VAR_5 += VAR_14;\n        VAR_6 += VAR_14;\n    }\n    if (VAR_23 < VAR_20) {\n        size_t VAR_24;\n\n        for (VAR_24 = 0U; VAR_24 < (VAR_14 & ~(size_t)1U); VAR_24 += 2U) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n            ++VAR_11;\n            ++VAR_12;\n        }\n        if (VAR_24 < VAR_14) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n        }\n    }\n\n    opj_image_data_free(VAR_0->comps[0].data);\n    VAR_0->comps[0].data = VAR_1;\n    opj_image_data_free(VAR_0->comps[1].data);\n    VAR_0->comps[1].data = VAR_2;\n    opj_image_data_free(VAR_0->comps[2].data);\n    VAR_0->comps[2].data = VAR_3;\n\n    VAR_0->comps[1].w = VAR_0->comps[2].w = VAR_0->comps[0].w;\n    VAR_0->comps[1].h = VAR_0->comps[2].h = VAR_0->comps[0].h;\n    VAR_0->comps[1].dx = VAR_0->comps[2].dx = VAR_0->comps[0].dx;\n    VAR_0->comps[1].dy = VAR_0->comps[2].dy = VAR_0->comps[0].dy;\n    VAR_0->color_space = VAR_25;\n    return;\n\nfails:\n    opj_image_data_free(VAR_4);\n    opj_image_data_free(VAR_5);\n    opj_image_data_free(VAR_6);\n}",
  "func_graph_path_before": "uclouvain/openjpeg/7bd884f8750892de4f50bf4642fcfbe7011c6bdf/color.c/vul/before/0.json",
  "func": "static void sycc420_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n    const int *y, *cb, *cr, *ny;\n    size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n    int offset, upb;\n    size_t i;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    /* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n    offx = img->x0 & 1U;\n    loopmaxw = maxw - offx;\n    /* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n    offy = img->y0 & 1U;\n    loopmaxh = maxh - offy;\n\n    if (offy > 0U) {\n        size_t j;\n\n        for (j = 0; j < maxw; ++j) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n        }\n    }\n\n    for (i = 0U; i < (loopmaxh & ~(size_t)1U); i += 2U) {\n        size_t j;\n\n        ny = y + maxw;\n        nr = r + maxw;\n        ng = g + maxw;\n        nb = b + maxw;\n\n        if (offx > 0U) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n        }\n\n        for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        if (j < loopmaxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        y += maxw;\n        r += maxw;\n        g += maxw;\n        b += maxw;\n    }\n    if (i < loopmaxh) {\n        size_t j;\n\n        if (offx > 0U) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n        }\n\n        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n        if (j < loopmaxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n        }\n    }\n\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n\n    img->comps[1].w = img->comps[2].w = img->comps[0].w;\n    img->comps[1].h = img->comps[2].h = img->comps[0].h;\n    img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n    img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}",
  "abstract_func": "static void sycc420_to_rgb(opj_image_t *VAR_0)\n{\n    int *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;\n    const int *VAR_10, *VAR_11, *VAR_12, *VAR_13;\n    size_t VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;\n    int VAR_21, VAR_22;\n    size_t VAR_23;\n\n    VAR_22 = (int)VAR_0->comps[0].prec;\n    VAR_21 = 1 << (VAR_22 - 1);\n    VAR_22 = (1 << VAR_22) - 1;\n\n    VAR_14 = (size_t)VAR_0->comps[0].w;\n    VAR_15 = (size_t)VAR_0->comps[0].h;\n    VAR_16 = VAR_14 * VAR_15;\n\n    VAR_10 = VAR_0->comps[0].data;\n    VAR_11 = VAR_0->comps[1].data;\n    VAR_12 = VAR_0->comps[2].data;\n\n    VAR_1 = VAR_4 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);\n    VAR_2 = VAR_5 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);\n    VAR_3 = VAR_6 = (int*)opj_image_data_alloc(sizeof(int) * VAR_16);\n\n    if (VAR_4 == NULL || VAR_5 == NULL || VAR_6 == NULL) {\n        goto fails;\n    }\n\n    /* COMMENT_0 */\n    VAR_17 = VAR_0->x0 & 1U;\n    VAR_18 = VAR_14 - VAR_17;\n    /* COMMENT_1 */\n    VAR_19 = VAR_0->y0 & 1U;\n    VAR_20 = VAR_15 - VAR_19;\n\n    if (VAR_19 > 0U) {\n        size_t VAR_24;\n\n        for (VAR_24 = 0; VAR_24 < VAR_14; ++VAR_24) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n        }\n    }\n\n    for (VAR_23 = 0U; VAR_23 < (VAR_20 & ~(size_t)1U); VAR_23 += 2U) {\n        size_t VAR_24;\n\n        VAR_13 = VAR_10 + VAR_14;\n        VAR_7 = VAR_4 + VAR_14;\n        VAR_8 = VAR_5 + VAR_14;\n        VAR_9 = VAR_6 + VAR_14;\n\n        if (VAR_17 > 0U) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n        }\n\n        for (VAR_24 = 0; VAR_24 < (VAR_18 & ~(size_t)1U); VAR_24 += 2U) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n            ++VAR_11;\n            ++VAR_12;\n        }\n        if (VAR_24 < VAR_18) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_13, *VAR_11, *VAR_12, VAR_7, VAR_8, VAR_9);\n            ++VAR_13;\n            ++VAR_7;\n            ++VAR_8;\n            ++VAR_9;\n            ++VAR_11;\n            ++VAR_12;\n        }\n        VAR_10 += VAR_14;\n        VAR_4 += VAR_14;\n        VAR_5 += VAR_14;\n        VAR_6 += VAR_14;\n    }\n    if (VAR_23 < VAR_20) {\n        size_t VAR_24;\n\n        if (VAR_17 > 0U) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, 0, 0, VAR_4, VAR_5, VAR_6);\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n        }\n\n        for (VAR_24 = 0U; VAR_24 < (VAR_18 & ~(size_t)1U); VAR_24 += 2U) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n\n            ++VAR_10;\n            ++VAR_4;\n            ++VAR_5;\n            ++VAR_6;\n            ++VAR_11;\n            ++VAR_12;\n        }\n        if (VAR_24 < VAR_18) {\n            sycc_to_rgb(VAR_21, VAR_22, *VAR_10, *VAR_11, *VAR_12, VAR_4, VAR_5, VAR_6);\n        }\n    }\n\n    opj_image_data_free(VAR_0->comps[0].data);\n    VAR_0->comps[0].data = VAR_1;\n    opj_image_data_free(VAR_0->comps[1].data);\n    VAR_0->comps[1].data = VAR_2;\n    opj_image_data_free(VAR_0->comps[2].data);\n    VAR_0->comps[2].data = VAR_3;\n\n    VAR_0->comps[1].w = VAR_0->comps[2].w = VAR_0->comps[0].w;\n    VAR_0->comps[1].h = VAR_0->comps[2].h = VAR_0->comps[0].h;\n    VAR_0->comps[1].dx = VAR_0->comps[2].dx = VAR_0->comps[0].dx;\n    VAR_0->comps[1].dy = VAR_0->comps[2].dy = VAR_0->comps[0].dy;\n    VAR_0->color_space = VAR_25;\n    return;\n\nfails:\n    opj_image_data_free(VAR_4);\n    opj_image_data_free(VAR_5);\n    opj_image_data_free(VAR_6);\n}",
  "func_graph_path": "uclouvain/openjpeg/7bd884f8750892de4f50bf4642fcfbe7011c6bdf/color.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -114,7 +114,15 @@\n     if (i < loopmaxh) {\n         size_t j;\n \n-        for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {\n+        if (offx > 0U) {\n+            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n+            ++y;\n+            ++r;\n+            ++g;\n+            ++b;\n+        }\n+\n+        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n             sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \n             ++y;\n@@ -131,7 +139,7 @@\n             ++cb;\n             ++cr;\n         }\n-        if (j < maxw) {\n+        if (j < loopmaxw) {\n             sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n         }\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "        for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {",
      "        if (j < maxw) {"
    ],
    "added_lines": [
      "        if (offx > 0U) {",
      "            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);",
      "            ++y;",
      "            ++r;",
      "            ++g;",
      "            ++b;",
      "        }",
      "",
      "        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {",
      "        if (j < loopmaxw) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1509",
  "description": {
    "pr_info": {
      "title": "opj_decompress: fix off-by-one read heap-buffer-overflow in sycc420_to_rgb() when x0 and y0 are odd (CVE-2021-3575, fixes #1347)",
      "number": 1509
    },
    "comment": [
      "Now Valgrind output is clean:\r\n```\r\n$ valgrind ./bin/opj_decompress -i ./poc.j2k -o out.png\r\n==167167== Memcheck, a memory error detector\r\n==167167== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==167167== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==167167== Command: ./bin/opj_decompress -i ./poc.j2k -o out.png\r\n==167167== \r\n\r\n[INFO] Start to read j2k main header (0).\r\n[ERROR] Unknown progression order in COD marker\r\n[WARNING] Unknown marker\r\n[ERROR] Unknown progression order in COD marker\r\n[WARNING] Unknown marker\r\n[WARNING] Unknown marker\r\n[WARNING] Unknown marker\r\n[ERROR] Unknown progression order in COD marker\r\n[WARNING] Unknown marker\r\n[WARNING] Unknown marker\r\n[WARNING] Unknown marker\r\n[INFO] Main header has been correctly decoded.\r\n[INFO] No decoded area parameters, set the decoded area to the whole image\r\n[INFO] Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\r\n[INFO] Header of tile 1 / 1 has been read.\r\n[INFO] Tile 1/1 has been decoded.\r\n[INFO] Image data has been updated with tile 1.\r\n\r\nimagetopng: All components shall have the same subsampling, same bit depth, same sign.\r\n\tAborting\r\n[ERROR] Error generating png file. Outfile out.png not generated\r\n```\r\n\r\nPreviously it reported:\r\n```\r\n==167517== Invalid read of size 4\r\n==167517==    at 0x1308EC: sycc420_to_rgb (color.c:379)\r\n==167517==    by 0x130B79: color_sycc_to_rgb (color.c:416)\r\n==167517==    by 0x121624: main (opj_decompress.c:1629)\r\n==167517==  Address 0x4d7ff80 is 0 bytes after a block of size 288 alloc'd\r\n==167517==    at 0x483E0F0: memalign (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==167517==    by 0x483E212: posix_memalign (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==167517==    by 0x48C0EE8: opj_aligned_alloc_n (opj_malloc.c:61)\r\n==167517==    by 0x48C1092: opj_aligned_malloc (opj_malloc.c:209)\r\n==167517==    by 0x489042A: opj_image_data_alloc (openjpeg.c:1135)\r\n==167517==    by 0x48BADF0: opj_alloc_tile_component_data (tcd.c:765)\r\n==167517==    by 0x48BD265: opj_tcd_decode_tile (tcd.c:1629)\r\n==167517==    by 0x487DA54: opj_j2k_decode_tile (j2k.c:9887)\r\n==167517==    by 0x48825E1: opj_j2k_decode_tiles (j2k.c:11733)\r\n==167517==    by 0x487BA3F: opj_j2k_exec (j2k.c:9031)\r\n==167517==    by 0x48831C4: opj_j2k_decode (j2k.c:12036)\r\n==167517==    by 0x488F6E8: opj_decode (openjpeg.c:526)\r\n==167517== \r\n```",
      "Is there a plan to release v2.5.1 with the fix anytime soon?",
      "> Is there a plan to release v2.5.1 with the fix anytime soon?\r\n\r\nyes, as indicated on the mailing list : https://groups.google.com/g/openjpeg/c/Mrz0Zeo79WY\r\n\"I'll hope to tackle soon a 2.5.1 release. Use that as a signal to test\r\nmaster and report any regression, or if there are changes that need to\r\ngo in it, be sure to provide pull requests soon \""
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}