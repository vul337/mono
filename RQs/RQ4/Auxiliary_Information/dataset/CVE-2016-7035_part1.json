{
  "cve_id": "CVE-2016-7035",
  "cwe_ids": [
    "CWE-285"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "ClusterLabs/pacemaker",
  "commit_msg": "High: libcrmcommon: fix CVE-2016-7035 (improper IPC guarding)\n\nIt was discovered that at some not so uncommon circumstances, some\npacemaker daemons could be talked to, via libqb-facilitated IPC, by\nunprivileged clients due to flawed authorization decision.  Depending\non the capabilities of affected daemons, this might equip unauthorized\nuser with local privilege escalation or up to cluster-wide remote\nexecution of possibly arbitrary commands when such user happens to\nreside at standard or remote/guest cluster node, respectively.\n\nThe original vulnerability was introduced in an attempt to allow\nunprivileged IPC clients to clean up the file system materialized\nleftovers in case the server (otherwise responsible for the lifecycle\nof these files) crashes.  While the intended part of such behavior is\nnow effectively voided (along with the unintended one), a best-effort\nfix to address this corner case systemically at libqb is coming along\n(https://github.com/ClusterLabs/libqb/pull/231).\n\nAffected versions:  1.1.10-rc1 (2013-04-17) - 1.1.15 (2016-06-21)\nImpact:             Important\nCVSSv3 ranking:     8.8 : AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H\n\nCredits for independent findings, in chronological order:\n  Jan \"poki\" Pokorn√Ω, of Red Hat\n  Alain Moulle, of ATOS/BULL",
  "commit_hash": "5d71e65049",
  "git_url": "https://github.com/ClusterLabs/pacemaker/commit/5d71e65049d143435b03d6b3709d82900f32276f",
  "file_path": "lib/common/ipc.c",
  "func_name": "crm_client_new",
  "func_before": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n{\n    static uid_t uid_server = 0;\n    static gid_t gid_cluster = 0;\n\n    crm_client_t *client = NULL;\n\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    if (gid_cluster == 0) {\n        uid_server = getuid();\n        if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n            static bool have_error = FALSE;\n            if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n        }\n    }\n\n    if(gid_cluster != 0 && gid_client != 0) {\n        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n\n        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n            best_uid = QB_MAX(uid_client, uid_server);\n            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n        }\n\n        crm_trace(\"Giving access to group %u\", gid_cluster);\n        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    crm_client_init();\n\n    /* TODO: Do our own auth checking, return NULL if unauthorized */\n    client = calloc(1, sizeof(crm_client_t));\n\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n\n    client->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}",
  "abstract_func_before": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * VAR_0, uid_t VAR_1, gid_t VAR_2)\n{\n    static uid_t VAR_3 = 0;\n    static gid_t VAR_4 = 0;\n\n    crm_client_t *VAR_5 = NULL;\n\n    CRM_LOG_ASSERT(VAR_0);\n    if (VAR_0 == NULL) {\n        return NULL;\n    }\n\n    if (VAR_4 == 0) {\n        VAR_3 = getuid();\n        if(crm_user_lookup(VAR_6, NULL, &VAR_4) < 0) {\n            static bool VAR_7 = FALSE;\n            if(VAR_7 == FALSE) {\n                crm_warn(\"Could not find group for user %s\", VAR_6);\n                VAR_7 = TRUE;\n            }\n        }\n    }\n\n    if(VAR_4 != 0 && VAR_2 != 0) {\n        uid_t VAR_8 = -1; /* COMMENT_0 */\n\n        if(VAR_1 == 0 || VAR_3 == 0) { /* COMMENT_1 */\n            VAR_8 = QB_MAX(VAR_1, VAR_3);\n            crm_trace(\"Allowing user %u to clean up after disconnect\", VAR_8);\n        }\n\n        crm_trace(\"Giving access to group %u\", VAR_4);\n        qb_ipcs_connection_auth_set(VAR_0, VAR_8, VAR_4, VAR_9 | VAR_10 | VAR_11 | VAR_12);\n    }\n\n    crm_client_init();\n\n    /* COMMENT_2 */\n    VAR_5 = calloc(1, sizeof(crm_client_t));\n\n    VAR_5->ipcs = VAR_0;\n    VAR_5->kind = VAR_13;\n    VAR_5->pid = crm_ipcs_client_pid(VAR_0);\n\n    VAR_5->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", VAR_0, VAR_1, VAR_2, VAR_5->pid, VAR_5->id);\n\n#if VAR_14\n    VAR_5->user = uid2username(VAR_1);\n#endif\n\n    g_hash_table_insert(VAR_15, VAR_0, VAR_5);\n    return VAR_5;\n}",
  "func_graph_path_before": "ClusterLabs/pacemaker/5d71e65049/ipc.c/vul/before/0.json",
  "func": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n{\n    static gid_t gid_cluster = 0;\n\n    crm_client_t *client = NULL;\n\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    if (gid_cluster == 0) {\n        if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n            static bool have_error = FALSE;\n            if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n        }\n    }\n\n    if (uid_client != 0) {\n        crm_trace(\"Giving access to group %u\", gid_cluster);\n        /* Passing -1 to chown(2) means don't change */\n        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    crm_client_init();\n\n    /* TODO: Do our own auth checking, return NULL if unauthorized */\n    client = calloc(1, sizeof(crm_client_t));\n\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n\n    client->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}",
  "abstract_func": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * VAR_0, uid_t VAR_1, gid_t VAR_2)\n{\n    static gid_t VAR_3 = 0;\n\n    crm_client_t *VAR_4 = NULL;\n\n    CRM_LOG_ASSERT(VAR_0);\n    if (VAR_0 == NULL) {\n        return NULL;\n    }\n\n    if (VAR_3 == 0) {\n        if(crm_user_lookup(VAR_5, NULL, &VAR_3) < 0) {\n            static bool VAR_6 = FALSE;\n            if(VAR_6 == FALSE) {\n                crm_warn(\"Could not find group for user %s\", VAR_5);\n                VAR_6 = TRUE;\n            }\n        }\n    }\n\n    if (VAR_1 != 0) {\n        crm_trace(\"Giving access to group %u\", VAR_3);\n        /* COMMENT_0 */\n        qb_ipcs_connection_auth_set(VAR_0, -1, VAR_3, VAR_7 | VAR_8 | VAR_9 | VAR_10);\n    }\n\n    crm_client_init();\n\n    /* COMMENT_1 */\n    VAR_4 = calloc(1, sizeof(crm_client_t));\n\n    VAR_4->ipcs = VAR_0;\n    VAR_4->kind = VAR_11;\n    VAR_4->pid = crm_ipcs_client_pid(VAR_0);\n\n    VAR_4->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", VAR_0, VAR_1, VAR_2, VAR_4->pid, VAR_4->id);\n\n#if VAR_12\n    VAR_4->user = uid2username(VAR_1);\n#endif\n\n    g_hash_table_insert(VAR_13, VAR_0, VAR_4);\n    return VAR_4;\n}",
  "func_graph_path": "ClusterLabs/pacemaker/5d71e65049/ipc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,6 @@\n crm_client_t *\n crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n {\n-    static uid_t uid_server = 0;\n     static gid_t gid_cluster = 0;\n \n     crm_client_t *client = NULL;\n@@ -12,7 +11,6 @@\n     }\n \n     if (gid_cluster == 0) {\n-        uid_server = getuid();\n         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n             static bool have_error = FALSE;\n             if(have_error == FALSE) {\n@@ -22,16 +20,10 @@\n         }\n     }\n \n-    if(gid_cluster != 0 && gid_client != 0) {\n-        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n-\n-        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n-            best_uid = QB_MAX(uid_client, uid_server);\n-            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n-        }\n-\n+    if (uid_client != 0) {\n         crm_trace(\"Giving access to group %u\", gid_cluster);\n-        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n+        /* Passing -1 to chown(2) means don't change */\n+        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n     }\n \n     crm_client_init();",
  "diff_line_info": {
    "deleted_lines": [
      "    static uid_t uid_server = 0;",
      "        uid_server = getuid();",
      "    if(gid_cluster != 0 && gid_client != 0) {",
      "        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */",
      "",
      "        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */",
      "            best_uid = QB_MAX(uid_client, uid_server);",
      "            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);",
      "        }",
      "",
      "        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);"
    ],
    "added_lines": [
      "    if (uid_client != 0) {",
      "        /* Passing -1 to chown(2) means don't change */",
      "        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ClusterLabs/pacemaker/pull/1166",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/ClusterLabs/pacemaker/pull/1166: 403 Client Error: Forbidden for url: https://api.github.com/repos/ClusterLabs/pacemaker/pulls/1166",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit message references a CVE (CVE-2016-7035), describes a security issue with IPC authorization, and the code changes fix the vulnerability by adjusting IPC permissions to prevent unauthorized access. All elements align clearly with a security fix."
}