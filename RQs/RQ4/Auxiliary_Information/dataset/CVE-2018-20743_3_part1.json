{
  "cve_id": "CVE-2018-20743",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "mumble-voip/mumble",
  "commit_msg": "Prevent instability and crash due to message flood\n\nThis patch adds a rate limiting to selected patches. The underlying rate limiter\nused is the Leaky-Bucket algorithm. It allows for a burst of messages, but\nlimits them after a specified amount of messages within a time frame.",
  "commit_hash": "0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "git_url": "https://github.com/mumble-voip/mumble/commit/0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "file_path": "src/murmur/Messages.cpp",
  "func_name": "Server::msgTextMessage",
  "func_before": "void Server::msgTextMessage(ServerUser *uSource, MumbleProto::TextMessage &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tQMutexLocker qml(&qmCache);\n\n\tTextMessage tm; // for signal userTextMessage\n\n\tQSet<ServerUser *> users;\n\tQQueue<Channel *> q;\n\n\tint res = 0;\n\temit textMessageFilterSig(res, uSource, msg);\n\tswitch (res) {\n\t\t// Accept\n\t\tcase 0:\n\t\t\t// No-op.\n\t\t\tbreak;\n\t\t// Reject\n\t\tcase 1:\n\t\t\tPERM_DENIED(uSource, uSource->cChannel, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t// Drop\n\t\tcase 2:\n\t\t\treturn;\n\t}\n\n\tQString text = u8(msg.message());\n\tbool changed = false;\n\n\tif (! isTextAllowed(text, changed)) {\n\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\treturn;\n\t}\n\tif (text.isEmpty())\n\t\treturn;\n\tif (changed)\n\t\tmsg.set_message(u8(text));\n\n\ttm.qsText = text;\n\n\t{ // Happy easter\n\t\tchar m[29] = {0117, 0160, 0145, 0156, 040, 0164, 0150, 0145, 040, 0160, 0157, 0144, 040, 0142, 0141, 0171, 040, 0144, 0157, 0157, 0162, 0163, 054, 040, 0110, 0101, 0114, 056, 0};\n\t\tif (msg.channel_id_size() == 1 && msg.channel_id(0) == 0 && msg.message() == m) {\n\t\t\tPERM_DENIED_TYPE(H9K);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmsg.set_actor(uSource->uiSession);\n\tfor (int i=0;i<msg.channel_id_size(); ++i) {\n\t\tunsigned int id = msg.channel_id(i);\n\n\t\tChannel *c = qhChannels.value(id);\n\t\tif (! c)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, c, ChanACL::TextMessage, &acCache)) {\n\t\t\tPERM_DENIED(uSource, c, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tforeach(User *p, c->qlUsers)\n\t\t\tusers.insert(static_cast<ServerUser *>(p));\n\n\t\ttm.qlChannels.append(id);\n\t}\n\n\tfor (int i=0;i<msg.tree_id_size(); ++i) {\n\t\tunsigned int id = msg.tree_id(i);\n\n\t\tChannel *c = qhChannels.value(id);\n\t\tif (! c)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, c, ChanACL::TextMessage, &acCache)) {\n\t\t\tPERM_DENIED(uSource, c, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tq.enqueue(c);\n\n\t\ttm.qlTrees.append(id);\n\t}\n\n\twhile (! q.isEmpty()) {\n\t\tChannel *c = q.dequeue();\n\t\tif (ChanACL::hasPermission(uSource, c, ChanACL::TextMessage, &acCache)) {\n\t\t\tforeach(Channel *sub, c->qlChannels)\n\t\t\t\tq.enqueue(sub);\n\t\t\tforeach(User *p, c->qlUsers)\n\t\t\t\tusers.insert(static_cast<ServerUser *>(p));\n\t\t}\n\t}\n\n\tfor (int i=0;i < msg.session_size(); ++i) {\n\t\tunsigned int session = msg.session(i);\n\t\tServerUser *u = qhUsers.value(session);\n\t\tif (u) {\n\t\t\tif (! ChanACL::hasPermission(uSource, u->cChannel, ChanACL::TextMessage, &acCache)) {\n\t\t\t\tPERM_DENIED(uSource, u->cChannel, ChanACL::TextMessage);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusers.insert(u);\n\t\t}\n\n\t\ttm.qlSessions.append(session);\n\t}\n\n\tusers.remove(uSource);\n\n\tforeach(ServerUser *u, users)\n\t\tsendMessage(u, msg);\n\n\temit userTextMessage(uSource, tm);\n}",
  "abstract_func_before": "void Server::msgTextMessage(ServerUser *VAR_0, MumbleProto::TextMessage &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tQMutexLocker VAR_2(&VAR_3);\n\n\tTextMessage VAR_4; /* COMMENT_0 */\n\n\tQSet<ServerUser *> VAR_5;\n\tQQueue<Channel *> VAR_6;\n\n\tint VAR_7 = 0;\n\temit textMessageFilterSig(res, uSource, msg);\n\tswitch (res) {\n\t\t/* COMMENT_1 */\n\t\tcase 0:\n\t\t\t/* COMMENT_2 */\n\t\t\tbreak;\n\t\t/* COMMENT_3 */\n\t\tcase 1:\n\t\t\tPERM_DENIED(uSource, uSource->cChannel, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t/* COMMENT_4 */\n\t\tcase 2:\n\t\t\treturn;\n\t}\n\n\tQString VAR_8 = u8(msg.message());\n\tbool VAR_9 = false;\n\n\tif (! isTextAllowed(VAR_8, VAR_9)) {\n\t\tPERM_DENIED_TYPE(VAR_10);\n\t\treturn;\n\t}\n\tif (VAR_8.isEmpty())\n\t\treturn;\n\tif (VAR_9)\n\t\tmsg.set_message(u8(VAR_8));\n\n\tVAR_4.qsText = VAR_8;\n\n\t{ /* COMMENT_5 */\n\t\tchar VAR_11[29] = {0117, 0160, 0145, 0156, 040, 0164, 0150, 0145, 040, 0160, 0157, 0144, 040, 0142, 0141, 0171, 040, 0144, 0157, 0157, 0162, 0163, 054, 040, 0110, 0101, 0114, 056, 0};\n\t\tif (msg.channel_id_size() == 1 && msg.channel_id(0) == 0 && msg.message() == VAR_11) {\n\t\t\tPERM_DENIED_TYPE(VAR_12);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmsg.set_actor(uSource->uiSession);\n\tfor (int VAR_13=0;VAR_13<msg.channel_id_size(); ++VAR_13) {\n\t\tunsigned int VAR_14 = msg.channel_id(VAR_13);\n\n\t\tChannel *VAR_15 = VAR_16.value(VAR_14);\n\t\tif (! VAR_15)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, VAR_15, ChanACL::TextMessage, &VAR_17)) {\n\t\t\tPERM_DENIED(uSource, VAR_15, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tforeach(VAR_18 *VAR_19, VAR_15->qlUsers)\n\t\t\tVAR_5.insert(VAR_20<ServerUser *>(VAR_19));\n\n\t\tVAR_4.qlChannels.append(VAR_14);\n\t}\n\n\tfor (int VAR_13=0;VAR_13<msg.tree_id_size(); ++VAR_13) {\n\t\tunsigned int VAR_14 = msg.tree_id(VAR_13);\n\n\t\tChannel *VAR_15 = VAR_16.value(VAR_14);\n\t\tif (! VAR_15)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, VAR_15, ChanACL::TextMessage, &VAR_17)) {\n\t\t\tPERM_DENIED(uSource, VAR_15, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tVAR_6.enqueue(VAR_15);\n\n\t\tVAR_4.qlTrees.append(VAR_14);\n\t}\n\n\twhile (! VAR_6.isEmpty()) {\n\t\tChannel *VAR_15 = VAR_6.dequeue();\n\t\tif (ChanACL::hasPermission(uSource, VAR_15, ChanACL::TextMessage, &VAR_17)) {\n\t\t\tforeach(Channel *VAR_21, VAR_15->qlChannels)\n\t\t\t\tVAR_6.enqueue(VAR_21);\n\t\t\tforeach(VAR_18 *VAR_19, VAR_15->qlUsers)\n\t\t\t\tVAR_5.insert(VAR_20<ServerUser *>(VAR_19));\n\t\t}\n\t}\n\n\tfor (int VAR_13=0;VAR_13 < msg.session_size(); ++VAR_13) {\n\t\tunsigned int VAR_22 = msg.session(VAR_13);\n\t\tServerUser *VAR_23 = VAR_24.value(VAR_22);\n\t\tif (VAR_23) {\n\t\t\tif (! ChanACL::hasPermission(uSource, VAR_23->cChannel, ChanACL::TextMessage, &VAR_17)) {\n\t\t\t\tPERM_DENIED(uSource, VAR_23->cChannel, ChanACL::TextMessage);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tVAR_5.insert(VAR_23);\n\t\t}\n\n\t\tVAR_4.qlSessions.append(VAR_22);\n\t}\n\n\tVAR_5.remove(uSource);\n\n\tforeach(ServerUser *VAR_23, users)\n\t\tsendMessage(VAR_23, msg);\n\n\temit userTextMessage(uSource, tm);\n}",
  "func_graph_path_before": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/before/4.json",
  "func": "void Server::msgTextMessage(ServerUser *uSource, MumbleProto::TextMessage &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tQMutexLocker qml(&qmCache);\n\n\tTextMessage tm; // for signal userTextMessage\n\n\tQSet<ServerUser *> users;\n\tQQueue<Channel *> q;\n\n\tRATELIMIT(uSource);\n\n\tint res = 0;\n\temit textMessageFilterSig(res, uSource, msg);\n\tswitch (res) {\n\t\t// Accept\n\t\tcase 0:\n\t\t\t// No-op.\n\t\t\tbreak;\n\t\t// Reject\n\t\tcase 1:\n\t\t\tPERM_DENIED(uSource, uSource->cChannel, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t// Drop\n\t\tcase 2:\n\t\t\treturn;\n\t}\n\n\tQString text = u8(msg.message());\n\tbool changed = false;\n\n\tif (! isTextAllowed(text, changed)) {\n\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\treturn;\n\t}\n\tif (text.isEmpty())\n\t\treturn;\n\tif (changed)\n\t\tmsg.set_message(u8(text));\n\n\ttm.qsText = text;\n\n\t{ // Happy easter\n\t\tchar m[29] = {0117, 0160, 0145, 0156, 040, 0164, 0150, 0145, 040, 0160, 0157, 0144, 040, 0142, 0141, 0171, 040, 0144, 0157, 0157, 0162, 0163, 054, 040, 0110, 0101, 0114, 056, 0};\n\t\tif (msg.channel_id_size() == 1 && msg.channel_id(0) == 0 && msg.message() == m) {\n\t\t\tPERM_DENIED_TYPE(H9K);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmsg.set_actor(uSource->uiSession);\n\tfor (int i=0;i<msg.channel_id_size(); ++i) {\n\t\tunsigned int id = msg.channel_id(i);\n\n\t\tChannel *c = qhChannels.value(id);\n\t\tif (! c)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, c, ChanACL::TextMessage, &acCache)) {\n\t\t\tPERM_DENIED(uSource, c, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tforeach(User *p, c->qlUsers)\n\t\t\tusers.insert(static_cast<ServerUser *>(p));\n\n\t\ttm.qlChannels.append(id);\n\t}\n\n\tfor (int i=0;i<msg.tree_id_size(); ++i) {\n\t\tunsigned int id = msg.tree_id(i);\n\n\t\tChannel *c = qhChannels.value(id);\n\t\tif (! c)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, c, ChanACL::TextMessage, &acCache)) {\n\t\t\tPERM_DENIED(uSource, c, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tq.enqueue(c);\n\n\t\ttm.qlTrees.append(id);\n\t}\n\n\twhile (! q.isEmpty()) {\n\t\tChannel *c = q.dequeue();\n\t\tif (ChanACL::hasPermission(uSource, c, ChanACL::TextMessage, &acCache)) {\n\t\t\tforeach(Channel *sub, c->qlChannels)\n\t\t\t\tq.enqueue(sub);\n\t\t\tforeach(User *p, c->qlUsers)\n\t\t\t\tusers.insert(static_cast<ServerUser *>(p));\n\t\t}\n\t}\n\n\tfor (int i=0;i < msg.session_size(); ++i) {\n\t\tunsigned int session = msg.session(i);\n\t\tServerUser *u = qhUsers.value(session);\n\t\tif (u) {\n\t\t\tif (! ChanACL::hasPermission(uSource, u->cChannel, ChanACL::TextMessage, &acCache)) {\n\t\t\t\tPERM_DENIED(uSource, u->cChannel, ChanACL::TextMessage);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusers.insert(u);\n\t\t}\n\n\t\ttm.qlSessions.append(session);\n\t}\n\n\tusers.remove(uSource);\n\n\tforeach(ServerUser *u, users)\n\t\tsendMessage(u, msg);\n\n\temit userTextMessage(uSource, tm);\n}",
  "abstract_func": "void Server::msgTextMessage(ServerUser *VAR_0, MumbleProto::TextMessage &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tQMutexLocker VAR_2(&VAR_3);\n\n\tTextMessage VAR_4; /* COMMENT_0 */\n\n\tQSet<ServerUser *> VAR_5;\n\tQQueue<Channel *> VAR_6;\n\n\tRATELIMIT(VAR_0);\n\n\tint VAR_7 = 0;\n\temit textMessageFilterSig(res, uSource, msg);\n\tswitch (res) {\n\t\t/* COMMENT_1 */\n\t\tcase 0:\n\t\t\t/* COMMENT_2 */\n\t\t\tbreak;\n\t\t/* COMMENT_3 */\n\t\tcase 1:\n\t\t\tPERM_DENIED(uSource, uSource->cChannel, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t/* COMMENT_4 */\n\t\tcase 2:\n\t\t\treturn;\n\t}\n\n\tQString VAR_8 = u8(msg.message());\n\tbool VAR_9 = false;\n\n\tif (! isTextAllowed(VAR_8, VAR_9)) {\n\t\tPERM_DENIED_TYPE(VAR_10);\n\t\treturn;\n\t}\n\tif (VAR_8.isEmpty())\n\t\treturn;\n\tif (VAR_9)\n\t\tmsg.set_message(u8(VAR_8));\n\n\tVAR_4.qsText = VAR_8;\n\n\t{ /* COMMENT_5 */\n\t\tchar VAR_11[29] = {0117, 0160, 0145, 0156, 040, 0164, 0150, 0145, 040, 0160, 0157, 0144, 040, 0142, 0141, 0171, 040, 0144, 0157, 0157, 0162, 0163, 054, 040, 0110, 0101, 0114, 056, 0};\n\t\tif (msg.channel_id_size() == 1 && msg.channel_id(0) == 0 && msg.message() == VAR_11) {\n\t\t\tPERM_DENIED_TYPE(VAR_12);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmsg.set_actor(uSource->uiSession);\n\tfor (int VAR_13=0;VAR_13<msg.channel_id_size(); ++VAR_13) {\n\t\tunsigned int VAR_14 = msg.channel_id(VAR_13);\n\n\t\tChannel *VAR_15 = VAR_16.value(VAR_14);\n\t\tif (! VAR_15)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, VAR_15, ChanACL::TextMessage, &VAR_17)) {\n\t\t\tPERM_DENIED(uSource, VAR_15, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tforeach(VAR_18 *VAR_19, VAR_15->qlUsers)\n\t\t\tVAR_5.insert(VAR_20<ServerUser *>(VAR_19));\n\n\t\tVAR_4.qlChannels.append(VAR_14);\n\t}\n\n\tfor (int VAR_13=0;VAR_13<msg.tree_id_size(); ++VAR_13) {\n\t\tunsigned int VAR_14 = msg.tree_id(VAR_13);\n\n\t\tChannel *VAR_15 = VAR_16.value(VAR_14);\n\t\tif (! VAR_15)\n\t\t\treturn;\n\n\t\tif (! ChanACL::hasPermission(uSource, VAR_15, ChanACL::TextMessage, &VAR_17)) {\n\t\t\tPERM_DENIED(uSource, VAR_15, ChanACL::TextMessage);\n\t\t\treturn;\n\t\t}\n\n\t\tVAR_6.enqueue(VAR_15);\n\n\t\tVAR_4.qlTrees.append(VAR_14);\n\t}\n\n\twhile (! VAR_6.isEmpty()) {\n\t\tChannel *VAR_15 = VAR_6.dequeue();\n\t\tif (ChanACL::hasPermission(uSource, VAR_15, ChanACL::TextMessage, &VAR_17)) {\n\t\t\tforeach(Channel *VAR_21, VAR_15->qlChannels)\n\t\t\t\tVAR_6.enqueue(VAR_21);\n\t\t\tforeach(VAR_18 *VAR_19, VAR_15->qlUsers)\n\t\t\t\tVAR_5.insert(VAR_20<ServerUser *>(VAR_19));\n\t\t}\n\t}\n\n\tfor (int VAR_13=0;VAR_13 < msg.session_size(); ++VAR_13) {\n\t\tunsigned int VAR_22 = msg.session(VAR_13);\n\t\tServerUser *VAR_23 = VAR_24.value(VAR_22);\n\t\tif (VAR_23) {\n\t\t\tif (! ChanACL::hasPermission(uSource, VAR_23->cChannel, ChanACL::TextMessage, &VAR_17)) {\n\t\t\t\tPERM_DENIED(uSource, VAR_23->cChannel, ChanACL::TextMessage);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tVAR_5.insert(VAR_23);\n\t\t}\n\n\t\tVAR_4.qlSessions.append(VAR_22);\n\t}\n\n\tVAR_5.remove(uSource);\n\n\tforeach(ServerUser *VAR_23, users)\n\t\tsendMessage(VAR_23, msg);\n\n\temit userTextMessage(uSource, tm);\n}",
  "func_graph_path": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,8 @@\n \n \tQSet<ServerUser *> users;\n \tQQueue<Channel *> q;\n+\n+\tRATELIMIT(uSource);\n \n \tint res = 0;\n \temit textMessageFilterSig(res, uSource, msg);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\tRATELIMIT(uSource);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mumble-voip/mumble/pull/3510",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/mumble-voip/mumble/pull/3510: 403 Client Error: Forbidden for url: https://api.github.com/repos/mumble-voip/mumble/pulls/3510",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nStep-by-step explanation:  \n1. **Purpose Evaluation:** The patch addresses an instability caused by message floods, using a rate limiter.  \n2. **Security Vulnerability Assessment:** Prevents server crashes due to excessive messages, indicating a security fix against a denial-of-service scenario.  \n3. **Code Consistency:** The added rate limit directly affects message handling, aligning with the vulnerability description.  \n\nThis is a clear security fix, hence the high confidence score."
}