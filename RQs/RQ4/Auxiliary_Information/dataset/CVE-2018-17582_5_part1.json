{
  "cve_id": "CVE-2018-17582",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files\n\n* Check for packets that are larger than 262144 bytes\n* Check for capture lengths that are greater than packet length\n\nExample of a corrupt PCAP file ...\n\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144",
  "commit_hash": "68f67b1a3a4d319543692afb5bd5b191ec984287",
  "git_url": "https://github.com/appneta/tcpreplay/commit/68f67b1a3a4d319543692afb5bd5b191ec984287",
  "file_path": "src/send_packets.c",
  "func_name": "get_next_packet",
  "func_before": "u_char *\nget_next_packet(tcpreplay_t *ctx, pcap_t *pcap, struct pcap_pkthdr *pkthdr, int idx, \n    packet_cache_t **prev_packet)\n{\n    tcpreplay_opt_t *options = ctx->options;\n    u_char *pktdata = NULL;\n    uint32_t pktlen;\n\n    /* pcap may be null in cache mode! */\n    /* packet_cache_t may be null in file read mode! */\n    assert(pkthdr);\n\n    /*\n     * Check if we're caching files\n     */\n    if (options->preload_pcap && (prev_packet != NULL)) {\n        /*\n         * Yes we are caching files - has this one been cached?\n         */\n        if (options->file_cache[idx].cached) {\n            if (*prev_packet == NULL) {\n                /*\n                 * Get the first packet in the cache list directly from the file\n                 */\n                *prev_packet = options->file_cache[idx].packet_cache;\n            } else {\n                /*\n                 * Get the next packet in the cache list\n                 */\n                *prev_packet = (*prev_packet)->next;\n            }\n\n            if (*prev_packet != NULL) {\n                pktdata = (*prev_packet)->pktdata;\n                memcpy(pkthdr, &((*prev_packet)->pkthdr), sizeof(struct pcap_pkthdr));\n            }\n        } else {\n            /*\n             * We should read the pcap file, and cache the results\n             */\n            pktdata = (u_char *)pcap_next(pcap, pkthdr);\n            if (pktdata != NULL) {\n                if (*prev_packet == NULL) {\n                    /*\n                     * Create the first packet in the list\n                     */\n                    *prev_packet = safe_malloc(sizeof(packet_cache_t));\n                    options->file_cache[idx].packet_cache = *prev_packet;\n                } else {\n                    /*\n                     * Add a packet to the end of the list\n                     */\n                    (*prev_packet)->next = safe_malloc(sizeof(packet_cache_t));\n                    *prev_packet = (*prev_packet)->next;\n                }\n\n                if (*prev_packet != NULL) {\n                    (*prev_packet)->next = NULL;\n                    pktlen = pkthdr->len;\n\n                    (*prev_packet)->pktdata = safe_malloc(pktlen);\n                    memcpy((*prev_packet)->pktdata, pktdata, pktlen);\n                    memcpy(&((*prev_packet)->pkthdr), pkthdr, sizeof(struct pcap_pkthdr));\n                }\n            }\n        }\n    } else {\n        /*\n         * Read pcap file as normal\n         */\n        pktdata = (u_char *)pcap_next(pcap, pkthdr);\n    }\n\n    /* this get's casted to a const on the way out */\n    return pktdata;\n}",
  "abstract_func_before": "u_char *\nget_next_packet(tcpreplay_t *VAR_0, pcap_t *VAR_1, struct pcap_pkthdr *VAR_2, int VAR_3, \n    packet_cache_t **VAR_4)\n{\n    tcpreplay_opt_t *VAR_5 = VAR_0->options;\n    u_char *VAR_6 = NULL;\n    uint32_t VAR_7;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    assert(VAR_2);\n\n    /* COMMENT_2 */\n                                   \n       \n    if (VAR_5->preload_pcap && (VAR_4 != NULL)) {\n        /* COMMENT_5 */\n                                                               \n           \n        if (VAR_5->file_cache[VAR_3].cached) {\n            if (*VAR_4 == NULL) {\n                /* COMMENT_8 */\n                                                                                \n                   \n                *VAR_4 = VAR_5->file_cache[VAR_3].packet_cache;\n            } else {\n                /* COMMENT_11 */\n                                                        \n                   \n                *VAR_4 = (*VAR_4)->next;\n            }\n\n            if (*VAR_4 != NULL) {\n                VAR_6 = (*VAR_4)->pktdata;\n                memcpy(VAR_2, &((*VAR_4)->pkthdr), sizeof(struct pcap_pkthdr));\n            }\n        } else {\n            /* COMMENT_14 */\n                                                                  \n               \n            VAR_6 = (u_char *)pcap_next(VAR_1, VAR_2);\n            if (VAR_6 != NULL) {\n                if (*VAR_4 == NULL) {\n                    /* COMMENT_17 */\n                                                          \n                       \n                    *VAR_4 = safe_malloc(sizeof(packet_cache_t));\n                    VAR_5->file_cache[VAR_3].packet_cache = *VAR_4;\n                } else {\n                    /* COMMENT_20 */\n                                                          \n                       \n                    (*VAR_4)->next = safe_malloc(sizeof(packet_cache_t));\n                    *VAR_4 = (*VAR_4)->next;\n                }\n\n                if (*VAR_4 != NULL) {\n                    (*VAR_4)->next = NULL;\n                    VAR_7 = VAR_2->len;\n\n                    (*VAR_4)->pktdata = safe_malloc(VAR_7);\n                    memcpy((*VAR_4)->pktdata, VAR_6, VAR_7);\n                    memcpy(&((*VAR_4)->pkthdr), VAR_2, sizeof(struct pcap_pkthdr));\n                }\n            }\n        }\n    } else {\n        /* COMMENT_23 */\n                                   \n           \n        VAR_6 = (u_char *)pcap_next(VAR_1, VAR_2);\n    }\n\n    /* COMMENT_26 */\n    return VAR_6;\n}",
  "func_graph_path_before": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/send_packets.c/vul/before/0.json",
  "func": "u_char *\nget_next_packet(tcpreplay_t *ctx, pcap_t *pcap, struct pcap_pkthdr *pkthdr, int idx, \n    packet_cache_t **prev_packet)\n{\n    tcpreplay_opt_t *options = ctx->options;\n    u_char *pktdata = NULL;\n    uint32_t pktlen;\n\n    /* pcap may be null in cache mode! */\n    /* packet_cache_t may be null in file read mode! */\n    assert(pkthdr);\n\n    /*\n     * Check if we're caching files\n     */\n    if (options->preload_pcap && (prev_packet != NULL)) {\n        /*\n         * Yes we are caching files - has this one been cached?\n         */\n        if (options->file_cache[idx].cached) {\n            if (*prev_packet == NULL) {\n                /*\n                 * Get the first packet in the cache list directly from the file\n                 */\n                *prev_packet = options->file_cache[idx].packet_cache;\n            } else {\n                /*\n                 * Get the next packet in the cache list\n                 */\n                *prev_packet = (*prev_packet)->next;\n            }\n\n            if (*prev_packet != NULL) {\n                pktdata = (*prev_packet)->pktdata;\n                memcpy(pkthdr, &((*prev_packet)->pkthdr), sizeof(struct pcap_pkthdr));\n            }\n        } else {\n            /*\n             * We should read the pcap file, and cache the results\n             */\n            pktdata = safe_pcap_next(pcap, pkthdr);\n            if (pktdata != NULL) {\n                if (*prev_packet == NULL) {\n                    /*\n                     * Create the first packet in the list\n                     */\n                    *prev_packet = safe_malloc(sizeof(packet_cache_t));\n                    options->file_cache[idx].packet_cache = *prev_packet;\n                } else {\n                    /*\n                     * Add a packet to the end of the list\n                     */\n                    (*prev_packet)->next = safe_malloc(sizeof(packet_cache_t));\n                    *prev_packet = (*prev_packet)->next;\n                }\n\n                if (*prev_packet != NULL) {\n                    (*prev_packet)->next = NULL;\n                    pktlen = pkthdr->len;\n\n                    (*prev_packet)->pktdata = safe_malloc(pktlen);\n                    memcpy((*prev_packet)->pktdata, pktdata, pktlen);\n                    memcpy(&((*prev_packet)->pkthdr), pkthdr, sizeof(struct pcap_pkthdr));\n                }\n            }\n        }\n    } else {\n        /*\n         * Read pcap file as normal\n         */\n        pktdata = safe_pcap_next(pcap, pkthdr);\n    }\n\n    /* this get's casted to a const on the way out */\n    return pktdata;\n}",
  "abstract_func": "u_char *\nget_next_packet(tcpreplay_t *VAR_0, pcap_t *VAR_1, struct pcap_pkthdr *VAR_2, int VAR_3, \n    packet_cache_t **VAR_4)\n{\n    tcpreplay_opt_t *VAR_5 = VAR_0->options;\n    u_char *VAR_6 = NULL;\n    uint32_t VAR_7;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    assert(VAR_2);\n\n    /* COMMENT_2 */\n                                   \n       \n    if (VAR_5->preload_pcap && (VAR_4 != NULL)) {\n        /* COMMENT_5 */\n                                                               \n           \n        if (VAR_5->file_cache[VAR_3].cached) {\n            if (*VAR_4 == NULL) {\n                /* COMMENT_8 */\n                                                                                \n                   \n                *VAR_4 = VAR_5->file_cache[VAR_3].packet_cache;\n            } else {\n                /* COMMENT_11 */\n                                                        \n                   \n                *VAR_4 = (*VAR_4)->next;\n            }\n\n            if (*VAR_4 != NULL) {\n                VAR_6 = (*VAR_4)->pktdata;\n                memcpy(VAR_2, &((*VAR_4)->pkthdr), sizeof(struct pcap_pkthdr));\n            }\n        } else {\n            /* COMMENT_14 */\n                                                                  \n               \n            VAR_6 = safe_pcap_next(VAR_1, VAR_2);\n            if (VAR_6 != NULL) {\n                if (*VAR_4 == NULL) {\n                    /* COMMENT_17 */\n                                                          \n                       \n                    *VAR_4 = safe_malloc(sizeof(packet_cache_t));\n                    VAR_5->file_cache[VAR_3].packet_cache = *VAR_4;\n                } else {\n                    /* COMMENT_20 */\n                                                          \n                       \n                    (*VAR_4)->next = safe_malloc(sizeof(packet_cache_t));\n                    *VAR_4 = (*VAR_4)->next;\n                }\n\n                if (*VAR_4 != NULL) {\n                    (*VAR_4)->next = NULL;\n                    VAR_7 = VAR_2->len;\n\n                    (*VAR_4)->pktdata = safe_malloc(VAR_7);\n                    memcpy((*VAR_4)->pktdata, VAR_6, VAR_7);\n                    memcpy(&((*VAR_4)->pkthdr), VAR_2, sizeof(struct pcap_pkthdr));\n                }\n            }\n        }\n    } else {\n        /* COMMENT_23 */\n                                   \n           \n        VAR_6 = safe_pcap_next(VAR_1, VAR_2);\n    }\n\n    /* COMMENT_26 */\n    return VAR_6;\n}",
  "func_graph_path": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/send_packets.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,7 +38,7 @@\n             /*\n              * We should read the pcap file, and cache the results\n              */\n-            pktdata = (u_char *)pcap_next(pcap, pkthdr);\n+            pktdata = safe_pcap_next(pcap, pkthdr);\n             if (pktdata != NULL) {\n                 if (*prev_packet == NULL) {\n                     /*\n@@ -68,7 +68,7 @@\n         /*\n          * Read pcap file as normal\n          */\n-        pktdata = (u_char *)pcap_next(pcap, pkthdr);\n+        pktdata = safe_pcap_next(pcap, pkthdr);\n     }\n \n     /* this get's casted to a const on the way out */",
  "diff_line_info": {
    "deleted_lines": [
      "            pktdata = (u_char *)pcap_next(pcap, pkthdr);",
      "        pktdata = (u_char *)pcap_next(pcap, pkthdr);"
    ],
    "added_lines": [
      "            pktdata = safe_pcap_next(pcap, pkthdr);",
      "        pktdata = safe_pcap_next(pcap, pkthdr);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/491",
  "description": {
    "pr_info": {
      "title": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files",
      "number": 491
    },
    "comment": [
      "* Check for packets that are larger than 262144 bytes\r\n* Check for capture lengths that are greater than packet length\r\n\r\nExample of a corrupt PCAP file ...\r\n\r\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\r\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0  \nThe patch addresses a CVE, modifies code to handle unsafe PCAP files, and includes checks against large packet sizes, all signs of a security fix.\n\n**Step-by-Step Explanation:**\n\n1. **Commit Message & Vulnerability Description**: Both reference CVE-2018-17582 and discuss checks against corrupt PCAP files, indicating a security concern.\n\n2. **Code Diff**: The introduction of `safe_pcap_next` replaces the standard `pcap_next`, suggesting added safety measures against buffer overflow issues.\n\n3. **Consistency Check**: The code changes match the described intent to validate packet lengths, ensuring the fix directly addresses the security issue.\n\n4. **Purpose Evaluation**: This is a core fix in the handling of external input, aimed at preventing potential exploitation.\n\n5. **Security Fix**: The changes are designed to mitigate risks associated with processing corrupt files, classifying this as a security vulnerability fix.\n\n**Confidence Score:** 1.0  \nAll elements clearly indicate a security fix with no ambiguity."
}