{
  "cve_id": "CVE-2018-7868",
  "cwe_ids": [
    "CWE-119",
    "CWE-476",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "Fix heap-buffer-overflows when accessing pool\n\nConstants are usually retrieved from the constant pool without verifying\nthat the pool actually contains them, which may lead to various heap\nbuffer overflow issues.\n\nIn this patch we add a counter keeping track of how many elements the pool\ncontains, and checks making sure that whenever the pool is accessed, the\nconstant in present in the pool (constant position < pool counter).\n\nAlso, do not return \"\" when a pointer is excepted (it should be legal to free\nthis return value).\n\nThis patch fixes #112 (CVE-2018-7875), fixes #120 (CVE-2018-7871),\nfixes #117 (CVE-2018-7870), fixes #114 (CVE-2018-7872), fixes #122,\nfixes #113 (CVE-2018-7868), fixes #123.",
  "commit_hash": "3a000c7b6fe978dd9925266bb6847709e06dbaa3",
  "git_url": "https://github.com/libming/libming/commit/3a000c7b6fe978dd9925266bb6847709e06dbaa3",
  "file_path": "util/decompile.c",
  "func_name": "decompilePUSHPARAM",
  "func_before": "static void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\n{\n\tchar *t;\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif( wantstring ) printf (\"'%s'\", act->p.String);\n\t\telse printf (\"%s\", act->p.String);\n\t\tbreak;\n\tcase PUSH_FLOAT: /* FLOAT */\n\t\tprintf (\"%f\", act->p.Float);\n\t\tbreak;\n\tcase PUSH_NULL: /* NULL */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase PUSH_UNDEF: /* Undefined */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase PUSH_REGISTER: /* Register */\n\t\tif( regs[act->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(act));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)act->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tprintf (\"%s\", act->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\tprintf (\"%g\", act->p.Double);\n\t\tbreak;\n\tcase PUSH_INT: /* INTEGER */\n\t\tprintf (\"%ld\", act->p.Integer);\n\t\tbreak;\n\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif( wantstring ) t=getString(act);\n\t  \telse t=getName(act);\n\t  \tputs(t);  \n\t  \tfree(t);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* CONSTANT8 */\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* CONSTANT16 */\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\tprintf (\"%s\", act->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", act->Type);\n\t}\n}",
  "abstract_func_before": "static void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *VAR_0, int VAR_1)\n{\n\tchar *VAR_2;\n\tswitch( VAR_0->Type ) \n\t{\n\tcase VAR_3: /* COMMENT_0 */\n\t\tif( VAR_1 ) printf (\"'%s'\", VAR_0->p.String);\n\t\telse printf (\"%s\", VAR_0->p.String);\n\t\tbreak;\n\tcase VAR_4: /* COMMENT_1 */\n\t\tprintf (\"%f\", VAR_0->p.Float);\n\t\tbreak;\n\tcase VAR_5: /* COMMENT_2 */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase VAR_6: /* COMMENT_3 */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase VAR_7: /* COMMENT_4 */\n\t\tif( VAR_8[VAR_0->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(VAR_0));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)VAR_0->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase VAR_9: /* COMMENT_5 */\n\t\tprintf (\"%s\", VAR_0->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase VAR_10: /* COMMENT_6 */\n\t\tprintf (\"%g\", VAR_0->p.Double);\n\t\tbreak;\n\tcase VAR_11: /* COMMENT_7 */\n\t\tprintf (\"%ld\", VAR_0->p.Integer);\n\t\tbreak;\n\n\tcase VAR_12: /* COMMENT_8 */\n\tcase VAR_13: /* COMMENT_9 */\n\t\tif( VAR_1 ) VAR_2=getString(VAR_0);\n\t  \telse VAR_2=getName(VAR_0);\n\t  \tputs(VAR_2);  \n\t  \tfree(VAR_2);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* COMMENT_8 */\n\t\tif( VAR_1 )\n  \t\t  printf (\"'%s'\", VAR_14[VAR_0->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", VAR_14[VAR_0->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* COMMENT_9 */\n\t\tif( VAR_1 )\n  \t\t  printf (\"'%s'\", VAR_14[VAR_0->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", VAR_14[VAR_0->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* COMMENT_10 */\n\tcase VAR_15: /* COMMENT_11 */\n\t\tprintf (\"%s\", VAR_0->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", VAR_0->Type);\n\t}\n}",
  "func_graph_path_before": "libming/3a000c7b6fe978dd9925266bb6847709e06dbaa3/decompile.c/vul/before/1.json",
  "func": "static void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\n{\n\tchar *t;\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif( wantstring ) printf (\"'%s'\", act->p.String);\n\t\telse printf (\"%s\", act->p.String);\n\t\tbreak;\n\tcase PUSH_FLOAT: /* FLOAT */\n\t\tprintf (\"%f\", act->p.Float);\n\t\tbreak;\n\tcase PUSH_NULL: /* NULL */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase PUSH_UNDEF: /* Undefined */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase PUSH_REGISTER: /* Register */\n\t\tif( regs[act->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(act));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)act->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tprintf (\"%s\", act->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\tprintf (\"%g\", act->p.Double);\n\t\tbreak;\n\tcase PUSH_INT: /* INTEGER */\n\t\tprintf (\"%ld\", act->p.Integer);\n\t\tbreak;\n\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif( wantstring ) t=getString(act);\n\t  \telse t=getName(act);\n\t  \tputs(t);  \n\t  \tfree(t);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\tprintf (\"%s\", act->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", act->Type);\n\t}\n}",
  "abstract_func": "static void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *VAR_0, int VAR_1)\n{\n\tchar *VAR_2;\n\tswitch( VAR_0->Type ) \n\t{\n\tcase VAR_3: /* COMMENT_0 */\n\t\tif( VAR_1 ) printf (\"'%s'\", VAR_0->p.String);\n\t\telse printf (\"%s\", VAR_0->p.String);\n\t\tbreak;\n\tcase VAR_4: /* COMMENT_1 */\n\t\tprintf (\"%f\", VAR_0->p.Float);\n\t\tbreak;\n\tcase VAR_5: /* COMMENT_2 */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase VAR_6: /* COMMENT_3 */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase VAR_7: /* COMMENT_4 */\n\t\tif( VAR_8[VAR_0->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(VAR_0));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)VAR_0->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase VAR_9: /* COMMENT_5 */\n\t\tprintf (\"%s\", VAR_0->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase VAR_10: /* COMMENT_6 */\n\t\tprintf (\"%g\", VAR_0->p.Double);\n\t\tbreak;\n\tcase VAR_11: /* COMMENT_7 */\n\t\tprintf (\"%ld\", VAR_0->p.Integer);\n\t\tbreak;\n\n\tcase VAR_12: /* COMMENT_8 */\n\tcase VAR_13: /* COMMENT_9 */\n\t\tif( VAR_1 ) VAR_2=getString(VAR_0);\n\t  \telse VAR_2=getName(VAR_0);\n\t  \tputs(VAR_2);  \n\t  \tfree(VAR_2);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* COMMENT_8 */\n\t\tif (VAR_0->p.Constant8 > VAR_14)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( VAR_1 )\n  \t\t  printf (\"'%s'\", VAR_15[VAR_0->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", VAR_15[VAR_0->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* COMMENT_9 */\n\t\tif (VAR_0->p.Constant16 > VAR_14)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( VAR_1 )\n  \t\t  printf (\"'%s'\", VAR_15[VAR_0->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", VAR_15[VAR_0->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* COMMENT_10 */\n\tcase VAR_16: /* COMMENT_11 */\n\t\tprintf (\"%s\", VAR_0->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", VAR_0->Type);\n\t}\n}",
  "func_graph_path": "libming/3a000c7b6fe978dd9925266bb6847709e06dbaa3/decompile.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -44,12 +44,22 @@\n \n #if 0\n \t  case 8: /* CONSTANT8 */\n+\t\tif (act->p.Constant8 > poolcounter)\n+\t\t{\n+\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n+\t\t        break;\n+\t\t}\n \t\tif( wantstring )\n   \t\t  printf (\"'%s'\", pool[act->p.Constant8]);\n \t\telse\n   \t\t  printf (\"%s\", pool[act->p.Constant8]);\n \t\tbreak;\n \t  case 9: /* CONSTANT16 */\n+\t\tif (act->p.Constant16 > poolcounter)\n+\t\t{\n+\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n+\t\t        break;\n+\t\t}\n \t\tif( wantstring )\n   \t\t  printf (\"'%s'\", pool[act->p.Constant16]);\n \t\telse",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\tif (act->p.Constant8 > poolcounter)",
      "\t\t{",
      "\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");",
      "\t\t        break;",
      "\t\t}",
      "\t\tif (act->p.Constant16 > poolcounter)",
      "\t\t{",
      "\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");",
      "\t\t        break;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/125",
  "description": {
    "pr_info": {
      "title": "Fix various issues with pool management / access",
      "number": 125
    },
    "comment": [
      "Constants are usually retrieved from the constant pool without verifying that the pool actually contains them, which may lead to various heap buffer overflow issues.\r\n\r\nIn this PR we add a counter keeping track of how many elements the pool contains, and checks making sure that whenever the pool is accessed, the constant in present in the pool (constant position < pool counter).\r\n\r\nAlso, do not return \"\" when a pointer is excepted (it should be legal to free this return value).\r\n\r\nThis PR fixes #112 (CVE-2018-7875), fixes #120 (CVE-2018-7871), fixes #117 (CVE-2018-7870), fixes #114 (CVE-2018-7872), fixes #122, fixes #113 (CVE-2018-7868), fixes #123.\r\n\r\nLots of non trivial stuff here, careful review would be really helpful.",
      "Thanks, always great contributions !"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 1.0"
}