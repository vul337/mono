{
  "cve_id": "CVE-2023-38403",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "esnet/iperf",
  "commit_msg": "Fix memory allocation hazard (#1542). (#1543)\n\nReported by:\t@someusername123 on GitHub",
  "commit_hash": "0ef151550d96cc4460f98832df84b4a1e87c65e9",
  "git_url": "https://github.com/esnet/iperf/commit/0ef151550d96cc4460f98832df84b4a1e87c65e9",
  "file_path": "src/iperf_api.c",
  "func_name": "JSON_read",
  "func_before": "static cJSON *\nJSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n\n    /*\n     * Read a four-byte integer, which is the length of the JSON to follow.\n     * Then read the JSON into a buffer and parse it.  Return a parsed JSON\n     * structure, NULL if there was an error.\n     */\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\t/* Allocate a buffer to hold the JSON */\n\tstr = (char *) calloc(sizeof(char), hsize+1);\t/* +1 for trailing null */\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\t/*\n\t\t * We should be reading in the number of bytes corresponding to the\n\t\t * length in that 4-byte integer.  If we don't the socket might have\n\t\t * prematurely closed.  Only do the JSON parsing if we got the\n\t\t * correct number of bytes.\n\t\t */\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}",
  "abstract_func_before": "static cJSON *\nJSON_read(int VAR_0)\n{\n    uint32_t VAR_1, VAR_2;\n    char *VAR_3;\n    cJSON *VAR_4 = NULL;\n    int VAR_5;\n\n    /* COMMENT_0 */\n                                                                           \n                                                                           \n                                             \n       \n    if (Nread(VAR_0, (char*) &VAR_2, sizeof(VAR_2), VAR_6) >= 0) {\n\tVAR_1 = ntohl(VAR_2);\n\t/* COMMENT_5 */\n\tVAR_3 = (char *) calloc(sizeof(char), VAR_1+1);\t/* COMMENT_6 */\n\tif (VAR_3 != NULL) {\n\t    VAR_5 = Nread(VAR_0, VAR_3, VAR_1, VAR_6);\n\t    if (VAR_5 >= 0) {\n\t\t/* COMMENT_7 */\n                                                                     \n                                                                      \n                                                                \n                             \n     \n\t\tif (VAR_5 == VAR_1) {\n\t\t    VAR_4 = cJSON_Parse(VAR_3);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(VAR_3);\n    }\n    return VAR_4;\n}",
  "func_graph_path_before": "esnet/iperf/0ef151550d96cc4460f98832df84b4a1e87c65e9/iperf_api.c/vul/before/0.json",
  "func": "static cJSON *\nJSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    size_t strsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n\n    /*\n     * Read a four-byte integer, which is the length of the JSON to follow.\n     * Then read the JSON into a buffer and parse it.  Return a parsed JSON\n     * structure, NULL if there was an error.\n     */\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\t/* Allocate a buffer to hold the JSON */\n\tstrsize = hsize + 1;              /* +1 for trailing NULL */\n\tif (strsize) {\n\tstr = (char *) calloc(sizeof(char), strsize);\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\t/*\n\t\t * We should be reading in the number of bytes corresponding to the\n\t\t * length in that 4-byte integer.  If we don't the socket might have\n\t\t * prematurely closed.  Only do the JSON parsing if we got the\n\t\t * correct number of bytes.\n\t\t */\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n\t}\n\telse {\n\t    printf(\"WARNING:  Data length overflow\\n\");\n\t}\n    }\n    return json;\n}",
  "abstract_func": "static cJSON *\nJSON_read(int VAR_0)\n{\n    uint32_t VAR_1, VAR_2;\n    size_t VAR_3;\n    char *VAR_4;\n    cJSON *VAR_5 = NULL;\n    int VAR_6;\n\n    /* COMMENT_0 */\n                                                                           \n                                                                           \n                                             \n       \n    if (Nread(VAR_0, (char*) &VAR_2, sizeof(VAR_2), VAR_7) >= 0) {\n\tVAR_1 = ntohl(VAR_2);\n\t/* COMMENT_5 */\n\tVAR_3 = VAR_1 + 1;              /* COMMENT_6 */\n\tif (VAR_3) {\n\tVAR_4 = (char *) calloc(sizeof(char), VAR_3);\n\tif (VAR_4 != NULL) {\n\t    VAR_6 = Nread(VAR_0, VAR_4, VAR_1, VAR_7);\n\t    if (VAR_6 >= 0) {\n\t\t/* COMMENT_7 */\n                                                                     \n                                                                      \n                                                                \n                             \n     \n\t\tif (VAR_6 == VAR_1) {\n\t\t    VAR_5 = cJSON_Parse(VAR_4);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(VAR_4);\n\t}\n\telse {\n\t    printf(\"WARNING:  Data length overflow\\n\");\n\t}\n    }\n    return VAR_5;\n}",
  "func_graph_path": "esnet/iperf/0ef151550d96cc4460f98832df84b4a1e87c65e9/iperf_api.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n JSON_read(int fd)\n {\n     uint32_t hsize, nsize;\n+    size_t strsize;\n     char *str;\n     cJSON *json = NULL;\n     int rc;\n@@ -14,7 +15,9 @@\n     if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n \thsize = ntohl(nsize);\n \t/* Allocate a buffer to hold the JSON */\n-\tstr = (char *) calloc(sizeof(char), hsize+1);\t/* +1 for trailing null */\n+\tstrsize = hsize + 1;              /* +1 for trailing NULL */\n+\tif (strsize) {\n+\tstr = (char *) calloc(sizeof(char), strsize);\n \tif (str != NULL) {\n \t    rc = Nread(fd, str, hsize, Ptcp);\n \t    if (rc >= 0) {\n@@ -33,6 +36,10 @@\n \t    }\n \t}\n \tfree(str);\n+\t}\n+\telse {\n+\t    printf(\"WARNING:  Data length overflow\\n\");\n+\t}\n     }\n     return json;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tstr = (char *) calloc(sizeof(char), hsize+1);\t/* +1 for trailing null */"
    ],
    "added_lines": [
      "    size_t strsize;",
      "\tstrsize = hsize + 1;              /* +1 for trailing NULL */",
      "\tif (strsize) {",
      "\tstr = (char *) calloc(sizeof(char), strsize);",
      "\t}",
      "\telse {",
      "\t    printf(\"WARNING:  Data length overflow\\n\");",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/esnet/iperf/pull/1543",
  "description": {
    "pr_info": {
      "title": "Fix memory allocation hazard (#1542).",
      "number": 1543
    },
    "comment": [
      "Reported by:\t@someusername123 on GitHub\r\n\r\n_PLEASE NOTE the following text from the iperf3 license.  Submitting a\r\npull request to the iperf3 repository constitutes \"[making]\r\nEnhancements available...publicly\":_\r\n\r\n```\r\nYou are under no obligation whatsoever to provide any bug fixes, patches, or\r\nupgrades to the features, functionality or performance of the source code\r\n(\"Enhancements\") to anyone; however, if you choose to make your Enhancements\r\navailable either publicly, or directly to Lawrence Berkeley National\r\nLaboratory, without imposing a separate written license agreement for such\r\nEnhancements, then you hereby grant the following license: a non-exclusive,\r\nroyalty-free perpetual license to install, use, modify, prepare derivative\r\nworks, incorporate into other computer software, distribute, and sublicense\r\nsuch enhancements or derivative works thereof, in binary and source code form.\r\n```\r\n\r\n_The complete iperf3 license is available in the `LICENSE` file in the\r\ntop directory of the iperf3 source tree._\r\n\r\n* Version of iperf3 (or development branch, such as `master` or\r\n  `3.1-STABLE`) to which this pull request applies: master\r\n\r\n* Issues fixed (if any): Closes #1542 \r\n\r\n* Brief description of code changes (suitable for use as a commit message):\r\n\r\n",
      "Thanks @someusername123 for the bug report!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}