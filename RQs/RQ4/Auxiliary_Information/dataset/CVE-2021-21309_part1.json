{
  "cve_id": "CVE-2021-21309",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix integer overflow (CVE-2021-21309). (#8522)\n\nOn 32-bit systems, setting the proto-max-bulk-len config parameter to a high value may result with integer overflow and a subsequent heap overflow when parsing an input bulk (CVE-2021-21309).\n\nThis fix has two parts:\n\nSet a reasonable limit to the config parameter.\nAdd additional checks to prevent the problem in other potential but unknown code paths.\n\n(cherry picked from commit d32f2e9999ce003bad0bd2c3bca29f64dcce4433)",
  "commit_hash": "c992857618db99776917f10bf4f2345a5fdc78b0",
  "git_url": "https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0",
  "file_path": "src/sds.c",
  "func_name": "sdsnewlen",
  "func_before": "sds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n\n    sh = s_malloc(hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    if (init==SDS_NOINIT)\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}",
  "abstract_func_before": "sds sdsnewlen(const void *VAR_0, size_t VAR_1) {\n    void *VAR_2;\n    sds VAR_3;\n    char VAR_4 = sdsReqType(VAR_1);\n    /* COMMENT_0 */\n                                           \n    if (VAR_4 == VAR_5 && VAR_1 == 0) VAR_4 = VAR_6;\n    int VAR_7 = sdsHdrSize(VAR_4);\n    unsigned char *VAR_8; /* COMMENT_2 */\n\n    VAR_2 = s_malloc(VAR_7+VAR_1+1);\n    if (VAR_2 == NULL) return NULL;\n    if (VAR_0==VAR_9)\n        VAR_0 = NULL;\n    else if (!VAR_0)\n        memset(VAR_2, 0, VAR_7+VAR_1+1);\n    VAR_3 = (char*)VAR_2+VAR_7;\n    VAR_8 = ((unsigned char*)VAR_3)-1;\n    switch(VAR_4) {\n        case VAR_5: {\n            *VAR_8 = VAR_4 | (VAR_1 << VAR_10);\n            break;\n        }\n        case VAR_6: {\n            SDS_HDR_VAR(8,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n        case VAR_11: {\n            SDS_HDR_VAR(16,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n        case VAR_12: {\n            SDS_HDR_VAR(32,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n        case VAR_13: {\n            SDS_HDR_VAR(64,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n    }\n    if (VAR_1 && VAR_0)\n        memcpy(VAR_3, VAR_0, VAR_1);\n    VAR_3[VAR_1] = '\\0';\n    return VAR_3;\n}",
  "func_graph_path_before": "redis/c992857618db99776917f10bf4f2345a5fdc78b0/sds.c/vul/before/0.json",
  "func": "sds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n\n    assert(initlen + hdrlen + 1 > initlen); /* Catch size_t overflow */\n    sh = s_malloc(hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    if (init==SDS_NOINIT)\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}",
  "abstract_func": "sds sdsnewlen(const void *VAR_0, size_t VAR_1) {\n    void *VAR_2;\n    sds VAR_3;\n    char VAR_4 = sdsReqType(VAR_1);\n    /* COMMENT_0 */\n                                           \n    if (VAR_4 == VAR_5 && VAR_1 == 0) VAR_4 = VAR_6;\n    int VAR_7 = sdsHdrSize(VAR_4);\n    unsigned char *VAR_8; /* COMMENT_2 */\n\n    assert(VAR_1 + VAR_7 + 1 > VAR_1); /* COMMENT_3 */\n    VAR_2 = s_malloc(VAR_7+VAR_1+1);\n    if (VAR_2 == NULL) return NULL;\n    if (VAR_0==VAR_9)\n        VAR_0 = NULL;\n    else if (!VAR_0)\n        memset(VAR_2, 0, VAR_7+VAR_1+1);\n    VAR_3 = (char*)VAR_2+VAR_7;\n    VAR_8 = ((unsigned char*)VAR_3)-1;\n    switch(VAR_4) {\n        case VAR_5: {\n            *VAR_8 = VAR_4 | (VAR_1 << VAR_10);\n            break;\n        }\n        case VAR_6: {\n            SDS_HDR_VAR(8,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n        case VAR_11: {\n            SDS_HDR_VAR(16,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n        case VAR_12: {\n            SDS_HDR_VAR(32,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n        case VAR_13: {\n            SDS_HDR_VAR(64,VAR_3);\n            VAR_2->len = VAR_1;\n            VAR_2->alloc = VAR_1;\n            *VAR_8 = VAR_4;\n            break;\n        }\n    }\n    if (VAR_1 && VAR_0)\n        memcpy(VAR_3, VAR_0, VAR_1);\n    VAR_3[VAR_1] = '\\0';\n    return VAR_3;\n}",
  "func_graph_path": "redis/c992857618db99776917f10bf4f2345a5fdc78b0/sds.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n     int hdrlen = sdsHdrSize(type);\n     unsigned char *fp; /* flags pointer. */\n \n+    assert(initlen + hdrlen + 1 > initlen); /* Catch size_t overflow */\n     sh = s_malloc(hdrlen+initlen+1);\n     if (sh == NULL) return NULL;\n     if (init==SDS_NOINIT)",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    assert(initlen + hdrlen + 1 > initlen); /* Catch size_t overflow */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/8527",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/redis/redis/pull/8527: 403 Client Error: Forbidden for url: https://api.github.com/repos/redis/redis/pulls/8527",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses an integer overflow vulnerability (CVE-2021-21309), which is a security issue. The code changes include an assert to prevent overflow, aligning with the commit's intention to fix this security flaw.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}