{
  "cve_id": "CVE-2017-11462",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Preserve GSS context on init/accept failure\n\nAfter gss_init_sec_context() or gss_accept_sec_context() has created a\ncontext, don't delete the mechglue context on failures from subsequent\ncalls, even if the mechanism deletes the mech-specific context (which\nis allowed by RFC 2744 but not preferred).  Check for union contexts\nwith no mechanism context in each GSS function which accepts a\ngss_ctx_id_t.\n\nCVE-2017-11462:\n\nRFC 2744 permits a GSS-API implementation to delete an existing\nsecurity context on a second or subsequent call to\ngss_init_sec_context() or gss_accept_sec_context() if the call results\nin an error.  This API behavior has been found to be dangerous,\nleading to the possibility of memory errors in some callers.  For\nsafety, GSS-API implementations should instead preserve existing\nsecurity contexts on error until the caller deletes them.\n\nAll versions of MIT krb5 prior to this change may delete acceptor\ncontexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through\n1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on\nerror.\n\nticket: 8598 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup",
  "commit_hash": "56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
  "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
  "file_path": "src/lib/gssapi/mechglue/g_seal.c",
  "func_name": "gss_wrap",
  "func_before": "OM_uint32 KRB5_CALLCONV\ngss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n\n    /* EXPORT DELETE START */\n\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n\n        return(status);\n    }\n    /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}",
  "abstract_func_before": "OM_uint32 VAR_0\ngss_wrap( OM_uint32 *VAR_1,\n          gss_ctx_id_t VAR_2,\n          int VAR_3,\n          gss_qop_t VAR_4,\n          gss_buffer_t VAR_5,\n          int *VAR_6,\n          gss_buffer_t VAR_7)\n{\n\n    /* COMMENT_0 */\n\n    OM_uint32           VAR_8;\n    gss_union_ctx_id_t  VAR_9;\n    gss_mechanism       VAR_10;\n\n    VAR_8 = val_wrap_args(VAR_1, VAR_2,\n                           VAR_3, VAR_4,\n                           VAR_5, VAR_6,\n                           VAR_7);\n    if (VAR_8 != VAR_11)\n        return (VAR_8);\n\n    /* COMMENT_1 */\n                                                             \n               \n       \n\n    VAR_9 = (gss_union_ctx_id_t) VAR_2;\n    VAR_10 = gssint_get_mechanism (VAR_9->mech_type);\n\n    if (VAR_10) {\n        if (VAR_10->gss_wrap) {\n            VAR_8 = VAR_10->gss_wrap(VAR_1,\n                                    VAR_9->internal_ctx_id,\n                                    VAR_3,\n                                    VAR_4,\n                                    VAR_5,\n                                    VAR_6,\n                                    VAR_7);\n            if (VAR_8 != VAR_11)\n                map_error(VAR_1, VAR_10);\n        } else if (VAR_10->gss_wrap_aead ||\n                   (VAR_10->gss_wrap_iov && VAR_10->gss_wrap_iov_length)) {\n            VAR_8 = gssint_wrap_aead(VAR_10,\n                                      VAR_1,\n                                      VAR_9,\n                                      VAR_3,\n                                      (gss_qop_t)VAR_4,\n                                      VAR_12,\n                                      VAR_5,\n                                      VAR_6,\n                                      VAR_7);\n        } else\n            VAR_8 = VAR_13;\n\n        return(VAR_8);\n    }\n    /* COMMENT_5 */\n\n    return (VAR_14);\n}",
  "func_graph_path_before": null,
  "func": "OM_uint32 KRB5_CALLCONV\ngss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n\n    /* EXPORT DELETE START */\n\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n\n        return(status);\n    }\n    /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}",
  "abstract_func": "OM_uint32 VAR_0\ngss_wrap( OM_uint32 *VAR_1,\n          gss_ctx_id_t VAR_2,\n          int VAR_3,\n          gss_qop_t VAR_4,\n          gss_buffer_t VAR_5,\n          int *VAR_6,\n          gss_buffer_t VAR_7)\n{\n\n    /* COMMENT_0 */\n\n    OM_uint32           VAR_8;\n    gss_union_ctx_id_t  VAR_9;\n    gss_mechanism       VAR_10;\n\n    VAR_8 = val_wrap_args(VAR_1, VAR_2,\n                           VAR_3, VAR_4,\n                           VAR_5, VAR_6,\n                           VAR_7);\n    if (VAR_8 != VAR_11)\n        return (VAR_8);\n\n    /* COMMENT_1 */\n                                                             \n               \n       \n\n    VAR_9 = (gss_union_ctx_id_t) VAR_2;\n    if (VAR_9->internal_ctx_id == VAR_12)\n        return (VAR_13);\n    VAR_10 = gssint_get_mechanism (VAR_9->mech_type);\n\n    if (VAR_10) {\n        if (VAR_10->gss_wrap) {\n            VAR_8 = VAR_10->gss_wrap(VAR_1,\n                                    VAR_9->internal_ctx_id,\n                                    VAR_3,\n                                    VAR_4,\n                                    VAR_5,\n                                    VAR_6,\n                                    VAR_7);\n            if (VAR_8 != VAR_11)\n                map_error(VAR_1, VAR_10);\n        } else if (VAR_10->gss_wrap_aead ||\n                   (VAR_10->gss_wrap_iov && VAR_10->gss_wrap_iov_length)) {\n            VAR_8 = gssint_wrap_aead(VAR_10,\n                                      VAR_1,\n                                      VAR_9,\n                                      VAR_3,\n                                      (gss_qop_t)VAR_4,\n                                      VAR_14,\n                                      VAR_5,\n                                      VAR_6,\n                                      VAR_7);\n        } else\n            VAR_8 = VAR_15;\n\n        return(VAR_8);\n    }\n    /* COMMENT_5 */\n\n    return (VAR_16);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
      "        return (GSS_S_NO_CONTEXT);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/677",
  "description": {
    "pr_info": {
      "title": "Preserve GSS context on init/accept failure",
      "number": 677
    },
    "comment": [
      "[@frozencemetery: please run interposer tests against this PR]\r\n\r\nAfter gss_init_sec_context() or gss_accept_sec_context() has created a\r\ncontext, don't delete the mechglue context on failures from subsequent\r\ncalls, even if the mechanism deletes the mech-specific context (which\r\nis allowed by RFC 2744 but not preferred).  Check for union contexts\r\nwith no mechanism context in each GSS function which accepts a\r\ngss_ctx_id_t.\r\n",
      "Interposer tests and gssproxy tests passing.  Will try to review in a bit."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a known security vulnerability (CVE-2017-11462) by ensuring GSS contexts are preserved upon failure, preventing memory errors. The commit message and code changes clearly indicate a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}