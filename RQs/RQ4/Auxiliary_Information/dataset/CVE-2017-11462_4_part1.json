{
  "cve_id": "CVE-2017-11462",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Preserve GSS context on init/accept failure\n\nAfter gss_init_sec_context() or gss_accept_sec_context() has created a\ncontext, don't delete the mechglue context on failures from subsequent\ncalls, even if the mechanism deletes the mech-specific context (which\nis allowed by RFC 2744 but not preferred).  Check for union contexts\nwith no mechanism context in each GSS function which accepts a\ngss_ctx_id_t.\n\nCVE-2017-11462:\n\nRFC 2744 permits a GSS-API implementation to delete an existing\nsecurity context on a second or subsequent call to\ngss_init_sec_context() or gss_accept_sec_context() if the call results\nin an error.  This API behavior has been found to be dangerous,\nleading to the possibility of memory errors in some callers.  For\nsafety, GSS-API implementations should instead preserve existing\nsecurity contexts on error until the caller deletes them.\n\nAll versions of MIT krb5 prior to this change may delete acceptor\ncontexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through\n1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on\nerror.\n\nticket: 8598 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup",
  "commit_hash": "56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
  "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
  "file_path": "src/lib/gssapi/mechglue/g_complete_auth_token.c",
  "func_name": "gss_complete_auth_token",
  "func_before": "OM_uint32 KRB5_CALLCONV\ngss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}",
  "abstract_func_before": "OM_uint32 VAR_0\ngss_complete_auth_token (OM_uint32 *VAR_1,\n\t                 const gss_ctx_id_t VAR_2,\n\t                 gss_buffer_t VAR_3)\n{\n    OM_uint32\t\tVAR_4;\n    gss_union_ctx_id_t\tVAR_5;\n    gss_mechanism\tVAR_6;\n\n    if (VAR_2 == VAR_7)\n\treturn VAR_8;\n\n    /* COMMENT_0 */\n                                                             \n               \n       \n\n    VAR_5 = (gss_union_ctx_id_t) VAR_2;\n    VAR_6 = gssint_get_mechanism (VAR_5->mech_type);\n\n    if (VAR_6 != NULL) {\n\tif (VAR_6->gss_complete_auth_token != NULL) {\n\t    VAR_4 = VAR_6->gss_complete_auth_token(VAR_1,\n\t\t\t\t\t\t   VAR_5->internal_ctx_id,\n\t\t\t\t\t\t   VAR_3);\n\t    if (VAR_4 != VAR_9)\n\t\tmap_error(VAR_1, VAR_6);\n\t} else\n\t    VAR_4 = VAR_9;\n    } else\n\tVAR_4 = VAR_10;\n\n    return VAR_4;\n}",
  "func_graph_path_before": null,
  "func": "OM_uint32 KRB5_CALLCONV\ngss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}",
  "abstract_func": "OM_uint32 VAR_0\ngss_complete_auth_token (OM_uint32 *VAR_1,\n\t                 const gss_ctx_id_t VAR_2,\n\t                 gss_buffer_t VAR_3)\n{\n    OM_uint32\t\tVAR_4;\n    gss_union_ctx_id_t\tVAR_5;\n    gss_mechanism\tVAR_6;\n\n    if (VAR_2 == VAR_7)\n\treturn VAR_8;\n\n    /* COMMENT_0 */\n                                                             \n               \n       \n\n    VAR_5 = (gss_union_ctx_id_t) VAR_2;\n    if (VAR_5->internal_ctx_id == VAR_7)\n\treturn VAR_8;\n    VAR_6 = gssint_get_mechanism (VAR_5->mech_type);\n\n    if (VAR_6 != NULL) {\n\tif (VAR_6->gss_complete_auth_token != NULL) {\n\t    VAR_4 = VAR_6->gss_complete_auth_token(VAR_1,\n\t\t\t\t\t\t   VAR_5->internal_ctx_id,\n\t\t\t\t\t\t   VAR_3);\n\t    if (VAR_4 != VAR_9)\n\t\tmap_error(VAR_1, VAR_6);\n\t} else\n\t    VAR_4 = VAR_9;\n    } else\n\tVAR_4 = VAR_10;\n\n    return VAR_4;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
      "\treturn GSS_S_NO_CONTEXT;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/677",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/krb5/krb5/pull/677: 403 Client Error: Forbidden for url: https://api.github.com/repos/krb5/krb5/pulls/677",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}