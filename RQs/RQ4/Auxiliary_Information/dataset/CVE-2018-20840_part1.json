{
  "cve_id": "CVE-2018-20840",
  "cwe_ids": [
    "CWE-754"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "google/google-api-cpp-client",
  "commit_msg": "fixed 'exp' handling in ID token",
  "commit_hash": "c62e7bcb3ae9d8ef1a94c2fbb143019d647f6304",
  "git_url": "https://github.com/google/google-api-cpp-client/commit/c62e7bcb3ae9d8ef1a94c2fbb143019d647f6304",
  "file_path": "src/googleapis/client/auth/oauth2_authorization.cc",
  "func_name": "OAuth2Credential::UpdateFromString",
  "func_before": "util::Status OAuth2Credential::UpdateFromString(const string& json) {\n  OAuth2AuthorizationFlow::SimpleJsonData data;\n  googleapis::util::Status status = data.Init(json);\n  if (!status.ok()) return status;\n\n  string str_value;\n  int int_value;\n\n  if (data.GetString(\"refresh_token\", &str_value)) {\n    VLOG(1) << \"Updating refresh token\";\n    refresh_token_.set(str_value);\n  }\n  if (data.GetString(\"access_token\", &str_value)) {\n    access_token_.set(str_value);\n    VLOG(1) << \"Updating access token\";\n  }\n  if (data.GetString(\"expires_at\", &str_value)\n      || data.GetString(\"exp\", &str_value)) {\n    int64 timestamp;\n    if (!safe_strto64(str_value.c_str(), &timestamp)) {\n      LOG(ERROR) << \"Invalid timestamp=[\" << str_value << \"]\";\n    } else {\n      expiration_timestamp_secs_.set(timestamp);\n      VLOG(1) << \"Updating access token expiration\";\n    }\n  } else if (data.GetScalar(\"expires_in\", &int_value)) {\n    int64 now = DateTime().ToEpochTime();\n    int64 expiration = now + int_value;\n    expiration_timestamp_secs_.set(expiration);\n    VLOG(1) << \"Updating access token expiration\";\n  }\n  if (data.GetString(\"email\", &str_value)) {\n    string bool_str;\n    // Read this as a string because OAuth2 server returns it as\n    // a true/false string.\n    data.GetString(\"email_verified\", &bool_str);\n\n    email_ = str_value;\n    email_verified_ = bool_str == \"true\";\n  }\n\n  if (data.GetString(\"id_token\", &str_value)) {\n    // Extract additional stuff from the JWT claims.\n    // We dont need to verify the signature since we already know\n    // this is coming from the OAuth2 server and is secure with https.\n    // see https://developers.google.com/accounts/docs/OAuth2Login\n    //     #validatinganidtoken\n    int dot_positions[3];\n    int n_dots = 0;\n    for (size_t i = 0; i < str_value.size(); ++i) {\n      if (str_value[i] == '.') {\n        dot_positions[n_dots] = i;\n        ++n_dots;\n        if (n_dots == 3) break;\n      }\n    }\n    if (n_dots != 2) {\n      return StatusUnknown(\"Invalid id_token attribute - not a JWT\");\n    }\n    string claims;\n    const char *claims_start = str_value.data() + dot_positions[0] + 1;\n    size_t claims_len = dot_positions[1] - dot_positions[0] - 1;\n    if (!googleapis_util::Base64Unescape(claims_start, claims_len, &claims)) {\n      return StatusUnknown(\"id_token claims not base-64 encoded\");\n    }\n    return UpdateFromString(claims);\n  }\n\n  return StatusOk();\n}",
  "abstract_func_before": "util::Status OAuth2Credential::UpdateFromString(const string& VAR_0) {\n  OAuth2AuthorizationFlow::SimpleJsonData VAR_1;\n  googleapis::util::Status VAR_2 = VAR_1.Init(VAR_0);\n  if (!VAR_2.ok()) return VAR_2;\n\n  string VAR_3;\n  int VAR_4;\n\n  if (VAR_1.GetString(\"refresh_token\", &VAR_3)) {\n    VLOG(1) << \"Updating refresh token\";\n    VAR_5.set(VAR_3);\n  }\n  if (VAR_1.GetString(\"access_token\", &VAR_3)) {\n    VAR_6.set(VAR_3);\n    VLOG(1) << \"Updating access token\";\n  }\n  if (VAR_1.GetString(\"expires_at\", &VAR_3)\n      || VAR_1.GetString(\"exp\", &VAR_3)) {\n    int64 VAR_7;\n    if (!safe_strto64(VAR_3.c_str(), &VAR_7)) {\n      LOG(VAR_8) << \"Invalid timestamp=[\" << VAR_3 << \"]\";\n    } else {\n      VAR_9.set(VAR_7);\n      VLOG(1) << \"Updating access token expiration\";\n    }\n  } else if (VAR_1.GetScalar(\"expires_in\", &VAR_4)) {\n    int64 VAR_10 = DateTime().ToEpochTime();\n    int64 VAR_11 = VAR_10 + VAR_4;\n    VAR_9.set(VAR_11);\n    VLOG(1) << \"Updating access token expiration\";\n  }\n  if (VAR_1.GetString(\"email\", &VAR_3)) {\n    string VAR_12;\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_1.GetString(\"email_verified\", &VAR_12);\n\n    VAR_13 = VAR_3;\n    VAR_14 = VAR_12 == \"true\";\n  }\n\n  if (VAR_1.GetString(\"id_token\", &VAR_3)) {\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    int VAR_15[3];\n    int VAR_16 = 0;\n    for (size_t VAR_17 = 0; VAR_17 < VAR_3.size(); ++VAR_17) {\n      if (VAR_3[VAR_17] == '.') {\n        VAR_15[VAR_16] = VAR_17;\n        ++VAR_16;\n        if (VAR_16 == 3) break;\n      }\n    }\n    if (VAR_16 != 2) {\n      return StatusUnknown(\"Invalid id_token attribute - not a JWT\");\n    }\n    string VAR_18;\n    const char *VAR_19 = VAR_3.data() + VAR_15[0] + 1;\n    size_t VAR_20 = VAR_15[1] - VAR_15[0] - 1;\n    if (!googleapis_util::Base64Unescape(VAR_19, VAR_20, &VAR_18)) {\n      return StatusUnknown(\"id_token claims not base-64 encoded\");\n    }\n    return UpdateFromString(VAR_18);\n  }\n\n  return StatusOk();\n}",
  "func_graph_path_before": "google/google-api-cpp-client/c62e7bcb3ae9d8ef1a94c2fbb143019d647f6304/oauth2_authorization.cc/vul/before/0.json",
  "func": "util::Status OAuth2Credential::UpdateFromString(const string& json) {\n  OAuth2AuthorizationFlow::SimpleJsonData data;\n  googleapis::util::Status status = data.Init(json);\n  if (!status.ok()) return status;\n\n  string str_value;\n  int int_value;\n\n  if (data.GetString(\"refresh_token\", &str_value)) {\n    VLOG(1) << \"Updating refresh token\";\n    refresh_token_.set(str_value);\n  }\n  if (data.GetString(\"access_token\", &str_value)) {\n    access_token_.set(str_value);\n    VLOG(1) << \"Updating access token\";\n  }\n  if (data.GetString(\"expires_at\", &str_value)) {\n    int64 timestamp;\n    if (!safe_strto64(str_value.c_str(), &timestamp)) {\n      LOG(ERROR) << \"Invalid timestamp=[\" << str_value << \"]\";\n    } else {\n      expiration_timestamp_secs_.set(timestamp);\n      VLOG(1) << \"Updating access token expiration\";\n    }\n  } else if (data.GetScalar(\"exp\", &int_value)) {\n    int64 timestamp = int_value;\n    expiration_timestamp_secs_.set(timestamp);\n    VLOG(1) << \"Updating access token expiration\";\n  } else if (data.GetScalar(\"expires_in\", &int_value)) {\n    int64 now = DateTime().ToEpochTime();\n    int64 expiration = now + int_value;\n    expiration_timestamp_secs_.set(expiration);\n    VLOG(1) << \"Updating access token expiration\";\n  }\n  if (data.GetString(\"email\", &str_value)) {\n    string bool_str;\n    // Read this as a string because OAuth2 server returns it as\n    // a true/false string.\n    data.GetString(\"email_verified\", &bool_str);\n\n    email_ = str_value;\n    email_verified_ = bool_str == \"true\";\n  }\n\n  if (data.GetString(\"id_token\", &str_value)) {\n    // Extract additional stuff from the JWT claims.\n    // We dont need to verify the signature since we already know\n    // this is coming from the OAuth2 server and is secure with https.\n    // see https://developers.google.com/accounts/docs/OAuth2Login\n    //     #validatinganidtoken\n    int dot_positions[3];\n    int n_dots = 0;\n    for (size_t i = 0; i < str_value.size(); ++i) {\n      if (str_value[i] == '.') {\n        dot_positions[n_dots] = i;\n        ++n_dots;\n        if (n_dots == 3) break;\n      }\n    }\n    if (n_dots != 2) {\n      return StatusUnknown(\"Invalid id_token attribute - not a JWT\");\n    }\n    string claims;\n    const char *claims_start = str_value.data() + dot_positions[0] + 1;\n    size_t claims_len = dot_positions[1] - dot_positions[0] - 1;\n    if (!googleapis_util::Base64Unescape(claims_start, claims_len, &claims)) {\n      return StatusUnknown(\"id_token claims not base-64 encoded\");\n    }\n    return UpdateFromString(claims);\n  }\n\n  return StatusOk();\n}",
  "abstract_func": "util::Status OAuth2Credential::UpdateFromString(const string& VAR_0) {\n  OAuth2AuthorizationFlow::SimpleJsonData VAR_1;\n  googleapis::util::Status VAR_2 = VAR_1.Init(VAR_0);\n  if (!VAR_2.ok()) return VAR_2;\n\n  string VAR_3;\n  int VAR_4;\n\n  if (VAR_1.GetString(\"refresh_token\", &VAR_3)) {\n    VLOG(1) << \"Updating refresh token\";\n    VAR_5.set(VAR_3);\n  }\n  if (VAR_1.GetString(\"access_token\", &VAR_3)) {\n    VAR_6.set(VAR_3);\n    VLOG(1) << \"Updating access token\";\n  }\n  if (VAR_1.GetString(\"expires_at\", &VAR_3)) {\n    int64 VAR_7;\n    if (!safe_strto64(VAR_3.c_str(), &VAR_7)) {\n      LOG(VAR_8) << \"Invalid timestamp=[\" << VAR_3 << \"]\";\n    } else {\n      VAR_9.set(VAR_7);\n      VLOG(1) << \"Updating access token expiration\";\n    }\n  } else if (VAR_1.GetScalar(\"exp\", &VAR_4)) {\n    int64 VAR_7 = VAR_4;\n    VAR_9.set(VAR_7);\n    VLOG(1) << \"Updating access token expiration\";\n  } else if (VAR_1.GetScalar(\"expires_in\", &VAR_4)) {\n    int64 VAR_10 = DateTime().ToEpochTime();\n    int64 VAR_11 = VAR_10 + VAR_4;\n    VAR_9.set(VAR_11);\n    VLOG(1) << \"Updating access token expiration\";\n  }\n  if (VAR_1.GetString(\"email\", &VAR_3)) {\n    string VAR_12;\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_1.GetString(\"email_verified\", &VAR_12);\n\n    VAR_13 = VAR_3;\n    VAR_14 = VAR_12 == \"true\";\n  }\n\n  if (VAR_1.GetString(\"id_token\", &VAR_3)) {\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    int VAR_15[3];\n    int VAR_16 = 0;\n    for (size_t VAR_17 = 0; VAR_17 < VAR_3.size(); ++VAR_17) {\n      if (VAR_3[VAR_17] == '.') {\n        VAR_15[VAR_16] = VAR_17;\n        ++VAR_16;\n        if (VAR_16 == 3) break;\n      }\n    }\n    if (VAR_16 != 2) {\n      return StatusUnknown(\"Invalid id_token attribute - not a JWT\");\n    }\n    string VAR_18;\n    const char *VAR_19 = VAR_3.data() + VAR_15[0] + 1;\n    size_t VAR_20 = VAR_15[1] - VAR_15[0] - 1;\n    if (!googleapis_util::Base64Unescape(VAR_19, VAR_20, &VAR_18)) {\n      return StatusUnknown(\"id_token claims not base-64 encoded\");\n    }\n    return UpdateFromString(VAR_18);\n  }\n\n  return StatusOk();\n}",
  "func_graph_path": "google/google-api-cpp-client/c62e7bcb3ae9d8ef1a94c2fbb143019d647f6304/oauth2_authorization.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,7 @@\n     access_token_.set(str_value);\n     VLOG(1) << \"Updating access token\";\n   }\n-  if (data.GetString(\"expires_at\", &str_value)\n-      || data.GetString(\"exp\", &str_value)) {\n+  if (data.GetString(\"expires_at\", &str_value)) {\n     int64 timestamp;\n     if (!safe_strto64(str_value.c_str(), &timestamp)) {\n       LOG(ERROR) << \"Invalid timestamp=[\" << str_value << \"]\";\n@@ -23,6 +22,10 @@\n       expiration_timestamp_secs_.set(timestamp);\n       VLOG(1) << \"Updating access token expiration\";\n     }\n+  } else if (data.GetScalar(\"exp\", &int_value)) {\n+    int64 timestamp = int_value;\n+    expiration_timestamp_secs_.set(timestamp);\n+    VLOG(1) << \"Updating access token expiration\";\n   } else if (data.GetScalar(\"expires_in\", &int_value)) {\n     int64 now = DateTime().ToEpochTime();\n     int64 expiration = now + int_value;",
  "diff_line_info": {
    "deleted_lines": [
      "  if (data.GetString(\"expires_at\", &str_value)",
      "      || data.GetString(\"exp\", &str_value)) {"
    ],
    "added_lines": [
      "  if (data.GetString(\"expires_at\", &str_value)) {",
      "  } else if (data.GetScalar(\"exp\", &int_value)) {",
      "    int64 timestamp = int_value;",
      "    expiration_timestamp_secs_.set(timestamp);",
      "    VLOG(1) << \"Updating access token expiration\";"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/google/google-api-cpp-client/pull/58",
  "description": {
    "pr_info": {
      "title": "Fixed 'exp' handling in ID token",
      "number": 58
    },
    "comment": [
      "It is a measure for issue #57.\r\n\r\nModification:\r\nChange the way of ‘exp’ handling; from data.GetString(“exp”, &str_value) to data.GetScalar(“exp”, &int_value)\r\n\r\nResult:\r\nIt will not happen the bug when receiving ID token value.\r\n \r\n",
      "\nThanks for your pull request. It looks like this may be your first contribution to a Google open source project (if not, look below for help). Before we can look at your pull request, you'll need to sign a Contributor License Agreement (CLA).\n\n:memo: **Please visit <https://cla.developers.google.com/> to sign.**\n\nOnce you've signed (or fixed any issues), please reply here (e.g. `I signed it!`) and we'll verify it.\n\n----\n\n#### What to do if you already signed the CLA\n\n##### Individual signers\n\n*   It's possible we don't have your GitHub username or you're using a different email address on your commit. Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).\n\n##### Corporate signers\n\n*   Your company has a Point of Contact who decides which employees are authorized to participate. Ask your POC to be added to the group of authorized contributors. If you don't know who your Point of Contact is, direct the Google project maintainer to [go/cla#troubleshoot](http://go/cla#troubleshoot) ([Public version](https://opensource.google.com/docs/cla/#troubleshoot)).\n*   The email used to register you as an authorized contributor must be the email used for the Git commit. Check [your existing CLA data](https://cla.developers.google.com/clas) and verify that your [email is set on your git commits](https://help.github.com/articles/setting-your-email-in-git/).\n*   The email used to register you as an authorized contributor must also be [attached to your GitHub account](https://github.com/settings/emails).\n\t\t\n\n<!-- need_sender_cla -->",
      "I signed it!",
      "CLAs look good, thanks!\n\n<!-- ok -->",
      "@SurferJeffAtGoogle Could you check the issue?",
      "Thank you for submitting this fix.  I apologize for taking so long to review.  It got lost my TODO list.  😞\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Commit Message & Vulnerability Description Analysis:** The commit fixes the 'exp' handling in an ID token, suggesting a bug in processing the expiration value. The code changes how 'exp' is retrieved from scalar to string, preventing bugs when receiving the token.\n\n2. **Code Diff Analysis:** The code no longer retrieves 'exp' as a string but as a scalar (integer), indicating a core logic fix rather than a security-specific change.\n\n3. **Security Implication Consideration:** The 'exp' field is critical for token validity. Incorrect handling could lead to security issues, but without explicit security mentions, it's a defect fix.\n\n4. **Classification:** The fix addresses a core issue in token processing, not explicitly a security vulnerability. Therefore, it's categorized under Defect Remediation.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}