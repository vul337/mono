{
  "cve_id": "CVE-2021-20244",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "ImageMagick",
  "commit_msg": "uses the PerceptibleReciprocal() to prevent the divide-by-zero from occurring",
  "commit_hash": "6720594ccb46afeb3365fb54d814271608f754b3",
  "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6720594ccb46afeb3365fb54d814271608f754b3",
  "file_path": "MagickCore/visual-effects.c",
  "func_name": "ImplodeImage",
  "func_before": "MagickExport Image *ImplodeImage(const Image *image,const double amount,\n  const PixelInterpolateMethod method,ExceptionInfo *exception)\n{\n#define ImplodeImageTag  \"Implode/Image\"\n\n  CacheView\n    *canvas_view,\n    *implode_view,\n    *interpolate_view;\n\n  double\n    radius;\n\n  Image\n    *canvas_image,\n    *implode_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PointInfo\n    center,\n    scale;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize implode image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  canvas_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (canvas_image == (Image *) NULL)\n    return((Image *) NULL);\n  if ((canvas_image->alpha_trait == UndefinedPixelTrait) &&\n      (canvas_image->background_color.alpha != OpaqueAlpha))\n    (void) SetImageAlphaChannel(canvas_image,OpaqueAlphaChannel,exception);\n  implode_image=CloneImage(canvas_image,0,0,MagickTrue,exception);\n  if (implode_image == (Image *) NULL)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  if (SetImageStorageClass(implode_image,DirectClass,exception) == MagickFalse)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      implode_image=DestroyImage(implode_image);\n      return((Image *) NULL);\n    }\n  /*\n    Compute scaling factor.\n  */\n  scale.x=1.0;\n  scale.y=1.0;\n  center.x=0.5*canvas_image->columns;\n  center.y=0.5*canvas_image->rows;\n  radius=center.x;\n  if (canvas_image->columns > canvas_image->rows)\n    scale.y=(double) canvas_image->columns/(double) canvas_image->rows;\n  else\n    if (canvas_image->columns < canvas_image->rows)\n      {\n        scale.x=(double) canvas_image->rows/(double) canvas_image->columns;\n        radius=center.y;\n      }\n  /*\n    Implode image.\n  */\n  status=MagickTrue;\n  progress=0;\n  canvas_view=AcquireVirtualCacheView(canvas_image,exception);\n  interpolate_view=AcquireVirtualCacheView(canvas_image,exception);\n  implode_view=AcquireAuthenticCacheView(implode_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(canvas_image,implode_image,canvas_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) canvas_image->rows; y++)\n  {\n    double\n      distance;\n\n    PointInfo\n      delta;\n\n    const Quantum\n      *magick_restrict p;\n\n    ssize_t\n      x;\n\n    Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(canvas_view,0,y,canvas_image->columns,1,\n      exception);\n    q=QueueCacheViewAuthenticPixels(implode_view,0,y,implode_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    delta.y=scale.y*(double) (y-center.y);\n    for (x=0; x < (ssize_t) canvas_image->columns; x++)\n    {\n      ssize_t\n        i;\n\n      /*\n        Determine if the pixel is within an ellipse.\n      */\n      delta.x=scale.x*(double) (x-center.x);\n      distance=delta.x*delta.x+delta.y*delta.y;\n      if (distance >= (radius*radius))\n        for (i=0; i < (ssize_t) GetPixelChannels(canvas_image); i++)\n        {\n          PixelChannel channel = GetPixelChannelChannel(canvas_image,i);\n          PixelTrait traits = GetPixelChannelTraits(canvas_image,channel);\n          PixelTrait implode_traits = GetPixelChannelTraits(implode_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (implode_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(implode_image,channel,p[i],q);\n        }\n      else\n        {\n          double\n            factor;\n\n          /*\n            Implode the pixel.\n          */\n          factor=1.0;\n          if (distance > 0.0)\n            factor=pow(sin(MagickPI*sqrt((double) distance)/radius/2),-amount);\n          status=InterpolatePixelChannels(canvas_image,interpolate_view,\n            implode_image,method,(double) (factor*delta.x/scale.x+center.x),\n            (double) (factor*delta.y/scale.y+center.y),q,exception);\n          if (status == MagickFalse)\n            break;\n        }\n      p+=GetPixelChannels(canvas_image);\n      q+=GetPixelChannels(implode_image);\n    }\n    if (SyncCacheViewAuthenticPixels(implode_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (canvas_image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(canvas_image,ImplodeImageTag,progress,\n          canvas_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  implode_view=DestroyCacheView(implode_view);\n  interpolate_view=DestroyCacheView(interpolate_view);\n  canvas_view=DestroyCacheView(canvas_view);\n  canvas_image=DestroyImage(canvas_image);\n  if (status == MagickFalse)\n    implode_image=DestroyImage(implode_image);\n  return(implode_image);\n}",
  "abstract_func_before": "MagickExport VAR_0 *ImplodeImage(const Image *VAR_1,const double VAR_2,\n  const PixelInterpolateMethod VAR_3,ExceptionInfo *VAR_4)\n{\n#define VAR_5  \"Implode/Image\"\n\n  CacheView\n    *VAR_6,\n    *VAR_7,\n    *VAR_8;\n\n  double\n    VAR_9;\n\n  Image\n    *VAR_10,\n    *VAR_11;\n\n  MagickBooleanType\n    VAR_12;\n\n  MagickOffsetType\n    VAR_13;\n\n  PointInfo\n    VAR_14,\n    VAR_15;\n\n  ssize_t\n    VAR_16;\n\n  /* COMMENT_0 */\n                                        \n    \n  assert(VAR_1 != (Image *) NULL);\n  assert(VAR_1->signature == VAR_17);\n  if (VAR_1->debug != VAR_18)\n    (void) LogMagickEvent(VAR_19,GetMagickModule(),\"%s\",VAR_1->filename);\n  assert(VAR_4 != (ExceptionInfo *) NULL);\n  assert(VAR_4->signature == VAR_17);\n  VAR_10=CloneImage(VAR_1,0,0,VAR_20,VAR_4);\n  if (VAR_10 == (Image *) NULL)\n    return((Image *) NULL);\n  if ((VAR_10->alpha_trait == VAR_21) &&\n      (VAR_10->background_color.alpha != VAR_22))\n    (void) SetImageAlphaChannel(VAR_10,VAR_23,VAR_4);\n  VAR_11=CloneImage(VAR_10,0,0,VAR_20,VAR_4);\n  if (VAR_11 == (Image *) NULL)\n    {\n      VAR_10=DestroyImage(VAR_10);\n      return((Image *) NULL);\n    }\n  if (SetImageStorageClass(VAR_11,VAR_24,VAR_4) == VAR_18)\n    {\n      VAR_10=DestroyImage(VAR_10);\n      VAR_11=DestroyImage(VAR_11);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                           \n    \n  VAR_15.x=1.0;\n  VAR_15.y=1.0;\n  VAR_14.x=0.5*VAR_10->columns;\n  VAR_14.y=0.5*VAR_10->rows;\n  VAR_9=VAR_14.x;\n  if (VAR_10->columns > VAR_10->rows)\n    VAR_15.y=(double) VAR_10->columns/(double) VAR_10->rows;\n  else\n    if (VAR_10->columns < VAR_10->rows)\n      {\n        VAR_15.x=(double) VAR_10->rows/(double) VAR_10->columns;\n        VAR_9=VAR_14.y;\n      }\n  /* COMMENT_6 */\n                  \n    \n  VAR_12=VAR_20;\n  VAR_13=0;\n  VAR_6=AcquireVirtualCacheView(VAR_10,VAR_4);\n  VAR_8=AcquireVirtualCacheView(VAR_10,VAR_4);\n  VAR_7=AcquireAuthenticCacheView(VAR_11,VAR_4);\n#if defined(VAR_25)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(canvas_image,implode_image,canvas_image->rows,1)\n#endif\n  for (VAR_16=0; VAR_16 < (ssize_t) VAR_10->rows; VAR_16++)\n  {\n    double\n      VAR_26;\n\n    PointInfo\n      VAR_27;\n\n    const Quantum\n      *magick_restrict VAR_28;\n\n    ssize_t\n      VAR_29;\n\n    Quantum\n      *magick_restrict VAR_30;\n\n    if (VAR_12 == VAR_18)\n      continue;\n    VAR_28=GetCacheViewVirtualPixels(VAR_6,0,VAR_16,VAR_10->columns,1,\n      VAR_4);\n    VAR_30=QueueCacheViewAuthenticPixels(VAR_7,0,VAR_16,VAR_11->columns,1,\n      VAR_4);\n    if ((VAR_28 == (const Quantum *) NULL) || (VAR_30 == (Quantum *) NULL))\n      {\n        VAR_12=VAR_18;\n        continue;\n      }\n    VAR_27.y=VAR_15.y*(double) (VAR_16-VAR_14.y);\n    for (VAR_29=0; VAR_29 < (ssize_t) VAR_10->columns; VAR_29++)\n    {\n      ssize_t\n        VAR_31;\n\n      /* COMMENT_9 */\n                                                    \n        \n      VAR_27.x=VAR_15.x*(double) (VAR_29-VAR_14.x);\n      VAR_26=VAR_27.x*VAR_27.x+VAR_27.y*VAR_27.y;\n      if (VAR_26 >= (VAR_9*VAR_9))\n        for (VAR_31=0; VAR_31 < (ssize_t) GetPixelChannels(VAR_10); VAR_31++)\n        {\n          PixelChannel VAR_32 = GetPixelChannelChannel(VAR_10,VAR_31);\n          PixelTrait VAR_33 = GetPixelChannelTraits(VAR_10,VAR_32);\n          PixelTrait VAR_34 = GetPixelChannelTraits(VAR_11,\n            VAR_32);\n          if ((VAR_33 == VAR_21) ||\n              (VAR_34 == VAR_21))\n            continue;\n          SetPixelChannel(VAR_11,VAR_32,VAR_28[VAR_31],VAR_30);\n        }\n      else\n        {\n          double\n            VAR_35;\n\n          /* COMMENT_12 */\n                              \n            \n          VAR_35=1.0;\n          if (VAR_26 > 0.0)\n            VAR_35=pow(sin(VAR_36*sqrt((double) VAR_26)/VAR_9/2),-VAR_2);\n          VAR_12=InterpolatePixelChannels(VAR_10,VAR_8,\n            VAR_11,VAR_3,(double) (VAR_35*VAR_27.x/VAR_15.x+VAR_14.x),\n            (double) (VAR_35*VAR_27.y/VAR_15.y+VAR_14.y),VAR_30,VAR_4);\n          if (VAR_12 == VAR_18)\n            break;\n        }\n      VAR_28+=GetPixelChannels(VAR_10);\n      VAR_30+=GetPixelChannels(VAR_11);\n    }\n    if (SyncCacheViewAuthenticPixels(VAR_7,VAR_4) == VAR_18)\n      VAR_12=VAR_18;\n    if (VAR_10->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          VAR_37;\n\n#if defined(VAR_25)\n        #pragma omp atomic\n#endif\n        VAR_13++;\n        VAR_37=SetImageProgress(VAR_10,VAR_5,VAR_13,\n          VAR_10->rows);\n        if (VAR_37 == VAR_18)\n          VAR_12=VAR_18;\n      }\n  }\n  VAR_7=DestroyCacheView(VAR_7);\n  VAR_8=DestroyCacheView(VAR_8);\n  VAR_6=DestroyCacheView(VAR_6);\n  VAR_10=DestroyImage(VAR_10);\n  if (VAR_12 == VAR_18)\n    VAR_11=DestroyImage(VAR_11);\n  return(VAR_11);\n}",
  "func_graph_path_before": null,
  "func": "MagickExport Image *ImplodeImage(const Image *image,const double amount,\n  const PixelInterpolateMethod method,ExceptionInfo *exception)\n{\n#define ImplodeImageTag  \"Implode/Image\"\n\n  CacheView\n    *canvas_view,\n    *implode_view,\n    *interpolate_view;\n\n  double\n    radius;\n\n  Image\n    *canvas_image,\n    *implode_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PointInfo\n    center,\n    scale;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize implode image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  canvas_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (canvas_image == (Image *) NULL)\n    return((Image *) NULL);\n  if ((canvas_image->alpha_trait == UndefinedPixelTrait) &&\n      (canvas_image->background_color.alpha != OpaqueAlpha))\n    (void) SetImageAlphaChannel(canvas_image,OpaqueAlphaChannel,exception);\n  implode_image=CloneImage(canvas_image,0,0,MagickTrue,exception);\n  if (implode_image == (Image *) NULL)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  if (SetImageStorageClass(implode_image,DirectClass,exception) == MagickFalse)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      implode_image=DestroyImage(implode_image);\n      return((Image *) NULL);\n    }\n  /*\n    Compute scaling factor.\n  */\n  scale.x=1.0;\n  scale.y=1.0;\n  center.x=0.5*canvas_image->columns;\n  center.y=0.5*canvas_image->rows;\n  radius=center.x;\n  if (canvas_image->columns > canvas_image->rows)\n    scale.y=(double) canvas_image->columns*PerceptibleReciprocal((double) canvas_image->rows);\n  else\n    if (canvas_image->columns < canvas_image->rows)\n      {\n        scale.x=(double) canvas_image->rows*PerceptibleReciprocal((double) canvas_image->columns);\n        radius=center.y;\n      }\n  /*\n    Implode image.\n  */\n  status=MagickTrue;\n  progress=0;\n  canvas_view=AcquireVirtualCacheView(canvas_image,exception);\n  interpolate_view=AcquireVirtualCacheView(canvas_image,exception);\n  implode_view=AcquireAuthenticCacheView(implode_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(canvas_image,implode_image,canvas_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) canvas_image->rows; y++)\n  {\n    double\n      distance;\n\n    PointInfo\n      delta;\n\n    const Quantum\n      *magick_restrict p;\n\n    ssize_t\n      x;\n\n    Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(canvas_view,0,y,canvas_image->columns,1,\n      exception);\n    q=QueueCacheViewAuthenticPixels(implode_view,0,y,implode_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    delta.y=scale.y*(double) (y-center.y);\n    for (x=0; x < (ssize_t) canvas_image->columns; x++)\n    {\n      ssize_t\n        i;\n\n      /*\n        Determine if the pixel is within an ellipse.\n      */\n      delta.x=scale.x*(double) (x-center.x);\n      distance=delta.x*delta.x+delta.y*delta.y;\n      if (distance >= (radius*radius))\n        for (i=0; i < (ssize_t) GetPixelChannels(canvas_image); i++)\n        {\n          PixelChannel channel = GetPixelChannelChannel(canvas_image,i);\n          PixelTrait traits = GetPixelChannelTraits(canvas_image,channel);\n          PixelTrait implode_traits = GetPixelChannelTraits(implode_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (implode_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(implode_image,channel,p[i],q);\n        }\n      else\n        {\n          double\n            factor;\n\n          /*\n            Implode the pixel.\n          */\n          factor=1.0;\n          if (distance > 0.0)\n            factor=pow(sin(MagickPI*sqrt((double) distance)*PerceptibleReciprocal(radius)/2),-amount);\n          status=InterpolatePixelChannels(canvas_image,interpolate_view,\n            implode_image,method,(double) (factor*delta.x*PerceptibleReciprocal(scale.x)+center.x),\n            (double) (factor*delta.y*PerceptibleReciprocal(scale.y)+center.y),q,exception);\n          if (status == MagickFalse)\n            break;\n        }\n      p+=GetPixelChannels(canvas_image);\n      q+=GetPixelChannels(implode_image);\n    }\n    if (SyncCacheViewAuthenticPixels(implode_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (canvas_image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(canvas_image,ImplodeImageTag,progress,\n          canvas_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  implode_view=DestroyCacheView(implode_view);\n  interpolate_view=DestroyCacheView(interpolate_view);\n  canvas_view=DestroyCacheView(canvas_view);\n  canvas_image=DestroyImage(canvas_image);\n  if (status == MagickFalse)\n    implode_image=DestroyImage(implode_image);\n  return(implode_image);\n}",
  "abstract_func": "MagickExport VAR_0 *ImplodeImage(const Image *VAR_1,const double VAR_2,\n  const PixelInterpolateMethod VAR_3,ExceptionInfo *VAR_4)\n{\n#define VAR_5  \"Implode/Image\"\n\n  CacheView\n    *VAR_6,\n    *VAR_7,\n    *VAR_8;\n\n  double\n    VAR_9;\n\n  Image\n    *VAR_10,\n    *VAR_11;\n\n  MagickBooleanType\n    VAR_12;\n\n  MagickOffsetType\n    VAR_13;\n\n  PointInfo\n    VAR_14,\n    VAR_15;\n\n  ssize_t\n    VAR_16;\n\n  /* COMMENT_0 */\n                                        \n    \n  assert(VAR_1 != (Image *) NULL);\n  assert(VAR_1->signature == VAR_17);\n  if (VAR_1->debug != VAR_18)\n    (void) LogMagickEvent(VAR_19,GetMagickModule(),\"%s\",VAR_1->filename);\n  assert(VAR_4 != (ExceptionInfo *) NULL);\n  assert(VAR_4->signature == VAR_17);\n  VAR_10=CloneImage(VAR_1,0,0,VAR_20,VAR_4);\n  if (VAR_10 == (Image *) NULL)\n    return((Image *) NULL);\n  if ((VAR_10->alpha_trait == VAR_21) &&\n      (VAR_10->background_color.alpha != VAR_22))\n    (void) SetImageAlphaChannel(VAR_10,VAR_23,VAR_4);\n  VAR_11=CloneImage(VAR_10,0,0,VAR_20,VAR_4);\n  if (VAR_11 == (Image *) NULL)\n    {\n      VAR_10=DestroyImage(VAR_10);\n      return((Image *) NULL);\n    }\n  if (SetImageStorageClass(VAR_11,VAR_24,VAR_4) == VAR_18)\n    {\n      VAR_10=DestroyImage(VAR_10);\n      VAR_11=DestroyImage(VAR_11);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                           \n    \n  VAR_15.x=1.0;\n  VAR_15.y=1.0;\n  VAR_14.x=0.5*VAR_10->columns;\n  VAR_14.y=0.5*VAR_10->rows;\n  VAR_9=VAR_14.x;\n  if (VAR_10->columns > VAR_10->rows)\n    VAR_15.y=(double) VAR_10->columns*PerceptibleReciprocal((double) VAR_10->rows);\n  else\n    if (VAR_10->columns < VAR_10->rows)\n      {\n        VAR_15.x=(double) VAR_10->rows*PerceptibleReciprocal((double) VAR_10->columns);\n        VAR_9=VAR_14.y;\n      }\n  /* COMMENT_6 */\n                  \n    \n  VAR_12=VAR_20;\n  VAR_13=0;\n  VAR_6=AcquireVirtualCacheView(VAR_10,VAR_4);\n  VAR_8=AcquireVirtualCacheView(VAR_10,VAR_4);\n  VAR_7=AcquireAuthenticCacheView(VAR_11,VAR_4);\n#if defined(VAR_25)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(canvas_image,implode_image,canvas_image->rows,1)\n#endif\n  for (VAR_16=0; VAR_16 < (ssize_t) VAR_10->rows; VAR_16++)\n  {\n    double\n      VAR_26;\n\n    PointInfo\n      VAR_27;\n\n    const Quantum\n      *magick_restrict VAR_28;\n\n    ssize_t\n      VAR_29;\n\n    Quantum\n      *magick_restrict VAR_30;\n\n    if (VAR_12 == VAR_18)\n      continue;\n    VAR_28=GetCacheViewVirtualPixels(VAR_6,0,VAR_16,VAR_10->columns,1,\n      VAR_4);\n    VAR_30=QueueCacheViewAuthenticPixels(VAR_7,0,VAR_16,VAR_11->columns,1,\n      VAR_4);\n    if ((VAR_28 == (const Quantum *) NULL) || (VAR_30 == (Quantum *) NULL))\n      {\n        VAR_12=VAR_18;\n        continue;\n      }\n    VAR_27.y=VAR_15.y*(double) (VAR_16-VAR_14.y);\n    for (VAR_29=0; VAR_29 < (ssize_t) VAR_10->columns; VAR_29++)\n    {\n      ssize_t\n        VAR_31;\n\n      /* COMMENT_9 */\n                                                    \n        \n      VAR_27.x=VAR_15.x*(double) (VAR_29-VAR_14.x);\n      VAR_26=VAR_27.x*VAR_27.x+VAR_27.y*VAR_27.y;\n      if (VAR_26 >= (VAR_9*VAR_9))\n        for (VAR_31=0; VAR_31 < (ssize_t) GetPixelChannels(VAR_10); VAR_31++)\n        {\n          PixelChannel VAR_32 = GetPixelChannelChannel(VAR_10,VAR_31);\n          PixelTrait VAR_33 = GetPixelChannelTraits(VAR_10,VAR_32);\n          PixelTrait VAR_34 = GetPixelChannelTraits(VAR_11,\n            VAR_32);\n          if ((VAR_33 == VAR_21) ||\n              (VAR_34 == VAR_21))\n            continue;\n          SetPixelChannel(VAR_11,VAR_32,VAR_28[VAR_31],VAR_30);\n        }\n      else\n        {\n          double\n            VAR_35;\n\n          /* COMMENT_12 */\n                              \n            \n          VAR_35=1.0;\n          if (VAR_26 > 0.0)\n            VAR_35=pow(sin(VAR_36*sqrt((double) VAR_26)*PerceptibleReciprocal(VAR_9)/2),-VAR_2);\n          VAR_12=InterpolatePixelChannels(VAR_10,VAR_8,\n            VAR_11,VAR_3,(double) (VAR_35*VAR_27.x*PerceptibleReciprocal(VAR_15.x)+VAR_14.x),\n            (double) (VAR_35*VAR_27.y*PerceptibleReciprocal(VAR_15.y)+VAR_14.y),VAR_30,VAR_4);\n          if (VAR_12 == VAR_18)\n            break;\n        }\n      VAR_28+=GetPixelChannels(VAR_10);\n      VAR_30+=GetPixelChannels(VAR_11);\n    }\n    if (SyncCacheViewAuthenticPixels(VAR_7,VAR_4) == VAR_18)\n      VAR_12=VAR_18;\n    if (VAR_10->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          VAR_37;\n\n#if defined(VAR_25)\n        #pragma omp atomic\n#endif\n        VAR_13++;\n        VAR_37=SetImageProgress(VAR_10,VAR_5,VAR_13,\n          VAR_10->rows);\n        if (VAR_37 == VAR_18)\n          VAR_12=VAR_18;\n      }\n  }\n  VAR_7=DestroyCacheView(VAR_7);\n  VAR_8=DestroyCacheView(VAR_8);\n  VAR_6=DestroyCacheView(VAR_6);\n  VAR_10=DestroyImage(VAR_10);\n  if (VAR_12 == VAR_18)\n    VAR_11=DestroyImage(VAR_11);\n  return(VAR_11);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -64,11 +64,11 @@\n   center.y=0.5*canvas_image->rows;\n   radius=center.x;\n   if (canvas_image->columns > canvas_image->rows)\n-    scale.y=(double) canvas_image->columns/(double) canvas_image->rows;\n+    scale.y=(double) canvas_image->columns*PerceptibleReciprocal((double) canvas_image->rows);\n   else\n     if (canvas_image->columns < canvas_image->rows)\n       {\n-        scale.x=(double) canvas_image->rows/(double) canvas_image->columns;\n+        scale.x=(double) canvas_image->rows*PerceptibleReciprocal((double) canvas_image->columns);\n         radius=center.y;\n       }\n   /*\n@@ -144,10 +144,10 @@\n           */\n           factor=1.0;\n           if (distance > 0.0)\n-            factor=pow(sin(MagickPI*sqrt((double) distance)/radius/2),-amount);\n+            factor=pow(sin(MagickPI*sqrt((double) distance)*PerceptibleReciprocal(radius)/2),-amount);\n           status=InterpolatePixelChannels(canvas_image,interpolate_view,\n-            implode_image,method,(double) (factor*delta.x/scale.x+center.x),\n-            (double) (factor*delta.y/scale.y+center.y),q,exception);\n+            implode_image,method,(double) (factor*delta.x*PerceptibleReciprocal(scale.x)+center.x),\n+            (double) (factor*delta.y*PerceptibleReciprocal(scale.y)+center.y),q,exception);\n           if (status == MagickFalse)\n             break;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "    scale.y=(double) canvas_image->columns/(double) canvas_image->rows;",
      "        scale.x=(double) canvas_image->rows/(double) canvas_image->columns;",
      "            factor=pow(sin(MagickPI*sqrt((double) distance)/radius/2),-amount);",
      "            implode_image,method,(double) (factor*delta.x/scale.x+center.x),",
      "            (double) (factor*delta.y/scale.y+center.y),q,exception);"
    ],
    "added_lines": [
      "    scale.y=(double) canvas_image->columns*PerceptibleReciprocal((double) canvas_image->rows);",
      "        scale.x=(double) canvas_image->rows*PerceptibleReciprocal((double) canvas_image->columns);",
      "            factor=pow(sin(MagickPI*sqrt((double) distance)*PerceptibleReciprocal(radius)/2),-amount);",
      "            implode_image,method,(double) (factor*delta.x*PerceptibleReciprocal(scale.x)+center.x),",
      "            (double) (factor*delta.y*PerceptibleReciprocal(scale.y)+center.y),q,exception);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ImageMagick/ImageMagick/pull/3194",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/ImageMagick/ImageMagick/pull/3194: 403 Client Error: Forbidden for url: https://api.github.com/repos/ImageMagick/ImageMagick/pulls/3194",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "The patch modifies the code to prevent division by zero errors, which are critical and can lead to security issues. The changes are consistent with the commit message, which suggests a fix for a potential security flaw. However, the lack of explicit security identifiers lowers confidence.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.7"
}