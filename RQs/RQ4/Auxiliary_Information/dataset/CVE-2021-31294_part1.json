{
  "cve_id": "CVE-2021-31294",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Prevent replicas from sending commands that interact with keyspace (#8868)\n\nThis solves an issue reported in #8712 in which a replica would bypass\r\nthe client write pause check and cause an assertion due to executing a\r\nwrite command during failover.\r\n\r\nThe fact is that we don't expect replicas to execute any command other\r\nthan maybe REPLCONF and PING, etc. but matching against the ADMIN\r\ncommand flag is insufficient, so instead i just block keyspace access\r\nfor now.\n\n(cherry picked from commit 46f4ebbe842620f0976a36741a72482620aa4b48)",
  "commit_hash": "6cbea7d29b5285692843bc1c351abba1a7ef326f",
  "git_url": "https://github.com/redis/redis/commit/6cbea7d29b5285692843bc1c351abba1a7ef326f",
  "file_path": "src/server.c",
  "func_name": "processCommand",
  "func_before": "int processCommand(client *c) {\n    if (!server.lua_timedout) {\n        /* Both EXEC and EVAL call call() directly so there should be\n         * no way in_exec or in_eval or propagate_in_transaction is 1.\n         * That is unless lua_timedout, in which case client may run\n         * some commands. */\n        serverAssert(!server.propagate_in_transaction);\n        serverAssert(!server.in_exec);\n        serverAssert(!server.in_eval);\n    }\n\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n    int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||\n                                   (c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));\n\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    if (auth_required) {\n        /* AUTH and HELLO and no auth modules are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_errpos;\n    int acl_retval = ACLCheckAllPerm(c,&acl_errpos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_errpos,NULL);\n        switch (acl_retval) {\n        case ACL_DENIED_CMD:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n            break;\n        case ACL_DENIED_KEY:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n            break;\n        case ACL_DENIED_CHANNEL:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the channels used as arguments\");\n            break;\n        default:\n            rejectCommandFormat(c, \"no permission\");\n            break;\n        }\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(!cmdHasMovableKeys(c->cmd) && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            c->cmd->rejected_calls++;\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = (performEvictions() == EVICT_FAIL);\n        /* performEvictions may flush slave output buffers. This may result\n         * in a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand &&\n            c->cmd->proc != resetCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand &&\n        c->cmd->proc != resetCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n\t  c->cmd->proc != resetCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* If the server is paused, block the client until\n     * the pause has ended. Replicas are never paused. */\n    if (!(c->flags & CLIENT_SLAVE) && \n        ((server.client_pause_type == CLIENT_PAUSE_ALL) ||\n        (server.client_pause_type == CLIENT_PAUSE_WRITE && is_may_replicate_command)))\n    {\n        c->bpop.timeout = 0;\n        blockClient(c,BLOCKED_PAUSE);\n        return C_OK;       \n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand &&\n        c->cmd->proc != resetCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n\n    return C_OK;\n}",
  "abstract_func_before": "int processCommand(client *VAR_0) {\n    if (!VAR_1.lua_timedout) {\n        /* COMMENT_0 */\n                                                                      \n                                                                    \n                            \n        serverAssert(!VAR_1.propagate_in_transaction);\n        serverAssert(!VAR_1.in_exec);\n        serverAssert(!VAR_1.in_eval);\n    }\n\n    moduleCallCommandFilters(VAR_0);\n\n    /* COMMENT_4 */\n                                                                      \n                                                                    \n                                 \n    if (!strcasecmp(VAR_0->argv[0]->ptr,\"quit\")) {\n        addReply(VAR_0,VAR_2.ok);\n        VAR_0->flags |= VAR_3;\n        return VAR_4;\n    }\n\n    /* COMMENT_8 */\n                                                             \n    VAR_0->cmd = VAR_0->lastcmd = lookupCommand(VAR_0->argv[0]->ptr);\n    if (!VAR_0->cmd) {\n        sds VAR_5 = sdsempty();\n        int VAR_6;\n        for (VAR_6=1; VAR_6 < VAR_0->argc && sdslen(VAR_5) < 128; VAR_6++)\n            VAR_5 = sdscatprintf(VAR_5, \"`%.*s`, \", 128-(int)sdslen(VAR_5), (char*)VAR_0->argv[VAR_6]->ptr);\n        rejectCommandFormat(VAR_0,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)VAR_0->argv[0]->ptr, VAR_5);\n        sdsfree(VAR_5);\n        return VAR_7;\n    } else if ((VAR_0->cmd->arity > 0 && VAR_0->cmd->arity != VAR_0->argc) ||\n               (VAR_0->argc < -VAR_0->cmd->arity)) {\n        rejectCommandFormat(VAR_0,\"wrong number of arguments for '%s' command\",\n            VAR_0->cmd->name);\n        return VAR_7;\n    }\n\n    int VAR_8 = (VAR_0->cmd->flags & VAR_9) ||\n                           (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_9));\n    int VAR_11 = (VAR_0->cmd->flags & VAR_12) ||\n                             (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_12));\n    int VAR_13 = !(VAR_0->cmd->flags & VAR_14) ||\n                               (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_14));\n    int VAR_15 = !(VAR_0->cmd->flags & VAR_16) ||\n                                 (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_16));\n    int VAR_17 = (VAR_0->cmd->flags & (VAR_9 | VAR_18)) ||\n                                   (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & (VAR_9 | VAR_18)));\n\n    /* COMMENT_10 */\n                                                                \n    int VAR_19 = (!(VAR_20->flags & VAR_21) ||\n                          (VAR_20->flags & VAR_22)) &&\n                        !VAR_0->authenticated;\n    if (VAR_19) {\n        /* COMMENT_12 */\n                                      \n        if (!(VAR_0->cmd->flags & VAR_23)) {\n            rejectCommand(VAR_0,VAR_2.noautherr);\n            return VAR_7;\n        }\n    }\n\n    /* COMMENT_14 */\n               \n    int VAR_24;\n    int VAR_25 = ACLCheckAllPerm(VAR_0,&VAR_24);\n    if (VAR_25 != VAR_26) {\n        addACLLogEntry(VAR_0,VAR_25,VAR_24,NULL);\n        switch (VAR_25) {\n        case VAR_27:\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", VAR_0->cmd->name);\n            break;\n        case VAR_28:\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n            break;\n        case VAR_29:\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the channels used as arguments\");\n            break;\n        default:\n            rejectCommandFormat(VAR_0, \"no permission\");\n            break;\n        }\n        return VAR_7;\n    }\n\n    /* COMMENT_16 */\n                                                   \n                                                   \n                                              \n    if (VAR_1.cluster_enabled &&\n        !(VAR_0->flags & VAR_30) &&\n        !(VAR_0->flags & VAR_31 &&\n          VAR_1.lua_caller->flags & VAR_30) &&\n        !(!cmdHasMovableKeys(VAR_0->cmd) && VAR_0->cmd->firstkey == 0 &&\n          VAR_0->cmd->proc != VAR_10))\n    {\n        int VAR_32;\n        int VAR_33;\n        clusterNode *VAR_34 = getNodeByQuery(VAR_0,VAR_0->cmd,VAR_0->argv,VAR_0->argc,\n                                        &VAR_32,&VAR_33);\n        if (VAR_34 == NULL || VAR_34 != VAR_1.cluster->myself) {\n            if (VAR_0->cmd->proc == VAR_10) {\n                discardTransaction(VAR_0);\n            } else {\n                flagTransaction(VAR_0);\n            }\n            clusterRedirectClient(VAR_0,VAR_34,VAR_32,VAR_33);\n            VAR_0->cmd->rejected_calls++;\n            return VAR_7;\n        }\n    }\n\n    /* COMMENT_20 */\n      \n                                                                            \n                                                                         \n                                                                     \n                                              \n    if (VAR_1.maxmemory && !VAR_1.lua_timedout) {\n        int VAR_35 = (performEvictions() == VAR_36);\n        /* COMMENT_26 */\n                                                                     \n        if (VAR_1.current_client == NULL) return VAR_4;\n\n        int VAR_37 = VAR_11;\n        /* COMMENT_28 */\n                                                     \n                                                                            \n                                                                                \n                  \n        if (VAR_0->flags & VAR_38 &&\n            VAR_0->cmd->proc != VAR_10 &&\n            VAR_0->cmd->proc != VAR_39 &&\n            VAR_0->cmd->proc != VAR_40) {\n            VAR_37 = 1;\n        }\n\n        if (VAR_35 && VAR_37) {\n            rejectCommand(VAR_0, VAR_2.oomerr);\n            return VAR_7;\n        }\n\n        /* COMMENT_33 */\n                                                                        \n                                        \n        if (VAR_0->cmd->proc == VAR_41 || VAR_0->cmd->proc == VAR_42) {\n            VAR_1.lua_oom = VAR_35;\n        }\n    }\n\n    /* COMMENT_36 */\n                           \n    if (VAR_1.tracking_clients) trackingLimitUsedSlots();\n\n    /* COMMENT_38 */\n                                           \n    int VAR_43 = writeCommandsDeniedByDiskError();\n    if (VAR_43 != VAR_44 &&\n        VAR_1.masterhost == NULL &&\n        (VAR_8 ||VAR_0->cmd->proc == VAR_45))\n    {\n        if (VAR_43 == VAR_46)\n            rejectCommand(VAR_0, VAR_2.bgsaveerr);\n        else\n            rejectCommandFormat(VAR_0,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(VAR_1.aof_last_write_errno));\n        return VAR_7;\n    }\n\n    /* COMMENT_40 */\n                                                         \n    if (VAR_1.masterhost == NULL &&\n        VAR_1.repl_min_slaves_to_write &&\n        VAR_1.repl_min_slaves_max_lag &&\n        VAR_8 &&\n        VAR_1.repl_good_slaves_count < VAR_1.repl_min_slaves_to_write)\n    {\n        rejectCommand(VAR_0, VAR_2.noreplicaserr);\n        return VAR_7;\n    }\n\n    /* COMMENT_42 */\n                                                      \n    if (VAR_1.masterhost && VAR_1.repl_slave_ro &&\n        !(VAR_0->flags & VAR_30) &&\n        VAR_8)\n    {\n        rejectCommand(VAR_0, VAR_2.roslaveerr);\n        return VAR_7;\n    }\n\n    /* COMMENT_44 */\n                                                                      \n    if ((VAR_0->flags & VAR_47 && VAR_0->resp == 2) &&\n        VAR_0->cmd->proc != VAR_45 &&\n        VAR_0->cmd->proc != VAR_48 &&\n        VAR_0->cmd->proc != VAR_49 &&\n        VAR_0->cmd->proc != VAR_50 &&\n        VAR_0->cmd->proc != VAR_51 &&\n        VAR_0->cmd->proc != VAR_40) {\n        rejectCommandFormat(VAR_0,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\",\n            VAR_0->cmd->name);\n        return VAR_7;\n    }\n\n    /* COMMENT_46 */\n                                                                         \n                           \n    if (VAR_1.masterhost && VAR_1.repl_state != VAR_52 &&\n        VAR_1.repl_serve_stale_data == 0 &&\n        VAR_13)\n    {\n        rejectCommand(VAR_0, VAR_2.masterdownerr);\n        return VAR_7;\n    }\n\n    /* COMMENT_49 */\n                           \n    if (VAR_1.loading && VAR_15) {\n        rejectCommand(VAR_0, VAR_2.loadingerr);\n        return VAR_7;\n    }\n\n    /* COMMENT_51 */\n                                                                              \n                                                                             \n                                                                      \n                                                                      \n                                        \n    if (VAR_1.lua_timedout &&\n          VAR_0->cmd->proc != VAR_53 &&\n          VAR_0->cmd->proc != VAR_54 &&\n          VAR_0->cmd->proc != VAR_55 &&\n          VAR_0->cmd->proc != VAR_56 &&\n          VAR_0->cmd->proc != VAR_39 &&\n          VAR_0->cmd->proc != VAR_57 &&\n          VAR_0->cmd->proc != VAR_58 &&\n\t  VAR_0->cmd->proc != VAR_40 &&\n        !(VAR_0->cmd->proc == VAR_59 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'n') &&\n        !(VAR_0->cmd->proc == VAR_60 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(VAR_0, VAR_2.slowscripterr);\n        return VAR_7;\n    }\n\n    /* COMMENT_57 */\n                                                         \n    if (!(VAR_0->flags & VAR_61) && \n        ((VAR_1.client_pause_type == VAR_62) ||\n        (VAR_1.client_pause_type == VAR_63 && VAR_17)))\n    {\n        VAR_0->bpop.timeout = 0;\n        blockClient(VAR_0,VAR_64);\n        return VAR_7;       \n    }\n\n    /* COMMENT_59 */\n    if (VAR_0->flags & VAR_38 &&\n        VAR_0->cmd->proc != VAR_10 && VAR_0->cmd->proc != VAR_39 &&\n        VAR_0->cmd->proc != VAR_56 && VAR_0->cmd->proc != VAR_57 &&\n        VAR_0->cmd->proc != VAR_40)\n    {\n        queueMultiCommand(VAR_0);\n        addReply(VAR_0,VAR_2.queued);\n    } else {\n        call(VAR_0,VAR_65);\n        VAR_0->woff = VAR_1.master_repl_offset;\n        if (listLength(VAR_1.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n\n    return VAR_7;\n}",
  "func_graph_path_before": "redis/6cbea7d29b5285692843bc1c351abba1a7ef326f/server.c/vul/before/0.json",
  "func": "int processCommand(client *c) {\n    if (!server.lua_timedout) {\n        /* Both EXEC and EVAL call call() directly so there should be\n         * no way in_exec or in_eval or propagate_in_transaction is 1.\n         * That is unless lua_timedout, in which case client may run\n         * some commands. */\n        serverAssert(!server.propagate_in_transaction);\n        serverAssert(!server.in_exec);\n        serverAssert(!server.in_eval);\n    }\n\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_read_command = (c->cmd->flags & CMD_READONLY) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_READONLY));\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n    int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||\n                                   (c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));\n\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    if (auth_required) {\n        /* AUTH and HELLO and no auth modules are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_errpos;\n    int acl_retval = ACLCheckAllPerm(c,&acl_errpos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_errpos,NULL);\n        switch (acl_retval) {\n        case ACL_DENIED_CMD:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n            break;\n        case ACL_DENIED_KEY:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n            break;\n        case ACL_DENIED_CHANNEL:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the channels used as arguments\");\n            break;\n        default:\n            rejectCommandFormat(c, \"no permission\");\n            break;\n        }\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(!cmdHasMovableKeys(c->cmd) && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            c->cmd->rejected_calls++;\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = (performEvictions() == EVICT_FAIL);\n        /* performEvictions may flush slave output buffers. This may result\n         * in a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand &&\n            c->cmd->proc != resetCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand &&\n        c->cmd->proc != resetCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n          c->cmd->proc != resetCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Prevent a replica from sending commands that access the keyspace.\n     * The main objective here is to prevent abuse of client pause check\n     * from which replicas are exempt. */\n    if ((c->flags & CLIENT_SLAVE) && (is_may_replicate_command || is_write_command || is_read_command)) {\n        rejectCommandFormat(c, \"Replica can't interract with the keyspace\");\n        return C_OK;\n    }\n\n    /* If the server is paused, block the client until\n     * the pause has ended. Replicas are never paused. */\n    if (!(c->flags & CLIENT_SLAVE) && \n        ((server.client_pause_type == CLIENT_PAUSE_ALL) ||\n        (server.client_pause_type == CLIENT_PAUSE_WRITE && is_may_replicate_command)))\n    {\n        c->bpop.timeout = 0;\n        blockClient(c,BLOCKED_PAUSE);\n        return C_OK;       \n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand &&\n        c->cmd->proc != resetCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n\n    return C_OK;\n}",
  "abstract_func": "int processCommand(client *VAR_0) {\n    if (!VAR_1.lua_timedout) {\n        /* COMMENT_0 */\n                                                                      \n                                                                    \n                            \n        serverAssert(!VAR_1.propagate_in_transaction);\n        serverAssert(!VAR_1.in_exec);\n        serverAssert(!VAR_1.in_eval);\n    }\n\n    moduleCallCommandFilters(VAR_0);\n\n    /* COMMENT_4 */\n                                                                      \n                                                                    \n                                 \n    if (!strcasecmp(VAR_0->argv[0]->ptr,\"quit\")) {\n        addReply(VAR_0,VAR_2.ok);\n        VAR_0->flags |= VAR_3;\n        return VAR_4;\n    }\n\n    /* COMMENT_8 */\n                                                             \n    VAR_0->cmd = VAR_0->lastcmd = lookupCommand(VAR_0->argv[0]->ptr);\n    if (!VAR_0->cmd) {\n        sds VAR_5 = sdsempty();\n        int VAR_6;\n        for (VAR_6=1; VAR_6 < VAR_0->argc && sdslen(VAR_5) < 128; VAR_6++)\n            VAR_5 = sdscatprintf(VAR_5, \"`%.*s`, \", 128-(int)sdslen(VAR_5), (char*)VAR_0->argv[VAR_6]->ptr);\n        rejectCommandFormat(VAR_0,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)VAR_0->argv[0]->ptr, VAR_5);\n        sdsfree(VAR_5);\n        return VAR_7;\n    } else if ((VAR_0->cmd->arity > 0 && VAR_0->cmd->arity != VAR_0->argc) ||\n               (VAR_0->argc < -VAR_0->cmd->arity)) {\n        rejectCommandFormat(VAR_0,\"wrong number of arguments for '%s' command\",\n            VAR_0->cmd->name);\n        return VAR_7;\n    }\n\n    int VAR_8 = (VAR_0->cmd->flags & VAR_9) ||\n                           (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_9));\n    int VAR_11 = (VAR_0->cmd->flags & VAR_12) ||\n                           (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_12));\n    int VAR_13 = (VAR_0->cmd->flags & VAR_14) ||\n                             (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_14));\n    int VAR_15 = !(VAR_0->cmd->flags & VAR_16) ||\n                               (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_16));\n    int VAR_17 = !(VAR_0->cmd->flags & VAR_18) ||\n                                 (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_18));\n    int VAR_19 = (VAR_0->cmd->flags & (VAR_12 | VAR_20)) ||\n                                   (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & (VAR_12 | VAR_20)));\n\n    /* COMMENT_10 */\n                                                                \n    int VAR_21 = (!(VAR_22->flags & VAR_23) ||\n                          (VAR_22->flags & VAR_24)) &&\n                        !VAR_0->authenticated;\n    if (VAR_21) {\n        /* COMMENT_12 */\n                                      \n        if (!(VAR_0->cmd->flags & VAR_25)) {\n            rejectCommand(VAR_0,VAR_2.noautherr);\n            return VAR_7;\n        }\n    }\n\n    /* COMMENT_14 */\n               \n    int VAR_26;\n    int VAR_27 = ACLCheckAllPerm(VAR_0,&VAR_26);\n    if (VAR_27 != VAR_28) {\n        addACLLogEntry(VAR_0,VAR_27,VAR_26,NULL);\n        switch (VAR_27) {\n        case VAR_29:\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", VAR_0->cmd->name);\n            break;\n        case VAR_30:\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n            break;\n        case VAR_31:\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the channels used as arguments\");\n            break;\n        default:\n            rejectCommandFormat(VAR_0, \"no permission\");\n            break;\n        }\n        return VAR_7;\n    }\n\n    /* COMMENT_16 */\n                                                   \n                                                   \n                                              \n    if (VAR_1.cluster_enabled &&\n        !(VAR_0->flags & VAR_32) &&\n        !(VAR_0->flags & VAR_33 &&\n          VAR_1.lua_caller->flags & VAR_32) &&\n        !(!cmdHasMovableKeys(VAR_0->cmd) && VAR_0->cmd->firstkey == 0 &&\n          VAR_0->cmd->proc != VAR_10))\n    {\n        int VAR_34;\n        int VAR_35;\n        clusterNode *VAR_36 = getNodeByQuery(VAR_0,VAR_0->cmd,VAR_0->argv,VAR_0->argc,\n                                        &VAR_34,&VAR_35);\n        if (VAR_36 == NULL || VAR_36 != VAR_1.cluster->myself) {\n            if (VAR_0->cmd->proc == VAR_10) {\n                discardTransaction(VAR_0);\n            } else {\n                flagTransaction(VAR_0);\n            }\n            clusterRedirectClient(VAR_0,VAR_36,VAR_34,VAR_35);\n            VAR_0->cmd->rejected_calls++;\n            return VAR_7;\n        }\n    }\n\n    /* COMMENT_20 */\n      \n                                                                            \n                                                                         \n                                                                     \n                                              \n    if (VAR_1.maxmemory && !VAR_1.lua_timedout) {\n        int VAR_37 = (performEvictions() == VAR_38);\n        /* COMMENT_26 */\n                                                                     \n        if (VAR_1.current_client == NULL) return VAR_4;\n\n        int VAR_39 = VAR_13;\n        /* COMMENT_28 */\n                                                     \n                                                                            \n                                                                                \n                  \n        if (VAR_0->flags & VAR_40 &&\n            VAR_0->cmd->proc != VAR_10 &&\n            VAR_0->cmd->proc != VAR_41 &&\n            VAR_0->cmd->proc != VAR_42) {\n            VAR_39 = 1;\n        }\n\n        if (VAR_37 && VAR_39) {\n            rejectCommand(VAR_0, VAR_2.oomerr);\n            return VAR_7;\n        }\n\n        /* COMMENT_33 */\n                                                                        \n                                        \n        if (VAR_0->cmd->proc == VAR_43 || VAR_0->cmd->proc == VAR_44) {\n            VAR_1.lua_oom = VAR_37;\n        }\n    }\n\n    /* COMMENT_36 */\n                           \n    if (VAR_1.tracking_clients) trackingLimitUsedSlots();\n\n    /* COMMENT_38 */\n                                           \n    int VAR_45 = writeCommandsDeniedByDiskError();\n    if (VAR_45 != VAR_46 &&\n        VAR_1.masterhost == NULL &&\n        (VAR_11 ||VAR_0->cmd->proc == VAR_47))\n    {\n        if (VAR_45 == VAR_48)\n            rejectCommand(VAR_0, VAR_2.bgsaveerr);\n        else\n            rejectCommandFormat(VAR_0,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(VAR_1.aof_last_write_errno));\n        return VAR_7;\n    }\n\n    /* COMMENT_40 */\n                                                         \n    if (VAR_1.masterhost == NULL &&\n        VAR_1.repl_min_slaves_to_write &&\n        VAR_1.repl_min_slaves_max_lag &&\n        VAR_11 &&\n        VAR_1.repl_good_slaves_count < VAR_1.repl_min_slaves_to_write)\n    {\n        rejectCommand(VAR_0, VAR_2.noreplicaserr);\n        return VAR_7;\n    }\n\n    /* COMMENT_42 */\n                                                      \n    if (VAR_1.masterhost && VAR_1.repl_slave_ro &&\n        !(VAR_0->flags & VAR_32) &&\n        VAR_11)\n    {\n        rejectCommand(VAR_0, VAR_2.roslaveerr);\n        return VAR_7;\n    }\n\n    /* COMMENT_44 */\n                                                                      \n    if ((VAR_0->flags & VAR_49 && VAR_0->resp == 2) &&\n        VAR_0->cmd->proc != VAR_47 &&\n        VAR_0->cmd->proc != VAR_50 &&\n        VAR_0->cmd->proc != VAR_51 &&\n        VAR_0->cmd->proc != VAR_52 &&\n        VAR_0->cmd->proc != VAR_53 &&\n        VAR_0->cmd->proc != VAR_42) {\n        rejectCommandFormat(VAR_0,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\",\n            VAR_0->cmd->name);\n        return VAR_7;\n    }\n\n    /* COMMENT_46 */\n                                                                         \n                           \n    if (VAR_1.masterhost && VAR_1.repl_state != VAR_54 &&\n        VAR_1.repl_serve_stale_data == 0 &&\n        VAR_15)\n    {\n        rejectCommand(VAR_0, VAR_2.masterdownerr);\n        return VAR_7;\n    }\n\n    /* COMMENT_49 */\n                           \n    if (VAR_1.loading && VAR_17) {\n        rejectCommand(VAR_0, VAR_2.loadingerr);\n        return VAR_7;\n    }\n\n    /* COMMENT_51 */\n                                                                              \n                                                                             \n                                                                      \n                                                                      \n                                        \n    if (VAR_1.lua_timedout &&\n          VAR_0->cmd->proc != VAR_55 &&\n          VAR_0->cmd->proc != VAR_56 &&\n          VAR_0->cmd->proc != VAR_57 &&\n          VAR_0->cmd->proc != VAR_58 &&\n          VAR_0->cmd->proc != VAR_41 &&\n          VAR_0->cmd->proc != VAR_59 &&\n          VAR_0->cmd->proc != VAR_60 &&\n          VAR_0->cmd->proc != VAR_42 &&\n        !(VAR_0->cmd->proc == VAR_61 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'n') &&\n        !(VAR_0->cmd->proc == VAR_62 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(VAR_0, VAR_2.slowscripterr);\n        return VAR_7;\n    }\n\n    /* COMMENT_57 */\n                                                                        \n                                         \n    if ((VAR_0->flags & VAR_63) && (VAR_19 || VAR_11 || VAR_8)) {\n        rejectCommandFormat(VAR_0, \"Replica can't interract with the keyspace\");\n        return VAR_7;\n    }\n\n    /* COMMENT_60 */\n                                                         \n    if (!(VAR_0->flags & VAR_63) && \n        ((VAR_1.client_pause_type == VAR_64) ||\n        (VAR_1.client_pause_type == VAR_65 && VAR_19)))\n    {\n        VAR_0->bpop.timeout = 0;\n        blockClient(VAR_0,VAR_66);\n        return VAR_7;       \n    }\n\n    /* COMMENT_62 */\n    if (VAR_0->flags & VAR_40 &&\n        VAR_0->cmd->proc != VAR_10 && VAR_0->cmd->proc != VAR_41 &&\n        VAR_0->cmd->proc != VAR_58 && VAR_0->cmd->proc != VAR_59 &&\n        VAR_0->cmd->proc != VAR_42)\n    {\n        queueMultiCommand(VAR_0);\n        addReply(VAR_0,VAR_2.queued);\n    } else {\n        call(VAR_0,VAR_67);\n        VAR_0->woff = VAR_1.master_repl_offset;\n        if (listLength(VAR_1.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n\n    return VAR_7;\n}",
  "func_graph_path": "redis/6cbea7d29b5285692843bc1c351abba1a7ef326f/server.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,8 @@\n         return C_OK;\n     }\n \n+    int is_read_command = (c->cmd->flags & CMD_READONLY) ||\n+                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_READONLY));\n     int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                            (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n     int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n@@ -249,7 +251,7 @@\n           c->cmd->proc != discardCommand &&\n           c->cmd->proc != watchCommand &&\n           c->cmd->proc != unwatchCommand &&\n-\t  c->cmd->proc != resetCommand &&\n+          c->cmd->proc != resetCommand &&\n         !(c->cmd->proc == shutdownCommand &&\n           c->argc == 2 &&\n           tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n@@ -258,6 +260,14 @@\n           tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n     {\n         rejectCommand(c, shared.slowscripterr);\n+        return C_OK;\n+    }\n+\n+    /* Prevent a replica from sending commands that access the keyspace.\n+     * The main objective here is to prevent abuse of client pause check\n+     * from which replicas are exempt. */\n+    if ((c->flags & CLIENT_SLAVE) && (is_may_replicate_command || is_write_command || is_read_command)) {\n+        rejectCommandFormat(c, \"Replica can't interract with the keyspace\");\n         return C_OK;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t  c->cmd->proc != resetCommand &&"
    ],
    "added_lines": [
      "    int is_read_command = (c->cmd->flags & CMD_READONLY) ||",
      "                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_READONLY));",
      "          c->cmd->proc != resetCommand &&",
      "        return C_OK;",
      "    }",
      "",
      "    /* Prevent a replica from sending commands that access the keyspace.",
      "     * The main objective here is to prevent abuse of client pause check",
      "     * from which replicas are exempt. */",
      "    if ((c->flags & CLIENT_SLAVE) && (is_may_replicate_command || is_write_command || is_read_command)) {",
      "        rejectCommandFormat(c, \"Replica can't interract with the keyspace\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/8904",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/redis/redis/pull/8904: 403 Client Error: Forbidden for url: https://api.github.com/repos/redis/redis/pulls/8904",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}