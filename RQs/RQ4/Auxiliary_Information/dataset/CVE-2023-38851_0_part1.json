{
  "cve_id": "CVE-2023-38851",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "libxls",
  "commit_msg": "Fix buffer overflows when parsing style records\n\nCloses #124, #126.\n\nAccording to https://download.microsoft.com/download/5/0/1/501ED102-E53F-4CE0-AA6B-B0F93629DDC6/Office/Excel97-2007BinaryFileFormat(xls)Specification.pdf\na \"STYLE: Style Information (293h)\" record might be 4 or 3+ bytes\nlong, depending on the first word.\n\nWe need to check that we've read enough bytes for the whole\nrecord, so\n- first we check that we have a word at least,\n- then we check the subtype of the record.\n- If it is a built-in style, then it has 4 bytes, so we check that.\n- Otherwise the length of the name is in byte 3, so the whole record\n  is 3 + buf[3] bytes long. So we need at least three bytes before we\n  check the length in byte 3. Then we check if we have 3 + buf[3]\n  bytes.",
  "commit_hash": "c009fa87fc775f8cc63e85d2018223143cb200e6",
  "git_url": "https://github.com/libxls/libxls/commit/c009fa87fc775f8cc63e85d2018223143cb200e6",
  "file_path": "src/xls.c",
  "func_name": "xls_parseWorkBook",
  "func_before": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}",
  "abstract_func_before": "xls_error_t xls_parseWorkBook(xlsWorkBook* VAR_0)\n{\n    if(!VAR_0) return VAR_1;\n\n    BOF VAR_2 = { .id = 0, .size = 0 };\n    BOF VAR_3 = { .id = 0, .size = 0 };\n    BYTE* VAR_4 = NULL;\n\tBYTE VAR_5 = 0;\n    xls_error_t VAR_6 = VAR_7;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(VAR_8 > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)VAR_0->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    VAR_0->olestr->start, (unsigned int)VAR_0->olestr->pos,\n                    (unsigned int)VAR_0->olestr->size, (unsigned int)VAR_0->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&VAR_2, 1, 4, VAR_0->olestr) != 4) {\n            VAR_6 = VAR_9;\n            goto cleanup;\n        }\n        xlsConvertBof(&VAR_2);\n \t\tif(VAR_8) xls_showBOF(&VAR_2);\n\n        if (VAR_2.size) {\n            if ((VAR_4 = realloc(VAR_4, VAR_2.size)) == NULL) {\n                if (VAR_8) fprintf(VAR_10, \"Error: failed to allocate buffer of size %d\\n\", (int)VAR_2.size);\n                VAR_6 = VAR_11;\n                goto cleanup;\n            }\n            if (ole2_read(VAR_4, 1, VAR_2.size, VAR_0->olestr) != VAR_2.size) {\n                if (VAR_8) fprintf(VAR_10, \"Error: failed to read OLE block\\n\");\n                VAR_6 = VAR_9;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(VAR_0, &VAR_2)) {\n            VAR_6 = VAR_12;\n            goto cleanup;\n        }\n\n        switch (VAR_2.id) {\n        case VAR_13:\n            /* COMMENT_0 */\n            break;\n        case VAR_14:\t/* COMMENT_1 */\n            VAR_0->is5ver = (VAR_4[0] + (VAR_4[1] << 8) != 0x600);\n            VAR_0->type = VAR_4[2] + (VAR_4[3] << 8);\n            if(VAR_8) {\n                printf(\"version: %s\\n\", VAR_0->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", VAR_0->type);\n            }\n            break;\n\n        case VAR_15:\n            VAR_0->codepage = VAR_4[0] + (VAR_4[1] << 8);\n\t\t\tif(VAR_8) printf(\"codepage: %d\\n\", VAR_0->codepage);\n            break;\n\n        case VAR_16:\n\t\t\tif(VAR_5) {\n\t\t\t\tif (VAR_3.id==VAR_17) {\n\t\t\t\t\tif ((VAR_6 = xls_appendSST(VAR_0,VAR_4,VAR_2.size)) != VAR_7)\n                        goto cleanup;\n                }\n\t\t\t\tVAR_2=VAR_3;\n\t\t\t}\n            break;\n\n\t\tcase VAR_18:\n\t\t\t{\n\t\t\t\tWIND1 *VAR_19 = (WIND1*)VAR_4;\n                xlsConvertWindow(VAR_19);\n\t\t\t\tVAR_0->activeSheetIdx = VAR_19->itabCur;\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", VAR_19->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", VAR_19->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", VAR_19->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", VAR_19->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", VAR_19->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", VAR_19->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", VAR_19->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", VAR_19->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", VAR_19->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case VAR_17:\n\t\t\t/* COMMENT_2 */\n            xlsConvertSst((SST *)VAR_4);\n            if ((VAR_6 = xls_addSST(VAR_0,(SST*)VAR_4,VAR_2.size)) != VAR_7) {\n                goto cleanup;\n            }\n            break;\n\n        case VAR_20:\n            break;\n\n        case VAR_21:\n\t\t\t{\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tBOUNDSHEET *VAR_22 = (BOUNDSHEET *)VAR_4;\n                xlsConvertBoundsheet(VAR_22);\n\t\t\t\t/* COMMENT_4 */\n                if ((VAR_6 = xls_addSheet(VAR_0, VAR_22, VAR_2.size)) != VAR_7) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case VAR_23:\n\t\t\tif(VAR_0->is5ver) {\n\t\t\t\tXF5 *VAR_24;\n\t\t\t\tVAR_24 = (XF5 *)VAR_4;\n                xlsConvertXf5(VAR_24);\n\n\t\t\t\tif ((VAR_6 = xls_addXF5(VAR_0,VAR_24)) != VAR_7) {\n                    goto cleanup;\n                }\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", VAR_24->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", VAR_24->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", VAR_24->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", VAR_24->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", VAR_24->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", VAR_24->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", VAR_24->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", VAR_24->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *VAR_24;\n\t\t\t\tVAR_24 = (XF8 *)VAR_4;\n                xlsConvertXf8(VAR_24);\n\n\t\t\t\tif ((VAR_6 = xls_addXF8(VAR_0,VAR_24)) != VAR_7) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\txls_showXF(VAR_24);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case VAR_25:\n        case VAR_26:\n\t\t\t{\n\t\t\t\tchar *VAR_27;\n\t\t\t\tFONT *VAR_28 = (FONT*)VAR_4;\n                xlsConvertFont(VAR_28);\n\t\t\t\tVAR_27 = xls_addFont(VAR_0,VAR_28, VAR_2.size);\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\tprintf(\" height: %d\\n\", VAR_28->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", VAR_28->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", VAR_28->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", VAR_28->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", VAR_28->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", VAR_28->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", VAR_28->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", VAR_28->charset);\n\t\t\t\t\tif(VAR_27) printf(\"   name: %s\\n\", VAR_27);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case VAR_29:\n            xlsConvertFormat((FORMAT *)VAR_4);\n            if ((VAR_6 = xls_addFormat(VAR_0, (FORMAT*)VAR_4, VAR_2.size)) != VAR_7) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase VAR_30:\n\t\t\tif(VAR_8) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *VAR_31;\n\t\t\t\tVAR_31 = (void *)VAR_4;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", VAR_31->idx & 0x07FF);\n\t\t\t\tif(VAR_31->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", VAR_31->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", VAR_31->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *VAR_27 = get_string((char *)&VAR_4[2], VAR_2.size - 2, 1, VAR_0);\n\t\t\t\t\tprintf(\"  name=%s\\n\", VAR_27);\n                    free(VAR_27);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case VAR_32:\n\t\t\tif(VAR_8 > 10) {\n\t\t\t\tunsigned char *VAR_33 = VAR_4 + 2;\n\t\t\t\tint VAR_34, VAR_35;\n\n\t\t\t\tVAR_35 = VAR_4[0] + (VAR_4[1] << 8);\n\t\t\t\tfor(VAR_34=0; VAR_34<VAR_35; ++VAR_34) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", VAR_34+8, VAR_33[0], VAR_33[1], VAR_33[2] );\n\t\t\t\t\tVAR_33 += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_36:\n\t\t\tVAR_0->is1904 = *(BYTE *)VAR_4;\t/* COMMENT_5 */\n\t\t\tif(VAR_8) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", VAR_0->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_37:\n\t\t\tVAR_6 = VAR_38;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase VAR_39:\n\t\t\tif(VAR_8) {\n\t\t\t\tint VAR_40;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(VAR_40=0; VAR_40<VAR_2.size; ++VAR_40) printf(\"%2.2x \", VAR_4[VAR_40]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(VAR_8)\n\t\t\t{\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", VAR_2.id, VAR_2.size);\n\t\t\t}\n            break;\n        }\n        VAR_3=VAR_2;\n\t\tVAR_5=1;\n    }\n    while ((!VAR_0->olestr->eof)&&(VAR_2.id!=VAR_13));\n\ncleanup:\n    if (VAR_4)\n        free(VAR_4);\n\n    return VAR_6;\n}",
  "func_graph_path_before": "libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/before/1.json",
  "func": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}",
  "abstract_func": "xls_error_t xls_parseWorkBook(xlsWorkBook* VAR_0)\n{\n    if(!VAR_0) return VAR_1;\n\n    BOF VAR_2 = { .id = 0, .size = 0 };\n    BOF VAR_3 = { .id = 0, .size = 0 };\n    BYTE* VAR_4 = NULL;\n\tBYTE VAR_5 = 0;\n    xls_error_t VAR_6 = VAR_7;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(VAR_8 > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)VAR_0->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    VAR_0->olestr->start, (unsigned int)VAR_0->olestr->pos,\n                    (unsigned int)VAR_0->olestr->size, (unsigned int)VAR_0->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&VAR_2, 1, 4, VAR_0->olestr) != 4) {\n            VAR_6 = VAR_9;\n            goto cleanup;\n        }\n        xlsConvertBof(&VAR_2);\n \t\tif(VAR_8) xls_showBOF(&VAR_2);\n\n        if (VAR_2.size) {\n            if ((VAR_4 = realloc(VAR_4, VAR_2.size)) == NULL) {\n                if (VAR_8) fprintf(VAR_10, \"Error: failed to allocate buffer of size %d\\n\", (int)VAR_2.size);\n                VAR_6 = VAR_11;\n                goto cleanup;\n            }\n            if (ole2_read(VAR_4, 1, VAR_2.size, VAR_0->olestr) != VAR_2.size) {\n                if (VAR_8) fprintf(VAR_10, \"Error: failed to read OLE block\\n\");\n                VAR_6 = VAR_9;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(VAR_0, &VAR_2, VAR_4)) {\n            VAR_6 = VAR_12;\n            goto cleanup;\n        }\n\n        switch (VAR_2.id) {\n        case VAR_13:\n            /* COMMENT_0 */\n            break;\n        case VAR_14:\t/* COMMENT_1 */\n            VAR_0->is5ver = (VAR_4[0] + (VAR_4[1] << 8) != 0x600);\n            VAR_0->type = VAR_4[2] + (VAR_4[3] << 8);\n            if(VAR_8) {\n                printf(\"version: %s\\n\", VAR_0->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", VAR_0->type);\n            }\n            break;\n\n        case VAR_15:\n            VAR_0->codepage = VAR_4[0] + (VAR_4[1] << 8);\n\t\t\tif(VAR_8) printf(\"codepage: %d\\n\", VAR_0->codepage);\n            break;\n\n        case VAR_16:\n\t\t\tif(VAR_5) {\n\t\t\t\tif (VAR_3.id==VAR_17) {\n\t\t\t\t\tif ((VAR_6 = xls_appendSST(VAR_0,VAR_4,VAR_2.size)) != VAR_7)\n                        goto cleanup;\n                }\n\t\t\t\tVAR_2=VAR_3;\n\t\t\t}\n            break;\n\n\t\tcase VAR_18:\n\t\t\t{\n\t\t\t\tWIND1 *VAR_19 = (WIND1*)VAR_4;\n                xlsConvertWindow(VAR_19);\n\t\t\t\tVAR_0->activeSheetIdx = VAR_19->itabCur;\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", VAR_19->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", VAR_19->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", VAR_19->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", VAR_19->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", VAR_19->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", VAR_19->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", VAR_19->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", VAR_19->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", VAR_19->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case VAR_17:\n\t\t\t/* COMMENT_2 */\n            xlsConvertSst((SST *)VAR_4);\n            if ((VAR_6 = xls_addSST(VAR_0,(SST*)VAR_4,VAR_2.size)) != VAR_7) {\n                goto cleanup;\n            }\n            break;\n\n        case VAR_20:\n            break;\n\n        case VAR_21:\n\t\t\t{\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tBOUNDSHEET *VAR_22 = (BOUNDSHEET *)VAR_4;\n                xlsConvertBoundsheet(VAR_22);\n\t\t\t\t/* COMMENT_4 */\n                if ((VAR_6 = xls_addSheet(VAR_0, VAR_22, VAR_2.size)) != VAR_7) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case VAR_23:\n\t\t\tif(VAR_0->is5ver) {\n\t\t\t\tXF5 *VAR_24;\n\t\t\t\tVAR_24 = (XF5 *)VAR_4;\n                xlsConvertXf5(VAR_24);\n\n\t\t\t\tif ((VAR_6 = xls_addXF5(VAR_0,VAR_24)) != VAR_7) {\n                    goto cleanup;\n                }\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", VAR_24->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", VAR_24->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", VAR_24->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", VAR_24->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", VAR_24->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", VAR_24->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", VAR_24->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", VAR_24->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *VAR_24;\n\t\t\t\tVAR_24 = (XF8 *)VAR_4;\n                xlsConvertXf8(VAR_24);\n\n\t\t\t\tif ((VAR_6 = xls_addXF8(VAR_0,VAR_24)) != VAR_7) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\txls_showXF(VAR_24);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case VAR_25:\n        case VAR_26:\n\t\t\t{\n\t\t\t\tchar *VAR_27;\n\t\t\t\tFONT *VAR_28 = (FONT*)VAR_4;\n                xlsConvertFont(VAR_28);\n\t\t\t\tVAR_27 = xls_addFont(VAR_0,VAR_28, VAR_2.size);\n\t\t\t\tif(VAR_8) {\n\t\t\t\t\tprintf(\" height: %d\\n\", VAR_28->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", VAR_28->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", VAR_28->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", VAR_28->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", VAR_28->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", VAR_28->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", VAR_28->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", VAR_28->charset);\n\t\t\t\t\tif(VAR_27) printf(\"   name: %s\\n\", VAR_27);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case VAR_29:\n            xlsConvertFormat((FORMAT *)VAR_4);\n            if ((VAR_6 = xls_addFormat(VAR_0, (FORMAT*)VAR_4, VAR_2.size)) != VAR_7) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase VAR_30:\n\t\t\tif(VAR_8) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *VAR_31;\n\t\t\t\tVAR_31 = (void *)VAR_4;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", VAR_31->idx & 0x07FF);\n\t\t\t\tif(VAR_31->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", VAR_31->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", VAR_31->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *VAR_27 = get_string((char *)&VAR_4[2], VAR_2.size - 2, 1, VAR_0);\n\t\t\t\t\tprintf(\"  name=%s\\n\", VAR_27);\n                    free(VAR_27);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case VAR_32:\n\t\t\tif(VAR_8 > 10) {\n\t\t\t\tunsigned char *VAR_33 = VAR_4 + 2;\n\t\t\t\tint VAR_34, VAR_35;\n\n\t\t\t\tVAR_35 = VAR_4[0] + (VAR_4[1] << 8);\n\t\t\t\tfor(VAR_34=0; VAR_34<VAR_35; ++VAR_34) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", VAR_34+8, VAR_33[0], VAR_33[1], VAR_33[2] );\n\t\t\t\t\tVAR_33 += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_36:\n\t\t\tVAR_0->is1904 = *(BYTE *)VAR_4;\t/* COMMENT_5 */\n\t\t\tif(VAR_8) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", VAR_0->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_37:\n\t\t\tVAR_6 = VAR_38;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase VAR_39:\n\t\t\tif(VAR_8) {\n\t\t\t\tint VAR_40;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(VAR_40=0; VAR_40<VAR_2.size; ++VAR_40) printf(\"%2.2x \", VAR_4[VAR_40]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(VAR_8)\n\t\t\t{\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", VAR_2.id, VAR_2.size);\n\t\t\t}\n            break;\n        }\n        VAR_3=VAR_2;\n\t\tVAR_5=1;\n    }\n    while ((!VAR_0->olestr->eof)&&(VAR_2.id!=VAR_13));\n\ncleanup:\n    if (VAR_4)\n        free(VAR_4);\n\n    return VAR_6;\n}",
  "func_graph_path": "libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,7 @@\n             }\n         }\n \n-        if (xls_isRecordTooSmall(pWB, &bof1)) {\n+        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n             retval = LIBXLS_ERROR_PARSE;\n             goto cleanup;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "        if (xls_isRecordTooSmall(pWB, &bof1)) {"
    ],
    "added_lines": [
      "        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libxls/libxls/pull/129",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libxls/libxls/pull/129: 403 Client Error: Forbidden for url: https://api.github.com/repos/libxls/libxls/pulls/129",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}