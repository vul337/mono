{
  "cve_id": "CVE-2021-36145",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "projectacrn/acrn-hypervisor",
  "commit_msg": "dm: rb: only free rb_entry when we remove this entry from the rb tree\n\nOnly free rb_entry when we remove this entry from the rb tree, otherwise, a\npage fault would trigger when next rb itreation would access the freed rb_entry.\n\nTracked-On: #6056\nSigned-off-by: Li Fei1 <fei1.li@intel.com>",
  "commit_hash": "f880086ffe5423e67d968c8f8f665954786582ce",
  "git_url": "https://github.com/projectacrn/acrn-hypervisor/commit/f880086ffe5423e67d968c8f8f665954786582ce",
  "file_path": "devicemodel/core/mem.c",
  "func_name": "unregister_mem_int",
  "func_before": "static int\nunregister_mem_int(struct mmio_rb_tree *rbt, struct mem_range *memp)\n{\n\tstruct mem_range *mr;\n\tstruct mmio_rb_range *entry = NULL;\n\tint err;\n\n\tpthread_rwlock_wrlock(&mmio_rwlock);\n\terr = mmio_rb_lookup(rbt, memp->base, &entry);\n\tif (err == 0) {\n\t\tmr = &entry->mr_param;\n\t\tif (strncmp(mr->name, memp->name, MEMNAMESZ)\n\t\t\t|| (mr->base != memp->base) || (mr->size != memp->size)\n\t\t\t|| ((mr->flags & MEM_F_IMMUTABLE) != 0)) {\n\t\t\terr = -1;\n\t\t} else {\n\t\t\tRB_REMOVE(mmio_rb_tree, rbt, entry);\n\n\t\t\t/* flush Per-VM cache */\n\t\t\tif (mmio_hint == entry)\n\t\t\t\tmmio_hint = NULL;\n\t\t}\n\t}\n\tpthread_rwlock_unlock(&mmio_rwlock);\n\n\tif (entry)\n\t\tfree(entry);\n\n\treturn err;\n}",
  "abstract_func_before": "static int\nunregister_mem_int(struct mmio_rb_tree *VAR_0, struct mem_range *VAR_1)\n{\n\tstruct mem_range *VAR_2;\n\tstruct mmio_rb_range *VAR_3 = NULL;\n\tint VAR_4;\n\n\tpthread_rwlock_wrlock(&VAR_5);\n\tVAR_4 = mmio_rb_lookup(VAR_0, VAR_1->base, &VAR_3);\n\tif (VAR_4 == 0) {\n\t\tVAR_2 = &VAR_3->mr_param;\n\t\tif (strncmp(VAR_2->name, VAR_1->name, VAR_6)\n\t\t\t|| (VAR_2->base != VAR_1->base) || (VAR_2->size != VAR_1->size)\n\t\t\t|| ((VAR_2->flags & VAR_7) != 0)) {\n\t\t\tVAR_4 = -1;\n\t\t} else {\n\t\t\tRB_REMOVE(mmio_rb_tree, VAR_0, VAR_3);\n\n\t\t\t/* COMMENT_0 */\n\t\t\tif (VAR_8 == VAR_3)\n\t\t\t\tVAR_8 = NULL;\n\t\t}\n\t}\n\tpthread_rwlock_unlock(&VAR_5);\n\n\tif (VAR_3)\n\t\tfree(VAR_3);\n\n\treturn VAR_4;\n}",
  "func_graph_path_before": "projectacrn/acrn-hypervisor/f880086ffe5423e67d968c8f8f665954786582ce/mem.c/vul/before/0.json",
  "func": "static int\nunregister_mem_int(struct mmio_rb_tree *rbt, struct mem_range *memp)\n{\n\tstruct mem_range *mr;\n\tstruct mmio_rb_range *entry = NULL;\n\tint err;\n\n\tpthread_rwlock_wrlock(&mmio_rwlock);\n\terr = mmio_rb_lookup(rbt, memp->base, &entry);\n\tif (err == 0) {\n\t\tmr = &entry->mr_param;\n\t\tif (strncmp(mr->name, memp->name, MEMNAMESZ)\n\t\t\t|| (mr->base != memp->base) || (mr->size != memp->size)\n\t\t\t|| ((mr->flags & MEM_F_IMMUTABLE) != 0)) {\n\t\t\terr = -1;\n\t\t} else {\n\t\t\tRB_REMOVE(mmio_rb_tree, rbt, entry);\n\n\t\t\t/* flush Per-VM cache */\n\t\t\tif (mmio_hint == entry)\n\t\t\t\tmmio_hint = NULL;\n\n\t\t\tif (entry)\n\t\t\t\tfree(entry);\n\t\t}\n\t}\n\tpthread_rwlock_unlock(&mmio_rwlock);\n\n\treturn err;\n}",
  "abstract_func": "static int\nunregister_mem_int(struct mmio_rb_tree *VAR_0, struct mem_range *VAR_1)\n{\n\tstruct mem_range *VAR_2;\n\tstruct mmio_rb_range *VAR_3 = NULL;\n\tint VAR_4;\n\n\tpthread_rwlock_wrlock(&VAR_5);\n\tVAR_4 = mmio_rb_lookup(VAR_0, VAR_1->base, &VAR_3);\n\tif (VAR_4 == 0) {\n\t\tVAR_2 = &VAR_3->mr_param;\n\t\tif (strncmp(VAR_2->name, VAR_1->name, VAR_6)\n\t\t\t|| (VAR_2->base != VAR_1->base) || (VAR_2->size != VAR_1->size)\n\t\t\t|| ((VAR_2->flags & VAR_7) != 0)) {\n\t\t\tVAR_4 = -1;\n\t\t} else {\n\t\t\tRB_REMOVE(mmio_rb_tree, VAR_0, VAR_3);\n\n\t\t\t/* COMMENT_0 */\n\t\t\tif (VAR_8 == VAR_3)\n\t\t\t\tVAR_8 = NULL;\n\n\t\t\tif (VAR_3)\n\t\t\t\tfree(VAR_3);\n\t\t}\n\t}\n\tpthread_rwlock_unlock(&VAR_5);\n\n\treturn VAR_4;\n}",
  "func_graph_path": "projectacrn/acrn-hypervisor/f880086ffe5423e67d968c8f8f665954786582ce/mem.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,12 +19,12 @@\n \t\t\t/* flush Per-VM cache */\n \t\t\tif (mmio_hint == entry)\n \t\t\t\tmmio_hint = NULL;\n+\n+\t\t\tif (entry)\n+\t\t\t\tfree(entry);\n \t\t}\n \t}\n \tpthread_rwlock_unlock(&mmio_rwlock);\n \n-\tif (entry)\n-\t\tfree(entry);\n-\n \treturn err;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (entry)",
      "\t\tfree(entry);",
      ""
    ],
    "added_lines": [
      "",
      "\t\t\tif (entry)",
      "\t\t\t\tfree(entry);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/projectacrn/acrn-hypervisor/pull/6058",
  "description": {
    "pr_info": {
      "title": "release_2.5: dm: rb: only free rb_entry when we remove this entry from the rb tree",
      "number": 6058
    },
    "comment": [
      "Only free rb_entry when we remove this entry from the rb tree, otherwise, a\r\npage fault would trigger when next rb itreation would access the freed rb_entry.\r\n\r\nTracked-On: #6056\r\nSigned-off-by: Li Fei1 <fei1.li@intel.com>",
      "No new violations to the coding guideline detected.<br>No New Name Conflict<br>No New Function Declaration/Definition Mismatch",
      "@fyin1 "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.7  \n\nThe analysis indicates that the fix addresses a resource management issue that could lead to crashes, which is a security concern. However, while it's a bug fix, there's some ambiguity in whether it's a security vulnerability. The lack of CVE reference lowers the confidence slightly."
}