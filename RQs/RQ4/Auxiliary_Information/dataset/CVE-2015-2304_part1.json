{
  "cve_id": "CVE-2015-2304",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "Add ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS option\n\nThis fixes a directory traversal in the cpio tool.",
  "commit_hash": "59357157706d47c365b2227739e17daba3607526",
  "git_url": "https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526",
  "file_path": "libarchive/archive_write_disk_posix.c",
  "func_name": "cleanup_pathname",
  "func_before": "static int\ncleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/')\n\t\tseparator = *src++;\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}",
  "abstract_func_before": "static int\ncleanup_pathname(struct archive_write_disk *VAR_0)\n{\n\tchar *VAR_1, *VAR_2;\n\tchar VAR_3 = '\\0';\n\n\tVAR_1 = VAR_2 = VAR_0->name;\n\tif (*VAR_2 == '\\0') {\n\t\tarchive_set_error(&VAR_0->archive, VAR_4,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (VAR_5);\n\t}\n\n#if defined(VAR_6)\n\tcleanup_pathname_win(VAR_0);\n#endif\n\t/* COMMENT_0 */\n\tif (*VAR_2 == '/')\n\t\tVAR_3 = *VAR_2++;\n\n\t/* COMMENT_1 */\n\tfor (;;) {\n\t\t/* COMMENT_2 */\n\t\tif (VAR_2[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (VAR_2[0] == '/') {\n\t\t\t/* COMMENT_3 */\n\t\t\tVAR_2++;\n\t\t\tcontinue;\n\t\t} else if (VAR_2[0] == '.') {\n\t\t\tif (VAR_2[1] == '\\0') {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tbreak;\n\t\t\t} else if (VAR_2[1] == '/') {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tVAR_2 += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (VAR_2[1] == '.') {\n\t\t\t\tif (VAR_2[2] == '/' || VAR_2[2] == '\\0') {\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tif (VAR_0->flags & VAR_7) {\n\t\t\t\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t\t\t\t    VAR_4,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (VAR_5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_7 */\n                                         \n                                \n                            \n                                       \n                                  \n       \n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_14 */\n\t\tif (VAR_3)\n\t\t\t*VAR_1++ = '/';\n\t\twhile (*VAR_2 != '\\0' && *VAR_2 != '/') {\n\t\t\t*VAR_1++ = *VAR_2++;\n\t\t}\n\n\t\tif (*VAR_2 == '\\0')\n\t\t\tbreak;\n\n\t\t/* COMMENT_15 */\n\t\tVAR_3 = *VAR_2++;\n\t}\n\t/* COMMENT_16 */\n                                                                   \n              \n    \n\tif (VAR_1 == VAR_0->name) {\n\t\t/* COMMENT_20 */\n                                                           \n                                               \n     \n\t\tif (VAR_3)\n\t\t\t*VAR_1++ = '/';\n\t\telse\n\t\t\t*VAR_1++ = '.';\n\t}\n\t/* COMMENT_24 */\n\t*VAR_1 = '\\0';\n\treturn (VAR_8);\n}",
  "func_graph_path_before": "libarchive/59357157706d47c365b2227739e17daba3607526/archive_write_disk_posix.c/vul/before/0.json",
  "func": "static int\ncleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/') {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}",
  "abstract_func": "static int\ncleanup_pathname(struct archive_write_disk *VAR_0)\n{\n\tchar *VAR_1, *VAR_2;\n\tchar VAR_3 = '\\0';\n\n\tVAR_1 = VAR_2 = VAR_0->name;\n\tif (*VAR_2 == '\\0') {\n\t\tarchive_set_error(&VAR_0->archive, VAR_4,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (VAR_5);\n\t}\n\n#if defined(VAR_6)\n\tcleanup_pathname_win(VAR_0);\n#endif\n\t/* COMMENT_0 */\n\tif (*VAR_2 == '/') {\n\t\tif (VAR_0->flags & VAR_7) {\n\t\t\tarchive_set_error(&VAR_0->archive, VAR_4,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (VAR_5);\n\t\t}\n\n\t\tVAR_3 = *VAR_2++;\n\t}\n\n\t/* COMMENT_1 */\n\tfor (;;) {\n\t\t/* COMMENT_2 */\n\t\tif (VAR_2[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (VAR_2[0] == '/') {\n\t\t\t/* COMMENT_3 */\n\t\t\tVAR_2++;\n\t\t\tcontinue;\n\t\t} else if (VAR_2[0] == '.') {\n\t\t\tif (VAR_2[1] == '\\0') {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tbreak;\n\t\t\t} else if (VAR_2[1] == '/') {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tVAR_2 += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (VAR_2[1] == '.') {\n\t\t\t\tif (VAR_2[2] == '/' || VAR_2[2] == '\\0') {\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tif (VAR_0->flags & VAR_8) {\n\t\t\t\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t\t\t\t    VAR_4,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (VAR_5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_7 */\n                                         \n                                \n                            \n                                       \n                                  \n       \n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_14 */\n\t\tif (VAR_3)\n\t\t\t*VAR_1++ = '/';\n\t\twhile (*VAR_2 != '\\0' && *VAR_2 != '/') {\n\t\t\t*VAR_1++ = *VAR_2++;\n\t\t}\n\n\t\tif (*VAR_2 == '\\0')\n\t\t\tbreak;\n\n\t\t/* COMMENT_15 */\n\t\tVAR_3 = *VAR_2++;\n\t}\n\t/* COMMENT_16 */\n                                                                   \n              \n    \n\tif (VAR_1 == VAR_0->name) {\n\t\t/* COMMENT_20 */\n                                                           \n                                               \n     \n\t\tif (VAR_3)\n\t\t\t*VAR_1++ = '/';\n\t\telse\n\t\t\t*VAR_1++ = '.';\n\t}\n\t/* COMMENT_24 */\n\t*VAR_1 = '\\0';\n\treturn (VAR_9);\n}",
  "func_graph_path": "libarchive/59357157706d47c365b2227739e17daba3607526/archive_write_disk_posix.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,15 @@\n \tcleanup_pathname_win(a);\n #endif\n \t/* Skip leading '/'. */\n-\tif (*src == '/')\n+\tif (*src == '/') {\n+\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n+\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n+\t\t\t                  \"Path is absolute\");\n+\t\t\treturn (ARCHIVE_FAILED);\n+\t\t}\n+\n \t\tseparator = *src++;\n+\t}\n \n \t/* Scan the pathname one element at a time. */\n \tfor (;;) {",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (*src == '/')"
    ],
    "added_lines": [
      "\tif (*src == '/') {",
      "\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
      "\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
      "\t\t\t                  \"Path is absolute\");",
      "\t\t\treturn (ARCHIVE_FAILED);",
      "\t\t}",
      "",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/110",
  "description": {
    "pr_info": {
      "title": "Fix directory traversal in bsdcpio",
      "number": 110
    },
    "comment": [
      "This fixes a directory traversal issue in the cpio tool that was originally reported by [Alexander Cherepanov](https://groups.google.com/forum/#!msg/libarchive-discuss/dN9y1VvE1Qk/Z9uerigjQn0J).\n\nThe patch adds a new option `ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS` that disables extraction of absolute paths. It also provides a test case and updates the documentation.\n\nNote that I only implemented this for posix, because I don't have a windows machine to test this on.\n\nAlso, a [CVE id was requested for this issue](http://www.openwall.com/lists/oss-security/2015/01/16/7) but none has been assigned yet.\n",
      "This is a nice start.  The tests need a few more checks to verify that the security check really does prevent or not prevent the file creation.  (Right now, you're just verifying that the security check returns an error.)\n",
      "Should be fixed now. I use `assertFileExists(\"/tmp/abs\")`, then `unlink(\"/tmp/abs\")` in the test without the flag, and `assertFileNotExists(\"/tmp/abs\")` in the one with the flag.\n\nNot sure if using `unlink()` is ok though.\n",
      "If we're going to use a fixed name, we need to use one that is reasonably certain to not interfere with any other user of /tmp.  How about\n   /tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\n",
      "Sounds good to me. I just updated the PR.\n",
      "Thank you.  I'll merge this now; we will of course need to update this logic soon to identify absolute paths on Windows as well.\n",
      "CVE-2015-2304 was assigned for this at some point.OSVDB 117148 corresponds to this entry as well.\n",
      "I'm wondering if this fix is correct for the `cpio -dumpl <abspath>` case, used in quite a few scripts (FreeBSD ports's macro ${COPY_TREE_SHARE} as a prime example) to hardlink something from place a to b, falling back top copy if no hardlink is possible.\n\nThe error is thrown on the path that is the combination of the <abspath> argument and the relative path provided by stdin. So if input path is verified to be relative and abspath argument is identical to it's realpath, there is no issue and the error thrown is a false positive. Please correct me if I'm missing something here.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe patch clearly addresses a directory traversal vulnerability in the cpio tool by adding a security option to disable absolute path extraction. The confidence is high as all elements align with a security fix, despite the lack of a CVE."
}