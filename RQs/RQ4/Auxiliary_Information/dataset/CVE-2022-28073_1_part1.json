{
  "cve_id": "CVE-2022-28073",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix uaf crash in aaft (tests_64927) ##crash\n\nReported by giantbranch of NSFOCUS TIANJI Lab",
  "commit_hash": "59a9dfb60acf8b5c0312061cffd9693fc9526053",
  "git_url": "https://github.com/radareorg/radare2/commit/59a9dfb60acf8b5c0312061cffd9693fc9526053",
  "file_path": "libr/reg/rvalue.c",
  "func_name": "r_reg_set_value",
  "func_before": "R_API bool r_reg_set_value(RReg *reg, RRegItem *item, ut64 value) {\n\tut8 bytes[12];\n\tut8 *src = bytes;\n\tr_return_val_if_fail (reg && item, false);\n\n\tif (r_reg_is_readonly (reg, item)) {\n\t\treturn true;\n\t}\n\tif (item->offset < 0) {\n\t\treturn true;\n\t}\n\tRRegArena *arena = reg->regset[item->arena].arena;\n\tif (!arena) {\n\t\treturn false;\n\t}\n\tswitch (item->size) {\n\tcase 80:\n\tcase 96: // long floating value\n\t\tr_reg_set_longdouble (reg, item, (long double)value);\n\t\tbreak;\n\tcase 64:\n\t\tif (reg->big_endian) {\n\t\t\tr_write_be64 (src, value);\n\t\t} else {\n\t\t\tr_write_le64 (src, value);\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tif (reg->big_endian) {\n\t\t\tr_write_be32 (src, value);\n\t\t} else {\n\t\t\tr_write_le32 (src, value);\n\t\t}\n\t\tbreak;\n\tcase 16:\n\t\tif (reg->big_endian) {\n\t\t\tr_write_be16 (src, value);\n\t\t} else {\n\t\t\tr_write_le16 (src, value);\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tr_write_ble8 (src, (ut8) (value & UT8_MAX));\n\t\tbreak;\n\tcase 1:\n\t\tif (value) {\n\t\t\tut8 *buf = arena->bytes + (item->offset / 8);\n\t\t\tint bit = (item->offset % 8);\n\t\t\tut8 mask = (1 << bit);\n\t\t\tbuf[0] = (buf[0] & (0xff ^ mask)) | mask;\n\t\t} else {\n\t\t\tint idx = item->offset / 8;\n\t\t\tif (idx + item->size > arena->size) {\n\t\t\t\teprintf (\"RRegSetOverflow %d vs %d\\n\", idx + item->size, arena->size);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tut8 *buf = arena->bytes + idx;\n\t\t\tint bit = item->offset % 8;\n\t\t\tut8 mask = 0xff ^ (1 << bit);\n\t\t\tbuf[0] = (buf[0] & mask) | 0;\n\t\t}\n\t\treturn true;\n\tcase 128:\n\tcase 256:\n\t\t// XXX 128 & 256 bit\n\t\treturn false; // (ut64)r_reg_get_longdouble (reg, item);\n\tdefault:\n\t\teprintf (\"r_reg_set_value: Bit size %d not supported\\n\", item->size);\n\t\treturn false;\n\t}\n\tconst bool fits_in_arena = (arena->size - BITS2BYTES (item->offset) - BITS2BYTES (item->size)) >= 0;\n\tif (src && fits_in_arena) {\n\t\tr_mem_copybits (reg->regset[item->arena].arena->bytes +\n\t\t\t\tBITS2BYTES (item->offset),\n\t\t\t\tsrc, item->size);\n\t\treturn true;\n\t}\n\teprintf (\"r_reg_set_value: Cannot set %s to 0x%\" PFMT64x \"\\n\", item->name, value);\n\treturn false;\n}",
  "abstract_func_before": "R_API bool r_reg_set_value(RReg *VAR_0, RRegItem *VAR_1, ut64 VAR_2) {\n\tut8 VAR_3[12];\n\tut8 *VAR_4 = VAR_3;\n\tr_return_val_if_fail (VAR_0 && VAR_1, false);\n\n\tif (r_reg_is_readonly (VAR_0, VAR_1)) {\n\t\treturn true;\n\t}\n\tif (VAR_1->offset < 0) {\n\t\treturn true;\n\t}\n\tRRegArena *VAR_5 = VAR_0->regset[VAR_1->arena].arena;\n\tif (!VAR_5) {\n\t\treturn false;\n\t}\n\tswitch (VAR_1->size) {\n\tcase 80:\n\tcase 96: /* COMMENT_0 */\n\t\tr_reg_set_longdouble (VAR_0, VAR_1, (long double)VAR_2);\n\t\tbreak;\n\tcase 64:\n\t\tif (VAR_0->big_endian) {\n\t\t\tr_write_be64 (VAR_4, VAR_2);\n\t\t} else {\n\t\t\tr_write_le64 (VAR_4, VAR_2);\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tif (VAR_0->big_endian) {\n\t\t\tr_write_be32 (VAR_4, VAR_2);\n\t\t} else {\n\t\t\tr_write_le32 (VAR_4, VAR_2);\n\t\t}\n\t\tbreak;\n\tcase 16:\n\t\tif (VAR_0->big_endian) {\n\t\t\tr_write_be16 (VAR_4, VAR_2);\n\t\t} else {\n\t\t\tr_write_le16 (VAR_4, VAR_2);\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tr_write_ble8 (VAR_4, (ut8) (VAR_2 & VAR_6));\n\t\tbreak;\n\tcase 1:\n\t\tif (VAR_2) {\n\t\t\tut8 *VAR_7 = VAR_5->bytes + (VAR_1->offset / 8);\n\t\t\tint VAR_8 = (VAR_1->offset % 8);\n\t\t\tut8 VAR_9 = (1 << VAR_8);\n\t\t\tVAR_7[0] = (VAR_7[0] & (0xff ^ VAR_9)) | VAR_9;\n\t\t} else {\n\t\t\tint VAR_10 = VAR_1->offset / 8;\n\t\t\tif (VAR_10 + VAR_1->size > VAR_5->size) {\n\t\t\t\teprintf (\"RRegSetOverflow %d vs %d\\n\", VAR_10 + VAR_1->size, VAR_5->size);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tut8 *VAR_7 = VAR_5->bytes + VAR_10;\n\t\t\tint VAR_8 = VAR_1->offset % 8;\n\t\t\tut8 VAR_9 = 0xff ^ (1 << VAR_8);\n\t\t\tVAR_7[0] = (VAR_7[0] & VAR_9) | 0;\n\t\t}\n\t\treturn true;\n\tcase 128:\n\tcase 256:\n\t\t/* COMMENT_1 */\n\t\treturn false; /* COMMENT_2 */\n\tdefault:\n\t\teprintf (\"r_reg_set_value: Bit size %d not supported\\n\", VAR_1->size);\n\t\treturn false;\n\t}\n\tconst bool VAR_11 = (VAR_5->size - BITS2BYTES (VAR_1->offset) - BITS2BYTES (VAR_1->size)) >= 0;\n\tif (VAR_4 && VAR_11) {\n\t\tr_mem_copybits (VAR_0->regset[VAR_1->arena].arena->bytes +\n\t\t\t\tBITS2BYTES (VAR_1->offset),\n\t\t\t\tVAR_4, VAR_1->size);\n\t\treturn true;\n\t}\n\teprintf (\"r_reg_set_value: Cannot set %s to 0x%\" VAR_12 \"\\n\", VAR_1->name, VAR_2);\n\treturn false;\n}",
  "func_graph_path_before": null,
  "func": "R_API bool r_reg_set_value(RReg *reg, RRegItem *item, ut64 value) {\n\tr_return_val_if_fail (reg && item, false);\n\n\tut8 bytes[12];\n\tut8 *src = bytes;\n\n\tif (r_reg_is_readonly (reg, item)) {\n\t\treturn true;\n\t}\n\tif (item->offset < 0) {\n\t\treturn true;\n\t}\n\tRRegArena *arena = reg->regset[item->arena].arena;\n\tif (!arena) {\n\t\treturn false;\n\t}\n\tswitch (item->size) {\n\tcase 80:\n\tcase 96: // long floating value\n\t\tr_reg_set_longdouble (reg, item, (long double)value);\n\t\tbreak;\n\tcase 64:\n\t\tif (reg->big_endian) {\n\t\t\tr_write_be64 (src, value);\n\t\t} else {\n\t\t\tr_write_le64 (src, value);\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tif (reg->big_endian) {\n\t\t\tr_write_be32 (src, value);\n\t\t} else {\n\t\t\tr_write_le32 (src, value);\n\t\t}\n\t\tbreak;\n\tcase 16:\n\t\tif (reg->big_endian) {\n\t\t\tr_write_be16 (src, value);\n\t\t} else {\n\t\t\tr_write_le16 (src, value);\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tr_write_ble8 (src, (ut8) (value & UT8_MAX));\n\t\tbreak;\n\tcase 1:\n\t\tif (value) {\n\t\t\tut8 *buf = arena->bytes + (item->offset / 8);\n\t\t\tint bit = (item->offset % 8);\n\t\t\tut8 mask = (1 << bit);\n\t\t\tbuf[0] = (buf[0] & (0xff ^ mask)) | mask;\n\t\t} else {\n\t\t\tint idx = item->offset / 8;\n\t\t\tif (idx + item->size > arena->size) {\n\t\t\t\teprintf (\"RRegSetOverflow %d vs %d\\n\", idx + item->size, arena->size);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tut8 *buf = arena->bytes + idx;\n\t\t\tint bit = item->offset % 8;\n\t\t\tut8 mask = 0xff ^ (1 << bit);\n\t\t\tbuf[0] = (buf[0] & mask) | 0;\n\t\t}\n\t\treturn true;\n\tcase 128:\n\tcase 256:\n\t\t// XXX 128 & 256 bit\n\t\treturn false; // (ut64)r_reg_get_longdouble (reg, item);\n\tdefault:\n\t\teprintf (\"r_reg_set_value: Bit size %d not supported\\n\", item->size);\n\t\treturn false;\n\t}\n\tconst bool fits_in_arena = (arena->size - BITS2BYTES (item->offset) - BITS2BYTES (item->size)) >= 0;\n\tif (src && fits_in_arena) {\n\t\tr_mem_copybits (reg->regset[item->arena].arena->bytes +\n\t\t\t\tBITS2BYTES (item->offset),\n\t\t\t\tsrc, item->size);\n\t\treturn true;\n\t}\n\teprintf (\"r_reg_set_value: Cannot set %s to 0x%\" PFMT64x \"\\n\", item->name, value);\n\treturn false;\n}",
  "abstract_func": "R_API bool r_reg_set_value(RReg *VAR_0, RRegItem *VAR_1, ut64 VAR_2) {\n\tr_return_val_if_fail (VAR_0 && VAR_1, false);\n\n\tut8 VAR_3[12];\n\tut8 *VAR_4 = VAR_3;\n\n\tif (r_reg_is_readonly (VAR_0, VAR_1)) {\n\t\treturn true;\n\t}\n\tif (VAR_1->offset < 0) {\n\t\treturn true;\n\t}\n\tRRegArena *VAR_5 = VAR_0->regset[VAR_1->arena].arena;\n\tif (!VAR_5) {\n\t\treturn false;\n\t}\n\tswitch (VAR_1->size) {\n\tcase 80:\n\tcase 96: /* COMMENT_0 */\n\t\tr_reg_set_longdouble (VAR_0, VAR_1, (long double)VAR_2);\n\t\tbreak;\n\tcase 64:\n\t\tif (VAR_0->big_endian) {\n\t\t\tr_write_be64 (VAR_4, VAR_2);\n\t\t} else {\n\t\t\tr_write_le64 (VAR_4, VAR_2);\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tif (VAR_0->big_endian) {\n\t\t\tr_write_be32 (VAR_4, VAR_2);\n\t\t} else {\n\t\t\tr_write_le32 (VAR_4, VAR_2);\n\t\t}\n\t\tbreak;\n\tcase 16:\n\t\tif (VAR_0->big_endian) {\n\t\t\tr_write_be16 (VAR_4, VAR_2);\n\t\t} else {\n\t\t\tr_write_le16 (VAR_4, VAR_2);\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tr_write_ble8 (VAR_4, (ut8) (VAR_2 & VAR_6));\n\t\tbreak;\n\tcase 1:\n\t\tif (VAR_2) {\n\t\t\tut8 *VAR_7 = VAR_5->bytes + (VAR_1->offset / 8);\n\t\t\tint VAR_8 = (VAR_1->offset % 8);\n\t\t\tut8 VAR_9 = (1 << VAR_8);\n\t\t\tVAR_7[0] = (VAR_7[0] & (0xff ^ VAR_9)) | VAR_9;\n\t\t} else {\n\t\t\tint VAR_10 = VAR_1->offset / 8;\n\t\t\tif (VAR_10 + VAR_1->size > VAR_5->size) {\n\t\t\t\teprintf (\"RRegSetOverflow %d vs %d\\n\", VAR_10 + VAR_1->size, VAR_5->size);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tut8 *VAR_7 = VAR_5->bytes + VAR_10;\n\t\t\tint VAR_8 = VAR_1->offset % 8;\n\t\t\tut8 VAR_9 = 0xff ^ (1 << VAR_8);\n\t\t\tVAR_7[0] = (VAR_7[0] & VAR_9) | 0;\n\t\t}\n\t\treturn true;\n\tcase 128:\n\tcase 256:\n\t\t/* COMMENT_1 */\n\t\treturn false; /* COMMENT_2 */\n\tdefault:\n\t\teprintf (\"r_reg_set_value: Bit size %d not supported\\n\", VAR_1->size);\n\t\treturn false;\n\t}\n\tconst bool VAR_11 = (VAR_5->size - BITS2BYTES (VAR_1->offset) - BITS2BYTES (VAR_1->size)) >= 0;\n\tif (VAR_4 && VAR_11) {\n\t\tr_mem_copybits (VAR_0->regset[VAR_1->arena].arena->bytes +\n\t\t\t\tBITS2BYTES (VAR_1->offset),\n\t\t\t\tVAR_4, VAR_1->size);\n\t\treturn true;\n\t}\n\teprintf (\"r_reg_set_value: Cannot set %s to 0x%\" VAR_12 \"\\n\", VAR_1->name, VAR_2);\n\treturn false;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n R_API bool r_reg_set_value(RReg *reg, RRegItem *item, ut64 value) {\n+\tr_return_val_if_fail (reg && item, false);\n+\n \tut8 bytes[12];\n \tut8 *src = bytes;\n-\tr_return_val_if_fail (reg && item, false);\n \n \tif (r_reg_is_readonly (reg, item)) {\n \t\treturn true;",
  "diff_line_info": {
    "deleted_lines": [
      "\tr_return_val_if_fail (reg && item, false);"
    ],
    "added_lines": [
      "\tr_return_val_if_fail (reg && item, false);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19343",
  "description": {
    "pr_info": {
      "title": "Soft fixes2",
      "number": 19343
    },
    "comment": [
      "<!-- Please read the contributing guidelines:\r\n* https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\nIn short:\r\n* PR title must be capitalized, concise and use ##tags\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n**Checklist**\r\n\r\n- [ ] Closing issues: #issue\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [radare2book](https://github.com/radareorg/radare2book)\r\n\r\n**Description**\r\n\r\n<!-- Explain the **details** to understand the purpose of this contribution, with enough information to help us understand better the changes. -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit addresses a Use-after-free crash, a security issue, by adding a null check, thus preventing access to invalid pointers."
}