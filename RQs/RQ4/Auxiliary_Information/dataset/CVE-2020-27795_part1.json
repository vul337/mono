{
  "cve_id": "CVE-2020-27795",
  "cwe_ids": [
    "CWE-908"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix segfault in adf  (#16230)",
  "commit_hash": "4d3811681a80f92a53e795f6a64c4b0fc2c8dd22",
  "git_url": "https://github.com/radareorg/radare2/commit/4d3811681a80f92a53e795f6a64c4b0fc2c8dd22",
  "file_path": "libr/core/cmd_anal.c",
  "func_name": "anal_fcn_data",
  "func_before": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}",
  "abstract_func_before": "static bool anal_fcn_data (RCore *VAR_0, const char *VAR_1) {\n\tRAnalFunction *VAR_2 = r_anal_get_fcn_in (VAR_0->anal, VAR_0->offset, -1);\n\tut32 VAR_3 = r_anal_function_size_from_entry (VAR_2);\n\tif (VAR_2) {\n\t\tint VAR_4;\n\t\tbool VAR_5 = false;\n\t\tut64 VAR_6 = VAR_7;\n\t\tchar *VAR_8 = calloc (1, VAR_3);\n\t\tif (VAR_8) {\n\t\t\tRAnalBlock *VAR_9;\n\t\t\tRListIter *VAR_10;\n\t\t\tr_list_foreach (VAR_2->bbs, VAR_10, VAR_9) {\n\t\t\t\tint VAR_11 = VAR_9->addr - VAR_2->addr;\n\t\t\t\tint VAR_12 = R_MIN (VAR_11 + VAR_9->size, VAR_3);\n\t\t\t\tif (VAR_11 >= 0) {\n\t\t\t\t\twhile (VAR_11 < VAR_12) {\n\t\t\t\t\t\tVAR_8[VAR_11++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (VAR_4 = 0; VAR_4 < VAR_3; VAR_4++) {\n\t\t\tut64 VAR_13 = VAR_2->addr + VAR_4;\n\t\t\tif (VAR_8 && VAR_8[VAR_4]) {\n\t\t\t\tif (VAR_5) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"VAR_14\"\\n\", VAR_13 - VAR_6, VAR_6);\n\t\t\t\t\tVAR_5 = false;\n\t\t\t\t}\n\t\t\t\tVAR_6 = VAR_7;\n\t\t\t} else {\n\t\t\t\tif (!VAR_5) {\n\t\t\t\t\tVAR_5 = true;\n\t\t\t\t\tVAR_6 = VAR_13;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (VAR_5) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"VAR_14\"\\n\", VAR_2->addr + VAR_3 - VAR_6, VAR_6);\n\t\t}\n\t\tfree (VAR_8);\n\t\treturn true;\n\t}\n\treturn false;\n}",
  "func_graph_path_before": "radareorg/radare2/4d3811681a80f92a53e795f6a64c4b0fc2c8dd22/cmd_anal.c/vul/before/0.json",
  "func": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}",
  "abstract_func": "static bool anal_fcn_data (RCore *VAR_0, const char *VAR_1) {\n\tRAnalFunction *VAR_2 = r_anal_get_fcn_in (VAR_0->anal, VAR_0->offset, VAR_3);\n\tif (VAR_2) {\n\t\tint VAR_4;\n\t\tbool VAR_5 = false;\n\t\tut64 VAR_6 = VAR_7;\n\t\tut32 VAR_8 = r_anal_function_size_from_entry (VAR_2);\n\t\tchar *VAR_9 = calloc (1, VAR_8);\n\t\tif (VAR_9) {\n\t\t\tRAnalBlock *VAR_10;\n\t\t\tRListIter *VAR_11;\n\t\t\tr_list_foreach (VAR_2->bbs, VAR_11, VAR_10) {\n\t\t\t\tint VAR_12 = VAR_10->addr - VAR_2->addr;\n\t\t\t\tint VAR_13 = R_MIN (VAR_12 + VAR_10->size, VAR_8);\n\t\t\t\tif (VAR_12 >= 0) {\n\t\t\t\t\twhile (VAR_12 < VAR_13) {\n\t\t\t\t\t\tVAR_9[VAR_12++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (VAR_4 = 0; VAR_4 < VAR_8; VAR_4++) {\n\t\t\tut64 VAR_14 = VAR_2->addr + VAR_4;\n\t\t\tif (VAR_9 && VAR_9[VAR_4]) {\n\t\t\t\tif (VAR_5) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"VAR_15\"\\n\", VAR_14 - VAR_6, VAR_6);\n\t\t\t\t\tVAR_5 = false;\n\t\t\t\t}\n\t\t\t\tVAR_6 = VAR_7;\n\t\t\t} else {\n\t\t\t\tif (!VAR_5) {\n\t\t\t\t\tVAR_5 = true;\n\t\t\t\t\tVAR_6 = VAR_14;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (VAR_5) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"VAR_15\"\\n\", VAR_2->addr + VAR_8 - VAR_6, VAR_6);\n\t\t}\n\t\tfree (VAR_9);\n\t\treturn true;\n\t}\n\treturn false;\n}",
  "func_graph_path": "radareorg/radare2/4d3811681a80f92a53e795f6a64c4b0fc2c8dd22/cmd_anal.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n static bool anal_fcn_data (RCore *core, const char *input) {\n-\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n-\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n+\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);\n \tif (fcn) {\n \t\tint i;\n \t\tbool gap = false;\n \t\tut64 gap_addr = UT64_MAX;\n+\t\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n \t\tchar *bitmap = calloc (1, fcn_size);\n \t\tif (bitmap) {\n \t\t\tRAnalBlock *b;",
  "diff_line_info": {
    "deleted_lines": [
      "\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);",
      "\tut32 fcn_size = r_anal_function_size_from_entry (fcn);"
    ],
    "added_lines": [
      "\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ANY);",
      "\t\tut32 fcn_size = r_anal_function_size_from_entry (fcn);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/16230",
  "description": {
    "pr_info": {
      "title": "Fix segfault in adf ",
      "number": 16230
    },
    "comment": [
      " <!-- Filling this template is mandatory -->\r\n\r\n**Your checklist for this pull request**\r\n- [X] I've read the [guidelines for contributing](https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md) to this repository\r\n- [X] I made sure to follow the project's [coding style](https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md#code-style)\r\n- [X] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the documentation and the [radare2 book](https://github.com/radareorg/radare2book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\nSegmentation fault when `adf` is used without analysis\r\n\r\n**Test plan**\r\n\r\n<!-- What steps should the reviewer take to test your pull request? Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots/videos. This is your time to re-check that everything works and that you covered all the edge cases -->\r\n\r\n- Should not seg fault when using `adf` without analysis\r\n\r\n**Closing issues**\r\n\r\n<!-- put \"closes #XXXX\" in your comment to auto-close the issue that your PR fixes (if any). -->\r\n\r\nCloses #16215"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9"
}