{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveStaticFieldRefInto",
  "func_before": "void *    \nresolveStaticFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMStaticFieldRef *ramCPEntry)\n{\n\tvoid *staticAddress;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\ntryAgain:\n\tstaticAddress = NULL;\n\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tJ9Class *localClassAndFlags = NULL;\n\t\tUDATA initStatus = 0;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\ttargetClass = resolvedClass;\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\tgoto illegalAccess;\n\t\t}\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\tstaticAddress = staticFieldAddress(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t/* Stop if an exception occurred. */\n\t\tif (staticAddress != NULL) {\n\t\t\tmodifiers = field->modifiers;\n\t\t\tlocalClassAndFlags = definingClass;\n\t\t\tinitStatus = definingClass->initializeStatus;\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t/* save away field for callee */\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\n\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\t\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA) vmStruct) {\n\t\t\t\t\t/* Initialize the class if java code is allowed */\n\t\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\t\tUDATA preCount = javaVM->hotSwapCount;\n\n\t\t\t\t\t\tinitializeClass(vmStruct, definingClass);\n\t\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preCount != javaVM->hotSwapCount) {\n\t\t\t\t\t\t\tgoto tryAgain;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER) != 0 && (modifiers & J9AccFinal) != 0) {\n\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, lookupOptions | J9_LOOK_NO_NESTMATES);\n\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\ttargetClass = definingClass;\n\t\t\t\t\tbadMemberModifier = J9AccPrivate;\nillegalAccess:\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tif (canRunJavaCode && !threadEventsPending(vmStruct)) {\n\t\t\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (!finalFieldSetAllowed(vmStruct, true, method, definingClass, classFromCP, field, canRunJavaCode)) {\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t} else { /* finalFieldSetAllowed */\n\t\t\t\t\tif (jitCompileTimeResolve) {\n\t\t\t\t\t\t/* Don't report the final field modification for JIT compile-time resolves.\n\t\t\t\t\t\t * Reporting may deadlock due to interaction between safepoint and ClassUnloadMutex.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVM_VMHelpers::reportFinalFieldModified(vmStruct, definingClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* If this is a JIT compile-time resolve, do not allow fields declared in uninitialized classes. */\n\t\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (ramCPEntry != NULL) {\n\t\t\t\tUDATA localClassAndFlagsData = (UDATA)localClassAndFlags;\n\t\t\t\t/* Add bits to the class for base type and double wide field. */\n\t\t\t\tif ((modifiers & J9FieldFlagObject) != J9FieldFlagObject) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBaseType;\n\t\t\t\t\tif ((modifiers & J9FieldSizeDouble) == J9FieldSizeDouble) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefDouble;\n\t\t\t\t\t} else if (J9FieldTypeBoolean == (modifiers & J9FieldTypeMask)) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBoolean;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Set the volatile, final and setter bits in the flags as needed */\n\t\t\t\tif ((modifiers & J9AccVolatile) == J9AccVolatile) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefVolatile;\n\t\t\t\t}\n\t\t\t\tif ((modifiers & J9AccFinal) == J9AccFinal) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefFinal;\n\t\t\t\t}\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefPutResolved;\n\t\t\t\t}\n\t\t\t\t/* Swap the class address bits and the flag bits. */\n\t\t\t\tramCPEntry->flagsAndClass = J9FLAGSANDCLASS_FROM_CLASSANDFLAGS(localClassAndFlagsData);\n\t\t\t\t/* Set the high bit in valueOffset to ensure that a resolved static field ref is always interpreted as an unresolved instance fieldref. */\n\t\t\t\tramCPEntry->valueOffset = ((UDATA) staticAddress - (UDATA) localClassAndFlags->ramStatics) | (UDATA) IDATA_MIN;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveStaticFieldRef_Exit(vmStruct, staticAddress);\n\treturn staticAddress;\n}",
  "abstract_func_before": "void *    \nresolveStaticFieldRefInto(J9VMThread *VAR_0, J9Method *VAR_1, J9ConstantPool *VAR_2, UDATA VAR_3, UDATA VAR_4, J9ROMFieldShape **VAR_5, J9RAMStaticFieldRef *VAR_6)\n{\n\tvoid *VAR_7;\n\tJ9ROMFieldRef *VAR_8;\n\tJ9Class *VAR_9;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_4, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_4, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_4, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveStaticFieldRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);\n\ntryAgain:\n\tVAR_7 = NULL;\n\n\t/* COMMENT_0 */\n\tVAR_8 = (J9ROMFieldRef *)&VAR_2->romConstantPool[VAR_3];\n\tVAR_9 = resolveClassRef(VAR_0, VAR_2, VAR_8->classRefCPIndex, VAR_4);\n\t/* COMMENT_1 */\n\tif (VAR_9 != NULL) {\n\t\tJ9JavaVM *VAR_19 = VAR_0->javaVM;\n\t\tJ9Class *VAR_20 = J9_CLASS_FROM_CP(VAR_2);\n\t\tJ9ROMFieldShape *VAR_21;\n\t\tJ9Class *VAR_22;\n\t\tJ9ROMNameAndSignature *VAR_23;\n\t\tJ9UTF8 *VAR_24;\n\t\tJ9UTF8 *VAR_25;\n\t\tIDATA VAR_26 = VAR_27;\n\t\tIDATA VAR_28 = 0;\n\t\tJ9Class *VAR_29 = NULL;\n\t\tUDATA VAR_30 = 0;\n\t\tJ9Class *VAR_31 = NULL;\n\t\tUDATA VAR_32 = 0;\n\n\t\t/* COMMENT_2 */\n\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_9, VAR_9->romClass->modifiers, VAR_16);\n\t\tif (VAR_26 < VAR_33) {\n\t\t\tVAR_29 = VAR_9;\n\t\t\tVAR_28 = VAR_9->romClass->modifiers;\n\t\t\tgoto illegalAccess;\n\t\t}\n\n\t\t/* COMMENT_3 */\n\t\tVAR_23 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_8);\n\t\tVAR_24 = J9ROMNAMEANDSIGNATURE_NAME(VAR_23);\n\t\tVAR_25 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_23);\n\t\tVAR_7 = staticFieldAddress(VAR_0, VAR_9, J9UTF8_DATA(VAR_24), J9UTF8_LENGTH(VAR_24), J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), &VAR_22, (UDATA *)&VAR_21, VAR_16, VAR_20);\n\t\t/* COMMENT_4 */\n\t\tif (VAR_7 != NULL) {\n\t\t\tVAR_30 = VAR_21->modifiers;\n\t\t\tVAR_31 = VAR_22;\n\t\t\tVAR_32 = VAR_22->initializeStatus;\n\n\t\t\tif (VAR_5 != NULL) {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\t*VAR_5 = VAR_21;\n\t\t\t}\n\n\t\t\tif (J9_ARE_NO_BITS_SET(VAR_4, VAR_34)) {\n\t\t\t\tif (VAR_32 != VAR_35 && VAR_32 != (UDATA) VAR_0) {\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tif (VAR_12) {\n\t\t\t\t\t\tUDATA VAR_36 = VAR_19->hotSwapCount;\n\n\t\t\t\t\t\tinitializeClass(VAR_0, VAR_22);\n\t\t\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (VAR_36 != VAR_19->hotSwapCount) {\n\t\t\t\t\t\t\tgoto tryAgain;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_7 */\n\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((VAR_4 & VAR_37) != 0 && (VAR_30 & VAR_38) != 0) {\n\t\t\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_22, VAR_39, VAR_16 | VAR_40);\n\t\t\t\tif (VAR_26 < VAR_33) {\n\t\t\t\t\tVAR_29 = VAR_22;\n\t\t\t\t\tVAR_28 = VAR_39;\nillegalAccess:\n\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\tif (VAR_12 && !threadEventsPending(VAR_0)) {\n\t\t\t\t\t\tchar *VAR_41 = NULL;\n\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(VAR_0);\n\t\t\t\t\t\tif (VAR_27 == VAR_26) {\n\t\t\t\t\t\t\tVAR_41 = illegalAccessMessage(VAR_0, VAR_28, VAR_20, VAR_29, VAR_27);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVAR_41 = illegalAccessMessage(VAR_0, -1, VAR_20, VAR_29, VAR_26);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_42, VAR_41);\n\t\t\t\t\t\tj9mem_free_memory(VAR_41);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (!finalFieldSetAllowed(VAR_0, true, VAR_1, VAR_22, VAR_20, VAR_21, VAR_12)) {\n\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t} else { /* COMMENT_8 */\n\t\t\t\t\tif (VAR_10) {\n\t\t\t\t\t\t/* COMMENT_9 */\n                                                                                          \n         \n\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVM_VMHelpers::reportFinalFieldModified(VAR_0, VAR_22);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* COMMENT_12 */\n\t\t\tif ((VAR_19->runtimeFlags & VAR_43) != 0) {\n\t\t\t\tJ9ClassLoader *VAR_44 = VAR_20->classLoader;\n\t\t\t\tJ9ClassLoader *VAR_45 = VAR_22->classLoader;\n\n\t\t\t\tif (VAR_44 == NULL) {\n\t\t\t\t\tVAR_44 = VAR_19->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (VAR_44 != VAR_45) {\n\t\t\t\t\tJ9UTF8 *VAR_46 = J9ROMFIELDSHAPE_SIGNATURE(VAR_21);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(VAR_0, VAR_44, VAR_45, VAR_25, VAR_46) != 0) {\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_47, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* COMMENT_13 */\n\t\t\tif (VAR_10 && (VAR_35 != VAR_32)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (VAR_6 != NULL) {\n\t\t\t\tUDATA VAR_48 = (UDATA)VAR_31;\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tif ((VAR_30 & VAR_49) != VAR_49) {\n\t\t\t\t\tVAR_48 |= VAR_50;\n\t\t\t\t\tif ((VAR_30 & VAR_51) == VAR_51) {\n\t\t\t\t\t\tVAR_48 |= VAR_52;\n\t\t\t\t\t} else if (VAR_53 == (VAR_30 & VAR_54)) {\n\t\t\t\t\t\tVAR_48 |= VAR_55;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tif ((VAR_30 & VAR_56) == VAR_56) {\n\t\t\t\t\tVAR_48 |= VAR_57;\n\t\t\t\t}\n\t\t\t\tif ((VAR_30 & VAR_38) == VAR_38) {\n\t\t\t\t\tVAR_48 |= VAR_58;\n\t\t\t\t}\n\t\t\t\tif (0 != (VAR_4 & VAR_37)) {\n\t\t\t\t\tVAR_48 |= VAR_59;\n\t\t\t\t}\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\tVAR_6->flagsAndClass = J9FLAGSANDCLASS_FROM_CLASSANDFLAGS(VAR_48);\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_6->valueOffset = ((UDATA) VAR_7 - (UDATA) VAR_31->ramStatics) | (UDATA) VAR_60;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveStaticFieldRef_Exit(VAR_0, VAR_7);\n\treturn VAR_7;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/11.json",
  "func": "void *    \nresolveStaticFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMStaticFieldRef *ramCPEntry)\n{\n\tvoid *staticAddress;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\ntryAgain:\n\tstaticAddress = NULL;\n\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tJ9Class *localClassAndFlags = NULL;\n\t\tUDATA initStatus = 0;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\ttargetClass = resolvedClass;\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\tgoto illegalAccess;\n\t\t}\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\tstaticAddress = staticFieldAddress(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t/* Stop if an exception occurred. */\n\t\tif (staticAddress != NULL) {\n\t\t\tmodifiers = field->modifiers;\n\t\t\tlocalClassAndFlags = definingClass;\n\t\t\tinitStatus = definingClass->initializeStatus;\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t/* save away field for callee */\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\n\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\t\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA) vmStruct) {\n\t\t\t\t\t/* Initialize the class if java code is allowed */\n\t\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\t\tUDATA preCount = javaVM->hotSwapCount;\n\n\t\t\t\t\t\tinitializeClass(vmStruct, definingClass);\n\t\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preCount != javaVM->hotSwapCount) {\n\t\t\t\t\t\t\tgoto tryAgain;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER) != 0 && (modifiers & J9AccFinal) != 0) {\n\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, lookupOptions | J9_LOOK_NO_NESTMATES);\n\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\ttargetClass = definingClass;\n\t\t\t\t\tbadMemberModifier = J9AccPrivate;\nillegalAccess:\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tif (canRunJavaCode && !threadEventsPending(vmStruct)) {\n\t\t\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (!finalFieldSetAllowed(vmStruct, true, method, definingClass, classFromCP, field, canRunJavaCode)) {\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t} else { /* finalFieldSetAllowed */\n\t\t\t\t\tif (jitCompileTimeResolve) {\n\t\t\t\t\t\t/* Don't report the final field modification for JIT compile-time resolves.\n\t\t\t\t\t\t * Reporting may deadlock due to interaction between safepoint and ClassUnloadMutex.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVM_VMHelpers::reportFinalFieldModified(vmStruct, definingClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* If this is a JIT compile-time resolve, do not allow fields declared in uninitialized classes. */\n\t\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\tUDATA localClassAndFlagsData = (UDATA)localClassAndFlags;\n\t\t\t\t/* Add bits to the class for base type and double wide field. */\n\t\t\t\tif ((modifiers & J9FieldFlagObject) != J9FieldFlagObject) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBaseType;\n\t\t\t\t\tif ((modifiers & J9FieldSizeDouble) == J9FieldSizeDouble) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefDouble;\n\t\t\t\t\t} else if (J9FieldTypeBoolean == (modifiers & J9FieldTypeMask)) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBoolean;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Set the volatile, final and setter bits in the flags as needed */\n\t\t\t\tif ((modifiers & J9AccVolatile) == J9AccVolatile) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefVolatile;\n\t\t\t\t}\n\t\t\t\tif ((modifiers & J9AccFinal) == J9AccFinal) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefFinal;\n\t\t\t\t}\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefPutResolved;\n\t\t\t\t}\n\t\t\t\t/* Swap the class address bits and the flag bits. */\n\t\t\t\tramCPEntry->flagsAndClass = J9FLAGSANDCLASS_FROM_CLASSANDFLAGS(localClassAndFlagsData);\n\t\t\t\t/* Set the high bit in valueOffset to ensure that a resolved static field ref is always interpreted as an unresolved instance fieldref. */\n\t\t\t\tramCPEntry->valueOffset = ((UDATA) staticAddress - (UDATA) localClassAndFlags->ramStatics) | (UDATA) IDATA_MIN;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveStaticFieldRef_Exit(vmStruct, staticAddress);\n\treturn staticAddress;\n}",
  "abstract_func": "void *    \nresolveStaticFieldRefInto(J9VMThread *VAR_0, J9Method *VAR_1, J9ConstantPool *VAR_2, UDATA VAR_3, UDATA VAR_4, J9ROMFieldShape **VAR_5, J9RAMStaticFieldRef *VAR_6)\n{\n\tvoid *VAR_7;\n\tJ9ROMFieldRef *VAR_8;\n\tJ9Class *VAR_9;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_4, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_4, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_4, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveStaticFieldRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);\n\ntryAgain:\n\tVAR_7 = NULL;\n\n\t/* COMMENT_0 */\n\tVAR_8 = (J9ROMFieldRef *)&VAR_2->romConstantPool[VAR_3];\n\tVAR_9 = resolveClassRef(VAR_0, VAR_2, VAR_8->classRefCPIndex, VAR_4);\n\t/* COMMENT_1 */\n\tif (VAR_9 != NULL) {\n\t\tJ9JavaVM *VAR_19 = VAR_0->javaVM;\n\t\tJ9Class *VAR_20 = J9_CLASS_FROM_CP(VAR_2);\n\t\tJ9ROMFieldShape *VAR_21;\n\t\tJ9Class *VAR_22;\n\t\tJ9ROMNameAndSignature *VAR_23;\n\t\tJ9UTF8 *VAR_24;\n\t\tJ9UTF8 *VAR_25;\n\t\tIDATA VAR_26 = VAR_27;\n\t\tIDATA VAR_28 = 0;\n\t\tJ9Class *VAR_29 = NULL;\n\t\tUDATA VAR_30 = 0;\n\t\tJ9Class *VAR_31 = NULL;\n\t\tUDATA VAR_32 = 0;\n\n\t\t/* COMMENT_2 */\n\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_9, VAR_9->romClass->modifiers, VAR_16);\n\t\tif (VAR_26 < VAR_33) {\n\t\t\tVAR_29 = VAR_9;\n\t\t\tVAR_28 = VAR_9->romClass->modifiers;\n\t\t\tgoto illegalAccess;\n\t\t}\n\n\t\t/* COMMENT_3 */\n\t\tVAR_23 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_8);\n\t\tVAR_24 = J9ROMNAMEANDSIGNATURE_NAME(VAR_23);\n\t\tVAR_25 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_23);\n\t\tVAR_7 = staticFieldAddress(VAR_0, VAR_9, J9UTF8_DATA(VAR_24), J9UTF8_LENGTH(VAR_24), J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), &VAR_22, (UDATA *)&VAR_21, VAR_16, VAR_20);\n\t\t/* COMMENT_4 */\n\t\tif (VAR_7 != NULL) {\n\t\t\tVAR_30 = VAR_21->modifiers;\n\t\t\tVAR_31 = VAR_22;\n\t\t\tVAR_32 = VAR_22->initializeStatus;\n\n\t\t\tif (VAR_5 != NULL) {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\t*VAR_5 = VAR_21;\n\t\t\t}\n\n\t\t\tif (J9_ARE_NO_BITS_SET(VAR_4, VAR_34)) {\n\t\t\t\tif (VAR_32 != VAR_35 && VAR_32 != (UDATA) VAR_0) {\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tif (VAR_12) {\n\t\t\t\t\t\tUDATA VAR_36 = VAR_19->hotSwapCount;\n\n\t\t\t\t\t\tinitializeClass(VAR_0, VAR_22);\n\t\t\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (VAR_36 != VAR_19->hotSwapCount) {\n\t\t\t\t\t\t\tgoto tryAgain;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_7 */\n\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((VAR_4 & VAR_37) != 0 && (VAR_30 & VAR_38) != 0) {\n\t\t\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_22, VAR_39, VAR_16 | VAR_40);\n\t\t\t\tif (VAR_26 < VAR_33) {\n\t\t\t\t\tVAR_29 = VAR_22;\n\t\t\t\t\tVAR_28 = VAR_39;\nillegalAccess:\n\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\tif (VAR_12 && !threadEventsPending(VAR_0)) {\n\t\t\t\t\t\tchar *VAR_41 = NULL;\n\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(VAR_0);\n\t\t\t\t\t\tif (VAR_27 == VAR_26) {\n\t\t\t\t\t\t\tVAR_41 = illegalAccessMessage(VAR_0, VAR_28, VAR_20, VAR_29, VAR_27);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVAR_41 = illegalAccessMessage(VAR_0, -1, VAR_20, VAR_29, VAR_26);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_42, VAR_41);\n\t\t\t\t\t\tj9mem_free_memory(VAR_41);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (!finalFieldSetAllowed(VAR_0, true, VAR_1, VAR_22, VAR_20, VAR_21, VAR_12)) {\n\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t} else { /* COMMENT_8 */\n\t\t\t\t\tif (VAR_10) {\n\t\t\t\t\t\t/* COMMENT_9 */\n                                                                                          \n         \n\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVM_VMHelpers::reportFinalFieldModified(VAR_0, VAR_22);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* COMMENT_12 */\n\t\t\tif ((VAR_19->runtimeFlags & VAR_43) != 0) {\n\t\t\t\tJ9ClassLoader *VAR_44 = VAR_20->classLoader;\n\t\t\t\tJ9ClassLoader *VAR_45 = VAR_22->classLoader;\n\n\t\t\t\tif (VAR_44 == NULL) {\n\t\t\t\t\tVAR_44 = VAR_19->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (VAR_44 != VAR_45) {\n\t\t\t\t\tJ9UTF8 *VAR_46 = J9ROMFIELDSHAPE_SIGNATURE(VAR_21);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(VAR_0, VAR_44, VAR_45, VAR_25, VAR_46) != 0) {\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_47, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* COMMENT_13 */\n\t\t\tif (VAR_10 && (VAR_35 != VAR_32)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif ((NULL != VAR_6) && J9_ARE_NO_BITS_SET(VAR_4, VAR_48)) {\n\t\t\t\tUDATA VAR_49 = (UDATA)VAR_31;\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tif ((VAR_30 & VAR_50) != VAR_50) {\n\t\t\t\t\tVAR_49 |= VAR_51;\n\t\t\t\t\tif ((VAR_30 & VAR_52) == VAR_52) {\n\t\t\t\t\t\tVAR_49 |= VAR_53;\n\t\t\t\t\t} else if (VAR_54 == (VAR_30 & VAR_55)) {\n\t\t\t\t\t\tVAR_49 |= VAR_56;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tif ((VAR_30 & VAR_57) == VAR_57) {\n\t\t\t\t\tVAR_49 |= VAR_58;\n\t\t\t\t}\n\t\t\t\tif ((VAR_30 & VAR_38) == VAR_38) {\n\t\t\t\t\tVAR_49 |= VAR_59;\n\t\t\t\t}\n\t\t\t\tif (0 != (VAR_4 & VAR_37)) {\n\t\t\t\t\tVAR_49 |= VAR_60;\n\t\t\t\t}\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\tVAR_6->flagsAndClass = J9FLAGSANDCLASS_FROM_CLASSANDFLAGS(VAR_49);\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_6->valueOffset = ((UDATA) VAR_7 - (UDATA) VAR_31->ramStatics) | (UDATA) VAR_61;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveStaticFieldRef_Exit(VAR_0, VAR_7);\n\treturn VAR_7;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/11.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -146,7 +146,7 @@\n \t\t\t\tgoto done;\n \t\t\t}\n \n-\t\t\tif (ramCPEntry != NULL) {\n+\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\t\tUDATA localClassAndFlagsData = (UDATA)localClassAndFlags;\n \t\t\t\t/* Add bits to the class for base type and double wide field. */\n \t\t\t\tif ((modifiers & J9FieldFlagObject) != J9FieldFlagObject) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tif (ramCPEntry != NULL) {"
    ],
    "added_lines": [
      "\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}