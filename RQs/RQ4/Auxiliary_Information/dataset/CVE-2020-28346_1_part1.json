{
  "cve_id": "CVE-2020-28346",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "projectacrn/acrn-hypervisor",
  "commit_msg": "dm: virtio: check for paddr_guest2host return value\n\npaddr_guest2host can return NULL, but code paths in virtio\nare not checking the return value.\n_vq_record() initializes iov_base pointer using paddr_guest2host()\nbut there is nothing in the flow that checks for NULL.\nChane _vq_record to return -1 in case the address translation\nhas failed.\n\nTracked-On: #5452\nSigned-off-by: Tomas Winkler <tomas.winkler@intel.com>\nAcked-by: Wang, Yu1 <yu1.wang@intel.com>",
  "commit_hash": "ae0ab82434509d6e75f4a2f1e1a0dd2ee3dc3681",
  "git_url": "https://github.com/projectacrn/acrn-hypervisor/commit/ae0ab82434509d6e75f4a2f1e1a0dd2ee3dc3681",
  "file_path": "devicemodel/hw/pci/virtio/virtio.c",
  "func_name": "vq_getchain",
  "func_before": "int\nvq_getchain(struct virtio_vq_info *vq, uint16_t *pidx,\n\t    struct iovec *iov, int n_iov, uint16_t *flags)\n{\n\tint i;\n\tu_int ndesc, n_indir;\n\tu_int idx, next;\n\n\tvolatile struct vring_desc *vdir, *vindir, *vp;\n\tstruct vmctx *ctx;\n\tstruct virtio_base *base;\n\tconst char *name;\n\n\tbase = vq->base;\n\tname = base->vops->name;\n\n\t/*\n\t * Note: it's the responsibility of the guest not to\n\t * update vq->avail->idx until all of the descriptors\n\t * the guest has written are valid (including all their\n\t * next fields and vd_flags).\n\t *\n\t * Compute (last_avail - idx) in integers mod 2**16.  This is\n\t * the number of descriptors the device has made available\n\t * since the last time we updated vq->last_avail.\n\t *\n\t * We just need to do the subtraction as an unsigned int,\n\t * then trim off excess bits.\n\t */\n\tidx = vq->last_avail;\n\tndesc = (uint16_t)((u_int)vq->avail->idx - idx);\n\tif (ndesc == 0)\n\t\treturn 0;\n\tif (ndesc > vq->qsize) {\n\t\t/* XXX need better way to diagnose issues */\n\t\tpr_err(\"%s: ndesc (%u) out of range, driver confused?\\r\\n\",\n\t\t    name, (u_int)ndesc);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now count/parse \"involved\" descriptors starting from\n\t * the head of the chain.\n\t *\n\t * To prevent loops, we could be more complicated and\n\t * check whether we're re-visiting a previously visited\n\t * index, but we just abort if the count gets excessive.\n\t */\n\tctx = base->dev->vmctx;\n\t*pidx = next = vq->avail->ring[idx & (vq->qsize - 1)];\n\tvq->last_avail++;\n\tfor (i = 0; i < VQ_MAX_DESCRIPTORS; next = vdir->next) {\n\t\tif (next >= vq->qsize) {\n\t\t\tpr_err(\"%s: descriptor index %u out of range, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    name, next);\n\t\t\treturn -1;\n\t\t}\n\t\tvdir = &vq->desc[next];\n\t\tif ((vdir->flags & VRING_DESC_F_INDIRECT) == 0) {\n\t\t\t_vq_record(i, vdir, ctx, iov, n_iov, flags);\n\t\t\ti++;\n\t\t} else if ((base->device_caps &\n\t\t    (1 << VIRTIO_RING_F_INDIRECT_DESC)) == 0) {\n\t\t\tpr_err(\"%s: descriptor has forbidden INDIRECT flag, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    name);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tn_indir = vdir->len / 16;\n\t\t\tif ((vdir->len & 0xf) || n_indir == 0) {\n\t\t\t\tpr_err(\"%s: invalid indir len 0x%x, \"\n\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t    name, (u_int)vdir->len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tvindir = paddr_guest2host(ctx,\n\t\t\t    vdir->addr, vdir->len);\n\t\t\t/*\n\t\t\t * Indirects start at the 0th, then follow\n\t\t\t * their own embedded \"next\"s until those run\n\t\t\t * out.  Each one's indirect flag must be off\n\t\t\t * (we don't really have to check, could just\n\t\t\t * ignore errors...).\n\t\t\t */\n\t\t\tnext = 0;\n\t\t\tfor (;;) {\n\t\t\t\tvp = &vindir[next];\n\t\t\t\tif (vp->flags & VRING_DESC_F_INDIRECT) {\n\t\t\t\t\tpr_err(\"%s: indirect desc has INDIR flag,\"\n\t\t\t\t\t    \" driver confused?\\r\\n\",\n\t\t\t\t\t    name);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t_vq_record(i, vp, ctx, iov, n_iov, flags);\n\t\t\t\tif (++i > VQ_MAX_DESCRIPTORS)\n\t\t\t\t\tgoto loopy;\n\t\t\t\tif ((vp->flags & VRING_DESC_F_NEXT) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tnext = vp->next;\n\t\t\t\tif (next >= n_indir) {\n\t\t\t\t\tpr_err(\"%s: invalid next %u > %u, \"\n\t\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t\t    name, (u_int)next, n_indir);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((vdir->flags & VRING_DESC_F_NEXT) == 0)\n\t\t\treturn i;\n\t}\nloopy:\n\tpr_err(\"%s: descriptor loop? count > %d - driver confused?\\r\\n\",\n\t    name, i);\n\treturn -1;\n}",
  "abstract_func_before": "int\nvq_getchain(struct virtio_vq_info *VAR_0, uint16_t *VAR_1,\n\t    struct iovec *VAR_2, int VAR_3, uint16_t *VAR_4)\n{\n\tint VAR_5;\n\tu_int VAR_6, VAR_7;\n\tu_int VAR_8, VAR_9;\n\n\tvolatile struct vring_desc *VAR_10, *VAR_11, *VAR_12;\n\tstruct vmctx *VAR_13;\n\tstruct virtio_base *VAR_14;\n\tconst char *VAR_15;\n\n\tVAR_14 = VAR_0->base;\n\tVAR_15 = VAR_14->vops->name;\n\n\t/* COMMENT_0 */\n                                                     \n                                                      \n                                                        \n                              \n   \n                                                              \n                                                           \n                                                  \n   \n                                                          \n                              \n    \n\tVAR_8 = VAR_0->last_avail;\n\tVAR_6 = (uint16_t)((u_int)VAR_0->avail->idx - VAR_8);\n\tif (VAR_6 == 0)\n\t\treturn 0;\n\tif (VAR_6 > VAR_0->qsize) {\n\t\t/* COMMENT_12 */\n\t\tpr_err(\"%s: ndesc (%u) out of range, driver confused?\\r\\n\",\n\t\t    VAR_15, (u_int)VAR_6);\n\t\treturn -1;\n\t}\n\n\t/* COMMENT_13 */\n                                                        \n                          \n   \n                                                      \n                                                        \n                                                         \n    \n\tVAR_13 = VAR_14->dev->vmctx;\n\t*VAR_1 = VAR_9 = VAR_0->avail->ring[VAR_8 & (VAR_0->qsize - 1)];\n\tVAR_0->last_avail++;\n\tfor (VAR_5 = 0; VAR_5 < VAR_16; VAR_9 = VAR_10->next) {\n\t\tif (VAR_9 >= VAR_0->qsize) {\n\t\t\tpr_err(\"%s: descriptor index %u out of range, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    VAR_15, VAR_9);\n\t\t\treturn -1;\n\t\t}\n\t\tVAR_10 = &VAR_0->desc[VAR_9];\n\t\tif ((VAR_10->flags & VAR_17) == 0) {\n\t\t\t_vq_record(VAR_5, VAR_10, VAR_13, VAR_2, VAR_3, VAR_4);\n\t\t\tVAR_5++;\n\t\t} else if ((VAR_14->device_caps &\n\t\t    (1 << VAR_18)) == 0) {\n\t\t\tpr_err(\"%s: descriptor has forbidden INDIRECT flag, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    VAR_15);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tVAR_7 = VAR_10->len / 16;\n\t\t\tif ((VAR_10->len & 0xf) || VAR_7 == 0) {\n\t\t\t\tpr_err(\"%s: invalid indir len 0x%x, \"\n\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t    VAR_15, (u_int)VAR_10->len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tVAR_11 = paddr_guest2host(VAR_13,\n\t\t\t    VAR_10->addr, VAR_10->len);\n\t\t\t/* COMMENT_21 */\n                                             \n                                                \n                                                \n                                                \n                        \n      \n\t\t\tVAR_9 = 0;\n\t\t\tfor (;;) {\n\t\t\t\tVAR_12 = &VAR_11[VAR_9];\n\t\t\t\tif (VAR_12->flags & VAR_17) {\n\t\t\t\t\tpr_err(\"%s: indirect desc has INDIR flag,\"\n\t\t\t\t\t    \" driver confused?\\r\\n\",\n\t\t\t\t\t    VAR_15);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t_vq_record(VAR_5, VAR_12, VAR_13, VAR_2, VAR_3, VAR_4);\n\t\t\t\tif (++VAR_5 > VAR_16)\n\t\t\t\t\tgoto loopy;\n\t\t\t\tif ((VAR_12->flags & VAR_19) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tVAR_9 = VAR_12->next;\n\t\t\t\tif (VAR_9 >= VAR_7) {\n\t\t\t\t\tpr_err(\"%s: invalid next %u > %u, \"\n\t\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t\t    VAR_15, (u_int)VAR_9, VAR_7);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((VAR_10->flags & VAR_19) == 0)\n\t\t\treturn VAR_5;\n\t}\nloopy:\n\tpr_err(\"%s: descriptor loop? count > %d - driver confused?\\r\\n\",\n\t    VAR_15, VAR_5);\n\treturn -1;\n}",
  "func_graph_path_before": "projectacrn/acrn-hypervisor/ae0ab82434509d6e75f4a2f1e1a0dd2ee3dc3681/virtio.c/vul/before/2.json",
  "func": "int\nvq_getchain(struct virtio_vq_info *vq, uint16_t *pidx,\n\t    struct iovec *iov, int n_iov, uint16_t *flags)\n{\n\tint i;\n\tu_int ndesc, n_indir;\n\tu_int idx, next;\n\n\tvolatile struct vring_desc *vdir, *vindir, *vp;\n\tstruct vmctx *ctx;\n\tstruct virtio_base *base;\n\tconst char *name;\n\n\tbase = vq->base;\n\tname = base->vops->name;\n\n\t/*\n\t * Note: it's the responsibility of the guest not to\n\t * update vq->avail->idx until all of the descriptors\n\t * the guest has written are valid (including all their\n\t * next fields and vd_flags).\n\t *\n\t * Compute (last_avail - idx) in integers mod 2**16.  This is\n\t * the number of descriptors the device has made available\n\t * since the last time we updated vq->last_avail.\n\t *\n\t * We just need to do the subtraction as an unsigned int,\n\t * then trim off excess bits.\n\t */\n\tidx = vq->last_avail;\n\tndesc = (uint16_t)((u_int)vq->avail->idx - idx);\n\tif (ndesc == 0)\n\t\treturn 0;\n\tif (ndesc > vq->qsize) {\n\t\t/* XXX need better way to diagnose issues */\n\t\tpr_err(\"%s: ndesc (%u) out of range, driver confused?\\r\\n\",\n\t\t    name, (u_int)ndesc);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now count/parse \"involved\" descriptors starting from\n\t * the head of the chain.\n\t *\n\t * To prevent loops, we could be more complicated and\n\t * check whether we're re-visiting a previously visited\n\t * index, but we just abort if the count gets excessive.\n\t */\n\tctx = base->dev->vmctx;\n\t*pidx = next = vq->avail->ring[idx & (vq->qsize - 1)];\n\tvq->last_avail++;\n\tfor (i = 0; i < VQ_MAX_DESCRIPTORS; next = vdir->next) {\n\t\tif (next >= vq->qsize) {\n\t\t\tpr_err(\"%s: descriptor index %u out of range, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    name, next);\n\t\t\treturn -1;\n\t\t}\n\t\tvdir = &vq->desc[next];\n\t\tif ((vdir->flags & VRING_DESC_F_INDIRECT) == 0) {\n\t\t\tif (_vq_record(i, vdir, ctx, iov, n_iov, flags)) {\n\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if ((base->device_caps &\n\t\t    (1 << VIRTIO_RING_F_INDIRECT_DESC)) == 0) {\n\t\t\tpr_err(\"%s: descriptor has forbidden INDIRECT flag, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    name);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tn_indir = vdir->len / 16;\n\t\t\tif ((vdir->len & 0xf) || n_indir == 0) {\n\t\t\t\tpr_err(\"%s: invalid indir len 0x%x, \"\n\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t    name, (u_int)vdir->len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tvindir = paddr_guest2host(ctx,\n\t\t\t    vdir->addr, vdir->len);\n\n\t\t\tif (!vindir) {\n\t\t\t\tpr_err(\"%s cannot get host memory\\r\\n\", name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Indirects start at the 0th, then follow\n\t\t\t * their own embedded \"next\"s until those run\n\t\t\t * out.  Each one's indirect flag must be off\n\t\t\t * (we don't really have to check, could just\n\t\t\t * ignore errors...).\n\t\t\t */\n\t\t\tnext = 0;\n\t\t\tfor (;;) {\n\t\t\t\tvp = &vindir[next];\n\t\t\t\tif (vp->flags & VRING_DESC_F_INDIRECT) {\n\t\t\t\t\tpr_err(\"%s: indirect desc has INDIR flag,\"\n\t\t\t\t\t    \" driver confused?\\r\\n\",\n\t\t\t\t\t    name);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (_vq_record(i, vp, ctx, iov, n_iov, flags)) {\n\t\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (++i > VQ_MAX_DESCRIPTORS)\n\t\t\t\t\tgoto loopy;\n\t\t\t\tif ((vp->flags & VRING_DESC_F_NEXT) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tnext = vp->next;\n\t\t\t\tif (next >= n_indir) {\n\t\t\t\t\tpr_err(\"%s: invalid next %u > %u, \"\n\t\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t\t    name, (u_int)next, n_indir);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((vdir->flags & VRING_DESC_F_NEXT) == 0)\n\t\t\treturn i;\n\t}\nloopy:\n\tpr_err(\"%s: descriptor loop? count > %d - driver confused?\\r\\n\",\n\t    name, i);\n\treturn -1;\n}",
  "abstract_func": "int\nvq_getchain(struct virtio_vq_info *VAR_0, uint16_t *VAR_1,\n\t    struct iovec *VAR_2, int VAR_3, uint16_t *VAR_4)\n{\n\tint VAR_5;\n\tu_int VAR_6, VAR_7;\n\tu_int VAR_8, VAR_9;\n\n\tvolatile struct vring_desc *VAR_10, *VAR_11, *VAR_12;\n\tstruct vmctx *VAR_13;\n\tstruct virtio_base *VAR_14;\n\tconst char *VAR_15;\n\n\tVAR_14 = VAR_0->base;\n\tVAR_15 = VAR_14->vops->name;\n\n\t/* COMMENT_0 */\n                                                     \n                                                      \n                                                        \n                              \n   \n                                                              \n                                                           \n                                                  \n   \n                                                          \n                              \n    \n\tVAR_8 = VAR_0->last_avail;\n\tVAR_6 = (uint16_t)((u_int)VAR_0->avail->idx - VAR_8);\n\tif (VAR_6 == 0)\n\t\treturn 0;\n\tif (VAR_6 > VAR_0->qsize) {\n\t\t/* COMMENT_12 */\n\t\tpr_err(\"%s: ndesc (%u) out of range, driver confused?\\r\\n\",\n\t\t    VAR_15, (u_int)VAR_6);\n\t\treturn -1;\n\t}\n\n\t/* COMMENT_13 */\n                                                        \n                          \n   \n                                                      \n                                                        \n                                                         \n    \n\tVAR_13 = VAR_14->dev->vmctx;\n\t*VAR_1 = VAR_9 = VAR_0->avail->ring[VAR_8 & (VAR_0->qsize - 1)];\n\tVAR_0->last_avail++;\n\tfor (VAR_5 = 0; VAR_5 < VAR_16; VAR_9 = VAR_10->next) {\n\t\tif (VAR_9 >= VAR_0->qsize) {\n\t\t\tpr_err(\"%s: descriptor index %u out of range, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    VAR_15, VAR_9);\n\t\t\treturn -1;\n\t\t}\n\t\tVAR_10 = &VAR_0->desc[VAR_9];\n\t\tif ((VAR_10->flags & VAR_17) == 0) {\n\t\t\tif (_vq_record(VAR_5, VAR_10, VAR_13, VAR_2, VAR_3, VAR_4)) {\n\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", VAR_15);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tVAR_5++;\n\t\t} else if ((VAR_14->device_caps &\n\t\t    (1 << VAR_18)) == 0) {\n\t\t\tpr_err(\"%s: descriptor has forbidden INDIRECT flag, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    VAR_15);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tVAR_7 = VAR_10->len / 16;\n\t\t\tif ((VAR_10->len & 0xf) || VAR_7 == 0) {\n\t\t\t\tpr_err(\"%s: invalid indir len 0x%x, \"\n\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t    VAR_15, (u_int)VAR_10->len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tVAR_11 = paddr_guest2host(VAR_13,\n\t\t\t    VAR_10->addr, VAR_10->len);\n\n\t\t\tif (!VAR_11) {\n\t\t\t\tpr_err(\"%s cannot get host memory\\r\\n\", VAR_15);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* COMMENT_21 */\n                                             \n                                                \n                                                \n                                                \n                        \n      \n\t\t\tVAR_9 = 0;\n\t\t\tfor (;;) {\n\t\t\t\tVAR_12 = &VAR_11[VAR_9];\n\t\t\t\tif (VAR_12->flags & VAR_17) {\n\t\t\t\t\tpr_err(\"%s: indirect desc has INDIR flag,\"\n\t\t\t\t\t    \" driver confused?\\r\\n\",\n\t\t\t\t\t    VAR_15);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (_vq_record(VAR_5, VAR_12, VAR_13, VAR_2, VAR_3, VAR_4)) {\n\t\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", VAR_15);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (++VAR_5 > VAR_16)\n\t\t\t\t\tgoto loopy;\n\t\t\t\tif ((VAR_12->flags & VAR_19) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tVAR_9 = VAR_12->next;\n\t\t\t\tif (VAR_9 >= VAR_7) {\n\t\t\t\t\tpr_err(\"%s: invalid next %u > %u, \"\n\t\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t\t    VAR_15, (u_int)VAR_9, VAR_7);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((VAR_10->flags & VAR_19) == 0)\n\t\t\treturn VAR_5;\n\t}\nloopy:\n\tpr_err(\"%s: descriptor loop? count > %d - driver confused?\\r\\n\",\n\t    VAR_15, VAR_5);\n\treturn -1;\n}",
  "func_graph_path": "projectacrn/acrn-hypervisor/ae0ab82434509d6e75f4a2f1e1a0dd2ee3dc3681/virtio.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,10 @@\n \t\t}\n \t\tvdir = &vq->desc[next];\n \t\tif ((vdir->flags & VRING_DESC_F_INDIRECT) == 0) {\n-\t\t\t_vq_record(i, vdir, ctx, iov, n_iov, flags);\n+\t\t\tif (_vq_record(i, vdir, ctx, iov, n_iov, flags)) {\n+\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);\n+\t\t\t\treturn -1;\n+\t\t\t}\n \t\t\ti++;\n \t\t} else if ((base->device_caps &\n \t\t    (1 << VIRTIO_RING_F_INDIRECT_DESC)) == 0) {\n@@ -76,6 +79,11 @@\n \t\t\t}\n \t\t\tvindir = paddr_guest2host(ctx,\n \t\t\t    vdir->addr, vdir->len);\n+\n+\t\t\tif (!vindir) {\n+\t\t\t\tpr_err(\"%s cannot get host memory\\r\\n\", name);\n+\t\t\t\treturn -1;\n+\t\t\t}\n \t\t\t/*\n \t\t\t * Indirects start at the 0th, then follow\n \t\t\t * their own embedded \"next\"s until those run\n@@ -92,7 +100,10 @@\n \t\t\t\t\t    name);\n \t\t\t\t\treturn -1;\n \t\t\t\t}\n-\t\t\t\t_vq_record(i, vp, ctx, iov, n_iov, flags);\n+\t\t\t\tif (_vq_record(i, vp, ctx, iov, n_iov, flags)) {\n+\t\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tif (++i > VQ_MAX_DESCRIPTORS)\n \t\t\t\t\tgoto loopy;\n \t\t\t\tif ((vp->flags & VRING_DESC_F_NEXT) == 0)",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t_vq_record(i, vdir, ctx, iov, n_iov, flags);",
      "\t\t\t\t_vq_record(i, vp, ctx, iov, n_iov, flags);"
    ],
    "added_lines": [
      "\t\t\tif (_vq_record(i, vdir, ctx, iov, n_iov, flags)) {",
      "\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);",
      "\t\t\t\treturn -1;",
      "\t\t\t}",
      "",
      "\t\t\tif (!vindir) {",
      "\t\t\t\tpr_err(\"%s cannot get host memory\\r\\n\", name);",
      "\t\t\t\treturn -1;",
      "\t\t\t}",
      "\t\t\t\tif (_vq_record(i, vp, ctx, iov, n_iov, flags)) {",
      "\t\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);",
      "\t\t\t\t\treturn -1;",
      "\t\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/projectacrn/acrn-hypervisor/pull/5453",
  "description": {
    "pr_info": {
      "title": "dm: virtio: check for paddr_guest2host return value",
      "number": 5453
    },
    "comment": [
      "paddr_guest2host can return NULL, but code paths in virtio\r\nare not checking the return value.\r\n_vq_record() initializes iov_base pointer using paddr_guest2host()\r\nbut there is nothing in the flow that checks for NULL.\r\nChane _vq_record to return -1 in case the address translation\r\nhas failed.\r\n\r\nTracked-On: #5452\r\nSigned-off-by: Tomas Winkler <tomas.winkler@intel.com>\r\nAcked-by: Wang, Yu1 <yu1.wang@intel.com>",
      "No new violations to the coding guideline detected.<br>No New Name Conflict<br><br>No New Function Declaration/Definition Mismatch<br>",
      "OK to verify",
      "No new violations to the coding guideline detected.<br>No New Name Conflict<br><br>No New Function Declaration/Definition Mismatch<br>",
      "@tomasbw\r\n   RT could not boot up..",
      "@tomasbw \r\nboot rt fail ~~ Please check it out \r\n`pm_by_vuart_init idx: 1, path: /dev/ttyS1\r\npci init hostbridge\r\npci init passthru\r\npolling 35...\r\nListening 35...\r\ninitiate a connection on a socket error\r\ncreate socket to connect life-cycle manager failed\r\npci init virtio-console\r\ntpm: init_vtpm2:Invalid socket path!\r\n                                    /tmp/dm.XbAOPLW     24:     Device (PCI0)\r\n                                                                             Warning  3073 -        Multiple types ^  (Device object requires either a _HID or _ADR, but not both)\r\n\r\n                                                                                                                                                                                  /tmp/dm.XbAOPLW    110:     Processor (CPU0, 0x00, 0x00000000, 0x00) {}\r\n                                                              Warning  3168 -                          ^ Legacy Processor() keyword detected. Use Device() keyword instead.\r\n\r\n                                                                                                                                                                           /tmp/dm.XbAOPLW    111:     Processor (CPU1, 0x01, 0x00000000, 0x00) {}\r\n                                                       Warning  3168 -                          ^ Legacy Processor() keyword detected. Use Device() keyword instead.\r\n\r\n                                                                                                                                                                    acrn_sw_load\r\n                                                                                                                                                                                SW_LOAD: partition blob /usr/share/acrn/bios/OVMF.fd size 2097152 copy to guest 0xffe00000\r\n                                                                               SW_LOAD: build e820 7 entries to addr: 0x7f26800ef008\r\nSW_LOAD: entry[0]: addr 0x0000000000000000, size 0x00000000000a0000,  type 0x1\r\nSW_LOAD: entry[1]: addr 0x0000000000100000, size 0x000000003b700000,  type 0x1\r\nSW_LOAD: entry[2]: addr 0x000000003b800000, size 0x0000000004004000,  type 0x2\r\nSW_LOAD: entry[3]: addr 0x0000000040080000, size 0x0000000000800000,  type 0x2\r\nSW_LOAD: entry[4]: addr 0x00000000e0000000, size 0x0000000020000000,  type 0x2\r\nSW_LOAD: entry[5]: addr 0x0000000140000000, size 0x0000000000000000,  type 0x2\r\nSW_LOAD: entry[6]: addr 0x0000000000000000, size 0x0000000000000000,  type 0x0\r\nSW_LOAD: ovmf_entry 0xfffffff0\r\n                              add_cpu\r\n                                     out instr on NMI port (0x61) not supported\r\n                                                                               out instr on NMI port (0x61) not supported\r\n                                                                                                                         out instr on NMI port (0x61) not supported\r\n                                                                                                                                                                   virtio_vq_init: vq enable failed\r\n        virtio_vq_init: vq enable failed\r\n                                        virtio_vq_init: vq enable failed\r\n                                                                        virtio_vq_init: vq enable failed\r\n                                                                                                        virtio_vq_init: vq enable failed\r\n                                                                                                                                        virtio_vq_init: vq enable failed\r\n                                                                                                                                                                        virtio_vq_init: vq enable failed\r\n             virtio_vq_init: vq enable failed\r\n                                             virtio_vq_init: vq enable failed\r\n                                                                             virtio_vq_init: vq enable failed\r\n                                                                                                             virtio_vq_init: vq enable failed\r\n                                                                                                                                             virtio_vq_init: vq enable failed\r\n                                                                                                                                                                             virtio_vq_init: vq enable failed\r\n                  virtio_vq_init: vq enable failed\r\n                                                  virtio_vq_init: vq enable failed\r\n                                                                                  virtio_vq_init: vq enable failed\r\n                                                                                                                  virtio_vq_init: vq enable failed\r\n                                                                                                                                                  virtio_vq_init: vq enable failed\r\n                                                                                                                                                                                  virtio_vq_init: vq enable failed\r\n                       virtio_vq_init: vq enable failed\r\n                                                       virtio_vq_init: vq enable failed\r\n                                                                                       virtio_vq_init: vq enable failed\r\n                                                                                                                       virtio_vq_init: vq enable failed\r\n                                                                                                                                                       virtio_vq_init: vq enable failed\r\n                                                                                                                                                                                       virtio_vq_init: vq enable failed\r\n                            virtio_vq_init: vq enable failed\r\n                                                            virtio_vq_init: vq enable failed\r\n                                                                                            virtio_vq_init: vq enable failed\r\n                                                                                                                            virtio_vq_init: vq enable failed\r\n                                                                                                                                                            virtio_vq_init: vq enable failed\r\n virtio_vq_init: vq enable failed\r\n                                 virtio_vq_init: vq enable failed\r\n                                                                 virtio_vq_init: vq enable failed\r\n                                                                                                 virtio_vq_init: vq enable failed\r\n`",
      "@tomasbw  please check your patch:\r\n\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed\r\nvirtio_vq_init: vq enable failed",
      "the issue was fixed, missing return before the error label.",
      "No new violations to the coding guideline detected.<br>No New Name Conflict<br><br>No New Function Declaration/Definition Mismatch<br>"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}