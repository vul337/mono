{
  "cve_id": "CVE-2018-20362",
  "cwe_ids": [
    "CWE-787",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "syntax.c: check for syntax element inconsistencies\n\nImplicit channel mapping reconfiguration is explicitely forbidden by\nISO/IEC 13818-7:2006 (8.5.3.3). Decoders should be able to detect such\nfiles and reject them. FAAD2 does not perform any kind of checks\nregarding this.\n\nThis leads to security vulnerabilities when processing crafted AAC\nfiles performing such reconfigurations.\n\nAdd checks to decode_sce_lfe and decode_cpe to make sure such\ninconsistencies are detected as early as possible.\n\nThese checks first read hDecoder->frame: if this is not the first\nframe then we make sure that the syntax element at the same position\nin the previous frame also had element_id id_syn_ele. If not, return\n21 as this is a fatal file structure issue.\n\nThis patch addresses CVE-2018-20362 (fixes #26) and possibly other\nrelated issues.",
  "commit_hash": "466b01d504d7e45f1e9169ac90b3e34ab94aed14",
  "git_url": "https://github.com/knik0/faad2/commit/466b01d504d7e45f1e9169ac90b3e34ab94aed14",
  "file_path": "libfaad/syntax.c",
  "func_name": "decode_cpe",
  "func_before": "static void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = channel_pair_element(hDecoder, ld, channels, &tag);\n\n    /* map output channel position to internal data channels */\n    if (hDecoder->pce_set)\n    {\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels;\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    }\n\n    hDecoder->fr_channels += 2;\n    hDecoder->fr_ch_ele++;\n}",
  "abstract_func_before": "static void decode_cpe(NeAACDecStruct *VAR_0, NeAACDecFrameInfo *VAR_1, bitfile *VAR_2,\n                       uint8_t VAR_3)\n{\n    uint8_t VAR_4 = VAR_0->fr_channels;\n    uint8_t VAR_5 = 0;\n\n    if (VAR_4+2 > VAR_6)\n    {\n        VAR_1->error = 12;\n        return;\n    }\n    if (VAR_0->fr_ch_ele+1 > VAR_7)\n    {\n        VAR_1->error = 13;\n        return;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n    {\n        /* COMMENT_1 */\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = 2;\n    } else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != 2) {\n        /* COMMENT_2 */\n        VAR_1->error = 21;\n        return;\n    }\n\n    /* COMMENT_3 */\n    VAR_0->element_id[VAR_0->fr_ch_ele] = VAR_3;\n\n    /* COMMENT_4 */\n    VAR_1->error = channel_pair_element(VAR_0, VAR_2, VAR_4, &VAR_5);\n\n    /* COMMENT_5 */\n    if (VAR_0->pce_set)\n    {\n        VAR_0->internal_channel[VAR_0->pce.cpe_channel[VAR_5]] = VAR_4;\n        VAR_0->internal_channel[VAR_0->pce.cpe_channel[VAR_5]+1] = VAR_4+1;\n    } else {\n        VAR_0->internal_channel[VAR_4] = VAR_4;\n        VAR_0->internal_channel[VAR_4+1] = VAR_4+1;\n    }\n\n    VAR_0->fr_channels += 2;\n    VAR_0->fr_ch_ele++;\n}",
  "func_graph_path_before": "knik0/faad2/466b01d504d7e45f1e9169ac90b3e34ab94aed14/syntax.c/vul/before/1.json",
  "func": "static void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = channel_pair_element(hDecoder, ld, channels, &tag);\n\n    /* map output channel position to internal data channels */\n    if (hDecoder->pce_set)\n    {\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels;\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    }\n\n    hDecoder->fr_channels += 2;\n    hDecoder->fr_ch_ele++;\n}",
  "abstract_func": "static void decode_cpe(NeAACDecStruct *VAR_0, NeAACDecFrameInfo *VAR_1, bitfile *VAR_2,\n                       uint8_t VAR_3)\n{\n    uint8_t VAR_4 = VAR_0->fr_channels;\n    uint8_t VAR_5 = 0;\n\n    if (VAR_4+2 > VAR_6)\n    {\n        VAR_1->error = 12;\n        return;\n    }\n    if (VAR_0->fr_ch_ele+1 > VAR_7)\n    {\n        VAR_1->error = 13;\n        return;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n    {\n        /* COMMENT_1 */\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = 2;\n    } else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != 2) {\n        /* COMMENT_2 */\n        VAR_1->error = 21;\n        return;\n    }\n\n    if (VAR_0->frame && VAR_0->element_id[VAR_0->fr_ch_ele] != VAR_3) {\n        /* COMMENT_2 */\n        VAR_1->error = 21;\n        return;\n    }\n\n    /* COMMENT_3 */\n    VAR_0->element_id[VAR_0->fr_ch_ele] = VAR_3;\n\n    /* COMMENT_4 */\n    VAR_1->error = channel_pair_element(VAR_0, VAR_2, VAR_4, &VAR_5);\n\n    /* COMMENT_5 */\n    if (VAR_0->pce_set)\n    {\n        VAR_0->internal_channel[VAR_0->pce.cpe_channel[VAR_5]] = VAR_4;\n        VAR_0->internal_channel[VAR_0->pce.cpe_channel[VAR_5]+1] = VAR_4+1;\n    } else {\n        VAR_0->internal_channel[VAR_4] = VAR_4;\n        VAR_0->internal_channel[VAR_4+1] = VAR_4+1;\n    }\n\n    VAR_0->fr_channels += 2;\n    VAR_0->fr_ch_ele++;\n}",
  "func_graph_path": "knik0/faad2/466b01d504d7e45f1e9169ac90b3e34ab94aed14/syntax.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,12 @@\n         return;\n     }\n \n+    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n+        /* element inconsistency */\n+        hInfo->error = 21;\n+        return;\n+    }\n+\n     /* save the syntax element id */\n     hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {",
      "        /* element inconsistency */",
      "        hInfo->error = 21;",
      "        return;",
      "    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/33",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/knik0/faad2/pull/33: 403 Client Error: Forbidden for url: https://api.github.com/repos/knik0/faad2/pulls/33",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:**  \n   The commit message clearly states that the patch addresses CVE-2018-20362, which is a security vulnerability. The code changes introduce checks for inconsistencies in AAC files, directly relating to the vulnerability description.\n\n2. **Consistency Check:**  \n   The commit message accurately reflects the code modifications, which add checks to detect potentially malicious AAC files early.\n\n3. **Purpose Evaluation:**  \n   The changes are explicit security fixes, as they prevent processing of crafted AAC files that could exploit security vulnerabilities.\n\n4. **Security Vulnerability Assessment:**  \n   The patch fixes a known CVE and involves checks for crafted files, indicating it's a security fix.\n\n5. **Confidence Scoring:**  \n   The classification is clear and direct with a known CVE reference, so confidence is high.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}