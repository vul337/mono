{
  "cve_id": "CVE-2022-21700",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "micronaut-projects/micronaut-core",
  "commit_msg": "Use ConversionContext constants where possible instead of class (#2356)\n\nChanges\r\n-------\r\n * Added ArgumentConversionContext constants in ConversionContext\r\n * Replaced Argument.of and use of argument classes with\r\nConversionContext constants where possible\r\n * Added getFirst method in ConvertibleMultiValues that accepts\r\nArgumentConversionContent parameter\r\n\r\nPartially addresses issue #2355",
  "commit_hash": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "git_url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "file_path": "runtime/src/main/java/io/micronaut/cache/interceptor/CacheInterceptor.java",
  "func_name": "interceptCompletableFuture",
  "func_before": "protected Object interceptCompletableFuture(MethodInvocationContext<Object, Object> context, ReturnType<?> returnTypeObject, Class returnType) {\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n        AnnotationValue<Cacheable> cacheable = cacheOperation.cacheable;\n        CompletableFuture<Object> returnFuture;\n        if (cacheable != null) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n            CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n            Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, params);\n            CompletableFuture<Object> thisFuture = new CompletableFuture<>();\n            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n            asyncCache.get(key, firstTypeVariable).whenComplete((BiConsumer<Optional<?>, Throwable>) (o, throwable) -> {\n                if (throwable == null && o.isPresent()) {\n                    // cache hit, return result\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                    }\n                    thisFuture.complete(o.get());\n                } else {\n                    // cache miss proceed with original future\n                    try {\n                        if (throwable != null) {\n                            if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                                thisFuture.completeExceptionally(throwable);\n                                return;\n                            }\n                        }\n                        CompletableFuture<?> completableFuture = (CompletableFuture) context.proceed();\n                        if (completableFuture == null) {\n                            thisFuture.complete(null);\n                        } else {\n                            completableFuture.whenComplete((BiConsumer<Object, Throwable>) (o1, t2) -> {\n                                if (t2 != null) {\n                                    thisFuture.completeExceptionally(t2);\n                                } else {\n                                    // new cacheable result, cache it\n                                    asyncCache.put(key, o1).whenComplete((aBoolean, throwable1) -> {\n                                        if (throwable1 == null) {\n                                            thisFuture.complete(o1);\n                                        } else {\n                                            thisFuture.completeExceptionally(throwable1);\n                                        }\n                                    });\n\n                                }\n                            });\n                        }\n                    } catch (RuntimeException e) {\n                        thisFuture.completeExceptionally(e);\n                    }\n                }\n            });\n            returnFuture = thisFuture;\n        } else {\n            returnFuture = (CompletableFuture<Object>) context.proceed();\n        }\n        if (cacheOperation.hasWriteOperations()) {\n            returnFuture = processFuturePutOperations(context, cacheOperation, returnFuture);\n        }\n        return returnFuture;\n    }",
  "abstract_func_before": "protected Object interceptCompletableFuture(MethodInvocationContext<Object, Object> VAR_0, ReturnType<?> VAR_1, Class VAR_2) {\n        CacheOperation VAR_3 = new CacheOperation(VAR_0, VAR_2);\n        AnnotationValue<Cacheable> VAR_4 = VAR_3.cacheable;\n        CompletableFuture<Object> VAR_5;\n        if (VAR_4 != null) {\n            AsyncCache<?> VAR_6 = VAR_7.getCache(VAR_3.cacheableCacheName).async();\n            CacheKeyGenerator VAR_8 = resolveKeyGenerator(VAR_3.defaultKeyGenerator, VAR_4);\n            Object[] VAR_9 = resolveParams(VAR_0, VAR_4.get(VAR_10, String[].class, VAR_11.EMPTY_STRING_ARRAY));\n            Object VAR_12 = VAR_8.generateKey(VAR_0, VAR_9);\n            CompletableFuture<Object> VAR_13 = new CompletableFuture<>();\n            Argument<?> VAR_14 = VAR_1.getFirstTypeVariable().orElse(VAR_15.of(Object.class));\n            VAR_6.get(VAR_12, VAR_14).whenComplete((BiConsumer<Optional<?>, Throwable>) (VAR_16, VAR_17) -> {\n                if (VAR_17 == null && VAR_16.isPresent()) {\n                    /* COMMENT_0 */\n                    if (VAR_18.isDebugEnabled()) {\n                        VAR_18.debug(\"Value found in cache [\" + VAR_6.getName() + \"] for invocation: \" + VAR_0);\n                    }\n                    VAR_13.complete(VAR_16.get());\n                } else {\n                    /* COMMENT_1 */\n                    try {\n                        if (VAR_17 != null) {\n                            if (VAR_19.handleLoadError(VAR_6, VAR_12, asRuntimeException(VAR_17))) {\n                                VAR_13.completeExceptionally(VAR_17);\n                                return;\n                            }\n                        }\n                        CompletableFuture<?> VAR_20 = (CompletableFuture) VAR_0.proceed();\n                        if (VAR_20 == null) {\n                            VAR_13.complete(null);\n                        } else {\n                            VAR_20.whenComplete((BiConsumer<Object, Throwable>) (VAR_21, VAR_22) -> {\n                                if (VAR_22 != null) {\n                                    VAR_13.completeExceptionally(VAR_22);\n                                } else {\n                                    /* COMMENT_2 */\n                                    VAR_6.put(VAR_12, VAR_21).whenComplete((VAR_23, VAR_24) -> {\n                                        if (VAR_24 == null) {\n                                            VAR_13.complete(VAR_21);\n                                        } else {\n                                            VAR_13.completeExceptionally(VAR_24);\n                                        }\n                                    });\n\n                                }\n                            });\n                        }\n                    } catch (RuntimeException VAR_25) {\n                        VAR_13.completeExceptionally(VAR_25);\n                    }\n                }\n            });\n            VAR_5 = VAR_13;\n        } else {\n            VAR_5 = (CompletableFuture<Object>) VAR_0.proceed();\n        }\n        if (VAR_3.hasWriteOperations()) {\n            VAR_5 = processFuturePutOperations(VAR_0, VAR_3, VAR_5);\n        }\n        return VAR_5;\n    }",
  "func_graph_path_before": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/CacheInterceptor.java/vul/before/1.json",
  "func": "protected Object interceptCompletableFuture(MethodInvocationContext<Object, Object> context, ReturnType<?> returnTypeObject, Class returnType) {\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n        AnnotationValue<Cacheable> cacheable = cacheOperation.cacheable;\n        CompletableFuture<Object> returnFuture;\n        if (cacheable != null) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n            CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n            Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, params);\n            CompletableFuture<Object> thisFuture = new CompletableFuture<>();\n            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n            asyncCache.get(key, firstTypeVariable).whenComplete((BiConsumer<Optional<?>, Throwable>) (o, throwable) -> {\n                if (throwable == null && o.isPresent()) {\n                    // cache hit, return result\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                    }\n                    thisFuture.complete(o.get());\n                } else {\n                    // cache miss proceed with original future\n                    try {\n                        if (throwable != null) {\n                            if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                                thisFuture.completeExceptionally(throwable);\n                                return;\n                            }\n                        }\n                        CompletableFuture<?> completableFuture = (CompletableFuture) context.proceed();\n                        if (completableFuture == null) {\n                            thisFuture.complete(null);\n                        } else {\n                            completableFuture.whenComplete((BiConsumer<Object, Throwable>) (o1, t2) -> {\n                                if (t2 != null) {\n                                    thisFuture.completeExceptionally(t2);\n                                } else {\n                                    // new cacheable result, cache it\n                                    asyncCache.put(key, o1).whenComplete((aBoolean, throwable1) -> {\n                                        if (throwable1 == null) {\n                                            thisFuture.complete(o1);\n                                        } else {\n                                            thisFuture.completeExceptionally(throwable1);\n                                        }\n                                    });\n\n                                }\n                            });\n                        }\n                    } catch (RuntimeException e) {\n                        thisFuture.completeExceptionally(e);\n                    }\n                }\n            });\n            returnFuture = thisFuture;\n        } else {\n            returnFuture = (CompletableFuture<Object>) context.proceed();\n        }\n        if (cacheOperation.hasWriteOperations()) {\n            returnFuture = processFuturePutOperations(context, cacheOperation, returnFuture);\n        }\n        return returnFuture;\n    }",
  "abstract_func": "protected Object interceptCompletableFuture(MethodInvocationContext<Object, Object> VAR_0, ReturnType<?> VAR_1, Class VAR_2) {\n        CacheOperation VAR_3 = new CacheOperation(VAR_0, VAR_2);\n        AnnotationValue<Cacheable> VAR_4 = VAR_3.cacheable;\n        CompletableFuture<Object> VAR_5;\n        if (VAR_4 != null) {\n            AsyncCache<?> VAR_6 = VAR_7.getCache(VAR_3.cacheableCacheName).async();\n            CacheKeyGenerator VAR_8 = resolveKeyGenerator(VAR_3.defaultKeyGenerator, VAR_4);\n            Object[] VAR_9 = resolveParams(VAR_0, VAR_4.get(VAR_10, String[].class, VAR_11.EMPTY_STRING_ARRAY));\n            Object VAR_12 = VAR_8.generateKey(VAR_0, VAR_9);\n            CompletableFuture<Object> VAR_13 = new CompletableFuture<>();\n            Argument<?> VAR_14 = VAR_1.getFirstTypeVariable().orElse(VAR_15.OBJECT_ARGUMENT);\n            VAR_6.get(VAR_12, VAR_14).whenComplete((BiConsumer<Optional<?>, Throwable>) (VAR_16, VAR_17) -> {\n                if (VAR_17 == null && VAR_16.isPresent()) {\n                    /* COMMENT_0 */\n                    if (VAR_18.isDebugEnabled()) {\n                        VAR_18.debug(\"Value found in cache [\" + VAR_6.getName() + \"] for invocation: \" + VAR_0);\n                    }\n                    VAR_13.complete(VAR_16.get());\n                } else {\n                    /* COMMENT_1 */\n                    try {\n                        if (VAR_17 != null) {\n                            if (VAR_19.handleLoadError(VAR_6, VAR_12, asRuntimeException(VAR_17))) {\n                                VAR_13.completeExceptionally(VAR_17);\n                                return;\n                            }\n                        }\n                        CompletableFuture<?> VAR_20 = (CompletableFuture) VAR_0.proceed();\n                        if (VAR_20 == null) {\n                            VAR_13.complete(null);\n                        } else {\n                            VAR_20.whenComplete((BiConsumer<Object, Throwable>) (VAR_21, VAR_22) -> {\n                                if (VAR_22 != null) {\n                                    VAR_13.completeExceptionally(VAR_22);\n                                } else {\n                                    /* COMMENT_2 */\n                                    VAR_6.put(VAR_12, VAR_21).whenComplete((VAR_23, VAR_24) -> {\n                                        if (VAR_24 == null) {\n                                            VAR_13.complete(VAR_21);\n                                        } else {\n                                            VAR_13.completeExceptionally(VAR_24);\n                                        }\n                                    });\n\n                                }\n                            });\n                        }\n                    } catch (RuntimeException VAR_25) {\n                        VAR_13.completeExceptionally(VAR_25);\n                    }\n                }\n            });\n            VAR_5 = VAR_13;\n        } else {\n            VAR_5 = (CompletableFuture<Object>) VAR_0.proceed();\n        }\n        if (VAR_3.hasWriteOperations()) {\n            VAR_5 = processFuturePutOperations(VAR_0, VAR_3, VAR_5);\n        }\n        return VAR_5;\n    }",
  "func_graph_path": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/CacheInterceptor.java/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n             Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n             Object key = keyGenerator.generateKey(context, params);\n             CompletableFuture<Object> thisFuture = new CompletableFuture<>();\n-            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n+            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n             asyncCache.get(key, firstTypeVariable).whenComplete((BiConsumer<Optional<?>, Throwable>) (o, throwable) -> {\n                 if (throwable == null && o.isPresent()) {\n                     // cache hit, return result",
  "diff_line_info": {
    "deleted_lines": [
      "            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));"
    ],
    "added_lines": [
      "            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/micronaut-projects/micronaut-core/pull/2356",
  "description": {
    "pr_info": {
      "title": "Use Argument constants where possible instead of class",
      "number": 2356
    },
    "comment": [
      "Changes\r\n-------\r\n * Added ArgumentConversionContext constants in ConversionContext\r\n * Replaced Argument.of and use of argument classes with\r\nConversionContext constants where possible\r\n * Added getFirst method in ConvertibleMultiValues that accepts\r\nArgumentConversionContent parameter\r\n\r\nPartially addresses issue #2355",
      "Nice progress"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 0.9"
}