{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/t1_lib.c",
  "func_name": "ssl_add_serverhello_tlsext",
  "func_before": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,\n                                          unsigned char *limit, int *al)\n{\n    int extdatalen = 0;\n    unsigned char *orig = buf;\n    unsigned char *ret = buf;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    int next_proto_neg_seen;\n#endif\n#ifndef OPENSSL_NO_EC\n    unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n    int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA);\n    using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    ret += 2;\n    if (ret >= limit)\n        return NULL;            /* this really never occurs, but ... */\n\n    if (s->s3->send_connection_binding) {\n        int el;\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the reneg type and extension length\n         * + reneg data length\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_renegotiate, ret);\n        s2n(el, ret);\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        ret += el;\n    }\n\n    /* Only add RI for SSLv3 */\n    if (s->version == SSL3_VERSION)\n        goto done;\n\n    if (!s->hit && s->servername_done == 1\n        && s->session->tlsext_hostname != NULL) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the server name type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_server_name, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        const unsigned char *plist;\n        size_t plistlen;\n        /*\n         * Add TLS extension ECPointFormats to the ServerHello message\n         */\n\n        tls1_get_formatlist(s, &plist, &plistlen);\n\n        if (plistlen > 255) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ec points format type and extension length\n         * 1 byte for the points format list length\n         * + length of points format list\n         */\n        if (CHECKLEN(ret, 5 + plistlen, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_ec_point_formats, ret);\n        s2n(plistlen + 1, ret);\n        *(ret++) = (unsigned char)plistlen;\n        memcpy(ret, plist, plistlen);\n        ret += plistlen;\n\n    }\n    /*\n     * Currently the server should not respond with a SupportedCurves\n     * extension\n     */\n#endif                          /* OPENSSL_NO_EC */\n\n    if (s->tlsext_ticket_expected && tls_use_ticket(s)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Ticket type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_session_ticket, ret);\n        s2n(0, ret);\n    } else {\n        /*\n         * if we don't add the above TLSEXT, we can't add a session ticket\n         * later\n         */\n        s->tlsext_ticket_expected = 0;\n    }\n\n    if (s->tlsext_status_expected) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Status request type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_status_request, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && s->srtp_profile) {\n        int el;\n\n        /* Returns 0 on success!! */\n        if (ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        /*-\n         * check for enough space.\n         * 4 bytes for the SRTP profiles type and extension length\n         * + length of the SRTP profiles list\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_use_srtp, ret);\n        s2n(el, ret);\n\n        if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        ret += el;\n    }\n#endif\n\n    if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {\n        const unsigned char cryptopro_ext[36] = {\n            0xfd, 0xe8,         /* 65000 */\n            0x00, 0x20,         /* 32 bytes length */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n\n        /* check for enough space. */\n        if (CHECKLEN(ret, sizeof(cryptopro_ext), limit))\n            return NULL;\n        memcpy(ret, cryptopro_ext, sizeof(cryptopro_ext));\n        ret += sizeof(cryptopro_ext);\n\n    }\n#ifndef OPENSSL_NO_HEARTBEATS\n    /* Add Heartbeat extension if we've received one */\n    if (SSL_IS_DTLS(s) && (s->tlsext_heartbeat & SSL_DTLSEXT_HB_ENABLED)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Heartbeat type and extension length\n         * 1 byte for the mode\n         */\n        if (CHECKLEN(ret, 5, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_heartbeat, ret);\n        s2n(1, ret);\n        /*-\n         * Set mode:\n         * 1: peer may send requests\n         * 2: peer not allowed to send requests\n         */\n        if (s->tlsext_heartbeat & SSL_DTLSEXT_HB_DONT_RECV_REQUESTS)\n            *(ret++) = SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n        else\n            *(ret++) = SSL_DTLSEXT_HB_ENABLED;\n\n    }\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    next_proto_neg_seen = s->s3->next_proto_neg_seen;\n    s->s3->next_proto_neg_seen = 0;\n    if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {\n        const unsigned char *npa;\n        unsigned int npalen;\n        int r;\n\n        r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,\n                                              s->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (r == SSL_TLSEXT_ERR_OK) {\n            /*-\n             * check for enough space.\n             * 4 bytes for the NPN type and extension length\n             * + length of protocols list\n             */\n            if (CHECKLEN(ret, 4 + npalen, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_next_proto_neg, ret);\n            s2n(npalen, ret);\n            memcpy(ret, npa, npalen);\n            ret += npalen;\n            s->s3->next_proto_neg_seen = 1;\n        }\n    }\n#endif\n    if (!custom_ext_add(s, 1, &ret, limit, al))\n        return NULL;\n    if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {\n        /*\n         * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n         * for other cases too.\n         */\n        if (SSL_IS_DTLS(s) || s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n        else {\n            /*-\n             * check for enough space.\n             * 4 bytes for the ETM type and extension length\n             */\n            if (CHECKLEN(ret, 4, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_encrypt_then_mac, ret);\n            s2n(0, ret);\n        }\n    }\n    if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the EMS type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_extended_master_secret, ret);\n        s2n(0, ret);\n    }\n\n    if (s->s3->alpn_selected != NULL) {\n        const unsigned char *selected = s->s3->alpn_selected;\n        size_t len = s->s3->alpn_selected_len;\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ALPN type and extension length\n         * 2 bytes for ALPN data length\n         * 1 byte for selected protocol length\n         * + length of the selected protocol\n         */\n        if (CHECKLEN(ret, 7 + len, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\n        s2n(3 + len, ret);\n        s2n(1 + len, ret);\n        *ret++ = len;\n        memcpy(ret, selected, len);\n        ret += len;\n    }\n\n done:\n\n    if ((extdatalen = ret - orig - 2) == 0)\n        return orig;\n\n    s2n(extdatalen, orig);\n    return ret;\n}",
  "abstract_func_before": "unsigned char *ssl_add_serverhello_tlsext(SSL *VAR_0, unsigned char *VAR_1,\n                                          unsigned char *VAR_2, int *VAR_3)\n{\n    int VAR_4 = 0;\n    unsigned char *VAR_5 = VAR_1;\n    unsigned char *VAR_6 = VAR_1;\n#ifndef VAR_7\n    int VAR_8;\n#endif\n#ifndef VAR_9\n    unsigned long VAR_10 = VAR_0->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long VAR_11 = VAR_0->s3->tmp.new_cipher->algorithm_auth;\n    int VAR_12 = (VAR_10 & VAR_13) || (VAR_11 & VAR_14);\n    VAR_12 = VAR_12 && (VAR_0->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    VAR_6 += 2;\n    if (VAR_6 >= VAR_2)\n        return NULL;            /* COMMENT_0 */\n\n    if (VAR_0->s3->send_connection_binding) {\n        int VAR_15;\n\n        if (!ssl_add_serverhello_renegotiate_ext(VAR_0, 0, &VAR_15, 0)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n\n        /* COMMENT_1 */\n                                  \n                                                          \n                              \n           \n        if (CHECKLEN(VAR_6, 4 + VAR_15, VAR_2))\n            return NULL;\n\n        s2n(VAR_18, VAR_6);\n        s2n(VAR_15, VAR_6);\n\n        if (!ssl_add_serverhello_renegotiate_ext(VAR_0, VAR_6, &VAR_15, VAR_15)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n\n        VAR_6 += VAR_15;\n    }\n\n    /* COMMENT_6 */\n    if (VAR_0->version == VAR_19)\n        goto done;\n\n    if (!VAR_0->hit && VAR_0->servername_done == 1\n        && VAR_0->session->tlsext_hostname != NULL) {\n        /* COMMENT_7 */\n                                  \n                                                                \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n\n        s2n(VAR_20, VAR_6);\n        s2n(0, VAR_6);\n    }\n#ifndef VAR_9\n    if (VAR_12) {\n        const unsigned char *VAR_21;\n        size_t VAR_22;\n        /* COMMENT_11 */\n                                                                      \n           \n\n        tls1_get_formatlist(VAR_0, &VAR_21, &VAR_22);\n\n        if (VAR_22 > 255) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n\n        /* COMMENT_14 */\n                                  \n                                                                     \n                                                   \n                                         \n           \n        if (CHECKLEN(VAR_6, 5 + VAR_22, VAR_2))\n            return NULL;\n\n        s2n(VAR_23, VAR_6);\n        s2n(VAR_22 + 1, VAR_6);\n        *(VAR_6++) = (unsigned char)VAR_22;\n        memcpy(VAR_6, VAR_21, VAR_22);\n        VAR_6 += VAR_22;\n\n    }\n    /* COMMENT_20 */\n                                                                     \n                \n       \n#endif                          /* COMMENT_24 */\n\n    if (VAR_0->tlsext_ticket_expected && tls_use_ticket(VAR_0)) {\n        /* COMMENT_25 */\n                                  \n                                                           \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n        s2n(VAR_24, VAR_6);\n        s2n(0, VAR_6);\n    } else {\n        /* COMMENT_29 */\n                                                                          \n                \n           \n        VAR_0->tlsext_ticket_expected = 0;\n    }\n\n    if (VAR_0->tlsext_status_expected) {\n        /* COMMENT_33 */\n                                  \n                                                                   \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n        s2n(VAR_25, VAR_6);\n        s2n(0, VAR_6);\n    }\n#ifndef VAR_26\n    if (SSL_IS_DTLS(VAR_0) && VAR_0->srtp_profile) {\n        int VAR_15;\n\n        /* COMMENT_37 */\n        if (ssl_add_serverhello_use_srtp_ext(VAR_0, 0, &VAR_15, 0)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n        /* COMMENT_38 */\n                                  \n                                                                  \n                                             \n           \n        if (CHECKLEN(VAR_6, 4 + VAR_15, VAR_2))\n            return NULL;\n\n        s2n(VAR_27, VAR_6);\n        s2n(VAR_15, VAR_6);\n\n        if (ssl_add_serverhello_use_srtp_ext(VAR_0, VAR_6, &VAR_15, VAR_15)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n        VAR_6 += VAR_15;\n    }\n#endif\n\n    if (((VAR_0->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (VAR_0->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(VAR_0) & VAR_28)) {\n        const unsigned char VAR_29[36] = {\n            0xfd, 0xe8,         /* COMMENT_43 */\n            0x00, 0x20,         /* COMMENT_44 */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n\n        /* COMMENT_45 */\n        if (CHECKLEN(VAR_6, sizeof(VAR_29), VAR_2))\n            return NULL;\n        memcpy(VAR_6, VAR_29, sizeof(VAR_29));\n        VAR_6 += sizeof(VAR_29);\n\n    }\n#ifndef VAR_30\n    /* COMMENT_46 */\n    if (SSL_IS_DTLS(VAR_0) && (VAR_0->tlsext_heartbeat & VAR_31)) {\n        /* COMMENT_47 */\n                                  \n                                                              \n                              \n           \n        if (CHECKLEN(VAR_6, 5, VAR_2))\n            return NULL;\n        s2n(VAR_32, VAR_6);\n        s2n(1, VAR_6);\n        /* COMMENT_52 */\n                    \n                                    \n                                               \n           \n        if (VAR_0->tlsext_heartbeat & VAR_33)\n            *(VAR_6++) = VAR_34;\n        else\n            *(VAR_6++) = VAR_31;\n\n    }\n#endif\n\n#ifndef VAR_7\n    VAR_8 = VAR_0->s3->next_proto_neg_seen;\n    VAR_0->s3->next_proto_neg_seen = 0;\n    if (VAR_8 && VAR_0->ctx->next_protos_advertised_cb) {\n        const unsigned char *VAR_35;\n        unsigned int VAR_36;\n        int VAR_37;\n\n        VAR_37 = VAR_0->ctx->next_protos_advertised_cb(VAR_0, &VAR_35, &VAR_36,\n                                              VAR_0->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (VAR_37 == VAR_38) {\n            /* COMMENT_57 */\n                                      \n                                                            \n                                         \n               \n            if (CHECKLEN(VAR_6, 4 + VAR_36, VAR_2))\n                return NULL;\n            s2n(VAR_39, VAR_6);\n            s2n(VAR_36, VAR_6);\n            memcpy(VAR_6, VAR_35, VAR_36);\n            VAR_6 += VAR_36;\n            VAR_0->s3->next_proto_neg_seen = 1;\n        }\n    }\n#endif\n    if (!custom_ext_add(VAR_0, 1, &VAR_6, VAR_2, VAR_3))\n        return NULL;\n    if (VAR_0->s3->flags & VAR_40) {\n        /* COMMENT_62 */\n                                                                          \n                               \n           \n        if (SSL_IS_DTLS(VAR_0) || VAR_0->s3->tmp.new_cipher->algorithm_mac == VAR_41\n            || VAR_0->s3->tmp.new_cipher->algorithm_enc == VAR_42\n            || VAR_0->s3->tmp.new_cipher->algorithm_enc == VAR_43\n            || VAR_0->s3->tmp.new_cipher->algorithm_enc == VAR_44)\n            VAR_0->s3->flags &= ~VAR_40;\n        else {\n            /* COMMENT_66 */\n                                      \n                                                            \n               \n            if (CHECKLEN(VAR_6, 4, VAR_2))\n                return NULL;\n            s2n(VAR_45, VAR_6);\n            s2n(0, VAR_6);\n        }\n    }\n    if (VAR_0->s3->flags & VAR_46) {\n        /* COMMENT_70 */\n                                  \n                                                        \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n        s2n(VAR_47, VAR_6);\n        s2n(0, VAR_6);\n    }\n\n    if (VAR_0->s3->alpn_selected != NULL) {\n        const unsigned char *VAR_48 = VAR_0->s3->alpn_selected;\n        size_t VAR_49 = VAR_0->s3->alpn_selected_len;\n\n        /* COMMENT_74 */\n                                  \n                                                         \n                                       \n                                              \n                                            \n           \n        if (CHECKLEN(VAR_6, 7 + VAR_49, VAR_2))\n            return NULL;\n        s2n(VAR_50, VAR_6);\n        s2n(3 + VAR_49, VAR_6);\n        s2n(1 + VAR_49, VAR_6);\n        *VAR_6++ = VAR_49;\n        memcpy(VAR_6, VAR_48, VAR_49);\n        VAR_6 += VAR_49;\n    }\n\n done:\n\n    if ((VAR_4 = VAR_6 - VAR_5 - 2) == 0)\n        return VAR_5;\n\n    s2n(VAR_4, VAR_5);\n    return VAR_6;\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_lib.c/vul/before/1.json",
  "func": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,\n                                          unsigned char *limit, int *al)\n{\n    int extdatalen = 0;\n    unsigned char *orig = buf;\n    unsigned char *ret = buf;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    int next_proto_neg_seen;\n#endif\n#ifndef OPENSSL_NO_EC\n    unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n    int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA);\n    using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    ret += 2;\n    if (ret >= limit)\n        return NULL;            /* this really never occurs, but ... */\n\n    if (s->s3->send_connection_binding) {\n        int el;\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the reneg type and extension length\n         * + reneg data length\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_renegotiate, ret);\n        s2n(el, ret);\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        ret += el;\n    }\n\n    /* Only add RI for SSLv3 */\n    if (s->version == SSL3_VERSION)\n        goto done;\n\n    if (!s->hit && s->servername_done == 1\n        && s->session->tlsext_hostname != NULL) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the server name type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_server_name, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        const unsigned char *plist;\n        size_t plistlen;\n        /*\n         * Add TLS extension ECPointFormats to the ServerHello message\n         */\n\n        tls1_get_formatlist(s, &plist, &plistlen);\n\n        if (plistlen > 255) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ec points format type and extension length\n         * 1 byte for the points format list length\n         * + length of points format list\n         */\n        if (CHECKLEN(ret, 5 + plistlen, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_ec_point_formats, ret);\n        s2n(plistlen + 1, ret);\n        *(ret++) = (unsigned char)plistlen;\n        memcpy(ret, plist, plistlen);\n        ret += plistlen;\n\n    }\n    /*\n     * Currently the server should not respond with a SupportedCurves\n     * extension\n     */\n#endif                          /* OPENSSL_NO_EC */\n\n    if (s->tlsext_ticket_expected && tls_use_ticket(s)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Ticket type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_session_ticket, ret);\n        s2n(0, ret);\n    } else {\n        /*\n         * if we don't add the above TLSEXT, we can't add a session ticket\n         * later\n         */\n        s->tlsext_ticket_expected = 0;\n    }\n\n    if (s->tlsext_status_expected) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Status request type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_status_request, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && s->srtp_profile) {\n        int el;\n\n        /* Returns 0 on success!! */\n        if (ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        /*-\n         * check for enough space.\n         * 4 bytes for the SRTP profiles type and extension length\n         * + length of the SRTP profiles list\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_use_srtp, ret);\n        s2n(el, ret);\n\n        if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        ret += el;\n    }\n#endif\n\n    if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {\n        const unsigned char cryptopro_ext[36] = {\n            0xfd, 0xe8,         /* 65000 */\n            0x00, 0x20,         /* 32 bytes length */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n\n        /* check for enough space. */\n        if (CHECKLEN(ret, sizeof(cryptopro_ext), limit))\n            return NULL;\n        memcpy(ret, cryptopro_ext, sizeof(cryptopro_ext));\n        ret += sizeof(cryptopro_ext);\n\n    }\n#ifndef OPENSSL_NO_HEARTBEATS\n    /* Add Heartbeat extension if we've received one */\n    if (SSL_IS_DTLS(s) && (s->tlsext_heartbeat & SSL_DTLSEXT_HB_ENABLED)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Heartbeat type and extension length\n         * 1 byte for the mode\n         */\n        if (CHECKLEN(ret, 5, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_heartbeat, ret);\n        s2n(1, ret);\n        /*-\n         * Set mode:\n         * 1: peer may send requests\n         * 2: peer not allowed to send requests\n         */\n        if (s->tlsext_heartbeat & SSL_DTLSEXT_HB_DONT_RECV_REQUESTS)\n            *(ret++) = SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n        else\n            *(ret++) = SSL_DTLSEXT_HB_ENABLED;\n\n    }\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    next_proto_neg_seen = s->s3->next_proto_neg_seen;\n    s->s3->next_proto_neg_seen = 0;\n    if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {\n        const unsigned char *npa;\n        unsigned int npalen;\n        int r;\n\n        r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,\n                                              s->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (r == SSL_TLSEXT_ERR_OK) {\n            /*-\n             * check for enough space.\n             * 4 bytes for the NPN type and extension length\n             * + length of protocols list\n             */\n            if (CHECKLEN(ret, 4 + npalen, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_next_proto_neg, ret);\n            s2n(npalen, ret);\n            memcpy(ret, npa, npalen);\n            ret += npalen;\n            s->s3->next_proto_neg_seen = 1;\n        }\n    }\n#endif\n    if (!custom_ext_add(s, 1, &ret, limit, al))\n        return NULL;\n    if (s->tlsext_use_etm) {\n        /*\n         * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n         * for other cases too.\n         */\n        if (SSL_IS_DTLS(s) || s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n            s->tlsext_use_etm = 0;\n        else {\n            /*-\n             * check for enough space.\n             * 4 bytes for the ETM type and extension length\n             */\n            if (CHECKLEN(ret, 4, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_encrypt_then_mac, ret);\n            s2n(0, ret);\n        }\n    }\n    if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the EMS type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_extended_master_secret, ret);\n        s2n(0, ret);\n    }\n\n    if (s->s3->alpn_selected != NULL) {\n        const unsigned char *selected = s->s3->alpn_selected;\n        size_t len = s->s3->alpn_selected_len;\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ALPN type and extension length\n         * 2 bytes for ALPN data length\n         * 1 byte for selected protocol length\n         * + length of the selected protocol\n         */\n        if (CHECKLEN(ret, 7 + len, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\n        s2n(3 + len, ret);\n        s2n(1 + len, ret);\n        *ret++ = len;\n        memcpy(ret, selected, len);\n        ret += len;\n    }\n\n done:\n\n    if ((extdatalen = ret - orig - 2) == 0)\n        return orig;\n\n    s2n(extdatalen, orig);\n    return ret;\n}",
  "abstract_func": "unsigned char *ssl_add_serverhello_tlsext(SSL *VAR_0, unsigned char *VAR_1,\n                                          unsigned char *VAR_2, int *VAR_3)\n{\n    int VAR_4 = 0;\n    unsigned char *VAR_5 = VAR_1;\n    unsigned char *VAR_6 = VAR_1;\n#ifndef VAR_7\n    int VAR_8;\n#endif\n#ifndef VAR_9\n    unsigned long VAR_10 = VAR_0->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long VAR_11 = VAR_0->s3->tmp.new_cipher->algorithm_auth;\n    int VAR_12 = (VAR_10 & VAR_13) || (VAR_11 & VAR_14);\n    VAR_12 = VAR_12 && (VAR_0->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    VAR_6 += 2;\n    if (VAR_6 >= VAR_2)\n        return NULL;            /* COMMENT_0 */\n\n    if (VAR_0->s3->send_connection_binding) {\n        int VAR_15;\n\n        if (!ssl_add_serverhello_renegotiate_ext(VAR_0, 0, &VAR_15, 0)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n\n        /* COMMENT_1 */\n                                  \n                                                          \n                              \n           \n        if (CHECKLEN(VAR_6, 4 + VAR_15, VAR_2))\n            return NULL;\n\n        s2n(VAR_18, VAR_6);\n        s2n(VAR_15, VAR_6);\n\n        if (!ssl_add_serverhello_renegotiate_ext(VAR_0, VAR_6, &VAR_15, VAR_15)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n\n        VAR_6 += VAR_15;\n    }\n\n    /* COMMENT_6 */\n    if (VAR_0->version == VAR_19)\n        goto done;\n\n    if (!VAR_0->hit && VAR_0->servername_done == 1\n        && VAR_0->session->tlsext_hostname != NULL) {\n        /* COMMENT_7 */\n                                  \n                                                                \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n\n        s2n(VAR_20, VAR_6);\n        s2n(0, VAR_6);\n    }\n#ifndef VAR_9\n    if (VAR_12) {\n        const unsigned char *VAR_21;\n        size_t VAR_22;\n        /* COMMENT_11 */\n                                                                      \n           \n\n        tls1_get_formatlist(VAR_0, &VAR_21, &VAR_22);\n\n        if (VAR_22 > 255) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n\n        /* COMMENT_14 */\n                                  \n                                                                     \n                                                   \n                                         \n           \n        if (CHECKLEN(VAR_6, 5 + VAR_22, VAR_2))\n            return NULL;\n\n        s2n(VAR_23, VAR_6);\n        s2n(VAR_22 + 1, VAR_6);\n        *(VAR_6++) = (unsigned char)VAR_22;\n        memcpy(VAR_6, VAR_21, VAR_22);\n        VAR_6 += VAR_22;\n\n    }\n    /* COMMENT_20 */\n                                                                     \n                \n       \n#endif                          /* COMMENT_24 */\n\n    if (VAR_0->tlsext_ticket_expected && tls_use_ticket(VAR_0)) {\n        /* COMMENT_25 */\n                                  \n                                                           \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n        s2n(VAR_24, VAR_6);\n        s2n(0, VAR_6);\n    } else {\n        /* COMMENT_29 */\n                                                                          \n                \n           \n        VAR_0->tlsext_ticket_expected = 0;\n    }\n\n    if (VAR_0->tlsext_status_expected) {\n        /* COMMENT_33 */\n                                  \n                                                                   \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n        s2n(VAR_25, VAR_6);\n        s2n(0, VAR_6);\n    }\n#ifndef VAR_26\n    if (SSL_IS_DTLS(VAR_0) && VAR_0->srtp_profile) {\n        int VAR_15;\n\n        /* COMMENT_37 */\n        if (ssl_add_serverhello_use_srtp_ext(VAR_0, 0, &VAR_15, 0)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n        /* COMMENT_38 */\n                                  \n                                                                  \n                                             \n           \n        if (CHECKLEN(VAR_6, 4 + VAR_15, VAR_2))\n            return NULL;\n\n        s2n(VAR_27, VAR_6);\n        s2n(VAR_15, VAR_6);\n\n        if (ssl_add_serverhello_use_srtp_ext(VAR_0, VAR_6, &VAR_15, VAR_15)) {\n            SSLerr(VAR_16, VAR_17);\n            return NULL;\n        }\n        VAR_6 += VAR_15;\n    }\n#endif\n\n    if (((VAR_0->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (VAR_0->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(VAR_0) & VAR_28)) {\n        const unsigned char VAR_29[36] = {\n            0xfd, 0xe8,         /* COMMENT_43 */\n            0x00, 0x20,         /* COMMENT_44 */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n\n        /* COMMENT_45 */\n        if (CHECKLEN(VAR_6, sizeof(VAR_29), VAR_2))\n            return NULL;\n        memcpy(VAR_6, VAR_29, sizeof(VAR_29));\n        VAR_6 += sizeof(VAR_29);\n\n    }\n#ifndef VAR_30\n    /* COMMENT_46 */\n    if (SSL_IS_DTLS(VAR_0) && (VAR_0->tlsext_heartbeat & VAR_31)) {\n        /* COMMENT_47 */\n                                  \n                                                              \n                              \n           \n        if (CHECKLEN(VAR_6, 5, VAR_2))\n            return NULL;\n        s2n(VAR_32, VAR_6);\n        s2n(1, VAR_6);\n        /* COMMENT_52 */\n                    \n                                    \n                                               \n           \n        if (VAR_0->tlsext_heartbeat & VAR_33)\n            *(VAR_6++) = VAR_34;\n        else\n            *(VAR_6++) = VAR_31;\n\n    }\n#endif\n\n#ifndef VAR_7\n    VAR_8 = VAR_0->s3->next_proto_neg_seen;\n    VAR_0->s3->next_proto_neg_seen = 0;\n    if (VAR_8 && VAR_0->ctx->next_protos_advertised_cb) {\n        const unsigned char *VAR_35;\n        unsigned int VAR_36;\n        int VAR_37;\n\n        VAR_37 = VAR_0->ctx->next_protos_advertised_cb(VAR_0, &VAR_35, &VAR_36,\n                                              VAR_0->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (VAR_37 == VAR_38) {\n            /* COMMENT_57 */\n                                      \n                                                            \n                                         \n               \n            if (CHECKLEN(VAR_6, 4 + VAR_36, VAR_2))\n                return NULL;\n            s2n(VAR_39, VAR_6);\n            s2n(VAR_36, VAR_6);\n            memcpy(VAR_6, VAR_35, VAR_36);\n            VAR_6 += VAR_36;\n            VAR_0->s3->next_proto_neg_seen = 1;\n        }\n    }\n#endif\n    if (!custom_ext_add(VAR_0, 1, &VAR_6, VAR_2, VAR_3))\n        return NULL;\n    if (VAR_0->tlsext_use_etm) {\n        /* COMMENT_62 */\n                                                                          \n                               \n           \n        if (SSL_IS_DTLS(VAR_0) || VAR_0->s3->tmp.new_cipher->algorithm_mac == VAR_40\n            || VAR_0->s3->tmp.new_cipher->algorithm_enc == VAR_41\n            || VAR_0->s3->tmp.new_cipher->algorithm_enc == VAR_42\n            || VAR_0->s3->tmp.new_cipher->algorithm_enc == VAR_43)\n            VAR_0->tlsext_use_etm = 0;\n        else {\n            /* COMMENT_66 */\n                                      \n                                                            \n               \n            if (CHECKLEN(VAR_6, 4, VAR_2))\n                return NULL;\n            s2n(VAR_44, VAR_6);\n            s2n(0, VAR_6);\n        }\n    }\n    if (VAR_0->s3->flags & VAR_45) {\n        /* COMMENT_70 */\n                                  \n                                                        \n           \n        if (CHECKLEN(VAR_6, 4, VAR_2))\n            return NULL;\n        s2n(VAR_46, VAR_6);\n        s2n(0, VAR_6);\n    }\n\n    if (VAR_0->s3->alpn_selected != NULL) {\n        const unsigned char *VAR_47 = VAR_0->s3->alpn_selected;\n        size_t VAR_48 = VAR_0->s3->alpn_selected_len;\n\n        /* COMMENT_74 */\n                                  \n                                                         \n                                       \n                                              \n                                            \n           \n        if (CHECKLEN(VAR_6, 7 + VAR_48, VAR_2))\n            return NULL;\n        s2n(VAR_49, VAR_6);\n        s2n(3 + VAR_48, VAR_6);\n        s2n(1 + VAR_48, VAR_6);\n        *VAR_6++ = VAR_48;\n        memcpy(VAR_6, VAR_47, VAR_48);\n        VAR_6 += VAR_48;\n    }\n\n done:\n\n    if ((VAR_4 = VAR_6 - VAR_5 - 2) == 0)\n        return VAR_5;\n\n    s2n(VAR_4, VAR_5);\n    return VAR_6;\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_lib.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -226,7 +226,7 @@\n #endif\n     if (!custom_ext_add(s, 1, &ret, limit, al))\n         return NULL;\n-    if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {\n+    if (s->tlsext_use_etm) {\n         /*\n          * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n          * for other cases too.\n@@ -235,7 +235,7 @@\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n-            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+            s->tlsext_use_etm = 0;\n         else {\n             /*-\n              * check for enough space.",
  "diff_line_info": {
    "deleted_lines": [
      "    if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {",
      "            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;"
    ],
    "added_lines": [
      "    if (s->tlsext_use_etm) {",
      "            s->tlsext_use_etm = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/EktapopaT/openssl/pull/1: 403 Client Error: Forbidden for url: https://api.github.com/repos/EktapopaT/openssl/pulls/1",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}