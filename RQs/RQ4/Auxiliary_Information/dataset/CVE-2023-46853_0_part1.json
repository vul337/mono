{
  "cve_id": "CVE-2023-46853",
  "cwe_ids": [
    "CWE-193"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "memcached",
  "commit_msg": "proxy: fix off-by-one if \\r is missing\n\nA bunch of the parser assumed we only had \\r\\n, but I didn't actually\nhave that strictness set. Some commands worked and some broke in subtle\nways when just \"\\n\" was being submitted.\n\nI'm not 100% confident in this change yet so I'm opening a PR to stage\nit while I run some more thorough tests.",
  "commit_hash": "6987918e9a3094ec4fc8976f01f769f624d790fa",
  "git_url": "https://github.com/memcached/memcached/commit/6987918e9a3094ec4fc8976f01f769f624d790fa",
  "file_path": "proxy_request.c",
  "func_name": "process_request",
  "func_before": "int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen) {\n    // we want to \"parse in place\" as much as possible, which allows us to\n    // forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    const char *s = memchr(command, ' ', cmdlen-2);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = cmdlen - 2;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl + 1;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:\n        case 1:\n            // falls through with cmd as -1. should error.\n            break;\n        case 2:\n            if (cm[0] == 'm') {\n                type = CMD_TYPE_META;\n                switch (cm[1]) {\n                    case 'g':\n                        cmd = CMD_MG;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 's':\n                        cmd = CMD_MS;\n                        ret = _process_request_mset(pr);\n                        break;\n                    case 'd':\n                        cmd = CMD_MD;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'n':\n                        // TODO: do we route/handle NOP's at all?\n                        // they should simply reflect to the client.\n                        cmd = CMD_MN;\n                        break;\n                    case 'a':\n                        cmd = CMD_MA;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'e':\n                        cmd = CMD_ME;\n                        // TODO: not much special processing here; binary keys\n                        ret = _process_request_meta(pr);\n                        break;\n                }\n            }\n            break;\n        case 3:\n            if (cm[0] == 'g') {\n                if (cm[1] == 'e' && cm[2] == 't') {\n                    cmd = CMD_GET;\n                    type = CMD_TYPE_GET;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_simple(pr, 2, 2);\n                }\n                if (cm[1] == 'a' && cm[2] == 't') {\n                    type = CMD_TYPE_GET;\n                    cmd = CMD_GAT;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_gat(pr);\n                }\n            } else if (cm[0] == 's' && cm[1] == 'e' && cm[2] == 't') {\n                cmd = CMD_SET;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'a' && cm[1] == 'd' && cm[2] == 'd') {\n                cmd = CMD_ADD;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'c' && cm[1] == 'a' && cm[2] == 's') {\n                cmd = CMD_CAS;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 4:\n            if (strncmp(cm, \"gets\", 4) == 0) {\n                cmd = CMD_GETS;\n                type = CMD_TYPE_GET;\n                token_max = 2; // don't chew through multigets.\n                ret = _process_request_simple(pr, 2, 2);\n            } else if (strncmp(cm, \"incr\", 4) == 0) {\n                cmd = CMD_INCR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"decr\", 4) == 0) {\n                cmd = CMD_DECR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"gats\", 4) == 0) {\n                cmd = CMD_GATS;\n                type = CMD_TYPE_GET;\n                ret = _process_request_gat(pr);\n            } else if (strncmp(cm, \"quit\", 4) == 0) {\n                cmd = CMD_QUIT;\n            }\n            break;\n        case 5:\n            if (strncmp(cm, \"touch\", 5) == 0) {\n                cmd = CMD_TOUCH;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"stats\", 5) == 0) {\n                cmd = CMD_STATS;\n                // Don't process a key; fetch via arguments.\n                _process_tokenize(pr, token_max);\n            } else if (strncmp(cm, \"watch\", 5) == 0) {\n                cmd = CMD_WATCH;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n        case 6:\n            if (strncmp(cm, \"delete\", 6) == 0) {\n                cmd = CMD_DELETE;\n                ret = _process_request_simple(pr, 2, 4);\n            } else if (strncmp(cm, \"append\", 6) == 0) {\n                cmd = CMD_APPEND;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 7:\n            if (strncmp(cm, \"replace\", 7) == 0) {\n                cmd = CMD_REPLACE;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"prepend\", 7) == 0) {\n                cmd = CMD_PREPEND;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"version\", 7) == 0) {\n                cmd = CMD_VERSION;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n    }\n\n    // TODO: log more specific error code.\n    if (cmd == -1 || ret != 0) {\n        return -1;\n    }\n\n    pr->command = cmd;\n    pr->cmd_type = type;\n\n    return 0;\n}",
  "abstract_func_before": "int process_request(mcp_parser_t *VAR_0, const char *VAR_1, size_t VAR_2) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n\n    const char *VAR_3 = VAR_1;\n    size_t VAR_4 = 0;\n    /* COMMENT_2 */\n    if (VAR_2 < 4) {\n        return -1;\n    }\n\n    const char *VAR_5 = memchr(VAR_1, ' ', VAR_2-2);\n    if (VAR_5 != NULL) {\n        VAR_4 = VAR_5 - VAR_1;\n    } else {\n        VAR_4 = VAR_2 - 2;\n    }\n    VAR_0->keytoken = 0;\n    VAR_0->has_space = false;\n    VAR_0->parsed = VAR_4 + 1;\n    VAR_0->request = VAR_1;\n    VAR_0->reqlen = VAR_2;\n    int VAR_6 = VAR_7;\n\n    int VAR_8 = -1;\n    int VAR_9 = VAR_10;\n    int VAR_11 = 0;\n\n    switch (VAR_4) {\n        case 0:\n        case 1:\n            /* COMMENT_3 */\n            break;\n        case 2:\n            if (VAR_3[0] == 'm') {\n                VAR_9 = VAR_12;\n                switch (VAR_3[1]) {\n                    case 'g':\n                        VAR_8 = VAR_13;\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                    case 's':\n                        VAR_8 = VAR_14;\n                        VAR_11 = _process_request_mset(VAR_0);\n                        break;\n                    case 'd':\n                        VAR_8 = VAR_15;\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                    case 'n':\n                        /* COMMENT_4 */\n                        /* COMMENT_5 */\n                        VAR_8 = VAR_16;\n                        break;\n                    case 'a':\n                        VAR_8 = VAR_17;\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                    case 'e':\n                        VAR_8 = VAR_18;\n                        /* COMMENT_6 */\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                }\n            }\n            break;\n        case 3:\n            if (VAR_3[0] == 'g') {\n                if (VAR_3[1] == 'e' && VAR_3[2] == 't') {\n                    VAR_8 = VAR_19;\n                    VAR_9 = VAR_20;\n                    VAR_6 = 2; /* COMMENT_7 */\n                    VAR_11 = _process_request_simple(VAR_0, 2, 2);\n                }\n                if (VAR_3[1] == 'a' && VAR_3[2] == 't') {\n                    VAR_9 = VAR_20;\n                    VAR_8 = VAR_21;\n                    VAR_6 = 2; /* COMMENT_7 */\n                    VAR_11 = _process_request_gat(VAR_0);\n                }\n            } else if (VAR_3[0] == 's' && VAR_3[1] == 'e' && VAR_3[2] == 't') {\n                VAR_8 = VAR_22;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (VAR_3[0] == 'a' && VAR_3[1] == 'd' && VAR_3[2] == 'd') {\n                VAR_8 = VAR_23;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (VAR_3[0] == 'c' && VAR_3[1] == 'a' && VAR_3[2] == 's') {\n                VAR_8 = VAR_24;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            }\n            break;\n        case 4:\n            if (strncmp(VAR_3, \"gets\", 4) == 0) {\n                VAR_8 = VAR_25;\n                VAR_9 = VAR_20;\n                VAR_6 = 2; /* COMMENT_7 */\n                VAR_11 = _process_request_simple(VAR_0, 2, 2);\n            } else if (strncmp(VAR_3, \"incr\", 4) == 0) {\n                VAR_8 = VAR_26;\n                VAR_11 = _process_request_simple(VAR_0, 3, 4);\n            } else if (strncmp(VAR_3, \"decr\", 4) == 0) {\n                VAR_8 = VAR_27;\n                VAR_11 = _process_request_simple(VAR_0, 3, 4);\n            } else if (strncmp(VAR_3, \"gats\", 4) == 0) {\n                VAR_8 = VAR_28;\n                VAR_9 = VAR_20;\n                VAR_11 = _process_request_gat(VAR_0);\n            } else if (strncmp(VAR_3, \"quit\", 4) == 0) {\n                VAR_8 = VAR_29;\n            }\n            break;\n        case 5:\n            if (strncmp(VAR_3, \"touch\", 5) == 0) {\n                VAR_8 = VAR_30;\n                VAR_11 = _process_request_simple(VAR_0, 3, 4);\n            } else if (strncmp(VAR_3, \"stats\", 5) == 0) {\n                VAR_8 = VAR_31;\n                /* COMMENT_8 */\n                _process_tokenize(VAR_0, VAR_6);\n            } else if (strncmp(VAR_3, \"watch\", 5) == 0) {\n                VAR_8 = VAR_32;\n                _process_tokenize(VAR_0, VAR_6);\n            }\n            break;\n        case 6:\n            if (strncmp(VAR_3, \"delete\", 6) == 0) {\n                VAR_8 = VAR_33;\n                VAR_11 = _process_request_simple(VAR_0, 2, 4);\n            } else if (strncmp(VAR_3, \"append\", 6) == 0) {\n                VAR_8 = VAR_34;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            }\n            break;\n        case 7:\n            if (strncmp(VAR_3, \"replace\", 7) == 0) {\n                VAR_8 = VAR_35;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (strncmp(VAR_3, \"prepend\", 7) == 0) {\n                VAR_8 = VAR_36;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (strncmp(VAR_3, \"version\", 7) == 0) {\n                VAR_8 = VAR_37;\n                _process_tokenize(VAR_0, VAR_6);\n            }\n            break;\n    }\n\n    /* COMMENT_9 */\n    if (VAR_8 == -1 || VAR_11 != 0) {\n        return -1;\n    }\n\n    VAR_0->command = VAR_8;\n    VAR_0->cmd_type = VAR_9;\n\n    return 0;\n}",
  "func_graph_path_before": "memcached/6987918e9a3094ec4fc8976f01f769f624d790fa/proxy_request.c/vul/before/1.json",
  "func": "int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen) {\n    // we want to \"parse in place\" as much as possible, which allows us to\n    // forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    // Commands can end with bare '\\n's. Depressingly I intended to be strict\n    // with a \\r\\n requirement but never did this and need backcompat.\n    // In this case we _know_ \\n is at cmdlen because we can't enter this\n    // function otherwise.\n    if (cm[cmdlen-2] == '\\r') {\n        pr->endlen = cmdlen - 2;\n    } else {\n        pr->endlen = cmdlen - 1;\n    }\n\n    const char *s = memchr(command, ' ', pr->endlen);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = pr->endlen;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:\n        case 1:\n            // falls through with cmd as -1. should error.\n            break;\n        case 2:\n            if (cm[0] == 'm') {\n                type = CMD_TYPE_META;\n                switch (cm[1]) {\n                    case 'g':\n                        cmd = CMD_MG;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 's':\n                        cmd = CMD_MS;\n                        ret = _process_request_mset(pr);\n                        break;\n                    case 'd':\n                        cmd = CMD_MD;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'n':\n                        // TODO: do we route/handle NOP's at all?\n                        // they should simply reflect to the client.\n                        cmd = CMD_MN;\n                        break;\n                    case 'a':\n                        cmd = CMD_MA;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'e':\n                        cmd = CMD_ME;\n                        // TODO: not much special processing here; binary keys\n                        ret = _process_request_meta(pr);\n                        break;\n                }\n            }\n            break;\n        case 3:\n            if (cm[0] == 'g') {\n                if (cm[1] == 'e' && cm[2] == 't') {\n                    cmd = CMD_GET;\n                    type = CMD_TYPE_GET;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_simple(pr, 2, 2);\n                }\n                if (cm[1] == 'a' && cm[2] == 't') {\n                    type = CMD_TYPE_GET;\n                    cmd = CMD_GAT;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_gat(pr);\n                }\n            } else if (cm[0] == 's' && cm[1] == 'e' && cm[2] == 't') {\n                cmd = CMD_SET;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'a' && cm[1] == 'd' && cm[2] == 'd') {\n                cmd = CMD_ADD;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'c' && cm[1] == 'a' && cm[2] == 's') {\n                cmd = CMD_CAS;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 4:\n            if (strncmp(cm, \"gets\", 4) == 0) {\n                cmd = CMD_GETS;\n                type = CMD_TYPE_GET;\n                token_max = 2; // don't chew through multigets.\n                ret = _process_request_simple(pr, 2, 2);\n            } else if (strncmp(cm, \"incr\", 4) == 0) {\n                cmd = CMD_INCR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"decr\", 4) == 0) {\n                cmd = CMD_DECR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"gats\", 4) == 0) {\n                cmd = CMD_GATS;\n                type = CMD_TYPE_GET;\n                ret = _process_request_gat(pr);\n            } else if (strncmp(cm, \"quit\", 4) == 0) {\n                cmd = CMD_QUIT;\n            }\n            break;\n        case 5:\n            if (strncmp(cm, \"touch\", 5) == 0) {\n                cmd = CMD_TOUCH;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"stats\", 5) == 0) {\n                cmd = CMD_STATS;\n                // Don't process a key; fetch via arguments.\n                _process_tokenize(pr, token_max);\n            } else if (strncmp(cm, \"watch\", 5) == 0) {\n                cmd = CMD_WATCH;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n        case 6:\n            if (strncmp(cm, \"delete\", 6) == 0) {\n                cmd = CMD_DELETE;\n                ret = _process_request_simple(pr, 2, 4);\n            } else if (strncmp(cm, \"append\", 6) == 0) {\n                cmd = CMD_APPEND;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 7:\n            if (strncmp(cm, \"replace\", 7) == 0) {\n                cmd = CMD_REPLACE;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"prepend\", 7) == 0) {\n                cmd = CMD_PREPEND;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"version\", 7) == 0) {\n                cmd = CMD_VERSION;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n    }\n\n    // TODO: log more specific error code.\n    if (cmd == -1 || ret != 0) {\n        return -1;\n    }\n\n    pr->command = cmd;\n    pr->cmd_type = type;\n\n    return 0;\n}",
  "abstract_func": "int process_request(mcp_parser_t *VAR_0, const char *VAR_1, size_t VAR_2) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n\n    const char *VAR_3 = VAR_1;\n    size_t VAR_4 = 0;\n    /* COMMENT_2 */\n    if (VAR_2 < 4) {\n        return -1;\n    }\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if (VAR_3[VAR_2-2] == '\\r') {\n        VAR_0->endlen = VAR_2 - 2;\n    } else {\n        VAR_0->endlen = VAR_2 - 1;\n    }\n\n    const char *VAR_5 = memchr(VAR_1, ' ', VAR_0->endlen);\n    if (VAR_5 != NULL) {\n        VAR_4 = VAR_5 - VAR_1;\n    } else {\n        VAR_4 = VAR_0->endlen;\n    }\n    VAR_0->keytoken = 0;\n    VAR_0->has_space = false;\n    VAR_0->parsed = VAR_4;\n    VAR_0->request = VAR_1;\n    VAR_0->reqlen = VAR_2;\n    int VAR_6 = VAR_7;\n\n    int VAR_8 = -1;\n    int VAR_9 = VAR_10;\n    int VAR_11 = 0;\n\n    switch (VAR_4) {\n        case 0:\n        case 1:\n            /* COMMENT_7 */\n            break;\n        case 2:\n            if (VAR_3[0] == 'm') {\n                VAR_9 = VAR_12;\n                switch (VAR_3[1]) {\n                    case 'g':\n                        VAR_8 = VAR_13;\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                    case 's':\n                        VAR_8 = VAR_14;\n                        VAR_11 = _process_request_mset(VAR_0);\n                        break;\n                    case 'd':\n                        VAR_8 = VAR_15;\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                    case 'n':\n                        /* COMMENT_8 */\n                        /* COMMENT_9 */\n                        VAR_8 = VAR_16;\n                        break;\n                    case 'a':\n                        VAR_8 = VAR_17;\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                    case 'e':\n                        VAR_8 = VAR_18;\n                        /* COMMENT_10 */\n                        VAR_11 = _process_request_meta(VAR_0);\n                        break;\n                }\n            }\n            break;\n        case 3:\n            if (VAR_3[0] == 'g') {\n                if (VAR_3[1] == 'e' && VAR_3[2] == 't') {\n                    VAR_8 = VAR_19;\n                    VAR_9 = VAR_20;\n                    VAR_6 = 2; /* COMMENT_11 */\n                    VAR_11 = _process_request_simple(VAR_0, 2, 2);\n                }\n                if (VAR_3[1] == 'a' && VAR_3[2] == 't') {\n                    VAR_9 = VAR_20;\n                    VAR_8 = VAR_21;\n                    VAR_6 = 2; /* COMMENT_11 */\n                    VAR_11 = _process_request_gat(VAR_0);\n                }\n            } else if (VAR_3[0] == 's' && VAR_3[1] == 'e' && VAR_3[2] == 't') {\n                VAR_8 = VAR_22;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (VAR_3[0] == 'a' && VAR_3[1] == 'd' && VAR_3[2] == 'd') {\n                VAR_8 = VAR_23;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (VAR_3[0] == 'c' && VAR_3[1] == 'a' && VAR_3[2] == 's') {\n                VAR_8 = VAR_24;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            }\n            break;\n        case 4:\n            if (strncmp(VAR_3, \"gets\", 4) == 0) {\n                VAR_8 = VAR_25;\n                VAR_9 = VAR_20;\n                VAR_6 = 2; /* COMMENT_11 */\n                VAR_11 = _process_request_simple(VAR_0, 2, 2);\n            } else if (strncmp(VAR_3, \"incr\", 4) == 0) {\n                VAR_8 = VAR_26;\n                VAR_11 = _process_request_simple(VAR_0, 3, 4);\n            } else if (strncmp(VAR_3, \"decr\", 4) == 0) {\n                VAR_8 = VAR_27;\n                VAR_11 = _process_request_simple(VAR_0, 3, 4);\n            } else if (strncmp(VAR_3, \"gats\", 4) == 0) {\n                VAR_8 = VAR_28;\n                VAR_9 = VAR_20;\n                VAR_11 = _process_request_gat(VAR_0);\n            } else if (strncmp(VAR_3, \"quit\", 4) == 0) {\n                VAR_8 = VAR_29;\n            }\n            break;\n        case 5:\n            if (strncmp(VAR_3, \"touch\", 5) == 0) {\n                VAR_8 = VAR_30;\n                VAR_11 = _process_request_simple(VAR_0, 3, 4);\n            } else if (strncmp(VAR_3, \"stats\", 5) == 0) {\n                VAR_8 = VAR_31;\n                /* COMMENT_12 */\n                _process_tokenize(VAR_0, VAR_6);\n            } else if (strncmp(VAR_3, \"watch\", 5) == 0) {\n                VAR_8 = VAR_32;\n                _process_tokenize(VAR_0, VAR_6);\n            }\n            break;\n        case 6:\n            if (strncmp(VAR_3, \"delete\", 6) == 0) {\n                VAR_8 = VAR_33;\n                VAR_11 = _process_request_simple(VAR_0, 2, 4);\n            } else if (strncmp(VAR_3, \"append\", 6) == 0) {\n                VAR_8 = VAR_34;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            }\n            break;\n        case 7:\n            if (strncmp(VAR_3, \"replace\", 7) == 0) {\n                VAR_8 = VAR_35;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (strncmp(VAR_3, \"prepend\", 7) == 0) {\n                VAR_8 = VAR_36;\n                VAR_11 = _process_request_storage(VAR_0, VAR_6);\n            } else if (strncmp(VAR_3, \"version\", 7) == 0) {\n                VAR_8 = VAR_37;\n                _process_tokenize(VAR_0, VAR_6);\n            }\n            break;\n    }\n\n    /* COMMENT_13 */\n    if (VAR_8 == -1 || VAR_11 != 0) {\n        return -1;\n    }\n\n    VAR_0->command = VAR_8;\n    VAR_0->cmd_type = VAR_9;\n\n    return 0;\n}",
  "func_graph_path": "memcached/6987918e9a3094ec4fc8976f01f769f624d790fa/proxy_request.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,15 +9,25 @@\n         return -1;\n     }\n \n-    const char *s = memchr(command, ' ', cmdlen-2);\n+    // Commands can end with bare '\\n's. Depressingly I intended to be strict\n+    // with a \\r\\n requirement but never did this and need backcompat.\n+    // In this case we _know_ \\n is at cmdlen because we can't enter this\n+    // function otherwise.\n+    if (cm[cmdlen-2] == '\\r') {\n+        pr->endlen = cmdlen - 2;\n+    } else {\n+        pr->endlen = cmdlen - 1;\n+    }\n+\n+    const char *s = memchr(command, ' ', pr->endlen);\n     if (s != NULL) {\n         cl = s - command;\n     } else {\n-        cl = cmdlen - 2;\n+        cl = pr->endlen;\n     }\n     pr->keytoken = 0;\n     pr->has_space = false;\n-    pr->parsed = cl + 1;\n+    pr->parsed = cl;\n     pr->request = command;\n     pr->reqlen = cmdlen;\n     int token_max = PARSER_MAX_TOKENS;",
  "diff_line_info": {
    "deleted_lines": [
      "    const char *s = memchr(command, ' ', cmdlen-2);",
      "        cl = cmdlen - 2;",
      "    pr->parsed = cl + 1;"
    ],
    "added_lines": [
      "    // Commands can end with bare '\\n's. Depressingly I intended to be strict",
      "    // with a \\r\\n requirement but never did this and need backcompat.",
      "    // In this case we _know_ \\n is at cmdlen because we can't enter this",
      "    // function otherwise.",
      "    if (cm[cmdlen-2] == '\\r') {",
      "        pr->endlen = cmdlen - 2;",
      "    } else {",
      "        pr->endlen = cmdlen - 1;",
      "    }",
      "",
      "    const char *s = memchr(command, ' ', pr->endlen);",
      "        cl = pr->endlen;",
      "    pr->parsed = cl;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/memcached/memcached/pull/1063",
  "description": {
    "pr_info": {
      "title": "proxy: fix off-by-one if \\r is missing",
      "number": 1063
    },
    "comment": [
      "A bunch of the parser assumed we only had \\r\\n, but I didn't actually have that strictness set. Some commands worked and some broke in subtle ways when just \"\\n\" was being submitted.\r\n\r\nI'm not 100% confident in this change yet so I'm opening a PR to stage it while I run some more thorough tests.",
      "running the stability suite on it now too.",
      "okay I'm good with this now. it's passed half the stability suite while I stepped through the code in a debugger.. so it's run through the multiget tests several times now."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}