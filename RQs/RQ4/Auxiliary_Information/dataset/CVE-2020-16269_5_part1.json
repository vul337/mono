{
  "cve_id": "CVE-2020-16269",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Removed code duplication",
  "commit_hash": "5319d3525523a5e1cb5d48005e4fd1b79512db95",
  "git_url": "https://github.com/radareorg/radare2/commit/5319d3525523a5e1cb5d48005e4fd1b79512db95",
  "file_path": "libr/anal/type_dwarf.c",
  "func_name": "parse_struct_member",
  "func_before": "static RAnalStructMember *parse_struct_member (const RBinDwarfDie *all_dies,\n\tconst ut64 all_dies_count, ut64 curr_die_idx, RAnalStructMember *result) {\n\n\tr_return_val_if_fail (all_dies && result, NULL);\n\tconst RBinDwarfDie *die = &all_dies[curr_die_idx];\n\n\tchar *name = NULL;\n\tchar *type = NULL;\n\tut64 offset = 0;\n\tut64 size = 0;\n\tRStrBuf strbuf;\n\tr_strbuf_init (&strbuf);\n\tsize_t i;\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tif (!value->string.content) {\n\t\t\t\tname = create_type_name_from_offset (die->offset);\n\t\t\t} else {\n\t\t\t\tname = strdup (value->string.content);\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_type:\n\t\t\tparse_type (all_dies, all_dies_count, value->reference, &strbuf, &size);\n\t\t\ttype = r_strbuf_drain_nofree (&strbuf);\n\t\t\tif (!type || !*type) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_data_member_location:\n\t\t\t/*\n\t\t\t\t2 cases, 1.: If val is integer, it offset in bytes from\n\t\t\t\tthe beginning of containing entity. If containing entity has \n\t\t\t\ta bit offset, member has that bit offset aswell\n\t\t\t\t2.: value is a location description \n\t\t\t\thttp://www.dwarfstd.org/doc/DWARF4.pdf#page=39&zoom=100,0,0\n\t\t\t*/\n\t\t\toffset = value->data;\n\t\t\tbreak;\n\t\tcase DW_AT_accessibility: // private, public etc.\n\t\tcase DW_AT_mutable: // flag is it is mutable\n\t\tcase DW_AT_data_bit_offset:\n\t\t\t/* \n\t\t\t\tint that specifies the number of bits from beginning\n\t\t\t\tof containing entity to the beginning of the data member\n\t\t\t*/\n\t\t\tbreak;\n\t\t// If the size of a data member is not the same as the\n\t\t//  size of the type given for the data member\n\t\tcase DW_AT_byte_size:\n\t\t\tsize = value->data * CHAR_BIT;\n\t\t\tbreak;\n\t\tcase DW_AT_bit_size:\n\t\t\tsize = value->data;\n\t\t\tbreak;\n\t\tcase DW_AT_containing_type:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult->name = name;\n\tresult->type = type;\n\tresult->offset = offset;\n\tresult->size = size;\n\treturn result;\ncleanup:\n\tfree (name);\n\tfree (type);\n\treturn NULL;\n}",
  "abstract_func_before": "static RAnalStructMember *parse_struct_member (const RBinDwarfDie *VAR_0,\n\tconst ut64 VAR_1, ut64 VAR_2, RAnalStructMember *VAR_3) {\n\n\tr_return_val_if_fail (VAR_0 && VAR_3, NULL);\n\tconst RBinDwarfDie *VAR_4 = &VAR_0[VAR_2];\n\n\tchar *VAR_5 = NULL;\n\tchar *VAR_6 = NULL;\n\tut64 VAR_7 = 0;\n\tut64 VAR_8 = 0;\n\tRStrBuf VAR_9;\n\tr_strbuf_init (&VAR_9);\n\tsize_t VAR_10;\n\tfor (VAR_10 = 0; VAR_10 < VAR_4->count; VAR_10++) {\n\t\tRBinDwarfAttrValue *VAR_11 = &VAR_4->attr_values[VAR_10];\n\t\tswitch (VAR_4->attr_values[VAR_10].attr_name) {\n\t\tcase VAR_12:\n\t\t\tif (!VAR_11->string.content) {\n\t\t\t\tVAR_5 = create_type_name_from_offset (VAR_4->offset);\n\t\t\t} else {\n\t\t\t\tVAR_5 = strdup (VAR_11->string.content);\n\t\t\t}\n\t\t\tif (!VAR_5) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_13:\n\t\t\tparse_type (VAR_0, VAR_1, VAR_11->reference, &VAR_9, &VAR_8);\n\t\t\tVAR_6 = r_strbuf_drain_nofree (&VAR_9);\n\t\t\tif (!VAR_6 || !*VAR_6) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_14:\n\t\t\t/* COMMENT_0 */\n                                                           \n                                                                 \n                                                   \n                                        \n                                                               \n     \n\t\t\tVAR_7 = VAR_11->data;\n\t\t\tbreak;\n\t\tcase VAR_15: /* COMMENT_7 */\n\t\tcase VAR_16: /* COMMENT_8 */\n\t\tcase VAR_17:\n\t\t\t/* COMMENT_9 */\n                                                        \n                                                            \n     \n\t\t\tbreak;\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\tcase VAR_18:\n\t\t\tVAR_8 = VAR_11->data * VAR_19;\n\t\t\tbreak;\n\t\tcase VAR_20:\n\t\t\tVAR_8 = VAR_11->data;\n\t\t\tbreak;\n\t\tcase VAR_21:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tVAR_3->name = VAR_5;\n\tVAR_3->type = VAR_6;\n\tVAR_3->offset = VAR_7;\n\tVAR_3->size = VAR_8;\n\treturn VAR_3;\ncleanup:\n\tfree (VAR_5);\n\tfree (VAR_6);\n\treturn NULL;\n}",
  "func_graph_path_before": "radareorg/radare2/5319d3525523a5e1cb5d48005e4fd1b79512db95/type_dwarf.c/vul/before/0.json",
  "func": "static RAnalStructMember *parse_struct_member (const RBinDwarfDie *all_dies,\n\tconst ut64 all_dies_count, ut64 curr_die_idx, RAnalStructMember *result) {\n\n\tr_return_val_if_fail (all_dies && result, NULL);\n\tconst RBinDwarfDie *die = &all_dies[curr_die_idx];\n\n\tchar *name = NULL;\n\tchar *type = NULL;\n\tut64 offset = 0;\n\tut64 size = 0;\n\tRStrBuf strbuf;\n\tr_strbuf_init (&strbuf);\n\tsize_t i;\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tname = get_die_name (die);\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_type:\n\t\t\tparse_type (all_dies, all_dies_count, value->reference, &strbuf, &size);\n\t\t\ttype = r_strbuf_drain_nofree (&strbuf);\n\t\t\tif (!type || !*type) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_data_member_location:\n\t\t\t/*\n\t\t\t\t2 cases, 1.: If val is integer, it offset in bytes from\n\t\t\t\tthe beginning of containing entity. If containing entity has \n\t\t\t\ta bit offset, member has that bit offset aswell\n\t\t\t\t2.: value is a location description \n\t\t\t\thttp://www.dwarfstd.org/doc/DWARF4.pdf#page=39&zoom=100,0,0\n\t\t\t*/\n\t\t\toffset = value->data;\n\t\t\tbreak;\n\t\tcase DW_AT_accessibility: // private, public etc.\n\t\tcase DW_AT_mutable: // flag is it is mutable\n\t\tcase DW_AT_data_bit_offset:\n\t\t\t/* \n\t\t\t\tint that specifies the number of bits from beginning\n\t\t\t\tof containing entity to the beginning of the data member\n\t\t\t*/\n\t\t\tbreak;\n\t\t// If the size of a data member is not the same as the\n\t\t//  size of the type given for the data member\n\t\tcase DW_AT_byte_size:\n\t\t\tsize = value->data * CHAR_BIT;\n\t\t\tbreak;\n\t\tcase DW_AT_bit_size:\n\t\t\tsize = value->data;\n\t\t\tbreak;\n\t\tcase DW_AT_containing_type:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult->name = name;\n\tresult->type = type;\n\tresult->offset = offset;\n\tresult->size = size;\n\treturn result;\ncleanup:\n\tfree (name);\n\tfree (type);\n\treturn NULL;\n}",
  "abstract_func": "static RAnalStructMember *parse_struct_member (const RBinDwarfDie *VAR_0,\n\tconst ut64 VAR_1, ut64 VAR_2, RAnalStructMember *VAR_3) {\n\n\tr_return_val_if_fail (VAR_0 && VAR_3, NULL);\n\tconst RBinDwarfDie *VAR_4 = &VAR_0[VAR_2];\n\n\tchar *VAR_5 = NULL;\n\tchar *VAR_6 = NULL;\n\tut64 VAR_7 = 0;\n\tut64 VAR_8 = 0;\n\tRStrBuf VAR_9;\n\tr_strbuf_init (&VAR_9);\n\tsize_t VAR_10;\n\tfor (VAR_10 = 0; VAR_10 < VAR_4->count; VAR_10++) {\n\t\tRBinDwarfAttrValue *VAR_11 = &VAR_4->attr_values[VAR_10];\n\t\tswitch (VAR_4->attr_values[VAR_10].attr_name) {\n\t\tcase VAR_12:\n\t\t\tVAR_5 = get_die_name (VAR_4);\n\t\t\tif (!VAR_5) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_13:\n\t\t\tparse_type (VAR_0, VAR_1, VAR_11->reference, &VAR_9, &VAR_8);\n\t\t\tVAR_6 = r_strbuf_drain_nofree (&VAR_9);\n\t\t\tif (!VAR_6 || !*VAR_6) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_14:\n\t\t\t/* COMMENT_0 */\n                                                           \n                                                                 \n                                                   \n                                        \n                                                               \n     \n\t\t\tVAR_7 = VAR_11->data;\n\t\t\tbreak;\n\t\tcase VAR_15: /* COMMENT_7 */\n\t\tcase VAR_16: /* COMMENT_8 */\n\t\tcase VAR_17:\n\t\t\t/* COMMENT_9 */\n                                                        \n                                                            \n     \n\t\t\tbreak;\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\tcase VAR_18:\n\t\t\tVAR_8 = VAR_11->data * VAR_19;\n\t\t\tbreak;\n\t\tcase VAR_20:\n\t\t\tVAR_8 = VAR_11->data;\n\t\t\tbreak;\n\t\tcase VAR_21:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tVAR_3->name = VAR_5;\n\tVAR_3->type = VAR_6;\n\tVAR_3->offset = VAR_7;\n\tVAR_3->size = VAR_8;\n\treturn VAR_3;\ncleanup:\n\tfree (VAR_5);\n\tfree (VAR_6);\n\treturn NULL;\n}",
  "func_graph_path": "radareorg/radare2/5319d3525523a5e1cb5d48005e4fd1b79512db95/type_dwarf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,11 +15,7 @@\n \t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n \t\tswitch (die->attr_values[i].attr_name) {\n \t\tcase DW_AT_name:\n-\t\t\tif (!value->string.content) {\n-\t\t\t\tname = create_type_name_from_offset (die->offset);\n-\t\t\t} else {\n-\t\t\t\tname = strdup (value->string.content);\n-\t\t\t}\n+\t\t\tname = get_die_name (die);\n \t\t\tif (!name) {\n \t\t\t\tgoto cleanup;\n \t\t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tif (!value->string.content) {",
      "\t\t\t\tname = create_type_name_from_offset (die->offset);",
      "\t\t\t} else {",
      "\t\t\t\tname = strdup (value->string.content);",
      "\t\t\t}"
    ],
    "added_lines": [
      "\t\t\tname = get_die_name (die);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/17399",
  "description": {
    "pr_info": {
      "title": "Fix malformed DWARF crash due invalid .debug_str reference ##bin",
      "number": 17399
    },
    "comment": [
      " <!-- Filling this template is mandatory -->\r\n\r\n**Your checklist for this pull request**\r\n- [x] I've read the [guidelines for contributing](https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md) to this repository\r\n- [x] I made sure to follow the project's [coding style](https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the documentation and the [radare2 book](https://github.com/radareorg/radare2book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\nFix for #17383 \r\n\r\nIn case the string pointer into debug_str isn't valid, the string can be NULL which wasn't accounted for in the future type parsing, I've added the handling for this situation.",
      "Btw, you might want to create a macros or a small inline function for this pattern:\r\n```c\r\n\t\tif (!value->string.content) {\r\n\t\t\t\tname = create_type_name_from_offset (die->offset);\r\n\t\t\t} else {\r\n\t\t\t\tname = strdup (value->string.content);\r\n\t\t\t}\r\n\t\t\tif (!name) {\r\n\t\t\t\tgoto cleanup;\r\n\t\t\t}\r\n```"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}