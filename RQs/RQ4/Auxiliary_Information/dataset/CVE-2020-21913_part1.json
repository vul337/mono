{
  "cve_id": "CVE-2020-21913",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "unicode-org/icu",
  "commit_msg": "ICU-20850 Use LocalMemory for cmd to prevent use after free",
  "commit_hash": "657c326d4b8a6c4c6721957320fc8c3c68670cfb",
  "git_url": "https://github.com/unicode-org/icu/commit/657c326d4b8a6c4c6721957320fc8c3c68670cfb",
  "file_path": "icu4c/source/tools/pkgdata/pkgdata.cpp",
  "func_name": "pkg_createWithAssemblyCode",
  "func_before": "static int32_t pkg_createWithAssemblyCode(const char *targetDir, const char mode, const char *gencFilePath) {\n    char tempObjectFile[SMALL_BUFFER_MAX_SIZE] = \"\";\n    char *cmd;\n    int32_t result = 0;\n\n    int32_t length = 0;\n\n    /* Remove the ending .s and replace it with .o for the new object file. */\n    uprv_strcpy(tempObjectFile, gencFilePath);\n    tempObjectFile[uprv_strlen(tempObjectFile)-1] = 'o';\n\n    length = static_cast<int32_t>(uprv_strlen(pkgDataFlags[COMPILER]) + uprv_strlen(pkgDataFlags[LIBFLAGS])\n             + uprv_strlen(tempObjectFile) + uprv_strlen(gencFilePath) + BUFFER_PADDING_SIZE);\n\n    cmd = (char *)uprv_malloc(sizeof(char) * length);\n    if (cmd == NULL) {\n        return -1;\n    }\n\n    /* Generate the object file. */\n    sprintf(cmd, \"%s %s -o %s %s\",\n            pkgDataFlags[COMPILER],\n            pkgDataFlags[LIBFLAGS],\n            tempObjectFile,\n            gencFilePath);\n\n    result = runCommand(cmd);\n    uprv_free(cmd);\n    if (result != 0) {\n        fprintf(stderr, \"Error creating with assembly code. Failed command: %s\\n\", cmd);\n        return result;\n    }\n\n    return pkg_generateLibraryFile(targetDir, mode, tempObjectFile);\n}",
  "abstract_func_before": "static int32_t pkg_createWithAssemblyCode(const char *VAR_0, const char VAR_1, const char *VAR_2) {\n    char VAR_3[VAR_4] = \"\";\n    char *VAR_5;\n    int32_t VAR_6 = 0;\n\n    int32_t VAR_7 = 0;\n\n    /* COMMENT_0 */\n    uprv_strcpy(VAR_3, VAR_2);\n    VAR_3[uprv_strlen(VAR_3)-1] = 'o';\n\n    VAR_7 = VAR_8<int32_t>(uprv_strlen(VAR_9[VAR_10]) + uprv_strlen(VAR_9[VAR_11])\n             + uprv_strlen(VAR_3) + uprv_strlen(VAR_2) + VAR_12);\n\n    VAR_5 = (char *)uprv_malloc(sizeof(char) * VAR_7);\n    if (VAR_5 == NULL) {\n        return -1;\n    }\n\n    /* COMMENT_1 */\n    sprintf(VAR_5, \"%s %s -o %s %s\",\n            VAR_9[VAR_10],\n            VAR_9[VAR_11],\n            VAR_3,\n            VAR_2);\n\n    VAR_6 = runCommand(VAR_5);\n    uprv_free(VAR_5);\n    if (VAR_6 != 0) {\n        fprintf(VAR_13, \"Error creating with assembly code. Failed command: %s\\n\", VAR_5);\n        return VAR_6;\n    }\n\n    return pkg_generateLibraryFile(VAR_0, VAR_1, VAR_3);\n}",
  "func_graph_path_before": "unicode-org/icu/657c326d4b8a6c4c6721957320fc8c3c68670cfb/pkgdata.cpp/vul/before/0.json",
  "func": "static int32_t pkg_createWithAssemblyCode(const char *targetDir, const char mode, const char *gencFilePath) {\n    char tempObjectFile[SMALL_BUFFER_MAX_SIZE] = \"\";\n    int32_t result = 0;\n    int32_t length = 0;\n\n    /* Remove the ending .s and replace it with .o for the new object file. */\n    uprv_strcpy(tempObjectFile, gencFilePath);\n    tempObjectFile[uprv_strlen(tempObjectFile)-1] = 'o';\n\n    length = static_cast<int32_t>(uprv_strlen(pkgDataFlags[COMPILER]) + uprv_strlen(pkgDataFlags[LIBFLAGS])\n             + uprv_strlen(tempObjectFile) + uprv_strlen(gencFilePath) + BUFFER_PADDING_SIZE);\n\n    LocalMemory<char> cmd((char *)uprv_malloc(sizeof(char) * length));\n    if (cmd.isNull()) {\n        return -1;\n    }\n\n    /* Generate the object file. */\n    sprintf(cmd.getAlias(), \"%s %s -o %s %s\",\n            pkgDataFlags[COMPILER],\n            pkgDataFlags[LIBFLAGS],\n            tempObjectFile,\n            gencFilePath);\n\n    result = runCommand(cmd.getAlias());\n\n    if (result != 0) {\n        fprintf(stderr, \"Error creating with assembly code. Failed command: %s\\n\", cmd.getAlias());\n        return result;\n    }\n\n    return pkg_generateLibraryFile(targetDir, mode, tempObjectFile);\n}",
  "abstract_func": "static int32_t pkg_createWithAssemblyCode(const char *VAR_0, const char VAR_1, const char *VAR_2) {\n    char VAR_3[VAR_4] = \"\";\n    int32_t VAR_5 = 0;\n    int32_t VAR_6 = 0;\n\n    /* COMMENT_0 */\n    uprv_strcpy(VAR_3, VAR_2);\n    VAR_3[uprv_strlen(VAR_3)-1] = 'o';\n\n    VAR_6 = VAR_7<int32_t>(uprv_strlen(VAR_8[VAR_9]) + uprv_strlen(VAR_8[VAR_10])\n             + uprv_strlen(VAR_3) + uprv_strlen(VAR_2) + VAR_11);\n\n    LocalMemory<char> VAR_12((char *)uprv_malloc(sizeof(char) * VAR_6));\n    if (VAR_12.isNull()) {\n        return -1;\n    }\n\n    /* COMMENT_1 */\n    sprintf(VAR_12.getAlias(), \"%s %s -o %s %s\",\n            VAR_8[VAR_9],\n            VAR_8[VAR_10],\n            VAR_3,\n            VAR_2);\n\n    VAR_5 = runCommand(VAR_12.getAlias());\n\n    if (VAR_5 != 0) {\n        fprintf(VAR_13, \"Error creating with assembly code. Failed command: %s\\n\", VAR_12.getAlias());\n        return VAR_5;\n    }\n\n    return pkg_generateLibraryFile(VAR_0, VAR_1, VAR_3);\n}",
  "func_graph_path": "unicode-org/icu/657c326d4b8a6c4c6721957320fc8c3c68670cfb/pkgdata.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,6 @@\n static int32_t pkg_createWithAssemblyCode(const char *targetDir, const char mode, const char *gencFilePath) {\n     char tempObjectFile[SMALL_BUFFER_MAX_SIZE] = \"\";\n-    char *cmd;\n     int32_t result = 0;\n-\n     int32_t length = 0;\n \n     /* Remove the ending .s and replace it with .o for the new object file. */\n@@ -12,22 +10,22 @@\n     length = static_cast<int32_t>(uprv_strlen(pkgDataFlags[COMPILER]) + uprv_strlen(pkgDataFlags[LIBFLAGS])\n              + uprv_strlen(tempObjectFile) + uprv_strlen(gencFilePath) + BUFFER_PADDING_SIZE);\n \n-    cmd = (char *)uprv_malloc(sizeof(char) * length);\n-    if (cmd == NULL) {\n+    LocalMemory<char> cmd((char *)uprv_malloc(sizeof(char) * length));\n+    if (cmd.isNull()) {\n         return -1;\n     }\n \n     /* Generate the object file. */\n-    sprintf(cmd, \"%s %s -o %s %s\",\n+    sprintf(cmd.getAlias(), \"%s %s -o %s %s\",\n             pkgDataFlags[COMPILER],\n             pkgDataFlags[LIBFLAGS],\n             tempObjectFile,\n             gencFilePath);\n \n-    result = runCommand(cmd);\n-    uprv_free(cmd);\n+    result = runCommand(cmd.getAlias());\n+\n     if (result != 0) {\n-        fprintf(stderr, \"Error creating with assembly code. Failed command: %s\\n\", cmd);\n+        fprintf(stderr, \"Error creating with assembly code. Failed command: %s\\n\", cmd.getAlias());\n         return result;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    char *cmd;",
      "",
      "    cmd = (char *)uprv_malloc(sizeof(char) * length);",
      "    if (cmd == NULL) {",
      "    sprintf(cmd, \"%s %s -o %s %s\",",
      "    result = runCommand(cmd);",
      "    uprv_free(cmd);",
      "        fprintf(stderr, \"Error creating with assembly code. Failed command: %s\\n\", cmd);"
    ],
    "added_lines": [
      "    LocalMemory<char> cmd((char *)uprv_malloc(sizeof(char) * length));",
      "    if (cmd.isNull()) {",
      "    sprintf(cmd.getAlias(), \"%s %s -o %s %s\",",
      "    result = runCommand(cmd.getAlias());",
      "",
      "        fprintf(stderr, \"Error creating with assembly code. Failed command: %s\\n\", cmd.getAlias());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/unicode-org/icu/pull/886",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/unicode-org/icu/pull/886: 403 Client Error: Forbidden for url: https://api.github.com/repos/unicode-org/icu/pulls/886",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix  \nConfidence: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message highlights the use of LocalMemory to prevent a \"use after free\" error, a security issue. The code diff replaces manual memory allocation with LocalMemory, which automatically manages memory and prevents such vulnerabilities.\n\n2. **Consistency Check:** The commit message aligns with the code change, showing a direct fix for the security issue by improving memory management.\n\n3. **Purpose Evaluation:** The change modifies core logic to fix a memory-related bug, indicating a security enhancement.\n\n4. **Security Vulnerability Assessment:** The patch addresses a use-after-free vulnerability, a known security risk. While noCVE identifier is explicitly mentioned, the context strongly implies a security fix.\n\n5. **Confidence Scoring:** The explicit mention of preventing a use-after-free and the memory management fix justify a high confidence level.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}