{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_server.cpp",
  "func_name": "zmq::curve_server_t::encode",
  "func_before": "int zmq::curve_server_t::encode (msg_t *msg_)\n{\n    zmq_assert (state == connected);\n\n    const size_t mlen = crypto_box_ZEROBYTES + 1 + msg_->size ();\n\n    uint8_t message_nonce [crypto_box_NONCEBYTES];\n    memcpy (message_nonce, \"CurveZMQMESSAGES\", 16);\n    memcpy (message_nonce + 16, &cn_nonce, 8);\n\n    uint8_t flags = 0;\n    if (msg_->flags () & msg_t::more)\n        flags |= 0x01;\n\n    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (mlen));\n    alloc_assert (message_plaintext);\n\n    memset (message_plaintext, 0, crypto_box_ZEROBYTES);\n    message_plaintext [crypto_box_ZEROBYTES] = flags;\n    memcpy (message_plaintext + crypto_box_ZEROBYTES + 1,\n            msg_->data (), msg_->size ());\n\n    uint8_t *message_box = static_cast <uint8_t *> (malloc (mlen));\n    alloc_assert (message_box);\n\n    int rc = crypto_box_afternm (message_box, message_plaintext,\n                                 mlen, message_nonce, cn_precom);\n    zmq_assert (rc == 0);\n\n    rc = msg_->close ();\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (16 + mlen - crypto_box_BOXZEROBYTES);\n    zmq_assert (rc == 0);\n\n    uint8_t *message = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (message, \"\\x07MESSAGE\", 8);\n    memcpy (message + 8, &cn_nonce, 8);\n    memcpy (message + 16, message_box + crypto_box_BOXZEROBYTES,\n            mlen - crypto_box_BOXZEROBYTES);\n\n    free (message_plaintext);\n    free (message_box);\n\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func_before": "int zmq::curve_server_t::encode (msg_t *VAR_0)\n{\n    zmq_assert (VAR_1 == VAR_2);\n\n    const size_t VAR_3 = VAR_4 + 1 + VAR_0->size ();\n\n    uint8_t VAR_5 [VAR_6];\n    memcpy (VAR_5, \"CurveZMQMESSAGES\", 16);\n    memcpy (VAR_5 + 16, &VAR_7, 8);\n\n    uint8_t VAR_8 = 0;\n    if (VAR_0->flags () & msg_t::more)\n        VAR_8 |= 0x01;\n\n    uint8_t *VAR_9 = VAR_10 <uint8_t *> (malloc (VAR_3));\n    alloc_assert (VAR_9);\n\n    memset (VAR_9, 0, VAR_4);\n    VAR_9 [VAR_4] = VAR_8;\n    memcpy (VAR_9 + VAR_4 + 1,\n            VAR_0->data (), VAR_0->size ());\n\n    uint8_t *VAR_11 = VAR_10 <uint8_t *> (malloc (VAR_3));\n    alloc_assert (VAR_11);\n\n    int VAR_12 = crypto_box_afternm (VAR_11, VAR_9,\n                                 VAR_3, VAR_5, VAR_13);\n    zmq_assert (VAR_12 == 0);\n\n    VAR_12 = VAR_0->close ();\n    zmq_assert (VAR_12 == 0);\n\n    VAR_12 = VAR_0->init_size (16 + VAR_3 - VAR_14);\n    zmq_assert (VAR_12 == 0);\n\n    uint8_t *VAR_15 = VAR_10 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_15, \"\\x07MESSAGE\", 8);\n    memcpy (VAR_15 + 8, &VAR_7, 8);\n    memcpy (VAR_15 + 16, VAR_11 + VAR_14,\n            VAR_3 - VAR_14);\n\n    free (VAR_9);\n    free (VAR_11);\n\n    VAR_7++;\n\n    return 0;\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/before/1.json",
  "func": "int zmq::curve_server_t::encode (msg_t *msg_)\n{\n    zmq_assert (state == connected);\n\n    const size_t mlen = crypto_box_ZEROBYTES + 1 + msg_->size ();\n\n    uint8_t message_nonce [crypto_box_NONCEBYTES];\n    memcpy (message_nonce, \"CurveZMQMESSAGES\", 16);\n    put_uint64 (message_nonce + 16, cn_nonce);\n\n    uint8_t flags = 0;\n    if (msg_->flags () & msg_t::more)\n        flags |= 0x01;\n\n    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (mlen));\n    alloc_assert (message_plaintext);\n\n    memset (message_plaintext, 0, crypto_box_ZEROBYTES);\n    message_plaintext [crypto_box_ZEROBYTES] = flags;\n    memcpy (message_plaintext + crypto_box_ZEROBYTES + 1,\n            msg_->data (), msg_->size ());\n\n    uint8_t *message_box = static_cast <uint8_t *> (malloc (mlen));\n    alloc_assert (message_box);\n\n    int rc = crypto_box_afternm (message_box, message_plaintext,\n                                 mlen, message_nonce, cn_precom);\n    zmq_assert (rc == 0);\n\n    rc = msg_->close ();\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (16 + mlen - crypto_box_BOXZEROBYTES);\n    zmq_assert (rc == 0);\n\n    uint8_t *message = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (message, \"\\x07MESSAGE\", 8);\n    memcpy (message + 8, message_nonce + 16, 8);\n    memcpy (message + 16, message_box + crypto_box_BOXZEROBYTES,\n            mlen - crypto_box_BOXZEROBYTES);\n\n    free (message_plaintext);\n    free (message_box);\n\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func": "int zmq::curve_server_t::encode (msg_t *VAR_0)\n{\n    zmq_assert (VAR_1 == VAR_2);\n\n    const size_t VAR_3 = VAR_4 + 1 + VAR_0->size ();\n\n    uint8_t VAR_5 [VAR_6];\n    memcpy (VAR_5, \"CurveZMQMESSAGES\", 16);\n    put_uint64 (VAR_5 + 16, VAR_7);\n\n    uint8_t VAR_8 = 0;\n    if (VAR_0->flags () & msg_t::more)\n        VAR_8 |= 0x01;\n\n    uint8_t *VAR_9 = VAR_10 <uint8_t *> (malloc (VAR_3));\n    alloc_assert (VAR_9);\n\n    memset (VAR_9, 0, VAR_4);\n    VAR_9 [VAR_4] = VAR_8;\n    memcpy (VAR_9 + VAR_4 + 1,\n            VAR_0->data (), VAR_0->size ());\n\n    uint8_t *VAR_11 = VAR_10 <uint8_t *> (malloc (VAR_3));\n    alloc_assert (VAR_11);\n\n    int VAR_12 = crypto_box_afternm (VAR_11, VAR_9,\n                                 VAR_3, VAR_5, VAR_13);\n    zmq_assert (VAR_12 == 0);\n\n    VAR_12 = VAR_0->close ();\n    zmq_assert (VAR_12 == 0);\n\n    VAR_12 = VAR_0->init_size (16 + VAR_3 - VAR_14);\n    zmq_assert (VAR_12 == 0);\n\n    uint8_t *VAR_15 = VAR_10 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_15, \"\\x07MESSAGE\", 8);\n    memcpy (VAR_15 + 8, VAR_5 + 16, 8);\n    memcpy (VAR_15 + 16, VAR_11 + VAR_14,\n            VAR_3 - VAR_14);\n\n    free (VAR_9);\n    free (VAR_11);\n\n    VAR_7++;\n\n    return 0;\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n     uint8_t message_nonce [crypto_box_NONCEBYTES];\n     memcpy (message_nonce, \"CurveZMQMESSAGES\", 16);\n-    memcpy (message_nonce + 16, &cn_nonce, 8);\n+    put_uint64 (message_nonce + 16, cn_nonce);\n \n     uint8_t flags = 0;\n     if (msg_->flags () & msg_t::more)\n@@ -36,7 +36,7 @@\n     uint8_t *message = static_cast <uint8_t *> (msg_->data ());\n \n     memcpy (message, \"\\x07MESSAGE\", 8);\n-    memcpy (message + 8, &cn_nonce, 8);\n+    memcpy (message + 8, message_nonce + 16, 8);\n     memcpy (message + 16, message_box + crypto_box_BOXZEROBYTES,\n             mlen - crypto_box_BOXZEROBYTES);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    memcpy (message_nonce + 16, &cn_nonce, 8);",
      "    memcpy (message + 8, &cn_nonce, 8);"
    ],
    "added_lines": [
      "    put_uint64 (message_nonce + 16, cn_nonce);",
      "    memcpy (message + 8, message_nonce + 16, 8);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zeromq/libzmq/pull/1189: 403 Client Error: Forbidden for url: https://api.github.com/repos/zeromq/libzmq/pulls/1189",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a replay attack vulnerability by ensuring nonces are strictly increasing and validated, which is a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}