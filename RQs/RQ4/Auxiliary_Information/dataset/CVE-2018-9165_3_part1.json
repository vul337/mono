{
  "cve_id": "CVE-2018-9165",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "Perform deep copy in pushdup (instead of shallow)\n\nUntil now, the element duplication in pushdup was performed via\nt->val = Stack->val.\n\nWhile this is perfectly fine for integer/double/register values,\nthis may create nasty, hard to debug issues with Strings. In fact,\nwhen called with a String at the top of the stack, pushdup would\nonly push *a reference* to the same String element (shallow copy),\nlater allowing to modify several stack elements at once, which may\npotentially lead to NULL pointer dereferences or any other\nunspecified impact.\n\nIn this patch we implement deep copy in pushdup:\n* If the type of the stack element is 's' (for String), we\n  allocate a new buffer and copy the String into it.\n* Otherwise we simply proceed as before, that is we do t->val = Stack->val\n  which is perfectly fine since we are not dealing with pointers.\n\nThis patch is the last part of the patch for #121 (fixes #121), which\nshould now be completely fixed.",
  "commit_hash": "7ca571cd8068709f6a7e57f93b46275ec94af80d",
  "git_url": "https://github.com/libming/libming/commit/7ca571cd8068709f6a7e57f93b46275ec94af80d",
  "file_path": "util/decompile.c",
  "func_name": "pushdup",
  "func_before": "void\npushdup()\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushdup*\\n\");\n#endif\n\tif(Stack == NULL)\n\t{\n\t\tSWF_warn(\"WARNING: pushdup on empty stack. This might be wrong!\\n\");\n\t\treturn;\n\t}\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = Stack->type;\n\tt->val =  Stack->val;\n\tt->next = Stack;\n\tStack = t;\n}",
  "abstract_func_before": "void\npushdup()\n{\n\tstruct _stack *VAR_0;\n#ifdef VAR_1\n\tprintf(\"*pushdup*\\n\");\n#endif\n\tif(VAR_2 == NULL)\n\t{\n\t\tSWF_warn(\"WARNING: pushdup on empty stack. This might be wrong!\\n\");\n\t\treturn;\n\t}\n\tVAR_0 = calloc(1,sizeof(*VAR_2));\n\tVAR_0->type = VAR_2->type;\n\tVAR_0->val =  VAR_2->val;\n\tVAR_0->next = VAR_2;\n\tVAR_2 = VAR_0;\n}",
  "func_graph_path_before": "libming/7ca571cd8068709f6a7e57f93b46275ec94af80d/decompile.c/vul/before/0.json",
  "func": "void\npushdup()\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushdup*\\n\");\n#endif\n\tif(Stack == NULL)\n\t{\n\t\tSWF_warn(\"WARNING: pushdup on empty stack. This might be wrong!\\n\");\n\t\treturn;\n\t}\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = Stack->type;\n\n\t// If element is a string, perform deep copy of Stack->val->p\n\tif (Stack->val->Type == PUSH_STRING) {\n\t\tt->val = calloc(1, sizeof(struct SWF_ACTIONPUSHPARAM));\n\t\t*t->val = *Stack->val;\n\n\t\tint len = strlen(Stack->val->p.String) + 1; // NULL terminated\n\t\tt->val->p.String = calloc(len, sizeof(char));\n\t\tstrcpy(t->val->p.String, Stack->val->p.String);\n\t} else {\n\t\tt->val =  Stack->val;\n\t}\n\n\tt->next = Stack;\n\tStack = t;\n}",
  "abstract_func": "void\npushdup()\n{\n\tstruct _stack *VAR_0;\n#ifdef VAR_1\n\tprintf(\"*pushdup*\\n\");\n#endif\n\tif(VAR_2 == NULL)\n\t{\n\t\tSWF_warn(\"WARNING: pushdup on empty stack. This might be wrong!\\n\");\n\t\treturn;\n\t}\n\tVAR_0 = calloc(1,sizeof(*VAR_2));\n\tVAR_0->type = VAR_2->type;\n\n\t/* COMMENT_0 */\n\tif (VAR_2->val->Type == VAR_3) {\n\t\tVAR_0->val = calloc(1, sizeof(struct SWF_ACTIONPUSHPARAM));\n\t\t*VAR_0->val = *VAR_2->val;\n\n\t\tint VAR_4 = strlen(VAR_2->val->p.String) + 1; /* COMMENT_1 */\n\t\tVAR_0->val->p.String = calloc(VAR_4, sizeof(char));\n\t\tstrcpy(VAR_0->val->p.String, VAR_2->val->p.String);\n\t} else {\n\t\tVAR_0->val =  VAR_2->val;\n\t}\n\n\tVAR_0->next = VAR_2;\n\tVAR_2 = VAR_0;\n}",
  "func_graph_path": "libming/7ca571cd8068709f6a7e57f93b46275ec94af80d/decompile.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,19 @@\n \t}\n \tt = calloc(1,sizeof(*Stack));\n \tt->type = Stack->type;\n-\tt->val =  Stack->val;\n+\n+\t// If element is a string, perform deep copy of Stack->val->p\n+\tif (Stack->val->Type == PUSH_STRING) {\n+\t\tt->val = calloc(1, sizeof(struct SWF_ACTIONPUSHPARAM));\n+\t\t*t->val = *Stack->val;\n+\n+\t\tint len = strlen(Stack->val->p.String) + 1; // NULL terminated\n+\t\tt->val->p.String = calloc(len, sizeof(char));\n+\t\tstrcpy(t->val->p.String, Stack->val->p.String);\n+\t} else {\n+\t\tt->val =  Stack->val;\n+\t}\n+\n \tt->next = Stack;\n \tStack = t;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tt->val =  Stack->val;"
    ],
    "added_lines": [
      "",
      "\t// If element is a string, perform deep copy of Stack->val->p",
      "\tif (Stack->val->Type == PUSH_STRING) {",
      "\t\tt->val = calloc(1, sizeof(struct SWF_ACTIONPUSHPARAM));",
      "\t\t*t->val = *Stack->val;",
      "",
      "\t\tint len = strlen(Stack->val->p.String) + 1; // NULL terminated",
      "\t\tt->val->p.String = calloc(len, sizeof(char));",
      "\t\tstrcpy(t->val->p.String, Stack->val->p.String);",
      "\t} else {",
      "\t\tt->val =  Stack->val;",
      "\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/127",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libming/libming/pull/127: 403 Client Error: Forbidden for url: https://api.github.com/repos/libming/libming/pulls/127",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}