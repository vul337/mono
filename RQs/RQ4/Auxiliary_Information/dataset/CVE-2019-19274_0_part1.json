{
  "cve_id": "CVE-2019-19274",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "python/typed_ast",
  "commit_msg": "Fix two out-of-bounds array reads (#99)\n\nThe patch is taken from a commit to the CPython repo with the message:\r\n\r\nbpo-36495: Fix two out-of-bounds array reads (GH-12641)\r\n\r\nResearch and fix by @bradlarsen.",
  "commit_hash": "dc317ac9cff859aa84eeabe03fb5004982545b3b",
  "git_url": "https://github.com/python/typed_ast/commit/dc317ac9cff859aa84eeabe03fb5004982545b3b",
  "file_path": "ast3/Python/ast.c",
  "func_name": "ast_for_arguments",
  "func_before": "static arguments_ty\nast_for_arguments(struct compiling *c, const node *n)\n{\n    /* This function handles both typedargslist (function definition)\n       and varargslist (lambda definition).\n\n       parameters: '(' [typedargslist] ')'\n       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [\n               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n             | '**' tfpdef [',']]]\n         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n         | '**' tfpdef [','])\n       tfpdef: NAME [':' test]\n       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [\n               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n             | '**' vfpdef [',']]]\n         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n         | '**' vfpdef [',']\n       )\n       vfpdef: NAME\n\n    */\n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) /* () as argument list */\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    /* First count the number of positional args & defaults.  The\n       variable i is the loop index for this for loop and the next.\n       The next loop picks up where the first leaves off.\n    */\n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            /* skip star */\n            i++;\n            if (i < NCH(n) && /* skip argument following star */\n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    /* count the number of keyword only args &\n       defaults for keyword only args */\n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    /* The length of kwonlyargs and kwdefaults are same\n       since we set NULL as default for keyword only argument w/o default\n       - we have sequence data structure, but no dictionary */\n    kwdefaults = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    /* tfpdef: NAME [':' test]\n       vfpdef: NAME\n    */\n    i = 0;\n    j = 0;  /* index for defaults */\n    k = 0;  /* index for args */\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is\n                   anything other than EQUAL or a comma? */\n                /* XXX Should NCH(n) check be made a separate check? */\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  /* tfpdef or COMMA */\n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; /* now follows keyword only arguments */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; /* res has new position to process */\n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                    i += 2; /* the star and the name */\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                        i += 1; /* the comma, if present */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; /* res has new position to process */\n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; /* the double star and the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}",
  "abstract_func_before": "static arguments_ty\nast_for_arguments(struct compiling *VAR_0, const node *VAR_1)\n{\n    /* COMMENT_0 */\n                                           \n\n                                          \n                                                                        \n                                                                              \n                                  \n                                                                          \n                             \n                              \n                                                                      \n                                                                              \n                                  \n                                                                          \n                            \n        \n                   \n\n      \n    int VAR_2, VAR_3, VAR_4, VAR_5 = 0, VAR_6 = 0;\n    int VAR_7 = 0, VAR_8 = 0;\n    asdl_seq *VAR_9, *VAR_10, *VAR_11, *VAR_12;\n    arg_ty VAR_13 = NULL, VAR_14 = NULL;\n    arg_ty VAR_15 = NULL;\n    node *VAR_16;\n\n    if (TYPE(VAR_1) == VAR_17) {\n        if (NCH(VAR_1) == 2) /* COMMENT_18 */\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, VAR_0->c_arena);\n        VAR_1 = CHILD(VAR_1, 1);\n    }\n    assert(TYPE(VAR_1) == VAR_18 || TYPE(VAR_1) == VAR_19);\n\n    /* COMMENT_19 */\n                                                                   \n                                                         \n      \n    for (VAR_2 = 0; VAR_2 < NCH(VAR_1); VAR_2++) {\n        VAR_16 = CHILD(VAR_1, VAR_2);\n        if (TYPE(VAR_16) == VAR_20) {\n            /* COMMENT_23 */\n            VAR_2++;\n            if (VAR_2 < NCH(VAR_1) && /* COMMENT_24 */\n                (TYPE(CHILD(VAR_1, VAR_2)) == VAR_21 ||\n                 TYPE(CHILD(VAR_1, VAR_2)) == VAR_22)) {\n                VAR_2++;\n            }\n            break;\n        }\n        if (TYPE(VAR_16) == VAR_23) break;\n        if (TYPE(VAR_16) == VAR_22 || TYPE(VAR_16) == VAR_21) VAR_5++;\n        if (TYPE(VAR_16) == VAR_24) VAR_7++;\n    }\n    /* COMMENT_25 */\n                                        \n    for ( ; VAR_2 < NCH(VAR_1); ++VAR_2) {\n        VAR_16 = CHILD(VAR_1, VAR_2);\n        if (TYPE(VAR_16) == VAR_23) break;\n        if (TYPE(VAR_16) == VAR_21 || TYPE(VAR_16) == VAR_22) VAR_6++;\n    }\n    VAR_9 = (VAR_5 ? _Ta3_asdl_seq_new(VAR_5, VAR_0->c_arena) : NULL);\n    if (!VAR_9 && VAR_5)\n        return NULL;\n    VAR_11 = (VAR_6 ?\n                   _Ta3_asdl_seq_new(VAR_6, VAR_0->c_arena) : NULL);\n    if (!VAR_11 && VAR_6)\n        return NULL;\n    VAR_10 = (VAR_7 ?\n                    _Ta3_asdl_seq_new(VAR_7, VAR_0->c_arena) : NULL);\n    if (!VAR_10 && VAR_7)\n        return NULL;\n    /* COMMENT_27 */\n                                                                         \n                                                              \n    VAR_12 = (VAR_6 ?\n                   _Ta3_asdl_seq_new(VAR_6, VAR_0->c_arena) : NULL);\n    if (!VAR_12 && VAR_6)\n        return NULL;\n\n    /* COMMENT_30 */\n                   \n      \n    VAR_2 = 0;\n    VAR_3 = 0;  /* COMMENT_33 */\n    VAR_4 = 0;  /* COMMENT_34 */\n    while (VAR_2 < NCH(VAR_1)) {\n        VAR_16 = CHILD(VAR_1, VAR_2);\n        switch (TYPE(VAR_16)) {\n            case VAR_21:\n            case VAR_22:\n                /* COMMENT_35 */\n                                                           \n                /* COMMENT_37 */\n                if (VAR_2 + 1 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2 + 1)) == VAR_24) {\n                    expr_ty VAR_25 = ast_for_expr(VAR_0, CHILD(VAR_1, VAR_2 + 2));\n                    if (!VAR_25)\n                        return NULL;\n                    assert(VAR_10 != NULL);\n                    asdl_seq_SET(VAR_10, VAR_3++, VAR_25);\n                    VAR_2 += 2;\n                    VAR_8 = 1;\n                }\n                else if (VAR_8) {\n                    ast_error(VAR_0, VAR_1,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                VAR_15 = ast_for_arg(VAR_0, VAR_16);\n                if (!VAR_15)\n                    return NULL;\n                asdl_seq_SET(VAR_9, VAR_4++, VAR_15);\n                VAR_2 += 1; /* COMMENT_38 */\n                if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_26)\n                    VAR_2 += 1; /* COMMENT_39 */\n                break;\n            case VAR_20:\n                if (VAR_2+1 >= NCH(VAR_1) ||\n                    (VAR_2+2 == NCH(VAR_1) && (TYPE(CHILD(VAR_1, VAR_2+1)) == VAR_26\n                                       || TYPE(CHILD(VAR_1, VAR_2+1)) == VAR_27))) {\n                    ast_error(VAR_0, CHILD(VAR_1, VAR_2),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                VAR_16 = CHILD(VAR_1, VAR_2+1);  /* COMMENT_40 */\n                if (TYPE(VAR_16) == VAR_26) {\n                    int VAR_28 = 0;\n                    VAR_2 += 2; /* COMMENT_41 */\n\n                    if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_27) {\n                        ast_error(VAR_0, CHILD(VAR_1, VAR_2),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    VAR_28 = handle_keywordonly_args(VAR_0, VAR_1, VAR_2,\n                                                  VAR_11, VAR_12);\n                    if (VAR_28 == -1) return NULL;\n                    VAR_2 = VAR_28; /* COMMENT_42 */\n                }\n                else {\n                    VAR_13 = ast_for_arg(VAR_0, VAR_16);\n                    if (!VAR_13)\n                        return NULL;\n\n                    VAR_2 += 2; /* COMMENT_43 */\n                    if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_26)\n                        VAR_2 += 1; /* COMMENT_39 */\n\n                    if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_27) {\n                        VAR_13->type_comment = NEW_TYPE_COMMENT(CHILD(VAR_1, VAR_2));\n                        if (!VAR_13->type_comment)\n                            return NULL;\n                        VAR_2 += 1;\n                    }\n\n                    if (VAR_2 < NCH(VAR_1) && (TYPE(CHILD(VAR_1, VAR_2)) == VAR_21\n                                    || TYPE(CHILD(VAR_1, VAR_2)) == VAR_22)) {\n                        int VAR_28 = 0;\n                        VAR_28 = handle_keywordonly_args(VAR_0, VAR_1, VAR_2,\n                                                      VAR_11, VAR_12);\n                        if (VAR_28 == -1) return NULL;\n                        VAR_2 = VAR_28; /* COMMENT_42 */\n                    }\n                }\n                break;\n            case VAR_23:\n                VAR_16 = CHILD(VAR_1, VAR_2+1);  /* COMMENT_44 */\n                assert(TYPE(VAR_16) == VAR_21 || TYPE(VAR_16) == VAR_22);\n                VAR_14 = ast_for_arg(VAR_0, VAR_16);\n                if (!VAR_14)\n                    return NULL;\n                VAR_2 += 2; /* COMMENT_45 */\n                if (TYPE(CHILD(VAR_1, VAR_2)) == VAR_26)\n                    VAR_2 += 1; /* COMMENT_39 */\n                break;\n            case VAR_27:\n                assert(VAR_2);\n\n                if (VAR_14)\n                    VAR_15 = VAR_14;\n\n                /* COMMENT_46 */\n                VAR_15->type_comment = NEW_TYPE_COMMENT(VAR_16);\n                if (!VAR_15->type_comment)\n                    return NULL;\n                VAR_2 += 1;\n                break;\n            default:\n                PyErr_Format(VAR_29,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(VAR_16), VAR_2);\n                return NULL;\n        }\n    }\n    return arguments(VAR_9, VAR_13, VAR_11, VAR_12, VAR_14, VAR_10, VAR_0->c_arena);\n}",
  "func_graph_path_before": "python/typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b/ast.c/vul/before/1.json",
  "func": "static arguments_ty\nast_for_arguments(struct compiling *c, const node *n)\n{\n    /* This function handles both typedargslist (function definition)\n       and varargslist (lambda definition).\n\n       parameters: '(' [typedargslist] ')'\n       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [\n               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n             | '**' tfpdef [',']]]\n         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n         | '**' tfpdef [','])\n       tfpdef: NAME [':' test]\n       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [\n               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n             | '**' vfpdef [',']]]\n         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n         | '**' vfpdef [',']\n       )\n       vfpdef: NAME\n\n    */\n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) /* () as argument list */\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    /* First count the number of positional args & defaults.  The\n       variable i is the loop index for this for loop and the next.\n       The next loop picks up where the first leaves off.\n    */\n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            /* skip star */\n            i++;\n            if (i < NCH(n) && /* skip argument following star */\n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    /* count the number of keyword only args &\n       defaults for keyword only args */\n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    /* The length of kwonlyargs and kwdefaults are same\n       since we set NULL as default for keyword only argument w/o default\n       - we have sequence data structure, but no dictionary */\n    kwdefaults = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    /* tfpdef: NAME [':' test]\n       vfpdef: NAME\n    */\n    i = 0;\n    j = 0;  /* index for defaults */\n    k = 0;  /* index for args */\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is\n                   anything other than EQUAL or a comma? */\n                /* XXX Should NCH(n) check be made a separate check? */\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  /* tfpdef or COMMA */\n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; /* now follows keyword only arguments */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; /* res has new position to process */\n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                    i += 2; /* the star and the name */\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                        i += 1; /* the comma, if present */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; /* res has new position to process */\n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; /* the double star and the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}",
  "abstract_func": "static arguments_ty\nast_for_arguments(struct compiling *VAR_0, const node *VAR_1)\n{\n    /* COMMENT_0 */\n                                           \n\n                                          \n                                                                        \n                                                                              \n                                  \n                                                                          \n                             \n                              \n                                                                      \n                                                                              \n                                  \n                                                                          \n                            \n        \n                   \n\n      \n    int VAR_2, VAR_3, VAR_4, VAR_5 = 0, VAR_6 = 0;\n    int VAR_7 = 0, VAR_8 = 0;\n    asdl_seq *VAR_9, *VAR_10, *VAR_11, *VAR_12;\n    arg_ty VAR_13 = NULL, VAR_14 = NULL;\n    arg_ty VAR_15 = NULL;\n    node *VAR_16;\n\n    if (TYPE(VAR_1) == VAR_17) {\n        if (NCH(VAR_1) == 2) /* COMMENT_18 */\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, VAR_0->c_arena);\n        VAR_1 = CHILD(VAR_1, 1);\n    }\n    assert(TYPE(VAR_1) == VAR_18 || TYPE(VAR_1) == VAR_19);\n\n    /* COMMENT_19 */\n                                                                   \n                                                         \n      \n    for (VAR_2 = 0; VAR_2 < NCH(VAR_1); VAR_2++) {\n        VAR_16 = CHILD(VAR_1, VAR_2);\n        if (TYPE(VAR_16) == VAR_20) {\n            /* COMMENT_23 */\n            VAR_2++;\n            if (VAR_2 < NCH(VAR_1) && /* COMMENT_24 */\n                (TYPE(CHILD(VAR_1, VAR_2)) == VAR_21 ||\n                 TYPE(CHILD(VAR_1, VAR_2)) == VAR_22)) {\n                VAR_2++;\n            }\n            break;\n        }\n        if (TYPE(VAR_16) == VAR_23) break;\n        if (TYPE(VAR_16) == VAR_22 || TYPE(VAR_16) == VAR_21) VAR_5++;\n        if (TYPE(VAR_16) == VAR_24) VAR_7++;\n    }\n    /* COMMENT_25 */\n                                        \n    for ( ; VAR_2 < NCH(VAR_1); ++VAR_2) {\n        VAR_16 = CHILD(VAR_1, VAR_2);\n        if (TYPE(VAR_16) == VAR_23) break;\n        if (TYPE(VAR_16) == VAR_21 || TYPE(VAR_16) == VAR_22) VAR_6++;\n    }\n    VAR_9 = (VAR_5 ? _Ta3_asdl_seq_new(VAR_5, VAR_0->c_arena) : NULL);\n    if (!VAR_9 && VAR_5)\n        return NULL;\n    VAR_11 = (VAR_6 ?\n                   _Ta3_asdl_seq_new(VAR_6, VAR_0->c_arena) : NULL);\n    if (!VAR_11 && VAR_6)\n        return NULL;\n    VAR_10 = (VAR_7 ?\n                    _Ta3_asdl_seq_new(VAR_7, VAR_0->c_arena) : NULL);\n    if (!VAR_10 && VAR_7)\n        return NULL;\n    /* COMMENT_27 */\n                                                                         \n                                                              \n    VAR_12 = (VAR_6 ?\n                   _Ta3_asdl_seq_new(VAR_6, VAR_0->c_arena) : NULL);\n    if (!VAR_12 && VAR_6)\n        return NULL;\n\n    /* COMMENT_30 */\n                   \n      \n    VAR_2 = 0;\n    VAR_3 = 0;  /* COMMENT_33 */\n    VAR_4 = 0;  /* COMMENT_34 */\n    while (VAR_2 < NCH(VAR_1)) {\n        VAR_16 = CHILD(VAR_1, VAR_2);\n        switch (TYPE(VAR_16)) {\n            case VAR_21:\n            case VAR_22:\n                /* COMMENT_35 */\n                                                           \n                /* COMMENT_37 */\n                if (VAR_2 + 1 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2 + 1)) == VAR_24) {\n                    expr_ty VAR_25 = ast_for_expr(VAR_0, CHILD(VAR_1, VAR_2 + 2));\n                    if (!VAR_25)\n                        return NULL;\n                    assert(VAR_10 != NULL);\n                    asdl_seq_SET(VAR_10, VAR_3++, VAR_25);\n                    VAR_2 += 2;\n                    VAR_8 = 1;\n                }\n                else if (VAR_8) {\n                    ast_error(VAR_0, VAR_1,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                VAR_15 = ast_for_arg(VAR_0, VAR_16);\n                if (!VAR_15)\n                    return NULL;\n                asdl_seq_SET(VAR_9, VAR_4++, VAR_15);\n                VAR_2 += 1; /* COMMENT_38 */\n                if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_26)\n                    VAR_2 += 1; /* COMMENT_39 */\n                break;\n            case VAR_20:\n                if (VAR_2+1 >= NCH(VAR_1) ||\n                    (VAR_2+2 == NCH(VAR_1) && (TYPE(CHILD(VAR_1, VAR_2+1)) == VAR_26\n                                       || TYPE(CHILD(VAR_1, VAR_2+1)) == VAR_27))) {\n                    ast_error(VAR_0, CHILD(VAR_1, VAR_2),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                VAR_16 = CHILD(VAR_1, VAR_2+1);  /* COMMENT_40 */\n                if (TYPE(VAR_16) == VAR_26) {\n                    int VAR_28 = 0;\n                    VAR_2 += 2; /* COMMENT_41 */\n\n                    if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_27) {\n                        ast_error(VAR_0, CHILD(VAR_1, VAR_2),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    VAR_28 = handle_keywordonly_args(VAR_0, VAR_1, VAR_2,\n                                                  VAR_11, VAR_12);\n                    if (VAR_28 == -1) return NULL;\n                    VAR_2 = VAR_28; /* COMMENT_42 */\n                }\n                else {\n                    VAR_13 = ast_for_arg(VAR_0, VAR_16);\n                    if (!VAR_13)\n                        return NULL;\n\n                    VAR_2 += 2; /* COMMENT_43 */\n                    if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_26)\n                        VAR_2 += 1; /* COMMENT_39 */\n\n                    if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_27) {\n                        VAR_13->type_comment = NEW_TYPE_COMMENT(CHILD(VAR_1, VAR_2));\n                        if (!VAR_13->type_comment)\n                            return NULL;\n                        VAR_2 += 1;\n                    }\n\n                    if (VAR_2 < NCH(VAR_1) && (TYPE(CHILD(VAR_1, VAR_2)) == VAR_21\n                                    || TYPE(CHILD(VAR_1, VAR_2)) == VAR_22)) {\n                        int VAR_28 = 0;\n                        VAR_28 = handle_keywordonly_args(VAR_0, VAR_1, VAR_2,\n                                                      VAR_11, VAR_12);\n                        if (VAR_28 == -1) return NULL;\n                        VAR_2 = VAR_28; /* COMMENT_42 */\n                    }\n                }\n                break;\n            case VAR_23:\n                VAR_16 = CHILD(VAR_1, VAR_2+1);  /* COMMENT_44 */\n                assert(TYPE(VAR_16) == VAR_21 || TYPE(VAR_16) == VAR_22);\n                VAR_14 = ast_for_arg(VAR_0, VAR_16);\n                if (!VAR_14)\n                    return NULL;\n                VAR_2 += 2; /* COMMENT_45 */\n                if (VAR_2 < NCH(VAR_1) && TYPE(CHILD(VAR_1, VAR_2)) == VAR_26)\n                    VAR_2 += 1; /* COMMENT_39 */\n                break;\n            case VAR_27:\n                assert(VAR_2);\n\n                if (VAR_14)\n                    VAR_15 = VAR_14;\n\n                /* COMMENT_46 */\n                VAR_15->type_comment = NEW_TYPE_COMMENT(VAR_16);\n                if (!VAR_15->type_comment)\n                    return NULL;\n                VAR_2 += 1;\n                break;\n            default:\n                PyErr_Format(VAR_29,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(VAR_16), VAR_2);\n                return NULL;\n        }\n    }\n    return arguments(VAR_9, VAR_13, VAR_11, VAR_12, VAR_14, VAR_10, VAR_0->c_arena);\n}",
  "func_graph_path": "python/typed_ast/dc317ac9cff859aa84eeabe03fb5004982545b3b/ast.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -173,7 +173,7 @@\n                 if (!kwarg)\n                     return NULL;\n                 i += 2; /* the double star and the name */\n-                if (TYPE(CHILD(n, i)) == COMMA)\n+                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                     i += 1; /* the comma, if present */\n                 break;\n             case TYPE_COMMENT:",
  "diff_line_info": {
    "deleted_lines": [
      "                if (TYPE(CHILD(n, i)) == COMMA)"
    ],
    "added_lines": [
      "                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/typed_ast/pull/99",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/python/typed_ast/pull/99: 403 Client Error: Forbidden for url: https://api.github.com/repos/python/typed_ast/pulls/99",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \nThe patch addresses an out-of-bounds array read, a clear security issue, with code changes adding necessary bounds checks, confirming it's a security fix.\n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}