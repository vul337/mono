{
  "cve_id": "CVE-2018-16981",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "nothings/stb",
  "commit_msg": "stb_image: Fix multiple bugs in GIF decoder.\n\n1. Check not just g->out allocation for failure.\n2. If an image descriptor specified a 0-width image, this could be\n   used to produce an out-of-bounds write.\n3. Fix memory leak in case an error occurs during decoding.\n\nFixes issue #656.",
  "commit_hash": "50b1bfba583b12ceb23ef949567bdd914461e524",
  "git_url": "https://github.com/nothings/stb/commit/50b1bfba583b12ceb23ef949567bdd914461e524",
  "file_path": "stb_image.h",
  "func_name": "stbi__gif_load",
  "func_before": "static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *u = 0;\n   stbi__gif g;\n   memset(&g, 0, sizeof(g));\n   STBI_NOTUSED(ri);\n\n   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n   if (u) {\n      *x = g.w;\n      *y = g.h;\n\n      // moved conversion to after successful load so that the same\n      // can be done for multiple frames. \n      if (req_comp && req_comp != 4)\n         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);\n   }\n\n   // free buffers needed for multiple frame loading; \n   STBI_FREE(g.history);\n   STBI_FREE(g.background); \n\n   return u;\n}",
  "abstract_func_before": "static void *stbi__gif_load(stbi__context *VAR_0, int *VAR_1, int *VAR_2, int *VAR_3, int VAR_4, stbi__result_info *VAR_5)\n{\n   stbi_uc *VAR_6 = 0;\n   stbi__gif VAR_7;\n   memset(&VAR_7, 0, sizeof(VAR_7));\n   STBI_NOTUSED(VAR_5);\n\n   VAR_6 = stbi__gif_load_next(VAR_0, &VAR_7, VAR_3, VAR_4, 0);\n   if (VAR_6 == (stbi_uc *) VAR_0) VAR_6 = 0;  /* COMMENT_0 */\n   if (VAR_6) {\n      *VAR_1 = VAR_7.w;\n      *VAR_2 = VAR_7.h;\n\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      if (VAR_4 && VAR_4 != 4)\n         VAR_6 = stbi__convert_format(VAR_6, 4, VAR_4, VAR_7.w, VAR_7.h);\n   }\n\n   /* COMMENT_3 */\n   STBI_FREE(VAR_7.history);\n   STBI_FREE(VAR_7.background); \n\n   return VAR_6;\n}",
  "func_graph_path_before": "nothings/stb/50b1bfba583b12ceb23ef949567bdd914461e524/stb_image.h/vul/before/0.json",
  "func": "static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *u = 0;\n   stbi__gif g;\n   memset(&g, 0, sizeof(g));\n   STBI_NOTUSED(ri);\n\n   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n   if (u) {\n      *x = g.w;\n      *y = g.h;\n\n      // moved conversion to after successful load so that the same\n      // can be done for multiple frames. \n      if (req_comp && req_comp != 4)\n         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);\n   } else if (g.out) {\n      // if there was an error and we allocated an image buffer, free it!\n      STBI_FREE(g.out);\n   }\n\n   // free buffers needed for multiple frame loading; \n   STBI_FREE(g.history);\n   STBI_FREE(g.background); \n\n   return u;\n}",
  "abstract_func": "static void *stbi__gif_load(stbi__context *VAR_0, int *VAR_1, int *VAR_2, int *VAR_3, int VAR_4, stbi__result_info *VAR_5)\n{\n   stbi_uc *VAR_6 = 0;\n   stbi__gif VAR_7;\n   memset(&VAR_7, 0, sizeof(VAR_7));\n   STBI_NOTUSED(VAR_5);\n\n   VAR_6 = stbi__gif_load_next(VAR_0, &VAR_7, VAR_3, VAR_4, 0);\n   if (VAR_6 == (stbi_uc *) VAR_0) VAR_6 = 0;  /* COMMENT_0 */\n   if (VAR_6) {\n      *VAR_1 = VAR_7.w;\n      *VAR_2 = VAR_7.h;\n\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      if (VAR_4 && VAR_4 != 4)\n         VAR_6 = stbi__convert_format(VAR_6, 4, VAR_4, VAR_7.w, VAR_7.h);\n   } else if (VAR_7.out) {\n      /* COMMENT_3 */\n      STBI_FREE(VAR_7.out);\n   }\n\n   /* COMMENT_4 */\n   STBI_FREE(VAR_7.history);\n   STBI_FREE(VAR_7.background); \n\n   return VAR_6;\n}",
  "func_graph_path": "nothings/stb/50b1bfba583b12ceb23ef949567bdd914461e524/stb_image.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,9 @@\n       // can be done for multiple frames. \n       if (req_comp && req_comp != 4)\n          u = stbi__convert_format(u, 4, req_comp, g.w, g.h);\n+   } else if (g.out) {\n+      // if there was an error and we allocated an image buffer, free it!\n+      STBI_FREE(g.out);\n    }\n \n    // free buffers needed for multiple frame loading; ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "   } else if (g.out) {",
      "      // if there was an error and we allocated an image buffer, free it!",
      "      STBI_FREE(g.out);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nothings/stb/pull/725",
  "description": {
    "pr_info": {
      "title": "stb_image: Fix multiple bugs in GIF decoder.",
      "number": 725
    },
    "comment": [
      "1. Check not just g->out allocation for failure; also make sure\r\n   that the image allocs don't overflow.\r\n2. If an image descriptor specified a 0-width image, this could be\r\n   used to produce an out-of-bounds write.\r\n3. Fix memory leak in case an error occurs during decoding.\r\n\r\nFixes issue #614.\r\nFixes issue #656.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}