{
  "cve_id": "CVE-2018-16391",
  "cwe_ids": [
    "CWE-415",
    "CWE-119"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
  "commit_hash": "360e95d45ac4123255a4c796db96337f332160ad",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
  "file_path": "src/libopensc/pkcs15-gemsafeV1.c",
  "func_name": "gemsafe_get_cert_len",
  "func_before": "static int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}",
  "abstract_func_before": "static int gemsafe_get_cert_len(sc_card_t *VAR_0)\n{\n\tint VAR_1;\n\tu8  VAR_2[VAR_3];\n\tu8 *VAR_4;\n\tstruct sc_path VAR_5;\n\tstruct sc_file *VAR_6;\n\tsize_t VAR_7, VAR_8;\n\tunsigned int VAR_9, VAR_10=0;\n\n\tsc_format_path(VAR_11, &VAR_5);\n\tVAR_1 = sc_select_file(VAR_0, &VAR_5, &VAR_6);\n\tif (VAR_1 != VAR_12 || !VAR_6)\n\t\treturn VAR_13;\n\n\t/* COMMENT_0 */\n\tVAR_1 = sc_read_binary(VAR_0, 0, VAR_2, VAR_14, 0);\n\tif (VAR_1 < 0)\n\t\treturn VAR_13;\n\n\t/* COMMENT_1 */\n                                         \n    \n\tVAR_7 = (((size_t) VAR_2[0]) << 8) | VAR_2[1];\n\tsc_log(VAR_0->ctx, \"Stored object is of size: %\"VAR_15\"u\",\n\t       VAR_7);\n\tif (VAR_7 < 1 || VAR_7 > VAR_3) {\n\t    sc_log(VAR_0->ctx, \"Invalid object size: %\"VAR_15\"u\",\n\t\t   VAR_7);\n\t    return VAR_13;\n\t}\n\n\t/* COMMENT_4 */\n                                                              \n                                                               \n                                                       \n                                                       \n                                                     \n                                                     \n                                                       \n       \n                                                       \n                                                             \n                                                           \n                    \n    \n\tVAR_9 = 2; /* COMMENT_18 */\n\twhile (VAR_2[VAR_9] == 0x01) {\n\t\tif (VAR_2[VAR_9+1] == 0xFE) {\n\t\t\tVAR_16[VAR_10].ref = VAR_2[VAR_9+4];\n\t\t\tsc_log(VAR_0->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\tVAR_10+1, VAR_16[VAR_10].ref);\n\t\t\tVAR_9 += 9;\n\t\t}\n\t\telse {\n\t\t\tVAR_16[VAR_10].label = NULL;\n\t\t\tVAR_17[VAR_10].label = NULL;\n\t\t\tsc_log(VAR_0->ctx, \"Key container %d is unallocated\", VAR_10+1);\n\t\t\tVAR_9 += 8;\n\t\t}\n\t\tVAR_10++;\n\t}\n\n\t/* COMMENT_19 */\n                                     \n    \n\tfor (; VAR_10 < VAR_18; VAR_10++) {\n\t\tVAR_16[VAR_10].label = NULL;\n\t\tVAR_17[VAR_10].label = NULL;\n\t}\n\n\t/* COMMENT_22 */\n                                                      \n    \n\tVAR_4 = VAR_2 + VAR_14;\n\twhile ((size_t)(VAR_4 - VAR_2) < VAR_7) {\n\t\tVAR_1 = sc_read_binary(VAR_0, VAR_4 - VAR_2, VAR_4,\n\t\t\t\t   MIN(VAR_14, VAR_7 - (VAR_4 - VAR_2)), 0);\n\t\tif (VAR_1 < 0) {\n\t\t\tsc_log(VAR_0->ctx, \"Could not read cert object\");\n\t\t\treturn VAR_13;\n\t\t}\n\t\tVAR_4 += VAR_14;\n\t}\n\n\t/* COMMENT_25 */\n\tVAR_10 = 0;\n\twhile (VAR_9 < VAR_7 - 1) {\n\t\tif (VAR_2[VAR_9] == 0x30 && VAR_2[VAR_9+1] == 0x82) {\n\t\t\t/* COMMENT_26 */\n\t\t\twhile (VAR_10 < VAR_18 && VAR_17[VAR_10].label == NULL)\n\t\t\t\tVAR_10++;\n\t\t\tif (VAR_10 == VAR_18) {\n\t\t\t\tsc_log(VAR_0->ctx, \"Warning: Found orphaned certificate at offset %d\", VAR_9);\n\t\t\t\treturn VAR_12;\n\t\t\t}\n\t\t\t/* COMMENT_27 */\n\t\t\tif (VAR_9+3 >= sizeof VAR_2)\n\t\t\t\treturn VAR_19;\n\t\t\tVAR_8 = ((((size_t) VAR_2[VAR_9+2]) << 8) | VAR_2[VAR_9+3]) + 4;\n\t\t\tsc_log(VAR_0->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"VAR_15\"u\",\n\t\t\t       VAR_10+1, VAR_9, VAR_8);\n\t\t\tVAR_17[VAR_10].index = VAR_9;\n\t\t\tVAR_17[VAR_10].count = VAR_8;\n\t\t\tVAR_9 += VAR_8;\n\t\t\tVAR_10++;\n\t\t} else\n\t\t\tVAR_9++;\n\t}\n\n\t/* COMMENT_28 */\n                                \n    \n\tfor (; VAR_10 < VAR_18; VAR_10++) {\n\t\tif (VAR_17[VAR_10].label) {\n\t\t\tsc_log(VAR_0->ctx, \"Warning: Certificate of key container %d is missing\", VAR_10+1);\n\t\t\tVAR_16[VAR_10].label = NULL;\n\t\t\tVAR_17[VAR_10].label = NULL;\n\t\t}\n\t}\n\n\treturn VAR_12;\n}",
  "func_graph_path_before": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/pkcs15-gemsafeV1.c/vul/before/0.json",
  "func": "static int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}",
  "abstract_func": "static int gemsafe_get_cert_len(sc_card_t *VAR_0)\n{\n\tint VAR_1;\n\tu8  VAR_2[VAR_3];\n\tu8 *VAR_4;\n\tstruct sc_path VAR_5;\n\tstruct sc_file *VAR_6;\n\tsize_t VAR_7, VAR_8;\n\tunsigned int VAR_9, VAR_10=0;\n\n\tsc_format_path(VAR_11, &VAR_5);\n\tVAR_1 = sc_select_file(VAR_0, &VAR_5, &VAR_6);\n\tif (VAR_1 != VAR_12 || !VAR_6)\n\t\treturn VAR_13;\n\n\t/* COMMENT_0 */\n\tVAR_1 = sc_read_binary(VAR_0, 0, VAR_2, VAR_14, 0);\n\tif (VAR_1 < 0)\n\t\treturn VAR_13;\n\n\t/* COMMENT_1 */\n                                         \n    \n\tVAR_7 = (((size_t) VAR_2[0]) << 8) | VAR_2[1];\n\tsc_log(VAR_0->ctx, \"Stored object is of size: %\"VAR_15\"u\",\n\t       VAR_7);\n\tif (VAR_7 < 1 || VAR_7 > VAR_3) {\n\t    sc_log(VAR_0->ctx, \"Invalid object size: %\"VAR_15\"u\",\n\t\t   VAR_7);\n\t    return VAR_13;\n\t}\n\n\t/* COMMENT_4 */\n                                                              \n                                                               \n                                                       \n                                                       \n                                                     \n                                                     \n                                                       \n       \n                                                       \n                                                             \n                                                           \n                    \n    \n\tVAR_9 = 2; /* COMMENT_18 */\n\twhile (VAR_2[VAR_9] == 0x01 && VAR_10 < VAR_16) {\n\t\tif (VAR_2[VAR_9+1] == 0xFE) {\n\t\t\tVAR_17[VAR_10].ref = VAR_2[VAR_9+4];\n\t\t\tsc_log(VAR_0->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\tVAR_10+1, VAR_17[VAR_10].ref);\n\t\t\tVAR_9 += 9;\n\t\t}\n\t\telse {\n\t\t\tVAR_17[VAR_10].label = NULL;\n\t\t\tVAR_18[VAR_10].label = NULL;\n\t\t\tsc_log(VAR_0->ctx, \"Key container %d is unallocated\", VAR_10+1);\n\t\t\tVAR_9 += 8;\n\t\t}\n\t\tVAR_10++;\n\t}\n\n\t/* COMMENT_19 */\n                                     \n    \n\tfor (; VAR_10 < VAR_16; VAR_10++) {\n\t\tVAR_17[VAR_10].label = NULL;\n\t\tVAR_18[VAR_10].label = NULL;\n\t}\n\n\t/* COMMENT_22 */\n                                                      \n    \n\tVAR_4 = VAR_2 + VAR_14;\n\twhile ((size_t)(VAR_4 - VAR_2) < VAR_7) {\n\t\tVAR_1 = sc_read_binary(VAR_0, VAR_4 - VAR_2, VAR_4,\n\t\t\t\t   MIN(VAR_14, VAR_7 - (VAR_4 - VAR_2)), 0);\n\t\tif (VAR_1 < 0) {\n\t\t\tsc_log(VAR_0->ctx, \"Could not read cert object\");\n\t\t\treturn VAR_13;\n\t\t}\n\t\tVAR_4 += VAR_14;\n\t}\n\n\t/* COMMENT_25 */\n\tVAR_10 = 0;\n\twhile (VAR_9 < VAR_7 - 1) {\n\t\tif (VAR_2[VAR_9] == 0x30 && VAR_2[VAR_9+1] == 0x82) {\n\t\t\t/* COMMENT_26 */\n\t\t\twhile (VAR_10 < VAR_16 && VAR_18[VAR_10].label == NULL)\n\t\t\t\tVAR_10++;\n\t\t\tif (VAR_10 == VAR_16) {\n\t\t\t\tsc_log(VAR_0->ctx, \"Warning: Found orphaned certificate at offset %d\", VAR_9);\n\t\t\t\treturn VAR_12;\n\t\t\t}\n\t\t\t/* COMMENT_27 */\n\t\t\tif (VAR_9+3 >= sizeof VAR_2)\n\t\t\t\treturn VAR_19;\n\t\t\tVAR_8 = ((((size_t) VAR_2[VAR_9+2]) << 8) | VAR_2[VAR_9+3]) + 4;\n\t\t\tsc_log(VAR_0->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"VAR_15\"u\",\n\t\t\t       VAR_10+1, VAR_9, VAR_8);\n\t\t\tVAR_18[VAR_10].index = VAR_9;\n\t\t\tVAR_18[VAR_10].count = VAR_8;\n\t\t\tVAR_9 += VAR_8;\n\t\t\tVAR_10++;\n\t\t} else\n\t\t\tVAR_9++;\n\t}\n\n\t/* COMMENT_28 */\n                                \n    \n\tfor (; VAR_10 < VAR_16; VAR_10++) {\n\t\tif (VAR_18[VAR_10].label) {\n\t\t\tsc_log(VAR_0->ctx, \"Warning: Certificate of key container %d is missing\", VAR_10+1);\n\t\t\tVAR_17[VAR_10].label = NULL;\n\t\t\tVAR_18[VAR_10].label = NULL;\n\t\t}\n\t}\n\n\treturn VAR_12;\n}",
  "func_graph_path": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/pkcs15-gemsafeV1.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",",
  "diff_line_info": {
    "deleted_lines": [
      "\twhile (ibuf[ind] == 0x01) {"
    ],
    "added_lines": [
      "\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OpenSC/OpenSC/pull/1447: 403 Client Error: Forbidden for url: https://api.github.com/repos/OpenSC/OpenSC/pulls/1447",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}