{
  "cve_id": "CVE-2018-8098",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "index: error out on unreasonable prefix-compressed path lengths\n\nWhen computing the complete path length from the encoded\nprefix-compressed path, we end up just allocating the complete path\nwithout ever checking what the encoded path length actually is. This can\neasily lead to a denial of service by just encoding an unreasonable long\npath name inside of the index. Git already enforces a maximum path\nlength of 4096 bytes. As we also have that enforcement ready in some\nplaces, just make sure that the resulting path is smaller than\nGIT_PATH_MAX.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
  "commit_hash": "3db1af1f370295ad5355b8f64b865a2a357bcac0",
  "git_url": "https://github.com/libgit2/libgit2/commit/3db1af1f370295ad5355b8f64b865a2a357bcac0",
  "file_path": "src/index.c",
  "func_name": "read_entry",
  "func_before": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
  "abstract_func_before": "static int read_entry(\n\tgit_index_entry **VAR_0,\n\tsize_t *VAR_1,\n\tgit_index *VAR_2,\n\tconst void *VAR_3,\n\tsize_t VAR_4,\n\tconst char *VAR_5)\n{\n\tsize_t VAR_6, VAR_7;\n\tconst char *VAR_8;\n\tstruct entry_short VAR_9;\n\tgit_index_entry VAR_10 = {{0}};\n\tbool VAR_11 = VAR_2->version >= VAR_12;\n\tchar *VAR_13 = NULL;\n\n\tif (VAR_14 + VAR_15 > VAR_4)\n\t\treturn -1;\n\n\t/* COMMENT_0 */\n\tmemcpy(&VAR_9, VAR_3, sizeof(struct entry_short));\n\n\tVAR_10.ctime.seconds = (git_time_t)ntohl(VAR_9.ctime.seconds);\n\tVAR_10.ctime.nanoseconds = ntohl(VAR_9.ctime.nanoseconds);\n\tVAR_10.mtime.seconds = (git_time_t)ntohl(VAR_9.mtime.seconds);\n\tVAR_10.mtime.nanoseconds = ntohl(VAR_9.mtime.nanoseconds);\n\tVAR_10.dev = ntohl(VAR_9.dev);\n\tVAR_10.ino = ntohl(VAR_9.ino);\n\tVAR_10.mode = ntohl(VAR_9.mode);\n\tVAR_10.uid = ntohl(VAR_9.uid);\n\tVAR_10.gid = ntohl(VAR_9.gid);\n\tVAR_10.file_size = ntohl(VAR_9.file_size);\n\tgit_oid_cpy(&VAR_10.id, &VAR_9.oid);\n\tVAR_10.flags = ntohs(VAR_9.flags);\n\n\tif (VAR_10.flags & VAR_16) {\n\t\tuint16_t VAR_17;\n\t\tsize_t VAR_18;\n\n\t\tVAR_18 = offsetof(struct VAR_19, VAR_20);\n\t\tmemcpy(&VAR_17, (const char *) VAR_3 + VAR_18,\n\t\t\tsizeof(VAR_17));\n\t\tVAR_17 = ntohs(VAR_17);\n\n\t\tmemcpy(&VAR_10.flags_extended, &VAR_17, sizeof(VAR_17));\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct VAR_19, VAR_21);\n\t} else\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct entry_short, VAR_21);\n\n\tif (!VAR_11) {\n\t\tVAR_6 = VAR_10.flags & VAR_22;\n\n\t\t/* COMMENT_1 */\n                                       \n\t\tif (VAR_6 == 0xFFF) {\n\t\t\tconst char *VAR_23;\n\n\t\t\tVAR_23 = memchr(VAR_8, '\\0', VAR_4);\n\t\t\tif (VAR_23 == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tVAR_6 = VAR_23 - VAR_8;\n\t\t}\n\n\t\tVAR_7 = index_entry_size(VAR_6, 0, VAR_10.flags);\n\t\tVAR_10.path = (char *)VAR_8;\n\t} else {\n\t\tsize_t VAR_24, VAR_25, VAR_26, VAR_27, VAR_28;\n\t\tuintmax_t VAR_29;\n\n\t\tVAR_29 = git_decode_varint((const unsigned char *)VAR_8, &VAR_24);\n\t\tVAR_25 = strlen(VAR_5);\n\n\t\tif (VAR_24 == 0 || VAR_25 < VAR_29)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tVAR_26 = VAR_25 - VAR_29;\n\t\tVAR_27 = strlen(VAR_8 + VAR_24);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_26, VAR_27);\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_28, 1);\n\t\tVAR_13 = git__malloc(VAR_28);\n\t\tGITERR_CHECK_ALLOC(VAR_13);\n\n\t\tmemcpy(VAR_13, VAR_5, VAR_26);\n\t\tmemcpy(VAR_13 + VAR_26, VAR_8 + VAR_24, VAR_27 + 1);\n\t\tVAR_7 = index_entry_size(VAR_27, VAR_24, VAR_10.flags);\n\t\tVAR_10.path = VAR_13;\n\t}\n\n\tif (VAR_7 == 0)\n\t\treturn -1;\n\n\tif (VAR_14 + VAR_7 > VAR_4)\n\t\treturn -1;\n\n\tif (index_entry_dup(VAR_0, VAR_2, &VAR_10) < 0) {\n\t\tgit__free(VAR_13);\n\t\treturn -1;\n\t}\n\n\tgit__free(VAR_13);\n\t*VAR_1 = VAR_7;\n\treturn 0;\n}",
  "func_graph_path_before": "libgit2/3db1af1f370295ad5355b8f64b865a2a357bcac0/index.c/vul/before/0.json",
  "func": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\n\t\tif (path_len > GIT_PATH_MAX)\n\t\t\treturn index_error_invalid(\"unreasonable path length\");\n\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
  "abstract_func": "static int read_entry(\n\tgit_index_entry **VAR_0,\n\tsize_t *VAR_1,\n\tgit_index *VAR_2,\n\tconst void *VAR_3,\n\tsize_t VAR_4,\n\tconst char *VAR_5)\n{\n\tsize_t VAR_6, VAR_7;\n\tconst char *VAR_8;\n\tstruct entry_short VAR_9;\n\tgit_index_entry VAR_10 = {{0}};\n\tbool VAR_11 = VAR_2->version >= VAR_12;\n\tchar *VAR_13 = NULL;\n\n\tif (VAR_14 + VAR_15 > VAR_4)\n\t\treturn -1;\n\n\t/* COMMENT_0 */\n\tmemcpy(&VAR_9, VAR_3, sizeof(struct entry_short));\n\n\tVAR_10.ctime.seconds = (git_time_t)ntohl(VAR_9.ctime.seconds);\n\tVAR_10.ctime.nanoseconds = ntohl(VAR_9.ctime.nanoseconds);\n\tVAR_10.mtime.seconds = (git_time_t)ntohl(VAR_9.mtime.seconds);\n\tVAR_10.mtime.nanoseconds = ntohl(VAR_9.mtime.nanoseconds);\n\tVAR_10.dev = ntohl(VAR_9.dev);\n\tVAR_10.ino = ntohl(VAR_9.ino);\n\tVAR_10.mode = ntohl(VAR_9.mode);\n\tVAR_10.uid = ntohl(VAR_9.uid);\n\tVAR_10.gid = ntohl(VAR_9.gid);\n\tVAR_10.file_size = ntohl(VAR_9.file_size);\n\tgit_oid_cpy(&VAR_10.id, &VAR_9.oid);\n\tVAR_10.flags = ntohs(VAR_9.flags);\n\n\tif (VAR_10.flags & VAR_16) {\n\t\tuint16_t VAR_17;\n\t\tsize_t VAR_18;\n\n\t\tVAR_18 = offsetof(struct VAR_19, VAR_20);\n\t\tmemcpy(&VAR_17, (const char *) VAR_3 + VAR_18,\n\t\t\tsizeof(VAR_17));\n\t\tVAR_17 = ntohs(VAR_17);\n\n\t\tmemcpy(&VAR_10.flags_extended, &VAR_17, sizeof(VAR_17));\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct VAR_19, VAR_21);\n\t} else\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct entry_short, VAR_21);\n\n\tif (!VAR_11) {\n\t\tVAR_6 = VAR_10.flags & VAR_22;\n\n\t\t/* COMMENT_1 */\n                                       \n\t\tif (VAR_6 == 0xFFF) {\n\t\t\tconst char *VAR_23;\n\n\t\t\tVAR_23 = memchr(VAR_8, '\\0', VAR_4);\n\t\t\tif (VAR_23 == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tVAR_6 = VAR_23 - VAR_8;\n\t\t}\n\n\t\tVAR_7 = index_entry_size(VAR_6, 0, VAR_10.flags);\n\t\tVAR_10.path = (char *)VAR_8;\n\t} else {\n\t\tsize_t VAR_24, VAR_25, VAR_26, VAR_27, VAR_28;\n\t\tuintmax_t VAR_29;\n\n\t\tVAR_29 = git_decode_varint((const unsigned char *)VAR_8, &VAR_24);\n\t\tVAR_25 = strlen(VAR_5);\n\n\t\tif (VAR_24 == 0 || VAR_25 < VAR_29)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tVAR_26 = VAR_25 - VAR_29;\n\t\tVAR_27 = strlen(VAR_8 + VAR_24);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_26, VAR_27);\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_28, 1);\n\n\t\tif (VAR_28 > VAR_30)\n\t\t\treturn index_error_invalid(\"unreasonable path length\");\n\n\t\tVAR_13 = git__malloc(VAR_28);\n\t\tGITERR_CHECK_ALLOC(VAR_13);\n\n\t\tmemcpy(VAR_13, VAR_5, VAR_26);\n\t\tmemcpy(VAR_13 + VAR_26, VAR_8 + VAR_24, VAR_27 + 1);\n\t\tVAR_7 = index_entry_size(VAR_27, VAR_24, VAR_10.flags);\n\t\tVAR_10.path = VAR_13;\n\t}\n\n\tif (VAR_7 == 0)\n\t\treturn -1;\n\n\tif (VAR_14 + VAR_7 > VAR_4)\n\t\treturn -1;\n\n\tif (index_entry_dup(VAR_0, VAR_2, &VAR_10) < 0) {\n\t\tgit__free(VAR_13);\n\t\treturn -1;\n\t}\n\n\tgit__free(VAR_13);\n\t*VAR_1 = VAR_7;\n\treturn 0;\n}",
  "func_graph_path": "libgit2/3db1af1f370295ad5355b8f64b865a2a357bcac0/index.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -78,6 +78,10 @@\n \n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n+\n+\t\tif (path_len > GIT_PATH_MAX)\n+\t\t\treturn index_error_invalid(\"unreasonable path length\");\n+\n \t\ttmp_path = git__malloc(path_len);\n \t\tGITERR_CHECK_ALLOC(tmp_path);\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\t\tif (path_len > GIT_PATH_MAX)",
      "\t\t\treturn index_error_invalid(\"unreasonable path length\");",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4575",
  "description": {
    "pr_info": {
      "title": "Index parsing fixes",
      "number": 4575
    },
    "comment": [
      "This is the security fix regarding reading of the compressed index entries forward-ported to the master branch."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\n---\n\n**Analysis:**\n\n1. **Input Analysis:** The commit message addresses a potential denial of service (DoS) vulnerability due to overly long path names in the index. The code diff introduces a check for path length exceeding `GIT_PATH_MAX` and returns an error if this condition is met.\n\n2. **Consistency Check:** The commit message aligns with the code changes, introducing a security check.\n\n3. **Purpose Evaluation:** The change modifies core logic by adding a security check to prevent an exploit.\n\n4. **Security Vulnerability Assessment:** The patch aims to mitigate a DoS vulnerability associated with excessively long path names, confirming it as a security fix.\n\n5. **Non-Security Classification:** Not applicable, as it is a security fix.\n\n6. **Confidence Scoring:** High confidence (1.0) due to clear alignment between the commit message, vulnerability description, and code changes.\n\n**Decision:** The patch is a \"Security Vulnerability Fix\" with confidence 1.0."
}