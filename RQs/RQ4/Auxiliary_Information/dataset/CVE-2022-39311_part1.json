{
  "cve_id": "CVE-2022-39311",
  "cwe_ids": [
    "CWE-502"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "gocd",
  "commit_msg": "Disable RMI endpoint by default\n\nThis endpoint can be enabled by including `gocd.agent.remoting.legacy=true` in the\n`-Dgocd.agent.extra.properties` property for the server process.",
  "commit_hash": "7b88b70d6f7f429562d5cab49a80ea856e34cdc8",
  "git_url": "https://github.com/gocd/gocd/commit/7b88b70d6f7f429562d5cab49a80ea856e34cdc8",
  "file_path": "server/src/main/java/com/thoughtworks/go/remote/AgentRemoteInvokerServiceExporter.java",
  "func_name": "handleRequest",
  "func_before": "@Override\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            RemoteInvocation invocation = readRemoteInvocation(request);\n\n            if (!authorized(request, response, invocation)) {\n                return;\n            }\n\n            RemoteInvocationResult result = invokeAndCreateResult(invocation, getProxy());\n            writeRemoteInvocationResult(request, response, result);\n        } catch (ClassNotFoundException ex) {\n            throw new NestedServletException(\"Class not found during deserialization\", ex);\n        }\n    }",
  "abstract_func_before": "@Override\n    public void handleRequest(HttpServletRequest VAR_0, HttpServletResponse VAR_1) throws ServletException, IOException {\n        try {\n            RemoteInvocation VAR_2 = readRemoteInvocation(VAR_0);\n\n            if (!authorized(VAR_0, VAR_1, VAR_2)) {\n                return;\n            }\n\n            RemoteInvocationResult VAR_3 = invokeAndCreateResult(VAR_2, getProxy());\n            writeRemoteInvocationResult(VAR_0, VAR_1, VAR_3);\n        } catch (ClassNotFoundException VAR_4) {\n            throw new NestedServletException(\"Class not found during deserialization\", VAR_4);\n        }\n    }",
  "func_graph_path_before": "gocd/7b88b70d6f7f429562d5cab49a80ea856e34cdc8/AgentRemoteInvokerServiceExporter.java/vul/before/0.json",
  "func": "@Override\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (rejectRMI()) {\n            // yes, ideally, this should be short-circuited in the agent auth filter, but keeping this logic here has\n            // some advantages:\n            //   - it keeps all deprecated RMI logic in one place so it's easier to remove (just remove this class)\n            //   - it's 100% reliable by virtue of its proximity to the RMI invocation code and can't be thwarted by\n            //     some clever URI encoding to circumvent the uri path test that we would need to write at the filter\n            //     level in order to selectively apply this logic to the RMI endpoint and not the JSON API endpoint\n            reject(response, SC_GONE, \"This RMI endpoint is disabled.\");\n            return;\n        }\n\n        try {\n            RemoteInvocation invocation = readRemoteInvocation(request);\n\n            if (!authorized(request, response, invocation)) {\n                return;\n            }\n\n            RemoteInvocationResult result = invokeAndCreateResult(invocation, getProxy());\n            writeRemoteInvocationResult(request, response, result);\n        } catch (ClassNotFoundException ex) {\n            throw new NestedServletException(\"Class not found during deserialization\", ex);\n        }\n    }",
  "abstract_func": "@Override\n    public void handleRequest(HttpServletRequest VAR_0, HttpServletResponse VAR_1) throws ServletException, IOException {\n        if (rejectRMI()) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            reject(VAR_1, VAR_2, \"This RMI endpoint is disabled.\");\n            return;\n        }\n\n        try {\n            RemoteInvocation VAR_3 = readRemoteInvocation(VAR_0);\n\n            if (!authorized(VAR_0, VAR_1, VAR_3)) {\n                return;\n            }\n\n            RemoteInvocationResult VAR_4 = invokeAndCreateResult(VAR_3, getProxy());\n            writeRemoteInvocationResult(VAR_0, VAR_1, VAR_4);\n        } catch (ClassNotFoundException VAR_5) {\n            throw new NestedServletException(\"Class not found during deserialization\", VAR_5);\n        }\n    }",
  "func_graph_path": "gocd/7b88b70d6f7f429562d5cab49a80ea856e34cdc8/AgentRemoteInvokerServiceExporter.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,16 @@\n @Override\n     public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n+        if (rejectRMI()) {\n+            // yes, ideally, this should be short-circuited in the agent auth filter, but keeping this logic here has\n+            // some advantages:\n+            //   - it keeps all deprecated RMI logic in one place so it's easier to remove (just remove this class)\n+            //   - it's 100% reliable by virtue of its proximity to the RMI invocation code and can't be thwarted by\n+            //     some clever URI encoding to circumvent the uri path test that we would need to write at the filter\n+            //     level in order to selectively apply this logic to the RMI endpoint and not the JSON API endpoint\n+            reject(response, SC_GONE, \"This RMI endpoint is disabled.\");\n+            return;\n+        }\n+\n         try {\n             RemoteInvocation invocation = readRemoteInvocation(request);\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (rejectRMI()) {",
      "            // yes, ideally, this should be short-circuited in the agent auth filter, but keeping this logic here has",
      "            // some advantages:",
      "            //   - it keeps all deprecated RMI logic in one place so it's easier to remove (just remove this class)",
      "            //   - it's 100% reliable by virtue of its proximity to the RMI invocation code and can't be thwarted by",
      "            //     some clever URI encoding to circumvent the uri path test that we would need to write at the filter",
      "            //     level in order to selectively apply this logic to the RMI endpoint and not the JSON API endpoint",
      "            reject(response, SC_GONE, \"This RMI endpoint is disabled.\");",
      "            return;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/gocd/gocd/pull/8929",
  "description": {
    "pr_info": {
      "title": "Disable RMI endpoint by default but allow toggling",
      "number": 8929
    },
    "comment": [
      "Even though agents now use the JSON remoting API, the RMI endpoint on the server should be disabled unless the agents are configured to use the legacy RMI comms.\r\n\r\nThis endpoint can be enabled by including `gocd.agent.remoting.legacy=true` in the `-Dgocd.agent.extra.properties` property for the server process, which is the same method used to enable RMI on the agents side.",
      "Hey folks - do you think it would be safe now to remove the RMI remoting entirely? Are you aware of any issues or reports of people needing to turn RMI remoting back on?\r\n\r\nThe only thing I am really aware of that might relate to this is #9641 which might relate to the change in comms approaches.\r\n\r\nI noticed that the regression tests seem to have been running with `gocd.agent.remoting.legacy=true` set which is, err, not ideal, especially as this area is a bit sensitive for the Java 16/17 upgrade (regarding serialization to objects or JSON). Just switched them - hopefully it's fine.\r\n\r\nEdit - this was completely removed in GoCD `22.2.0`"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch disables the RMI endpoint by default to mitigate a security risk, aligning with best practices for securing services. Although it doesn't reference specific CVEs, the intent to disable an endpoint not in use reduces the attack surface, confirming it as a security fix."
}