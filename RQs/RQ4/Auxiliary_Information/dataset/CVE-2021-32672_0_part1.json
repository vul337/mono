{
  "cve_id": "CVE-2021-32672",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
  "commit_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
  "git_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
  "file_path": "src/scripting.c",
  "func_name": "ldbRepl",
  "func_before": "int ldbRepl(lua_State *lua) {\n    sds *argv;\n    int argc;\n\n    /* We continue processing commands until a command that should return\n     * to the Lua interpreter is found. */\n    while(1) {\n        while((argv = ldbReplParseCommand(&argc)) == NULL) {\n            char buf[1024];\n            int nread = connRead(ldb.conn,buf,sizeof(buf));\n            if (nread <= 0) {\n                /* Make sure the script runs without user input since the\n                 * client is no longer connected. */\n                ldb.step = 0;\n                ldb.bpcount = 0;\n                return C_ERR;\n            }\n            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);\n        }\n\n        /* Flush the old buffer. */\n        sdsfree(ldb.cbuf);\n        ldb.cbuf = sdsempty();\n\n        /* Execute the command. */\n        if (!strcasecmp(argv[0],\"h\") || !strcasecmp(argv[0],\"help\")) {\nldbLog(sdsnew(\"Redis Lua debugger help:\"));\nldbLog(sdsnew(\"[h]elp               Show this help.\"));\nldbLog(sdsnew(\"[s]tep               Run current line and stop again.\"));\nldbLog(sdsnew(\"[n]ext               Alias for step.\"));\nldbLog(sdsnew(\"[c]continue          Run till next breakpoint.\"));\nldbLog(sdsnew(\"[l]list              List source code around current line.\"));\nldbLog(sdsnew(\"[l]list [line]       List source code around [line].\"));\nldbLog(sdsnew(\"                     line = 0 means: current position.\"));\nldbLog(sdsnew(\"[l]list [line] [ctx] In this form [ctx] specifies how many lines\"));\nldbLog(sdsnew(\"                     to show before/after [line].\"));\nldbLog(sdsnew(\"[w]hole              List all source code. Alias for 'list 1 1000000'.\"));\nldbLog(sdsnew(\"[p]rint              Show all the local variables.\"));\nldbLog(sdsnew(\"[p]rint <var>        Show the value of the specified variable.\"));\nldbLog(sdsnew(\"                     Can also show global vars KEYS and ARGV.\"));\nldbLog(sdsnew(\"[b]reak              Show all breakpoints.\"));\nldbLog(sdsnew(\"[b]reak <line>       Add a breakpoint to the specified line.\"));\nldbLog(sdsnew(\"[b]reak -<line>      Remove breakpoint from the specified line.\"));\nldbLog(sdsnew(\"[b]reak 0            Remove all breakpoints.\"));\nldbLog(sdsnew(\"[t]race              Show a backtrace.\"));\nldbLog(sdsnew(\"[e]eval <code>       Execute some Lua code (in a different callframe).\"));\nldbLog(sdsnew(\"[r]edis <cmd>        Execute a Redis command.\"));\nldbLog(sdsnew(\"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\"));\nldbLog(sdsnew(\"                     Specifying zero as <len> means unlimited.\"));\nldbLog(sdsnew(\"[a]bort              Stop the execution of the script. In sync\"));\nldbLog(sdsnew(\"                     mode dataset changes will be retained.\"));\nldbLog(sdsnew(\"\"));\nldbLog(sdsnew(\"Debugger functions you can call from Lua scripts:\"));\nldbLog(sdsnew(\"redis.debug()        Produce logs in the debugger console.\"));\nldbLog(sdsnew(\"redis.breakpoint()   Stop execution like if there was a breakpoint in the\"));\nldbLog(sdsnew(\"                     next line of code.\"));\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"s\") || !strcasecmp(argv[0],\"step\") ||\n                   !strcasecmp(argv[0],\"n\") || !strcasecmp(argv[0],\"next\")) {\n            ldb.step = 1;\n            break;\n        } else if (!strcasecmp(argv[0],\"c\") || !strcasecmp(argv[0],\"continue\")){\n            break;\n        } else if (!strcasecmp(argv[0],\"t\") || !strcasecmp(argv[0],\"trace\")) {\n            ldbTrace(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"m\") || !strcasecmp(argv[0],\"maxlen\")) {\n            ldbMaxlen(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"b\") || !strcasecmp(argv[0],\"break\")) {\n            ldbBreak(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"e\") || !strcasecmp(argv[0],\"eval\")) {\n            ldbEval(lua,argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"a\") || !strcasecmp(argv[0],\"abort\")) {\n            lua_pushstring(lua, \"script aborted for user request\");\n            lua_error(lua);\n        } else if (argc > 1 &&\n                   (!strcasecmp(argv[0],\"r\") || !strcasecmp(argv[0],\"redis\"))) {\n            ldbRedis(lua,argv,argc);\n            ldbSendLogs();\n        } else if ((!strcasecmp(argv[0],\"p\") || !strcasecmp(argv[0],\"print\"))) {\n            if (argc == 2)\n                ldbPrint(lua,argv[1]);\n            else\n                ldbPrintAll(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"l\") || !strcasecmp(argv[0],\"list\")){\n            int around = ldb.currentline, ctx = 5;\n            if (argc > 1) {\n                int num = atoi(argv[1]);\n                if (num > 0) around = num;\n            }\n            if (argc > 2) ctx = atoi(argv[2]);\n            ldbList(around,ctx);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"w\") || !strcasecmp(argv[0],\"whole\")){\n            ldbList(1,1000000);\n            ldbSendLogs();\n        } else {\n            ldbLog(sdsnew(\"<error> Unknown Redis Lua debugger command or \"\n                          \"wrong number of arguments.\"));\n            ldbSendLogs();\n        }\n\n        /* Free the command vector. */\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Free the current command argv if we break inside the while loop. */\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}",
  "abstract_func_before": "int ldbRepl(lua_State *VAR_0) {\n    sds *VAR_1;\n    int VAR_2;\n\n    /* COMMENT_0 */\n                                          \n    while(1) {\n        while((VAR_1 = ldbReplParseCommand(&VAR_2)) == NULL) {\n            char VAR_3[1024];\n            int VAR_4 = connRead(VAR_5.conn,VAR_3,sizeof(VAR_3));\n            if (VAR_4 <= 0) {\n                /* COMMENT_2 */\n                                                    \n                VAR_5.step = 0;\n                VAR_5.bpcount = 0;\n                return VAR_6;\n            }\n            VAR_5.cbuf = sdscatlen(VAR_5.cbuf,VAR_3,VAR_4);\n        }\n\n        /* COMMENT_4 */\n        sdsfree(VAR_5.cbuf);\n        VAR_5.cbuf = sdsempty();\n\n        /* COMMENT_5 */\n        if (!strcasecmp(VAR_1[0],\"h\") || !strcasecmp(VAR_1[0],\"help\")) {\nldbLog(sdsnew(\"Redis Lua debugger help:\"));\nldbLog(sdsnew(\"[h]elp               Show this help.\"));\nldbLog(sdsnew(\"[s]tep               Run current line and stop again.\"));\nldbLog(sdsnew(\"[n]ext               Alias for step.\"));\nldbLog(sdsnew(\"[c]continue          Run till next breakpoint.\"));\nldbLog(sdsnew(\"[l]list              List source code around current line.\"));\nldbLog(sdsnew(\"[l]list [line]       List source code around [line].\"));\nldbLog(sdsnew(\"                     line = 0 means: current position.\"));\nldbLog(sdsnew(\"[l]list [line] [ctx] In this form [ctx] specifies how many lines\"));\nldbLog(sdsnew(\"                     to show before/after [line].\"));\nldbLog(sdsnew(\"[w]hole              List all source code. Alias for 'list 1 1000000'.\"));\nldbLog(sdsnew(\"[p]rint              Show all the local variables.\"));\nldbLog(sdsnew(\"[p]rint <var>        Show the value of the specified variable.\"));\nldbLog(sdsnew(\"                     Can also show global vars KEYS and ARGV.\"));\nldbLog(sdsnew(\"[b]reak              Show all breakpoints.\"));\nldbLog(sdsnew(\"[b]reak <line>       Add a breakpoint to the specified line.\"));\nldbLog(sdsnew(\"[b]reak -<line>      Remove breakpoint from the specified line.\"));\nldbLog(sdsnew(\"[b]reak 0            Remove all breakpoints.\"));\nldbLog(sdsnew(\"[t]race              Show a backtrace.\"));\nldbLog(sdsnew(\"[e]eval <code>       Execute some Lua code (in a different callframe).\"));\nldbLog(sdsnew(\"[r]edis <cmd>        Execute a Redis command.\"));\nldbLog(sdsnew(\"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\"));\nldbLog(sdsnew(\"                     Specifying zero as <len> means unlimited.\"));\nldbLog(sdsnew(\"[a]bort              Stop the execution of the script. In sync\"));\nldbLog(sdsnew(\"                     mode dataset changes will be retained.\"));\nldbLog(sdsnew(\"\"));\nldbLog(sdsnew(\"Debugger functions you can call from Lua scripts:\"));\nldbLog(sdsnew(\"redis.debug()        Produce logs in the debugger console.\"));\nldbLog(sdsnew(\"redis.breakpoint()   Stop execution like if there was a breakpoint in the\"));\nldbLog(sdsnew(\"                     next line of code.\"));\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"s\") || !strcasecmp(VAR_1[0],\"step\") ||\n                   !strcasecmp(VAR_1[0],\"n\") || !strcasecmp(VAR_1[0],\"next\")) {\n            VAR_5.step = 1;\n            break;\n        } else if (!strcasecmp(VAR_1[0],\"c\") || !strcasecmp(VAR_1[0],\"continue\")){\n            break;\n        } else if (!strcasecmp(VAR_1[0],\"t\") || !strcasecmp(VAR_1[0],\"trace\")) {\n            ldbTrace(VAR_0);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"m\") || !strcasecmp(VAR_1[0],\"maxlen\")) {\n            ldbMaxlen(VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"b\") || !strcasecmp(VAR_1[0],\"break\")) {\n            ldbBreak(VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"e\") || !strcasecmp(VAR_1[0],\"eval\")) {\n            ldbEval(VAR_0,VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"a\") || !strcasecmp(VAR_1[0],\"abort\")) {\n            lua_pushstring(VAR_0, \"script aborted for user request\");\n            lua_error(VAR_0);\n        } else if (VAR_2 > 1 &&\n                   (!strcasecmp(VAR_1[0],\"r\") || !strcasecmp(VAR_1[0],\"redis\"))) {\n            ldbRedis(VAR_0,VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if ((!strcasecmp(VAR_1[0],\"p\") || !strcasecmp(VAR_1[0],\"print\"))) {\n            if (VAR_2 == 2)\n                ldbPrint(VAR_0,VAR_1[1]);\n            else\n                ldbPrintAll(VAR_0);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"l\") || !strcasecmp(VAR_1[0],\"list\")){\n            int VAR_7 = VAR_5.currentline, VAR_8 = 5;\n            if (VAR_2 > 1) {\n                int VAR_9 = atoi(VAR_1[1]);\n                if (VAR_9 > 0) VAR_7 = VAR_9;\n            }\n            if (VAR_2 > 2) VAR_8 = atoi(VAR_1[2]);\n            ldbList(VAR_7,VAR_8);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"w\") || !strcasecmp(VAR_1[0],\"whole\")){\n            ldbList(1,1000000);\n            ldbSendLogs();\n        } else {\n            ldbLog(sdsnew(\"<error> Unknown Redis Lua debugger command or \"\n                          \"wrong number of arguments.\"));\n            ldbSendLogs();\n        }\n\n        /* COMMENT_6 */\n        sdsfreesplitres(VAR_1,VAR_2);\n    }\n\n    /* COMMENT_7 */\n    sdsfreesplitres(VAR_1,VAR_2);\n    return VAR_10;\n}",
  "func_graph_path_before": "redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/before/1.json",
  "func": "int ldbRepl(lua_State *lua) {\n    sds *argv;\n    int argc;\n    char* err = NULL;\n\n    /* We continue processing commands until a command that should return\n     * to the Lua interpreter is found. */\n    while(1) {\n        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {\n            char buf[1024];\n            if (err) {\n                lua_pushstring(lua, err);\n                lua_error(lua);\n            }\n            int nread = connRead(ldb.conn,buf,sizeof(buf));\n            if (nread <= 0) {\n                /* Make sure the script runs without user input since the\n                 * client is no longer connected. */\n                ldb.step = 0;\n                ldb.bpcount = 0;\n                return C_ERR;\n            }\n            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);\n            /* after 1M we will exit with an error\n             * so that the client will not blow the memory\n             */\n            if (sdslen(ldb.cbuf) > 1<<20) {\n                sdsfree(ldb.cbuf);\n                ldb.cbuf = sdsempty();\n                lua_pushstring(lua, \"max client buffer reached\");\n                lua_error(lua);\n            }\n        }\n\n        /* Flush the old buffer. */\n        sdsfree(ldb.cbuf);\n        ldb.cbuf = sdsempty();\n\n        /* Execute the command. */\n        if (!strcasecmp(argv[0],\"h\") || !strcasecmp(argv[0],\"help\")) {\nldbLog(sdsnew(\"Redis Lua debugger help:\"));\nldbLog(sdsnew(\"[h]elp               Show this help.\"));\nldbLog(sdsnew(\"[s]tep               Run current line and stop again.\"));\nldbLog(sdsnew(\"[n]ext               Alias for step.\"));\nldbLog(sdsnew(\"[c]continue          Run till next breakpoint.\"));\nldbLog(sdsnew(\"[l]list              List source code around current line.\"));\nldbLog(sdsnew(\"[l]list [line]       List source code around [line].\"));\nldbLog(sdsnew(\"                     line = 0 means: current position.\"));\nldbLog(sdsnew(\"[l]list [line] [ctx] In this form [ctx] specifies how many lines\"));\nldbLog(sdsnew(\"                     to show before/after [line].\"));\nldbLog(sdsnew(\"[w]hole              List all source code. Alias for 'list 1 1000000'.\"));\nldbLog(sdsnew(\"[p]rint              Show all the local variables.\"));\nldbLog(sdsnew(\"[p]rint <var>        Show the value of the specified variable.\"));\nldbLog(sdsnew(\"                     Can also show global vars KEYS and ARGV.\"));\nldbLog(sdsnew(\"[b]reak              Show all breakpoints.\"));\nldbLog(sdsnew(\"[b]reak <line>       Add a breakpoint to the specified line.\"));\nldbLog(sdsnew(\"[b]reak -<line>      Remove breakpoint from the specified line.\"));\nldbLog(sdsnew(\"[b]reak 0            Remove all breakpoints.\"));\nldbLog(sdsnew(\"[t]race              Show a backtrace.\"));\nldbLog(sdsnew(\"[e]eval <code>       Execute some Lua code (in a different callframe).\"));\nldbLog(sdsnew(\"[r]edis <cmd>        Execute a Redis command.\"));\nldbLog(sdsnew(\"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\"));\nldbLog(sdsnew(\"                     Specifying zero as <len> means unlimited.\"));\nldbLog(sdsnew(\"[a]bort              Stop the execution of the script. In sync\"));\nldbLog(sdsnew(\"                     mode dataset changes will be retained.\"));\nldbLog(sdsnew(\"\"));\nldbLog(sdsnew(\"Debugger functions you can call from Lua scripts:\"));\nldbLog(sdsnew(\"redis.debug()        Produce logs in the debugger console.\"));\nldbLog(sdsnew(\"redis.breakpoint()   Stop execution like if there was a breakpoint in the\"));\nldbLog(sdsnew(\"                     next line of code.\"));\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"s\") || !strcasecmp(argv[0],\"step\") ||\n                   !strcasecmp(argv[0],\"n\") || !strcasecmp(argv[0],\"next\")) {\n            ldb.step = 1;\n            break;\n        } else if (!strcasecmp(argv[0],\"c\") || !strcasecmp(argv[0],\"continue\")){\n            break;\n        } else if (!strcasecmp(argv[0],\"t\") || !strcasecmp(argv[0],\"trace\")) {\n            ldbTrace(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"m\") || !strcasecmp(argv[0],\"maxlen\")) {\n            ldbMaxlen(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"b\") || !strcasecmp(argv[0],\"break\")) {\n            ldbBreak(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"e\") || !strcasecmp(argv[0],\"eval\")) {\n            ldbEval(lua,argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"a\") || !strcasecmp(argv[0],\"abort\")) {\n            lua_pushstring(lua, \"script aborted for user request\");\n            lua_error(lua);\n        } else if (argc > 1 &&\n                   (!strcasecmp(argv[0],\"r\") || !strcasecmp(argv[0],\"redis\"))) {\n            ldbRedis(lua,argv,argc);\n            ldbSendLogs();\n        } else if ((!strcasecmp(argv[0],\"p\") || !strcasecmp(argv[0],\"print\"))) {\n            if (argc == 2)\n                ldbPrint(lua,argv[1]);\n            else\n                ldbPrintAll(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"l\") || !strcasecmp(argv[0],\"list\")){\n            int around = ldb.currentline, ctx = 5;\n            if (argc > 1) {\n                int num = atoi(argv[1]);\n                if (num > 0) around = num;\n            }\n            if (argc > 2) ctx = atoi(argv[2]);\n            ldbList(around,ctx);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"w\") || !strcasecmp(argv[0],\"whole\")){\n            ldbList(1,1000000);\n            ldbSendLogs();\n        } else {\n            ldbLog(sdsnew(\"<error> Unknown Redis Lua debugger command or \"\n                          \"wrong number of arguments.\"));\n            ldbSendLogs();\n        }\n\n        /* Free the command vector. */\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Free the current command argv if we break inside the while loop. */\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}",
  "abstract_func": "int ldbRepl(lua_State *VAR_0) {\n    sds *VAR_1;\n    int VAR_2;\n    char* VAR_3 = NULL;\n\n    /* COMMENT_0 */\n                                          \n    while(1) {\n        while((VAR_1 = ldbReplParseCommand(&VAR_2, &VAR_3)) == NULL) {\n            char VAR_4[1024];\n            if (VAR_3) {\n                lua_pushstring(VAR_0, VAR_3);\n                lua_error(VAR_0);\n            }\n            int VAR_5 = connRead(VAR_6.conn,VAR_4,sizeof(VAR_4));\n            if (VAR_5 <= 0) {\n                /* COMMENT_2 */\n                                                    \n                VAR_6.step = 0;\n                VAR_6.bpcount = 0;\n                return VAR_7;\n            }\n            VAR_6.cbuf = sdscatlen(VAR_6.cbuf,VAR_4,VAR_5);\n            /* COMMENT_4 */\n                                                          \n               \n            if (sdslen(VAR_6.cbuf) > 1<<20) {\n                sdsfree(VAR_6.cbuf);\n                VAR_6.cbuf = sdsempty();\n                lua_pushstring(VAR_0, \"max client buffer reached\");\n                lua_error(VAR_0);\n            }\n        }\n\n        /* COMMENT_7 */\n        sdsfree(VAR_6.cbuf);\n        VAR_6.cbuf = sdsempty();\n\n        /* COMMENT_8 */\n        if (!strcasecmp(VAR_1[0],\"h\") || !strcasecmp(VAR_1[0],\"help\")) {\nldbLog(sdsnew(\"Redis Lua debugger help:\"));\nldbLog(sdsnew(\"[h]elp               Show this help.\"));\nldbLog(sdsnew(\"[s]tep               Run current line and stop again.\"));\nldbLog(sdsnew(\"[n]ext               Alias for step.\"));\nldbLog(sdsnew(\"[c]continue          Run till next breakpoint.\"));\nldbLog(sdsnew(\"[l]list              List source code around current line.\"));\nldbLog(sdsnew(\"[l]list [line]       List source code around [line].\"));\nldbLog(sdsnew(\"                     line = 0 means: current position.\"));\nldbLog(sdsnew(\"[l]list [line] [ctx] In this form [ctx] specifies how many lines\"));\nldbLog(sdsnew(\"                     to show before/after [line].\"));\nldbLog(sdsnew(\"[w]hole              List all source code. Alias for 'list 1 1000000'.\"));\nldbLog(sdsnew(\"[p]rint              Show all the local variables.\"));\nldbLog(sdsnew(\"[p]rint <var>        Show the value of the specified variable.\"));\nldbLog(sdsnew(\"                     Can also show global vars KEYS and ARGV.\"));\nldbLog(sdsnew(\"[b]reak              Show all breakpoints.\"));\nldbLog(sdsnew(\"[b]reak <line>       Add a breakpoint to the specified line.\"));\nldbLog(sdsnew(\"[b]reak -<line>      Remove breakpoint from the specified line.\"));\nldbLog(sdsnew(\"[b]reak 0            Remove all breakpoints.\"));\nldbLog(sdsnew(\"[t]race              Show a backtrace.\"));\nldbLog(sdsnew(\"[e]eval <code>       Execute some Lua code (in a different callframe).\"));\nldbLog(sdsnew(\"[r]edis <cmd>        Execute a Redis command.\"));\nldbLog(sdsnew(\"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\"));\nldbLog(sdsnew(\"                     Specifying zero as <len> means unlimited.\"));\nldbLog(sdsnew(\"[a]bort              Stop the execution of the script. In sync\"));\nldbLog(sdsnew(\"                     mode dataset changes will be retained.\"));\nldbLog(sdsnew(\"\"));\nldbLog(sdsnew(\"Debugger functions you can call from Lua scripts:\"));\nldbLog(sdsnew(\"redis.debug()        Produce logs in the debugger console.\"));\nldbLog(sdsnew(\"redis.breakpoint()   Stop execution like if there was a breakpoint in the\"));\nldbLog(sdsnew(\"                     next line of code.\"));\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"s\") || !strcasecmp(VAR_1[0],\"step\") ||\n                   !strcasecmp(VAR_1[0],\"n\") || !strcasecmp(VAR_1[0],\"next\")) {\n            VAR_6.step = 1;\n            break;\n        } else if (!strcasecmp(VAR_1[0],\"c\") || !strcasecmp(VAR_1[0],\"continue\")){\n            break;\n        } else if (!strcasecmp(VAR_1[0],\"t\") || !strcasecmp(VAR_1[0],\"trace\")) {\n            ldbTrace(VAR_0);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"m\") || !strcasecmp(VAR_1[0],\"maxlen\")) {\n            ldbMaxlen(VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"b\") || !strcasecmp(VAR_1[0],\"break\")) {\n            ldbBreak(VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"e\") || !strcasecmp(VAR_1[0],\"eval\")) {\n            ldbEval(VAR_0,VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"a\") || !strcasecmp(VAR_1[0],\"abort\")) {\n            lua_pushstring(VAR_0, \"script aborted for user request\");\n            lua_error(VAR_0);\n        } else if (VAR_2 > 1 &&\n                   (!strcasecmp(VAR_1[0],\"r\") || !strcasecmp(VAR_1[0],\"redis\"))) {\n            ldbRedis(VAR_0,VAR_1,VAR_2);\n            ldbSendLogs();\n        } else if ((!strcasecmp(VAR_1[0],\"p\") || !strcasecmp(VAR_1[0],\"print\"))) {\n            if (VAR_2 == 2)\n                ldbPrint(VAR_0,VAR_1[1]);\n            else\n                ldbPrintAll(VAR_0);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"l\") || !strcasecmp(VAR_1[0],\"list\")){\n            int VAR_8 = VAR_6.currentline, VAR_9 = 5;\n            if (VAR_2 > 1) {\n                int VAR_10 = atoi(VAR_1[1]);\n                if (VAR_10 > 0) VAR_8 = VAR_10;\n            }\n            if (VAR_2 > 2) VAR_9 = atoi(VAR_1[2]);\n            ldbList(VAR_8,VAR_9);\n            ldbSendLogs();\n        } else if (!strcasecmp(VAR_1[0],\"w\") || !strcasecmp(VAR_1[0],\"whole\")){\n            ldbList(1,1000000);\n            ldbSendLogs();\n        } else {\n            ldbLog(sdsnew(\"<error> Unknown Redis Lua debugger command or \"\n                          \"wrong number of arguments.\"));\n            ldbSendLogs();\n        }\n\n        /* COMMENT_9 */\n        sdsfreesplitres(VAR_1,VAR_2);\n    }\n\n    /* COMMENT_10 */\n    sdsfreesplitres(VAR_1,VAR_2);\n    return VAR_11;\n}",
  "func_graph_path": "redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,17 @@\n int ldbRepl(lua_State *lua) {\n     sds *argv;\n     int argc;\n+    char* err = NULL;\n \n     /* We continue processing commands until a command that should return\n      * to the Lua interpreter is found. */\n     while(1) {\n-        while((argv = ldbReplParseCommand(&argc)) == NULL) {\n+        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {\n             char buf[1024];\n+            if (err) {\n+                lua_pushstring(lua, err);\n+                lua_error(lua);\n+            }\n             int nread = connRead(ldb.conn,buf,sizeof(buf));\n             if (nread <= 0) {\n                 /* Make sure the script runs without user input since the\n@@ -16,6 +21,15 @@\n                 return C_ERR;\n             }\n             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);\n+            /* after 1M we will exit with an error\n+             * so that the client will not blow the memory\n+             */\n+            if (sdslen(ldb.cbuf) > 1<<20) {\n+                sdsfree(ldb.cbuf);\n+                ldb.cbuf = sdsempty();\n+                lua_pushstring(lua, \"max client buffer reached\");\n+                lua_error(lua);\n+            }\n         }\n \n         /* Flush the old buffer. */",
  "diff_line_info": {
    "deleted_lines": [
      "        while((argv = ldbReplParseCommand(&argc)) == NULL) {"
    ],
    "added_lines": [
      "    char* err = NULL;",
      "        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
      "            if (err) {",
      "                lua_pushstring(lua, err);",
      "                lua_error(lua);",
      "            }",
      "            /* after 1M we will exit with an error",
      "             * so that the client will not blow the memory",
      "             */",
      "            if (sdslen(ldb.cbuf) > 1<<20) {",
      "                sdsfree(ldb.cbuf);",
      "                ldb.cbuf = sdsempty();",
      "                lua_pushstring(lua, \"max client buffer reached\");",
      "                lua_error(lua);",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}