{
  "cve_id": "CVE-2023-31129",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "fix rs_input missing NULL pointer check",
  "commit_hash": "c23cf7a16289afe716ae023c664ded16e88efd2d",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/c23cf7a16289afe716ae023c664ded16e88efd2d",
  "file_path": "os/net/ipv6/uip-nd6.c",
  "func_name": "rs_input",
  "func_before": "static void\nrs_input(void)\n{\n\n  LOG_INFO(\"Received RS from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++uip_stat.nd6.recv);\n\n\n#if UIP_CONF_IPV6_CHECKS\n  /*\n   * Check hop limit / icmp code\n   * target address must not be multicast\n   * if the NA is solicited, dest must not be multicast\n   */\n  if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) || (UIP_ICMP_BUF->icode != 0)) {\n    LOG_ERR(\"RS received is bad\\n\");\n    goto discard;\n  }\n#endif /*UIP_CONF_IPV6_CHECKS */\n\n  /* Only valid option is Source Link-Layer Address option any thing\n     else is discarded */\n  nd6_opt_offset = UIP_ND6_RS_LEN;\n  nd6_opt_llao = NULL;\n\n  while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) {\n#if UIP_CONF_IPV6_CHECKS\n    if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    }\n#endif /*UIP_CONF_IPV6_CHECKS */\n    switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {\n    case UIP_ND6_OPT_SLLAO:\n      nd6_opt_llao = (uint8_t *)ND6_OPT_HDR_BUF(nd6_opt_offset);\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in RS\\n\");\n      break;\n    }\n    nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3);\n  }\n  /* Options processing: only SLLAO */\n  if(nd6_opt_llao != NULL) {\n#if UIP_CONF_IPV6_CHECKS\n    if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    } else {\n#endif /*UIP_CONF_IPV6_CHECKS */\n      uip_lladdr_t lladdr_aligned;\n      extract_lladdr_from_llao_aligned(&lladdr_aligned);\n      if((nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr)) == NULL) {\n        /* we need to add the neighbor */\n        uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,\n                        0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);\n      } else {\n        /* If LL address changed, set neighbor state to stale */\n        const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr);\n        if(lladdr == NULL) {\n          goto discard;\n        }\n        if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET],\n            lladdr, UIP_LLADDR_LEN) != 0) {\n          uip_ds6_nbr_t nbr_data;\n          nbr_data = *nbr;\n          uip_ds6_nbr_rm(nbr);\n          nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,\n                                0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);\n          nbr->reachable = nbr_data.reachable;\n          nbr->sendns = nbr_data.sendns;\n          nbr->nscount = nbr_data.nscount;\n        }\n        nbr->isrouter = 0;\n      }\n#if UIP_CONF_IPV6_CHECKS\n    }\n#endif /*UIP_CONF_IPV6_CHECKS */\n  }\n\n  /* Schedule a sollicited RA */\n  uip_ds6_send_ra_sollicited();\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "abstract_func_before": "static void\nrs_input(void)\n{\n\n  LOG_INFO(\"Received RS from \");\n  LOG_INFO_6ADDR(&VAR_0->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&VAR_0->destipaddr);\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++VAR_1.nd6.recv);\n\n\n#if VAR_2\n  /* COMMENT_0 */\n                                \n                                         \n                                                       \n     \n  if((VAR_0->ttl != VAR_3) || (VAR_4->icode != 0)) {\n    LOG_ERR(\"RS received is bad\\n\");\n    goto discard;\n  }\n#endif /* COMMENT_5 */\n\n  /* COMMENT_6 */\n                         \n  VAR_5 = VAR_6;\n  VAR_7 = NULL;\n\n  while(VAR_8 + VAR_5 < VAR_9) {\n#if VAR_2\n    if(ND6_OPT_HDR_BUF(VAR_5)->len == 0) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    }\n#endif /* COMMENT_5 */\n    switch (ND6_OPT_HDR_BUF(VAR_5)->type) {\n    case VAR_10:\n      VAR_7 = (uint8_t *)ND6_OPT_HDR_BUF(VAR_5);\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in RS\\n\");\n      break;\n    }\n    VAR_5 += (ND6_OPT_HDR_BUF(VAR_5)->len << 3);\n  }\n  /* COMMENT_8 */\n  if(VAR_7 != NULL) {\n#if VAR_2\n    if(uip_is_addr_unspecified(&VAR_0->srcipaddr)) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    } else {\n#endif/* COMMENT_9 */\n      uip_lladdr_t lladdr_aligned;\n      extract_lladdr_from_llao_aligned(&VAR_11);\n      if((VAR_12 = uip_ds6_nbr_lookup(&VAR_0->srcipaddr)) == NULL) {\n        /* COMMENT_10 */\n        uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,\n                        0, VAR_13, VAR_14, NULL);\n      } else {\n        /* COMMENT_11 */\n        const uip_lladdr_t *VAR_15 = uip_ds6_nbr_get_ll(VAR_12);\n        if(VAR_15 == NULL) {\n          goto discard;\n        }\n        if(memcmp(&VAR_7[VAR_16],\n            VAR_15, VAR_17) != 0) {\n          uip_ds6_nbr_t VAR_18;\n          VAR_18 = *VAR_12;\n          uip_ds6_nbr_rm(VAR_12);\n          VAR_12 = uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,\n                                0, VAR_13, VAR_14, NULL);\n          VAR_12->reachable = VAR_18.reachable;\n          VAR_12->sendns = VAR_18.sendns;\n          VAR_12->nscount = VAR_18.nscount;\n        }\n        VAR_12->isrouter = 0;\n      }\n#if VAR_2\n    }\n#endif /* COMMENT_5 */\n  }\n\n  /* COMMENT_12 */\n  uip_ds6_send_ra_sollicited();\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "func_graph_path_before": "contiki-ng/c23cf7a16289afe716ae023c664ded16e88efd2d/uip-nd6.c/vul/before/0.json",
  "func": "static void\nrs_input(void)\n{\n\n  LOG_INFO(\"Received RS from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++uip_stat.nd6.recv);\n\n\n#if UIP_CONF_IPV6_CHECKS\n  /*\n   * Check hop limit / icmp code\n   * target address must not be multicast\n   * if the NA is solicited, dest must not be multicast\n   */\n  if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) || (UIP_ICMP_BUF->icode != 0)) {\n    LOG_ERR(\"RS received is bad\\n\");\n    goto discard;\n  }\n#endif /*UIP_CONF_IPV6_CHECKS */\n\n  /* Only valid option is Source Link-Layer Address option any thing\n     else is discarded */\n  nd6_opt_offset = UIP_ND6_RS_LEN;\n  nd6_opt_llao = NULL;\n\n  while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) {\n#if UIP_CONF_IPV6_CHECKS\n    if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    }\n#endif /*UIP_CONF_IPV6_CHECKS */\n    switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {\n    case UIP_ND6_OPT_SLLAO:\n      nd6_opt_llao = (uint8_t *)ND6_OPT_HDR_BUF(nd6_opt_offset);\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in RS\\n\");\n      break;\n    }\n    nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3);\n  }\n  /* Options processing: only SLLAO */\n  if(nd6_opt_llao != NULL) {\n#if UIP_CONF_IPV6_CHECKS\n    if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    } else {\n#endif /*UIP_CONF_IPV6_CHECKS */\n      uip_lladdr_t lladdr_aligned;\n      extract_lladdr_from_llao_aligned(&lladdr_aligned);\n      if((nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr)) == NULL) {\n        /* we need to add the neighbor */\n        uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,\n                        0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);\n      } else {\n        /* If LL address changed, set neighbor state to stale */\n        const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr);\n        if(lladdr == NULL) {\n          goto discard;\n        }\n        if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET],\n            lladdr, UIP_LLADDR_LEN) != 0) {\n          uip_ds6_nbr_t nbr_data;\n          nbr_data = *nbr;\n          uip_ds6_nbr_rm(nbr);\n          nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,\n                                0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);\n          if(nbr == NULL) {\n            goto discard;\n          }\n          nbr->reachable = nbr_data.reachable;\n          nbr->sendns = nbr_data.sendns;\n          nbr->nscount = nbr_data.nscount;\n        }\n        nbr->isrouter = 0;\n      }\n#if UIP_CONF_IPV6_CHECKS\n    }\n#endif /*UIP_CONF_IPV6_CHECKS */\n  }\n\n  /* Schedule a sollicited RA */\n  uip_ds6_send_ra_sollicited();\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "abstract_func": "static void\nrs_input(void)\n{\n\n  LOG_INFO(\"Received RS from \");\n  LOG_INFO_6ADDR(&VAR_0->srcipaddr);\n  LOG_INFO_(\" to \");\n  LOG_INFO_6ADDR(&VAR_0->destipaddr);\n  LOG_INFO_(\"\\n\");\n  UIP_STAT(++VAR_1.nd6.recv);\n\n\n#if VAR_2\n  /* COMMENT_0 */\n                                \n                                         \n                                                       \n     \n  if((VAR_0->ttl != VAR_3) || (VAR_4->icode != 0)) {\n    LOG_ERR(\"RS received is bad\\n\");\n    goto discard;\n  }\n#endif /* COMMENT_5 */\n\n  /* COMMENT_6 */\n                         \n  VAR_5 = VAR_6;\n  VAR_7 = NULL;\n\n  while(VAR_8 + VAR_5 < VAR_9) {\n#if VAR_2\n    if(ND6_OPT_HDR_BUF(VAR_5)->len == 0) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    }\n#endif /* COMMENT_5 */\n    switch (ND6_OPT_HDR_BUF(VAR_5)->type) {\n    case VAR_10:\n      VAR_7 = (uint8_t *)ND6_OPT_HDR_BUF(VAR_5);\n      break;\n    default:\n      LOG_WARN(\"ND option not supported in RS\\n\");\n      break;\n    }\n    VAR_5 += (ND6_OPT_HDR_BUF(VAR_5)->len << 3);\n  }\n  /* COMMENT_8 */\n  if(VAR_7 != NULL) {\n#if VAR_2\n    if(uip_is_addr_unspecified(&VAR_0->srcipaddr)) {\n      LOG_ERR(\"RS received is bad\\n\");\n      goto discard;\n    } else {\n#endif/* COMMENT_9 */\n      uip_lladdr_t lladdr_aligned;\n      extract_lladdr_from_llao_aligned(&VAR_11);\n      if((VAR_12 = uip_ds6_nbr_lookup(&VAR_0->srcipaddr)) == NULL) {\n        /* COMMENT_10 */\n        uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,\n                        0, VAR_13, VAR_14, NULL);\n      } else {\n        /* COMMENT_11 */\n        const uip_lladdr_t *VAR_15 = uip_ds6_nbr_get_ll(VAR_12);\n        if(VAR_15 == NULL) {\n          goto discard;\n        }\n        if(memcmp(&VAR_7[VAR_16],\n            VAR_15, VAR_17) != 0) {\n          uip_ds6_nbr_t VAR_18;\n          VAR_18 = *VAR_12;\n          uip_ds6_nbr_rm(VAR_12);\n          VAR_12 = uip_ds6_nbr_add(&VAR_0->srcipaddr, &VAR_11,\n                                0, VAR_13, VAR_14, NULL);\n          if(VAR_12 == NULL) {\n            goto discard;\n          }\n          VAR_12->reachable = VAR_18.reachable;\n          VAR_12->sendns = VAR_18.sendns;\n          VAR_12->nscount = VAR_18.nscount;\n        }\n        VAR_12->isrouter = 0;\n      }\n#if VAR_2\n    }\n#endif /* COMMENT_5 */\n  }\n\n  /* COMMENT_12 */\n  uip_ds6_send_ra_sollicited();\n\ndiscard:\n  uipbuf_clear();\n  return;\n}",
  "func_graph_path": "contiki-ng/c23cf7a16289afe716ae023c664ded16e88efd2d/uip-nd6.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -71,6 +71,9 @@\n           uip_ds6_nbr_rm(nbr);\n           nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,\n                                 0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL);\n+          if(nbr == NULL) {\n+            goto discard;\n+          }\n           nbr->reachable = nbr_data.reachable;\n           nbr->sendns = nbr_data.sendns;\n           nbr->nscount = nbr_data.nscount;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "          if(nbr == NULL) {",
      "            goto discard;",
      "          }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/2271",
  "description": {
    "pr_info": {
      "title": "fix rs_input missing NULL pointer check",
      "number": 2271
    },
    "comment": [
      "Add a NULL pointer check to the return value of `uip_ds6_nbr_add` in the SLLAO link-layer address change case of Router Solicitation messages."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a missing NULL pointer check, preventing potential crashes or exploitations by ensuring `nbr` isn't NULL before accessing it. Therefore, it's a security vulnerability fix with high confidence.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}