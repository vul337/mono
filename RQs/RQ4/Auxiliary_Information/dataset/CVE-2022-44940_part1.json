{
  "cve_id": "CVE-2022-44940",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "NixOS/patchelf",
  "commit_msg": "Out-of-bounds read exists in the function modifyRPath",
  "commit_hash": "96c8422e374064c3407e73e8b1e4995f95e0a9e0",
  "git_url": "https://github.com/NixOS/patchelf/commit/96c8422e374064c3407e73e8b1e4995f95e0a9e0",
  "file_path": "src/patchelf.cc",
  "func_name": "ElfFile<ElfFileParamNames>::modifyRPath",
  "func_before": "void ElfFile<ElfFileParamNames>::modifyRPath(RPathOp op,\n    const std::vector<std::string> & allowedRpathPrefixes, std::string newRPath)\n{\n    auto shdrDynamic = findSectionHeader(\".dynamic\");\n\n    if (rdi(shdrDynamic.sh_type) == SHT_NOBITS) {\n            debug(\"no dynamic section\\n\");\n            return;\n    }\n\n    /* !!! We assume that the virtual address in the DT_STRTAB entry\n       of the dynamic section corresponds to the .dynstr section. */\n    auto shdrDynStr = findSectionHeader(\".dynstr\");\n    char * strTab = (char *) fileContents->data() + rdi(shdrDynStr.sh_offset);\n\n\n    /* Walk through the dynamic section, look for the RPATH/RUNPATH\n       entry.\n\n       According to the ld.so docs, DT_RPATH is obsolete, we should\n       use DT_RUNPATH.  DT_RUNPATH has two advantages: it can be\n       overriden by LD_LIBRARY_PATH, and it's scoped (the DT_RUNPATH\n       for an executable or library doesn't affect the search path for\n       libraries used by it).  DT_RPATH is ignored if DT_RUNPATH is\n       present.  The binutils 'ld' still generates only DT_RPATH,\n       unless you use its '--enable-new-dtag' option, in which case it\n       generates a DT_RPATH and DT_RUNPATH pointing at the same\n       string. */\n    std::vector<std::string> neededLibs;\n    auto dyn = (Elf_Dyn *)(fileContents->data() + rdi(shdrDynamic.sh_offset));\n    Elf_Dyn *dynRPath = nullptr, *dynRunPath = nullptr;\n    char * rpath = nullptr;\n    for ( ; rdi(dyn->d_tag) != DT_NULL; dyn++) {\n        if (rdi(dyn->d_tag) == DT_RPATH) {\n            dynRPath = dyn;\n            /* Only use DT_RPATH if there is no DT_RUNPATH. */\n            if (!dynRunPath)\n                rpath = strTab + rdi(dyn->d_un.d_val);\n        }\n        else if (rdi(dyn->d_tag) == DT_RUNPATH) {\n            dynRunPath = dyn;\n            rpath = strTab + rdi(dyn->d_un.d_val);\n        }\n        else if (rdi(dyn->d_tag) == DT_NEEDED)\n            neededLibs.push_back(std::string(strTab + rdi(dyn->d_un.d_val)));\n    }\n\n    switch (op) {\n        case rpPrint: {\n            printf(\"%s\\n\", rpath ? rpath : \"\");\n            return;\n        };\n        case rpRemove: {\n            if (!rpath) {\n                debug(\"no RPATH to delete\\n\");\n                return;\n            }\n            removeRPath(shdrDynamic);\n            return;\n        }\n        case rpShrink: {\n            if (!rpath) {\n                debug(\"no RPATH to shrink\\n\");\n                return;\n            ;}\n            newRPath = shrinkRPath(rpath, neededLibs, allowedRpathPrefixes);\n            break;\n        }\n        case rpAdd: {\n            auto temp = std::string(rpath ? rpath : \"\");\n            appendRPath(temp, newRPath);\n            newRPath = temp;\n            break;\n        }\n        case rpSet: { break; } /* new rpath was provied as input to this function */\n    }\n\n    if (!forceRPath && dynRPath && !dynRunPath) { /* convert DT_RPATH to DT_RUNPATH */\n        wri(dynRPath->d_tag, DT_RUNPATH);\n        dynRunPath = dynRPath;\n        dynRPath = nullptr;\n        changed = true;\n    } else if (forceRPath && dynRunPath) { /* convert DT_RUNPATH to DT_RPATH */\n        wri(dynRunPath->d_tag, DT_RPATH);\n        dynRPath = dynRunPath;\n        dynRunPath = nullptr;\n        changed = true;\n    }\n\n    if (rpath && rpath == newRPath) {\n        return;\n    }\n    changed = true;\n\n    /* Zero out the previous rpath to prevent retained dependencies in\n       Nix. */\n    size_t rpathSize = 0;\n    if (rpath) {\n        rpathSize = strlen(rpath);\n        memset(rpath, 'X', rpathSize);\n    }\n\n    debug(\"new rpath is '%s'\\n\", newRPath.c_str());\n\n\n    if (newRPath.size() <= rpathSize) {\n        if (rpath) memcpy(rpath, newRPath.c_str(), newRPath.size() + 1);\n        return;\n    }\n\n    /* Grow the .dynstr section to make room for the new RPATH. */\n    debug(\"rpath is too long, resizing...\\n\");\n\n    std::string & newDynStr = replaceSection(\".dynstr\",\n        rdi(shdrDynStr.sh_size) + newRPath.size() + 1);\n    setSubstr(newDynStr, rdi(shdrDynStr.sh_size), newRPath + '\\0');\n\n    /* Update the DT_RUNPATH and DT_RPATH entries. */\n    if (dynRunPath || dynRPath) {\n        if (dynRunPath) dynRunPath->d_un.d_val = shdrDynStr.sh_size;\n        if (dynRPath) dynRPath->d_un.d_val = shdrDynStr.sh_size;\n    }\n\n    else {\n        /* There is no DT_RUNPATH entry in the .dynamic section, so we\n           have to grow the .dynamic section. */\n        std::string & newDynamic = replaceSection(\".dynamic\",\n            rdi(shdrDynamic.sh_size) + sizeof(Elf_Dyn));\n\n        unsigned int idx = 0;\n        for ( ; rdi(((Elf_Dyn *) newDynamic.c_str())[idx].d_tag) != DT_NULL; idx++) ;\n        debug(\"DT_NULL index is %d\\n\", idx);\n\n        /* Shift all entries down by one. */\n        setSubstr(newDynamic, sizeof(Elf_Dyn),\n            std::string(newDynamic, 0, sizeof(Elf_Dyn) * (idx + 1)));\n\n        /* Add the DT_RUNPATH entry at the top. */\n        Elf_Dyn newDyn;\n        wri(newDyn.d_tag, forceRPath ? DT_RPATH : DT_RUNPATH);\n        newDyn.d_un.d_val = shdrDynStr.sh_size;\n        setSubstr(newDynamic, 0, std::string((char *) &newDyn, sizeof(Elf_Dyn)));\n    }\n    this->rewriteSections();\n}",
  "abstract_func_before": "void ElfFile<ElfFileParamNames>::modifyRPath(RPathOp VAR_0,\n    const std::vector<std::string> & VAR_1, std::string VAR_2)\n{\n    auto VAR_3 = findSectionHeader(\".dynamic\");\n\n    if (rdi(VAR_3.sh_type) == VAR_4) {\n            debug(\"no dynamic section\\n\");\n            return;\n    }\n\n    /* COMMENT_0 */\n                                                                    \n    auto VAR_5 = findSectionHeader(\".dynstr\");\n    char * VAR_6 = (char *) VAR_7->data() + rdi(VAR_5.sh_offset);\n\n\n    /* COMMENT_2 */\n             \n\n                                                                   \n                                                                \n                                                                    \n                                                                      \n                                                                   \n                                                                 \n                                                                      \n                                                               \n                 \n    std::vector<std::string> VAR_8;\n    auto VAR_9 = (Elf_Dyn *)(VAR_7->data() + rdi(VAR_3.sh_offset));\n    Elf_Dyn *VAR_10 = nullptr, *VAR_11 = nullptr;\n    char * VAR_12 = nullptr;\n    for ( ; rdi(VAR_9->d_tag) != VAR_13; VAR_9++) {\n        if (rdi(VAR_9->d_tag) == VAR_14) {\n            VAR_10 = VAR_9;\n            /* COMMENT_14 */\n            if (!VAR_11)\n                VAR_12 = VAR_6 + rdi(VAR_9->d_un.d_val);\n        }\n        else if (rdi(VAR_9->d_tag) == VAR_15) {\n            VAR_11 = VAR_9;\n            VAR_12 = VAR_6 + rdi(VAR_9->d_un.d_val);\n        }\n        else if (rdi(VAR_9->d_tag) == VAR_16)\n            VAR_8.push_back(std::string(VAR_6 + rdi(VAR_9->d_un.d_val)));\n    }\n\n    switch (VAR_0) {\n        case VAR_17: {\n            printf(\"%s\\n\", VAR_12 ? VAR_12 : \"\");\n            return;\n        };\n        case VAR_18: {\n            if (!VAR_12) {\n                debug(\"no RPATH to delete\\n\");\n                return;\n            }\n            removeRPath(VAR_3);\n            return;\n        }\n        case VAR_19: {\n            if (!VAR_12) {\n                debug(\"no RPATH to shrink\\n\");\n                return;\n            ;}\n            VAR_2 = shrinkRPath(VAR_12, VAR_8, VAR_1);\n            break;\n        }\n        case VAR_20: {\n            auto VAR_21 = std::string(VAR_12 ? VAR_12 : \"\");\n            appendRPath(VAR_21, VAR_2);\n            VAR_2 = VAR_21;\n            break;\n        }\n        case VAR_22: { break; } /* COMMENT_15 */\n    }\n\n    if (!VAR_23 && VAR_10 && !VAR_11) { /* COMMENT_16 */\n        wri(VAR_10->d_tag, VAR_15);\n        VAR_11 = VAR_10;\n        VAR_10 = nullptr;\n        VAR_24 = true;\n    } else if (VAR_23 && VAR_11) { /* COMMENT_17 */\n        wri(VAR_11->d_tag, VAR_14);\n        VAR_10 = VAR_11;\n        VAR_11 = nullptr;\n        VAR_24 = true;\n    }\n\n    if (VAR_12 && VAR_12 == VAR_2) {\n        return;\n    }\n    VAR_24 = true;\n\n    /* COMMENT_18 */\n              \n    size_t VAR_25 = 0;\n    if (VAR_12) {\n        VAR_25 = strlen(VAR_12);\n        memset(VAR_12, 'X', VAR_25);\n    }\n\n    debug(\"new rpath is '%s'\\n\", VAR_2.c_str());\n\n\n    if (VAR_2.size() <= VAR_25) {\n        if (VAR_12) memcpy(VAR_12, VAR_2.c_str(), VAR_2.size() + 1);\n        return;\n    }\n\n    /* COMMENT_20 */\n    debug(\"rpath is too long, resizing...\\n\");\n\n    std::string & VAR_26 = replaceSection(\".dynstr\",\n        rdi(VAR_5.sh_size) + VAR_2.size() + 1);\n    setSubstr(VAR_26, rdi(VAR_5.sh_size), VAR_2 + '\\0');\n\n    /* COMMENT_21 */\n    if (VAR_11 || VAR_10) {\n        if (VAR_11) VAR_11->d_un.d_val = VAR_5.sh_size;\n        if (VAR_10) VAR_10->d_un.d_val = VAR_5.sh_size;\n    }\n\n    else {\n        /* COMMENT_22 */\n                                                \n        std::string & VAR_27 = replaceSection(\".dynamic\",\n            rdi(VAR_3.sh_size) + sizeof(Elf_Dyn));\n\n        unsigned int VAR_28 = 0;\n        for ( ; rdi(((Elf_Dyn *) VAR_27.c_str())[VAR_28].d_tag) != VAR_13; VAR_28++) ;\n        debug(\"DT_NULL index is %d\\n\", VAR_28);\n\n        /* COMMENT_24 */\n        setSubstr(VAR_27, sizeof(Elf_Dyn),\n            std::string(VAR_27, 0, sizeof(Elf_Dyn) * (VAR_28 + 1)));\n\n        /* COMMENT_25 */\n        Elf_Dyn VAR_29;\n        wri(VAR_29.d_tag, VAR_23 ? VAR_14 : VAR_15);\n        VAR_29.d_un.d_val = VAR_5.sh_size;\n        setSubstr(VAR_27, 0, std::string((char *) &VAR_29, sizeof(Elf_Dyn)));\n    }\n    this->rewriteSections();\n}",
  "func_graph_path_before": "NixOS/patchelf/96c8422e374064c3407e73e8b1e4995f95e0a9e0/patchelf.cc/vul/before/0.json",
  "func": "void ElfFile<ElfFileParamNames>::modifyRPath(RPathOp op,\n    const std::vector<std::string> & allowedRpathPrefixes, std::string newRPath)\n{\n    auto shdrDynamic = findSectionHeader(\".dynamic\");\n\n    if (rdi(shdrDynamic.sh_type) == SHT_NOBITS) {\n            debug(\"no dynamic section\\n\");\n            return;\n    }\n\n    /* !!! We assume that the virtual address in the DT_STRTAB entry\n       of the dynamic section corresponds to the .dynstr section. */\n    auto shdrDynStr = findSectionHeader(\".dynstr\");\n    char * strTab = (char *) fileContents->data() + rdi(shdrDynStr.sh_offset);\n\n\n    /* Walk through the dynamic section, look for the RPATH/RUNPATH\n       entry.\n\n       According to the ld.so docs, DT_RPATH is obsolete, we should\n       use DT_RUNPATH.  DT_RUNPATH has two advantages: it can be\n       overriden by LD_LIBRARY_PATH, and it's scoped (the DT_RUNPATH\n       for an executable or library doesn't affect the search path for\n       libraries used by it).  DT_RPATH is ignored if DT_RUNPATH is\n       present.  The binutils 'ld' still generates only DT_RPATH,\n       unless you use its '--enable-new-dtag' option, in which case it\n       generates a DT_RPATH and DT_RUNPATH pointing at the same\n       string. */\n    std::vector<std::string> neededLibs;\n    auto dyn = (Elf_Dyn *)(fileContents->data() + rdi(shdrDynamic.sh_offset));\n    checkPointer(fileContents, dyn, sizeof(*dyn));\n    Elf_Dyn *dynRPath = nullptr, *dynRunPath = nullptr;\n    char * rpath = nullptr;\n    for ( ; rdi(dyn->d_tag) != DT_NULL; dyn++) {\n        if (rdi(dyn->d_tag) == DT_RPATH) {\n            dynRPath = dyn;\n            /* Only use DT_RPATH if there is no DT_RUNPATH. */\n            if (!dynRunPath)\n                rpath = strTab + rdi(dyn->d_un.d_val);\n        }\n        else if (rdi(dyn->d_tag) == DT_RUNPATH) {\n            dynRunPath = dyn;\n            rpath = strTab + rdi(dyn->d_un.d_val);\n        }\n        else if (rdi(dyn->d_tag) == DT_NEEDED)\n            neededLibs.push_back(std::string(strTab + rdi(dyn->d_un.d_val)));\n    }\n\n    switch (op) {\n        case rpPrint: {\n            printf(\"%s\\n\", rpath ? rpath : \"\");\n            return;\n        };\n        case rpRemove: {\n            if (!rpath) {\n                debug(\"no RPATH to delete\\n\");\n                return;\n            }\n            removeRPath(shdrDynamic);\n            return;\n        }\n        case rpShrink: {\n            if (!rpath) {\n                debug(\"no RPATH to shrink\\n\");\n                return;\n            ;}\n            newRPath = shrinkRPath(rpath, neededLibs, allowedRpathPrefixes);\n            break;\n        }\n        case rpAdd: {\n            auto temp = std::string(rpath ? rpath : \"\");\n            appendRPath(temp, newRPath);\n            newRPath = temp;\n            break;\n        }\n        case rpSet: { break; } /* new rpath was provied as input to this function */\n    }\n\n    if (!forceRPath && dynRPath && !dynRunPath) { /* convert DT_RPATH to DT_RUNPATH */\n        wri(dynRPath->d_tag, DT_RUNPATH);\n        dynRunPath = dynRPath;\n        dynRPath = nullptr;\n        changed = true;\n    } else if (forceRPath && dynRunPath) { /* convert DT_RUNPATH to DT_RPATH */\n        wri(dynRunPath->d_tag, DT_RPATH);\n        dynRPath = dynRunPath;\n        dynRunPath = nullptr;\n        changed = true;\n    }\n\n    if (rpath && rpath == newRPath) {\n        return;\n    }\n    changed = true;\n\n    /* Zero out the previous rpath to prevent retained dependencies in\n       Nix. */\n    size_t rpathSize = 0;\n    if (rpath) {\n        rpathSize = strlen(rpath);\n        memset(rpath, 'X', rpathSize);\n    }\n\n    debug(\"new rpath is '%s'\\n\", newRPath.c_str());\n\n\n    if (newRPath.size() <= rpathSize) {\n        if (rpath) memcpy(rpath, newRPath.c_str(), newRPath.size() + 1);\n        return;\n    }\n\n    /* Grow the .dynstr section to make room for the new RPATH. */\n    debug(\"rpath is too long, resizing...\\n\");\n\n    std::string & newDynStr = replaceSection(\".dynstr\",\n        rdi(shdrDynStr.sh_size) + newRPath.size() + 1);\n    setSubstr(newDynStr, rdi(shdrDynStr.sh_size), newRPath + '\\0');\n\n    /* Update the DT_RUNPATH and DT_RPATH entries. */\n    if (dynRunPath || dynRPath) {\n        if (dynRunPath) dynRunPath->d_un.d_val = shdrDynStr.sh_size;\n        if (dynRPath) dynRPath->d_un.d_val = shdrDynStr.sh_size;\n    }\n\n    else {\n        /* There is no DT_RUNPATH entry in the .dynamic section, so we\n           have to grow the .dynamic section. */\n        std::string & newDynamic = replaceSection(\".dynamic\",\n            rdi(shdrDynamic.sh_size) + sizeof(Elf_Dyn));\n\n        unsigned int idx = 0;\n        for ( ; rdi(((Elf_Dyn *) newDynamic.c_str())[idx].d_tag) != DT_NULL; idx++) ;\n        debug(\"DT_NULL index is %d\\n\", idx);\n\n        /* Shift all entries down by one. */\n        setSubstr(newDynamic, sizeof(Elf_Dyn),\n            std::string(newDynamic, 0, sizeof(Elf_Dyn) * (idx + 1)));\n\n        /* Add the DT_RUNPATH entry at the top. */\n        Elf_Dyn newDyn;\n        wri(newDyn.d_tag, forceRPath ? DT_RPATH : DT_RUNPATH);\n        newDyn.d_un.d_val = shdrDynStr.sh_size;\n        setSubstr(newDynamic, 0, std::string((char *) &newDyn, sizeof(Elf_Dyn)));\n    }\n    this->rewriteSections();\n}",
  "abstract_func": "void ElfFile<ElfFileParamNames>::modifyRPath(RPathOp VAR_0,\n    const std::vector<std::string> & VAR_1, std::string VAR_2)\n{\n    auto VAR_3 = findSectionHeader(\".dynamic\");\n\n    if (rdi(VAR_3.sh_type) == VAR_4) {\n            debug(\"no dynamic section\\n\");\n            return;\n    }\n\n    /* COMMENT_0 */\n                                                                    \n    auto VAR_5 = findSectionHeader(\".dynstr\");\n    char * VAR_6 = (char *) VAR_7->data() + rdi(VAR_5.sh_offset);\n\n\n    /* COMMENT_2 */\n             \n\n                                                                   \n                                                                \n                                                                    \n                                                                      \n                                                                   \n                                                                 \n                                                                      \n                                                               \n                 \n    std::vector<std::string> VAR_8;\n    auto VAR_9 = (Elf_Dyn *)(VAR_7->data() + rdi(VAR_3.sh_offset));\n    checkPointer(VAR_7, VAR_9, sizeof(*VAR_9));\n    Elf_Dyn *VAR_10 = nullptr, *VAR_11 = nullptr;\n    char * VAR_12 = nullptr;\n    for ( ; rdi(VAR_9->d_tag) != VAR_13; VAR_9++) {\n        if (rdi(VAR_9->d_tag) == VAR_14) {\n            VAR_10 = VAR_9;\n            /* COMMENT_14 */\n            if (!VAR_11)\n                VAR_12 = VAR_6 + rdi(VAR_9->d_un.d_val);\n        }\n        else if (rdi(VAR_9->d_tag) == VAR_15) {\n            VAR_11 = VAR_9;\n            VAR_12 = VAR_6 + rdi(VAR_9->d_un.d_val);\n        }\n        else if (rdi(VAR_9->d_tag) == VAR_16)\n            VAR_8.push_back(std::string(VAR_6 + rdi(VAR_9->d_un.d_val)));\n    }\n\n    switch (VAR_0) {\n        case VAR_17: {\n            printf(\"%s\\n\", VAR_12 ? VAR_12 : \"\");\n            return;\n        };\n        case VAR_18: {\n            if (!VAR_12) {\n                debug(\"no RPATH to delete\\n\");\n                return;\n            }\n            removeRPath(VAR_3);\n            return;\n        }\n        case VAR_19: {\n            if (!VAR_12) {\n                debug(\"no RPATH to shrink\\n\");\n                return;\n            ;}\n            VAR_2 = shrinkRPath(VAR_12, VAR_8, VAR_1);\n            break;\n        }\n        case VAR_20: {\n            auto VAR_21 = std::string(VAR_12 ? VAR_12 : \"\");\n            appendRPath(VAR_21, VAR_2);\n            VAR_2 = VAR_21;\n            break;\n        }\n        case VAR_22: { break; } /* COMMENT_15 */\n    }\n\n    if (!VAR_23 && VAR_10 && !VAR_11) { /* COMMENT_16 */\n        wri(VAR_10->d_tag, VAR_15);\n        VAR_11 = VAR_10;\n        VAR_10 = nullptr;\n        VAR_24 = true;\n    } else if (VAR_23 && VAR_11) { /* COMMENT_17 */\n        wri(VAR_11->d_tag, VAR_14);\n        VAR_10 = VAR_11;\n        VAR_11 = nullptr;\n        VAR_24 = true;\n    }\n\n    if (VAR_12 && VAR_12 == VAR_2) {\n        return;\n    }\n    VAR_24 = true;\n\n    /* COMMENT_18 */\n              \n    size_t VAR_25 = 0;\n    if (VAR_12) {\n        VAR_25 = strlen(VAR_12);\n        memset(VAR_12, 'X', VAR_25);\n    }\n\n    debug(\"new rpath is '%s'\\n\", VAR_2.c_str());\n\n\n    if (VAR_2.size() <= VAR_25) {\n        if (VAR_12) memcpy(VAR_12, VAR_2.c_str(), VAR_2.size() + 1);\n        return;\n    }\n\n    /* COMMENT_20 */\n    debug(\"rpath is too long, resizing...\\n\");\n\n    std::string & VAR_26 = replaceSection(\".dynstr\",\n        rdi(VAR_5.sh_size) + VAR_2.size() + 1);\n    setSubstr(VAR_26, rdi(VAR_5.sh_size), VAR_2 + '\\0');\n\n    /* COMMENT_21 */\n    if (VAR_11 || VAR_10) {\n        if (VAR_11) VAR_11->d_un.d_val = VAR_5.sh_size;\n        if (VAR_10) VAR_10->d_un.d_val = VAR_5.sh_size;\n    }\n\n    else {\n        /* COMMENT_22 */\n                                                \n        std::string & VAR_27 = replaceSection(\".dynamic\",\n            rdi(VAR_3.sh_size) + sizeof(Elf_Dyn));\n\n        unsigned int VAR_28 = 0;\n        for ( ; rdi(((Elf_Dyn *) VAR_27.c_str())[VAR_28].d_tag) != VAR_13; VAR_28++) ;\n        debug(\"DT_NULL index is %d\\n\", VAR_28);\n\n        /* COMMENT_24 */\n        setSubstr(VAR_27, sizeof(Elf_Dyn),\n            std::string(VAR_27, 0, sizeof(Elf_Dyn) * (VAR_28 + 1)));\n\n        /* COMMENT_25 */\n        Elf_Dyn VAR_29;\n        wri(VAR_29.d_tag, VAR_23 ? VAR_14 : VAR_15);\n        VAR_29.d_un.d_val = VAR_5.sh_size;\n        setSubstr(VAR_27, 0, std::string((char *) &VAR_29, sizeof(Elf_Dyn)));\n    }\n    this->rewriteSections();\n}",
  "func_graph_path": "NixOS/patchelf/96c8422e374064c3407e73e8b1e4995f95e0a9e0/patchelf.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,7 @@\n        string. */\n     std::vector<std::string> neededLibs;\n     auto dyn = (Elf_Dyn *)(fileContents->data() + rdi(shdrDynamic.sh_offset));\n+    checkPointer(fileContents, dyn, sizeof(*dyn));\n     Elf_Dyn *dynRPath = nullptr, *dynRunPath = nullptr;\n     char * rpath = nullptr;\n     for ( ; rdi(dyn->d_tag) != DT_NULL; dyn++) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    checkPointer(fileContents, dyn, sizeof(*dyn));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/NixOS/patchelf/pull/419",
  "description": {
    "pr_info": {
      "title": "Fix Out-of-bounds read in the function modifyRPath",
      "number": 419
    },
    "comment": [
      "Hi:\r\nOut-of-bounds read exists in the function modifyRPath,  I fixed this issue in this PR \r\n\r\n1. Here's ASAN log:\r\n\r\n```\r\nroot@iZ2vcadn43p7fjzbhl6zqwZ:~/patchelf_0# /usr/local/bin/patchelf --shrink-rpath sample00900 \r\nAddressSanitizer:DEADLYSIGNAL\r\n=================================================================\r\n==60417==ERROR: AddressSanitizer: SEGV on unknown address 0x626200001e58 (pc 0x557356cd43e7 bp 0x7ffeea76e550 sp 0x7ffeea76dfa0 T0)\r\n==60417==The signal is caused by a READ memory access.\r\n    #0 0x557356cd43e6 in ElfFile<Elf64_Ehdr, Elf64_Phdr, Elf64_Shdr, unsigned long, unsigned long, Elf64_Dyn, Elf64_Sym, Elf64_Verneed, unsigned short>::modifyRPath(ElfFile<Elf64_Ehdr, Elf64_Phdr, Elf64_Shdr, unsigned long, unsigned long, Elf64_Dyn, Elf64_Sym, Elf64_Verneed, unsigned short>::RPathOp, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /root/patchelf_0/src/patchelf.cc:1376\r\n    #1 0x557356b6ba6c in patchElf2<ElfFile<Elf64_Ehdr, Elf64_Phdr, Elf64_Shdr, long unsigned int, long unsigned int, Elf64_Dyn, Elf64_Sym, Elf64_Verneed, short unsigned int> > /root/patchelf_0/src/patchelf.cc:1865\r\n    #2 0x557356b6ba6c in patchElf /root/patchelf_0/src/patchelf.cc:1907\r\n    #3 0x557356b6ba6c in mainWrapped(int, char**) /root/patchelf_0/src/patchelf.cc:2089\r\n    #4 0x557356b56ee5 in main /root/patchelf_0/src/patchelf.cc:2097\r\n    #5 0x7ff86c8b6082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\r\n    #6 0x557356b57bdd in _start (/usr/local/bin/patchelf+0x225bdd)\r\n```\r\n\r\n2. Steps to Reproduce\r\n  ./configure --with-asan --with-ubsan\r\n  make & make install\r\n  /usr/local/bin/patchelf --shrink-rpath sample00900\r\n\r\n[sample00900.zip](https://github.com/NixOS/patchelf/files/9865746/sample00900.zip)\r\n",
      "bors merge"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}