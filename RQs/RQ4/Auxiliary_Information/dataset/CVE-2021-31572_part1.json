{
  "cve_id": "CVE-2021-31572",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "FreeRTOS/FreeRTOS-Kernel",
  "commit_msg": "Add addition overflow check for stream buffer (#226)",
  "commit_hash": "d05b9c123f2bf9090bce386a244fc934ae44db5b",
  "git_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b",
  "file_path": "stream_buffer.c",
  "func_name": "xStreamBufferGenericCreate",
  "func_before": "StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n\n        /* In case the stream buffer is going to be used as a message buffer\n         * (that is, it will hold discrete messages with a little meta data that\n         * says how big the next message is) check the buffer will be large enough\n         * to hold at least one message. */\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            /* Is a message buffer but not statically allocated. */\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            /* Not a message buffer and not statically allocated. */\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n\n        /* A trigger level of 0 would cause a waiting task to unblock even when\n         * the buffer was empty. */\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n\n        /* A stream buffer requires a StreamBuffer_t structure and a buffer.\n         * Both are allocated in a single call to pvPortMalloc().  The\n         * StreamBuffer_t structure is placed at the start of the allocated memory\n         * and the buffer follows immediately after.  The requested size is\n         * incremented so the free space is returned as the user would expect -\n         * this is a quirk of the implementation that means otherwise the free\n         * space would be reported as one byte smaller than would be logically\n         * expected. */\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\n\n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */\n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */\n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */\n    }",
  "abstract_func_before": "StreamBufferHandle_t xStreamBufferGenericCreate( size_t VAR_0,\n                                                     size_t VAR_1,\n                                                     BaseType_t VAR_2 )\n    {\n        uint8_t * VAR_3;\n        uint8_t VAR_4;\n\n        /* COMMENT_0 */\n                                                                                \n                                                                                  \n                                           \n        if( VAR_2 == VAR_5 )\n        {\n            /* COMMENT_4 */\n            VAR_4 = VAR_6;\n            configASSERT( VAR_0 > VAR_7 );\n        }\n        else\n        {\n            /* COMMENT_5 */\n            VAR_4 = 0;\n            configASSERT( VAR_0 > 0 );\n        }\n\n        configASSERT( VAR_1 <= VAR_0 );\n\n        /* COMMENT_6 */\n                                   \n        if( VAR_1 == ( size_t ) 0 )\n        {\n            VAR_1 = ( size_t ) 1;\n        }\n\n        /* COMMENT_8 */\n                                                                      \n                                                                                  \n                                                                           \n                                                                               \n                                                                              \n                                                                              \n                       \n        VAR_0++;\n        VAR_3 = ( uint8_t * ) pvPortMalloc( VAR_0 + sizeof( VAR_8 ) ); /* COMMENT_16 */\n\n        if( VAR_3 != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) VAR_3,       /* COMMENT_17 */ /* COMMENT_18 */ /* COMMENT_19 */\n                                          VAR_3 + sizeof( StreamBuffer_t ), /* COMMENT_20 */ /* COMMENT_21 */\n                                          VAR_0,\n                                          VAR_1,\n                                          VAR_4 );\n\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) VAR_3 ), VAR_2 );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( VAR_2 );\n        }\n\n        return ( StreamBufferHandle_t ) VAR_3; /* COMMENT_22 */\n    }",
  "func_graph_path_before": "FreeRTOS/FreeRTOS-Kernel/d05b9c123f2bf9090bce386a244fc934ae44db5b/stream_buffer.c/vul/before/0.json",
  "func": "StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n\n        /* In case the stream buffer is going to be used as a message buffer\n         * (that is, it will hold discrete messages with a little meta data that\n         * says how big the next message is) check the buffer will be large enough\n         * to hold at least one message. */\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            /* Is a message buffer but not statically allocated. */\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            /* Not a message buffer and not statically allocated. */\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n\n        /* A trigger level of 0 would cause a waiting task to unblock even when\n         * the buffer was empty. */\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n\n        /* A stream buffer requires a StreamBuffer_t structure and a buffer.\n         * Both are allocated in a single call to pvPortMalloc().  The\n         * StreamBuffer_t structure is placed at the start of the allocated memory\n         * and the buffer follows immediately after.  The requested size is\n         * incremented so the free space is returned as the user would expect -\n         * this is a quirk of the implementation that means otherwise the free\n         * space would be reported as one byte smaller than would be logically\n         * expected. */\n        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )\n        {\n            xBufferSizeBytes++;\n            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\n        }\n        else\n        {\n            pucAllocatedMemory = NULL;\n        }\n        \n\n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */\n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */\n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */\n    }",
  "abstract_func": "StreamBufferHandle_t xStreamBufferGenericCreate( size_t VAR_0,\n                                                     size_t VAR_1,\n                                                     BaseType_t VAR_2 )\n    {\n        uint8_t * VAR_3;\n        uint8_t VAR_4;\n\n        /* COMMENT_0 */\n                                                                                \n                                                                                  \n                                           \n        if( VAR_2 == VAR_5 )\n        {\n            /* COMMENT_4 */\n            VAR_4 = VAR_6;\n            configASSERT( VAR_0 > VAR_7 );\n        }\n        else\n        {\n            /* COMMENT_5 */\n            VAR_4 = 0;\n            configASSERT( VAR_0 > 0 );\n        }\n\n        configASSERT( VAR_1 <= VAR_0 );\n\n        /* COMMENT_6 */\n                                   \n        if( VAR_1 == ( size_t ) 0 )\n        {\n            VAR_1 = ( size_t ) 1;\n        }\n\n        /* COMMENT_8 */\n                                                                      \n                                                                                  \n                                                                           \n                                                                               \n                                                                              \n                                                                              \n                       \n        if( VAR_0 < ( VAR_0 + 1 + sizeof( VAR_8 ) ) )\n        {\n            VAR_0++;\n            VAR_3 = ( uint8_t * ) pvPortMalloc( VAR_0 + sizeof( VAR_8 ) ); /* COMMENT_16 */\n        }\n        else\n        {\n            VAR_3 = NULL;\n        }\n        \n\n        if( VAR_3 != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) VAR_3,       /* COMMENT_17 */ /* COMMENT_18 */ /* COMMENT_19 */\n                                          VAR_3 + sizeof( StreamBuffer_t ), /* COMMENT_20 */ /* COMMENT_21 */\n                                          VAR_0,\n                                          VAR_1,\n                                          VAR_4 );\n\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) VAR_3 ), VAR_2 );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( VAR_2 );\n        }\n\n        return ( StreamBufferHandle_t ) VAR_3; /* COMMENT_22 */\n    }",
  "func_graph_path": "FreeRTOS/FreeRTOS-Kernel/d05b9c123f2bf9090bce386a244fc934ae44db5b/stream_buffer.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -39,8 +39,16 @@\n          * this is a quirk of the implementation that means otherwise the free\n          * space would be reported as one byte smaller than would be logically\n          * expected. */\n-        xBufferSizeBytes++;\n-        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\n+        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )\n+        {\n+            xBufferSizeBytes++;\n+            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */\n+        }\n+        else\n+        {\n+            pucAllocatedMemory = NULL;\n+        }\n+        \n \n         if( pucAllocatedMemory != NULL )\n         {",
  "diff_line_info": {
    "deleted_lines": [
      "        xBufferSizeBytes++;",
      "        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */"
    ],
    "added_lines": [
      "        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )",
      "        {",
      "            xBufferSizeBytes++;",
      "            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */",
      "        }",
      "        else",
      "        {",
      "            pucAllocatedMemory = NULL;",
      "        }",
      "        "
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/226",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/226: 403 Client Error: Forbidden for url: https://api.github.com/repos/FreeRTOS/FreeRTOS-Kernel/pulls/226",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}