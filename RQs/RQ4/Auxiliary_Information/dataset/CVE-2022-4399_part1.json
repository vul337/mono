{
  "cve_id": "CVE-2022-4399",
  "cwe_ids": [
    "CWE-89"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "TicklishHoneyBee/nodau",
  "commit_msg": "Use parametetrized SQL statement\n\nMove to parametetrized SQL statement allows using chars like \"'\" in\nnotes and also avoid sql injection",
  "commit_hash": "7a7d737a3929f335b9717ddbd31db91151b69ad2",
  "git_url": "https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2",
  "file_path": "src/db.c",
  "func_name": "db_update",
  "func_before": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n\t\tfree(value);\n\t\tif (r < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n\t\t\treturn 1;\n\t}\n\n\t/* do it */\n\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\tfree(sql);\n\treturn r;\n}",
  "abstract_func_before": "int db_update(char* VAR_0, char* VAR_1)\n{\n\tchar* VAR_2;\n\tint VAR_3 = 0;\n\t/* COMMENT_0 */\n                                                                \n\tif (VAR_4) {\n\t\tVAR_1 = note_encrypt(VAR_1,VAR_4);\n\t\tVAR_3 = asprintf(&VAR_2, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", VAR_1, VAR_0);\n\t\tfree(VAR_1);\n\t\tif (VAR_3 < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&VAR_2, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", VAR_1, VAR_0) < 0)\n\t\t\treturn 1;\n\t}\n\n\t/* COMMENT_2 */\n\tVAR_3 = sqlite3_exec(VAR_5.db, VAR_2, NULL, 0, &VAR_5.error_msg);\n\tfree(VAR_2);\n\treturn VAR_3;\n}",
  "func_graph_path_before": "TicklishHoneyBee/nodau/7a7d737a3929f335b9717ddbd31db91151b69ad2/db.c/vul/before/0.json",
  "func": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}\n\n\tsqlite3_stmt *compiled_statement;\n\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\t/* do it */\n\tr = sqlite3_step(compiled_statement);\n\tif (r != SQLITE_DONE) {\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\t\treturn 1;\n\t}\n\tr = sqlite3_finalize(compiled_statement);\n\tif (r != SQLITE_OK)\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\n\tfree(sql);\n\tif (crypt_key)\n\t\tfree(value);\n\treturn r;\n}",
  "abstract_func": "int db_update(char* VAR_0, char* VAR_1)\n{\n\tchar* VAR_2;\n\tint VAR_3 = 0;\n\t/* COMMENT_0 */\n                                                                \n\tif (VAR_4) {\n\t\tVAR_1 = note_encrypt(VAR_1,VAR_4);\n\t\tif (asprintf(&VAR_2, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&VAR_2, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}\n\n\tsqlite3_stmt *VAR_5;\n\tVAR_3 = sqlite3_prepare_v2(VAR_6.db, VAR_2, -1, &VAR_5, NULL);\n\tif (VAR_3 != VAR_7)\n\t\treturn 1;\n\n\tVAR_3= sqlite3_bind_text(VAR_5, 1, VAR_1, -1, NULL);\n\tVAR_3= sqlite3_bind_text(VAR_5, 2, VAR_0, -1, NULL);\n\tif (VAR_3 != VAR_7)\n\t\treturn 1;\n\n\t/* COMMENT_2 */\n\tVAR_3 = sqlite3_step(VAR_5);\n\tif (VAR_3 != VAR_8) {\n\t\tfprintf(VAR_9, \"Error #%d: %s\\n\", VAR_3, db_err());\n\t\treturn 1;\n\t}\n\tVAR_3 = sqlite3_finalize(VAR_5);\n\tif (VAR_3 != VAR_7)\n\t\tfprintf(VAR_9, \"Error #%d: %s\\n\", VAR_3, db_err());\n\n\tfree(VAR_2);\n\tif (VAR_4)\n\t\tfree(VAR_1);\n\treturn VAR_3;\n}",
  "func_graph_path": "TicklishHoneyBee/nodau/7a7d737a3929f335b9717ddbd31db91151b69ad2/db.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,17 +6,35 @@\n \t * if it's meant to be encrypted, then crypt_key will be set */\n \tif (crypt_key) {\n \t\tvalue = note_encrypt(value,crypt_key);\n-\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n-\t\tfree(value);\n-\t\tif (r < 0)\n+\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n \t\t\treturn 1;\n \t}else{\n-\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n+\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)\n \t\t\treturn 1;\n \t}\n \n+\tsqlite3_stmt *compiled_statement;\n+\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);\n+\tif (r != SQLITE_OK)\n+\t\treturn 1;\n+\n+\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n+\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);\n+\tif (r != SQLITE_OK)\n+\t\treturn 1;\n+\n \t/* do it */\n-\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n+\tr = sqlite3_step(compiled_statement);\n+\tif (r != SQLITE_DONE) {\n+\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n+\t\treturn 1;\n+\t}\n+\tr = sqlite3_finalize(compiled_statement);\n+\tif (r != SQLITE_OK)\n+\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n+\n \tfree(sql);\n+\tif (crypt_key)\n+\t\tfree(value);\n \treturn r;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);",
      "\t\tfree(value);",
      "\t\tif (r < 0)",
      "\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)",
      "\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);"
    ],
    "added_lines": [
      "\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)",
      "\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)",
      "\tsqlite3_stmt *compiled_statement;",
      "\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);",
      "\tif (r != SQLITE_OK)",
      "\t\treturn 1;",
      "",
      "\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);",
      "\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);",
      "\tif (r != SQLITE_OK)",
      "\t\treturn 1;",
      "",
      "\tr = sqlite3_step(compiled_statement);",
      "\tif (r != SQLITE_DONE) {",
      "\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());",
      "\t\treturn 1;",
      "\t}",
      "\tr = sqlite3_finalize(compiled_statement);",
      "\tif (r != SQLITE_OK)",
      "\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());",
      "",
      "\tif (crypt_key)",
      "\t\tfree(value);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/TicklishHoneyBee/nodau/pull/26",
  "description": {
    "pr_info": {
      "title": "Use parametetrized SQL statement to allow special chars",
      "number": 26
    },
    "comment": [
      "Moving to parametetrized SQL statement allows using chars like \" ' \" in notes",
      "Hi, so this is a great idea, but there's a couple of issues with it as is.\r\n\r\nFirstly, if statements with only a single line body (and no else) don't needed braces. You've added a bit of a mix and match of this so please remove some braces (most notably, around line 316 of db.c). Also some spaces were added around an '}else{' making it '} else {' and different to every other else in the project.\r\n\r\nSecondly, you've used sqlite3_errmsg directly inside a printf in a couple of places, please either read directly from db_data.error_msg (if set), or use the included wrapper function db_err which prevents a NULL return that can cause segfaults in some printf implementations. Also, being system/internal error messages, these should use fprintf to output to stderr rather than stdout.\r\n\r\n",
      "Hi @TicklishHoneyBee , thanks for your reply. I will follow your guidelines and perform additional commit.",
      "Hi @TicklishHoneyBee , I followed your guidelines in my last commit. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses SQL injection by switching to parameterized queries, as indicated by the commit message and code diff.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}