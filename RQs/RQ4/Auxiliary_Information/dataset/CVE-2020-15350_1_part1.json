{
  "cve_id": "CVE-2020-15350",
  "cwe_ids": [
    "CWE-119",
    "CWE-131"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "sys/base64: Use void pointer for buffers in API\n\nThis is a non-breaking change, as `unsigned char *` can implicitly be converted\nto `void *`.",
  "commit_hash": "3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303",
  "file_path": "sys/base64/base64.c",
  "func_name": "base64_encode_base",
  "func_before": "static int base64_encode_base(const void *data_in, size_t data_in_size,\n                              unsigned char *base64_out, size_t *base64_out_size,\n                              bool urlsafe)\n{\n    const unsigned char *in = data_in;\n    size_t required_size = base64_estimate_encode_size(data_in_size);\n\n    if (data_in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (data_in_size == 0) {\n        *base64_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (*base64_out_size < required_size) {\n        *base64_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (base64_out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_base64_buffer = 0;\n    unsigned char nNum = 0;\n    int nLst = 0;\n    int njump = 0;\n\n    for (int i = 0; i < (int)(data_in_size); ++i) {\n        unsigned char tmpval;\n        njump++;\n        tmpval = *(in + i);\n\n        nNum = (tmpval >> (2 * njump));\n\n        if (njump == 4) {\n            nNum = nLst << (8 - 2 * njump);\n            njump = 0;\n            nLst = 0;\n            --i;\n        }\n        else {\n            nNum += nLst << (8 - 2 * njump);\n            nLst =  tmpval & ((1 << njump * 2) - 1);\n        }\n\n        base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);\n    }\n\n    /* The last character is not finished yet */\n    njump++;\n\n    nNum = nLst << (8 - 2 * njump);\n    base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);\n\n    /* if required we append '=' for the required dividability */\n    while (iterate_base64_buffer % 4) {\n        base64_out[iterate_base64_buffer++] = '=';\n    }\n\n    *base64_out_size = iterate_base64_buffer;\n\n    return BASE64_SUCCESS;\n}",
  "abstract_func_before": "static int base64_encode_base(const void *VAR_0, size_t VAR_1,\n                              unsigned char *VAR_2, size_t *VAR_3,\n                              bool VAR_4)\n{\n    const unsigned char *VAR_5 = VAR_0;\n    size_t VAR_6 = base64_estimate_encode_size(VAR_1);\n\n    if (VAR_0 == NULL) {\n        return VAR_7;\n    }\n\n    if (VAR_1 == 0) {\n        *VAR_3 = 0;\n        return VAR_8;\n    }\n\n    if (*VAR_3 < VAR_6) {\n        *VAR_3 = VAR_6;\n        return VAR_9;\n    }\n\n    if (VAR_2 == NULL) {\n        return VAR_10;\n    }\n\n    int VAR_11 = 0;\n    unsigned char VAR_12 = 0;\n    int VAR_13 = 0;\n    int VAR_14 = 0;\n\n    for (int VAR_15 = 0; VAR_15 < (int)(VAR_1); ++VAR_15) {\n        unsigned char VAR_16;\n        VAR_14++;\n        VAR_16 = *(VAR_5 + VAR_15);\n\n        VAR_12 = (VAR_16 >> (2 * VAR_14));\n\n        if (VAR_14 == 4) {\n            VAR_12 = VAR_13 << (8 - 2 * VAR_14);\n            VAR_14 = 0;\n            VAR_13 = 0;\n            --VAR_15;\n        }\n        else {\n            VAR_12 += VAR_13 << (8 - 2 * VAR_14);\n            VAR_13 =  VAR_16 & ((1 << VAR_14 * 2) - 1);\n        }\n\n        VAR_2[VAR_11++] = getsymbol(VAR_12, VAR_4);\n    }\n\n    /* COMMENT_0 */\n    VAR_14++;\n\n    VAR_12 = VAR_13 << (8 - 2 * VAR_14);\n    VAR_2[VAR_11++] = getsymbol(VAR_12, VAR_4);\n\n    /* COMMENT_1 */\n    while (VAR_11 % 4) {\n        VAR_2[VAR_11++] = '=';\n    }\n\n    *VAR_3 = VAR_11;\n\n    return VAR_8;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303/base64.c/vul/before/1.json",
  "func": "static int base64_encode_base(const void *data_in, size_t data_in_size,\n                              void *base64_out, size_t *base64_out_size,\n                              bool urlsafe)\n{\n    const uint8_t *in = data_in;\n    uint8_t *out = base64_out;\n    size_t required_size = base64_estimate_encode_size(data_in_size);\n\n    if (data_in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (data_in_size == 0) {\n        *base64_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (*base64_out_size < required_size) {\n        *base64_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_base64_buffer = 0;\n    uint8_t n_num = 0;\n    int nLst = 0;\n    int njump = 0;\n\n    for (int i = 0; i < (int)(data_in_size); ++i) {\n        uint8_t tmpval;\n        njump++;\n        tmpval = *(in + i);\n\n        n_num = (tmpval >> (2 * njump));\n\n        if (njump == 4) {\n            n_num = nLst << (8 - 2 * njump);\n            njump = 0;\n            nLst = 0;\n            --i;\n        }\n        else {\n            n_num += nLst << (8 - 2 * njump);\n            nLst =  tmpval & ((1 << njump * 2) - 1);\n        }\n\n        out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);\n    }\n\n    /* The last character is not finished yet */\n    njump++;\n\n    n_num = nLst << (8 - 2 * njump);\n    out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);\n\n    /* if required we append '=' for the required dividability */\n    while (iterate_base64_buffer % 4) {\n        out[iterate_base64_buffer++] = '=';\n    }\n\n    *base64_out_size = iterate_base64_buffer;\n\n    return BASE64_SUCCESS;\n}",
  "abstract_func": "static int base64_encode_base(const void *VAR_0, size_t VAR_1,\n                              void *VAR_2, size_t *VAR_3,\n                              bool VAR_4)\n{\n    const uint8_t *VAR_5 = VAR_0;\n    uint8_t *VAR_6 = VAR_2;\n    size_t VAR_7 = base64_estimate_encode_size(VAR_1);\n\n    if (VAR_0 == NULL) {\n        return VAR_8;\n    }\n\n    if (VAR_1 == 0) {\n        *VAR_3 = 0;\n        return VAR_9;\n    }\n\n    if (*VAR_3 < VAR_7) {\n        *VAR_3 = VAR_7;\n        return VAR_10;\n    }\n\n    if (VAR_6 == NULL) {\n        return VAR_11;\n    }\n\n    int VAR_12 = 0;\n    uint8_t VAR_13 = 0;\n    int VAR_14 = 0;\n    int VAR_15 = 0;\n\n    for (int VAR_16 = 0; VAR_16 < (int)(VAR_1); ++VAR_16) {\n        uint8_t VAR_17;\n        VAR_15++;\n        VAR_17 = *(VAR_5 + VAR_16);\n\n        VAR_13 = (VAR_17 >> (2 * VAR_15));\n\n        if (VAR_15 == 4) {\n            VAR_13 = VAR_14 << (8 - 2 * VAR_15);\n            VAR_15 = 0;\n            VAR_14 = 0;\n            --VAR_16;\n        }\n        else {\n            VAR_13 += VAR_14 << (8 - 2 * VAR_15);\n            VAR_14 =  VAR_17 & ((1 << VAR_15 * 2) - 1);\n        }\n\n        VAR_6[VAR_12++] = getsymbol(VAR_13, VAR_4);\n    }\n\n    /* COMMENT_0 */\n    VAR_15++;\n\n    VAR_13 = VAR_14 << (8 - 2 * VAR_15);\n    VAR_6[VAR_12++] = getsymbol(VAR_13, VAR_4);\n\n    /* COMMENT_1 */\n    while (VAR_12 % 4) {\n        VAR_6[VAR_12++] = '=';\n    }\n\n    *VAR_3 = VAR_12;\n\n    return VAR_9;\n}",
  "func_graph_path": "RIOT-OS/RIOT/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303/base64.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n static int base64_encode_base(const void *data_in, size_t data_in_size,\n-                              unsigned char *base64_out, size_t *base64_out_size,\n+                              void *base64_out, size_t *base64_out_size,\n                               bool urlsafe)\n {\n-    const unsigned char *in = data_in;\n+    const uint8_t *in = data_in;\n+    uint8_t *out = base64_out;\n     size_t required_size = base64_estimate_encode_size(data_in_size);\n \n     if (data_in == NULL) {\n@@ -19,45 +20,45 @@\n         return BASE64_ERROR_BUFFER_OUT_SIZE;\n     }\n \n-    if (base64_out == NULL) {\n+    if (out == NULL) {\n         return BASE64_ERROR_BUFFER_OUT;\n     }\n \n     int iterate_base64_buffer = 0;\n-    unsigned char nNum = 0;\n+    uint8_t n_num = 0;\n     int nLst = 0;\n     int njump = 0;\n \n     for (int i = 0; i < (int)(data_in_size); ++i) {\n-        unsigned char tmpval;\n+        uint8_t tmpval;\n         njump++;\n         tmpval = *(in + i);\n \n-        nNum = (tmpval >> (2 * njump));\n+        n_num = (tmpval >> (2 * njump));\n \n         if (njump == 4) {\n-            nNum = nLst << (8 - 2 * njump);\n+            n_num = nLst << (8 - 2 * njump);\n             njump = 0;\n             nLst = 0;\n             --i;\n         }\n         else {\n-            nNum += nLst << (8 - 2 * njump);\n+            n_num += nLst << (8 - 2 * njump);\n             nLst =  tmpval & ((1 << njump * 2) - 1);\n         }\n \n-        base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);\n+        out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);\n     }\n \n     /* The last character is not finished yet */\n     njump++;\n \n-    nNum = nLst << (8 - 2 * njump);\n-    base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);\n+    n_num = nLst << (8 - 2 * njump);\n+    out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);\n \n     /* if required we append '=' for the required dividability */\n     while (iterate_base64_buffer % 4) {\n-        base64_out[iterate_base64_buffer++] = '=';\n+        out[iterate_base64_buffer++] = '=';\n     }\n \n     *base64_out_size = iterate_base64_buffer;",
  "diff_line_info": {
    "deleted_lines": [
      "                              unsigned char *base64_out, size_t *base64_out_size,",
      "    const unsigned char *in = data_in;",
      "    if (base64_out == NULL) {",
      "    unsigned char nNum = 0;",
      "        unsigned char tmpval;",
      "        nNum = (tmpval >> (2 * njump));",
      "            nNum = nLst << (8 - 2 * njump);",
      "            nNum += nLst << (8 - 2 * njump);",
      "        base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);",
      "    nNum = nLst << (8 - 2 * njump);",
      "    base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);",
      "        base64_out[iterate_base64_buffer++] = '=';"
    ],
    "added_lines": [
      "                              void *base64_out, size_t *base64_out_size,",
      "    const uint8_t *in = data_in;",
      "    uint8_t *out = base64_out;",
      "    if (out == NULL) {",
      "    uint8_t n_num = 0;",
      "        uint8_t tmpval;",
      "        n_num = (tmpval >> (2 * njump));",
      "            n_num = nLst << (8 - 2 * njump);",
      "            n_num += nLst << (8 - 2 * njump);",
      "        out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);",
      "    n_num = nLst << (8 - 2 * njump);",
      "    out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);",
      "        out[iterate_base64_buffer++] = '=';"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/14400",
  "description": {
    "pr_info": {
      "title": "sys/base64: Fix, unit test cleanup, and benchmark",
      "number": 14400
    },
    "comment": [
      "### Contribution description\r\n\r\n- Cherry-picked [@mjurczak fix](https://github.com/mjurczak/RIOT/commit/d27b048c28ceb1e3d0e0b06faa2f77965b7784d9) for the decode buffer size estimation (which could result in a buffer overflow of up to one byte note being catched)\r\n- Made using the API less pain by accepting `void` pointers for buffers (non-breaking change, as `unsigned char *` is implicitly casted to `void *`)\r\n- Cleaned up the unit test to fix basic code quality issued\r\n- Added a unit test to check the `base64_estimate_{de,en}code_size()`\r\n- Added a benchmark for base64 (this will come in useful to review a follow up PR)\r\n\r\n### Testing procedure\r\n\r\nThe unit tests should no detect an issue in `base64_estimate_{de,en}code_size()`\r\n\r\n### Issues/PRs references\r\n\r\nNone",
      "Somehow the build was previously not queued, toggling `CI: ready for build` seems to have solved the issue.",
      "Looks like the unit test will now fail\r\n\r\n> `base64_tests.test_base64_13_size_estimation (tests/unittests/tests-base64/tests-base64.c 495) exp 3 was 0`",
      "No need to run tests on hardware. The compilation tests include a run of the unit tests on the `native` board.",
      "@mjurczak: I cherry-picked your suggested fix and included it in the PR. This way, the credit for and authorship of the commits stays with you.",
      "With @mjurczak fix included, the unit tests are now passing. I updated the PR title and the description accordingly.",
      "Fixed some style issues, while we're at it.\r\n\r\n(I will let Murdock run again when I have squashed.)",
      "> Should the benchmark have an automatic test?\r\n\r\nI'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n\r\nWhat we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.",
      "> I'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n> \r\n> What we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.\r\n\r\nI was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\". My comment comes mainly from the impression that we now ask for a `01-run.py` for new applications.",
      "> I was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\".\r\n\r\nAh, OK! I added the test.",
      "Please squash @maribu and re-trigger ci.",
      "I fixed a typo in the test input detected by the static tests (and the corresponding base64) and added the missing empty line flake8 complained about. I squashed right away.",
      "Murdock likes it too.",
      "@mjurczak: Thank you very much for reporting and fixing the issue!\r\n\r\nThanks everyone for the reviews.",
      "@maribu  I'm stunned with the fast reaction. Great job everyone!"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Supporting & Non-Core Improvements  \n**Confidence:** 0.8  \n\nThe patch primarily involves API refactor by changing pointer types, which doesn't directly address a security issue, though it was part of a broader fix that included a security update. The confidence is high due to clear API changes but lower because the security fix isn't directly shown here."
}