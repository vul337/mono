{
  "cve_id": "CVE-2021-36369",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "mkj/dropbear",
  "commit_msg": "added option to disable trivial auth methods",
  "commit_hash": "7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
  "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
  "file_path": "cli-authinteract.c",
  "func_name": "recv_msg_userauth_info_request",
  "func_before": "void recv_msg_userauth_info_request() {\n\n\tchar *name = NULL;\n\tchar *instruction = NULL;\n\tunsigned int num_prompts = 0;\n\tunsigned int i;\n\n\tchar *prompt = NULL;\n\tunsigned int echo = 0;\n\tchar *response = NULL;\n\n\tTRACE((\"enter recv_msg_recv_userauth_info_request\"))\n\n\t/* Let the user know what password/host they are authing for */\n\tif (!cli_ses.interact_request_received) {\n\t\tfprintf(stderr, \"Login for %s@%s\\n\", cli_opts.username,\n\t\t\t\tcli_opts.remotehost);\n\t}\n\tcli_ses.interact_request_received = 1;\n\n\tname = buf_getstring(ses.payload, NULL);\n\tinstruction = buf_getstring(ses.payload, NULL);\n\n\t/* language tag */\n\tbuf_eatstring(ses.payload);\n\n\tnum_prompts = buf_getint(ses.payload);\n\t\n\tif (num_prompts >= DROPBEAR_MAX_CLI_INTERACT_PROMPTS) {\n\t\tdropbear_exit(\"Too many prompts received for keyboard-interactive\");\n\t}\n\n\t/* we'll build the response as we go */\n\tCHECKCLEARTOWRITE();\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_INFO_RESPONSE);\n\tbuf_putint(ses.writepayload, num_prompts);\n\n\tif (strlen(name) > 0) {\n\t\tcleantext(name);\n\t\tfprintf(stderr, \"%s\", name);\n\t}\n\tm_free(name);\n\n\tif (strlen(instruction) > 0) {\n\t\tcleantext(instruction);\n\t\tfprintf(stderr, \"%s\", instruction);\n\t}\n\tm_free(instruction);\n\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tunsigned int response_len = 0;\n\t\tprompt = buf_getstring(ses.payload, NULL);\n\t\tcleantext(prompt);\n\n\t\techo = buf_getbool(ses.payload);\n\n\t\tif (!echo) {\n\t\t\tchar* p = getpass_or_cancel(prompt);\n\t\t\tresponse = m_strdup(p);\n\t\t\tm_burn(p, strlen(p));\n\t\t} else {\n\t\t\tresponse = get_response(prompt);\n\t\t}\n\n\t\tresponse_len = strlen(response);\n\t\tbuf_putstring(ses.writepayload, response, response_len);\n\t\tm_burn(response, response_len);\n\t\tm_free(prompt);\n\t\tm_free(response);\n\t}\n\n\tencrypt_packet();\n\n\n\tTRACE((\"leave recv_msg_recv_userauth_info_request\"))\n}",
  "abstract_func_before": "void recv_msg_userauth_info_request() {\n\n\tchar *VAR_0 = NULL;\n\tchar *VAR_1 = NULL;\n\tunsigned int VAR_2 = 0;\n\tunsigned int VAR_3;\n\n\tchar *VAR_4 = NULL;\n\tunsigned int VAR_5 = 0;\n\tchar *VAR_6 = NULL;\n\n\tTRACE((\"enter recv_msg_recv_userauth_info_request\"))\n\n\t/* COMMENT_0 */\n\tif (!VAR_7.interact_request_received) {\n\t\tfprintf(VAR_8, \"Login for %s@%s\\n\", VAR_9.username,\n\t\t\t\tVAR_9.remotehost);\n\t}\n\tVAR_7.interact_request_received = 1;\n\n\tVAR_0 = buf_getstring(VAR_10.payload, NULL);\n\tVAR_1 = buf_getstring(VAR_10.payload, NULL);\n\n\t/* COMMENT_1 */\n\tbuf_eatstring(VAR_10.payload);\n\n\tVAR_2 = buf_getint(VAR_10.payload);\n\t\n\tif (VAR_2 >= VAR_11) {\n\t\tdropbear_exit(\"Too many prompts received for keyboard-interactive\");\n\t}\n\n\t/* COMMENT_2 */\n\tCHECKCLEARTOWRITE();\n\tbuf_putbyte(VAR_10.writepayload, VAR_12);\n\tbuf_putint(VAR_10.writepayload, VAR_2);\n\n\tif (strlen(VAR_0) > 0) {\n\t\tcleantext(VAR_0);\n\t\tfprintf(VAR_8, \"%s\", VAR_0);\n\t}\n\tm_free(VAR_0);\n\n\tif (strlen(VAR_1) > 0) {\n\t\tcleantext(VAR_1);\n\t\tfprintf(VAR_8, \"%s\", VAR_1);\n\t}\n\tm_free(VAR_1);\n\n\tfor (VAR_3 = 0; VAR_3 < VAR_2; VAR_3++) {\n\t\tunsigned int VAR_13 = 0;\n\t\tVAR_4 = buf_getstring(VAR_10.payload, NULL);\n\t\tcleantext(VAR_4);\n\n\t\tVAR_5 = buf_getbool(VAR_10.payload);\n\n\t\tif (!VAR_5) {\n\t\t\tchar* VAR_14 = getpass_or_cancel(VAR_4);\n\t\t\tVAR_6 = m_strdup(VAR_14);\n\t\t\tm_burn(VAR_14, strlen(VAR_14));\n\t\t} else {\n\t\t\tVAR_6 = get_response(VAR_4);\n\t\t}\n\n\t\tVAR_13 = strlen(VAR_6);\n\t\tbuf_putstring(VAR_10.writepayload, VAR_6, VAR_13);\n\t\tm_burn(VAR_6, VAR_13);\n\t\tm_free(VAR_4);\n\t\tm_free(VAR_6);\n\t}\n\n\tencrypt_packet();\n\n\n\tTRACE((\"leave recv_msg_recv_userauth_info_request\"))\n}",
  "func_graph_path_before": "mkj/dropbear/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c/cli-authinteract.c/vul/before/0.json",
  "func": "void recv_msg_userauth_info_request() {\n\n\tchar *name = NULL;\n\tchar *instruction = NULL;\n\tunsigned int num_prompts = 0;\n\tunsigned int i;\n\n\tchar *prompt = NULL;\n\tunsigned int echo = 0;\n\tchar *response = NULL;\n\n\tTRACE((\"enter recv_msg_recv_userauth_info_request\"))\n\n\t/* Let the user know what password/host they are authing for */\n\tif (!cli_ses.interact_request_received) {\n\t\tfprintf(stderr, \"Login for %s@%s\\n\", cli_opts.username,\n\t\t\t\tcli_opts.remotehost);\n\t}\n\tcli_ses.interact_request_received = 1;\n\n\tname = buf_getstring(ses.payload, NULL);\n\tinstruction = buf_getstring(ses.payload, NULL);\n\n\t/* language tag */\n\tbuf_eatstring(ses.payload);\n\n\tnum_prompts = buf_getint(ses.payload);\n\t\n\tif (num_prompts >= DROPBEAR_MAX_CLI_INTERACT_PROMPTS) {\n\t\tdropbear_exit(\"Too many prompts received for keyboard-interactive\");\n\t}\n\n\t/* we'll build the response as we go */\n\tCHECKCLEARTOWRITE();\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_INFO_RESPONSE);\n\tbuf_putint(ses.writepayload, num_prompts);\n\n\tif (strlen(name) > 0) {\n\t\tcleantext(name);\n\t\tfprintf(stderr, \"%s\", name);\n\t}\n\tm_free(name);\n\n\tif (strlen(instruction) > 0) {\n\t\tcleantext(instruction);\n\t\tfprintf(stderr, \"%s\", instruction);\n\t}\n\tm_free(instruction);\n\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tcli_ses.is_trivial_auth = 0;\n\t\tunsigned int response_len = 0;\n\t\tprompt = buf_getstring(ses.payload, NULL);\n\t\tcleantext(prompt);\n\n\t\techo = buf_getbool(ses.payload);\n\n\t\tif (!echo) {\n\t\t\tchar* p = getpass_or_cancel(prompt);\n\t\t\tresponse = m_strdup(p);\n\t\t\tm_burn(p, strlen(p));\n\t\t} else {\n\t\t\tresponse = get_response(prompt);\n\t\t}\n\n\t\tresponse_len = strlen(response);\n\t\tbuf_putstring(ses.writepayload, response, response_len);\n\t\tm_burn(response, response_len);\n\t\tm_free(prompt);\n\t\tm_free(response);\n\t}\n\n\tencrypt_packet();\n\n\n\tTRACE((\"leave recv_msg_recv_userauth_info_request\"))\n}",
  "abstract_func": "void recv_msg_userauth_info_request() {\n\n\tchar *VAR_0 = NULL;\n\tchar *VAR_1 = NULL;\n\tunsigned int VAR_2 = 0;\n\tunsigned int VAR_3;\n\n\tchar *VAR_4 = NULL;\n\tunsigned int VAR_5 = 0;\n\tchar *VAR_6 = NULL;\n\n\tTRACE((\"enter recv_msg_recv_userauth_info_request\"))\n\n\t/* COMMENT_0 */\n\tif (!VAR_7.interact_request_received) {\n\t\tfprintf(VAR_8, \"Login for %s@%s\\n\", VAR_9.username,\n\t\t\t\tVAR_9.remotehost);\n\t}\n\tVAR_7.interact_request_received = 1;\n\n\tVAR_0 = buf_getstring(VAR_10.payload, NULL);\n\tVAR_1 = buf_getstring(VAR_10.payload, NULL);\n\n\t/* COMMENT_1 */\n\tbuf_eatstring(VAR_10.payload);\n\n\tVAR_2 = buf_getint(VAR_10.payload);\n\t\n\tif (VAR_2 >= VAR_11) {\n\t\tdropbear_exit(\"Too many prompts received for keyboard-interactive\");\n\t}\n\n\t/* COMMENT_2 */\n\tCHECKCLEARTOWRITE();\n\tbuf_putbyte(VAR_10.writepayload, VAR_12);\n\tbuf_putint(VAR_10.writepayload, VAR_2);\n\n\tif (strlen(VAR_0) > 0) {\n\t\tcleantext(VAR_0);\n\t\tfprintf(VAR_8, \"%s\", VAR_0);\n\t}\n\tm_free(VAR_0);\n\n\tif (strlen(VAR_1) > 0) {\n\t\tcleantext(VAR_1);\n\t\tfprintf(VAR_8, \"%s\", VAR_1);\n\t}\n\tm_free(VAR_1);\n\n\tfor (VAR_3 = 0; VAR_3 < VAR_2; VAR_3++) {\n\t\tVAR_7.is_trivial_auth = 0;\n\t\tunsigned int VAR_13 = 0;\n\t\tVAR_4 = buf_getstring(VAR_10.payload, NULL);\n\t\tcleantext(VAR_4);\n\n\t\tVAR_5 = buf_getbool(VAR_10.payload);\n\n\t\tif (!VAR_5) {\n\t\t\tchar* VAR_14 = getpass_or_cancel(VAR_4);\n\t\t\tVAR_6 = m_strdup(VAR_14);\n\t\t\tm_burn(VAR_14, strlen(VAR_14));\n\t\t} else {\n\t\t\tVAR_6 = get_response(VAR_4);\n\t\t}\n\n\t\tVAR_13 = strlen(VAR_6);\n\t\tbuf_putstring(VAR_10.writepayload, VAR_6, VAR_13);\n\t\tm_burn(VAR_6, VAR_13);\n\t\tm_free(VAR_4);\n\t\tm_free(VAR_6);\n\t}\n\n\tencrypt_packet();\n\n\n\tTRACE((\"leave recv_msg_recv_userauth_info_request\"))\n}",
  "func_graph_path": "mkj/dropbear/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c/cli-authinteract.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -48,6 +48,7 @@\n \tm_free(instruction);\n \n \tfor (i = 0; i < num_prompts; i++) {\n+\t\tcli_ses.is_trivial_auth = 0;\n \t\tunsigned int response_len = 0;\n \t\tprompt = buf_getstring(ses.payload, NULL);\n \t\tcleantext(prompt);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\tcli_ses.is_trivial_auth = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mkj/dropbear/pull/128",
  "description": {
    "pr_info": {
      "title": "added option to disable trivial auth methods",
      "number": 128
    },
    "comment": [
      "I have added an option ``-o ExitOnTrivialAuth=yes`` to disable trivial authentications as discussed in our mails",
      "I have renamed to argument to ``-o DisableTrivialAuth=yes`` to match OpenSSH's parameter",
      "Would you merge this pull request, because we are planning to create a CVE and I think this should be mitigated before we publish a full disclosure. ",
      "Hello, we are planning to release information about trivial succes authentication. Do you need help with merging the pull requests and creating the new release?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch introduces a new option to disable trivial authentication methods, which directly addresses a security concern by mitigating the risk of using weak authentication. The code changes and commit message are consistent, supporting the classification as a security fix.\n\n**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}