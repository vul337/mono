{
  "cve_id": "CVE-2023-25933",
  "cwe_ids": [
    "CWE-416",
    "CWE-843"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#960)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "e6ed9c1a4b02dc219de1648f44cd808a56171b81",
  "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
  "file_path": "lib/Optimizer/Scalar/TypeInference.cpp",
  "func_name": "inferBinaryInst",
  "func_before": "static bool inferBinaryInst(BinaryOperatorInst *BOI) {\n  switch (BOI->getOperatorKind()) {\n    // The following operations always return a boolean result.\n    // They may throw, they may read/write memory, but the result of the\n    // operation must be a boolean.\n    case BinaryOperatorInst::OpKind::EqualKind:\n    case BinaryOperatorInst::OpKind::NotEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyNotEqualKind:\n    case BinaryOperatorInst::OpKind::LessThanKind:\n    case BinaryOperatorInst::OpKind::LessThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::GreaterThanKind:\n    case BinaryOperatorInst::OpKind::GreaterThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::InKind:\n    case BinaryOperatorInst::OpKind::InstanceOfKind:\n      // Notice that the spec says that comparison of NaN should return\n      // \"Undefined\" but all VMs return 'false'. We decided to conform to the\n      // current implementation and not to the spec.\n      BOI->setType(Type::createBoolean());\n      return true;\n\n    // These arithmetic operations always return a number or bigint:\n    // https://262.ecma-international.org/#sec-multiplicative-operators\n    case BinaryOperatorInst::OpKind::DivideKind:\n    case BinaryOperatorInst::OpKind::MultiplyKind:\n    // https://tc39.es/ecma262/#sec-subtraction-operator-minus\n    case BinaryOperatorInst::OpKind::SubtractKind:\n    // https://tc39.es/ecma262/#sec-left-shift-operator\n    case BinaryOperatorInst::OpKind::LeftShiftKind:\n    // https://tc39.es/ecma262/#sec-signed-right-shift-operator\n    case BinaryOperatorInst::OpKind::RightShiftKind:\n      return inferBinaryArith(BOI);\n\n    case BinaryOperatorInst::OpKind::ModuloKind:\n      return inferBinaryArith(BOI, Type::createInt32());\n\n    // https://es5.github.io/#x11.7.3\n    case BinaryOperatorInst::OpKind::UnsignedRightShiftKind:\n      BOI->setType(Type::createUint32());\n      return true;\n\n    // The Add operator is special:\n    // https://262.ecma-international.org/#sec-addition-operator-plus\n    case BinaryOperatorInst::OpKind::AddKind: {\n      Type LeftTy = BOI->getLeftHandSide()->getType();\n      Type RightTy = BOI->getRightHandSide()->getType();\n      // String + String -> String. It is enough for one of the operands to be\n      // a string to force the result to be a string.\n      if (LeftTy.isStringType() || RightTy.isStringType()) {\n        BOI->setType(Type::createString());\n        return true;\n      }\n\n      // Number + Number -> Number.\n      if (LeftTy.isNumberType() && RightTy.isNumberType()) {\n        BOI->setType(Type::createNumber());\n        return true;\n      }\n\n      // BigInt + BigInt -> BigInt.\n      if (LeftTy.isBigIntType() && RightTy.isBigIntType()) {\n        BOI->setType(Type::createBigInt());\n        return true;\n      }\n\n      // ?BigInt + ?BigInt => ?BigInt. Both operands need to \"may be a BigInt\"\n      // for a possible BigInt result from this operator. This is true because\n      // there's no automative BigInt type conversion.\n      Type mayBeBigInt = (LeftTy.canBeBigInt() && RightTy.canBeBigInt())\n          ? Type::createBigInt()\n          : Type::createNoType();\n\n      // handy alias for number|maybe(BigInt).\n      Type numeric = Type::unionTy(Type::createNumber(), mayBeBigInt);\n\n      // If both sides of the binary operand are known and both sides are known\n      // to be non-string (and can't be converted to strings) then the result\n      // must be of a numeric type.\n      if (isSideEffectFree(LeftTy) && isSideEffectFree(RightTy) &&\n          !LeftTy.canBeString() && !RightTy.canBeString()) {\n        BOI->setType(numeric);\n        return true;\n      }\n\n      // The plus operator always returns a number, bigint, or a string.\n      BOI->setType(Type::unionTy(numeric, Type::createString()));\n      return false;\n    }\n\n    // https://tc39.es/ecma262/#sec-binary-bitwise-operators\n    case BinaryOperatorInst::OpKind::AndKind:\n    case BinaryOperatorInst::OpKind::OrKind:\n    case BinaryOperatorInst::OpKind::XorKind:\n      return inferBinaryBitwise(BOI);\n\n    default:\n      break;\n  }\n  return false;\n}",
  "abstract_func_before": "static bool inferBinaryInst(BinaryOperatorInst *VAR_0) {\n  switch (VAR_0->getOperatorKind()) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    case BinaryOperatorInst::OpKind::EqualKind:\n    case BinaryOperatorInst::OpKind::NotEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyNotEqualKind:\n    case BinaryOperatorInst::OpKind::LessThanKind:\n    case BinaryOperatorInst::OpKind::LessThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::GreaterThanKind:\n    case BinaryOperatorInst::OpKind::GreaterThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::InKind:\n    case BinaryOperatorInst::OpKind::InstanceOfKind:\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      VAR_0->setType(Type::createBoolean());\n      return true;\n\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    case BinaryOperatorInst::OpKind::DivideKind:\n    case BinaryOperatorInst::OpKind::MultiplyKind:\n    /* COMMENT_8 */\n    case BinaryOperatorInst::OpKind::SubtractKind:\n    /* COMMENT_9 */\n    case BinaryOperatorInst::OpKind::LeftShiftKind:\n    /* COMMENT_10 */\n    case BinaryOperatorInst::OpKind::RightShiftKind:\n      return inferBinaryArith(VAR_0);\n\n    case BinaryOperatorInst::OpKind::ModuloKind:\n      return inferBinaryArith(VAR_0, Type::createInt32());\n\n    /* COMMENT_11 */\n    case BinaryOperatorInst::OpKind::UnsignedRightShiftKind:\n      VAR_0->setType(Type::createUint32());\n      return true;\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    case BinaryOperatorInst::OpKind::AddKind: {\n      Type VAR_1 = VAR_0->getLeftHandSide()->getType();\n      Type VAR_2 = VAR_0->getRightHandSide()->getType();\n      /* COMMENT_14 */\n      /* COMMENT_15 */\n      if (VAR_1.isStringType() || VAR_2.isStringType()) {\n        VAR_0->setType(Type::createString());\n        return true;\n      }\n\n      /* COMMENT_16 */\n      if (VAR_1.isNumberType() && VAR_2.isNumberType()) {\n        VAR_0->setType(Type::createNumber());\n        return true;\n      }\n\n      /* COMMENT_17 */\n      if (VAR_1.isBigIntType() && VAR_2.isBigIntType()) {\n        VAR_0->setType(Type::createBigInt());\n        return true;\n      }\n\n      /* COMMENT_18 */\n      /* COMMENT_19 */\n      /* COMMENT_20 */\n      Type VAR_3 = (VAR_1.canBeBigInt() && VAR_2.canBeBigInt())\n          ? Type::createBigInt()\n          : Type::createNoType();\n\n      /* COMMENT_21 */\n      Type VAR_4 = Type::unionTy(Type::createNumber(), VAR_3);\n\n      /* COMMENT_22 */\n      /* COMMENT_23 */\n      /* COMMENT_24 */\n      if (isSideEffectFree(VAR_1) && isSideEffectFree(VAR_2) &&\n          !VAR_1.canBeString() && !VAR_2.canBeString()) {\n        VAR_0->setType(VAR_4);\n        return true;\n      }\n\n      /* COMMENT_25 */\n      VAR_0->setType(Type::unionTy(VAR_4, Type::createString()));\n      return false;\n    }\n\n    /* COMMENT_26 */\n    case BinaryOperatorInst::OpKind::AndKind:\n    case BinaryOperatorInst::OpKind::OrKind:\n    case BinaryOperatorInst::OpKind::XorKind:\n      return inferBinaryBitwise(VAR_0);\n\n    default:\n      break;\n  }\n  return false;\n}",
  "func_graph_path_before": "facebook/hermes/e6ed9c1a4b02dc219de1648f44cd808a56171b81/TypeInference.cpp/vul/before/2.json",
  "func": "static bool inferBinaryInst(BinaryOperatorInst *BOI) {\n  switch (BOI->getOperatorKind()) {\n    // The following operations always return a boolean result.\n    // They may throw, they may read/write memory, but the result of the\n    // operation must be a boolean.\n    case BinaryOperatorInst::OpKind::EqualKind:\n    case BinaryOperatorInst::OpKind::NotEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyNotEqualKind:\n    case BinaryOperatorInst::OpKind::LessThanKind:\n    case BinaryOperatorInst::OpKind::LessThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::GreaterThanKind:\n    case BinaryOperatorInst::OpKind::GreaterThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::InKind:\n    case BinaryOperatorInst::OpKind::InstanceOfKind:\n      // Notice that the spec says that comparison of NaN should return\n      // \"Undefined\" but all VMs return 'false'. We decided to conform to the\n      // current implementation and not to the spec.\n      BOI->setType(Type::createBoolean());\n      return true;\n\n    // These arithmetic operations always return a number or bigint:\n    // https://262.ecma-international.org/#sec-multiplicative-operators\n    case BinaryOperatorInst::OpKind::DivideKind:\n    case BinaryOperatorInst::OpKind::MultiplyKind:\n    // https://tc39.es/ecma262/#sec-subtraction-operator-minus\n    case BinaryOperatorInst::OpKind::SubtractKind:\n    // https://tc39.es/ecma262/#sec-left-shift-operator\n    case BinaryOperatorInst::OpKind::LeftShiftKind:\n    // https://tc39.es/ecma262/#sec-signed-right-shift-operator\n    case BinaryOperatorInst::OpKind::RightShiftKind:\n      return inferBinaryArith(BOI);\n\n    case BinaryOperatorInst::OpKind::ModuloKind:\n      return inferBinaryArith(BOI, Type::createInt32());\n\n    // https://es5.github.io/#x11.7.3\n    case BinaryOperatorInst::OpKind::UnsignedRightShiftKind:\n      BOI->setType(Type::createUint32());\n      return true;\n\n    // The Add operator is special:\n    // https://262.ecma-international.org/#sec-addition-operator-plus\n    case BinaryOperatorInst::OpKind::AddKind: {\n      Type LeftTy = BOI->getLeftHandSide()->getType();\n      Type RightTy = BOI->getRightHandSide()->getType();\n      // String + String -> String. It is enough for one of the operands to be\n      // a string to force the result to be a string.\n      if (LeftTy.isStringType() || RightTy.isStringType()) {\n        BOI->setType(Type::createString());\n        return true;\n      }\n\n      // Number + Number -> Number.\n      if (LeftTy.isNumberType() && RightTy.isNumberType()) {\n        BOI->setType(Type::createNumber());\n        return true;\n      }\n\n      // BigInt + BigInt -> BigInt.\n      if (LeftTy.isBigIntType() && RightTy.isBigIntType()) {\n        BOI->setType(Type::createBigInt());\n        return true;\n      }\n\n      // ?BigInt + ?BigInt => ?BigInt. Both operands need to \"may be a BigInt\"\n      // for a possible BigInt result from this operator. This is true because\n      // there's no automative BigInt type conversion.\n      Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n          ? Type::createBigInt()\n          : Type::createNoType();\n\n      // handy alias for number|maybe(BigInt).\n      Type numeric = Type::unionTy(Type::createNumber(), mayBeBigInt);\n\n      // If both sides of the binary operand are known and both sides are known\n      // to be non-string (and can't be converted to strings) then the result\n      // must be of a numeric type.\n      if (isSideEffectFree(LeftTy) && isSideEffectFree(RightTy) &&\n          !LeftTy.canBeString() && !RightTy.canBeString()) {\n        BOI->setType(numeric);\n        return true;\n      }\n\n      // The plus operator always returns a number, bigint, or a string.\n      BOI->setType(Type::unionTy(numeric, Type::createString()));\n      return false;\n    }\n\n    // https://tc39.es/ecma262/#sec-binary-bitwise-operators\n    case BinaryOperatorInst::OpKind::AndKind:\n    case BinaryOperatorInst::OpKind::OrKind:\n    case BinaryOperatorInst::OpKind::XorKind:\n      return inferBinaryBitwise(BOI);\n\n    default:\n      break;\n  }\n  return false;\n}",
  "abstract_func": "static bool inferBinaryInst(BinaryOperatorInst *VAR_0) {\n  switch (VAR_0->getOperatorKind()) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    case BinaryOperatorInst::OpKind::EqualKind:\n    case BinaryOperatorInst::OpKind::NotEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyNotEqualKind:\n    case BinaryOperatorInst::OpKind::LessThanKind:\n    case BinaryOperatorInst::OpKind::LessThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::GreaterThanKind:\n    case BinaryOperatorInst::OpKind::GreaterThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::InKind:\n    case BinaryOperatorInst::OpKind::InstanceOfKind:\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      VAR_0->setType(Type::createBoolean());\n      return true;\n\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    case BinaryOperatorInst::OpKind::DivideKind:\n    case BinaryOperatorInst::OpKind::MultiplyKind:\n    /* COMMENT_8 */\n    case BinaryOperatorInst::OpKind::SubtractKind:\n    /* COMMENT_9 */\n    case BinaryOperatorInst::OpKind::LeftShiftKind:\n    /* COMMENT_10 */\n    case BinaryOperatorInst::OpKind::RightShiftKind:\n      return inferBinaryArith(VAR_0);\n\n    case BinaryOperatorInst::OpKind::ModuloKind:\n      return inferBinaryArith(VAR_0, Type::createInt32());\n\n    /* COMMENT_11 */\n    case BinaryOperatorInst::OpKind::UnsignedRightShiftKind:\n      VAR_0->setType(Type::createUint32());\n      return true;\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    case BinaryOperatorInst::OpKind::AddKind: {\n      Type VAR_1 = VAR_0->getLeftHandSide()->getType();\n      Type VAR_2 = VAR_0->getRightHandSide()->getType();\n      /* COMMENT_14 */\n      /* COMMENT_15 */\n      if (VAR_1.isStringType() || VAR_2.isStringType()) {\n        VAR_0->setType(Type::createString());\n        return true;\n      }\n\n      /* COMMENT_16 */\n      if (VAR_1.isNumberType() && VAR_2.isNumberType()) {\n        VAR_0->setType(Type::createNumber());\n        return true;\n      }\n\n      /* COMMENT_17 */\n      if (VAR_1.isBigIntType() && VAR_2.isBigIntType()) {\n        VAR_0->setType(Type::createBigInt());\n        return true;\n      }\n\n      /* COMMENT_18 */\n      /* COMMENT_19 */\n      /* COMMENT_20 */\n      Type VAR_3 = (isBigIntOrObject(VAR_1) && isBigIntOrObject(VAR_2))\n          ? Type::createBigInt()\n          : Type::createNoType();\n\n      /* COMMENT_21 */\n      Type VAR_4 = Type::unionTy(Type::createNumber(), VAR_3);\n\n      /* COMMENT_22 */\n      /* COMMENT_23 */\n      /* COMMENT_24 */\n      if (isSideEffectFree(VAR_1) && isSideEffectFree(VAR_2) &&\n          !VAR_1.canBeString() && !VAR_2.canBeString()) {\n        VAR_0->setType(VAR_4);\n        return true;\n      }\n\n      /* COMMENT_25 */\n      VAR_0->setType(Type::unionTy(VAR_4, Type::createString()));\n      return false;\n    }\n\n    /* COMMENT_26 */\n    case BinaryOperatorInst::OpKind::AndKind:\n    case BinaryOperatorInst::OpKind::OrKind:\n    case BinaryOperatorInst::OpKind::XorKind:\n      return inferBinaryBitwise(VAR_0);\n\n    default:\n      break;\n  }\n  return false;\n}",
  "func_graph_path": "facebook/hermes/e6ed9c1a4b02dc219de1648f44cd808a56171b81/TypeInference.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n       // ?BigInt + ?BigInt => ?BigInt. Both operands need to \"may be a BigInt\"\n       // for a possible BigInt result from this operator. This is true because\n       // there's no automative BigInt type conversion.\n-      Type mayBeBigInt = (LeftTy.canBeBigInt() && RightTy.canBeBigInt())\n+      Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n           ? Type::createBigInt()\n           : Type::createNoType();\n ",
  "diff_line_info": {
    "deleted_lines": [
      "      Type mayBeBigInt = (LeftTy.canBeBigInt() && RightTy.canBeBigInt())"
    ],
    "added_lines": [
      "      Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/960",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 960
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.95  \n\nThe patch addresses a core type inference issue by adjusting how BigInts are handled, indicating a defect remediation rather than a security fix."
}