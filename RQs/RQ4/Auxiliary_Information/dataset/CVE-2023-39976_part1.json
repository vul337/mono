{
  "cve_id": "CVE-2023-39976",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "ClusterLabs/libqb",
  "commit_msg": "log: fix potential overflow with long log messages (#490)\n\nqb_vsnprintf_serialize was called with 'max_size' as the\r\nlimiting number for the length of the formatted log\r\nmessage. But the buffer also needs to contain the\r\nlog header (given by 'actual_size'), so we now pass\r\n't->max_line_length' as the maximum length of the\r\nformatted log message to limit space to the actual \r\nbytes left\r\n\r\nAlso added error checks to the blackbox calls at\r\nthe end of the test, as these now provide a proper\r\ntest that the BB is functioning. Before they were\r\nmasking failures.",
  "commit_hash": "1bbaa929b77113532785c408dd1b41cd0521ffc8",
  "git_url": "https://github.com/ClusterLabs/libqb/commit/1bbaa929b77113532785c408dd1b41cd0521ffc8",
  "file_path": "lib/log_blackbox.c",
  "func_name": "_blackbox_vlogger",
  "func_before": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
  "abstract_func_before": "static void\n_blackbox_vlogger(int32_t VAR_0,\n\t\t  struct qb_log_callsite *VAR_1, struct timespec *VAR_2, va_list VAR_3)\n{\n\tsize_t VAR_4;\n\tsize_t VAR_5;\n\tuint32_t VAR_6;\n\tchar *VAR_7;\n\tchar *VAR_8;\n\tuint32_t VAR_9;\n\tstruct qb_log_target *VAR_10 = qb_log_target_get(VAR_0);\n\n\tif (VAR_10->instance == NULL) {\n\t\treturn;\n\t}\n\n\tVAR_6 = strlen(VAR_1->function) + 1;\n\n\tVAR_5 = 4 * sizeof(uint32_t) + sizeof(uint8_t) + VAR_6 + sizeof(struct timespec);\n\tVAR_4 = VAR_5 + VAR_10->max_line_length;\n\n\tVAR_7 = qb_rb_chunk_alloc(VAR_10->instance, VAR_4);\n\n\tif (VAR_7 == NULL) {\n\t\t/* COMMENT_0 */\n\t\tqb_util_perror(VAR_11, \"Blackbox allocation error, aborting blackbox log %s\", VAR_10->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &VAR_10->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* COMMENT_1 */\n\tmemcpy(VAR_7, &VAR_1->lineno, sizeof(uint32_t));\n\tVAR_7 += sizeof(uint32_t);\n\n\t/* COMMENT_2 */\n\tmemcpy(VAR_7, &VAR_1->tags, sizeof(uint32_t));\n\tVAR_7 += sizeof(uint32_t);\n\n\t/* COMMENT_3 */\n\tmemcpy(VAR_7, &VAR_1->priority, sizeof(uint8_t));\n\tVAR_7 += sizeof(uint8_t);\n\n\t/* COMMENT_4 */\n\tmemcpy(VAR_7, &VAR_6, sizeof(uint32_t));\n\tVAR_7 += sizeof(uint32_t);\n\tmemcpy(VAR_7, VAR_1->function, VAR_6);\n\tVAR_7 += VAR_6;\n\n\t/* COMMENT_5 */\n\tmemcpy(VAR_7, VAR_2, sizeof(struct timespec));\n\tVAR_7 += sizeof(struct timespec);\n\n\t/* COMMENT_6 */\n\tVAR_8 = VAR_7;\n\tVAR_7 += sizeof(uint32_t);\n\n\t/* COMMENT_7 */\n\tVAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_4, VAR_1->format, VAR_3);\n\tif (VAR_9 >= VAR_4) {\n\t    VAR_7 = VAR_8 + sizeof(uint32_t); /* COMMENT_8 */\n\n\t    /* COMMENT_9 */\n\t    VAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_12,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , VAR_3);\n\t}\n\n\tVAR_5 += VAR_9;\n\n\t/* COMMENT_10 */\n    \n\tmemcpy(VAR_8, &VAR_9, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(VAR_10->instance, VAR_5);\n}",
  "func_graph_path_before": "ClusterLabs/libqb/1bbaa929b77113532785c408dd1b41cd0521ffc8/log_blackbox.c/vul/before/0.json",
  "func": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);\n\tif (msg_len >= t->max_line_length) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
  "abstract_func": "static void\n_blackbox_vlogger(int32_t VAR_0,\n\t\t  struct qb_log_callsite *VAR_1, struct timespec *VAR_2, va_list VAR_3)\n{\n\tsize_t VAR_4;\n\tsize_t VAR_5;\n\tuint32_t VAR_6;\n\tchar *VAR_7;\n\tchar *VAR_8;\n\tuint32_t VAR_9;\n\tstruct qb_log_target *VAR_10 = qb_log_target_get(VAR_0);\n\n\tif (VAR_10->instance == NULL) {\n\t\treturn;\n\t}\n\n\tVAR_6 = strlen(VAR_1->function) + 1;\n\n\tVAR_5 = 4 * sizeof(uint32_t) + sizeof(uint8_t) + VAR_6 + sizeof(struct timespec);\n\tVAR_4 = VAR_5 + VAR_10->max_line_length;\n\n\tVAR_7 = qb_rb_chunk_alloc(VAR_10->instance, VAR_4);\n\n\tif (VAR_7 == NULL) {\n\t\t/* COMMENT_0 */\n\t\tqb_util_perror(VAR_11, \"Blackbox allocation error, aborting blackbox log %s\", VAR_10->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &VAR_10->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* COMMENT_1 */\n\tmemcpy(VAR_7, &VAR_1->lineno, sizeof(uint32_t));\n\tVAR_7 += sizeof(uint32_t);\n\n\t/* COMMENT_2 */\n\tmemcpy(VAR_7, &VAR_1->tags, sizeof(uint32_t));\n\tVAR_7 += sizeof(uint32_t);\n\n\t/* COMMENT_3 */\n\tmemcpy(VAR_7, &VAR_1->priority, sizeof(uint8_t));\n\tVAR_7 += sizeof(uint8_t);\n\n\t/* COMMENT_4 */\n\tmemcpy(VAR_7, &VAR_6, sizeof(uint32_t));\n\tVAR_7 += sizeof(uint32_t);\n\tmemcpy(VAR_7, VAR_1->function, VAR_6);\n\tVAR_7 += VAR_6;\n\n\t/* COMMENT_5 */\n\tmemcpy(VAR_7, VAR_2, sizeof(struct timespec));\n\tVAR_7 += sizeof(struct timespec);\n\n\t/* COMMENT_6 */\n\tVAR_8 = VAR_7;\n\tVAR_7 += sizeof(uint32_t);\n\n\t/* COMMENT_7 */\n\tVAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_10->max_line_length, VAR_1->format, VAR_3);\n\tif (VAR_9 >= VAR_10->max_line_length) {\n\t    VAR_7 = VAR_8 + sizeof(uint32_t); /* COMMENT_8 */\n\n\t    /* COMMENT_9 */\n\t    VAR_9 = qb_vsnprintf_serialize(VAR_7, VAR_12,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , VAR_3);\n\t}\n\n\tVAR_5 += VAR_9;\n\n\t/* COMMENT_10 */\n    \n\tmemcpy(VAR_8, &VAR_9, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(VAR_10->instance, VAR_5);\n}",
  "func_graph_path": "ClusterLabs/libqb/1bbaa929b77113532785c408dd1b41cd0521ffc8/log_blackbox.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -57,8 +57,8 @@\n \tchunk += sizeof(uint32_t);\n \n \t/* log message */\n-\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n-\tif (msg_len >= max_size) {\n+\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);\n+\tif (msg_len >= t->max_line_length) {\n \t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n \n \t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */",
  "diff_line_info": {
    "deleted_lines": [
      "\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);",
      "\tif (msg_len >= max_size) {"
    ],
    "added_lines": [
      "\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);",
      "\tif (msg_len >= t->max_line_length) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ClusterLabs/libqb/pull/490",
  "description": {
    "pr_info": {
      "title": "log: fix potential overflow with long log messages",
      "number": 490
    },
    "comment": [
      "qb_vsnprintf_serialize was called with 'max_size' as the limiting number for the length of the formatted log message. But the buffer also needs to contain the\r\nlog header (given by 'actual_size'), so we now pass 'max_size - actual_size' as the maximum length of the formatted log message.\r\n\r\nAlso added error checks to the blacbkbox calls at\r\nthe end of the test, as these now provide a proper test that the BB is functioning. Before they were\r\nmasking failures.",
      "The ellipsis code has been in there for ages, but it needs to be enabled:\r\n\r\n        rc = qb_log_ctl(t, QB_LOG_CONF_ELLIPSIS, QB_TRUE);\r\n\r\n0ec02f9ac589e9e21e447f4406ec104ade01ef73\r\n\r\n",
      "> The ellipsis code has been in there for ages, but it needs to be enabled:\r\n> \r\n> ```\r\n>     rc = qb_log_ctl(t, QB_LOG_CONF_ELLIPSIS, QB_TRUE);\r\n> ```\r\n> \r\n> [0ec02f9](https://github.com/ClusterLabs/libqb/commit/0ec02f9ac589e9e21e447f4406ec104ade01ef73)\r\n\r\nlog_blackbox.c doesn't use qb_log_target_format() (I'm not familiar enough with the code to know why not), so the ellipsis code isn't hit"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nStep-by-step explanation:\n\n1. **Input Analysis:** The commit message describes modifying how a function handles log messages to prevent overflow by adjusting the max size. The vulnerability description aligns, detailing the same overflow issue, and the code diff shows changing the function's limit from `max_size` to `t->max_line_length`.\n\n2. **Consistency Check:** The commit message and code changes are consistent. The fix addresses buffer overflow by correctly limiting the log message size.\n\n3. **Purpose Evaluation:** The code change modifies core logic to prevent a buffer overflow, indicating a security concern.\n\n4. **Security Assessment:** The fix addresses a buffer overflow, an exploitable weakness. It involves adjusting the maximum allowed log message size to prevent the buffer from being exceeded.\n\n5. **Confidence:** All information is clear and consistent, confirming the fix addresses a security issue.\n\n```plaintext\nFinal Classification: Security Vulnerability Fix\nConfidence: 1.0\n```"
}