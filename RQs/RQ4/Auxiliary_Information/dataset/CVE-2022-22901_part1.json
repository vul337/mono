{
  "cve_id": "CVE-2022-22901",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Fix class static block opening brace parsing\n\nThe next character should not be consumed after finding the static block opening brace.\nThis patch fixes #4916.\n\nJerryScript-DCO-1.0-Signed-off-by: Martin Negyokru negyokru@inf.u-szeged.hu",
  "commit_hash": "5e1fdd1d1e75105b43392b4bb3996099cdc50f3d",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/5e1fdd1d1e75105b43392b4bb3996099cdc50f3d",
  "file_path": "jerry-core/parser/js/js-lexer.c",
  "func_name": "lexer_expect_object_literal_id",
  "func_before": "void\nlexer_expect_object_literal_id (parser_context_t *context_p, /**< context */\n                                uint32_t ident_opts) /**< lexer_obj_ident_opts_t option bits */\n{\n  lexer_skip_spaces (context_p);\n\n  if (context_p->source_p >= context_p->source_end_p)\n  {\n    parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n  }\n\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  bool create_literal_object = false;\n\n  JERRY_ASSERT ((ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER) || !(ident_opts & LEXER_OBJ_IDENT_CLASS_NO_STATIC));\n\n#if JERRY_FUNCTION_TO_STRING\n  if (ident_opts & LEXER_OBJ_IDENT_SET_FUNCTION_START)\n  {\n    context_p->function_start_p = context_p->source_p;\n  }\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n  if (lexer_parse_identifier (context_p, LEXER_PARSE_NO_OPTS))\n  {\n    if (!(ident_opts & (LEXER_OBJ_IDENT_ONLY_IDENTIFIERS | LEXER_OBJ_IDENT_OBJECT_PATTERN)))\n    {\n      lexer_skip_spaces (context_p);\n      context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n\n      if (context_p->source_p < context_p->source_end_p\n#if JERRY_ESNEXT\n          && context_p->source_p[0] != LIT_CHAR_COMMA && context_p->source_p[0] != LIT_CHAR_RIGHT_BRACE\n          && context_p->source_p[0] != LIT_CHAR_LEFT_PAREN && context_p->source_p[0] != LIT_CHAR_SEMICOLON\n          && context_p->source_p[0] != LIT_CHAR_EQUALS\n#endif /* JERRY_ESNEXT */\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_literal_to_string (context_p, \"get\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n          return;\n        }\n\n        if (lexer_compare_literal_to_string (context_p, \"set\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n          return;\n        }\n\n#if JERRY_ESNEXT\n        if (lexer_compare_literal_to_string (context_p, \"async\", 5))\n        {\n          context_p->token.type = LEXER_KEYW_ASYNC;\n          return;\n        }\n\n        if (ident_opts & LEXER_OBJ_IDENT_CLASS_NO_STATIC)\n        {\n          if (lexer_compare_literal_to_string (context_p, \"static\", 6))\n          {\n            context_p->token.type = LEXER_KEYW_STATIC;\n          }\n          return;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n    }\n\n    create_literal_object = true;\n  }\n#if JERRY_ESNEXT\n  else if (ident_opts & LEXER_OBJ_IDENT_CLASS_PRIVATE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);\n  }\n#endif /* JERRY_ESNEXT */\n  else\n  {\n    switch (context_p->source_p[0])\n    {\n      case LIT_CHAR_DOUBLE_QUOTE:\n      case LIT_CHAR_SINGLE_QUOTE:\n      {\n        lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n        create_literal_object = true;\n        break;\n      }\n#if JERRY_ESNEXT\n      case LIT_CHAR_LEFT_SQUARE:\n      {\n#if JERRY_FUNCTION_TO_STRING\n        const uint8_t *function_start_p = context_p->function_start_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n        lexer_consume_next_character (context_p);\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        if (context_p->token.type != LEXER_RIGHT_SQUARE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);\n        }\n\n#if JERRY_FUNCTION_TO_STRING\n        context_p->function_start_p = function_start_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n        return;\n      }\n      case LIT_CHAR_ASTERISK:\n      {\n        if (ident_opts & (LEXER_OBJ_IDENT_ONLY_IDENTIFIERS | LEXER_OBJ_IDENT_OBJECT_PATTERN))\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_MULTIPLY;\n        lexer_consume_next_character (context_p);\n        return;\n      }\n      case LIT_CHAR_HASHMARK:\n      {\n        if (ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n        {\n          context_p->token.type = LEXER_HASHMARK;\n          return;\n        }\n\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n      case LIT_CHAR_LEFT_BRACE:\n      {\n        if (ident_opts & (LEXER_OBJ_IDENT_CLASS_NO_STATIC | LEXER_OBJ_IDENT_CLASS_PRIVATE))\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_LEFT_BRACE;\n        lexer_consume_next_character (context_p);\n        return;\n      }\n      case LIT_CHAR_RIGHT_BRACE:\n      {\n        if (ident_opts & LEXER_OBJ_IDENT_ONLY_IDENTIFIERS)\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_RIGHT_BRACE;\n        lexer_consume_next_character (context_p);\n        return;\n      }\n#if JERRY_ESNEXT\n      case LIT_CHAR_DOT:\n      {\n        if (!(context_p->source_p + 1 >= context_p->source_end_p || lit_char_is_decimal_digit (context_p->source_p[1])))\n        {\n          if ((ident_opts & ((uint32_t) ~(LEXER_OBJ_IDENT_OBJECT_PATTERN | LEXER_OBJ_IDENT_SET_FUNCTION_START)))\n              || context_p->source_p + 2 >= context_p->source_end_p || context_p->source_p[1] != LIT_CHAR_DOT\n              || context_p->source_p[2] != LIT_CHAR_DOT)\n          {\n            break;\n          }\n\n          context_p->token.type = LEXER_THREE_DOTS;\n          context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n          PARSER_PLUS_EQUAL_LC (context_p->column, 3);\n          context_p->source_p += 3;\n          return;\n        }\n        /* FALLTHRU */\n      }\n#endif /* JERRY_ESNEXT */\n      default:\n      {\n        const uint8_t *char_p = context_p->source_p;\n\n        if (char_p[0] == LIT_CHAR_DOT)\n        {\n          char_p++;\n        }\n\n        if (char_p < context_p->source_end_p && char_p[0] >= LIT_CHAR_0 && char_p[0] <= LIT_CHAR_9)\n        {\n          lexer_parse_number (context_p);\n\n          if (!(ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER))\n          {\n            lexer_construct_number_object (context_p, false, false);\n          }\n          return;\n        }\n        break;\n      }\n    }\n  }\n\n  if (create_literal_object)\n  {\n#if JERRY_ESNEXT\n    if (ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n    {\n      return;\n    }\n\n    if (ident_opts & LEXER_OBJ_IDENT_CLASS_PRIVATE)\n    {\n      parser_resolve_private_identifier (context_p);\n      return;\n    }\n#endif /* JERRY_ESNEXT */\n\n    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);\n    return;\n  }\n\n  parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n}",
  "abstract_func_before": "void\nlexer_expect_object_literal_id (parser_context_t *VAR_0, /* COMMENT_0 */\n                                uint32_t VAR_1) /* COMMENT_1 */\n{\n  lexer_skip_spaces (VAR_0);\n\n  if (VAR_0->source_p >= VAR_0->source_end_p)\n  {\n    parser_raise_error (VAR_0, VAR_2);\n  }\n\n  VAR_0->token.keyword_type = VAR_3;\n  VAR_0->token.line = VAR_0->line;\n  VAR_0->token.column = VAR_0->column;\n  bool VAR_4 = false;\n\n  JERRY_ASSERT ((VAR_1 & VAR_5) || !(VAR_1 & VAR_6));\n\n#if VAR_7\n  if (VAR_1 & VAR_8)\n  {\n    VAR_0->function_start_p = VAR_0->source_p;\n  }\n#endif /* COMMENT_2 */\n\n  if (lexer_parse_identifier (VAR_0, VAR_9))\n  {\n    if (!(VAR_1 & (VAR_10 | VAR_11)))\n    {\n      lexer_skip_spaces (VAR_0);\n      VAR_0->token.flags = (uint8_t) (VAR_0->token.flags | VAR_12);\n\n      if (VAR_0->source_p < VAR_0->source_end_p\n#if VAR_13\n          && VAR_0->source_p[0] != VAR_14 && VAR_0->source_p[0] != VAR_15\n          && VAR_0->source_p[0] != VAR_16 && VAR_0->source_p[0] != VAR_17\n          && VAR_0->source_p[0] != VAR_18\n#endif /* COMMENT_3 */\n          && VAR_0->source_p[0] != VAR_19)\n      {\n        if (lexer_compare_literal_to_string (VAR_0, \"get\", 3))\n        {\n          VAR_0->token.type = VAR_20;\n          return;\n        }\n\n        if (lexer_compare_literal_to_string (VAR_0, \"set\", 3))\n        {\n          VAR_0->token.type = VAR_21;\n          return;\n        }\n\n#if VAR_13\n        if (lexer_compare_literal_to_string (VAR_0, \"async\", 5))\n        {\n          VAR_0->token.type = VAR_22;\n          return;\n        }\n\n        if (VAR_1 & VAR_6)\n        {\n          if (lexer_compare_literal_to_string (VAR_0, \"static\", 6))\n          {\n            VAR_0->token.type = VAR_23;\n          }\n          return;\n        }\n#endif /* COMMENT_3 */\n      }\n    }\n\n    VAR_4 = true;\n  }\n#if VAR_13\n  else if (ident_opts & VAR_24)\n  {\n    parser_raise_error (VAR_0, VAR_25);\n  }\n#endif /* COMMENT_3 */\n  else\n  {\n    switch (VAR_0->source_p[0])\n    {\n      case VAR_26:\n      case VAR_27:\n      {\n        lexer_parse_string (VAR_0, VAR_28);\n        VAR_4 = true;\n        break;\n      }\n#if VAR_13\n      case VAR_29:\n      {\n#if VAR_7\n        const uint8_t *VAR_30 = VAR_0->function_start_p;\n#endif /* COMMENT_2 */\n\n        lexer_consume_next_character (VAR_0);\n\n        lexer_next_token (VAR_0);\n        parser_parse_expression (VAR_0, VAR_31);\n\n        if (VAR_0->token.type != VAR_32)\n        {\n          parser_raise_error (VAR_0, VAR_33);\n        }\n\n#if VAR_7\n        VAR_0->function_start_p = VAR_30;\n#endif /* COMMENT_2 */\n        return;\n      }\n      case VAR_34:\n      {\n        if (ident_opts & (VAR_10 | VAR_11))\n        {\n          break;\n        }\n\n        VAR_0->token.type = VAR_35;\n        lexer_consume_next_character (VAR_0);\n        return;\n      }\n      case VAR_36:\n      {\n        if (ident_opts & VAR_5)\n        {\n          VAR_0->token.type = VAR_37;\n          return;\n        }\n\n        break;\n      }\n#endif /* COMMENT_3 */\n      case VAR_38:\n      {\n        if (ident_opts & (VAR_6 | VAR_24))\n        {\n          break;\n        }\n\n        VAR_0->token.type = VAR_39;\n        lexer_consume_next_character (VAR_0);\n        return;\n      }\n      case VAR_15:\n      {\n        if (ident_opts & VAR_10)\n        {\n          break;\n        }\n\n        VAR_0->token.type = VAR_40;\n        lexer_consume_next_character (VAR_0);\n        return;\n      }\n#if VAR_13\n      case VAR_41:\n      {\n        if (!(VAR_0->source_p + 1 >= VAR_0->source_end_p || lit_char_is_decimal_digit (VAR_0->source_p[1])))\n        {\n          if ((ident_opts & ((uint32_t) ~(VAR_11 | VAR_8)))\n              || VAR_0->source_p + 2 >= VAR_0->source_end_p || VAR_0->source_p[1] != VAR_41\n              || VAR_0->source_p[2] != VAR_41)\n          {\n            break;\n          }\n\n          VAR_0->token.type = VAR_42;\n          VAR_0->token.flags &= (uint8_t) ~VAR_12;\n          PARSER_PLUS_EQUAL_LC (VAR_0->column, 3);\n          VAR_0->source_p += 3;\n          return;\n        }\n        /* COMMENT_4 */\n      }\n#endif /* COMMENT_3 */\n      default:\n      {\n        const uint8_t *VAR_43 = VAR_0->source_p;\n\n        if (VAR_43[0] == VAR_41)\n        {\n          VAR_43++;\n        }\n\n        if (VAR_43 < VAR_0->source_end_p && VAR_43[0] >= VAR_44 && VAR_43[0] <= VAR_45)\n        {\n          lexer_parse_number (VAR_0);\n\n          if (!(ident_opts & VAR_5))\n          {\n            lexer_construct_number_object (VAR_0, false, false);\n          }\n          return;\n        }\n        break;\n      }\n    }\n  }\n\n  if (VAR_4)\n  {\n#if VAR_13\n    if (ident_opts & VAR_5)\n    {\n      return;\n    }\n\n    if (ident_opts & VAR_24)\n    {\n      parser_resolve_private_identifier (VAR_0);\n      return;\n    }\n#endif /* COMMENT_3 */\n\n    lexer_construct_literal_object (VAR_0, &VAR_0->token.lit_location, VAR_46);\n    return;\n  }\n\n  parser_raise_error (VAR_0, VAR_2);\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/5e1fdd1d1e75105b43392b4bb3996099cdc50f3d/js-lexer.c/vul/before/0.json",
  "func": "void\nlexer_expect_object_literal_id (parser_context_t *context_p, /**< context */\n                                uint32_t ident_opts) /**< lexer_obj_ident_opts_t option bits */\n{\n  lexer_skip_spaces (context_p);\n\n  if (context_p->source_p >= context_p->source_end_p)\n  {\n    parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n  }\n\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  bool create_literal_object = false;\n\n  JERRY_ASSERT ((ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER) || !(ident_opts & LEXER_OBJ_IDENT_CLASS_NO_STATIC));\n\n#if JERRY_FUNCTION_TO_STRING\n  if (ident_opts & LEXER_OBJ_IDENT_SET_FUNCTION_START)\n  {\n    context_p->function_start_p = context_p->source_p;\n  }\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n  if (lexer_parse_identifier (context_p, LEXER_PARSE_NO_OPTS))\n  {\n    if (!(ident_opts & (LEXER_OBJ_IDENT_ONLY_IDENTIFIERS | LEXER_OBJ_IDENT_OBJECT_PATTERN)))\n    {\n      lexer_skip_spaces (context_p);\n      context_p->token.flags = (uint8_t) (context_p->token.flags | LEXER_NO_SKIP_SPACES);\n\n      if (context_p->source_p < context_p->source_end_p\n#if JERRY_ESNEXT\n          && context_p->source_p[0] != LIT_CHAR_COMMA && context_p->source_p[0] != LIT_CHAR_RIGHT_BRACE\n          && context_p->source_p[0] != LIT_CHAR_LEFT_PAREN && context_p->source_p[0] != LIT_CHAR_SEMICOLON\n          && context_p->source_p[0] != LIT_CHAR_EQUALS\n#endif /* JERRY_ESNEXT */\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_literal_to_string (context_p, \"get\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n          return;\n        }\n\n        if (lexer_compare_literal_to_string (context_p, \"set\", 3))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n          return;\n        }\n\n#if JERRY_ESNEXT\n        if (lexer_compare_literal_to_string (context_p, \"async\", 5))\n        {\n          context_p->token.type = LEXER_KEYW_ASYNC;\n          return;\n        }\n\n        if (ident_opts & LEXER_OBJ_IDENT_CLASS_NO_STATIC)\n        {\n          if (lexer_compare_literal_to_string (context_p, \"static\", 6))\n          {\n            context_p->token.type = LEXER_KEYW_STATIC;\n          }\n          return;\n        }\n#endif /* JERRY_ESNEXT */\n      }\n    }\n\n    create_literal_object = true;\n  }\n#if JERRY_ESNEXT\n  else if (ident_opts & LEXER_OBJ_IDENT_CLASS_PRIVATE)\n  {\n    parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);\n  }\n#endif /* JERRY_ESNEXT */\n  else\n  {\n    switch (context_p->source_p[0])\n    {\n      case LIT_CHAR_DOUBLE_QUOTE:\n      case LIT_CHAR_SINGLE_QUOTE:\n      {\n        lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n        create_literal_object = true;\n        break;\n      }\n#if JERRY_ESNEXT\n      case LIT_CHAR_LEFT_SQUARE:\n      {\n#if JERRY_FUNCTION_TO_STRING\n        const uint8_t *function_start_p = context_p->function_start_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n\n        lexer_consume_next_character (context_p);\n\n        lexer_next_token (context_p);\n        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);\n\n        if (context_p->token.type != LEXER_RIGHT_SQUARE)\n        {\n          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);\n        }\n\n#if JERRY_FUNCTION_TO_STRING\n        context_p->function_start_p = function_start_p;\n#endif /* JERRY_FUNCTION_TO_STRING */\n        return;\n      }\n      case LIT_CHAR_ASTERISK:\n      {\n        if (ident_opts & (LEXER_OBJ_IDENT_ONLY_IDENTIFIERS | LEXER_OBJ_IDENT_OBJECT_PATTERN))\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_MULTIPLY;\n        lexer_consume_next_character (context_p);\n        return;\n      }\n      case LIT_CHAR_HASHMARK:\n      {\n        if (ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n        {\n          context_p->token.type = LEXER_HASHMARK;\n          return;\n        }\n\n        break;\n      }\n#endif /* JERRY_ESNEXT */\n      case LIT_CHAR_LEFT_BRACE:\n      {\n        const uint32_t static_block_flags =\n          (LEXER_OBJ_IDENT_CLASS_NO_STATIC | LEXER_OBJ_IDENT_CLASS_PRIVATE | LEXER_OBJ_IDENT_CLASS_IDENTIFIER);\n\n        if ((ident_opts & static_block_flags) == LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n        {\n          context_p->token.type = LEXER_LEFT_BRACE;\n          lexer_consume_next_character (context_p);\n          return;\n        }\n\n        break;\n      }\n      case LIT_CHAR_RIGHT_BRACE:\n      {\n        if (ident_opts & LEXER_OBJ_IDENT_ONLY_IDENTIFIERS)\n        {\n          break;\n        }\n\n        context_p->token.type = LEXER_RIGHT_BRACE;\n        lexer_consume_next_character (context_p);\n        return;\n      }\n#if JERRY_ESNEXT\n      case LIT_CHAR_DOT:\n      {\n        if (!(context_p->source_p + 1 >= context_p->source_end_p || lit_char_is_decimal_digit (context_p->source_p[1])))\n        {\n          if ((ident_opts & ((uint32_t) ~(LEXER_OBJ_IDENT_OBJECT_PATTERN | LEXER_OBJ_IDENT_SET_FUNCTION_START)))\n              || context_p->source_p + 2 >= context_p->source_end_p || context_p->source_p[1] != LIT_CHAR_DOT\n              || context_p->source_p[2] != LIT_CHAR_DOT)\n          {\n            break;\n          }\n\n          context_p->token.type = LEXER_THREE_DOTS;\n          context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n          PARSER_PLUS_EQUAL_LC (context_p->column, 3);\n          context_p->source_p += 3;\n          return;\n        }\n        /* FALLTHRU */\n      }\n#endif /* JERRY_ESNEXT */\n      default:\n      {\n        const uint8_t *char_p = context_p->source_p;\n\n        if (char_p[0] == LIT_CHAR_DOT)\n        {\n          char_p++;\n        }\n\n        if (char_p < context_p->source_end_p && char_p[0] >= LIT_CHAR_0 && char_p[0] <= LIT_CHAR_9)\n        {\n          lexer_parse_number (context_p);\n\n          if (!(ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER))\n          {\n            lexer_construct_number_object (context_p, false, false);\n          }\n          return;\n        }\n        break;\n      }\n    }\n  }\n\n  if (create_literal_object)\n  {\n#if JERRY_ESNEXT\n    if (ident_opts & LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n    {\n      return;\n    }\n\n    if (ident_opts & LEXER_OBJ_IDENT_CLASS_PRIVATE)\n    {\n      parser_resolve_private_identifier (context_p);\n      return;\n    }\n#endif /* JERRY_ESNEXT */\n\n    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);\n    return;\n  }\n\n  parser_raise_error (context_p, PARSER_ERR_PROPERTY_IDENTIFIER_EXPECTED);\n}",
  "abstract_func": "void\nlexer_expect_object_literal_id (parser_context_t *VAR_0, /* COMMENT_0 */\n                                uint32_t VAR_1) /* COMMENT_1 */\n{\n  lexer_skip_spaces (VAR_0);\n\n  if (VAR_0->source_p >= VAR_0->source_end_p)\n  {\n    parser_raise_error (VAR_0, VAR_2);\n  }\n\n  VAR_0->token.keyword_type = VAR_3;\n  VAR_0->token.line = VAR_0->line;\n  VAR_0->token.column = VAR_0->column;\n  bool VAR_4 = false;\n\n  JERRY_ASSERT ((VAR_1 & VAR_5) || !(VAR_1 & VAR_6));\n\n#if VAR_7\n  if (VAR_1 & VAR_8)\n  {\n    VAR_0->function_start_p = VAR_0->source_p;\n  }\n#endif /* COMMENT_2 */\n\n  if (lexer_parse_identifier (VAR_0, VAR_9))\n  {\n    if (!(VAR_1 & (VAR_10 | VAR_11)))\n    {\n      lexer_skip_spaces (VAR_0);\n      VAR_0->token.flags = (uint8_t) (VAR_0->token.flags | VAR_12);\n\n      if (VAR_0->source_p < VAR_0->source_end_p\n#if VAR_13\n          && VAR_0->source_p[0] != VAR_14 && VAR_0->source_p[0] != VAR_15\n          && VAR_0->source_p[0] != VAR_16 && VAR_0->source_p[0] != VAR_17\n          && VAR_0->source_p[0] != VAR_18\n#endif /* COMMENT_3 */\n          && VAR_0->source_p[0] != VAR_19)\n      {\n        if (lexer_compare_literal_to_string (VAR_0, \"get\", 3))\n        {\n          VAR_0->token.type = VAR_20;\n          return;\n        }\n\n        if (lexer_compare_literal_to_string (VAR_0, \"set\", 3))\n        {\n          VAR_0->token.type = VAR_21;\n          return;\n        }\n\n#if VAR_13\n        if (lexer_compare_literal_to_string (VAR_0, \"async\", 5))\n        {\n          VAR_0->token.type = VAR_22;\n          return;\n        }\n\n        if (VAR_1 & VAR_6)\n        {\n          if (lexer_compare_literal_to_string (VAR_0, \"static\", 6))\n          {\n            VAR_0->token.type = VAR_23;\n          }\n          return;\n        }\n#endif /* COMMENT_3 */\n      }\n    }\n\n    VAR_4 = true;\n  }\n#if VAR_13\n  else if (ident_opts & VAR_24)\n  {\n    parser_raise_error (VAR_0, VAR_25);\n  }\n#endif /* COMMENT_3 */\n  else\n  {\n    switch (VAR_0->source_p[0])\n    {\n      case VAR_26:\n      case VAR_27:\n      {\n        lexer_parse_string (VAR_0, VAR_28);\n        VAR_4 = true;\n        break;\n      }\n#if VAR_13\n      case VAR_29:\n      {\n#if VAR_7\n        const uint8_t *VAR_30 = VAR_0->function_start_p;\n#endif /* COMMENT_2 */\n\n        lexer_consume_next_character (VAR_0);\n\n        lexer_next_token (VAR_0);\n        parser_parse_expression (VAR_0, VAR_31);\n\n        if (VAR_0->token.type != VAR_32)\n        {\n          parser_raise_error (VAR_0, VAR_33);\n        }\n\n#if VAR_7\n        VAR_0->function_start_p = VAR_30;\n#endif /* COMMENT_2 */\n        return;\n      }\n      case VAR_34:\n      {\n        if (ident_opts & (VAR_10 | VAR_11))\n        {\n          break;\n        }\n\n        VAR_0->token.type = VAR_35;\n        lexer_consume_next_character (VAR_0);\n        return;\n      }\n      case VAR_36:\n      {\n        if (ident_opts & VAR_5)\n        {\n          VAR_0->token.type = VAR_37;\n          return;\n        }\n\n        break;\n      }\n#endif /* COMMENT_3 */\n      case VAR_38:\n      {\n        const uint32_t VAR_39 =\n          (VAR_6 | VAR_24 | VAR_5);\n\n        if ((ident_opts & VAR_39) == VAR_5)\n        {\n          VAR_0->token.type = VAR_40;\n          lexer_consume_next_character (VAR_0);\n          return;\n        }\n\n        break;\n      }\n      case VAR_15:\n      {\n        if (ident_opts & VAR_10)\n        {\n          break;\n        }\n\n        VAR_0->token.type = VAR_41;\n        lexer_consume_next_character (VAR_0);\n        return;\n      }\n#if VAR_13\n      case VAR_42:\n      {\n        if (!(VAR_0->source_p + 1 >= VAR_0->source_end_p || lit_char_is_decimal_digit (VAR_0->source_p[1])))\n        {\n          if ((ident_opts & ((uint32_t) ~(VAR_11 | VAR_8)))\n              || VAR_0->source_p + 2 >= VAR_0->source_end_p || VAR_0->source_p[1] != VAR_42\n              || VAR_0->source_p[2] != VAR_42)\n          {\n            break;\n          }\n\n          VAR_0->token.type = VAR_43;\n          VAR_0->token.flags &= (uint8_t) ~VAR_12;\n          PARSER_PLUS_EQUAL_LC (VAR_0->column, 3);\n          VAR_0->source_p += 3;\n          return;\n        }\n        /* COMMENT_4 */\n      }\n#endif /* COMMENT_3 */\n      default:\n      {\n        const uint8_t *VAR_44 = VAR_0->source_p;\n\n        if (VAR_44[0] == VAR_42)\n        {\n          VAR_44++;\n        }\n\n        if (VAR_44 < VAR_0->source_end_p && VAR_44[0] >= VAR_45 && VAR_44[0] <= VAR_46)\n        {\n          lexer_parse_number (VAR_0);\n\n          if (!(ident_opts & VAR_5))\n          {\n            lexer_construct_number_object (VAR_0, false, false);\n          }\n          return;\n        }\n        break;\n      }\n    }\n  }\n\n  if (VAR_4)\n  {\n#if VAR_13\n    if (ident_opts & VAR_5)\n    {\n      return;\n    }\n\n    if (ident_opts & VAR_24)\n    {\n      parser_resolve_private_identifier (VAR_0);\n      return;\n    }\n#endif /* COMMENT_3 */\n\n    lexer_construct_literal_object (VAR_0, &VAR_0->token.lit_location, VAR_47);\n    return;\n  }\n\n  parser_raise_error (VAR_0, VAR_2);\n}",
  "func_graph_path": "jerryscript-project/jerryscript/5e1fdd1d1e75105b43392b4bb3996099cdc50f3d/js-lexer.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -134,14 +134,17 @@\n #endif /* JERRY_ESNEXT */\n       case LIT_CHAR_LEFT_BRACE:\n       {\n-        if (ident_opts & (LEXER_OBJ_IDENT_CLASS_NO_STATIC | LEXER_OBJ_IDENT_CLASS_PRIVATE))\n-        {\n-          break;\n-        }\n-\n-        context_p->token.type = LEXER_LEFT_BRACE;\n-        lexer_consume_next_character (context_p);\n-        return;\n+        const uint32_t static_block_flags =\n+          (LEXER_OBJ_IDENT_CLASS_NO_STATIC | LEXER_OBJ_IDENT_CLASS_PRIVATE | LEXER_OBJ_IDENT_CLASS_IDENTIFIER);\n+\n+        if ((ident_opts & static_block_flags) == LEXER_OBJ_IDENT_CLASS_IDENTIFIER)\n+        {\n+          context_p->token.type = LEXER_LEFT_BRACE;\n+          lexer_consume_next_character (context_p);\n+          return;\n+        }\n+\n+        break;\n       }\n       case LIT_CHAR_RIGHT_BRACE:\n       {",
  "diff_line_info": {
    "deleted_lines": [
      "        if (ident_opts & (LEXER_OBJ_IDENT_CLASS_NO_STATIC | LEXER_OBJ_IDENT_CLASS_PRIVATE))",
      "        {",
      "          break;",
      "        }",
      "",
      "        context_p->token.type = LEXER_LEFT_BRACE;",
      "        lexer_consume_next_character (context_p);",
      "        return;"
    ],
    "added_lines": [
      "        const uint32_t static_block_flags =",
      "          (LEXER_OBJ_IDENT_CLASS_NO_STATIC | LEXER_OBJ_IDENT_CLASS_PRIVATE | LEXER_OBJ_IDENT_CLASS_IDENTIFIER);",
      "",
      "        if ((ident_opts & static_block_flags) == LEXER_OBJ_IDENT_CLASS_IDENTIFIER)",
      "        {",
      "          context_p->token.type = LEXER_LEFT_BRACE;",
      "          lexer_consume_next_character (context_p);",
      "          return;",
      "        }",
      "",
      "        break;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4942",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/jerryscript-project/jerryscript/pull/4942: 403 Client Error: Forbidden for url: https://api.github.com/repos/jerryscript-project/jerryscript/pulls/4942",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 1.0"
}