{
  "cve_id": "CVE-2019-3832",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:L/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libsndfile",
  "commit_msg": "wav_write_header: don't read past the array end\n\nIf loop_count is bigger than the array, truncate it to the array\nlength (and not to 32k).\n\nCVE-2019-3832",
  "commit_hash": "7408c4c788ce047d4e652b60a04e7796bcd7267e",
  "git_url": "https://github.com/libsndfile/libsndfile/commit/7408c4c788ce047d4e652b60a04e7796bcd7267e",
  "file_path": "src/wav.c",
  "func_name": "wav_write_header",
  "func_before": "static int\nwav_write_header (SF_PRIVATE *psf, int calc_length)\n{\tsf_count_t\tcurrent ;\n\tint \t\terror, has_data = SF_FALSE ;\n\n\tcurrent = psf_ftell (psf) ;\n\n\tif (current > psf->dataoffset)\n\t\thas_data = SF_TRUE ;\n\n\tif (calc_length)\n\t{\tpsf->filelength = psf_get_filelen (psf) ;\n\n\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\n\t\tif (psf->dataend)\n\t\t\tpsf->datalength -= psf->filelength - psf->dataend ;\n\t\telse if (psf->bytewidth > 0 && psf->sf.seekable == SF_TRUE)\n\t\t\tpsf->datalength = psf->sf.frames * psf->bytewidth * psf->sf.channels ;\n\t\t} ;\n\n\t/* Reset the current header length to zero. */\n\tpsf->header.ptr [0] = 0 ;\n\tpsf->header.indx = 0 ;\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\n\t/*\n\t** RIFX signifies big-endian format for all header and data.\n\t** To prevent lots of code copying here, we'll set the psf->rwf_endian flag\n\t** once here, and never specify endian-ness for all other header operations.\n\t*/\n\n\t/* RIFF/RIFX marker, length, WAVE and 'fmt ' markers. */\n\n\tif (psf->endian == SF_ENDIAN_LITTLE)\n\t\tpsf_binheader_writef (psf, \"etm8\", BHWm (RIFF_MARKER), BHW8 ((psf->filelength < 8) ? 8 : psf->filelength - 8)) ;\n\telse\n\t\tpsf_binheader_writef (psf, \"Etm8\", BHWm (RIFX_MARKER), BHW8 ((psf->filelength < 8) ? 8 : psf->filelength - 8)) ;\n\n\t/* WAVE and 'fmt ' markers. */\n\tpsf_binheader_writef (psf, \"mm\", BHWm (WAVE_MARKER), BHWm (fmt_MARKER)) ;\n\n\t/* Write the 'fmt ' chunk. */\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase SF_FORMAT_WAV :\n\t\t\t\tif ((error = wav_write_fmt_chunk (psf)) != 0)\n\t\t\t\t\treturn error ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_WAVEX :\n\t\t\t\tif ((error = wavex_write_fmt_chunk (psf)) != 0)\n\t\t\t\t\treturn error ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\t/* The LIST/INFO chunk. */\n\tif (psf->strings.flags & SF_STR_LOCATE_START)\n\t\twavlike_write_strings (psf, SF_STR_LOCATE_START) ;\n\n\tif (psf->peak_info != NULL && psf->peak_info->peak_loc == SF_PEAK_START)\n\t\twavlike_write_peak_chunk (psf) ;\n\n\tif (psf->broadcast_16k != NULL)\n\t\twavlike_write_bext_chunk (psf) ;\n\n\tif (psf->cart_16k != NULL)\n\t\twavlike_write_cart_chunk (psf) ;\n\n\tif (psf->cues != NULL)\n\t{\tuint32_t k ;\n\n\t\tpsf_binheader_writef (psf, \"em44\", BHWm (cue_MARKER), BHW4 (4 + psf->cues->cue_count * 6 * 4), BHW4 (psf->cues->cue_count)) ;\n\n\t\tfor (k = 0 ; k < psf->cues->cue_count ; k++)\n\t\t\tpsf_binheader_writef (psf, \"e44m444\", BHW4 (psf->cues->cue_points [k].indx), BHW4 (psf->cues->cue_points [k].position),\n\t\t\t\t\t\tBHWm (psf->cues->cue_points [k].fcc_chunk), BHW4 (psf->cues->cue_points [k].chunk_start),\n\t\t\t\t\t\tBHW4 (psf->cues->cue_points [k].block_start), BHW4 (psf->cues->cue_points [k].sample_offset)) ;\n\t\t} ;\n\n\tif (psf->instrument != NULL)\n\t{\tint\t\ttmp ;\n\t\tdouble\tdtune = (double) (0x40000000) / 25.0 ;\n\n\t\tpsf_binheader_writef (psf, \"m4\", BHWm (smpl_MARKER), BHW4 (9 * 4 + psf->instrument->loop_count * 6 * 4)) ;\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (0)) ; /* Manufacturer zero is everyone */\n\t\ttmp = (int) (1.0e9 / psf->sf.samplerate) ; /* Sample period in nano seconds */\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (tmp), BHW4 (psf->instrument->basenote)) ;\n\t\ttmp = (uint32_t) (psf->instrument->detune * dtune + 0.5) ;\n\t\tpsf_binheader_writef (psf, \"4\", BHW4 (tmp)) ;\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (0)) ; /* SMTPE format */\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (psf->instrument->loop_count), BHW4 (0)) ;\n\n\t\t/* Loop count is signed 16 bit number so we limit it range to something sensible. */\n\t\tpsf->instrument->loop_count &= 0x7fff ;\n\t\tfor (tmp = 0 ; tmp < psf->instrument->loop_count ; tmp++)\n\t\t{\tint type ;\n\n\t\t\ttype = psf->instrument->loops [tmp].mode ;\n\t\t\ttype = (type == SF_LOOP_FORWARD ? 0 : type == SF_LOOP_BACKWARD ? 2 : type == SF_LOOP_ALTERNATING ? 1 : 32) ;\n\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (tmp), BHW4 (type)) ;\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (psf->instrument->loops [tmp].start), BHW4 (psf->instrument->loops [tmp].end - 1)) ;\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (psf->instrument->loops [tmp].count)) ;\n\t\t\t} ;\n\t\t} ;\n\n\t/* Write custom headers. */\n\tif (psf->wchunks.used > 0)\n\t\twavlike_write_custom_chunks (psf) ;\n\n\tif (psf->header.indx + 16 < psf->dataoffset)\n\t{\t/* Add PAD data if necessary. */\n\t\tsize_t k = psf->dataoffset - (psf->header.indx + 16) ;\n\t\tpsf_binheader_writef (psf, \"m4z\", BHWm (PAD_MARKER), BHW4 (k), BHWz (k)) ;\n\t\t} ;\n\n\tpsf_binheader_writef (psf, \"tm8\", BHWm (data_MARKER), BHW8 (psf->datalength)) ;\n\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\tif (has_data && psf->dataoffset != psf->header.indx)\n\t{\tpsf_log_printf (psf, \"Oooops : has_data && psf->dataoffset != psf->header.indx\\n\") ;\n\t\treturn psf->error = SFE_INTERNAL ;\n\t\t} ;\n\n\tpsf->dataoffset = psf->header.indx ;\n\n\tif (! has_data)\n\t\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\telse if (current > 0)\n\t\tpsf_fseek (psf, current, SEEK_SET) ;\n\n\treturn psf->error ;\n}",
  "abstract_func_before": "static int\nwav_write_header (SF_PRIVATE *VAR_0, int VAR_1)\n{\tsf_count_t\tVAR_2 ;\n\tint \t\tVAR_3, VAR_4 = VAR_5 ;\n\n\tVAR_2 = psf_ftell (VAR_0) ;\n\n\tif (VAR_2 > VAR_0->dataoffset)\n\t\tVAR_4 = VAR_6 ;\n\n\tif (VAR_1)\n\t{\tVAR_0->filelength = psf_get_filelen (VAR_0) ;\n\n\t\tVAR_0->datalength = VAR_0->filelength - VAR_0->dataoffset ;\n\n\t\tif (VAR_0->dataend)\n\t\t\tVAR_0->datalength -= VAR_0->filelength - VAR_0->dataend ;\n\t\telse if (VAR_0->bytewidth > 0 && VAR_0->sf.seekable == VAR_6)\n\t\t\tVAR_0->datalength = VAR_0->sf.frames * VAR_0->bytewidth * VAR_0->sf.channels ;\n\t\t} ;\n\n\t/* COMMENT_0 */\n\tVAR_0->header.ptr [0] = 0 ;\n\tVAR_0->header.indx = 0 ;\n\tpsf_fseek (VAR_0, 0, VAR_7) ;\n\n\t/* COMMENT_1 */\n                                                             \n                                                                            \n                                                                             \n   \n\n\t/* COMMENT_6 */\n\n\tif (VAR_0->endian == VAR_8)\n\t\tpsf_binheader_writef (VAR_0, \"etm8\", BHWm (VAR_9), BHW8 ((VAR_0->filelength < 8) ? 8 : VAR_0->filelength - 8)) ;\n\telse\n\t\tpsf_binheader_writef (VAR_0, \"Etm8\", BHWm (VAR_10), BHW8 ((VAR_0->filelength < 8) ? 8 : VAR_0->filelength - 8)) ;\n\n\t/* COMMENT_7 */\n\tpsf_binheader_writef (VAR_0, \"mm\", BHWm (VAR_11), BHWm (VAR_12)) ;\n\n\t/* COMMENT_8 */\n\tswitch (SF_CONTAINER (VAR_0->sf.format))\n\t{\tcase VAR_13 :\n\t\t\t\tif ((VAR_3 = wav_write_fmt_chunk (VAR_0)) != 0)\n\t\t\t\t\treturn VAR_3 ;\n\t\t\t\tbreak ;\n\n\t\tcase VAR_14 :\n\t\t\t\tif ((VAR_3 = wavex_write_fmt_chunk (VAR_0)) != 0)\n\t\t\t\t\treturn VAR_3 ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn VAR_15 ;\n\t\t} ;\n\n\t/* COMMENT_9 */\n\tif (VAR_0->strings.flags & VAR_16)\n\t\twavlike_write_strings (VAR_0, VAR_16) ;\n\n\tif (VAR_0->peak_info != NULL && VAR_0->peak_info->peak_loc == VAR_17)\n\t\twavlike_write_peak_chunk (VAR_0) ;\n\n\tif (VAR_0->broadcast_16k != NULL)\n\t\twavlike_write_bext_chunk (VAR_0) ;\n\n\tif (VAR_0->cart_16k != NULL)\n\t\twavlike_write_cart_chunk (VAR_0) ;\n\n\tif (VAR_0->cues != NULL)\n\t{\tuint32_t VAR_18 ;\n\n\t\tpsf_binheader_writef (VAR_0, \"em44\", BHWm (VAR_19), BHW4 (4 + VAR_0->cues->cue_count * 6 * 4), BHW4 (VAR_0->cues->cue_count)) ;\n\n\t\tfor (VAR_18 = 0 ; VAR_18 < VAR_0->cues->cue_count ; VAR_18++)\n\t\t\tpsf_binheader_writef (VAR_0, \"e44m444\", BHW4 (VAR_0->cues->cue_points [VAR_18].indx), BHW4 (VAR_0->cues->cue_points [VAR_18].position),\n\t\t\t\t\t\tBHWm (VAR_0->cues->cue_points [VAR_18].fcc_chunk), BHW4 (VAR_0->cues->cue_points [VAR_18].chunk_start),\n\t\t\t\t\t\tBHW4 (VAR_0->cues->cue_points [VAR_18].block_start), BHW4 (VAR_0->cues->cue_points [VAR_18].sample_offset)) ;\n\t\t} ;\n\n\tif (VAR_0->instrument != NULL)\n\t{\tint\t\tVAR_20 ;\n\t\tdouble\tVAR_21 = (double) (0x40000000) / 25.0 ;\n\n\t\tpsf_binheader_writef (VAR_0, \"m4\", BHWm (VAR_22), BHW4 (9 * 4 + VAR_0->instrument->loop_count * 6 * 4)) ;\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (0), BHW4 (0)) ; /* COMMENT_10 */\n\t\tVAR_20 = (int) (1.0e9 / VAR_0->sf.samplerate) ; /* COMMENT_11 */\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_20), BHW4 (VAR_0->instrument->basenote)) ;\n\t\tVAR_20 = (uint32_t) (VAR_0->instrument->detune * VAR_21 + 0.5) ;\n\t\tpsf_binheader_writef (VAR_0, \"4\", BHW4 (VAR_20)) ;\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (0), BHW4 (0)) ; /* COMMENT_12 */\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_0->instrument->loop_count), BHW4 (0)) ;\n\n\t\t/* COMMENT_13 */\n\t\tVAR_0->instrument->loop_count &= 0x7fff ;\n\t\tfor (VAR_20 = 0 ; VAR_20 < VAR_0->instrument->loop_count ; VAR_20++)\n\t\t{\tint VAR_23 ;\n\n\t\t\tVAR_23 = VAR_0->instrument->loops [VAR_20].mode ;\n\t\t\tVAR_23 = (VAR_23 == VAR_24 ? 0 : VAR_23 == VAR_25 ? 2 : VAR_23 == VAR_26 ? 1 : 32) ;\n\n\t\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_20), BHW4 (VAR_23)) ;\n\t\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_0->instrument->loops [VAR_20].start), BHW4 (VAR_0->instrument->loops [VAR_20].end - 1)) ;\n\t\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (0), BHW4 (VAR_0->instrument->loops [VAR_20].count)) ;\n\t\t\t} ;\n\t\t} ;\n\n\t/* COMMENT_14 */\n\tif (VAR_0->wchunks.used > 0)\n\t\twavlike_write_custom_chunks (VAR_0) ;\n\n\tif (VAR_0->header.indx + 16 < VAR_0->dataoffset)\n\t{\t/* COMMENT_15 */\n\t\tsize_t VAR_18 = VAR_0->dataoffset - (VAR_0->header.indx + 16) ;\n\t\tpsf_binheader_writef (VAR_0, \"m4z\", BHWm (VAR_27), BHW4 (VAR_18), BHWz (VAR_18)) ;\n\t\t} ;\n\n\tpsf_binheader_writef (VAR_0, \"tm8\", BHWm (VAR_28), BHW8 (VAR_0->datalength)) ;\n\tpsf_fwrite (VAR_0->header.ptr, VAR_0->header.indx, 1, VAR_0) ;\n\tif (VAR_0->error)\n\t\treturn VAR_0->error ;\n\n\tif (VAR_4 && VAR_0->dataoffset != VAR_0->header.indx)\n\t{\tpsf_log_printf (VAR_0, \"Oooops : has_data && psf->dataoffset != psf->header.indx\\n\") ;\n\t\treturn VAR_0->error = VAR_29 ;\n\t\t} ;\n\n\tVAR_0->dataoffset = VAR_0->header.indx ;\n\n\tif (! VAR_4)\n\t\tpsf_fseek (VAR_0, VAR_0->dataoffset, VAR_7) ;\n\telse if (VAR_2 > 0)\n\t\tpsf_fseek (VAR_0, VAR_2, VAR_7) ;\n\n\treturn VAR_0->error ;\n}",
  "func_graph_path_before": "libsndfile/7408c4c788ce047d4e652b60a04e7796bcd7267e/wav.c/vul/before/0.json",
  "func": "static int\nwav_write_header (SF_PRIVATE *psf, int calc_length)\n{\tsf_count_t\tcurrent ;\n\tint \t\terror, has_data = SF_FALSE ;\n\n\tcurrent = psf_ftell (psf) ;\n\n\tif (current > psf->dataoffset)\n\t\thas_data = SF_TRUE ;\n\n\tif (calc_length)\n\t{\tpsf->filelength = psf_get_filelen (psf) ;\n\n\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\n\t\tif (psf->dataend)\n\t\t\tpsf->datalength -= psf->filelength - psf->dataend ;\n\t\telse if (psf->bytewidth > 0 && psf->sf.seekable == SF_TRUE)\n\t\t\tpsf->datalength = psf->sf.frames * psf->bytewidth * psf->sf.channels ;\n\t\t} ;\n\n\t/* Reset the current header length to zero. */\n\tpsf->header.ptr [0] = 0 ;\n\tpsf->header.indx = 0 ;\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\n\t/*\n\t** RIFX signifies big-endian format for all header and data.\n\t** To prevent lots of code copying here, we'll set the psf->rwf_endian flag\n\t** once here, and never specify endian-ness for all other header operations.\n\t*/\n\n\t/* RIFF/RIFX marker, length, WAVE and 'fmt ' markers. */\n\n\tif (psf->endian == SF_ENDIAN_LITTLE)\n\t\tpsf_binheader_writef (psf, \"etm8\", BHWm (RIFF_MARKER), BHW8 ((psf->filelength < 8) ? 8 : psf->filelength - 8)) ;\n\telse\n\t\tpsf_binheader_writef (psf, \"Etm8\", BHWm (RIFX_MARKER), BHW8 ((psf->filelength < 8) ? 8 : psf->filelength - 8)) ;\n\n\t/* WAVE and 'fmt ' markers. */\n\tpsf_binheader_writef (psf, \"mm\", BHWm (WAVE_MARKER), BHWm (fmt_MARKER)) ;\n\n\t/* Write the 'fmt ' chunk. */\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase SF_FORMAT_WAV :\n\t\t\t\tif ((error = wav_write_fmt_chunk (psf)) != 0)\n\t\t\t\t\treturn error ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_WAVEX :\n\t\t\t\tif ((error = wavex_write_fmt_chunk (psf)) != 0)\n\t\t\t\t\treturn error ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\t/* The LIST/INFO chunk. */\n\tif (psf->strings.flags & SF_STR_LOCATE_START)\n\t\twavlike_write_strings (psf, SF_STR_LOCATE_START) ;\n\n\tif (psf->peak_info != NULL && psf->peak_info->peak_loc == SF_PEAK_START)\n\t\twavlike_write_peak_chunk (psf) ;\n\n\tif (psf->broadcast_16k != NULL)\n\t\twavlike_write_bext_chunk (psf) ;\n\n\tif (psf->cart_16k != NULL)\n\t\twavlike_write_cart_chunk (psf) ;\n\n\tif (psf->cues != NULL)\n\t{\tuint32_t k ;\n\n\t\tpsf_binheader_writef (psf, \"em44\", BHWm (cue_MARKER), BHW4 (4 + psf->cues->cue_count * 6 * 4), BHW4 (psf->cues->cue_count)) ;\n\n\t\tfor (k = 0 ; k < psf->cues->cue_count ; k++)\n\t\t\tpsf_binheader_writef (psf, \"e44m444\", BHW4 (psf->cues->cue_points [k].indx), BHW4 (psf->cues->cue_points [k].position),\n\t\t\t\t\t\tBHWm (psf->cues->cue_points [k].fcc_chunk), BHW4 (psf->cues->cue_points [k].chunk_start),\n\t\t\t\t\t\tBHW4 (psf->cues->cue_points [k].block_start), BHW4 (psf->cues->cue_points [k].sample_offset)) ;\n\t\t} ;\n\n\tif (psf->instrument != NULL)\n\t{\tint\t\ttmp ;\n\t\tdouble\tdtune = (double) (0x40000000) / 25.0 ;\n\n\t\tpsf_binheader_writef (psf, \"m4\", BHWm (smpl_MARKER), BHW4 (9 * 4 + psf->instrument->loop_count * 6 * 4)) ;\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (0)) ; /* Manufacturer zero is everyone */\n\t\ttmp = (int) (1.0e9 / psf->sf.samplerate) ; /* Sample period in nano seconds */\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (tmp), BHW4 (psf->instrument->basenote)) ;\n\t\ttmp = (uint32_t) (psf->instrument->detune * dtune + 0.5) ;\n\t\tpsf_binheader_writef (psf, \"4\", BHW4 (tmp)) ;\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (0)) ; /* SMTPE format */\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (psf->instrument->loop_count), BHW4 (0)) ;\n\n\t\t/* Make sure we don't read past the loops array end. */\n\t\tif (psf->instrument->loop_count > ARRAY_LEN (psf->instrument->loops))\n\t\t\tpsf->instrument->loop_count = ARRAY_LEN (psf->instrument->loops) ;\n\n\t\tfor (tmp = 0 ; tmp < psf->instrument->loop_count ; tmp++)\n\t\t{\tint type ;\n\n\t\t\ttype = psf->instrument->loops [tmp].mode ;\n\t\t\ttype = (type == SF_LOOP_FORWARD ? 0 : type == SF_LOOP_BACKWARD ? 2 : type == SF_LOOP_ALTERNATING ? 1 : 32) ;\n\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (tmp), BHW4 (type)) ;\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (psf->instrument->loops [tmp].start), BHW4 (psf->instrument->loops [tmp].end - 1)) ;\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (psf->instrument->loops [tmp].count)) ;\n\t\t\t} ;\n\t\t} ;\n\n\t/* Write custom headers. */\n\tif (psf->wchunks.used > 0)\n\t\twavlike_write_custom_chunks (psf) ;\n\n\tif (psf->header.indx + 16 < psf->dataoffset)\n\t{\t/* Add PAD data if necessary. */\n\t\tsize_t k = psf->dataoffset - (psf->header.indx + 16) ;\n\t\tpsf_binheader_writef (psf, \"m4z\", BHWm (PAD_MARKER), BHW4 (k), BHWz (k)) ;\n\t\t} ;\n\n\tpsf_binheader_writef (psf, \"tm8\", BHWm (data_MARKER), BHW8 (psf->datalength)) ;\n\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\tif (has_data && psf->dataoffset != psf->header.indx)\n\t{\tpsf_log_printf (psf, \"Oooops : has_data && psf->dataoffset != psf->header.indx\\n\") ;\n\t\treturn psf->error = SFE_INTERNAL ;\n\t\t} ;\n\n\tpsf->dataoffset = psf->header.indx ;\n\n\tif (! has_data)\n\t\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\telse if (current > 0)\n\t\tpsf_fseek (psf, current, SEEK_SET) ;\n\n\treturn psf->error ;\n}",
  "abstract_func": "static int\nwav_write_header (SF_PRIVATE *VAR_0, int VAR_1)\n{\tsf_count_t\tVAR_2 ;\n\tint \t\tVAR_3, VAR_4 = VAR_5 ;\n\n\tVAR_2 = psf_ftell (VAR_0) ;\n\n\tif (VAR_2 > VAR_0->dataoffset)\n\t\tVAR_4 = VAR_6 ;\n\n\tif (VAR_1)\n\t{\tVAR_0->filelength = psf_get_filelen (VAR_0) ;\n\n\t\tVAR_0->datalength = VAR_0->filelength - VAR_0->dataoffset ;\n\n\t\tif (VAR_0->dataend)\n\t\t\tVAR_0->datalength -= VAR_0->filelength - VAR_0->dataend ;\n\t\telse if (VAR_0->bytewidth > 0 && VAR_0->sf.seekable == VAR_6)\n\t\t\tVAR_0->datalength = VAR_0->sf.frames * VAR_0->bytewidth * VAR_0->sf.channels ;\n\t\t} ;\n\n\t/* COMMENT_0 */\n\tVAR_0->header.ptr [0] = 0 ;\n\tVAR_0->header.indx = 0 ;\n\tpsf_fseek (VAR_0, 0, VAR_7) ;\n\n\t/* COMMENT_1 */\n                                                             \n                                                                            \n                                                                             \n   \n\n\t/* COMMENT_6 */\n\n\tif (VAR_0->endian == VAR_8)\n\t\tpsf_binheader_writef (VAR_0, \"etm8\", BHWm (VAR_9), BHW8 ((VAR_0->filelength < 8) ? 8 : VAR_0->filelength - 8)) ;\n\telse\n\t\tpsf_binheader_writef (VAR_0, \"Etm8\", BHWm (VAR_10), BHW8 ((VAR_0->filelength < 8) ? 8 : VAR_0->filelength - 8)) ;\n\n\t/* COMMENT_7 */\n\tpsf_binheader_writef (VAR_0, \"mm\", BHWm (VAR_11), BHWm (VAR_12)) ;\n\n\t/* COMMENT_8 */\n\tswitch (SF_CONTAINER (VAR_0->sf.format))\n\t{\tcase VAR_13 :\n\t\t\t\tif ((VAR_3 = wav_write_fmt_chunk (VAR_0)) != 0)\n\t\t\t\t\treturn VAR_3 ;\n\t\t\t\tbreak ;\n\n\t\tcase VAR_14 :\n\t\t\t\tif ((VAR_3 = wavex_write_fmt_chunk (VAR_0)) != 0)\n\t\t\t\t\treturn VAR_3 ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn VAR_15 ;\n\t\t} ;\n\n\t/* COMMENT_9 */\n\tif (VAR_0->strings.flags & VAR_16)\n\t\twavlike_write_strings (VAR_0, VAR_16) ;\n\n\tif (VAR_0->peak_info != NULL && VAR_0->peak_info->peak_loc == VAR_17)\n\t\twavlike_write_peak_chunk (VAR_0) ;\n\n\tif (VAR_0->broadcast_16k != NULL)\n\t\twavlike_write_bext_chunk (VAR_0) ;\n\n\tif (VAR_0->cart_16k != NULL)\n\t\twavlike_write_cart_chunk (VAR_0) ;\n\n\tif (VAR_0->cues != NULL)\n\t{\tuint32_t VAR_18 ;\n\n\t\tpsf_binheader_writef (VAR_0, \"em44\", BHWm (VAR_19), BHW4 (4 + VAR_0->cues->cue_count * 6 * 4), BHW4 (VAR_0->cues->cue_count)) ;\n\n\t\tfor (VAR_18 = 0 ; VAR_18 < VAR_0->cues->cue_count ; VAR_18++)\n\t\t\tpsf_binheader_writef (VAR_0, \"e44m444\", BHW4 (VAR_0->cues->cue_points [VAR_18].indx), BHW4 (VAR_0->cues->cue_points [VAR_18].position),\n\t\t\t\t\t\tBHWm (VAR_0->cues->cue_points [VAR_18].fcc_chunk), BHW4 (VAR_0->cues->cue_points [VAR_18].chunk_start),\n\t\t\t\t\t\tBHW4 (VAR_0->cues->cue_points [VAR_18].block_start), BHW4 (VAR_0->cues->cue_points [VAR_18].sample_offset)) ;\n\t\t} ;\n\n\tif (VAR_0->instrument != NULL)\n\t{\tint\t\tVAR_20 ;\n\t\tdouble\tVAR_21 = (double) (0x40000000) / 25.0 ;\n\n\t\tpsf_binheader_writef (VAR_0, \"m4\", BHWm (VAR_22), BHW4 (9 * 4 + VAR_0->instrument->loop_count * 6 * 4)) ;\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (0), BHW4 (0)) ; /* COMMENT_10 */\n\t\tVAR_20 = (int) (1.0e9 / VAR_0->sf.samplerate) ; /* COMMENT_11 */\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_20), BHW4 (VAR_0->instrument->basenote)) ;\n\t\tVAR_20 = (uint32_t) (VAR_0->instrument->detune * VAR_21 + 0.5) ;\n\t\tpsf_binheader_writef (VAR_0, \"4\", BHW4 (VAR_20)) ;\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (0), BHW4 (0)) ; /* COMMENT_12 */\n\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_0->instrument->loop_count), BHW4 (0)) ;\n\n\t\t/* COMMENT_13 */\n\t\tif (VAR_0->instrument->loop_count > ARRAY_LEN (VAR_0->instrument->loops))\n\t\t\tVAR_0->instrument->loop_count = ARRAY_LEN (VAR_0->instrument->loops) ;\n\n\t\tfor (VAR_20 = 0 ; VAR_20 < VAR_0->instrument->loop_count ; VAR_20++)\n\t\t{\tint VAR_23 ;\n\n\t\t\tVAR_23 = VAR_0->instrument->loops [VAR_20].mode ;\n\t\t\tVAR_23 = (VAR_23 == VAR_24 ? 0 : VAR_23 == VAR_25 ? 2 : VAR_23 == VAR_26 ? 1 : 32) ;\n\n\t\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_20), BHW4 (VAR_23)) ;\n\t\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (VAR_0->instrument->loops [VAR_20].start), BHW4 (VAR_0->instrument->loops [VAR_20].end - 1)) ;\n\t\t\tpsf_binheader_writef (VAR_0, \"44\", BHW4 (0), BHW4 (VAR_0->instrument->loops [VAR_20].count)) ;\n\t\t\t} ;\n\t\t} ;\n\n\t/* COMMENT_14 */\n\tif (VAR_0->wchunks.used > 0)\n\t\twavlike_write_custom_chunks (VAR_0) ;\n\n\tif (VAR_0->header.indx + 16 < VAR_0->dataoffset)\n\t{\t/* COMMENT_15 */\n\t\tsize_t VAR_18 = VAR_0->dataoffset - (VAR_0->header.indx + 16) ;\n\t\tpsf_binheader_writef (VAR_0, \"m4z\", BHWm (VAR_27), BHW4 (VAR_18), BHWz (VAR_18)) ;\n\t\t} ;\n\n\tpsf_binheader_writef (VAR_0, \"tm8\", BHWm (VAR_28), BHW8 (VAR_0->datalength)) ;\n\tpsf_fwrite (VAR_0->header.ptr, VAR_0->header.indx, 1, VAR_0) ;\n\tif (VAR_0->error)\n\t\treturn VAR_0->error ;\n\n\tif (VAR_4 && VAR_0->dataoffset != VAR_0->header.indx)\n\t{\tpsf_log_printf (VAR_0, \"Oooops : has_data && psf->dataoffset != psf->header.indx\\n\") ;\n\t\treturn VAR_0->error = VAR_29 ;\n\t\t} ;\n\n\tVAR_0->dataoffset = VAR_0->header.indx ;\n\n\tif (! VAR_4)\n\t\tpsf_fseek (VAR_0, VAR_0->dataoffset, VAR_7) ;\n\telse if (VAR_2 > 0)\n\t\tpsf_fseek (VAR_0, VAR_2, VAR_7) ;\n\n\treturn VAR_0->error ;\n}",
  "func_graph_path": "libsndfile/7408c4c788ce047d4e652b60a04e7796bcd7267e/wav.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -93,8 +93,10 @@\n \t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (0)) ; /* SMTPE format */\n \t\tpsf_binheader_writef (psf, \"44\", BHW4 (psf->instrument->loop_count), BHW4 (0)) ;\n \n-\t\t/* Loop count is signed 16 bit number so we limit it range to something sensible. */\n-\t\tpsf->instrument->loop_count &= 0x7fff ;\n+\t\t/* Make sure we don't read past the loops array end. */\n+\t\tif (psf->instrument->loop_count > ARRAY_LEN (psf->instrument->loops))\n+\t\t\tpsf->instrument->loop_count = ARRAY_LEN (psf->instrument->loops) ;\n+\n \t\tfor (tmp = 0 ; tmp < psf->instrument->loop_count ; tmp++)\n \t\t{\tint type ;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t/* Loop count is signed 16 bit number so we limit it range to something sensible. */",
      "\t\tpsf->instrument->loop_count &= 0x7fff ;"
    ],
    "added_lines": [
      "\t\t/* Make sure we don't read past the loops array end. */",
      "\t\tif (psf->instrument->loop_count > ARRAY_LEN (psf->instrument->loops))",
      "\t\t\tpsf->instrument->loop_count = ARRAY_LEN (psf->instrument->loops) ;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libsndfile/libsndfile/pull/460",
  "description": {
    "pr_info": {
      "title": "wav_write_header: don't read past the array end",
      "number": 460
    },
    "comment": [
      "If loop_count is bigger than the array, truncate it to the array\r\nlength (and not to 32k).\r\n\r\nCVE-2019-3832"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}