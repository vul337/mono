{
  "cve_id": "CVE-2022-48257",
  "cwe_ids": [
    "CWE-Other",
    "CWE-732"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "MisterTea/EternalTerminal",
  "commit_msg": "Unify logfile names and create with more secure open options and perms.\n\nFixes #555 (Tribute to Colin McRae)",
  "commit_hash": "4a8b02d5f1afb38b00c77ab1321d5f56720f4e30",
  "git_url": "https://github.com/MisterTea/EternalTerminal/commit/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30",
  "file_path": "src/htm/HtmClientMain.cpp",
  "func_name": "main",
  "func_before": "int main(int argc, char** argv) {\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n  // Parse command line arguments\n  cxxopts::Options options(\"htm\", \"Headless terminal multiplexer\");\n  options.allow_unrecognised_options();\n\n  options.add_options()       //\n      (\"help\", \"Print help\")  //\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  //\n      ;\n\n  auto result = options.parse(argc, argv);\n  if (result.count(\"help\")) {\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(0);\n  }\n\n  setvbuf(stdin, NULL, _IONBF, 0);   // turn off buffering\n  setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering\n\n  // Turn on raw terminal mode\n  termios terminal_local;\n  tcgetattr(0, &terminal_local);\n  memcpy(&terminal_backup, &terminal_local, sizeof(struct termios));\n  cfmakeraw(&terminal_local);\n  tcsetattr(0, TCSANOW, &terminal_local);\n\n  // Catch sigterm and send exit control code\n  struct sigaction action;\n  memset(&action, 0, sizeof(struct sigaction));\n  action.sa_handler = term;\n  sigaction(SIGTERM, &action, NULL);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n  el::Loggers::setVerboseLevel(3);\n  // default max log file size is 20MB for etserver\n  string maxlogsize = \"20971520\";\n  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",\n                           maxlogsize);\n  // Redirect std streams to a file\n  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  uid_t myuid = getuid();\n  if (result.count(\"x\")) {\n    LOG(INFO) << \"Killing previous htmd\";\n    // Kill previous htm daemon\n    string command =\n        string(\"pkill -x -U \") + to_string(myuid) + string(\" htmd\");\n    system(command.c_str());\n  }\n\n  // Check if daemon exists\n  string command = string(\"pgrep -x -U \") + to_string(myuid) + string(\" htmd\");\n  string pgrepOutput = SystemToStr(command.c_str());\n\n  if (pgrepOutput.length() == 0) {\n    // Fork to create the daemon\n    int result = DaemonCreator::create(false, \"\");\n    if (result == DaemonCreator::CHILD) {\n      // This means we are the daemon\n      exit(system(\"htmd\"));\n    }\n  }\n\n  // This means we are the client to the daemon\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  // Sleep for 10ms to let the daemon come alive\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint pipeEndpoint;\n  pipeEndpoint.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  htmClient.run();\n\n  char buf[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf));\n  fflush(stdout);\n  tcsetattr(0, TCSANOW, &terminal_backup);\n\n  return 0;\n}",
  "abstract_func_before": "int main(int VAR_0, char** VAR_1) {\n  VAR_2;\n  srand(1);\n  /* COMMENT_0 */\n  cxxopts::Options VAR_3(\"htm\", \"Headless terminal multiplexer\");\n  VAR_3.allow_unrecognised_options();\n\n  VAR_3.add_options()       /* COMMENT_1 */\n      (\"help\", \"Print help\")  /* COMMENT_1 */\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  /* COMMENT_1 */\n      ;\n\n  auto VAR_4 = VAR_3.parse(VAR_0, VAR_1);\n  if (VAR_4.count(\"help\")) {\n    CLOG(VAR_5, \"stdout\") << VAR_3.help({}) << VAR_6;\n    exit(0);\n  }\n\n  setvbuf(VAR_7, NULL, VAR_8, 0);   /* COMMENT_2 */\n  setvbuf(VAR_9, NULL, VAR_8, 0);  /* COMMENT_2 */\n\n  /* COMMENT_3 */\n  termios VAR_10;\n  tcgetattr(0, &VAR_10);\n  memcpy(&VAR_11, &VAR_10, sizeof(struct termios));\n  cfmakeraw(&VAR_10);\n  tcsetattr(0, VAR_12, &VAR_10);\n\n  /* COMMENT_4 */\n  struct sigaction VAR_13;\n  memset(&VAR_13, 0, sizeof(struct sigaction));\n  VAR_13.sa_handler = VAR_14;\n  sigaction(VAR_15, &VAR_13, NULL);\n\n  /* COMMENT_5 */\n  el::Configurations VAR_16 = LogHandler::setupLogHandler(&VAR_0, &VAR_1);\n  VAR_16.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n  el::Loggers::setVerboseLevel(3);\n  /* COMMENT_6 */\n  string VAR_17 = \"20971520\";\n  LogHandler::setupLogFile(&VAR_16, GetTempDirectory() + \"htm.log\",\n                           VAR_17);\n  /* COMMENT_7 */\n  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");\n\n  /* COMMENT_8 */\n  el::Loggers::reconfigureLogger(\"default\", VAR_16);\n\n  et::HandleTerminate();\n\n  /* COMMENT_9 */\n  ::signal(VAR_18, et::InterruptSignalHandler);\n\n  uid_t VAR_19 = getuid();\n  if (VAR_4.count(\"x\")) {\n    LOG(VAR_5) << \"Killing previous htmd\";\n    /* COMMENT_10 */\n    string VAR_20 =\n        string(\"pkill -x -U \") + to_string(VAR_19) + string(\" htmd\");\n    system(VAR_20.c_str());\n  }\n\n  /* COMMENT_11 */\n  string VAR_20 = string(\"pgrep -x -U \") + to_string(VAR_19) + string(\" htmd\");\n  string VAR_21 = SystemToStr(VAR_20.c_str());\n\n  if (VAR_21.length() == 0) {\n    /* COMMENT_12 */\n    int VAR_4 = DaemonCreator::create(false, \"\");\n    if (VAR_4 == DaemonCreator::CHILD) {\n      /* COMMENT_13 */\n      exit(system(\"htmd\"));\n    }\n  }\n\n  /* COMMENT_14 */\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  /* COMMENT_15 */\n  shared_ptr<SocketHandler> VAR_22(new PipeSocketHandler());\n  SocketEndpoint VAR_23;\n  VAR_23.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  VAR_24.run();\n\n  char VAR_25[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(VAR_26, VAR_25, sizeof(VAR_25));\n  fflush(VAR_9);\n  tcsetattr(0, VAR_12, &VAR_11);\n\n  return 0;\n}",
  "func_graph_path_before": "MisterTea/EternalTerminal/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30/HtmClientMain.cpp/vul/before/0.json",
  "func": "int main(int argc, char** argv) {\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n  // Parse command line arguments\n  cxxopts::Options options(\"htm\", \"Headless terminal multiplexer\");\n  options.allow_unrecognised_options();\n\n  options.add_options()       //\n      (\"help\", \"Print help\")  //\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  //\n      ;\n\n  auto result = options.parse(argc, argv);\n  if (result.count(\"help\")) {\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(0);\n  }\n\n  setvbuf(stdin, NULL, _IONBF, 0);   // turn off buffering\n  setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering\n\n  // Turn on raw terminal mode\n  termios terminal_local;\n  tcgetattr(0, &terminal_local);\n  memcpy(&terminal_backup, &terminal_local, sizeof(struct termios));\n  cfmakeraw(&terminal_local);\n  tcsetattr(0, TCSANOW, &terminal_local);\n\n  // Catch sigterm and send exit control code\n  struct sigaction action;\n  memset(&action, 0, sizeof(struct sigaction));\n  action.sa_handler = term;\n  sigaction(SIGTERM, &action, NULL);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  el::Loggers::setVerboseLevel(3);\n  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,\n                            true);\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  uid_t myuid = getuid();\n  if (result.count(\"x\")) {\n    LOG(INFO) << \"Killing previous htmd\";\n    // Kill previous htm daemon\n    string command =\n        string(\"pkill -x -U \") + to_string(myuid) + string(\" htmd\");\n    system(command.c_str());\n  }\n\n  // Check if daemon exists\n  string command = string(\"pgrep -x -U \") + to_string(myuid) + string(\" htmd\");\n  string pgrepOutput = SystemToStr(command.c_str());\n\n  if (pgrepOutput.length() == 0) {\n    // Fork to create the daemon\n    int result = DaemonCreator::create(false, \"\");\n    if (result == DaemonCreator::CHILD) {\n      // This means we are the daemon\n      exit(system(\"htmd\"));\n    }\n  }\n\n  // This means we are the client to the daemon\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  // Sleep for 10ms to let the daemon come alive\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint pipeEndpoint;\n  pipeEndpoint.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  htmClient.run();\n\n  char buf[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf));\n  fflush(stdout);\n  tcsetattr(0, TCSANOW, &terminal_backup);\n\n  return 0;\n}",
  "abstract_func": "int main(int VAR_0, char** VAR_1) {\n  VAR_2;\n  srand(1);\n  /* COMMENT_0 */\n  cxxopts::Options VAR_3(\"htm\", \"Headless terminal multiplexer\");\n  VAR_3.allow_unrecognised_options();\n\n  VAR_3.add_options()       /* COMMENT_1 */\n      (\"help\", \"Print help\")  /* COMMENT_1 */\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  /* COMMENT_1 */\n      ;\n\n  auto VAR_4 = VAR_3.parse(VAR_0, VAR_1);\n  if (VAR_4.count(\"help\")) {\n    CLOG(VAR_5, \"stdout\") << VAR_3.help({}) << VAR_6;\n    exit(0);\n  }\n\n  setvbuf(VAR_7, NULL, VAR_8, 0);   /* COMMENT_2 */\n  setvbuf(VAR_9, NULL, VAR_8, 0);  /* COMMENT_2 */\n\n  /* COMMENT_3 */\n  termios VAR_10;\n  tcgetattr(0, &VAR_10);\n  memcpy(&VAR_11, &VAR_10, sizeof(struct termios));\n  cfmakeraw(&VAR_10);\n  tcsetattr(0, VAR_12, &VAR_10);\n\n  /* COMMENT_4 */\n  struct sigaction VAR_13;\n  memset(&VAR_13, 0, sizeof(struct sigaction));\n  VAR_13.sa_handler = VAR_14;\n  sigaction(VAR_15, &VAR_13, NULL);\n\n  /* COMMENT_5 */\n  el::Configurations VAR_16 = LogHandler::setupLogHandler(&VAR_0, &VAR_1);\n  el::Loggers::setVerboseLevel(3);\n  LogHandler::setupLogFiles(&VAR_16, GetTempDirectory(), \"htm\", false,\n                            true);\n\n  /* COMMENT_6 */\n  el::Loggers::reconfigureLogger(\"default\", VAR_16);\n\n  et::HandleTerminate();\n\n  /* COMMENT_7 */\n  ::signal(VAR_17, et::InterruptSignalHandler);\n\n  uid_t VAR_18 = getuid();\n  if (VAR_4.count(\"x\")) {\n    LOG(VAR_5) << \"Killing previous htmd\";\n    /* COMMENT_8 */\n    string VAR_19 =\n        string(\"pkill -x -U \") + to_string(VAR_18) + string(\" htmd\");\n    system(VAR_19.c_str());\n  }\n\n  /* COMMENT_9 */\n  string VAR_19 = string(\"pgrep -x -U \") + to_string(VAR_18) + string(\" htmd\");\n  string VAR_20 = SystemToStr(VAR_19.c_str());\n\n  if (VAR_20.length() == 0) {\n    /* COMMENT_10 */\n    int VAR_4 = DaemonCreator::create(false, \"\");\n    if (VAR_4 == DaemonCreator::CHILD) {\n      /* COMMENT_11 */\n      exit(system(\"htmd\"));\n    }\n  }\n\n  /* COMMENT_12 */\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  /* COMMENT_13 */\n  shared_ptr<SocketHandler> VAR_21(new PipeSocketHandler());\n  SocketEndpoint VAR_22;\n  VAR_22.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  VAR_23.run();\n\n  char VAR_24[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(VAR_25, VAR_24, sizeof(VAR_24));\n  fflush(VAR_9);\n  tcsetattr(0, VAR_12, &VAR_11);\n\n  return 0;\n}",
  "func_graph_path": "MisterTea/EternalTerminal/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30/HtmClientMain.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,14 +35,9 @@\n \n   // Setup easylogging configurations\n   el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n-  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n   el::Loggers::setVerboseLevel(3);\n-  // default max log file size is 20MB for etserver\n-  string maxlogsize = \"20971520\";\n-  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",\n-                           maxlogsize);\n-  // Redirect std streams to a file\n-  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");\n+  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,\n+                            true);\n \n   // Reconfigure default logger to apply settings above\n   el::Loggers::reconfigureLogger(\"default\", defaultConf);",
  "diff_line_info": {
    "deleted_lines": [
      "  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
      "  // default max log file size is 20MB for etserver",
      "  string maxlogsize = \"20971520\";",
      "  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",",
      "                           maxlogsize);",
      "  // Redirect std streams to a file",
      "  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");"
    ],
    "added_lines": [
      "  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,",
      "                            true);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/MisterTea/EternalTerminal/pull/556",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/MisterTea/EternalTerminal/pull/556: 403 Client Error: Forbidden for url: https://api.github.com/repos/MisterTea/EternalTerminal/pulls/556",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 0.9"
}