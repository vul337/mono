{
  "cve_id": "CVE-2021-29464",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Better bounds checking in Jp2Image::encodeJp2Header()",
  "commit_hash": "f9308839198aca5e68a65194f151a1de92398f54",
  "git_url": "https://github.com/Exiv2/exiv2/commit/f9308839198aca5e68a65194f151a1de92398f54",
  "file_path": "src/jp2image.cpp",
  "func_name": "Jp2Image::encodeJp2Header",
  "func_before": "void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        int32_t       length = getLong((byte*)&pBox->length, bigEndian);\n        int32_t       count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            int32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    }",
  "abstract_func_before": "void Jp2Image::encodeJp2Header(const DataBuf& VAR_0,DataBuf& VAR_1)\n    {\n        DataBuf VAR_2(VAR_0.size_ + VAR_3.size_ + 100); /* COMMENT_0 */\n        int     VAR_4 = sizeof(VAR_5) ; /* COMMENT_1 */\n        int      VAR_6 = sizeof(VAR_5) ; /* COMMENT_2 */\n        Jp2BoxHeader* VAR_7   = (Jp2BoxHeader*) VAR_0.pData_;\n        int32_t       VAR_8 = getLong((byte*)&VAR_7->length, VAR_9);\n        int32_t       VAR_10  = sizeof (Jp2BoxHeader);\n        char*         VAR_11      = (char*) VAR_0.pData_;\n        bool          VAR_12 = false ;\n\n        while ( VAR_10 < VAR_8 || !VAR_12 ) {\n            Jp2BoxHeader* VAR_13 = (Jp2BoxHeader*) (VAR_11+VAR_10) ;\n\n            /* COMMENT_3 */\n            Jp2BoxHeader   VAR_14 ; memcpy(&VAR_14,VAR_13,sizeof(VAR_14));\n            Jp2BoxHeader   VAR_15 =  VAR_14;\n\n            if ( VAR_10 < VAR_8 ) {\n                VAR_14.length = getLong((byte*)&VAR_14.length, VAR_9);\n                VAR_14.type   = getLong((byte*)&VAR_14.type  , VAR_9);\n#ifdef VAR_16\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(VAR_14.type) << \" length = \" << VAR_14.length << std::endl;\n#endif\n                VAR_10        += VAR_14.length;\n                VAR_15.type   = VAR_14.type;\n            } else {\n                VAR_14.length=0;\n                VAR_15.type = VAR_17;\n                VAR_10 = VAR_8;\n            }\n\n            int32_t VAR_18 = VAR_14.length;\n            if ( VAR_15.type == VAR_17 ) {\n                VAR_12 = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* VAR_19   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    VAR_20 = 15;\n                    VAR_18            = sizeof(VAR_15) + VAR_20 ;\n                    ul2Data((byte*)&VAR_15.length,VAR_20      ,VAR_9);\n                    ul2Data((byte*)&VAR_15.type  ,VAR_15.type,VAR_9);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15));\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      ,VAR_19                ,VAR_20         );\n                } else {\n                    const char* VAR_19   = \"\\x02\\x00\\x00\";\n                    uint32_t    VAR_20 = 3;\n                    VAR_18            = sizeof(VAR_15) + VAR_20 + VAR_3.size_;\n                    ul2Data((byte*)&VAR_15.length,VAR_18,VAR_9);\n                    ul2Data((byte*)&VAR_15.type,VAR_15.type,VAR_9);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15)  );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      , VAR_19               ,VAR_20           );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)+VAR_20,VAR_3.pData_,VAR_3.size_);\n                }\n            } else {\n                ::memcpy(VAR_2.pData_+VAR_4,VAR_0.pData_+VAR_6,VAR_14.length);\n            }\n\n            VAR_4 += VAR_18;\n            VAR_6  += VAR_14.length;\n        }\n\n        /* COMMENT_4 */\n        VAR_1.alloc(VAR_4);\n        ::memcpy(VAR_1.pData_,VAR_2.pData_,VAR_4);\n        VAR_7   = (Jp2BoxHeader*) VAR_1.pData_;\n        ul2Data((byte*)&VAR_7->type,VAR_21,VAR_9);\n        ul2Data((byte*)&VAR_7->length,VAR_4,VAR_9);\n    }",
  "func_graph_path_before": "Exiv2/exiv2/f9308839198aca5e68a65194f151a1de92398f54/jp2image.cpp/vul/before/0.json",
  "func": "void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n        uint32_t      count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            uint32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    }",
  "abstract_func": "void Jp2Image::encodeJp2Header(const DataBuf& VAR_0,DataBuf& VAR_1)\n    {\n        DataBuf VAR_2(VAR_0.size_ + VAR_3.size_ + 100); /* COMMENT_0 */\n        long    VAR_4 = sizeof(VAR_5) ; /* COMMENT_1 */\n        long    VAR_6 = sizeof(VAR_5) ; /* COMMENT_2 */\n        Jp2BoxHeader* VAR_7   = (Jp2BoxHeader*) VAR_0.pData_;\n        uint32_t      VAR_8 = getLong((byte*)&VAR_7->length, VAR_9);\n        uint32_t      VAR_10  = sizeof (Jp2BoxHeader);\n        char*         VAR_11      = (char*) VAR_0.pData_;\n        bool          VAR_12 = false ;\n\n        while ( VAR_10 < VAR_8 || !VAR_12 ) {\n            Jp2BoxHeader* VAR_13 = (Jp2BoxHeader*) (VAR_11+VAR_10) ;\n\n            /* COMMENT_3 */\n            Jp2BoxHeader   VAR_14 ; memcpy(&VAR_14,VAR_13,sizeof(VAR_14));\n            Jp2BoxHeader   VAR_15 =  VAR_14;\n\n            if ( VAR_10 < VAR_8 ) {\n                VAR_14.length = getLong((byte*)&VAR_14.length, VAR_9);\n                VAR_14.type   = getLong((byte*)&VAR_14.type  , VAR_9);\n#ifdef VAR_16\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(VAR_14.type) << \" length = \" << VAR_14.length << std::endl;\n#endif\n                enforce(VAR_14.length <= VAR_8 - VAR_10, Exiv2::kerCorruptedMetadata);\n                VAR_10        += VAR_14.length;\n                VAR_15.type   = VAR_14.type;\n            } else {\n                VAR_14.length=0;\n                VAR_15.type = VAR_17;\n                VAR_10 = VAR_8;\n            }\n\n            uint32_t VAR_18 = VAR_14.length;\n            if ( VAR_15.type == VAR_17 ) {\n                VAR_12 = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* VAR_19   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    VAR_20 = 15;\n                    VAR_18            = sizeof(VAR_15) + VAR_20 ;\n                    enforce(VAR_18 <= VAR_2.size_ - VAR_4, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&VAR_15.length,VAR_20      ,VAR_9);\n                    ul2Data((byte*)&VAR_15.type  ,VAR_15.type,VAR_9);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15));\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      ,VAR_19                ,VAR_20         );\n                } else {\n                    const char* VAR_19   = \"\\x02\\x00\\x00\";\n                    uint32_t    VAR_20 = 3;\n                    VAR_18            = sizeof(VAR_15) + VAR_20 + VAR_3.size_;\n                    enforce(VAR_18 <= VAR_2.size_ - VAR_4, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&VAR_15.length,VAR_18,VAR_9);\n                    ul2Data((byte*)&VAR_15.type,VAR_15.type,VAR_9);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15)  );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      , VAR_19               ,VAR_20           );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)+VAR_20,VAR_3.pData_,VAR_3.size_);\n                }\n            } else {\n                enforce(VAR_18 <= VAR_2.size_ - VAR_4, Exiv2::kerCorruptedMetadata);\n                ::memcpy(VAR_2.pData_+VAR_4,VAR_0.pData_+VAR_6,VAR_14.length);\n            }\n\n            VAR_4 += VAR_18;\n            VAR_6  += VAR_14.length;\n        }\n\n        /* COMMENT_4 */\n        VAR_1.alloc(VAR_4);\n        ::memcpy(VAR_1.pData_,VAR_2.pData_,VAR_4);\n        VAR_7   = (Jp2BoxHeader*) VAR_1.pData_;\n        ul2Data((byte*)&VAR_7->type,VAR_21,VAR_9);\n        ul2Data((byte*)&VAR_7->length,VAR_4,VAR_9);\n    }",
  "func_graph_path": "Exiv2/exiv2/f9308839198aca5e68a65194f151a1de92398f54/jp2image.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,11 @@\n void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n     {\n         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n-        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n-        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n+        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n+        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n-        int32_t       length = getLong((byte*)&pBox->length, bigEndian);\n-        int32_t       count  = sizeof (Jp2BoxHeader);\n+        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n+        uint32_t      count  = sizeof (Jp2BoxHeader);\n         char*         p      = (char*) boxBuf.pData_;\n         bool          bWroteColor = false ;\n \n@@ -22,6 +22,7 @@\n #ifdef EXIV2_DEBUG_MESSAGES\n                 std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n #endif\n+                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n                 count        += subBox.length;\n                 newBox.type   = subBox.type;\n             } else {\n@@ -30,13 +31,14 @@\n                 count = length;\n             }\n \n-            int32_t newlen = subBox.length;\n+            uint32_t newlen = subBox.length;\n             if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                 bWroteColor = true ;\n                 if ( ! iccProfileDefined() ) {\n                     const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                     uint32_t    psize = 15;\n                     newlen            = sizeof(newBox) + psize ;\n+                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n@@ -45,6 +47,7 @@\n                     const char* pad   = \"\\x02\\x00\\x00\";\n                     uint32_t    psize = 3;\n                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n+                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                     ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n@@ -52,6 +55,7 @@\n                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                 }\n             } else {\n+                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n             }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "        int32_t       length = getLong((byte*)&pBox->length, bigEndian);",
      "        int32_t       count  = sizeof (Jp2BoxHeader);",
      "            int32_t newlen = subBox.length;"
    ],
    "added_lines": [
      "        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?",
      "        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?",
      "        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);",
      "        uint32_t      count  = sizeof (Jp2BoxHeader);",
      "                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);",
      "            uint32_t newlen = subBox.length;",
      "                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);",
      "                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/1578",
  "description": {
    "pr_info": {
      "title": "Main jp2 image bounts",
      "number": 1578
    },
    "comment": [
      "Port of #1576 to `main`\r\n\r\n@kevinbackhouse I decided to port this so that we do not forget to include these changes in master. However, if you had something else in mind for the synchronisation process between 0.27-maintenance and master, please let me know. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.85"
}