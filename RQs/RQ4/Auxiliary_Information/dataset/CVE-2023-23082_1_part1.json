{
  "cve_id": "CVE-2023-23082",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "xbmc",
  "commit_msg": "ExifParse: Backport further upstream fixes\n\nPartially via upstream commit:\nhttps://android.googlesource.com/platform/external/jhead/+/2a4c12f5e5808e309b9ba04fe8b1539debf466d1",
  "commit_hash": "7e5f9fbf9aaa3540aab35e7504036855b23dcf60",
  "git_url": "https://github.com/xbmc/xbmc/commit/7e5f9fbf9aaa3540aab35e7504036855b23dcf60",
  "file_path": "xbmc/pictures/ExifParse.cpp",
  "func_name": "CExifParse::Process",
  "func_before": "bool CExifParse::Process (const unsigned char* const ExifSection, const unsigned short length, ExifInfo_t *info)\n{\n  m_ExifInfo = info;\n  // EXIF signature: \"Exif\\0\\0\"\n  // Check EXIF signatures\n  const char ExifHeader[]     = \"Exif\\0\\0\";\n  const char ExifAlignment0[] = \"II\";\n  const char ExifAlignment1[] = \"MM\";\n  const char ExifExtra        = 0x2a;\n\n  const char* pos = (const char*)(ExifSection + sizeof(short));   // position data pointer after length field\n\n  if (memcmp(pos, ExifHeader,6))\n  {\n    printf(\"ExifParse: incorrect Exif header\");\n    return false;\n  }\n  pos += 6;\n\n  if (memcmp(pos, ExifAlignment0, strlen(ExifAlignment0)) == 0)\n  {\n    m_MotorolaOrder = false;\n  }\n  else if (memcmp(pos, ExifAlignment1, strlen(ExifAlignment1)) == 0)\n  {\n    m_MotorolaOrder = true;\n  }\n  else\n  {\n    printf(\"ExifParse: invalid Exif alignment marker\");\n    return false;\n  }\n  pos += strlen(ExifAlignment0);\n\n  // Check the next value for correctness.\n  if (Get16((const void*)(pos), m_MotorolaOrder) != ExifExtra)\n  {\n    printf(\"ExifParse: invalid Exif start (1)\");\n    return false;\n  }\n  pos += sizeof(short);\n\n  unsigned long FirstOffset = (unsigned)Get32((const void*)pos, m_MotorolaOrder);\n  if (FirstOffset < 8 || FirstOffset > 16)\n  {\n    // Usually set to 8, but other values valid too.\n//  CLog::Log(LOGERROR, \"ExifParse: suspicious offset of first IFD value\");\n  }\n\n\n\n  // First directory starts 16 bytes in.  All offset are relative to 8 bytes in.\n  ProcessDir(ExifSection+8+FirstOffset, ExifSection+8, length-8, 0);\n\n  m_ExifInfo->ThumbnailAtEnd = m_ExifInfo->ThumbnailOffset >= m_LargestExifOffset;\n\n  // Compute the CCD width, in millimeters.\n  if (m_FocalPlaneXRes != 0)\n  {\n    // Note: With some cameras, its not possible to compute this correctly because\n    // they don't adjust the indicated focal plane resolution units when using less\n    // than maximum resolution, so the CCDWidth value comes out too small.  Nothing\n    // that Jhead can do about it - its a camera problem.\n    m_ExifInfo->CCDWidth = (float)(m_ExifImageWidth * m_FocalPlaneUnits / m_FocalPlaneXRes);\n  }\n\n  if (m_ExifInfo->FocalLength)\n  {\n    if (m_ExifInfo->FocalLength35mmEquiv == 0)\n    {\n      // Compute 35 mm equivalent focal length based on sensor geometry if we haven't\n      // already got it explicitly from a tag.\n      if (m_ExifInfo->CCDWidth != 0.0f)\n      {\n        m_ExifInfo->FocalLength35mmEquiv =\n            (int)(m_ExifInfo->FocalLength / m_ExifInfo->CCDWidth * 36 + 0.5f);\n      }\n    }\n  }\n  return true;\n}",
  "abstract_func_before": "bool CExifParse::Process (const unsigned char* const VAR_0, const unsigned short VAR_1, ExifInfo_t *VAR_2)\n{\n  VAR_3 = VAR_2;\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  const char VAR_4[]     = \"Exif\\0\\0\";\n  const char VAR_5[] = \"II\";\n  const char VAR_6[] = \"MM\";\n  const char VAR_7        = 0x2a;\n\n  const char* VAR_8 = (const char*)(VAR_0 + sizeof(short));   /* COMMENT_2 */\n\n  if (memcmp(VAR_8, VAR_4,6))\n  {\n    printf(\"ExifParse: incorrect Exif header\");\n    return false;\n  }\n  VAR_8 += 6;\n\n  if (memcmp(VAR_8, VAR_5, strlen(VAR_5)) == 0)\n  {\n    VAR_9 = false;\n  }\n  else if (memcmp(VAR_8, VAR_6, strlen(VAR_6)) == 0)\n  {\n    VAR_9 = true;\n  }\n  else\n  {\n    printf(\"ExifParse: invalid Exif alignment marker\");\n    return false;\n  }\n  VAR_8 += strlen(VAR_5);\n\n  /* COMMENT_3 */\n  if (Get16((const void*)(VAR_8), VAR_9) != VAR_7)\n  {\n    printf(\"ExifParse: invalid Exif start (1)\");\n    return false;\n  }\n  VAR_8 += sizeof(short);\n\n  unsigned long VAR_10 = (unsigned)Get32((const void*)VAR_8, VAR_9);\n  if (VAR_10 < 8 || VAR_10 > 16)\n  {\n    /* COMMENT_4 */\n/* COMMENT_5 */\n  }\n\n\n\n  /* COMMENT_6 */\n  ProcessDir(VAR_0+8+VAR_10, VAR_0+8, VAR_1-8, 0);\n\n  VAR_3->ThumbnailAtEnd = VAR_3->ThumbnailOffset >= VAR_11;\n\n  /* COMMENT_7 */\n  if (VAR_12 != 0)\n  {\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    VAR_3->CCDWidth = (float)(VAR_13 * VAR_14 / VAR_12);\n  }\n\n  if (VAR_3->FocalLength)\n  {\n    if (VAR_3->FocalLength35mmEquiv == 0)\n    {\n      /* COMMENT_12 */\n      /* COMMENT_13 */\n      if (VAR_3->CCDWidth != 0.0f)\n      {\n        VAR_3->FocalLength35mmEquiv =\n            (int)(VAR_3->FocalLength / VAR_3->CCDWidth * 36 + 0.5f);\n      }\n    }\n  }\n  return true;\n}",
  "func_graph_path_before": "xbmc/7e5f9fbf9aaa3540aab35e7504036855b23dcf60/ExifParse.cpp/vul/before/2.json",
  "func": "bool CExifParse::Process (const unsigned char* const ExifSection, const unsigned short length, ExifInfo_t *info)\n{\n  m_ExifInfo = info;\n  // EXIF signature: \"Exif\\0\\0\"\n  // Check EXIF signatures\n  const char ExifHeader[]     = \"Exif\\0\\0\";\n  const char ExifAlignment0[] = \"II\";\n  const char ExifAlignment1[] = \"MM\";\n  const char ExifExtra        = 0x2a;\n\n  const char* pos = (const char*)(ExifSection + sizeof(short));   // position data pointer after length field\n\n  if (memcmp(pos, ExifHeader,6))\n  {\n    printf(\"ExifParse: incorrect Exif header\");\n    return false;\n  }\n  pos += 6;\n\n  if (memcmp(pos, ExifAlignment0, strlen(ExifAlignment0)) == 0)\n  {\n    m_MotorolaOrder = false;\n  }\n  else if (memcmp(pos, ExifAlignment1, strlen(ExifAlignment1)) == 0)\n  {\n    m_MotorolaOrder = true;\n  }\n  else\n  {\n    printf(\"ExifParse: invalid Exif alignment marker\");\n    return false;\n  }\n  pos += strlen(ExifAlignment0);\n\n  // Check the next value for correctness.\n  if (Get16((const void*)(pos), m_MotorolaOrder) != ExifExtra)\n  {\n    printf(\"ExifParse: invalid Exif start (1)\");\n    return false;\n  }\n  pos += sizeof(short);\n\n  unsigned long FirstOffset = (unsigned)Get32((const void*)pos, m_MotorolaOrder);\n  if (FirstOffset < 8 || FirstOffset + 8 >= length)\n  {\n    ErrNonfatal(\"Invalid offset of first IFD value: %u\", FirstOffset, 0);\n    return false;\n  }\n\n\n\n  // First directory starts 16 bytes in.  All offset are relative to 8 bytes in.\n  ProcessDir(ExifSection+8+FirstOffset, ExifSection+8, length-8, 0);\n\n  m_ExifInfo->ThumbnailAtEnd = m_ExifInfo->ThumbnailOffset >= m_LargestExifOffset;\n\n  // Compute the CCD width, in millimeters.\n  if (m_FocalPlaneXRes != 0)\n  {\n    // Note: With some cameras, its not possible to compute this correctly because\n    // they don't adjust the indicated focal plane resolution units when using less\n    // than maximum resolution, so the CCDWidth value comes out too small.  Nothing\n    // that Jhead can do about it - its a camera problem.\n    m_ExifInfo->CCDWidth = (float)(m_ExifImageWidth * m_FocalPlaneUnits / m_FocalPlaneXRes);\n  }\n\n  if (m_ExifInfo->FocalLength)\n  {\n    if (m_ExifInfo->FocalLength35mmEquiv == 0)\n    {\n      // Compute 35 mm equivalent focal length based on sensor geometry if we haven't\n      // already got it explicitly from a tag.\n      if (m_ExifInfo->CCDWidth != 0.0f)\n      {\n        m_ExifInfo->FocalLength35mmEquiv =\n            (int)(m_ExifInfo->FocalLength / m_ExifInfo->CCDWidth * 36 + 0.5f);\n      }\n    }\n  }\n  return true;\n}",
  "abstract_func": "bool CExifParse::Process (const unsigned char* const VAR_0, const unsigned short VAR_1, ExifInfo_t *VAR_2)\n{\n  VAR_3 = VAR_2;\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  const char VAR_4[]     = \"Exif\\0\\0\";\n  const char VAR_5[] = \"II\";\n  const char VAR_6[] = \"MM\";\n  const char VAR_7        = 0x2a;\n\n  const char* VAR_8 = (const char*)(VAR_0 + sizeof(short));   /* COMMENT_2 */\n\n  if (memcmp(VAR_8, VAR_4,6))\n  {\n    printf(\"ExifParse: incorrect Exif header\");\n    return false;\n  }\n  VAR_8 += 6;\n\n  if (memcmp(VAR_8, VAR_5, strlen(VAR_5)) == 0)\n  {\n    VAR_9 = false;\n  }\n  else if (memcmp(VAR_8, VAR_6, strlen(VAR_6)) == 0)\n  {\n    VAR_9 = true;\n  }\n  else\n  {\n    printf(\"ExifParse: invalid Exif alignment marker\");\n    return false;\n  }\n  VAR_8 += strlen(VAR_5);\n\n  /* COMMENT_3 */\n  if (Get16((const void*)(VAR_8), VAR_9) != VAR_7)\n  {\n    printf(\"ExifParse: invalid Exif start (1)\");\n    return false;\n  }\n  VAR_8 += sizeof(short);\n\n  unsigned long VAR_10 = (unsigned)Get32((const void*)VAR_8, VAR_9);\n  if (VAR_10 < 8 || VAR_10 + 8 >= VAR_1)\n  {\n    ErrNonfatal(\"Invalid offset of first IFD value: %u\", VAR_10, 0);\n    return false;\n  }\n\n\n\n  /* COMMENT_4 */\n  ProcessDir(VAR_0+8+VAR_10, VAR_0+8, VAR_1-8, 0);\n\n  VAR_3->ThumbnailAtEnd = VAR_3->ThumbnailOffset >= VAR_11;\n\n  /* COMMENT_5 */\n  if (VAR_12 != 0)\n  {\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    VAR_3->CCDWidth = (float)(VAR_13 * VAR_14 / VAR_12);\n  }\n\n  if (VAR_3->FocalLength)\n  {\n    if (VAR_3->FocalLength35mmEquiv == 0)\n    {\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      if (VAR_3->CCDWidth != 0.0f)\n      {\n        VAR_3->FocalLength35mmEquiv =\n            (int)(VAR_3->FocalLength / VAR_3->CCDWidth * 36 + 0.5f);\n      }\n    }\n  }\n  return true;\n}",
  "func_graph_path": "xbmc/7e5f9fbf9aaa3540aab35e7504036855b23dcf60/ExifParse.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -41,10 +41,10 @@\n   pos += sizeof(short);\n \n   unsigned long FirstOffset = (unsigned)Get32((const void*)pos, m_MotorolaOrder);\n-  if (FirstOffset < 8 || FirstOffset > 16)\n+  if (FirstOffset < 8 || FirstOffset + 8 >= length)\n   {\n-    // Usually set to 8, but other values valid too.\n-//  CLog::Log(LOGERROR, \"ExifParse: suspicious offset of first IFD value\");\n+    ErrNonfatal(\"Invalid offset of first IFD value: %u\", FirstOffset, 0);\n+    return false;\n   }\n \n ",
  "diff_line_info": {
    "deleted_lines": [
      "  if (FirstOffset < 8 || FirstOffset > 16)",
      "    // Usually set to 8, but other values valid too.",
      "//  CLog::Log(LOGERROR, \"ExifParse: suspicious offset of first IFD value\");"
    ],
    "added_lines": [
      "  if (FirstOffset < 8 || FirstOffset + 8 >= length)",
      "    ErrNonfatal(\"Invalid offset of first IFD value: %u\", FirstOffset, 0);",
      "    return false;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xbmc/xbmc/pull/22380",
  "description": {
    "pr_info": {
      "title": "ExifParser: Fix several out of bounds accesses while parsing exif information",
      "number": 22380
    },
    "comment": [
      "Several drafted images could crash kodi. This was tested with memory, address sanitizers enabled.\r\ncmake -DENABLE_VAAPI=1 -DCORE_PLATFORM_NAME=wayland -DCMAKE_BUILD_TYPE=Debug -DAPP_RENDER_SYSTEM=gl -DECM_ENABLE_SANITIZERS=address,memory\r\n\r\nExample Output:\r\nSUMMARY: AddressSanitizer: heap-buffer-overflow (/home/fritsch/Desktop/xbmc-fritsch/xbmc/build/kodi-wayland+0x3dca321) in CExifParse::Get32(void const*, bool)\r\nShadow bytes around the buggy address:\r\n  0x0c3c8004e070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e0a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e0b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n=>0x0c3c8004e0c0: 00 00 00 00 00[04]fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e0d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e0e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e0f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07 \r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n  Shadow gap:              cc\r\n==824657==ABORTING\r\n\r\nvia: https://paste.kodi.tv/kagukejefa.kodi\r\n\r\nThe issues were long fixed upstream: https://android.googlesource.com/platform/external/jhead/+/2a4c12f5e5808e309b9ba04fe8b1539debf466d1\r\n\r\nKodi should remove the copied libexif code and use jhead directly.\r\n\r\nThis fixes: #22377 "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}