{
  "cve_id": "CVE-2023-30546",
  "cwe_ids": [
    "CWE-193",
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "antelope,storage-cfs: Fix length of filename array",
  "commit_hash": "406ae7da30fb5fadacf0d646a4dc4ac0513a2dec",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/406ae7da30fb5fadacf0d646a4dc4ac0513a2dec",
  "file_path": "os/storage/antelope/storage-cfs.c",
  "func_name": "storage_put_index",
  "func_before": "db_result_t\nstorage_put_index(index_t *index)\n{\n  char filename[INDEX_NAME_LENGTH];\n  int fd;\n  int r;\n  struct index_record record;\n  db_result_t result;\n\n  merge_strings(filename, index->rel->name, INDEX_NAME_SUFFIX);\n\n  fd = cfs_open(filename, CFS_WRITE | CFS_APPEND);\n  if(fd < 0) {\n    return DB_STORAGE_ERROR;\n  }\n\n  strcpy(record.attribute_name, index->attr->name);\n  memcpy(record.file_name, index->descriptor_file, sizeof(record.file_name));\n  record.type = index->type;\n\n  result = DB_OK;\n  r = cfs_write(fd, &record, sizeof(record));\n  if(r < sizeof(record)) {\n    result = DB_STORAGE_ERROR;\n  } else {\n    PRINTF(\"DB: Wrote an index record for %s.%s, type %d\\n\",\n      index->rel->name, index->attr->name, record.type);\n  }\n\n  cfs_close(fd);\n\n  return result;\n}",
  "abstract_func_before": "db_result_t\nstorage_put_index(index_t *VAR_0)\n{\n  char VAR_1[VAR_2];\n  int VAR_3;\n  int VAR_4;\n  struct index_record VAR_5;\n  db_result_t VAR_6;\n\n  merge_strings(VAR_1, VAR_0->rel->name, VAR_7);\n\n  VAR_3 = cfs_open(VAR_1, VAR_8 | VAR_9);\n  if(VAR_3 < 0) {\n    return VAR_10;\n  }\n\n  strcpy(VAR_5.attribute_name, VAR_0->attr->name);\n  memcpy(VAR_5.file_name, VAR_0->descriptor_file, sizeof(VAR_5.file_name));\n  VAR_5.type = VAR_0->type;\n\n  VAR_6 = VAR_11;\n  VAR_4 = cfs_write(VAR_3, &VAR_5, sizeof(VAR_5));\n  if(VAR_4 < sizeof(VAR_5)) {\n    VAR_6 = VAR_10;\n  } else {\n    PRINTF(\"DB: Wrote an index record for %s.%s, type %d\\n\",\n      VAR_0->rel->name, VAR_0->attr->name, VAR_5.type);\n  }\n\n  cfs_close(VAR_3);\n\n  return VAR_6;\n}",
  "func_graph_path_before": "contiki-ng/406ae7da30fb5fadacf0d646a4dc4ac0513a2dec/storage-cfs.c/vul/before/0.json",
  "func": "db_result_t\nstorage_put_index(index_t *index)\n{\n  char filename[INDEX_NAME_LENGTH + 1];\n  int fd;\n  int r;\n  struct index_record record;\n  db_result_t result;\n\n  merge_strings(filename, index->rel->name, INDEX_NAME_SUFFIX);\n\n  fd = cfs_open(filename, CFS_WRITE | CFS_APPEND);\n  if(fd < 0) {\n    return DB_STORAGE_ERROR;\n  }\n\n  strcpy(record.attribute_name, index->attr->name);\n  memcpy(record.file_name, index->descriptor_file, sizeof(record.file_name));\n  record.type = index->type;\n\n  result = DB_OK;\n  r = cfs_write(fd, &record, sizeof(record));\n  if(r < sizeof(record)) {\n    result = DB_STORAGE_ERROR;\n  } else {\n    PRINTF(\"DB: Wrote an index record for %s.%s, type %d\\n\",\n      index->rel->name, index->attr->name, record.type);\n  }\n\n  cfs_close(fd);\n\n  return result;\n}",
  "abstract_func": "db_result_t\nstorage_put_index(index_t *VAR_0)\n{\n  char VAR_1[VAR_2 + 1];\n  int VAR_3;\n  int VAR_4;\n  struct index_record VAR_5;\n  db_result_t VAR_6;\n\n  merge_strings(VAR_1, VAR_0->rel->name, VAR_7);\n\n  VAR_3 = cfs_open(VAR_1, VAR_8 | VAR_9);\n  if(VAR_3 < 0) {\n    return VAR_10;\n  }\n\n  strcpy(VAR_5.attribute_name, VAR_0->attr->name);\n  memcpy(VAR_5.file_name, VAR_0->descriptor_file, sizeof(VAR_5.file_name));\n  VAR_5.type = VAR_0->type;\n\n  VAR_6 = VAR_11;\n  VAR_4 = cfs_write(VAR_3, &VAR_5, sizeof(VAR_5));\n  if(VAR_4 < sizeof(VAR_5)) {\n    VAR_6 = VAR_10;\n  } else {\n    PRINTF(\"DB: Wrote an index record for %s.%s, type %d\\n\",\n      VAR_0->rel->name, VAR_0->attr->name, VAR_5.type);\n  }\n\n  cfs_close(VAR_3);\n\n  return VAR_6;\n}",
  "func_graph_path": "contiki-ng/406ae7da30fb5fadacf0d646a4dc4ac0513a2dec/storage-cfs.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n db_result_t\n storage_put_index(index_t *index)\n {\n-  char filename[INDEX_NAME_LENGTH];\n+  char filename[INDEX_NAME_LENGTH + 1];\n   int fd;\n   int r;\n   struct index_record record;",
  "diff_line_info": {
    "deleted_lines": [
      "  char filename[INDEX_NAME_LENGTH];"
    ],
    "added_lines": [
      "  char filename[INDEX_NAME_LENGTH + 1];"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/2425",
  "description": {
    "pr_info": {
      "title": "antelope,storage-cfs: Fix length of filename array",
      "number": 2425
    },
    "comment": [
      "https://github.com/contiki-ng/contiki-ng/blob/406ae7da30fb5fadacf0d646a4dc4ac0513a2dec/os/storage/antelope/storage.h#L47-L49\r\nThe macro `INDEX_NAME_LENGTH` does not count the trailing null char.",
      "This looks like a off-by-one-byte error. Should there be a CVE for this? (@nvt)",
      "@Machiry Yes, it might get a CVE, but it is difficult to exploit the bug without direct access to the DBMS; e.g., by being able to inject shell commands into the IoT node.",
      "I agree about the exploitability. But given that this is in a storage stack, it is better to have a CVE (may be a low-severity)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}