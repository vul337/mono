{
  "cve_id": "CVE-2023-36328",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "libtom/libtommath",
  "commit_msg": "Fix possible integer overflow",
  "commit_hash": "beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "git_url": "https://github.com/libtom/libtommath/commit/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "file_path": "bn_mp_grow.c",
  "func_name": "mp_grow",
  "func_before": "mp_err mp_grow(mp_int *a, int size)\n{\n   int     i;\n   mp_digit *tmp;\n\n   /* if the alloc size is smaller alloc more ram */\n   if (a->alloc < size) {\n      /* reallocate the array a->dp\n       *\n       * We store the return in a temporary variable\n       * in case the operation failed we don't want\n       * to overwrite the dp member of a.\n       */\n      tmp = (mp_digit *) MP_REALLOC(a->dp,\n                                    (size_t)a->alloc * sizeof(mp_digit),\n                                    (size_t)size * sizeof(mp_digit));\n      if (tmp == NULL) {\n         /* reallocation failed but \"a\" is still valid [can be freed] */\n         return MP_MEM;\n      }\n\n      /* reallocation succeeded so set a->dp */\n      a->dp = tmp;\n\n      /* zero excess digits */\n      i        = a->alloc;\n      a->alloc = size;\n      MP_ZERO_DIGITS(a->dp + i, a->alloc - i);\n   }\n   return MP_OKAY;\n}",
  "abstract_func_before": "mp_err mp_grow(mp_int *VAR_0, int VAR_1)\n{\n   int     VAR_2;\n   mp_digit *VAR_3;\n\n   /* COMMENT_0 */\n   if (VAR_0->alloc < VAR_1) {\n      /* COMMENT_1 */\n        \n                                                    \n                                                   \n                                         \n         \n      VAR_3 = (mp_digit *) MP_REALLOC(VAR_0->dp,\n                                    (size_t)VAR_0->alloc * sizeof(mp_digit),\n                                    (size_t)VAR_1 * sizeof(mp_digit));\n      if (VAR_3 == NULL) {\n         /* COMMENT_7 */\n         return VAR_4;\n      }\n\n      /* COMMENT_8 */\n      VAR_0->dp = VAR_3;\n\n      /* COMMENT_9 */\n      VAR_2        = VAR_0->alloc;\n      VAR_0->alloc = VAR_1;\n      MP_ZERO_DIGITS(VAR_0->dp + VAR_2, VAR_0->alloc - VAR_2);\n   }\n   return VAR_5;\n}",
  "func_graph_path_before": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_mp_grow.c/vul/before/0.json",
  "func": "mp_err mp_grow(mp_int *a, int size)\n{\n   int     i;\n   mp_digit *tmp;\n\n   if (size < 0) {\n      return MP_VAL;\n   }\n\n   /* if the alloc size is smaller alloc more ram */\n   if (a->alloc < size) {\n      /* reallocate the array a->dp\n       *\n       * We store the return in a temporary variable\n       * in case the operation failed we don't want\n       * to overwrite the dp member of a.\n       */\n      tmp = (mp_digit *) MP_REALLOC(a->dp,\n                                    (size_t)a->alloc * sizeof(mp_digit),\n                                    (size_t)size * sizeof(mp_digit));\n      if (tmp == NULL) {\n         /* reallocation failed but \"a\" is still valid [can be freed] */\n         return MP_MEM;\n      }\n\n      /* reallocation succeeded so set a->dp */\n      a->dp = tmp;\n\n      /* zero excess digits */\n      i        = a->alloc;\n      a->alloc = size;\n      MP_ZERO_DIGITS(a->dp + i, a->alloc - i);\n   }\n   return MP_OKAY;\n}",
  "abstract_func": "mp_err mp_grow(mp_int *VAR_0, int VAR_1)\n{\n   int     VAR_2;\n   mp_digit *VAR_3;\n\n   if (VAR_1 < 0) {\n      return VAR_4;\n   }\n\n   /* COMMENT_0 */\n   if (VAR_0->alloc < VAR_1) {\n      /* COMMENT_1 */\n        \n                                                    \n                                                   \n                                         \n         \n      VAR_3 = (mp_digit *) MP_REALLOC(VAR_0->dp,\n                                    (size_t)VAR_0->alloc * sizeof(mp_digit),\n                                    (size_t)VAR_1 * sizeof(mp_digit));\n      if (VAR_3 == NULL) {\n         /* COMMENT_7 */\n         return VAR_5;\n      }\n\n      /* COMMENT_8 */\n      VAR_0->dp = VAR_3;\n\n      /* COMMENT_9 */\n      VAR_2        = VAR_0->alloc;\n      VAR_0->alloc = VAR_1;\n      MP_ZERO_DIGITS(VAR_0->dp + VAR_2, VAR_0->alloc - VAR_2);\n   }\n   return VAR_6;\n}",
  "func_graph_path": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_mp_grow.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,10 @@\n {\n    int     i;\n    mp_digit *tmp;\n+\n+   if (size < 0) {\n+      return MP_VAL;\n+   }\n \n    /* if the alloc size is smaller alloc more ram */\n    if (a->alloc < size) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "   if (size < 0) {",
      "      return MP_VAL;",
      "   }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libtom/libtommath/pull/546",
  "description": {
    "pr_info": {
      "title": "Fix possible integer overflow",
      "number": 546
    },
    "comment": [
      "It was possible to give `mp_grow` a negative size argument.\r\nSeveral other functions got an extra check for negative input, too.",
      "@sjaeckel please ask the reporter of that bug if they want to remain anonymous. I would like to put their name in, otherwise.",
      "@gal1ium thanks for reporting this. Do you wanna have a look at the changes?",
      "> @gal1ium thanks for reporting this. Do you wanna have a look at the changes?\r\n\r\nI think they're good! Thanks!",
      "> I double checked and it looks good.\r\n\r\nNone forgotten? Good.\r\n\r\n> I also cherry-picked this to develop locally and will open a PR soon.\r\n\r\nAh, thanks, wasn't able to get to it till now.\r\n",
      "@dod38fr @scaronni @gahr @DimStar77 @dfandrich @antonio-rojas @millak\r\n\r\ncould you please include this patch in your distro?",
      "@sjaeckel I can do that - are you planning a patch release, anyway?",
      "Does this fix a security vulnerability? Glacing at the diff, it looks like it fixes some things that a buggy program might hit but affect parameters that would not generally be under the control of an attacker.",
      "> @dod38fr @scaronni @gahr @DimStar77 @dfandrich @antonio-rojas @Millak\r\n> \r\n> could you please include this patch in your distro?\r\n\r\nIt's too late for Debian 12 which is to be released next week. \r\n\r\nI'll patch libtommath in Debian/unstable once Debian 12 is out. If this bug turns out to be a security issue, I'll make sure to include in a future Debian 12 point release (e.g. 12.1).",
      "I patched the FreeBSD port: https://cgit.freebsd.org/ports/commit/?id=02c46239ac8dce1c3573803e6c95ae152aa61ee9\r\n\r\nstill eager to know if there's a release coming",
      "I don't think there will be a patch release, but a new release will come which includes this patch.",
      "CVE-2023-36328 was assigned to this.\r\n\r\nI had no involvement in the assignment, posting here for reference only.",
      "Seems like someone really thinks that this needs a bugfix release ...\r\n\r\nhttps://github.com/libtom/libtommath/releases/tag/v1.2.1",
      "I see an error in the description https://nvd.nist.gov/vuln/detail/CVE-2023-36328#range-9994440 of the versions affected by the vulnerability. Version 1.2.1 is included, although it contains changes from this commit:\r\nhttps://github.com/libtom/libtommath/pull/546/commits/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9\r\nCan you correct and remove version 1.2.1 from the nist.gov description?",
      "I contacted them, let's see what happens and when :-) ",
      "Version is fixed, list will be updated within the next 24hours"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch addresses an integer overflow vulnerability by adding a check for negative size arguments, preventing a security risk."
}