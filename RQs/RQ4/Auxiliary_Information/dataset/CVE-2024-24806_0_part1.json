{
  "cve_id": "CVE-2024-24806",
  "cwe_ids": [
    "CWE-918"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
  "cvss_is_v3": true,
  "repo_name": "libuv",
  "commit_msg": "fix: reject zero-length idna inputs\n\nFixes: https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6",
  "commit_hash": "3530bcc30350d4a6ccf35d2f7b33e23292b9de70",
  "git_url": "https://github.com/libuv/libuv/commit/3530bcc30350d4a6ccf35d2f7b33e23292b9de70",
  "file_path": "src/idna.c",
  "func_name": "uv__idna_toascii",
  "func_before": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
  "abstract_func_before": "ssize_t uv__idna_toascii(const char* VAR_0, const char* VAR_1, char* VAR_2, char* VAR_3) {\n  const char* VAR_4;\n  const char* VAR_5;\n  unsigned VAR_6;\n  char* VAR_7;\n  int VAR_8;\n\n  VAR_7 = VAR_2;\n\n  VAR_4 = VAR_0;\n  while (VAR_4 < VAR_1) {\n    VAR_5 = VAR_4;\n    VAR_6 = uv__utf8_decode1(&VAR_4, VAR_1);\n\n    if (VAR_6 == VAR_9)\n      return VAR_10;\n\n    if (VAR_6 != '.')\n      if (VAR_6 != 0x3002)  /* COMMENT_0 */\n        if (VAR_6 != 0xFF0E)  /* COMMENT_1 */\n          if (VAR_6 != 0xFF61)  /* COMMENT_2 */\n            continue;\n\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_5, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n\n    if (VAR_2 < VAR_3)\n      *VAR_2++ = '.';\n\n    VAR_0 = VAR_4;\n  }\n\n  if (VAR_0 < VAR_1) {\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_1, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n  }\n\n  if (VAR_2 >= VAR_3)\n    return VAR_10;\n\n  *VAR_2++ = '\\0';\n  return VAR_2 - VAR_7;  /* COMMENT_3 */\n}",
  "func_graph_path_before": "libuv/3530bcc30350d4a6ccf35d2f7b33e23292b9de70/idna.c/vul/before/0.json",
  "func": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  if (s == se)\n    return UV_EINVAL;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
  "abstract_func": "ssize_t uv__idna_toascii(const char* VAR_0, const char* VAR_1, char* VAR_2, char* VAR_3) {\n  const char* VAR_4;\n  const char* VAR_5;\n  unsigned VAR_6;\n  char* VAR_7;\n  int VAR_8;\n\n  if (VAR_0 == VAR_1)\n    return VAR_9;\n\n  VAR_7 = VAR_2;\n\n  VAR_4 = VAR_0;\n  while (VAR_4 < VAR_1) {\n    VAR_5 = VAR_4;\n    VAR_6 = uv__utf8_decode1(&VAR_4, VAR_1);\n\n    if (VAR_6 == VAR_10)\n      return VAR_9;\n\n    if (VAR_6 != '.')\n      if (VAR_6 != 0x3002)  /* COMMENT_0 */\n        if (VAR_6 != 0xFF0E)  /* COMMENT_1 */\n          if (VAR_6 != 0xFF61)  /* COMMENT_2 */\n            continue;\n\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_5, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n\n    if (VAR_2 < VAR_3)\n      *VAR_2++ = '.';\n\n    VAR_0 = VAR_4;\n  }\n\n  if (VAR_0 < VAR_1) {\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_1, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n  }\n\n  if (VAR_2 >= VAR_3)\n    return VAR_9;\n\n  *VAR_2++ = '\\0';\n  return VAR_2 - VAR_7;  /* COMMENT_3 */\n}",
  "func_graph_path": "libuv/3530bcc30350d4a6ccf35d2f7b33e23292b9de70/idna.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n   unsigned c;\n   char* ds;\n   int rc;\n+\n+  if (s == se)\n+    return UV_EINVAL;\n \n   ds = d;\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "  if (s == se)",
      "    return UV_EINVAL;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libuv/libuv/pull/4305",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libuv/libuv/pull/4305: 403 Client Error: Forbidden for url: https://api.github.com/repos/libuv/libuv/pulls/4305",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch addresses a security vulnerability by adding input validation to prevent zero-length IDNA inputs, which aligns with the security advisory."
}