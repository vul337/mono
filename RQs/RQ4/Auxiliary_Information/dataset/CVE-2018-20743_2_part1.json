{
  "cve_id": "CVE-2018-20743",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "mumble-voip/mumble",
  "commit_msg": "Prevent instability and crash due to message flood\n\nThis patch adds a rate limiting to selected patches. The underlying rate limiter\nused is the Leaky-Bucket algorithm. It allows for a burst of messages, but\nlimits them after a specified amount of messages within a time frame.",
  "commit_hash": "0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "git_url": "https://github.com/mumble-voip/mumble/commit/0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "file_path": "src/murmur/Messages.cpp",
  "func_name": "Server::msgACL",
  "func_before": "void Server::msgACL(ServerUser *uSource, MumbleProto::ACL &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *c = qhChannels.value(msg.channel_id());\n\tif (!c)\n\t\treturn;\n\n\tif (! hasPermission(uSource, c, ChanACL::Write) && !(c->cParent && hasPermission(uSource, c->cParent, ChanACL::Write))) {\n\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\treturn;\n\t}\n\n\tif (msg.has_query() && msg.query()) {\n\t\tQStack<Channel *> chans;\n\t\tChannel *p;\n\t\tChanACL *acl;\n\n\t\tQSet<int> qsId;\n\n\t\tmsg.clear_groups();\n\t\tmsg.clear_acls();\n\t\tmsg.clear_query();\n\t\tmsg.set_inherit_acls(c->bInheritACL);\n\n\t\tp = c;\n\t\twhile (p) {\n\t\t\tchans.push(p);\n\t\t\tif ((p==c) || p->bInheritACL)\n\t\t\t\tp = p->cParent;\n\t\t\telse\n\t\t\t\tp = NULL;\n\t\t}\n\n\t\twhile (! chans.isEmpty()) {\n\t\t\tp = chans.pop();\n\t\t\tforeach(acl, p->qlACL) {\n\t\t\t\tif ((p == c) || (acl->bApplySubs)) {\n\t\t\t\t\tMumbleProto::ACL_ChanACL *mpacl = msg.add_acls();\n\n\t\t\t\t\tmpacl->set_inherited(p != c);\n\t\t\t\t\tmpacl->set_apply_here(acl->bApplyHere);\n\t\t\t\t\tmpacl->set_apply_subs(acl->bApplySubs);\n\t\t\t\t\tif (acl->iUserId >= 0) {\n\t\t\t\t\t\tmpacl->set_user_id(acl->iUserId);\n\t\t\t\t\t\tqsId.insert(acl->iUserId);\n\t\t\t\t\t} else\n\t\t\t\t\t\tmpacl->set_group(u8(acl->qsGroup));\n\t\t\t\t\tmpacl->set_grant(acl->pAllow);\n\t\t\t\t\tmpacl->set_deny(acl->pDeny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = c->cParent;\n\t\tQSet<QString> allnames=Group::groupNames(c);\n\t\tforeach(const QString &name, allnames) {\n\t\t\tGroup *g = c->qhGroups.value(name);\n\t\t\tGroup *pg = p ? Group::getGroup(p, name) : NULL;\n\n\t\t\tMumbleProto::ACL_ChanGroup *group = msg.add_groups();\n\t\t\tgroup->set_name(u8(name));\n\t\t\tgroup->set_inherit(g ? g->bInherit : true);\n\t\t\tgroup->set_inheritable(g ? g->bInheritable : true);\n\t\t\tgroup->set_inherited((pg != NULL) && pg->bInheritable);\n\t\t\tif (g) {\n\t\t\t\tforeach(int id, g->qsAdd) {\n\t\t\t\t\tqsId.insert(id);\n\t\t\t\t\tgroup->add_add(id);\n\t\t\t\t}\n\t\t\t\tforeach(int id, g->qsRemove) {\n\t\t\t\t\tqsId.insert(id);\n\t\t\t\t\tgroup->add_remove(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pg)\n\t\t\t\tforeach(int id, pg->members()) {\n\t\t\t\t\tqsId.insert(id);\n\t\t\t\t\tgroup->add_inherited_members(id);\n\t\t\t\t}\n\t\t}\n\n\t\tsendMessage(uSource, msg);\n\n\t\tMumbleProto::QueryUsers mpqu;\n\t\tforeach(int id, qsId) {\n\t\t\tQString uname=getUserName(id);\n\t\t\tif (! uname.isEmpty()) {\n\t\t\t\tmpqu.add_ids(id);\n\t\t\t\tmpqu.add_names(u8(uname));\n\t\t\t}\n\t\t}\n\t\tif (mpqu.ids_size())\n\t\t\tsendMessage(uSource, mpqu);\n\t} else {\n\t\tGroup *g;\n\t\tChanACL *a;\n\n\t\t{\n\t\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\t\tQHash<QString, QSet<int> > hOldTemp;\n\n\t\t\tforeach(g, c->qhGroups) {\n\t\t\t\thOldTemp.insert(g->qsName, g->qsTemporary);\n\t\t\t\tdelete g;\n\t\t\t}\n\n\t\t\tforeach(a, c->qlACL)\n\t\t\t\tdelete a;\n\n\t\t\tc->qhGroups.clear();\n\t\t\tc->qlACL.clear();\n\n\t\t\tc->bInheritACL = msg.inherit_acls();\n\n\t\t\tfor (int i = 0; i < msg.groups_size(); ++i) {\n\t\t\t\tconst MumbleProto::ACL_ChanGroup &group = msg.groups(i);\n\t\t\t\tg = new Group(c, u8(group.name()));\n\t\t\t\tg->bInherit = group.inherit();\n\t\t\t\tg->bInheritable = group.inheritable();\n\t\t\t\tfor (int j = 0; j < group.add_size(); ++j)\n\t\t\t\t\tif (!getUserName(group.add(j)).isEmpty())\n\t\t\t\t\t\tg->qsAdd << group.add(j);\n\t\t\t\tfor (int j = 0; j < group.remove_size(); ++j)\n\t\t\t\t\tif (!getUserName(group.remove(j)).isEmpty())\n\t\t\t\t\t\tg->qsRemove << group.remove(j);\n\t\t\t\tg->qsTemporary = hOldTemp.value(g->qsName);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < msg.acls_size(); ++i) {\n\t\t\t\tconst MumbleProto::ACL_ChanACL &mpacl = msg.acls(i);\n\t\t\t\tif (mpacl.has_user_id() && getUserName(mpacl.user_id()).isEmpty())\n\t\t\t\t\tcontinue;\n\n\t\t\t\ta = new ChanACL(c);\n\t\t\t\ta->bApplyHere = mpacl.apply_here();\n\t\t\t\ta->bApplySubs = mpacl.apply_subs();\n\t\t\t\tif (mpacl.has_user_id())\n\t\t\t\t\ta->iUserId = mpacl.user_id();\n\t\t\t\telse\n\t\t\t\t\ta->qsGroup = u8(mpacl.group());\n\t\t\t\ta->pDeny = static_cast<ChanACL::Permissions>(mpacl.deny()) & ChanACL::All;\n\t\t\t\ta->pAllow = static_cast<ChanACL::Permissions>(mpacl.grant()) & ChanACL::All;\n\t\t\t}\n\t\t}\n\n\t\tclearACLCache();\n\n\t\tif (! hasPermission(uSource, c, ChanACL::Write) && ((uSource->iId >= 0) || !uSource->qsHash.isEmpty())) {\n\t\t\t{\n\t\t\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\t\t\ta = new ChanACL(c);\n\t\t\t\ta->bApplyHere = true;\n\t\t\t\ta->bApplySubs = false;\n\t\t\t\tif (uSource->iId >= 0)\n\t\t\t\t\ta->iUserId = uSource->iId;\n\t\t\t\telse\n\t\t\t\t\ta->qsGroup = QLatin1Char('$') + uSource->qsHash;\n\t\t\t\ta->iUserId = uSource->iId;\n\t\t\t\ta->pDeny = ChanACL::None;\n\t\t\t\ta->pAllow = ChanACL::Write | ChanACL::Traverse;\n\t\t\t}\n\n\t\t\tclearACLCache();\n\t\t}\n\n\n\t\tupdateChannel(c);\n\t\tlog(uSource, QString(\"Updated ACL in channel %1\").arg(*c));\n\t}\n}",
  "abstract_func_before": "void Server::msgACL(ServerUser *VAR_0, MumbleProto::ACL &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *VAR_2 = VAR_3.value(VAR_1.channel_id());\n\tif (!VAR_2)\n\t\treturn;\n\n\tif (! hasPermission(VAR_0, VAR_2, ChanACL::Write) && !(VAR_2->cParent && hasPermission(VAR_0, VAR_2->cParent, ChanACL::Write))) {\n\t\tPERM_DENIED(VAR_0, VAR_2, ChanACL::Write);\n\t\treturn;\n\t}\n\n\tif (VAR_1.has_query() && VAR_1.query()) {\n\t\tQStack<Channel *> VAR_4;\n\t\tChannel *VAR_5;\n\t\tChanACL *VAR_6;\n\n\t\tQSet<int> VAR_7;\n\n\t\tVAR_1.clear_groups();\n\t\tVAR_1.clear_acls();\n\t\tVAR_1.clear_query();\n\t\tVAR_1.set_inherit_acls(VAR_2->bInheritACL);\n\n\t\tVAR_5 = VAR_2;\n\t\twhile (VAR_5) {\n\t\t\tVAR_4.push(VAR_5);\n\t\t\tif ((VAR_5==VAR_2) || VAR_5->bInheritACL)\n\t\t\t\tVAR_5 = VAR_5->cParent;\n\t\t\telse\n\t\t\t\tVAR_5 = NULL;\n\t\t}\n\n\t\twhile (! VAR_4.isEmpty()) {\n\t\t\tVAR_5 = VAR_4.pop();\n\t\t\tforeach(VAR_6, VAR_5->qlACL) {\n\t\t\t\tif ((VAR_5 == VAR_2) || (VAR_6->bApplySubs)) {\n\t\t\t\t\tMumbleProto::ACL_ChanACL *VAR_8 = VAR_1.add_acls();\n\n\t\t\t\t\tVAR_8->set_inherited(VAR_5 != VAR_2);\n\t\t\t\t\tVAR_8->set_apply_here(VAR_6->bApplyHere);\n\t\t\t\t\tVAR_8->set_apply_subs(VAR_6->bApplySubs);\n\t\t\t\t\tif (VAR_6->iUserId >= 0) {\n\t\t\t\t\t\tVAR_8->set_user_id(VAR_6->iUserId);\n\t\t\t\t\t\tVAR_7.insert(VAR_6->iUserId);\n\t\t\t\t\t} else\n\t\t\t\t\t\tVAR_8->set_group(u8(VAR_6->qsGroup));\n\t\t\t\t\tVAR_8->set_grant(VAR_6->pAllow);\n\t\t\t\t\tVAR_8->set_deny(VAR_6->pDeny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVAR_5 = VAR_2->cParent;\n\t\tQSet<QString> VAR_9=Group::groupNames(VAR_2);\n\t\tforeach(const QString &VAR_10, allnames) {\n\t\t\tGroup *VAR_11 = VAR_2->qhGroups.value(VAR_10);\n\t\t\tGroup *VAR_12 = VAR_5 ? Group::getGroup(VAR_5, VAR_10) : NULL;\n\n\t\t\tMumbleProto::ACL_ChanGroup *VAR_13 = VAR_1.add_groups();\n\t\t\tVAR_13->set_name(u8(VAR_10));\n\t\t\tVAR_13->set_inherit(VAR_11 ? VAR_11->bInherit : true);\n\t\t\tVAR_13->set_inheritable(VAR_11 ? VAR_11->bInheritable : true);\n\t\t\tVAR_13->set_inherited((VAR_12 != NULL) && VAR_12->bInheritable);\n\t\t\tif (VAR_11) {\n\t\t\t\tforeach(int VAR_14, g->VAR_15) {\n\t\t\t\t\tVAR_7.insert(VAR_14);\n\t\t\t\t\tVAR_13->add_add(VAR_14);\n\t\t\t\t}\n\t\t\t\tforeach(int VAR_14, g->VAR_16) {\n\t\t\t\t\tVAR_7.insert(VAR_14);\n\t\t\t\t\tVAR_13->add_remove(VAR_14);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_12)\n\t\t\t\tforeach(int VAR_14, VAR_12->members()) {\n\t\t\t\t\tVAR_7.insert(VAR_14);\n\t\t\t\t\tVAR_13->add_inherited_members(VAR_14);\n\t\t\t\t}\n\t\t}\n\n\t\tsendMessage(VAR_0, VAR_1);\n\n\t\tMumbleProto::QueryUsers VAR_17;\n\t\tforeach(int VAR_14, qsId) {\n\t\t\tQString VAR_18=getUserName(VAR_14);\n\t\t\tif (! VAR_18.isEmpty()) {\n\t\t\t\tVAR_17.add_ids(VAR_14);\n\t\t\t\tVAR_17.add_names(u8(VAR_18));\n\t\t\t}\n\t\t}\n\t\tif (VAR_17.ids_size())\n\t\t\tsendMessage(VAR_0, VAR_17);\n\t} else {\n\t\tGroup *g;\n\t\tChanACL *VAR_19;\n\n\t\t{\n\t\t\tQWriteLocker VAR_20(&VAR_21);\n\n\t\t\tQHash<QString, QSet<int> > VAR_22;\n\n\t\t\tforeach(g, VAR_2->qhGroups) {\n\t\t\t\tVAR_22.insert(g->qsName, g->qsTemporary);\n\t\t\t\tdelete g;\n\t\t\t}\n\n\t\t\tforeach(VAR_19, VAR_2->qlACL)\n\t\t\t\tdelete VAR_19;\n\n\t\t\tVAR_2->qhGroups.clear();\n\t\t\tVAR_2->qlACL.clear();\n\n\t\t\tVAR_2->bInheritACL = VAR_1.inherit_acls();\n\n\t\t\tfor (int VAR_23 = 0; VAR_23 < VAR_1.groups_size(); ++VAR_23) {\n\t\t\t\tconst MumbleProto::ACL_ChanGroup &VAR_13 = VAR_1.groups(VAR_23);\n\t\t\t\tg = new Group(VAR_2, u8(VAR_13.name()));\n\t\t\t\tg->bInherit = VAR_13.inherit();\n\t\t\t\tg->bInheritable = VAR_13.inheritable();\n\t\t\t\tfor (int VAR_24 = 0; VAR_24 < VAR_13.add_size(); ++VAR_24)\n\t\t\t\t\tif (!getUserName(VAR_13.add(VAR_24)).isEmpty())\n\t\t\t\t\t\tg->qsAdd << VAR_13.add(VAR_24);\n\t\t\t\tfor (int VAR_24 = 0; VAR_24 < VAR_13.remove_size(); ++VAR_24)\n\t\t\t\t\tif (!getUserName(VAR_13.remove(VAR_24)).isEmpty())\n\t\t\t\t\t\tg->qsRemove << VAR_13.remove(VAR_24);\n\t\t\t\tg->qsTemporary = VAR_22.value(g->qsName);\n\t\t\t}\n\n\t\t\tfor (int VAR_23 = 0; VAR_23 < VAR_1.acls_size(); ++VAR_23) {\n\t\t\t\tconst MumbleProto::ACL_ChanACL &VAR_8 = VAR_1.acls(VAR_23);\n\t\t\t\tif (VAR_8.has_user_id() && getUserName(VAR_8.user_id()).isEmpty())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tVAR_19 = new ChanACL(VAR_2);\n\t\t\t\tVAR_19->bApplyHere = VAR_8.apply_here();\n\t\t\t\tVAR_19->bApplySubs = VAR_8.apply_subs();\n\t\t\t\tif (VAR_8.has_user_id())\n\t\t\t\t\tVAR_19->iUserId = VAR_8.user_id();\n\t\t\t\telse\n\t\t\t\t\tVAR_19->qsGroup = u8(VAR_8.group());\n\t\t\t\tVAR_19->pDeny = VAR_25<ChanACL::Permissions>(VAR_8.deny()) & ChanACL::All;\n\t\t\t\tVAR_19->pAllow = VAR_25<ChanACL::Permissions>(VAR_8.grant()) & ChanACL::All;\n\t\t\t}\n\t\t}\n\n\t\tclearACLCache();\n\n\t\tif (! hasPermission(VAR_0, VAR_2, ChanACL::Write) && ((VAR_0->iId >= 0) || !VAR_0->qsHash.isEmpty())) {\n\t\t\t{\n\t\t\t\tQWriteLocker VAR_20(&VAR_21);\n\n\t\t\t\tVAR_19 = new ChanACL(VAR_2);\n\t\t\t\tVAR_19->bApplyHere = true;\n\t\t\t\tVAR_19->bApplySubs = false;\n\t\t\t\tif (VAR_0->iId >= 0)\n\t\t\t\t\tVAR_19->iUserId = VAR_0->iId;\n\t\t\t\telse\n\t\t\t\t\tVAR_19->qsGroup = QLatin1Char('$') + VAR_0->qsHash;\n\t\t\t\tVAR_19->iUserId = VAR_0->iId;\n\t\t\t\tVAR_19->pDeny = ChanACL::None;\n\t\t\t\tVAR_19->pAllow = ChanACL::Write | ChanACL::Traverse;\n\t\t\t}\n\n\t\t\tclearACLCache();\n\t\t}\n\n\n\t\tupdateChannel(VAR_2);\n\t\tlog(VAR_0, QString(\"Updated ACL in channel %1\").arg(*VAR_2));\n\t}\n}",
  "func_graph_path_before": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/before/3.json",
  "func": "void Server::msgACL(ServerUser *uSource, MumbleProto::ACL &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *c = qhChannels.value(msg.channel_id());\n\tif (!c)\n\t\treturn;\n\n\tif (! hasPermission(uSource, c, ChanACL::Write) && !(c->cParent && hasPermission(uSource, c->cParent, ChanACL::Write))) {\n\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\treturn;\n\t}\n\n\tRATELIMIT(uSource);\n\n\tif (msg.has_query() && msg.query()) {\n\t\tQStack<Channel *> chans;\n\t\tChannel *p;\n\t\tChanACL *acl;\n\n\t\tQSet<int> qsId;\n\n\t\tmsg.clear_groups();\n\t\tmsg.clear_acls();\n\t\tmsg.clear_query();\n\t\tmsg.set_inherit_acls(c->bInheritACL);\n\n\t\tp = c;\n\t\twhile (p) {\n\t\t\tchans.push(p);\n\t\t\tif ((p==c) || p->bInheritACL)\n\t\t\t\tp = p->cParent;\n\t\t\telse\n\t\t\t\tp = NULL;\n\t\t}\n\n\t\twhile (! chans.isEmpty()) {\n\t\t\tp = chans.pop();\n\t\t\tforeach(acl, p->qlACL) {\n\t\t\t\tif ((p == c) || (acl->bApplySubs)) {\n\t\t\t\t\tMumbleProto::ACL_ChanACL *mpacl = msg.add_acls();\n\n\t\t\t\t\tmpacl->set_inherited(p != c);\n\t\t\t\t\tmpacl->set_apply_here(acl->bApplyHere);\n\t\t\t\t\tmpacl->set_apply_subs(acl->bApplySubs);\n\t\t\t\t\tif (acl->iUserId >= 0) {\n\t\t\t\t\t\tmpacl->set_user_id(acl->iUserId);\n\t\t\t\t\t\tqsId.insert(acl->iUserId);\n\t\t\t\t\t} else\n\t\t\t\t\t\tmpacl->set_group(u8(acl->qsGroup));\n\t\t\t\t\tmpacl->set_grant(acl->pAllow);\n\t\t\t\t\tmpacl->set_deny(acl->pDeny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = c->cParent;\n\t\tQSet<QString> allnames=Group::groupNames(c);\n\t\tforeach(const QString &name, allnames) {\n\t\t\tGroup *g = c->qhGroups.value(name);\n\t\t\tGroup *pg = p ? Group::getGroup(p, name) : NULL;\n\n\t\t\tMumbleProto::ACL_ChanGroup *group = msg.add_groups();\n\t\t\tgroup->set_name(u8(name));\n\t\t\tgroup->set_inherit(g ? g->bInherit : true);\n\t\t\tgroup->set_inheritable(g ? g->bInheritable : true);\n\t\t\tgroup->set_inherited((pg != NULL) && pg->bInheritable);\n\t\t\tif (g) {\n\t\t\t\tforeach(int id, g->qsAdd) {\n\t\t\t\t\tqsId.insert(id);\n\t\t\t\t\tgroup->add_add(id);\n\t\t\t\t}\n\t\t\t\tforeach(int id, g->qsRemove) {\n\t\t\t\t\tqsId.insert(id);\n\t\t\t\t\tgroup->add_remove(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pg)\n\t\t\t\tforeach(int id, pg->members()) {\n\t\t\t\t\tqsId.insert(id);\n\t\t\t\t\tgroup->add_inherited_members(id);\n\t\t\t\t}\n\t\t}\n\n\t\tsendMessage(uSource, msg);\n\n\t\tMumbleProto::QueryUsers mpqu;\n\t\tforeach(int id, qsId) {\n\t\t\tQString uname=getUserName(id);\n\t\t\tif (! uname.isEmpty()) {\n\t\t\t\tmpqu.add_ids(id);\n\t\t\t\tmpqu.add_names(u8(uname));\n\t\t\t}\n\t\t}\n\t\tif (mpqu.ids_size())\n\t\t\tsendMessage(uSource, mpqu);\n\t} else {\n\t\tGroup *g;\n\t\tChanACL *a;\n\n\t\t{\n\t\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\t\tQHash<QString, QSet<int> > hOldTemp;\n\n\t\t\tforeach(g, c->qhGroups) {\n\t\t\t\thOldTemp.insert(g->qsName, g->qsTemporary);\n\t\t\t\tdelete g;\n\t\t\t}\n\n\t\t\tforeach(a, c->qlACL)\n\t\t\t\tdelete a;\n\n\t\t\tc->qhGroups.clear();\n\t\t\tc->qlACL.clear();\n\n\t\t\tc->bInheritACL = msg.inherit_acls();\n\n\t\t\tfor (int i = 0; i < msg.groups_size(); ++i) {\n\t\t\t\tconst MumbleProto::ACL_ChanGroup &group = msg.groups(i);\n\t\t\t\tg = new Group(c, u8(group.name()));\n\t\t\t\tg->bInherit = group.inherit();\n\t\t\t\tg->bInheritable = group.inheritable();\n\t\t\t\tfor (int j = 0; j < group.add_size(); ++j)\n\t\t\t\t\tif (!getUserName(group.add(j)).isEmpty())\n\t\t\t\t\t\tg->qsAdd << group.add(j);\n\t\t\t\tfor (int j = 0; j < group.remove_size(); ++j)\n\t\t\t\t\tif (!getUserName(group.remove(j)).isEmpty())\n\t\t\t\t\t\tg->qsRemove << group.remove(j);\n\t\t\t\tg->qsTemporary = hOldTemp.value(g->qsName);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < msg.acls_size(); ++i) {\n\t\t\t\tconst MumbleProto::ACL_ChanACL &mpacl = msg.acls(i);\n\t\t\t\tif (mpacl.has_user_id() && getUserName(mpacl.user_id()).isEmpty())\n\t\t\t\t\tcontinue;\n\n\t\t\t\ta = new ChanACL(c);\n\t\t\t\ta->bApplyHere = mpacl.apply_here();\n\t\t\t\ta->bApplySubs = mpacl.apply_subs();\n\t\t\t\tif (mpacl.has_user_id())\n\t\t\t\t\ta->iUserId = mpacl.user_id();\n\t\t\t\telse\n\t\t\t\t\ta->qsGroup = u8(mpacl.group());\n\t\t\t\ta->pDeny = static_cast<ChanACL::Permissions>(mpacl.deny()) & ChanACL::All;\n\t\t\t\ta->pAllow = static_cast<ChanACL::Permissions>(mpacl.grant()) & ChanACL::All;\n\t\t\t}\n\t\t}\n\n\t\tclearACLCache();\n\n\t\tif (! hasPermission(uSource, c, ChanACL::Write) && ((uSource->iId >= 0) || !uSource->qsHash.isEmpty())) {\n\t\t\t{\n\t\t\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\t\t\ta = new ChanACL(c);\n\t\t\t\ta->bApplyHere = true;\n\t\t\t\ta->bApplySubs = false;\n\t\t\t\tif (uSource->iId >= 0)\n\t\t\t\t\ta->iUserId = uSource->iId;\n\t\t\t\telse\n\t\t\t\t\ta->qsGroup = QLatin1Char('$') + uSource->qsHash;\n\t\t\t\ta->iUserId = uSource->iId;\n\t\t\t\ta->pDeny = ChanACL::None;\n\t\t\t\ta->pAllow = ChanACL::Write | ChanACL::Traverse;\n\t\t\t}\n\n\t\t\tclearACLCache();\n\t\t}\n\n\n\t\tupdateChannel(c);\n\t\tlog(uSource, QString(\"Updated ACL in channel %1\").arg(*c));\n\t}\n}",
  "abstract_func": "void Server::msgACL(ServerUser *VAR_0, MumbleProto::ACL &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *VAR_2 = VAR_3.value(VAR_1.channel_id());\n\tif (!VAR_2)\n\t\treturn;\n\n\tif (! hasPermission(VAR_0, VAR_2, ChanACL::Write) && !(VAR_2->cParent && hasPermission(VAR_0, VAR_2->cParent, ChanACL::Write))) {\n\t\tPERM_DENIED(VAR_0, VAR_2, ChanACL::Write);\n\t\treturn;\n\t}\n\n\tRATELIMIT(VAR_0);\n\n\tif (VAR_1.has_query() && VAR_1.query()) {\n\t\tQStack<Channel *> VAR_4;\n\t\tChannel *VAR_5;\n\t\tChanACL *VAR_6;\n\n\t\tQSet<int> VAR_7;\n\n\t\tVAR_1.clear_groups();\n\t\tVAR_1.clear_acls();\n\t\tVAR_1.clear_query();\n\t\tVAR_1.set_inherit_acls(VAR_2->bInheritACL);\n\n\t\tVAR_5 = VAR_2;\n\t\twhile (VAR_5) {\n\t\t\tVAR_4.push(VAR_5);\n\t\t\tif ((VAR_5==VAR_2) || VAR_5->bInheritACL)\n\t\t\t\tVAR_5 = VAR_5->cParent;\n\t\t\telse\n\t\t\t\tVAR_5 = NULL;\n\t\t}\n\n\t\twhile (! VAR_4.isEmpty()) {\n\t\t\tVAR_5 = VAR_4.pop();\n\t\t\tforeach(VAR_6, VAR_5->qlACL) {\n\t\t\t\tif ((VAR_5 == VAR_2) || (VAR_6->bApplySubs)) {\n\t\t\t\t\tMumbleProto::ACL_ChanACL *VAR_8 = VAR_1.add_acls();\n\n\t\t\t\t\tVAR_8->set_inherited(VAR_5 != VAR_2);\n\t\t\t\t\tVAR_8->set_apply_here(VAR_6->bApplyHere);\n\t\t\t\t\tVAR_8->set_apply_subs(VAR_6->bApplySubs);\n\t\t\t\t\tif (VAR_6->iUserId >= 0) {\n\t\t\t\t\t\tVAR_8->set_user_id(VAR_6->iUserId);\n\t\t\t\t\t\tVAR_7.insert(VAR_6->iUserId);\n\t\t\t\t\t} else\n\t\t\t\t\t\tVAR_8->set_group(u8(VAR_6->qsGroup));\n\t\t\t\t\tVAR_8->set_grant(VAR_6->pAllow);\n\t\t\t\t\tVAR_8->set_deny(VAR_6->pDeny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVAR_5 = VAR_2->cParent;\n\t\tQSet<QString> VAR_9=Group::groupNames(VAR_2);\n\t\tforeach(const QString &VAR_10, allnames) {\n\t\t\tGroup *VAR_11 = VAR_2->qhGroups.value(VAR_10);\n\t\t\tGroup *VAR_12 = VAR_5 ? Group::getGroup(VAR_5, VAR_10) : NULL;\n\n\t\t\tMumbleProto::ACL_ChanGroup *VAR_13 = VAR_1.add_groups();\n\t\t\tVAR_13->set_name(u8(VAR_10));\n\t\t\tVAR_13->set_inherit(VAR_11 ? VAR_11->bInherit : true);\n\t\t\tVAR_13->set_inheritable(VAR_11 ? VAR_11->bInheritable : true);\n\t\t\tVAR_13->set_inherited((VAR_12 != NULL) && VAR_12->bInheritable);\n\t\t\tif (VAR_11) {\n\t\t\t\tforeach(int VAR_14, g->VAR_15) {\n\t\t\t\t\tVAR_7.insert(VAR_14);\n\t\t\t\t\tVAR_13->add_add(VAR_14);\n\t\t\t\t}\n\t\t\t\tforeach(int VAR_14, g->VAR_16) {\n\t\t\t\t\tVAR_7.insert(VAR_14);\n\t\t\t\t\tVAR_13->add_remove(VAR_14);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_12)\n\t\t\t\tforeach(int VAR_14, VAR_12->members()) {\n\t\t\t\t\tVAR_7.insert(VAR_14);\n\t\t\t\t\tVAR_13->add_inherited_members(VAR_14);\n\t\t\t\t}\n\t\t}\n\n\t\tsendMessage(VAR_0, VAR_1);\n\n\t\tMumbleProto::QueryUsers VAR_17;\n\t\tforeach(int VAR_14, qsId) {\n\t\t\tQString VAR_18=getUserName(VAR_14);\n\t\t\tif (! VAR_18.isEmpty()) {\n\t\t\t\tVAR_17.add_ids(VAR_14);\n\t\t\t\tVAR_17.add_names(u8(VAR_18));\n\t\t\t}\n\t\t}\n\t\tif (VAR_17.ids_size())\n\t\t\tsendMessage(VAR_0, VAR_17);\n\t} else {\n\t\tGroup *g;\n\t\tChanACL *VAR_19;\n\n\t\t{\n\t\t\tQWriteLocker VAR_20(&VAR_21);\n\n\t\t\tQHash<QString, QSet<int> > VAR_22;\n\n\t\t\tforeach(g, VAR_2->qhGroups) {\n\t\t\t\tVAR_22.insert(g->qsName, g->qsTemporary);\n\t\t\t\tdelete g;\n\t\t\t}\n\n\t\t\tforeach(VAR_19, VAR_2->qlACL)\n\t\t\t\tdelete VAR_19;\n\n\t\t\tVAR_2->qhGroups.clear();\n\t\t\tVAR_2->qlACL.clear();\n\n\t\t\tVAR_2->bInheritACL = VAR_1.inherit_acls();\n\n\t\t\tfor (int VAR_23 = 0; VAR_23 < VAR_1.groups_size(); ++VAR_23) {\n\t\t\t\tconst MumbleProto::ACL_ChanGroup &VAR_13 = VAR_1.groups(VAR_23);\n\t\t\t\tg = new Group(VAR_2, u8(VAR_13.name()));\n\t\t\t\tg->bInherit = VAR_13.inherit();\n\t\t\t\tg->bInheritable = VAR_13.inheritable();\n\t\t\t\tfor (int VAR_24 = 0; VAR_24 < VAR_13.add_size(); ++VAR_24)\n\t\t\t\t\tif (!getUserName(VAR_13.add(VAR_24)).isEmpty())\n\t\t\t\t\t\tg->qsAdd << VAR_13.add(VAR_24);\n\t\t\t\tfor (int VAR_24 = 0; VAR_24 < VAR_13.remove_size(); ++VAR_24)\n\t\t\t\t\tif (!getUserName(VAR_13.remove(VAR_24)).isEmpty())\n\t\t\t\t\t\tg->qsRemove << VAR_13.remove(VAR_24);\n\t\t\t\tg->qsTemporary = VAR_22.value(g->qsName);\n\t\t\t}\n\n\t\t\tfor (int VAR_23 = 0; VAR_23 < VAR_1.acls_size(); ++VAR_23) {\n\t\t\t\tconst MumbleProto::ACL_ChanACL &VAR_8 = VAR_1.acls(VAR_23);\n\t\t\t\tif (VAR_8.has_user_id() && getUserName(VAR_8.user_id()).isEmpty())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tVAR_19 = new ChanACL(VAR_2);\n\t\t\t\tVAR_19->bApplyHere = VAR_8.apply_here();\n\t\t\t\tVAR_19->bApplySubs = VAR_8.apply_subs();\n\t\t\t\tif (VAR_8.has_user_id())\n\t\t\t\t\tVAR_19->iUserId = VAR_8.user_id();\n\t\t\t\telse\n\t\t\t\t\tVAR_19->qsGroup = u8(VAR_8.group());\n\t\t\t\tVAR_19->pDeny = VAR_25<ChanACL::Permissions>(VAR_8.deny()) & ChanACL::All;\n\t\t\t\tVAR_19->pAllow = VAR_25<ChanACL::Permissions>(VAR_8.grant()) & ChanACL::All;\n\t\t\t}\n\t\t}\n\n\t\tclearACLCache();\n\n\t\tif (! hasPermission(VAR_0, VAR_2, ChanACL::Write) && ((VAR_0->iId >= 0) || !VAR_0->qsHash.isEmpty())) {\n\t\t\t{\n\t\t\t\tQWriteLocker VAR_20(&VAR_21);\n\n\t\t\t\tVAR_19 = new ChanACL(VAR_2);\n\t\t\t\tVAR_19->bApplyHere = true;\n\t\t\t\tVAR_19->bApplySubs = false;\n\t\t\t\tif (VAR_0->iId >= 0)\n\t\t\t\t\tVAR_19->iUserId = VAR_0->iId;\n\t\t\t\telse\n\t\t\t\t\tVAR_19->qsGroup = QLatin1Char('$') + VAR_0->qsHash;\n\t\t\t\tVAR_19->iUserId = VAR_0->iId;\n\t\t\t\tVAR_19->pDeny = ChanACL::None;\n\t\t\t\tVAR_19->pAllow = ChanACL::Write | ChanACL::Traverse;\n\t\t\t}\n\n\t\t\tclearACLCache();\n\t\t}\n\n\n\t\tupdateChannel(VAR_2);\n\t\tlog(VAR_0, QString(\"Updated ACL in channel %1\").arg(*VAR_2));\n\t}\n}",
  "func_graph_path": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n \t\tPERM_DENIED(uSource, c, ChanACL::Write);\n \t\treturn;\n \t}\n+\n+\tRATELIMIT(uSource);\n \n \tif (msg.has_query() && msg.query()) {\n \t\tQStack<Channel *> chans;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\tRATELIMIT(uSource);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mumble-voip/mumble/pull/3510",
  "description": {
    "pr_info": {
      "title": "Prevent instability and crash due to message flood",
      "number": 3510
    },
    "comment": [
      "This patch adds a rate limiting to selected patches. The underlying rate limiter\r\nused is the Leaky-Bucket algorithm. It allows for a burst of messages, but\r\nlimits them after a specified amount of messages within a time frame.\r\nIf the ratelimit hits the messages are simply ignored.\r\n\r\nFor now its set to a burst of 30 allowed messages and a subsequent limit of 4 messages per second, which seems to do the trick without inconveniencing normal users.\r\n\r\nIt should to some extend prevent the recent issues with bots decribed in #3505.\r\n\r\nWhat was tested with the patch:\r\n\r\n- Joining (works)\r\n- Talking with UDP and TCP mode (works)\r\n- Switching channels (works)\r\n- Bringing down the server with a bot, tested with two different bots (does not work)\r\n\r\nI'm thanking the Zom.bi community for testing and @Natenom for some insight into the problem.\r\n\r\nI'm open to any suggestions.",
      "@davidebeatrici May I ask what priority/P0 entails?",
      "From https://wiki.mumble.info/wiki/Issue_Priorities:\r\n> MUST be fixed ASAP. Issues that prevent further development; legal issues; serious data loss issues; build issues for platforms we provide binaries for.",
      "@davidebeatrici How may I understand this? Is it my patch that \"MUST be fixed ASAP\" or does the patch fix something that \"MUST be fixed ASAP\"?",
      "The patch fixes something that \"MUST be fixed ASAP\".",
      "Qt 4 builds failing because:\r\n```c++\r\nIn file included from /usr/include/c++/4.8/chrono:35:0,\r\n                 from ./ServerUser.h:17,\r\n                 from ../ACL.cpp:14:\r\n/usr/include/c++/4.8/bits/c++0x_warning.h:32:2: error: #error This file requires compiler and library support for the ISO C++ 2011 standard. This support is currently experimental, and must be enabled with the -std=c++11 or -std=gnu++11 compiler options.\r\n #error This file requires compiler and library support for the \\\r\n  ^\r\n```\r\n\r\nMinGW builds failing because:\r\n```c++\r\nServerUser.h:106:36: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]\r\n   bool limit = this->currentTokens > (MAX_TOKENS - tokens);\r\n                                    ^\r\n```",
      "Alright, I can work with that. The first problem should be fixable by relying on pre-C++11 means to measure time if the software is not build using at least a C++11 compiler, unless we can have this as a requirement for building.\r\n\r\nThe second problem I didn't have, but it is easily fixable.",
      "After landing we should also put this into 1.2.",
      "I think that we shouldn't create another 1.2.x release.",
      "This edit to the patch should allow for pre-C++11 builds and fixes the warning with the unsigned signed comparison.\r\n\r\nEdit: Is it normal that the CI job is pending for such a long time? It seems to be finished according to the \"Details\" link.",
      "I hope you don't mind that I squashed them, so the history looks nicer. :+1: ",
      "No problem, we usually prefer commits to be squashed if they're all related.",
      "Perfect. Now do the last changes solve the problems you mentioned early? I'm sadly not able to easily try compiling it with Qt4 or MinGW.",
      "Builds succeeded.\r\n\r\nFeel free to review my changes and squash the commits.",
      "I separated the now and millisecondsBetween methods from the LeakyBucket class, as they were neither operating directly on the object nor public. And I added static inline to each to encourage the compile to inline them.\r\n\r\nAlso I moved a comment.\r\n\r\nPlease look at it again to see if you're okay with that.",
      "Thank you very much for your contribution!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}