{
  "cve_id": "CVE-2023-36328",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "libtom/libtommath",
  "commit_msg": "Fix possible integer overflow",
  "commit_hash": "beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "git_url": "https://github.com/libtom/libtommath/commit/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "file_path": "bn_s_mp_mul_high_digs.c",
  "func_name": "s_mp_mul_high_digs",
  "func_before": "mp_err s_mp_mul_high_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   mp_int   t;\n   int      pa, pb, ix, iy;\n   mp_err   err;\n   mp_digit u;\n   mp_word  r;\n   mp_digit tmpx, *tmpt, *tmpy;\n\n   /* can we use the fast multiplier? */\n   if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST)\n       && ((a->used + b->used + 1) < MP_WARRAY)\n       && (MP_MIN(a->used, b->used) < MP_MAXFAST)) {\n      return s_mp_mul_high_digs_fast(a, b, c, digs);\n   }\n\n   if ((err = mp_init_size(&t, a->used + b->used + 1)) != MP_OKAY) {\n      return err;\n   }\n   t.used = a->used + b->used + 1;\n\n   pa = a->used;\n   pb = b->used;\n   for (ix = 0; ix < pa; ix++) {\n      /* clear the carry */\n      u = 0;\n\n      /* left hand side of A[ix] * B[iy] */\n      tmpx = a->dp[ix];\n\n      /* alias to the address of where the digits will be stored */\n      tmpt = &(t.dp[digs]);\n\n      /* alias for where to read the right hand side from */\n      tmpy = b->dp + (digs - ix);\n\n      for (iy = digs - ix; iy < pb; iy++) {\n         /* calculate the double precision result */\n         r       = (mp_word)*tmpt +\n                   ((mp_word)tmpx * (mp_word)*tmpy++) +\n                   (mp_word)u;\n\n         /* get the lower part */\n         *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* carry the carry */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      *tmpt = u;\n   }\n   mp_clamp(&t);\n   mp_exch(&t, c);\n   mp_clear(&t);\n   return MP_OKAY;\n}",
  "abstract_func_before": "mp_err s_mp_mul_high_digs(const mp_int *VAR_0, const mp_int *VAR_1, mp_int *VAR_2, int VAR_3)\n{\n   mp_int   VAR_4;\n   int      VAR_5, VAR_6, VAR_7, VAR_8;\n   mp_err   VAR_9;\n   mp_digit VAR_10;\n   mp_word  VAR_11;\n   mp_digit VAR_12, *VAR_13, *VAR_14;\n\n   /* COMMENT_0 */\n   if (MP_HAS(VAR_15)\n       && ((VAR_0->used + VAR_1->used + 1) < VAR_16)\n       && (MP_MIN(VAR_0->used, VAR_1->used) < VAR_17)) {\n      return s_mp_mul_high_digs_fast(VAR_0, VAR_1, VAR_2, VAR_3);\n   }\n\n   if ((VAR_9 = mp_init_size(&VAR_4, VAR_0->used + VAR_1->used + 1)) != VAR_18) {\n      return VAR_9;\n   }\n   VAR_4.used = VAR_0->used + VAR_1->used + 1;\n\n   VAR_5 = VAR_0->used;\n   VAR_6 = VAR_1->used;\n   for (VAR_7 = 0; VAR_7 < VAR_5; VAR_7++) {\n      /* COMMENT_1 */\n      VAR_10 = 0;\n\n      /* COMMENT_2 */\n      VAR_12 = VAR_0->dp[VAR_7];\n\n      /* COMMENT_3 */\n      VAR_13 = &(VAR_4.dp[VAR_3]);\n\n      /* COMMENT_4 */\n      VAR_14 = VAR_1->dp + (VAR_3 - VAR_7);\n\n      for (VAR_8 = VAR_3 - VAR_7; VAR_8 < VAR_6; VAR_8++) {\n         /* COMMENT_5 */\n         VAR_11       = (mp_word)*VAR_13 +\n                   ((mp_word)VAR_12 * (mp_word)*VAR_14++) +\n                   (mp_word)VAR_10;\n\n         /* COMMENT_6 */\n         *VAR_13++ = (mp_digit)(VAR_11 & (mp_word)VAR_19);\n\n         /* COMMENT_7 */\n         VAR_10       = (mp_digit)(VAR_11 >> (mp_word)VAR_20);\n      }\n      *VAR_13 = VAR_10;\n   }\n   mp_clamp(&VAR_4);\n   mp_exch(&VAR_4, VAR_2);\n   mp_clear(&VAR_4);\n   return VAR_18;\n}",
  "func_graph_path_before": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_s_mp_mul_high_digs.c/vul/before/0.json",
  "func": "mp_err s_mp_mul_high_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   mp_int   t;\n   int      pa, pb, ix, iy;\n   mp_err   err;\n   mp_digit u;\n   mp_word  r;\n   mp_digit tmpx, *tmpt, *tmpy;\n\n   if (digs < 0) {\n      return MP_VAL;\n   }\n\n   /* can we use the fast multiplier? */\n   if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST)\n       && ((a->used + b->used + 1) < MP_WARRAY)\n       && (MP_MIN(a->used, b->used) < MP_MAXFAST)) {\n      return s_mp_mul_high_digs_fast(a, b, c, digs);\n   }\n\n   if ((err = mp_init_size(&t, a->used + b->used + 1)) != MP_OKAY) {\n      return err;\n   }\n   t.used = a->used + b->used + 1;\n\n   pa = a->used;\n   pb = b->used;\n   for (ix = 0; ix < pa; ix++) {\n      /* clear the carry */\n      u = 0;\n\n      /* left hand side of A[ix] * B[iy] */\n      tmpx = a->dp[ix];\n\n      /* alias to the address of where the digits will be stored */\n      tmpt = &(t.dp[digs]);\n\n      /* alias for where to read the right hand side from */\n      tmpy = b->dp + (digs - ix);\n\n      for (iy = digs - ix; iy < pb; iy++) {\n         /* calculate the double precision result */\n         r       = (mp_word)*tmpt +\n                   ((mp_word)tmpx * (mp_word)*tmpy++) +\n                   (mp_word)u;\n\n         /* get the lower part */\n         *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* carry the carry */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      *tmpt = u;\n   }\n   mp_clamp(&t);\n   mp_exch(&t, c);\n   mp_clear(&t);\n   return MP_OKAY;\n}",
  "abstract_func": "mp_err s_mp_mul_high_digs(const mp_int *VAR_0, const mp_int *VAR_1, mp_int *VAR_2, int VAR_3)\n{\n   mp_int   VAR_4;\n   int      VAR_5, VAR_6, VAR_7, VAR_8;\n   mp_err   VAR_9;\n   mp_digit VAR_10;\n   mp_word  VAR_11;\n   mp_digit VAR_12, *VAR_13, *VAR_14;\n\n   if (VAR_3 < 0) {\n      return VAR_15;\n   }\n\n   /* COMMENT_0 */\n   if (MP_HAS(VAR_16)\n       && ((VAR_0->used + VAR_1->used + 1) < VAR_17)\n       && (MP_MIN(VAR_0->used, VAR_1->used) < VAR_18)) {\n      return s_mp_mul_high_digs_fast(VAR_0, VAR_1, VAR_2, VAR_3);\n   }\n\n   if ((VAR_9 = mp_init_size(&VAR_4, VAR_0->used + VAR_1->used + 1)) != VAR_19) {\n      return VAR_9;\n   }\n   VAR_4.used = VAR_0->used + VAR_1->used + 1;\n\n   VAR_5 = VAR_0->used;\n   VAR_6 = VAR_1->used;\n   for (VAR_7 = 0; VAR_7 < VAR_5; VAR_7++) {\n      /* COMMENT_1 */\n      VAR_10 = 0;\n\n      /* COMMENT_2 */\n      VAR_12 = VAR_0->dp[VAR_7];\n\n      /* COMMENT_3 */\n      VAR_13 = &(VAR_4.dp[VAR_3]);\n\n      /* COMMENT_4 */\n      VAR_14 = VAR_1->dp + (VAR_3 - VAR_7);\n\n      for (VAR_8 = VAR_3 - VAR_7; VAR_8 < VAR_6; VAR_8++) {\n         /* COMMENT_5 */\n         VAR_11       = (mp_word)*VAR_13 +\n                   ((mp_word)VAR_12 * (mp_word)*VAR_14++) +\n                   (mp_word)VAR_10;\n\n         /* COMMENT_6 */\n         *VAR_13++ = (mp_digit)(VAR_11 & (mp_word)VAR_20);\n\n         /* COMMENT_7 */\n         VAR_10       = (mp_digit)(VAR_11 >> (mp_word)VAR_21);\n      }\n      *VAR_13 = VAR_10;\n   }\n   mp_clamp(&VAR_4);\n   mp_exch(&VAR_4, VAR_2);\n   mp_clear(&VAR_4);\n   return VAR_19;\n}",
  "func_graph_path": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_s_mp_mul_high_digs.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,10 @@\n    mp_digit u;\n    mp_word  r;\n    mp_digit tmpx, *tmpt, *tmpy;\n+\n+   if (digs < 0) {\n+      return MP_VAL;\n+   }\n \n    /* can we use the fast multiplier? */\n    if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST)",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "   if (digs < 0) {",
      "      return MP_VAL;",
      "   }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libtom/libtommath/pull/546",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libtom/libtommath/pull/546: 403 Client Error: Forbidden for url: https://api.github.com/repos/libtom/libtommath/pulls/546",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses an integer overflow vulnerability by adding input validation for negative values, preventing potential security risks.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}