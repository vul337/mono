{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvWrite",
  "func_before": "int wolfSSH_SFTP_RecvWrite(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WFD    fd;\n    word32 sz;\n    int    ret  = WS_SUCCESS;\n    word32 idx  = 0;\n    word32 ofst[2] = {0,0};\n\n    word32 outSz = 0;\n    byte*  out   = NULL;\n\n    char  suc[] = \"Write File Success\";\n    char  err[] = \"Write File Error\";\n    char* res  = suc;\n    byte  type = WOLFSSH_FTP_OK;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_WRITE\");\n\n    /* get file handle */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Error with file handle size\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }\n\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&fd, 0, sizeof(WFD));\n        WMEMCPY((byte*)&fd, data + idx, sz); idx += sz;\n\n        /* get offset into file */\n        ato32(data + idx, &ofst[1]); idx += UINT32_SZ;\n        ato32(data + idx, &ofst[0]); idx += UINT32_SZ;\n\n        /* get length to be written */\n        ato32(data + idx, &sz); idx += UINT32_SZ;\n\n        ret = WPWRITE(fd, data + idx, sz, ofst);\n        if (ret < 0) {\n    #if defined(WOLFSSL_NUCLEUS) && defined(DEBUG_WOLFSSH)\n            if (ret == NUF_NOSPC) {\n                WLOG(WS_LOG_SFTP, \"Ran out of memory\");\n            }\n    #endif\n            WLOG(WS_LOG_SFTP, \"Error writing to file\");\n            res  = err;\n            type = WOLFSSH_FTP_FAILURE;\n            ret  = WS_INVALID_STATE_E;\n        }\n        else {\n            ret = WS_SUCCESS;\n        }\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", NULL,\n                &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func_before": "int wolfSSH_SFTP_RecvWrite(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WFD    VAR_5;\n    word32 VAR_6;\n    int    VAR_7  = VAR_8;\n    word32 VAR_9  = 0;\n    word32 VAR_10[2] = {0,0};\n\n    word32 VAR_11 = 0;\n    byte*  VAR_12   = NULL;\n\n    char  VAR_13[] = \"Write File Success\";\n    char  VAR_14[] = \"Write File Error\";\n    char* VAR_15  = VAR_13;\n    byte  VAR_16 = VAR_17;\n\n    if (VAR_0 == NULL) {\n        return VAR_18;\n    }\n\n    WLOG(VAR_19, \"Receiving WOLFSSH_FTP_WRITE\");\n\n    /* COMMENT_0 */\n    ato32(VAR_2 + VAR_9, &VAR_6); VAR_9 += VAR_20;\n    if (VAR_6 + VAR_9 > VAR_3 || VAR_6 > VAR_21) {\n        WLOG(VAR_19, \"Error with file handle size\");\n        VAR_15  = VAR_14;\n        VAR_16 = VAR_22;\n        VAR_7  = VAR_23;\n    }\n\n    if (VAR_7 == VAR_8) {\n        WMEMSET((byte*)&VAR_5, 0, sizeof(WFD));\n        WMEMCPY((byte*)&VAR_5, VAR_2 + VAR_9, VAR_6); VAR_9 += VAR_6;\n\n        /* COMMENT_1 */\n        ato32(VAR_2 + VAR_9, &VAR_10[1]); VAR_9 += VAR_20;\n        ato32(VAR_2 + VAR_9, &VAR_10[0]); VAR_9 += VAR_20;\n\n        /* COMMENT_2 */\n        ato32(VAR_2 + VAR_9, &VAR_6); VAR_9 += VAR_20;\n\n        VAR_7 = WPWRITE(VAR_5, VAR_2 + VAR_9, VAR_6, VAR_10);\n        if (VAR_7 < 0) {\n    #if defined(VAR_24) && defined(VAR_25)\n            if (VAR_7 == VAR_26) {\n                WLOG(VAR_19, \"Ran out of memory\");\n            }\n    #endif\n            WLOG(VAR_19, \"Error writing to file\");\n            VAR_15  = VAR_14;\n            VAR_16 = VAR_22;\n            VAR_7  = VAR_27;\n        }\n        else {\n            VAR_7 = VAR_8;\n        }\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_16, VAR_1, VAR_15, \"English\", NULL,\n                &VAR_11) != VAR_28) {\n        return VAR_29;\n    }\n    VAR_12 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_30);\n    if (VAR_12 == NULL) {\n        return VAR_31;\n    }\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_16, VAR_1, VAR_15, \"English\", VAR_12,\n                &VAR_11) != VAR_8) {\n        WFREE(VAR_12, VAR_0->ctx->heap, VAR_30);\n        return VAR_29;\n    }\n\n    /* COMMENT_3 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_12, VAR_11);\n    return VAR_7;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/2.json",
  "func": "int wolfSSH_SFTP_RecvWrite(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WFD    fd;\n    word32 sz;\n    int    ret  = WS_SUCCESS;\n    word32 idx  = 0;\n    word32 ofst[2] = {0,0};\n\n    word32 outSz = 0;\n    byte*  out   = NULL;\n\n    char  suc[] = \"Write File Success\";\n    char  err[] = \"Write File Error\";\n    char* res  = suc;\n    byte  type = WOLFSSH_FTP_OK;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_WRITE\");\n\n    /* get file handle */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Error with file handle size\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }\n\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&fd, 0, sizeof(WFD));\n        WMEMCPY((byte*)&fd, data + idx, sz); idx += sz;\n\n        /* get offset into file */\n        ato32(data + idx, &ofst[1]); idx += UINT32_SZ;\n        ato32(data + idx, &ofst[0]); idx += UINT32_SZ;\n\n        /* get length to be written */\n        ato32(data + idx, &sz); idx += UINT32_SZ;\n        if (sz > maxSz - idx) {\n            return WS_BUFFER_E;\n        }\n\n        ret = WPWRITE(fd, data + idx, sz, ofst);\n        if (ret < 0) {\n    #if defined(WOLFSSL_NUCLEUS) && defined(DEBUG_WOLFSSH)\n            if (ret == NUF_NOSPC) {\n                WLOG(WS_LOG_SFTP, \"Ran out of memory\");\n            }\n    #endif\n            WLOG(WS_LOG_SFTP, \"Error writing to file\");\n            res  = err;\n            type = WOLFSSH_FTP_FAILURE;\n            ret  = WS_INVALID_STATE_E;\n        }\n        else {\n            ret = WS_SUCCESS;\n        }\n    }\n\n        if (sz > maxSz - idx) {\n            return WS_BUFFER_E;\n        }\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", NULL,\n                &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func": "int wolfSSH_SFTP_RecvWrite(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WFD    VAR_5;\n    word32 VAR_6;\n    int    VAR_7  = VAR_8;\n    word32 VAR_9  = 0;\n    word32 VAR_10[2] = {0,0};\n\n    word32 VAR_11 = 0;\n    byte*  VAR_12   = NULL;\n\n    char  VAR_13[] = \"Write File Success\";\n    char  VAR_14[] = \"Write File Error\";\n    char* VAR_15  = VAR_13;\n    byte  VAR_16 = VAR_17;\n\n    if (VAR_0 == NULL) {\n        return VAR_18;\n    }\n\n    WLOG(VAR_19, \"Receiving WOLFSSH_FTP_WRITE\");\n\n    /* COMMENT_0 */\n    ato32(VAR_2 + VAR_9, &VAR_6); VAR_9 += VAR_20;\n    if (VAR_6 + VAR_9 > VAR_3 || VAR_6 > VAR_21) {\n        WLOG(VAR_19, \"Error with file handle size\");\n        VAR_15  = VAR_14;\n        VAR_16 = VAR_22;\n        VAR_7  = VAR_23;\n    }\n\n    if (VAR_7 == VAR_8) {\n        WMEMSET((byte*)&VAR_5, 0, sizeof(WFD));\n        WMEMCPY((byte*)&VAR_5, VAR_2 + VAR_9, VAR_6); VAR_9 += VAR_6;\n\n        /* COMMENT_1 */\n        ato32(VAR_2 + VAR_9, &VAR_10[1]); VAR_9 += VAR_20;\n        ato32(VAR_2 + VAR_9, &VAR_10[0]); VAR_9 += VAR_20;\n\n        /* COMMENT_2 */\n        ato32(VAR_2 + VAR_9, &VAR_6); VAR_9 += VAR_20;\n        if (VAR_6 > VAR_3 - VAR_9) {\n            return VAR_24;\n        }\n\n        VAR_7 = WPWRITE(VAR_5, VAR_2 + VAR_9, VAR_6, VAR_10);\n        if (VAR_7 < 0) {\n    #if defined(VAR_25) && defined(VAR_26)\n            if (VAR_7 == VAR_27) {\n                WLOG(VAR_19, \"Ran out of memory\");\n            }\n    #endif\n            WLOG(VAR_19, \"Error writing to file\");\n            VAR_15  = VAR_14;\n            VAR_16 = VAR_22;\n            VAR_7  = VAR_28;\n        }\n        else {\n            VAR_7 = VAR_8;\n        }\n    }\n\n        if (VAR_6 > VAR_3 - VAR_9) {\n            return VAR_24;\n        }\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_16, VAR_1, VAR_15, \"English\", NULL,\n                &VAR_11) != VAR_29) {\n        return VAR_30;\n    }\n    VAR_12 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_31);\n    if (VAR_12 == NULL) {\n        return VAR_32;\n    }\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_16, VAR_1, VAR_15, \"English\", VAR_12,\n                &VAR_11) != VAR_8) {\n        WFREE(VAR_12, VAR_0->ctx->heap, VAR_31);\n        return VAR_30;\n    }\n\n    /* COMMENT_3 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_12, VAR_11);\n    return VAR_7;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,9 @@\n \n         /* get length to be written */\n         ato32(data + idx, &sz); idx += UINT32_SZ;\n+        if (sz > maxSz - idx) {\n+            return WS_BUFFER_E;\n+        }\n \n         ret = WPWRITE(fd, data + idx, sz, ofst);\n         if (ret < 0) {\n@@ -58,6 +61,9 @@\n         }\n     }\n \n+        if (sz > maxSz - idx) {\n+            return WS_BUFFER_E;\n+        }\n     if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", NULL,\n                 &outSz) != WS_SIZE_ONLY) {\n         return WS_FATAL_ERROR;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (sz > maxSz - idx) {",
      "            return WS_BUFFER_E;",
      "        }",
      "        if (sz > maxSz - idx) {",
      "            return WS_BUFFER_E;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/wolfSSL/wolfssh/pull/360: 403 Client Error: Forbidden for url: https://api.github.com/repos/wolfSSL/wolfssh/pulls/360",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}