{
  "cve_id": "CVE-2019-13351",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "jackaudio/jack2",
  "commit_msg": "Set fSocket to -1 after close on an error to prevent a double close.\n\nSigned-off-by: Joe Yasi <joe.yasi@gmail.com>",
  "commit_hash": "994e225bbb07a89f56147f7ce7d59beb49f8cfba",
  "git_url": "https://github.com/jackaudio/jack2/commit/994e225bbb07a89f56147f7ce7d59beb49f8cfba",
  "file_path": "posix/JackSocket.cpp",
  "func_name": "JackClientSocket::Connect",
  "func_before": "int JackClientSocket::Connect(const char* dir, const char* name, int which) // A revoir : utilisation de \"which\"\n{\n    struct sockaddr_un addr;\n\n    if ((fSocket = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        jack_error(\"Cannot create socket err = %s\", strerror(errno));\n        return -1;\n    }\n\n    addr.sun_family = AF_UNIX;\n    BuildName(name, addr.sun_path, dir, which, sizeof(addr.sun_path), fPromiscuous);\n    jack_log(\"JackClientSocket::Connect : addr.sun_path %s\", addr.sun_path);\n\n    if (connect(fSocket, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n        jack_error(\"Cannot connect to server socket err = %s\", strerror(errno));\n        close(fSocket);\n        return -1;\n    }\n\n#ifdef __APPLE__\n    int on = 1;\n    if (setsockopt(fSocket, SOL_SOCKET, SO_NOSIGPIPE, (const char*)&on, sizeof(on)) < 0) {\n        jack_log(\"setsockopt SO_NOSIGPIPE fd = %ld err = %s\", fSocket, strerror(errno));\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func_before": "int JackClientSocket::Connect(const char* VAR_0, const char* VAR_1, int VAR_2) /* COMMENT_0 */\n{\n    struct sockaddr_un VAR_3;\n\n    if ((VAR_4 = socket(VAR_5, VAR_6, 0)) < 0) {\n        jack_error(\"Cannot create socket err = %s\", strerror(VAR_7));\n        return -1;\n    }\n\n    VAR_3.sun_family = VAR_5;\n    BuildName(VAR_1, VAR_3.sun_path, VAR_0, VAR_2, sizeof(VAR_3.sun_path), VAR_8);\n    jack_log(\"JackClientSocket::Connect : addr.sun_path %s\", VAR_3.sun_path);\n\n    if (connect(VAR_4, (struct sockaddr*)&VAR_3, sizeof(VAR_3)) < 0) {\n        jack_error(\"Cannot connect to server socket err = %s\", strerror(VAR_7));\n        close(VAR_4);\n        return -1;\n    }\n\n#ifdef VAR_9\n    int VAR_10 = 1;\n    if (setsockopt(VAR_4, VAR_11, VAR_12, (const char*)&VAR_10, sizeof(VAR_10)) < 0) {\n        jack_log(\"setsockopt SO_NOSIGPIPE fd = %ld err = %s\", VAR_4, strerror(VAR_7));\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path_before": "jackaudio/jack2/994e225bbb07a89f56147f7ce7d59beb49f8cfba/JackSocket.cpp/vul/before/1.json",
  "func": "int JackClientSocket::Connect(const char* dir, const char* name, int which) // A revoir : utilisation de \"which\"\n{\n    struct sockaddr_un addr;\n\n    if ((fSocket = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        jack_error(\"Cannot create socket err = %s\", strerror(errno));\n        return -1;\n    }\n\n    addr.sun_family = AF_UNIX;\n    BuildName(name, addr.sun_path, dir, which, sizeof(addr.sun_path), fPromiscuous);\n    jack_log(\"JackClientSocket::Connect : addr.sun_path %s\", addr.sun_path);\n\n    if (connect(fSocket, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n        jack_error(\"Cannot connect to server socket err = %s\", strerror(errno));\n        close(fSocket);\n        fSocket = -1;\n        return -1;\n    }\n\n#ifdef __APPLE__\n    int on = 1;\n    if (setsockopt(fSocket, SOL_SOCKET, SO_NOSIGPIPE, (const char*)&on, sizeof(on)) < 0) {\n        jack_log(\"setsockopt SO_NOSIGPIPE fd = %ld err = %s\", fSocket, strerror(errno));\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func": "int JackClientSocket::Connect(const char* VAR_0, const char* VAR_1, int VAR_2) /* COMMENT_0 */\n{\n    struct sockaddr_un VAR_3;\n\n    if ((VAR_4 = socket(VAR_5, VAR_6, 0)) < 0) {\n        jack_error(\"Cannot create socket err = %s\", strerror(VAR_7));\n        return -1;\n    }\n\n    VAR_3.sun_family = VAR_5;\n    BuildName(VAR_1, VAR_3.sun_path, VAR_0, VAR_2, sizeof(VAR_3.sun_path), VAR_8);\n    jack_log(\"JackClientSocket::Connect : addr.sun_path %s\", VAR_3.sun_path);\n\n    if (connect(VAR_4, (struct sockaddr*)&VAR_3, sizeof(VAR_3)) < 0) {\n        jack_error(\"Cannot connect to server socket err = %s\", strerror(VAR_7));\n        close(VAR_4);\n        VAR_4 = -1;\n        return -1;\n    }\n\n#ifdef VAR_9\n    int VAR_10 = 1;\n    if (setsockopt(VAR_4, VAR_11, VAR_12, (const char*)&VAR_10, sizeof(VAR_10)) < 0) {\n        jack_log(\"setsockopt SO_NOSIGPIPE fd = %ld err = %s\", VAR_4, strerror(VAR_7));\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path": "jackaudio/jack2/994e225bbb07a89f56147f7ce7d59beb49f8cfba/JackSocket.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n     if (connect(fSocket, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n         jack_error(\"Cannot connect to server socket err = %s\", strerror(errno));\n         close(fSocket);\n+        fSocket = -1;\n         return -1;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        fSocket = -1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jackaudio/jack2/pull/480",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/jackaudio/jack2/pull/480: 403 Client Error: Forbidden for url: https://api.github.com/repos/jackaudio/jack2/pulls/480",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:**\n   - The commit message mentions preventing a double close by setting `fSocket` to -1.\n   - The vulnerability description details a crash due to a double close in specific code lines, leading to a fix by resetting `fSocket`.\n   - The code change shows adding `fSocket = -1;` after closing.\n\n2. **Consistency Check:**\n   - The commit message aligns with the code change, ensuring no double close occurs.\n\n3. **Purpose Evaluation:**\n   - The change prevents a crash caused by a programming error, not a security exploit.\n\n4. **Security Vulnerability Assessment:**\n   - Although it fixes a bug causing crashes, it doesn't address external security risks, so it's not a security fix.\n\n5. **Non-Security Classification:**\n   - It's a bug fix improving core functionality, thus falls under Defect Remediation.\n\n6. **Confidence Scoring:**\n   - High confidence due to clear alignment between description and code, rated 0.9.\n\n**Final Output:**  \nFinal Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9"
}