{
  "cve_id": "CVE-2022-43294",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "arendst/Tasmota",
  "commit_msg": " fix stack overflow vulnerability",
  "commit_hash": "066878da4d4762a9b6cb169fdf353e804d735cfd",
  "git_url": "https://github.com/arendst/Tasmota/commit/066878da4d4762a9b6cb169fdf353e804d735cfd",
  "file_path": "lib/libesp32/rtsp/CRtspSession.cpp",
  "func_name": "CRtspSession::ParseRtspRequest",
  "func_before": "bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize)\n{\n    // char CmdName[RTSP_PARAM_STRING_MAX];\n    //char CurRequest[RTSP_BUFFER_SIZE]; // Note: we assume single threaded, this large buf we keep off of the tiny stack\n    unsigned CurRequestSize;\n\n    Init();\n    CurRequestSize = aRequestSize;\n    memcpy(CurRequest,aRequest,aRequestSize);\n\n    // check whether the request contains information about the RTP/RTCP UDP client ports (SETUP command)\n    char * ClientPortPtr;\n    char * TmpPtr;\n    char CP[128]; //static char CP[1024];\n    char * pCP;\n\n    ClientPortPtr = strstr(CurRequest,\"client_port\");\n    if (ClientPortPtr != nullptr)\n    {\n        TmpPtr = strstr(ClientPortPtr,\"\\r\\n\");\n        if (TmpPtr != nullptr)\n        {\n            TmpPtr[0] = 0x00;\n            strcpy(CP,ClientPortPtr);\n            pCP = strstr(CP,\"=\");\n            if (pCP != nullptr)\n            {\n                pCP++;\n                strcpy(CP,pCP);\n                pCP = strstr(CP,\"-\");\n                if (pCP != nullptr)\n                {\n                    pCP[0] = 0x00;\n                    m_ClientRTPPort  = atoi(CP);\n                    m_ClientRTCPPort = m_ClientRTPPort + 1;\n                };\n            };\n        };\n    };\n\n    // Read everything up to the first space as the command name\n    bool parseSucceeded = false;\n    unsigned i;\n    for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i)\n    {\n        char c = CurRequest[i];\n        if (c == ' ' || c == '\\t')\n        {\n            parseSucceeded = true;\n            break;\n        }\n        CmdName[i] = c;\n    }\n    CmdName[i] = '\\0';\n    if (!parseSucceeded) {\n        printf(\"failed to parse RTSP\\n\");\n        return false;\n    }\n\n    printf(\"RTSP received %s\\n\", CmdName);\n\n    // find out the command type\n    if (strstr(CmdName,\"OPTIONS\")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else\n    if (strstr(CmdName,\"DESCRIBE\")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else\n    if (strstr(CmdName,\"SETUP\")     != nullptr) m_RtspCmdType = RTSP_SETUP; else\n    if (strstr(CmdName,\"PLAY\")      != nullptr) m_RtspCmdType = RTSP_PLAY; else\n    if (strstr(CmdName,\"TEARDOWN\")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN;\n\n    // check whether the request contains transport information (UDP or TCP)\n    if (m_RtspCmdType == RTSP_SETUP)\n    {\n        TmpPtr = strstr(CurRequest,\"RTP/AVP/TCP\");\n        if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false;\n    };\n\n    // Skip over the prefix of any \"rtsp://\" or \"rtsp:/\" URL that follows:\n    unsigned j = i+1;\n    while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\\t')) ++j; // skip over any additional white space\n    for (; (int)j < (int)(CurRequestSize-8); ++j)\n    {\n        if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   &&\n            (CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') &&\n            (CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') &&\n            (CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') &&\n            CurRequest[j+4] == ':' && CurRequest[j+5] == '/')\n        {\n            j += 6;\n            if (CurRequest[j] == '/')\n            {   // This is a \"rtsp://\" URL; skip over the host:port part that follows:\n                ++j;\n                unsigned uidx = 0;\n                while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1)\n                {   // extract the host:port part of the URL here\n                    m_URLHostPort[uidx] = CurRequest[j];\n                    uidx++;\n                    ++j;\n                };\n            }\n            else --j;\n            i = j;\n            break;\n        }\n    }\n\n    // Look for the URL suffix (before the following \"RTSP/\"):\n    parseSucceeded = false;\n    for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k)\n    {\n        if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   &&\n            CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   &&\n            CurRequest[k+4] == '/')\n        {\n            while (--k >= i && CurRequest[k] == ' ') {}\n            unsigned k1 = k;\n            while (k1 > i && CurRequest[k1] != '/') --k1;\n            if (k - k1 + 1 > sizeof(m_URLSuffix)) return false;\n            unsigned n = 0, k2 = k1+1;\n\n            while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++];\n            m_URLSuffix[n] = '\\0';\n\n            if (k1 - i > sizeof(m_URLPreSuffix)) return false;\n            n = 0; k2 = i + 1;\n            while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++];\n            m_URLPreSuffix[n] = '\\0';\n            i = k + 7;\n            parseSucceeded = true;\n            break;\n        }\n    }\n    if (!parseSucceeded) return false;\n\n    // Look for \"CSeq:\", skip whitespace, then read everything up to the next \\r or \\n as 'CSeq':\n    parseSucceeded = false;\n    for (j = i; (int)j < (int)(CurRequestSize-5); ++j)\n    {\n        if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' &&\n            CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' &&\n            CurRequest[j+4] == ':')\n        {\n            j += 5;\n            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\\t')) ++j;\n            unsigned n;\n            for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j)\n            {\n                char c = CurRequest[j];\n                if (c == '\\r' || c == '\\n')\n                {\n                    parseSucceeded = true;\n                    break;\n                }\n                m_CSeq[n] = c;\n            }\n            m_CSeq[n] = '\\0';\n            break;\n        }\n    }\n    if (!parseSucceeded) return false;\n\n    // Also: Look for \"Content-Length:\" (optional)\n    for (j = i; (int)j < (int)(CurRequestSize-15); ++j)\n    {\n        if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  &&\n            CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  &&\n            CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  &&\n            CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  &&\n            (CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') &&\n            CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' &&\n            CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' &&\n            CurRequest[j+13] == 'h' && CurRequest[j+14] == ':')\n        {\n            j += 15;\n            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\\t')) ++j;\n            unsigned num;\n            if (sscanf(&CurRequest[j], \"%u\", &num) == 1) m_ContentLength = num;\n        }\n    }\n    return true;\n}",
  "abstract_func_before": "bool CRtspSession::ParseRtspRequest(char const * VAR_0, unsigned VAR_1)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    unsigned VAR_2;\n\n    Init();\n    VAR_2 = VAR_1;\n    memcpy(VAR_3,VAR_0,VAR_1);\n\n    /* COMMENT_2 */\n    char * VAR_4;\n    char * VAR_5;\n    char VAR_6[128]; /* COMMENT_3 */\n    char * VAR_7;\n\n    VAR_4 = strstr(VAR_3,\"client_port\");\n    if (VAR_4 != nullptr)\n    {\n        VAR_5 = strstr(VAR_4,\"\\r\\n\");\n        if (VAR_5 != nullptr)\n        {\n            VAR_5[0] = 0x00;\n            strcpy(VAR_6,VAR_4);\n            VAR_7 = strstr(VAR_6,\"=\");\n            if (VAR_7 != nullptr)\n            {\n                VAR_7++;\n                strcpy(VAR_6,VAR_7);\n                VAR_7 = strstr(VAR_6,\"-\");\n                if (VAR_7 != nullptr)\n                {\n                    VAR_7[0] = 0x00;\n                    VAR_8  = atoi(VAR_6);\n                    VAR_9 = VAR_8 + 1;\n                };\n            };\n        };\n    };\n\n    /* COMMENT_4 */\n    bool VAR_10 = false;\n    unsigned VAR_11;\n    for (VAR_11 = 0; VAR_11 < sizeof(VAR_12)-1 && VAR_11 < VAR_2; ++VAR_11)\n    {\n        char VAR_13 = VAR_3[VAR_11];\n        if (VAR_13 == ' ' || VAR_13 == '\\t')\n        {\n            VAR_10 = true;\n            break;\n        }\n        VAR_12[VAR_11] = VAR_13;\n    }\n    VAR_12[VAR_11] = '\\0';\n    if (!VAR_10) {\n        printf(\"failed to parse RTSP\\n\");\n        return false;\n    }\n\n    printf(\"RTSP received %s\\n\", VAR_12);\n\n    /* COMMENT_5 */\n    if (strstr(VAR_12,\"OPTIONS\")   != nullptr) VAR_14 = VAR_15; else\n    if (strstr(VAR_12,\"DESCRIBE\")  != nullptr) VAR_14 = VAR_16; else\n    if (strstr(VAR_12,\"SETUP\")     != nullptr) VAR_14 = VAR_17; else\n    if (strstr(VAR_12,\"PLAY\")      != nullptr) VAR_14 = VAR_18; else\n    if (strstr(VAR_12,\"TEARDOWN\")  != nullptr) VAR_14 = VAR_19;\n\n    /* COMMENT_6 */\n    if (VAR_14 == VAR_17)\n    {\n        VAR_5 = strstr(VAR_3,\"RTP/AVP/TCP\");\n        if (VAR_5 != nullptr) VAR_20 = true; else VAR_20 = false;\n    };\n\n    /* COMMENT_7 */\n    unsigned VAR_21 = VAR_11+1;\n    while (VAR_21 < VAR_2 && (VAR_3[VAR_21] == ' ' || VAR_3[VAR_21] == '\\t')) ++VAR_21; /* COMMENT_8 */\n    for (; (int)VAR_21 < (int)(VAR_2-8); ++VAR_21)\n    {\n        if ((VAR_3[VAR_21]   == 'r' || VAR_3[VAR_21]   == 'R')   &&\n            (VAR_3[VAR_21+1] == 't' || VAR_3[VAR_21+1] == 'T') &&\n            (VAR_3[VAR_21+2] == 's' || VAR_3[VAR_21+2] == 'S') &&\n            (VAR_3[VAR_21+3] == 'p' || VAR_3[VAR_21+3] == 'P') &&\n            VAR_3[VAR_21+4] == ':' && VAR_3[VAR_21+5] == '/')\n        {\n            VAR_21 += 6;\n            if (VAR_3[VAR_21] == '/')\n            {   /* COMMENT_9 */\n                ++VAR_21;\n                unsigned VAR_22 = 0;\n                while (VAR_21 < VAR_2 && VAR_3[VAR_21] != '/' && VAR_3[VAR_21] != ' ' && VAR_22 < sizeof(VAR_23) - 1)\n                {   /* COMMENT_10 */\n                    VAR_23[VAR_22] = VAR_3[VAR_21];\n                    VAR_22++;\n                    ++VAR_21;\n                };\n            }\n            else --VAR_21;\n            VAR_11 = VAR_21;\n            break;\n        }\n    }\n\n    /* COMMENT_11 */\n    VAR_10 = false;\n    for (unsigned VAR_24 = VAR_11+1; (int)VAR_24 < (int)(VAR_2-5); ++VAR_24)\n    {\n        if (VAR_3[VAR_24]   == 'R'   && VAR_3[VAR_24+1] == 'T'   &&\n            VAR_3[VAR_24+2] == 'S'   && VAR_3[VAR_24+3] == 'P'   &&\n            VAR_3[VAR_24+4] == '/')\n        {\n            while (--VAR_24 >= VAR_11 && VAR_3[VAR_24] == ' ') {}\n            unsigned VAR_25 = VAR_24;\n            while (VAR_25 > VAR_11 && VAR_3[VAR_25] != '/') --VAR_25;\n            if (VAR_24 - VAR_25 + 1 > sizeof(VAR_26)) return false;\n            unsigned VAR_27 = 0, VAR_28 = VAR_25+1;\n\n            while (VAR_28 <= VAR_24) VAR_26[VAR_27++] = VAR_3[VAR_28++];\n            VAR_26[VAR_27] = '\\0';\n\n            if (VAR_25 - VAR_11 > sizeof(VAR_29)) return false;\n            VAR_27 = 0; VAR_28 = VAR_11 + 1;\n            while (VAR_28 <= VAR_25 - 1) VAR_29[VAR_27++] = VAR_3[VAR_28++];\n            VAR_29[VAR_27] = '\\0';\n            VAR_11 = VAR_24 + 7;\n            VAR_10 = true;\n            break;\n        }\n    }\n    if (!VAR_10) return false;\n\n    /* COMMENT_12 */\n    VAR_10 = false;\n    for (VAR_21 = VAR_11; (int)VAR_21 < (int)(VAR_2-5); ++VAR_21)\n    {\n        if (VAR_3[VAR_21]   == 'C' && VAR_3[VAR_21+1] == 'S' &&\n            VAR_3[VAR_21+2] == 'e' && VAR_3[VAR_21+3] == 'q' &&\n            VAR_3[VAR_21+4] == ':')\n        {\n            VAR_21 += 5;\n            while (VAR_21 < VAR_2 && (VAR_3[VAR_21] ==  ' ' || VAR_3[VAR_21] == '\\t')) ++VAR_21;\n            unsigned VAR_27;\n            for (VAR_27 = 0; VAR_27 < sizeof(VAR_30)-1 && VAR_21 < VAR_2; ++VAR_27,++VAR_21)\n            {\n                char VAR_13 = VAR_3[VAR_21];\n                if (VAR_13 == '\\r' || VAR_13 == '\\n')\n                {\n                    VAR_10 = true;\n                    break;\n                }\n                VAR_30[VAR_27] = VAR_13;\n            }\n            VAR_30[VAR_27] = '\\0';\n            break;\n        }\n    }\n    if (!VAR_10) return false;\n\n    /* COMMENT_13 */\n    for (VAR_21 = VAR_11; (int)VAR_21 < (int)(VAR_2-15); ++VAR_21)\n    {\n        if (VAR_3[VAR_21]    == 'C'  && VAR_3[VAR_21+1]  == 'o'  &&\n            VAR_3[VAR_21+2]  == 'n'  && VAR_3[VAR_21+3]  == 't'  &&\n            VAR_3[VAR_21+4]  == 'e'  && VAR_3[VAR_21+5]  == 'n'  &&\n            VAR_3[VAR_21+6]  == 't'  && VAR_3[VAR_21+7]  == '-'  &&\n            (VAR_3[VAR_21+8] == 'L' || VAR_3[VAR_21+8]   == 'l') &&\n            VAR_3[VAR_21+9]  == 'e'  && VAR_3[VAR_21+10] == 'n' &&\n            VAR_3[VAR_21+11] == 'g' && VAR_3[VAR_21+12]  == 't' &&\n            VAR_3[VAR_21+13] == 'h' && VAR_3[VAR_21+14] == ':')\n        {\n            VAR_21 += 15;\n            while (VAR_21 < VAR_2 && (VAR_3[VAR_21] ==  ' ' || VAR_3[VAR_21] == '\\t')) ++VAR_21;\n            unsigned VAR_31;\n            if (sscanf(&VAR_3[VAR_21], \"%u\", &VAR_31) == 1) VAR_32 = VAR_31;\n        }\n    }\n    return true;\n}",
  "func_graph_path_before": "arendst/Tasmota/066878da4d4762a9b6cb169fdf353e804d735cfd/CRtspSession.cpp/vul/before/0.json",
  "func": "bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize)\n{\n    // char CmdName[RTSP_PARAM_STRING_MAX];\n    //char CurRequest[RTSP_BUFFER_SIZE]; // Note: we assume single threaded, this large buf we keep off of the tiny stack\n    unsigned CurRequestSize;\n\n    Init();\n    CurRequestSize = aRequestSize;\n    memcpy(CurRequest,aRequest,aRequestSize);\n\n    // check whether the request contains information about the RTP/RTCP UDP client ports (SETUP command)\n    char * ClientPortPtr;\n    char * TmpPtr;\n    char CP[128]; //static char CP[1024];\n    char * pCP;\n    int Length;\n\n\n    ClientPortPtr = strstr(CurRequest,\"client_port\");\n    if (ClientPortPtr != nullptr)\n    {\n        TmpPtr = strstr(ClientPortPtr,\"\\r\\n\");\n        if (TmpPtr != nullptr)\n        {\n            TmpPtr[0] = 0x00;\n            Length = strlen(ClientPortPtr);\n            if (Length > 128)\n            {\n                Length = 128;\n            }\n            strncpy(CP,ClientPortPtr, Length);\n            pCP = strstr(CP,\"=\");\n            if (pCP != nullptr)\n            {\n                pCP++;\n                strcpy(CP,pCP);\n                pCP = strstr(CP,\"-\");\n                if (pCP != nullptr)\n                {\n                    pCP[0] = 0x00;\n                    m_ClientRTPPort  = atoi(CP);\n                    m_ClientRTCPPort = m_ClientRTPPort + 1;\n                };\n            };\n        };\n    };\n\n    // Read everything up to the first space as the command name\n    bool parseSucceeded = false;\n    unsigned i;\n    for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i)\n    {\n        char c = CurRequest[i];\n        if (c == ' ' || c == '\\t')\n        {\n            parseSucceeded = true;\n            break;\n        }\n        CmdName[i] = c;\n    }\n    CmdName[i] = '\\0';\n    if (!parseSucceeded) {\n        printf(\"failed to parse RTSP\\n\");\n        return false;\n    }\n\n    printf(\"RTSP received %s\\n\", CmdName);\n\n    // find out the command type\n    if (strstr(CmdName,\"OPTIONS\")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else\n    if (strstr(CmdName,\"DESCRIBE\")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else\n    if (strstr(CmdName,\"SETUP\")     != nullptr) m_RtspCmdType = RTSP_SETUP; else\n    if (strstr(CmdName,\"PLAY\")      != nullptr) m_RtspCmdType = RTSP_PLAY; else\n    if (strstr(CmdName,\"TEARDOWN\")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN;\n\n    // check whether the request contains transport information (UDP or TCP)\n    if (m_RtspCmdType == RTSP_SETUP)\n    {\n        TmpPtr = strstr(CurRequest,\"RTP/AVP/TCP\");\n        if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false;\n    };\n\n    // Skip over the prefix of any \"rtsp://\" or \"rtsp:/\" URL that follows:\n    unsigned j = i+1;\n    while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\\t')) ++j; // skip over any additional white space\n    for (; (int)j < (int)(CurRequestSize-8); ++j)\n    {\n        if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   &&\n            (CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') &&\n            (CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') &&\n            (CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') &&\n            CurRequest[j+4] == ':' && CurRequest[j+5] == '/')\n        {\n            j += 6;\n            if (CurRequest[j] == '/')\n            {   // This is a \"rtsp://\" URL; skip over the host:port part that follows:\n                ++j;\n                unsigned uidx = 0;\n                while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1)\n                {   // extract the host:port part of the URL here\n                    m_URLHostPort[uidx] = CurRequest[j];\n                    uidx++;\n                    ++j;\n                };\n            }\n            else --j;\n            i = j;\n            break;\n        }\n    }\n\n    // Look for the URL suffix (before the following \"RTSP/\"):\n    parseSucceeded = false;\n    for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k)\n    {\n        if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   &&\n            CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   &&\n            CurRequest[k+4] == '/')\n        {\n            while (--k >= i && CurRequest[k] == ' ') {}\n            unsigned k1 = k;\n            while (k1 > i && CurRequest[k1] != '/') --k1;\n            if (k - k1 + 1 > sizeof(m_URLSuffix)) return false;\n            unsigned n = 0, k2 = k1+1;\n\n            while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++];\n            m_URLSuffix[n] = '\\0';\n\n            if (k1 - i > sizeof(m_URLPreSuffix)) return false;\n            n = 0; k2 = i + 1;\n            while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++];\n            m_URLPreSuffix[n] = '\\0';\n            i = k + 7;\n            parseSucceeded = true;\n            break;\n        }\n    }\n    if (!parseSucceeded) return false;\n\n    // Look for \"CSeq:\", skip whitespace, then read everything up to the next \\r or \\n as 'CSeq':\n    parseSucceeded = false;\n    for (j = i; (int)j < (int)(CurRequestSize-5); ++j)\n    {\n        if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' &&\n            CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' &&\n            CurRequest[j+4] == ':')\n        {\n            j += 5;\n            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\\t')) ++j;\n            unsigned n;\n            for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j)\n            {\n                char c = CurRequest[j];\n                if (c == '\\r' || c == '\\n')\n                {\n                    parseSucceeded = true;\n                    break;\n                }\n                m_CSeq[n] = c;\n            }\n            m_CSeq[n] = '\\0';\n            break;\n        }\n    }\n    if (!parseSucceeded) return false;\n\n    // Also: Look for \"Content-Length:\" (optional)\n    for (j = i; (int)j < (int)(CurRequestSize-15); ++j)\n    {\n        if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  &&\n            CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  &&\n            CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  &&\n            CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  &&\n            (CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') &&\n            CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' &&\n            CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' &&\n            CurRequest[j+13] == 'h' && CurRequest[j+14] == ':')\n        {\n            j += 15;\n            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\\t')) ++j;\n            unsigned num;\n            if (sscanf(&CurRequest[j], \"%u\", &num) == 1) m_ContentLength = num;\n        }\n    }\n    return true;\n}",
  "abstract_func": "bool CRtspSession::ParseRtspRequest(char const * VAR_0, unsigned VAR_1)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    unsigned VAR_2;\n\n    Init();\n    VAR_2 = VAR_1;\n    memcpy(VAR_3,VAR_0,VAR_1);\n\n    /* COMMENT_2 */\n    char * VAR_4;\n    char * VAR_5;\n    char VAR_6[128]; /* COMMENT_3 */\n    char * VAR_7;\n    int VAR_8;\n\n\n    VAR_4 = strstr(VAR_3,\"client_port\");\n    if (VAR_4 != nullptr)\n    {\n        VAR_5 = strstr(VAR_4,\"\\r\\n\");\n        if (VAR_5 != nullptr)\n        {\n            VAR_5[0] = 0x00;\n            VAR_8 = strlen(VAR_4);\n            if (VAR_8 > 128)\n            {\n                VAR_8 = 128;\n            }\n            strncpy(VAR_6,VAR_4, VAR_8);\n            VAR_7 = strstr(VAR_6,\"=\");\n            if (VAR_7 != nullptr)\n            {\n                VAR_7++;\n                strcpy(VAR_6,VAR_7);\n                VAR_7 = strstr(VAR_6,\"-\");\n                if (VAR_7 != nullptr)\n                {\n                    VAR_7[0] = 0x00;\n                    VAR_9  = atoi(VAR_6);\n                    VAR_10 = VAR_9 + 1;\n                };\n            };\n        };\n    };\n\n    /* COMMENT_4 */\n    bool VAR_11 = false;\n    unsigned VAR_12;\n    for (VAR_12 = 0; VAR_12 < sizeof(VAR_13)-1 && VAR_12 < VAR_2; ++VAR_12)\n    {\n        char VAR_14 = VAR_3[VAR_12];\n        if (VAR_14 == ' ' || VAR_14 == '\\t')\n        {\n            VAR_11 = true;\n            break;\n        }\n        VAR_13[VAR_12] = VAR_14;\n    }\n    VAR_13[VAR_12] = '\\0';\n    if (!VAR_11) {\n        printf(\"failed to parse RTSP\\n\");\n        return false;\n    }\n\n    printf(\"RTSP received %s\\n\", VAR_13);\n\n    /* COMMENT_5 */\n    if (strstr(VAR_13,\"OPTIONS\")   != nullptr) VAR_15 = VAR_16; else\n    if (strstr(VAR_13,\"DESCRIBE\")  != nullptr) VAR_15 = VAR_17; else\n    if (strstr(VAR_13,\"SETUP\")     != nullptr) VAR_15 = VAR_18; else\n    if (strstr(VAR_13,\"PLAY\")      != nullptr) VAR_15 = VAR_19; else\n    if (strstr(VAR_13,\"TEARDOWN\")  != nullptr) VAR_15 = VAR_20;\n\n    /* COMMENT_6 */\n    if (VAR_15 == VAR_18)\n    {\n        VAR_5 = strstr(VAR_3,\"RTP/AVP/TCP\");\n        if (VAR_5 != nullptr) VAR_21 = true; else VAR_21 = false;\n    };\n\n    /* COMMENT_7 */\n    unsigned VAR_22 = VAR_12+1;\n    while (VAR_22 < VAR_2 && (VAR_3[VAR_22] == ' ' || VAR_3[VAR_22] == '\\t')) ++VAR_22; /* COMMENT_8 */\n    for (; (int)VAR_22 < (int)(VAR_2-8); ++VAR_22)\n    {\n        if ((VAR_3[VAR_22]   == 'r' || VAR_3[VAR_22]   == 'R')   &&\n            (VAR_3[VAR_22+1] == 't' || VAR_3[VAR_22+1] == 'T') &&\n            (VAR_3[VAR_22+2] == 's' || VAR_3[VAR_22+2] == 'S') &&\n            (VAR_3[VAR_22+3] == 'p' || VAR_3[VAR_22+3] == 'P') &&\n            VAR_3[VAR_22+4] == ':' && VAR_3[VAR_22+5] == '/')\n        {\n            VAR_22 += 6;\n            if (VAR_3[VAR_22] == '/')\n            {   /* COMMENT_9 */\n                ++VAR_22;\n                unsigned VAR_23 = 0;\n                while (VAR_22 < VAR_2 && VAR_3[VAR_22] != '/' && VAR_3[VAR_22] != ' ' && VAR_23 < sizeof(VAR_24) - 1)\n                {   /* COMMENT_10 */\n                    VAR_24[VAR_23] = VAR_3[VAR_22];\n                    VAR_23++;\n                    ++VAR_22;\n                };\n            }\n            else --VAR_22;\n            VAR_12 = VAR_22;\n            break;\n        }\n    }\n\n    /* COMMENT_11 */\n    VAR_11 = false;\n    for (unsigned VAR_25 = VAR_12+1; (int)VAR_25 < (int)(VAR_2-5); ++VAR_25)\n    {\n        if (VAR_3[VAR_25]   == 'R'   && VAR_3[VAR_25+1] == 'T'   &&\n            VAR_3[VAR_25+2] == 'S'   && VAR_3[VAR_25+3] == 'P'   &&\n            VAR_3[VAR_25+4] == '/')\n        {\n            while (--VAR_25 >= VAR_12 && VAR_3[VAR_25] == ' ') {}\n            unsigned VAR_26 = VAR_25;\n            while (VAR_26 > VAR_12 && VAR_3[VAR_26] != '/') --VAR_26;\n            if (VAR_25 - VAR_26 + 1 > sizeof(VAR_27)) return false;\n            unsigned VAR_28 = 0, VAR_29 = VAR_26+1;\n\n            while (VAR_29 <= VAR_25) VAR_27[VAR_28++] = VAR_3[VAR_29++];\n            VAR_27[VAR_28] = '\\0';\n\n            if (VAR_26 - VAR_12 > sizeof(VAR_30)) return false;\n            VAR_28 = 0; VAR_29 = VAR_12 + 1;\n            while (VAR_29 <= VAR_26 - 1) VAR_30[VAR_28++] = VAR_3[VAR_29++];\n            VAR_30[VAR_28] = '\\0';\n            VAR_12 = VAR_25 + 7;\n            VAR_11 = true;\n            break;\n        }\n    }\n    if (!VAR_11) return false;\n\n    /* COMMENT_12 */\n    VAR_11 = false;\n    for (VAR_22 = VAR_12; (int)VAR_22 < (int)(VAR_2-5); ++VAR_22)\n    {\n        if (VAR_3[VAR_22]   == 'C' && VAR_3[VAR_22+1] == 'S' &&\n            VAR_3[VAR_22+2] == 'e' && VAR_3[VAR_22+3] == 'q' &&\n            VAR_3[VAR_22+4] == ':')\n        {\n            VAR_22 += 5;\n            while (VAR_22 < VAR_2 && (VAR_3[VAR_22] ==  ' ' || VAR_3[VAR_22] == '\\t')) ++VAR_22;\n            unsigned VAR_28;\n            for (VAR_28 = 0; VAR_28 < sizeof(VAR_31)-1 && VAR_22 < VAR_2; ++VAR_28,++VAR_22)\n            {\n                char VAR_14 = VAR_3[VAR_22];\n                if (VAR_14 == '\\r' || VAR_14 == '\\n')\n                {\n                    VAR_11 = true;\n                    break;\n                }\n                VAR_31[VAR_28] = VAR_14;\n            }\n            VAR_31[VAR_28] = '\\0';\n            break;\n        }\n    }\n    if (!VAR_11) return false;\n\n    /* COMMENT_13 */\n    for (VAR_22 = VAR_12; (int)VAR_22 < (int)(VAR_2-15); ++VAR_22)\n    {\n        if (VAR_3[VAR_22]    == 'C'  && VAR_3[VAR_22+1]  == 'o'  &&\n            VAR_3[VAR_22+2]  == 'n'  && VAR_3[VAR_22+3]  == 't'  &&\n            VAR_3[VAR_22+4]  == 'e'  && VAR_3[VAR_22+5]  == 'n'  &&\n            VAR_3[VAR_22+6]  == 't'  && VAR_3[VAR_22+7]  == '-'  &&\n            (VAR_3[VAR_22+8] == 'L' || VAR_3[VAR_22+8]   == 'l') &&\n            VAR_3[VAR_22+9]  == 'e'  && VAR_3[VAR_22+10] == 'n' &&\n            VAR_3[VAR_22+11] == 'g' && VAR_3[VAR_22+12]  == 't' &&\n            VAR_3[VAR_22+13] == 'h' && VAR_3[VAR_22+14] == ':')\n        {\n            VAR_22 += 15;\n            while (VAR_22 < VAR_2 && (VAR_3[VAR_22] ==  ' ' || VAR_3[VAR_22] == '\\t')) ++VAR_22;\n            unsigned VAR_32;\n            if (sscanf(&VAR_3[VAR_22], \"%u\", &VAR_32) == 1) VAR_33 = VAR_32;\n        }\n    }\n    return true;\n}",
  "func_graph_path": "arendst/Tasmota/066878da4d4762a9b6cb169fdf353e804d735cfd/CRtspSession.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n     char * TmpPtr;\n     char CP[128]; //static char CP[1024];\n     char * pCP;\n+    int Length;\n+\n \n     ClientPortPtr = strstr(CurRequest,\"client_port\");\n     if (ClientPortPtr != nullptr)\n@@ -21,7 +23,12 @@\n         if (TmpPtr != nullptr)\n         {\n             TmpPtr[0] = 0x00;\n-            strcpy(CP,ClientPortPtr);\n+            Length = strlen(ClientPortPtr);\n+            if (Length > 128)\n+            {\n+                Length = 128;\n+            }\n+            strncpy(CP,ClientPortPtr, Length);\n             pCP = strstr(CP,\"=\");\n             if (pCP != nullptr)\n             {",
  "diff_line_info": {
    "deleted_lines": [
      "            strcpy(CP,ClientPortPtr);"
    ],
    "added_lines": [
      "    int Length;",
      "",
      "            Length = strlen(ClientPortPtr);",
      "            if (Length > 128)",
      "            {",
      "                Length = 128;",
      "            }",
      "            strncpy(CP,ClientPortPtr, Length);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/arendst/Tasmota/pull/16802",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/arendst/Tasmota/pull/16802: 403 Client Error: Forbidden for url: https://api.github.com/repos/arendst/Tasmota/pulls/16802",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}