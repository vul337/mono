{
  "cve_id": "CVE-2023-23082",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "xbmc",
  "commit_msg": "ExifParse: Backport further upstream fixes\n\nPartially via upstream commit:\nhttps://android.googlesource.com/platform/external/jhead/+/2a4c12f5e5808e309b9ba04fe8b1539debf466d1",
  "commit_hash": "7e5f9fbf9aaa3540aab35e7504036855b23dcf60",
  "git_url": "https://github.com/xbmc/xbmc/commit/7e5f9fbf9aaa3540aab35e7504036855b23dcf60",
  "file_path": "xbmc/pictures/ExifParse.cpp",
  "func_name": "CExifParse::ProcessDir",
  "func_before": "void CExifParse::ProcessDir(const unsigned char* const DirStart,\n                            const unsigned char* const OffsetBase,\n                            const unsigned ExifLength,\n                            int NestingLevel)\n{\n  if (NestingLevel > 4)\n  {\n    ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);\n    return;\n  }\n\n  char IndentString[25];\n  memset(IndentString, ' ', 25);\n  IndentString[NestingLevel * 4] = '\\0';\n\n\n  int NumDirEntries = Get16((const void*)DirStart, m_MotorolaOrder);\n\n  const unsigned char* const DirEnd = DIR_ENTRY_ADDR(DirStart, NumDirEntries);\n  if (DirEnd+4 > (OffsetBase+ExifLength))\n  {\n    if (DirEnd+2 == OffsetBase+ExifLength || DirEnd == OffsetBase+ExifLength)\n    {\n      // Version 1.3 of jhead would truncate a bit too much.\n      // This also caught later on as well.\n    }\n    else\n    {\n      ErrNonfatal(\"Illegally sized directory\", 0,0);\n      return;\n    }\n  }\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    int Tag, Format, Components;\n    unsigned char* ValuePtr;\n    int ByteCount;\n    const unsigned char* const DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    Tag = Get16(DirEntry, m_MotorolaOrder);\n    Format = Get16(DirEntry+2, m_MotorolaOrder);\n    Components = Get32(DirEntry+4, m_MotorolaOrder);\n\n    if (Format <= 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    if ((unsigned)Components > 0x10000)\n    {\n      ErrNonfatal(\"Illegal number of components %d for tag %04x\", Components, Tag);\n      continue;\n    }\n\n    ByteCount = Components * BytesPerFormat[Format - 1];\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal;\n      OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal+ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(OffsetBase)+OffsetVal);\n\n      if (OffsetVal > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = OffsetVal;\n      }\n\n    }\n    else {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(DirEntry)+8);\n    }\n\n\n    // Extract useful components of tag\n    switch(Tag)\n    {\n      case TAG_DESCRIPTION:\n      {\n        int length = max(ByteCount, 0);\n        length = min(length, MAX_COMMENT);\n        strncpy(m_ExifInfo->Description, (char *)ValuePtr, length);\n        m_ExifInfo->Description[length] = '\\0';\n        break;\n      }\n      case TAG_MAKE:\n      {\n        int space = sizeof(m_ExifInfo->CameraMake);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraMake, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraMake[space - 1] = '\\0';\n        }\n        break;\n      }\n      case TAG_MODEL:\n      {\n        int space = sizeof(m_ExifInfo->CameraModel);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraModel, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraModel[space - 1] = '\\0';\n        }\n        break;\n      }\n//      case TAG_SOFTWARE:          strncpy(m_ExifInfo->Software, ValuePtr, 5);    break;\n      case TAG_FOCALPLANEXRES:    m_FocalPlaneXRes  = ConvertAnyFormat(ValuePtr, Format);               break;\n      case TAG_THUMBNAIL_OFFSET:  m_ExifInfo->ThumbnailOffset = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n      case TAG_THUMBNAIL_LENGTH:  m_ExifInfo->ThumbnailSize   = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n\n      case TAG_MAKER_NOTE:\n        continue;\n      break;\n\n      case TAG_DATETIME_ORIGINAL:\n      {\n\n        int space = sizeof(m_ExifInfo->DateTime);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n          m_ExifInfo->DateTime[space - 1] = '\\0';\n          // If we get a DATETIME_ORIGINAL, we use that one.\n          m_DateFound = true;\n        }\n        break;\n      }\n      case TAG_DATETIME_DIGITIZED:\n      case TAG_DATETIME:\n      {\n        if (!m_DateFound)\n        {\n          // If we don't already have a DATETIME_ORIGINAL, use whatever\n          // time fields we may have.\n          int space = sizeof(m_ExifInfo->DateTime);\n          if (space > 0)\n          {\n            strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n            m_ExifInfo->DateTime[space - 1] = '\\0';\n          }\n        }\n        break;\n      }\n      case TAG_USERCOMMENT:\n      {\n        // The UserComment allows comments without the charset limitations of ImageDescription.\n        // Therefore the UserComment field is prefixed by a CharacterCode field (8 Byte):\n        //  - ASCII:         'ASCII\\0\\0\\0'\n        //  - Unicode:       'UNICODE\\0'\n        //  - JIS X208-1990: 'JIS\\0\\0\\0\\0\\0'\n        //  - Unknown:       '\\0\\0\\0\\0\\0\\0\\0\\0' (application specific)\n\n        m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNKNOWN;\n\n        const int EXIF_COMMENT_CHARSET_LENGTH = 8;\n        if (ByteCount >= EXIF_COMMENT_CHARSET_LENGTH)\n        {\n          // As some implementations use spaces instead of \\0 for the padding,\n          // we're not so strict and check only the prefix.\n          if (memcmp(ValuePtr, \"ASCII\", 5) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_ASCII;\n          else if (memcmp(ValuePtr, \"UNICODE\", 7) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n          else if (memcmp(ValuePtr, \"JIS\", 3) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_JIS;\n\n          int length = ByteCount - EXIF_COMMENT_CHARSET_LENGTH;\n          length = min(length, MAX_COMMENT);\n          memcpy(m_ExifInfo->Comments, ValuePtr + EXIF_COMMENT_CHARSET_LENGTH, length);\n          m_ExifInfo->Comments[length] = '\\0';\n//          FixComment(comment);                          // Ensure comment is printable\n        }\n      }\n      break;\n\n      case TAG_XP_COMMENT:\n      {\n        // The XP user comment field is always unicode (UCS-2) encoded\n        m_ExifInfo->XPCommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n        size_t length = min(ByteCount, MAX_COMMENT);\n        memcpy(m_ExifInfo->XPComment, ValuePtr, length);\n        m_ExifInfo->XPComment[length] = '\\0';\n      }\n      break;\n\n      case TAG_FNUMBER:\n        // Simplest way of expressing aperture, so I trust it the most.\n        // (overwrite previously computd value if there is one)\n        m_ExifInfo->ApertureFNumber = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_APERTURE:\n      case TAG_MAXAPERTURE:\n        // More relevant info always comes earlier, so only use this field if we don't\n        // have appropriate aperture information yet.\n        if (m_ExifInfo->ApertureFNumber == 0)\n        {\n          m_ExifInfo->ApertureFNumber = (float)exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)*0.5);\n        }\n      break;\n\n      case TAG_FOCALLENGTH:\n        // Nice digital cameras actually save the focal length as a function\n        // of how far they are zoomed in.\n        m_ExifInfo->FocalLength = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_SUBJECT_DISTANCE:\n        // Inidcates the distacne the autofocus camera is focused to.\n        // Tends to be less accurate as distance increases.\n        {\n          float distance = (float)ConvertAnyFormat(ValuePtr, Format);\n          m_ExifInfo->Distance = distance;\n        }\n      break;\n\n      case TAG_EXPOSURETIME:\n        {\n        // Simplest way of expressing exposure time, so I trust it most.\n        // (overwrite previously computd value if there is one)\n        float expTime = (float)ConvertAnyFormat(ValuePtr, Format);\n        if (expTime)\n          m_ExifInfo->ExposureTime = expTime;\n        }\n      break;\n\n      case TAG_SHUTTERSPEED:\n        // More complicated way of expressing exposure time, so only use\n        // this value if we don't already have it from somewhere else.\n        if (m_ExifInfo->ExposureTime == 0)\n        {\n          m_ExifInfo->ExposureTime = (float)(1/exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)));\n        }\n      break;\n\n      case TAG_FLASH:\n        m_ExifInfo->FlashUsed = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_ORIENTATION:\n        m_ExifInfo->Orientation = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->Orientation < 0 || m_ExifInfo->Orientation > 8)\n        {\n          ErrNonfatal(\"Undefined rotation value %d\", m_ExifInfo->Orientation, 0);\n          m_ExifInfo->Orientation = 0;\n        }\n      break;\n\n      case TAG_EXIF_IMAGELENGTH:\n      case TAG_EXIF_IMAGEWIDTH:\n        // Use largest of height and width to deal with images that have been\n        // rotated to portrait format.\n        {\n          int a = (int)ConvertAnyFormat(ValuePtr, Format);\n          if (m_ExifImageWidth < a) m_ExifImageWidth = a;\n        }\n      break;\n\n      case TAG_FOCALPLANEUNITS:\n        switch((int)ConvertAnyFormat(ValuePtr, Format))\n        {\n          // According to the information I was using, 2 means meters.\n          // But looking at the Cannon powershot's files, inches is the only\n          // sensible value.\n          case 1: m_FocalPlaneUnits = 25.4; break;  // inch\n          case 2: m_FocalPlaneUnits = 25.4; break;\n          case 3: m_FocalPlaneUnits = 10;   break;  // centimeter\n          case 4: m_FocalPlaneUnits = 1;    break;  // millimeter\n          case 5: m_FocalPlaneUnits = .001; break;  // micrometer\n        }\n      break;\n\n      case TAG_EXPOSURE_BIAS:\n        m_ExifInfo->ExposureBias = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_WHITEBALANCE:\n        m_ExifInfo->Whitebalance = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_LIGHT_SOURCE:\n        //Quercus: 17-1-2004 Added LightSource, some cams return this, whitebalance or both\n        m_ExifInfo->LightSource = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_METERING_MODE:\n        m_ExifInfo->MeteringMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_PROGRAM:\n        m_ExifInfo->ExposureProgram = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_INDEX:\n        if (m_ExifInfo->ISOequivalent == 0)\n        {\n          // Exposure index and ISO equivalent are often used interchangeably,\n          // so we will do the same.\n          // http://photography.about.com/library/glossary/bldef_ei.htm\n          m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        }\n      break;\n\n      case TAG_ISO_EQUIVALENT:\n        m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->ISOequivalent < 50)\n          m_ExifInfo->ISOequivalent *= 200;          // Fixes strange encoding on some older digicams.\n      break;\n\n      case TAG_EXPOSURE_MODE:\n        m_ExifInfo->ExposureMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_DIGITALZOOMRATIO:\n        m_ExifInfo->DigitalZoomRatio = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXIF_OFFSET:\n      case TAG_INTEROP_OFFSET:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);\n        }\n        else\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_GPSINFO:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal GPS directory link\",0,0);\n        }\n        else\n        {\n          ProcessGpsInfo(SubdirStart, ByteCount, OffsetBase, ExifLength);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_FOCALLENGTH_35MM:\n        // The focal length equivalent 35 mm is a 2.2 tag (defined as of April 2002)\n        // if its present, use it to compute equivalent focal length instead of\n        // computing it from sensor geometry and actual focal length.\n        m_ExifInfo->FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(ValuePtr, Format);\n      break;\n    }\n  }\n\n\n  // In addition to linking to subdirectories via exif tags,\n  // there's also a potential link to another directory at the end of each\n  // directory.  this has got to be the result of a committee!\n  unsigned Offset;\n\n  if (DIR_ENTRY_ADDR(DirStart, NumDirEntries) + 4 <= OffsetBase+ExifLength)\n  {\n    Offset = (unsigned)Get32(DirStart+2+12*NumDirEntries, m_MotorolaOrder);\n    if (Offset)\n    {\n      const unsigned char* const SubdirStart = OffsetBase + Offset;\n      if (SubdirStart > OffsetBase+ExifLength || SubdirStart < OffsetBase)\n      {\n        if (SubdirStart > OffsetBase && SubdirStart < OffsetBase+ExifLength+20)\n        {\n          // Jhead 1.3 or earlier would crop the whole directory!\n          // As Jhead produces this form of format incorrectness,\n          // I'll just let it pass silently\n        }\n        else\n        {\n          ErrNonfatal(\"Illegal subdirectory link\",0,0);\n        }\n      }\n      else\n      {\n        if (SubdirStart <= OffsetBase+ExifLength)\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n      }\n      if (Offset > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = Offset;\n      }\n    }\n  }\n  else\n  {\n    // The exif header ends before the last next directory pointer.\n  }\n\n  if (m_ExifInfo->ThumbnailOffset)\n  {\n    m_ExifInfo->ThumbnailAtEnd = false;\n\n    if (m_ExifInfo->ThumbnailOffset <= ExifLength)\n    {\n      if (m_ExifInfo->ThumbnailSize > ExifLength - m_ExifInfo->ThumbnailOffset)\n      {\n        // If thumbnail extends past exif header, only save the part that\n        // actually exists.  Canon's EOS viewer utility will do this - the\n        // thumbnail extracts ok with this hack.\n        m_ExifInfo->ThumbnailSize = ExifLength - m_ExifInfo->ThumbnailOffset;\n      }\n    }\n  }\n}",
  "abstract_func_before": "void CExifParse::ProcessDir(const unsigned char* const VAR_0,\n                            const unsigned char* const VAR_1,\n                            const unsigned VAR_2,\n                            int VAR_3)\n{\n  if (VAR_3 > 4)\n  {\n    ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);\n    return;\n  }\n\n  char VAR_4[25];\n  memset(VAR_4, ' ', 25);\n  VAR_4[VAR_3 * 4] = '\\0';\n\n\n  int VAR_5 = Get16((const void*)VAR_0, VAR_6);\n\n  const unsigned char* const VAR_7 = DIR_ENTRY_ADDR(VAR_0, VAR_5);\n  if (VAR_7+4 > (VAR_1+VAR_2))\n  {\n    if (VAR_7+2 == VAR_1+VAR_2 || VAR_7 == VAR_1+VAR_2)\n    {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n    }\n    else\n    {\n      ErrNonfatal(\"Illegally sized directory\", 0,0);\n      return;\n    }\n  }\n\n  for (int VAR_8=0;VAR_8<VAR_5;VAR_8++)\n  {\n    int VAR_9, VAR_10, VAR_11;\n    unsigned char* VAR_12;\n    int VAR_13;\n    const unsigned char* const VAR_14 = DIR_ENTRY_ADDR(VAR_0, VAR_8);\n\n    VAR_9 = Get16(VAR_14, VAR_6);\n    VAR_10 = Get16(VAR_14+2, VAR_6);\n    VAR_11 = Get32(VAR_14+4, VAR_6);\n\n    if (VAR_10 <= 0 || VAR_10 > VAR_15)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", VAR_10, VAR_9);\n      continue;\n    }\n\n    if ((unsigned)VAR_11 > 0x10000)\n    {\n      ErrNonfatal(\"Illegal number of components %d for tag %04x\", VAR_11, VAR_9);\n      continue;\n    }\n\n    VAR_13 = VAR_11 * VAR_16[VAR_10 - 1];\n\n    if (VAR_13 > 4)\n    {\n      unsigned VAR_17;\n      VAR_17 = (unsigned)Get32(VAR_14+8, VAR_6);\n      /* COMMENT_2 */\n      if (VAR_17+VAR_13 > VAR_2)\n      {\n        /* COMMENT_3 */\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", VAR_9,0);\n        continue;\n      }\n      VAR_12 = (unsigned char*)(VAR_18<unsigned char*>(VAR_1)+VAR_17);\n\n      if (VAR_17 > VAR_19)\n      {\n        VAR_19 = VAR_17;\n      }\n\n    }\n    else {\n      /* COMMENT_4 */\n      VAR_12 = (unsigned char*)(VAR_18<unsigned char*>(VAR_14)+8);\n    }\n\n\n    /* COMMENT_5 */\n    switch(VAR_9)\n    {\n      case VAR_20:\n      {\n        int VAR_21 = max(VAR_13, 0);\n        VAR_21 = min(VAR_21, VAR_22);\n        strncpy(VAR_23->Description, (char *)VAR_12, VAR_21);\n        VAR_23->Description[VAR_21] = '\\0';\n        break;\n      }\n      case VAR_24:\n      {\n        int VAR_25 = sizeof(VAR_23->CameraMake);\n        if (VAR_25 > 0)\n        {\n          strncpy(VAR_23->CameraMake, (char *)VAR_12, VAR_25 - 1);\n          VAR_23->CameraMake[VAR_25 - 1] = '\\0';\n        }\n        break;\n      }\n      case VAR_26:\n      {\n        int VAR_25 = sizeof(VAR_23->CameraModel);\n        if (VAR_25 > 0)\n        {\n          strncpy(VAR_23->CameraModel, (char *)VAR_12, VAR_25 - 1);\n          VAR_23->CameraModel[VAR_25 - 1] = '\\0';\n        }\n        break;\n      }\n/* COMMENT_6 */\n      case VAR_27:    VAR_28  = ConvertAnyFormat(VAR_12, VAR_10);               break;\n      case VAR_29:  VAR_23->ThumbnailOffset = (unsigned)ConvertAnyFormat(VAR_12, VAR_10);     break;\n      case VAR_30:  VAR_23->ThumbnailSize   = (unsigned)ConvertAnyFormat(VAR_12, VAR_10);     break;\n\n      case VAR_31:\n        continue;\n      break;\n\n      case VAR_32:\n      {\n\n        int VAR_25 = sizeof(VAR_23->DateTime);\n        if (VAR_25 > 0)\n        {\n          strncpy(VAR_23->DateTime, (char *)VAR_12, VAR_25 - 1);\n          VAR_23->DateTime[VAR_25 - 1] = '\\0';\n          /* COMMENT_7 */\n          VAR_33 = true;\n        }\n        break;\n      }\n      case VAR_34:\n      case VAR_35:\n      {\n        if (!VAR_33)\n        {\n          /* COMMENT_8 */\n          /* COMMENT_9 */\n          int VAR_25 = sizeof(VAR_23->DateTime);\n          if (VAR_25 > 0)\n          {\n            strncpy(VAR_23->DateTime, (char *)VAR_12, VAR_25 - 1);\n            VAR_23->DateTime[VAR_25 - 1] = '\\0';\n          }\n        }\n        break;\n      }\n      case VAR_36:\n      {\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n\n        VAR_23->CommentsCharset = VAR_37;\n\n        const int VAR_38 = 8;\n        if (VAR_13 >= VAR_38)\n        {\n          /* COMMENT_16 */\n          /* COMMENT_17 */\n          if (memcmp(VAR_12, \"ASCII\", 5) == 0)\n            VAR_23->CommentsCharset = VAR_39;\n          else if (memcmp(VAR_12, \"UNICODE\", 7) == 0)\n            VAR_23->CommentsCharset = VAR_40;\n          else if (memcmp(VAR_12, \"JIS\", 3) == 0)\n            VAR_23->CommentsCharset = VAR_41;\n\n          int VAR_21 = VAR_13 - VAR_38;\n          VAR_21 = min(VAR_21, VAR_22);\n          memcpy(VAR_23->Comments, VAR_12 + VAR_38, VAR_21);\n          VAR_23->Comments[VAR_21] = '\\0';\n/* COMMENT_18 */\n        }\n      }\n      break;\n\n      case VAR_42:\n      {\n        /* COMMENT_19 */\n        VAR_23->XPCommentsCharset = VAR_40;\n        size_t VAR_21 = min(VAR_13, VAR_22);\n        memcpy(VAR_23->XPComment, VAR_12, VAR_21);\n        VAR_23->XPComment[VAR_21] = '\\0';\n      }\n      break;\n\n      case VAR_43:\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        VAR_23->ApertureFNumber = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_44:\n      case VAR_45:\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n        if (VAR_23->ApertureFNumber == 0)\n        {\n          VAR_23->ApertureFNumber = (float)exp(ConvertAnyFormat(VAR_12, VAR_10)*log(2.0)*0.5);\n        }\n      break;\n\n      case VAR_46:\n        /* COMMENT_24 */\n        /* COMMENT_25 */\n        VAR_23->FocalLength = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_47:\n        /* COMMENT_26 */\n        /* COMMENT_27 */\n        {\n          float VAR_48 = (float)ConvertAnyFormat(VAR_12, VAR_10);\n          VAR_23->Distance = VAR_48;\n        }\n      break;\n\n      case VAR_49:\n        {\n        /* COMMENT_28 */\n        /* COMMENT_21 */\n        float VAR_50 = (float)ConvertAnyFormat(VAR_12, VAR_10);\n        if (VAR_50)\n          VAR_23->ExposureTime = VAR_50;\n        }\n      break;\n\n      case VAR_51:\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        if (VAR_23->ExposureTime == 0)\n        {\n          VAR_23->ExposureTime = (float)(1/exp(ConvertAnyFormat(VAR_12, VAR_10)*log(2.0)));\n        }\n      break;\n\n      case VAR_52:\n        VAR_23->FlashUsed = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_53:\n        VAR_23->Orientation = (int)ConvertAnyFormat(VAR_12, VAR_10);\n        if (VAR_23->Orientation < 0 || VAR_23->Orientation > 8)\n        {\n          ErrNonfatal(\"Undefined rotation value %d\", VAR_23->Orientation, 0);\n          VAR_23->Orientation = 0;\n        }\n      break;\n\n      case VAR_54:\n      case VAR_55:\n        /* COMMENT_31 */\n        /* COMMENT_32 */\n        {\n          int VAR_56 = (int)ConvertAnyFormat(VAR_12, VAR_10);\n          if (VAR_57 < VAR_56) VAR_57 = VAR_56;\n        }\n      break;\n\n      case VAR_58:\n        switch((int)ConvertAnyFormat(VAR_12, VAR_10))\n        {\n          /* COMMENT_33 */\n          /* COMMENT_34 */\n          /* COMMENT_35 */\n          case 1: VAR_59 = 25.4; break;  /* COMMENT_36 */\n          case 2: VAR_59 = 25.4; break;\n          case 3: VAR_59 = 10;   break;  /* COMMENT_37 */\n          case 4: VAR_59 = 1;    break;  /* COMMENT_38 */\n          case 5: VAR_59 = .001; break;  /* COMMENT_39 */\n        }\n      break;\n\n      case VAR_60:\n        VAR_23->ExposureBias = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_61:\n        VAR_23->Whitebalance = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_62:\n        /* COMMENT_40 */\n        VAR_23->LightSource = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_63:\n        VAR_23->MeteringMode = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_64:\n        VAR_23->ExposureProgram = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_65:\n        if (VAR_23->ISOequivalent == 0)\n        {\n          /* COMMENT_41 */\n          /* COMMENT_42 */\n          /* COMMENT_43 */\n          VAR_23->ISOequivalent = (int)ConvertAnyFormat(VAR_12, VAR_10);\n        }\n      break;\n\n      case VAR_66:\n        VAR_23->ISOequivalent = (int)ConvertAnyFormat(VAR_12, VAR_10);\n        if (VAR_23->ISOequivalent < 50)\n          VAR_23->ISOequivalent *= 200;          /* COMMENT_44 */\n      break;\n\n      case VAR_67:\n        VAR_23->ExposureMode = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_68:\n        VAR_23->DigitalZoomRatio = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_69:\n      case VAR_70:\n      {\n        const unsigned char* const VAR_71 = VAR_1 + (unsigned)Get32(VAR_12, VAR_6);\n        if (VAR_71 < VAR_1 || VAR_71 > VAR_1+VAR_2)\n        {\n          ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);\n        }\n        else\n        {\n          ProcessDir(VAR_71, VAR_1, VAR_2, VAR_3+1);\n        }\n        continue;\n      }\n      break;\n\n      case VAR_72:\n      {\n        const unsigned char* const VAR_71 = VAR_1 + (unsigned)Get32(VAR_12, VAR_6);\n        if (VAR_71 < VAR_1 || VAR_71 > VAR_1+VAR_2)\n        {\n          ErrNonfatal(\"Illegal GPS directory link\",0,0);\n        }\n        else\n        {\n          ProcessGpsInfo(VAR_71, VAR_13, VAR_1, VAR_2);\n        }\n        continue;\n      }\n      break;\n\n      case VAR_73:\n        /* COMMENT_45 */\n        /* COMMENT_46 */\n        /* COMMENT_47 */\n        VAR_23->FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n    }\n  }\n\n\n  /* COMMENT_48 */\n  /* COMMENT_49 */\n  /* COMMENT_50 */\n  unsigned VAR_74;\n\n  if (DIR_ENTRY_ADDR(VAR_0, VAR_5) + 4 <= VAR_1+VAR_2)\n  {\n    VAR_74 = (unsigned)Get32(VAR_0+2+12*VAR_5, VAR_6);\n    if (VAR_74)\n    {\n      const unsigned char* const VAR_71 = VAR_1 + VAR_74;\n      if (VAR_71 > VAR_1+VAR_2 || VAR_71 < VAR_1)\n      {\n        if (VAR_71 > VAR_1 && VAR_71 < VAR_1+VAR_2+20)\n        {\n          /* COMMENT_51 */\n          /* COMMENT_52 */\n          /* COMMENT_53 */\n        }\n        else\n        {\n          ErrNonfatal(\"Illegal subdirectory link\",0,0);\n        }\n      }\n      else\n      {\n        if (VAR_71 <= VAR_1+VAR_2)\n        {\n          ProcessDir(VAR_71, VAR_1, VAR_2, VAR_3+1);\n        }\n      }\n      if (VAR_74 > VAR_19)\n      {\n        VAR_19 = VAR_74;\n      }\n    }\n  }\n  else\n  {\n    /* COMMENT_54 */\n  }\n\n  if (VAR_23->ThumbnailOffset)\n  {\n    VAR_23->ThumbnailAtEnd = false;\n\n    if (VAR_23->ThumbnailOffset <= VAR_2)\n    {\n      if (VAR_23->ThumbnailSize > VAR_2 - VAR_23->ThumbnailOffset)\n      {\n        /* COMMENT_55 */\n        /* COMMENT_56 */\n        /* COMMENT_57 */\n        VAR_23->ThumbnailSize = VAR_2 - VAR_23->ThumbnailOffset;\n      }\n    }\n  }\n}",
  "func_graph_path_before": "xbmc/7e5f9fbf9aaa3540aab35e7504036855b23dcf60/ExifParse.cpp/vul/before/1.json",
  "func": "void CExifParse::ProcessDir(const unsigned char* const DirStart,\n                            const unsigned char* const OffsetBase,\n                            const unsigned ExifLength,\n                            int NestingLevel)\n{\n  if (NestingLevel > 4)\n  {\n    ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);\n    return;\n  }\n\n  char IndentString[25];\n  memset(IndentString, ' ', 25);\n  IndentString[NestingLevel * 4] = '\\0';\n\n\n  int NumDirEntries = Get16((const void*)DirStart, m_MotorolaOrder);\n\n  const unsigned char* const DirEnd = DIR_ENTRY_ADDR(DirStart, NumDirEntries);\n  if (DirEnd+4 > (OffsetBase+ExifLength))\n  {\n    if (DirEnd+2 == OffsetBase+ExifLength || DirEnd == OffsetBase+ExifLength)\n    {\n      // Version 1.3 of jhead would truncate a bit too much.\n      // This also caught later on as well.\n    }\n    else\n    {\n      ErrNonfatal(\"Illegally sized directory\", 0,0);\n      return;\n    }\n  }\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    int Tag, Format, Components;\n    unsigned char* ValuePtr;\n    int ByteCount;\n    const unsigned char* const DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    Tag = Get16(DirEntry, m_MotorolaOrder);\n    Format = Get16(DirEntry+2, m_MotorolaOrder);\n    Components = Get32(DirEntry+4, m_MotorolaOrder);\n\n    if (Format <= 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    if ((unsigned)Components > 0x10000)\n    {\n      ErrNonfatal(\"Illegal number of components %d for tag %04x\", Components, Tag);\n      continue;\n    }\n\n    ByteCount = Components * BytesPerFormat[Format - 1];\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal;\n      OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal > UINT32_MAX - ByteCount || OffsetVal + ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(OffsetBase)+OffsetVal);\n\n      if (OffsetVal > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = OffsetVal;\n      }\n\n    }\n    else {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(DirEntry)+8);\n    }\n\n\n    // Extract useful components of tag\n    switch(Tag)\n    {\n      case TAG_DESCRIPTION:\n      {\n        int length = max(ByteCount, 0);\n        length = min(length, MAX_COMMENT);\n        strncpy(m_ExifInfo->Description, (char *)ValuePtr, length);\n        m_ExifInfo->Description[length] = '\\0';\n        break;\n      }\n      case TAG_MAKE:\n      {\n        int space = sizeof(m_ExifInfo->CameraMake);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraMake, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraMake[space - 1] = '\\0';\n        }\n        break;\n      }\n      case TAG_MODEL:\n      {\n        int space = sizeof(m_ExifInfo->CameraModel);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraModel, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraModel[space - 1] = '\\0';\n        }\n        break;\n      }\n//      case TAG_SOFTWARE:          strncpy(m_ExifInfo->Software, ValuePtr, 5);    break;\n      case TAG_FOCALPLANEXRES:    m_FocalPlaneXRes  = ConvertAnyFormat(ValuePtr, Format);               break;\n      case TAG_THUMBNAIL_OFFSET:  m_ExifInfo->ThumbnailOffset = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n      case TAG_THUMBNAIL_LENGTH:  m_ExifInfo->ThumbnailSize   = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n\n      case TAG_MAKER_NOTE:\n        continue;\n      break;\n\n      case TAG_DATETIME_ORIGINAL:\n      {\n\n        int space = sizeof(m_ExifInfo->DateTime);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n          m_ExifInfo->DateTime[space - 1] = '\\0';\n          // If we get a DATETIME_ORIGINAL, we use that one.\n          m_DateFound = true;\n        }\n        break;\n      }\n      case TAG_DATETIME_DIGITIZED:\n      case TAG_DATETIME:\n      {\n        if (!m_DateFound)\n        {\n          // If we don't already have a DATETIME_ORIGINAL, use whatever\n          // time fields we may have.\n          int space = sizeof(m_ExifInfo->DateTime);\n          if (space > 0)\n          {\n            strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n            m_ExifInfo->DateTime[space - 1] = '\\0';\n          }\n        }\n        break;\n      }\n      case TAG_USERCOMMENT:\n      {\n        // The UserComment allows comments without the charset limitations of ImageDescription.\n        // Therefore the UserComment field is prefixed by a CharacterCode field (8 Byte):\n        //  - ASCII:         'ASCII\\0\\0\\0'\n        //  - Unicode:       'UNICODE\\0'\n        //  - JIS X208-1990: 'JIS\\0\\0\\0\\0\\0'\n        //  - Unknown:       '\\0\\0\\0\\0\\0\\0\\0\\0' (application specific)\n\n        m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNKNOWN;\n\n        const int EXIF_COMMENT_CHARSET_LENGTH = 8;\n        if (ByteCount >= EXIF_COMMENT_CHARSET_LENGTH)\n        {\n          // As some implementations use spaces instead of \\0 for the padding,\n          // we're not so strict and check only the prefix.\n          if (memcmp(ValuePtr, \"ASCII\", 5) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_ASCII;\n          else if (memcmp(ValuePtr, \"UNICODE\", 7) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n          else if (memcmp(ValuePtr, \"JIS\", 3) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_JIS;\n\n          int length = ByteCount - EXIF_COMMENT_CHARSET_LENGTH;\n          length = min(length, MAX_COMMENT);\n          memcpy(m_ExifInfo->Comments, ValuePtr + EXIF_COMMENT_CHARSET_LENGTH, length);\n          m_ExifInfo->Comments[length] = '\\0';\n//          FixComment(comment);                          // Ensure comment is printable\n        }\n      }\n      break;\n\n      case TAG_XP_COMMENT:\n      {\n        // The XP user comment field is always unicode (UCS-2) encoded\n        m_ExifInfo->XPCommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n        size_t length = min(ByteCount, MAX_COMMENT);\n        memcpy(m_ExifInfo->XPComment, ValuePtr, length);\n        m_ExifInfo->XPComment[length] = '\\0';\n      }\n      break;\n\n      case TAG_FNUMBER:\n        // Simplest way of expressing aperture, so I trust it the most.\n        // (overwrite previously computd value if there is one)\n        m_ExifInfo->ApertureFNumber = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_APERTURE:\n      case TAG_MAXAPERTURE:\n        // More relevant info always comes earlier, so only use this field if we don't\n        // have appropriate aperture information yet.\n        if (m_ExifInfo->ApertureFNumber == 0)\n        {\n          m_ExifInfo->ApertureFNumber = (float)exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)*0.5);\n        }\n      break;\n\n      case TAG_FOCALLENGTH:\n        // Nice digital cameras actually save the focal length as a function\n        // of how far they are zoomed in.\n        m_ExifInfo->FocalLength = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_SUBJECT_DISTANCE:\n        // Inidcates the distacne the autofocus camera is focused to.\n        // Tends to be less accurate as distance increases.\n        {\n          float distance = (float)ConvertAnyFormat(ValuePtr, Format);\n          m_ExifInfo->Distance = distance;\n        }\n      break;\n\n      case TAG_EXPOSURETIME:\n        {\n        // Simplest way of expressing exposure time, so I trust it most.\n        // (overwrite previously computd value if there is one)\n        float expTime = (float)ConvertAnyFormat(ValuePtr, Format);\n        if (expTime)\n          m_ExifInfo->ExposureTime = expTime;\n        }\n      break;\n\n      case TAG_SHUTTERSPEED:\n        // More complicated way of expressing exposure time, so only use\n        // this value if we don't already have it from somewhere else.\n        if (m_ExifInfo->ExposureTime == 0)\n        {\n          m_ExifInfo->ExposureTime = (float)(1/exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)));\n        }\n      break;\n\n      case TAG_FLASH:\n        m_ExifInfo->FlashUsed = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_ORIENTATION:\n        m_ExifInfo->Orientation = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->Orientation < 0 || m_ExifInfo->Orientation > 8)\n        {\n          ErrNonfatal(\"Undefined rotation value %d\", m_ExifInfo->Orientation, 0);\n          m_ExifInfo->Orientation = 0;\n        }\n      break;\n\n      case TAG_EXIF_IMAGELENGTH:\n      case TAG_EXIF_IMAGEWIDTH:\n        // Use largest of height and width to deal with images that have been\n        // rotated to portrait format.\n        {\n          int a = (int)ConvertAnyFormat(ValuePtr, Format);\n          if (m_ExifImageWidth < a) m_ExifImageWidth = a;\n        }\n      break;\n\n      case TAG_FOCALPLANEUNITS:\n        switch((int)ConvertAnyFormat(ValuePtr, Format))\n        {\n          // According to the information I was using, 2 means meters.\n          // But looking at the Cannon powershot's files, inches is the only\n          // sensible value.\n          case 1: m_FocalPlaneUnits = 25.4; break;  // inch\n          case 2: m_FocalPlaneUnits = 25.4; break;\n          case 3: m_FocalPlaneUnits = 10;   break;  // centimeter\n          case 4: m_FocalPlaneUnits = 1;    break;  // millimeter\n          case 5: m_FocalPlaneUnits = .001; break;  // micrometer\n        }\n      break;\n\n      case TAG_EXPOSURE_BIAS:\n        m_ExifInfo->ExposureBias = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_WHITEBALANCE:\n        m_ExifInfo->Whitebalance = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_LIGHT_SOURCE:\n        //Quercus: 17-1-2004 Added LightSource, some cams return this, whitebalance or both\n        m_ExifInfo->LightSource = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_METERING_MODE:\n        m_ExifInfo->MeteringMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_PROGRAM:\n        m_ExifInfo->ExposureProgram = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_INDEX:\n        if (m_ExifInfo->ISOequivalent == 0)\n        {\n          // Exposure index and ISO equivalent are often used interchangeably,\n          // so we will do the same.\n          // http://photography.about.com/library/glossary/bldef_ei.htm\n          m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        }\n      break;\n\n      case TAG_ISO_EQUIVALENT:\n        m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->ISOequivalent < 50)\n          m_ExifInfo->ISOequivalent *= 200;          // Fixes strange encoding on some older digicams.\n      break;\n\n      case TAG_EXPOSURE_MODE:\n        m_ExifInfo->ExposureMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_DIGITALZOOMRATIO:\n        m_ExifInfo->DigitalZoomRatio = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXIF_OFFSET:\n      case TAG_INTEROP_OFFSET:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);\n        }\n        else\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_GPSINFO:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal GPS directory link\",0,0);\n        }\n        else\n        {\n          ProcessGpsInfo(SubdirStart, ByteCount, OffsetBase, ExifLength);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_FOCALLENGTH_35MM:\n        // The focal length equivalent 35 mm is a 2.2 tag (defined as of April 2002)\n        // if its present, use it to compute equivalent focal length instead of\n        // computing it from sensor geometry and actual focal length.\n        m_ExifInfo->FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(ValuePtr, Format);\n      break;\n    }\n  }\n\n\n  // In addition to linking to subdirectories via exif tags,\n  // there's also a potential link to another directory at the end of each\n  // directory.  this has got to be the result of a committee!\n  unsigned Offset;\n\n  if (DIR_ENTRY_ADDR(DirStart, NumDirEntries) + 4 <= OffsetBase+ExifLength)\n  {\n    Offset = (unsigned)Get32(DirStart+2+12*NumDirEntries, m_MotorolaOrder);\n    if (Offset)\n    {\n      const unsigned char* const SubdirStart = OffsetBase + Offset;\n      if (SubdirStart > OffsetBase+ExifLength || SubdirStart < OffsetBase)\n      {\n        if (SubdirStart > OffsetBase && SubdirStart < OffsetBase+ExifLength+20)\n        {\n          // Jhead 1.3 or earlier would crop the whole directory!\n          // As Jhead produces this form of format incorrectness,\n          // I'll just let it pass silently\n        }\n        else\n        {\n          ErrNonfatal(\"Illegal subdirectory link\",0,0);\n        }\n      }\n      else\n      {\n        if (SubdirStart <= OffsetBase+ExifLength)\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n      }\n      if (Offset > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = Offset;\n      }\n    }\n  }\n  else\n  {\n    // The exif header ends before the last next directory pointer.\n  }\n\n  if (m_ExifInfo->ThumbnailOffset)\n  {\n    m_ExifInfo->ThumbnailAtEnd = false;\n\n    if (m_ExifInfo->ThumbnailOffset <= ExifLength)\n    {\n      if (m_ExifInfo->ThumbnailSize > ExifLength - m_ExifInfo->ThumbnailOffset)\n      {\n        // If thumbnail extends past exif header, only save the part that\n        // actually exists.  Canon's EOS viewer utility will do this - the\n        // thumbnail extracts ok with this hack.\n        m_ExifInfo->ThumbnailSize = ExifLength - m_ExifInfo->ThumbnailOffset;\n      }\n    }\n  }\n}",
  "abstract_func": "void CExifParse::ProcessDir(const unsigned char* const VAR_0,\n                            const unsigned char* const VAR_1,\n                            const unsigned VAR_2,\n                            int VAR_3)\n{\n  if (VAR_3 > 4)\n  {\n    ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);\n    return;\n  }\n\n  char VAR_4[25];\n  memset(VAR_4, ' ', 25);\n  VAR_4[VAR_3 * 4] = '\\0';\n\n\n  int VAR_5 = Get16((const void*)VAR_0, VAR_6);\n\n  const unsigned char* const VAR_7 = DIR_ENTRY_ADDR(VAR_0, VAR_5);\n  if (VAR_7+4 > (VAR_1+VAR_2))\n  {\n    if (VAR_7+2 == VAR_1+VAR_2 || VAR_7 == VAR_1+VAR_2)\n    {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n    }\n    else\n    {\n      ErrNonfatal(\"Illegally sized directory\", 0,0);\n      return;\n    }\n  }\n\n  for (int VAR_8=0;VAR_8<VAR_5;VAR_8++)\n  {\n    int VAR_9, VAR_10, VAR_11;\n    unsigned char* VAR_12;\n    int VAR_13;\n    const unsigned char* const VAR_14 = DIR_ENTRY_ADDR(VAR_0, VAR_8);\n\n    VAR_9 = Get16(VAR_14, VAR_6);\n    VAR_10 = Get16(VAR_14+2, VAR_6);\n    VAR_11 = Get32(VAR_14+4, VAR_6);\n\n    if (VAR_10 <= 0 || VAR_10 > VAR_15)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", VAR_10, VAR_9);\n      continue;\n    }\n\n    if ((unsigned)VAR_11 > 0x10000)\n    {\n      ErrNonfatal(\"Illegal number of components %d for tag %04x\", VAR_11, VAR_9);\n      continue;\n    }\n\n    VAR_13 = VAR_11 * VAR_16[VAR_10 - 1];\n\n    if (VAR_13 > 4)\n    {\n      unsigned VAR_17;\n      VAR_17 = (unsigned)Get32(VAR_14+8, VAR_6);\n      /* COMMENT_2 */\n      if (VAR_17 > VAR_18 - VAR_13 || VAR_17 + VAR_13 > VAR_2)\n      {\n        /* COMMENT_3 */\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", VAR_9,0);\n        continue;\n      }\n      VAR_12 = (unsigned char*)(VAR_19<unsigned char*>(VAR_1)+VAR_17);\n\n      if (VAR_17 > VAR_20)\n      {\n        VAR_20 = VAR_17;\n      }\n\n    }\n    else {\n      /* COMMENT_4 */\n      VAR_12 = (unsigned char*)(VAR_19<unsigned char*>(VAR_14)+8);\n    }\n\n\n    /* COMMENT_5 */\n    switch(VAR_9)\n    {\n      case VAR_21:\n      {\n        int VAR_22 = max(VAR_13, 0);\n        VAR_22 = min(VAR_22, VAR_23);\n        strncpy(VAR_24->Description, (char *)VAR_12, VAR_22);\n        VAR_24->Description[VAR_22] = '\\0';\n        break;\n      }\n      case VAR_25:\n      {\n        int VAR_26 = sizeof(VAR_24->CameraMake);\n        if (VAR_26 > 0)\n        {\n          strncpy(VAR_24->CameraMake, (char *)VAR_12, VAR_26 - 1);\n          VAR_24->CameraMake[VAR_26 - 1] = '\\0';\n        }\n        break;\n      }\n      case VAR_27:\n      {\n        int VAR_26 = sizeof(VAR_24->CameraModel);\n        if (VAR_26 > 0)\n        {\n          strncpy(VAR_24->CameraModel, (char *)VAR_12, VAR_26 - 1);\n          VAR_24->CameraModel[VAR_26 - 1] = '\\0';\n        }\n        break;\n      }\n/* COMMENT_6 */\n      case VAR_28:    VAR_29  = ConvertAnyFormat(VAR_12, VAR_10);               break;\n      case VAR_30:  VAR_24->ThumbnailOffset = (unsigned)ConvertAnyFormat(VAR_12, VAR_10);     break;\n      case VAR_31:  VAR_24->ThumbnailSize   = (unsigned)ConvertAnyFormat(VAR_12, VAR_10);     break;\n\n      case VAR_32:\n        continue;\n      break;\n\n      case VAR_33:\n      {\n\n        int VAR_26 = sizeof(VAR_24->DateTime);\n        if (VAR_26 > 0)\n        {\n          strncpy(VAR_24->DateTime, (char *)VAR_12, VAR_26 - 1);\n          VAR_24->DateTime[VAR_26 - 1] = '\\0';\n          /* COMMENT_7 */\n          VAR_34 = true;\n        }\n        break;\n      }\n      case VAR_35:\n      case VAR_36:\n      {\n        if (!VAR_34)\n        {\n          /* COMMENT_8 */\n          /* COMMENT_9 */\n          int VAR_26 = sizeof(VAR_24->DateTime);\n          if (VAR_26 > 0)\n          {\n            strncpy(VAR_24->DateTime, (char *)VAR_12, VAR_26 - 1);\n            VAR_24->DateTime[VAR_26 - 1] = '\\0';\n          }\n        }\n        break;\n      }\n      case VAR_37:\n      {\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n\n        VAR_24->CommentsCharset = VAR_38;\n\n        const int VAR_39 = 8;\n        if (VAR_13 >= VAR_39)\n        {\n          /* COMMENT_16 */\n          /* COMMENT_17 */\n          if (memcmp(VAR_12, \"ASCII\", 5) == 0)\n            VAR_24->CommentsCharset = VAR_40;\n          else if (memcmp(VAR_12, \"UNICODE\", 7) == 0)\n            VAR_24->CommentsCharset = VAR_41;\n          else if (memcmp(VAR_12, \"JIS\", 3) == 0)\n            VAR_24->CommentsCharset = VAR_42;\n\n          int VAR_22 = VAR_13 - VAR_39;\n          VAR_22 = min(VAR_22, VAR_23);\n          memcpy(VAR_24->Comments, VAR_12 + VAR_39, VAR_22);\n          VAR_24->Comments[VAR_22] = '\\0';\n/* COMMENT_18 */\n        }\n      }\n      break;\n\n      case VAR_43:\n      {\n        /* COMMENT_19 */\n        VAR_24->XPCommentsCharset = VAR_41;\n        size_t VAR_22 = min(VAR_13, VAR_23);\n        memcpy(VAR_24->XPComment, VAR_12, VAR_22);\n        VAR_24->XPComment[VAR_22] = '\\0';\n      }\n      break;\n\n      case VAR_44:\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        VAR_24->ApertureFNumber = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_45:\n      case VAR_46:\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n        if (VAR_24->ApertureFNumber == 0)\n        {\n          VAR_24->ApertureFNumber = (float)exp(ConvertAnyFormat(VAR_12, VAR_10)*log(2.0)*0.5);\n        }\n      break;\n\n      case VAR_47:\n        /* COMMENT_24 */\n        /* COMMENT_25 */\n        VAR_24->FocalLength = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_48:\n        /* COMMENT_26 */\n        /* COMMENT_27 */\n        {\n          float VAR_49 = (float)ConvertAnyFormat(VAR_12, VAR_10);\n          VAR_24->Distance = VAR_49;\n        }\n      break;\n\n      case VAR_50:\n        {\n        /* COMMENT_28 */\n        /* COMMENT_21 */\n        float VAR_51 = (float)ConvertAnyFormat(VAR_12, VAR_10);\n        if (VAR_51)\n          VAR_24->ExposureTime = VAR_51;\n        }\n      break;\n\n      case VAR_52:\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        if (VAR_24->ExposureTime == 0)\n        {\n          VAR_24->ExposureTime = (float)(1/exp(ConvertAnyFormat(VAR_12, VAR_10)*log(2.0)));\n        }\n      break;\n\n      case VAR_53:\n        VAR_24->FlashUsed = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_54:\n        VAR_24->Orientation = (int)ConvertAnyFormat(VAR_12, VAR_10);\n        if (VAR_24->Orientation < 0 || VAR_24->Orientation > 8)\n        {\n          ErrNonfatal(\"Undefined rotation value %d\", VAR_24->Orientation, 0);\n          VAR_24->Orientation = 0;\n        }\n      break;\n\n      case VAR_55:\n      case VAR_56:\n        /* COMMENT_31 */\n        /* COMMENT_32 */\n        {\n          int VAR_57 = (int)ConvertAnyFormat(VAR_12, VAR_10);\n          if (VAR_58 < VAR_57) VAR_58 = VAR_57;\n        }\n      break;\n\n      case VAR_59:\n        switch((int)ConvertAnyFormat(VAR_12, VAR_10))\n        {\n          /* COMMENT_33 */\n          /* COMMENT_34 */\n          /* COMMENT_35 */\n          case 1: VAR_60 = 25.4; break;  /* COMMENT_36 */\n          case 2: VAR_60 = 25.4; break;\n          case 3: VAR_60 = 10;   break;  /* COMMENT_37 */\n          case 4: VAR_60 = 1;    break;  /* COMMENT_38 */\n          case 5: VAR_60 = .001; break;  /* COMMENT_39 */\n        }\n      break;\n\n      case VAR_61:\n        VAR_24->ExposureBias = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_62:\n        VAR_24->Whitebalance = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_63:\n        /* COMMENT_40 */\n        VAR_24->LightSource = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_64:\n        VAR_24->MeteringMode = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_65:\n        VAR_24->ExposureProgram = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_66:\n        if (VAR_24->ISOequivalent == 0)\n        {\n          /* COMMENT_41 */\n          /* COMMENT_42 */\n          /* COMMENT_43 */\n          VAR_24->ISOequivalent = (int)ConvertAnyFormat(VAR_12, VAR_10);\n        }\n      break;\n\n      case VAR_67:\n        VAR_24->ISOequivalent = (int)ConvertAnyFormat(VAR_12, VAR_10);\n        if (VAR_24->ISOequivalent < 50)\n          VAR_24->ISOequivalent *= 200;          /* COMMENT_44 */\n      break;\n\n      case VAR_68:\n        VAR_24->ExposureMode = (int)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_69:\n        VAR_24->DigitalZoomRatio = (float)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n\n      case VAR_70:\n      case VAR_71:\n      {\n        const unsigned char* const VAR_72 = VAR_1 + (unsigned)Get32(VAR_12, VAR_6);\n        if (VAR_72 < VAR_1 || VAR_72 > VAR_1+VAR_2)\n        {\n          ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);\n        }\n        else\n        {\n          ProcessDir(VAR_72, VAR_1, VAR_2, VAR_3+1);\n        }\n        continue;\n      }\n      break;\n\n      case VAR_73:\n      {\n        const unsigned char* const VAR_72 = VAR_1 + (unsigned)Get32(VAR_12, VAR_6);\n        if (VAR_72 < VAR_1 || VAR_72 > VAR_1+VAR_2)\n        {\n          ErrNonfatal(\"Illegal GPS directory link\",0,0);\n        }\n        else\n        {\n          ProcessGpsInfo(VAR_72, VAR_13, VAR_1, VAR_2);\n        }\n        continue;\n      }\n      break;\n\n      case VAR_74:\n        /* COMMENT_45 */\n        /* COMMENT_46 */\n        /* COMMENT_47 */\n        VAR_24->FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(VAR_12, VAR_10);\n      break;\n    }\n  }\n\n\n  /* COMMENT_48 */\n  /* COMMENT_49 */\n  /* COMMENT_50 */\n  unsigned VAR_75;\n\n  if (DIR_ENTRY_ADDR(VAR_0, VAR_5) + 4 <= VAR_1+VAR_2)\n  {\n    VAR_75 = (unsigned)Get32(VAR_0+2+12*VAR_5, VAR_6);\n    if (VAR_75)\n    {\n      const unsigned char* const VAR_72 = VAR_1 + VAR_75;\n      if (VAR_72 > VAR_1+VAR_2 || VAR_72 < VAR_1)\n      {\n        if (VAR_72 > VAR_1 && VAR_72 < VAR_1+VAR_2+20)\n        {\n          /* COMMENT_51 */\n          /* COMMENT_52 */\n          /* COMMENT_53 */\n        }\n        else\n        {\n          ErrNonfatal(\"Illegal subdirectory link\",0,0);\n        }\n      }\n      else\n      {\n        if (VAR_72 <= VAR_1+VAR_2)\n        {\n          ProcessDir(VAR_72, VAR_1, VAR_2, VAR_3+1);\n        }\n      }\n      if (VAR_75 > VAR_20)\n      {\n        VAR_20 = VAR_75;\n      }\n    }\n  }\n  else\n  {\n    /* COMMENT_54 */\n  }\n\n  if (VAR_24->ThumbnailOffset)\n  {\n    VAR_24->ThumbnailAtEnd = false;\n\n    if (VAR_24->ThumbnailOffset <= VAR_2)\n    {\n      if (VAR_24->ThumbnailSize > VAR_2 - VAR_24->ThumbnailOffset)\n      {\n        /* COMMENT_55 */\n        /* COMMENT_56 */\n        /* COMMENT_57 */\n        VAR_24->ThumbnailSize = VAR_2 - VAR_24->ThumbnailOffset;\n      }\n    }\n  }\n}",
  "func_graph_path": "xbmc/7e5f9fbf9aaa3540aab35e7504036855b23dcf60/ExifParse.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -61,7 +61,7 @@\n       unsigned OffsetVal;\n       OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n       // If its bigger than 4 bytes, the dir entry contains an offset.\n-      if (OffsetVal+ByteCount > ExifLength)\n+      if (OffsetVal > UINT32_MAX - ByteCount || OffsetVal + ByteCount > ExifLength)\n       {\n         // Bogus pointer offset and / or bytecount value\n         ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);",
  "diff_line_info": {
    "deleted_lines": [
      "      if (OffsetVal+ByteCount > ExifLength)"
    ],
    "added_lines": [
      "      if (OffsetVal > UINT32_MAX - ByteCount || OffsetVal + ByteCount > ExifLength)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xbmc/xbmc/pull/22380",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/xbmc/xbmc/pull/22380: 403 Client Error: Forbidden for url: https://api.github.com/repos/xbmc/xbmc/pulls/22380",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}