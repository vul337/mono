{
  "cve_id": "CVE-2023-36328",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "libtom/libtommath",
  "commit_msg": "Fix possible integer overflow",
  "commit_hash": "beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "git_url": "https://github.com/libtom/libtommath/commit/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "file_path": "bn_s_mp_mul_high_digs_fast.c",
  "func_name": "s_mp_mul_high_digs_fast",
  "func_before": "mp_err s_mp_mul_high_digs_fast(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   int     olduse, pa, ix, iz;\n   mp_err   err;\n   mp_digit W[MP_WARRAY];\n   mp_word  _W;\n\n   /* grow the destination as required */\n   pa = a->used + b->used;\n   if (c->alloc < pa) {\n      if ((err = mp_grow(c, pa)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* number of output digits to produce */\n   pa = a->used + b->used;\n   _W = 0;\n   for (ix = digs; ix < pa; ix++) {\n      int      tx, ty, iy;\n      mp_digit *tmpx, *tmpy;\n\n      /* get offsets into the two bignums */\n      ty = MP_MIN(b->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = b->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially its\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MP_MIN(a->used-tx, ty+1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; iz++) {\n         _W += (mp_word)*tmpx++ * (mp_word)*tmpy--;\n      }\n\n      /* store term */\n      W[ix] = (mp_digit)_W & MP_MASK;\n\n      /* make next carry */\n      _W = _W >> (mp_word)MP_DIGIT_BIT;\n   }\n\n   /* setup dest */\n   olduse  = c->used;\n   c->used = pa;\n\n   {\n      mp_digit *tmpc;\n\n      tmpc = c->dp + digs;\n      for (ix = digs; ix < pa; ix++) {\n         /* now extract the previous digit [below the carry] */\n         *tmpc++ = W[ix];\n      }\n\n      /* clear unused digits [that existed in the old copy of c] */\n      MP_ZERO_DIGITS(tmpc, olduse - ix);\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}",
  "abstract_func_before": "mp_err s_mp_mul_high_digs_fast(const mp_int *VAR_0, const mp_int *VAR_1, mp_int *VAR_2, int VAR_3)\n{\n   int     VAR_4, VAR_5, VAR_6, VAR_7;\n   mp_err   VAR_8;\n   mp_digit VAR_9[VAR_10];\n   mp_word  VAR_11;\n\n   /* COMMENT_0 */\n   VAR_5 = VAR_0->used + VAR_1->used;\n   if (VAR_2->alloc < VAR_5) {\n      if ((VAR_8 = mp_grow(VAR_2, VAR_5)) != VAR_12) {\n         return VAR_8;\n      }\n   }\n\n   /* COMMENT_1 */\n   VAR_5 = VAR_0->used + VAR_1->used;\n   VAR_11 = 0;\n   for (VAR_6 = VAR_3; VAR_6 < VAR_5; VAR_6++) {\n      int      VAR_13, VAR_14, VAR_15;\n      mp_digit *VAR_16, *VAR_17;\n\n      /* COMMENT_2 */\n      VAR_14 = MP_MIN(VAR_1->used-1, VAR_6);\n      VAR_13 = VAR_6 - VAR_14;\n\n      /* COMMENT_3 */\n      VAR_16 = VAR_0->dp + VAR_13;\n      VAR_17 = VAR_1->dp + VAR_14;\n\n      /* COMMENT_4 */\n                                                    \n         \n      VAR_15 = MP_MIN(VAR_0->used-VAR_13, VAR_14+1);\n\n      /* COMMENT_7 */\n      for (VAR_7 = 0; VAR_7 < VAR_15; VAR_7++) {\n         VAR_11 += (mp_word)*VAR_16++ * (mp_word)*VAR_17--;\n      }\n\n      /* COMMENT_8 */\n      VAR_9[VAR_6] = (mp_digit)VAR_11 & VAR_18;\n\n      /* COMMENT_9 */\n      VAR_11 = VAR_11 >> (mp_word)VAR_19;\n   }\n\n   /* COMMENT_10 */\n   VAR_4  = VAR_2->used;\n   VAR_2->used = VAR_5;\n\n   {\n      mp_digit *VAR_20;\n\n      VAR_20 = VAR_2->dp + VAR_3;\n      for (VAR_6 = VAR_3; VAR_6 < VAR_5; VAR_6++) {\n         /* COMMENT_11 */\n         *VAR_20++ = VAR_9[VAR_6];\n      }\n\n      /* COMMENT_12 */\n      MP_ZERO_DIGITS(VAR_20, VAR_4 - VAR_6);\n   }\n   mp_clamp(VAR_2);\n   return VAR_12;\n}",
  "func_graph_path_before": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_s_mp_mul_high_digs_fast.c/vul/before/0.json",
  "func": "mp_err s_mp_mul_high_digs_fast(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   int     olduse, pa, ix, iz;\n   mp_err   err;\n   mp_digit W[MP_WARRAY];\n   mp_word  _W;\n\n   if (digs < 0) {\n      return MP_VAL;\n   }\n\n   /* grow the destination as required */\n   pa = a->used + b->used;\n   if (c->alloc < pa) {\n      if ((err = mp_grow(c, pa)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* number of output digits to produce */\n   pa = a->used + b->used;\n   _W = 0;\n   for (ix = digs; ix < pa; ix++) {\n      int      tx, ty, iy;\n      mp_digit *tmpx, *tmpy;\n\n      /* get offsets into the two bignums */\n      ty = MP_MIN(b->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = b->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially its\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MP_MIN(a->used-tx, ty+1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; iz++) {\n         _W += (mp_word)*tmpx++ * (mp_word)*tmpy--;\n      }\n\n      /* store term */\n      W[ix] = (mp_digit)_W & MP_MASK;\n\n      /* make next carry */\n      _W = _W >> (mp_word)MP_DIGIT_BIT;\n   }\n\n   /* setup dest */\n   olduse  = c->used;\n   c->used = pa;\n\n   {\n      mp_digit *tmpc;\n\n      tmpc = c->dp + digs;\n      for (ix = digs; ix < pa; ix++) {\n         /* now extract the previous digit [below the carry] */\n         *tmpc++ = W[ix];\n      }\n\n      /* clear unused digits [that existed in the old copy of c] */\n      MP_ZERO_DIGITS(tmpc, olduse - ix);\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}",
  "abstract_func": "mp_err s_mp_mul_high_digs_fast(const mp_int *VAR_0, const mp_int *VAR_1, mp_int *VAR_2, int VAR_3)\n{\n   int     VAR_4, VAR_5, VAR_6, VAR_7;\n   mp_err   VAR_8;\n   mp_digit VAR_9[VAR_10];\n   mp_word  VAR_11;\n\n   if (VAR_3 < 0) {\n      return VAR_12;\n   }\n\n   /* COMMENT_0 */\n   VAR_5 = VAR_0->used + VAR_1->used;\n   if (VAR_2->alloc < VAR_5) {\n      if ((VAR_8 = mp_grow(VAR_2, VAR_5)) != VAR_13) {\n         return VAR_8;\n      }\n   }\n\n   /* COMMENT_1 */\n   VAR_5 = VAR_0->used + VAR_1->used;\n   VAR_11 = 0;\n   for (VAR_6 = VAR_3; VAR_6 < VAR_5; VAR_6++) {\n      int      VAR_14, VAR_15, VAR_16;\n      mp_digit *VAR_17, *VAR_18;\n\n      /* COMMENT_2 */\n      VAR_15 = MP_MIN(VAR_1->used-1, VAR_6);\n      VAR_14 = VAR_6 - VAR_15;\n\n      /* COMMENT_3 */\n      VAR_17 = VAR_0->dp + VAR_14;\n      VAR_18 = VAR_1->dp + VAR_15;\n\n      /* COMMENT_4 */\n                                                    \n         \n      VAR_16 = MP_MIN(VAR_0->used-VAR_14, VAR_15+1);\n\n      /* COMMENT_7 */\n      for (VAR_7 = 0; VAR_7 < VAR_16; VAR_7++) {\n         VAR_11 += (mp_word)*VAR_17++ * (mp_word)*VAR_18--;\n      }\n\n      /* COMMENT_8 */\n      VAR_9[VAR_6] = (mp_digit)VAR_11 & VAR_19;\n\n      /* COMMENT_9 */\n      VAR_11 = VAR_11 >> (mp_word)VAR_20;\n   }\n\n   /* COMMENT_10 */\n   VAR_4  = VAR_2->used;\n   VAR_2->used = VAR_5;\n\n   {\n      mp_digit *VAR_21;\n\n      VAR_21 = VAR_2->dp + VAR_3;\n      for (VAR_6 = VAR_3; VAR_6 < VAR_5; VAR_6++) {\n         /* COMMENT_11 */\n         *VAR_21++ = VAR_9[VAR_6];\n      }\n\n      /* COMMENT_12 */\n      MP_ZERO_DIGITS(VAR_21, VAR_4 - VAR_6);\n   }\n   mp_clamp(VAR_2);\n   return VAR_13;\n}",
  "func_graph_path": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_s_mp_mul_high_digs_fast.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n    mp_err   err;\n    mp_digit W[MP_WARRAY];\n    mp_word  _W;\n+\n+   if (digs < 0) {\n+      return MP_VAL;\n+   }\n \n    /* grow the destination as required */\n    pa = a->used + b->used;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "   if (digs < 0) {",
      "      return MP_VAL;",
      "   }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libtom/libtommath/pull/546",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libtom/libtommath/pull/546: 403 Client Error: Forbidden for url: https://api.github.com/repos/libtom/libtommath/pulls/546",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}