{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvRead",
  "func_before": "int wolfSSH_SFTP_RecvRead(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WFD    fd;\n    word32 sz;\n    int    ret;\n    word32 idx  = 0;\n    word32 ofst[2] = {0, 0};\n\n    byte*  out;\n    word32 outSz;\n\n    char* res  = NULL;\n    char err[] = \"Read File Error\";\n    char eof[] = \"Read EOF\";\n    byte type = WOLFSSH_FTP_FAILURE;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_READ\");\n\n    /* get file handle */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        return WS_BUFFER_E;\n    }\n    WMEMSET((byte*)&fd, 0, sizeof(WFD));\n    WMEMCPY((byte*)&fd, data + idx, sz); idx += sz;\n\n    /* get offset into file */\n    ato32(data + idx, &ofst[1]); idx += UINT32_SZ;\n    ato32(data + idx, &ofst[0]); idx += UINT32_SZ;\n\n    /* get length to be read */\n    ato32(data + idx, &sz);\n\n    /* read from handle and send data back to client */\n    out = (byte*)WMALLOC(sz + WOLFSSH_SFTP_HEADER + UINT32_SZ,\n            ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    ret = WPREAD(fd, out + UINT32_SZ + WOLFSSH_SFTP_HEADER, sz, ofst);\n    if (ret < 0 || (word32)ret > sz) {\n        WLOG(WS_LOG_SFTP, \"Error reading from file\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }\n    else {\n        outSz = (word32)ret + WOLFSSH_SFTP_HEADER + UINT32_SZ;\n    }\n\n    /* eof */\n    if (ret == 0) {\n        WLOG(WS_LOG_SFTP, \"Error reading from file, EOF\");\n        res = eof;\n        type = WOLFSSH_FTP_EOF;\n        ret = WS_SUCCESS; /* end of file is not fatal error */\n    }\n\n    if (res != NULL) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", NULL,\n                &outSz) != WS_SIZE_ONLY) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        if (outSz > sz) {\n            /* need to increase buffer size for holding status packet */\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n            if (out == NULL) {\n                return WS_MEMORY_E;\n            }\n        }\n        if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                    &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        SFTP_CreatePacket(ssh, WOLFSSH_FTP_DATA, out, outSz, NULL, 0);\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func_before": "int wolfSSH_SFTP_RecvRead(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WFD    VAR_5;\n    word32 VAR_6;\n    int    VAR_7;\n    word32 VAR_8  = 0;\n    word32 VAR_9[2] = {0, 0};\n\n    byte*  VAR_10;\n    word32 VAR_11;\n\n    char* VAR_12  = NULL;\n    char VAR_13[] = \"Read File Error\";\n    char VAR_14[] = \"Read EOF\";\n    byte VAR_15 = VAR_16;\n\n    if (VAR_0 == NULL) {\n        return VAR_17;\n    }\n\n    WLOG(VAR_18, \"Receiving WOLFSSH_FTP_READ\");\n\n    /* COMMENT_0 */\n    ato32(VAR_2 + VAR_8, &VAR_6); VAR_8 += VAR_19;\n    if (VAR_6 + VAR_8 > VAR_3 || VAR_6 > VAR_20) {\n        return VAR_21;\n    }\n    WMEMSET((byte*)&VAR_5, 0, sizeof(WFD));\n    WMEMCPY((byte*)&VAR_5, VAR_2 + VAR_8, VAR_6); VAR_8 += VAR_6;\n\n    /* COMMENT_1 */\n    ato32(VAR_2 + VAR_8, &VAR_9[1]); VAR_8 += VAR_19;\n    ato32(VAR_2 + VAR_8, &VAR_9[0]); VAR_8 += VAR_19;\n\n    /* COMMENT_2 */\n    ato32(VAR_2 + VAR_8, &VAR_6);\n\n    /* COMMENT_3 */\n    VAR_10 = (byte*)WMALLOC(VAR_6 + VAR_22 + VAR_19,\n            VAR_0->ctx->heap, VAR_23);\n    if (VAR_10 == NULL) {\n        return VAR_24;\n    }\n\n    VAR_7 = WPREAD(VAR_5, VAR_10 + VAR_19 + VAR_22, VAR_6, VAR_9);\n    if (VAR_7 < 0 || (word32)VAR_7 > VAR_6) {\n        WLOG(VAR_18, \"Error reading from file\");\n        VAR_12  = VAR_13;\n        VAR_15 = VAR_16;\n        VAR_7  = VAR_25;\n    }\n    else {\n        VAR_11 = (word32)VAR_7 + VAR_22 + VAR_19;\n    }\n\n    /* COMMENT_4 */\n    if (VAR_7 == 0) {\n        WLOG(VAR_18, \"Error reading from file, EOF\");\n        VAR_12 = VAR_14;\n        VAR_15 = VAR_26;\n        VAR_7 = VAR_27; /* COMMENT_5 */\n    }\n\n    if (VAR_12 != NULL) {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_15, VAR_1, VAR_12, \"English\", NULL,\n                &VAR_11) != VAR_28) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_23);\n            return VAR_29;\n        }\n        if (VAR_11 > VAR_6) {\n            /* COMMENT_6 */\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_23);\n            VAR_10 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_23);\n            if (VAR_10 == NULL) {\n                return VAR_24;\n            }\n        }\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_15, VAR_1, VAR_12, \"English\", VAR_10,\n                    &VAR_11) != VAR_27) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_23);\n            return VAR_29;\n        }\n    }\n    else {\n        SFTP_CreatePacket(VAR_0, VAR_30, VAR_10, VAR_11, NULL, 0);\n    }\n\n    /* COMMENT_7 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_10, VAR_11);\n    return VAR_7;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/5.json",
  "func": "int wolfSSH_SFTP_RecvRead(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WFD    fd;\n    word32 sz;\n    int    ret;\n    word32 idx  = 0;\n    word32 ofst[2] = {0, 0};\n\n    byte*  out;\n    word32 outSz;\n\n    char* res  = NULL;\n    char err[] = \"Read File Error\";\n    char eof[] = \"Read EOF\";\n    byte type = WOLFSSH_FTP_FAILURE;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_READ\");\n\n    /* get file handle */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        return WS_BUFFER_E;\n    }\n    WMEMSET((byte*)&fd, 0, sizeof(WFD));\n    WMEMCPY((byte*)&fd, data + idx, sz); idx += sz;\n\n    /* get offset into file */\n    ato32(data + idx, &ofst[1]); idx += UINT32_SZ;\n    ato32(data + idx, &ofst[0]); idx += UINT32_SZ;\n\n    /* get length to be read */\n    ato32(data + idx, &sz);\n    if (sz > maxSz - WOLFSSH_SFTP_HEADER - UINT32_SZ - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* read from handle and send data back to client */\n    out = (byte*)WMALLOC(sz + WOLFSSH_SFTP_HEADER + UINT32_SZ,\n            ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    ret = WPREAD(fd, out + UINT32_SZ + WOLFSSH_SFTP_HEADER, sz, ofst);\n    if (ret < 0 || (word32)ret > sz) {\n        WLOG(WS_LOG_SFTP, \"Error reading from file\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }\n    else {\n        outSz = (word32)ret + WOLFSSH_SFTP_HEADER + UINT32_SZ;\n    }\n\n    /* eof */\n    if (ret == 0) {\n        WLOG(WS_LOG_SFTP, \"Error reading from file, EOF\");\n        res = eof;\n        type = WOLFSSH_FTP_EOF;\n        ret = WS_SUCCESS; /* end of file is not fatal error */\n    }\n\n    if (res != NULL) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", NULL,\n                &outSz) != WS_SIZE_ONLY) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        if (outSz > sz) {\n            /* need to increase buffer size for holding status packet */\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n            if (out == NULL) {\n                return WS_MEMORY_E;\n            }\n        }\n        if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                    &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        SFTP_CreatePacket(ssh, WOLFSSH_FTP_DATA, out, outSz, NULL, 0);\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func": "int wolfSSH_SFTP_RecvRead(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WFD    VAR_5;\n    word32 VAR_6;\n    int    VAR_7;\n    word32 VAR_8  = 0;\n    word32 VAR_9[2] = {0, 0};\n\n    byte*  VAR_10;\n    word32 VAR_11;\n\n    char* VAR_12  = NULL;\n    char VAR_13[] = \"Read File Error\";\n    char VAR_14[] = \"Read EOF\";\n    byte VAR_15 = VAR_16;\n\n    if (VAR_0 == NULL) {\n        return VAR_17;\n    }\n\n    WLOG(VAR_18, \"Receiving WOLFSSH_FTP_READ\");\n\n    /* COMMENT_0 */\n    ato32(VAR_2 + VAR_8, &VAR_6); VAR_8 += VAR_19;\n    if (VAR_6 + VAR_8 > VAR_3 || VAR_6 > VAR_20) {\n        return VAR_21;\n    }\n    WMEMSET((byte*)&VAR_5, 0, sizeof(WFD));\n    WMEMCPY((byte*)&VAR_5, VAR_2 + VAR_8, VAR_6); VAR_8 += VAR_6;\n\n    /* COMMENT_1 */\n    ato32(VAR_2 + VAR_8, &VAR_9[1]); VAR_8 += VAR_19;\n    ato32(VAR_2 + VAR_8, &VAR_9[0]); VAR_8 += VAR_19;\n\n    /* COMMENT_2 */\n    ato32(VAR_2 + VAR_8, &VAR_6);\n    if (VAR_6 > VAR_3 - VAR_22 - VAR_19 - VAR_8) {\n        return VAR_21;\n    }\n\n    /* COMMENT_3 */\n    VAR_10 = (byte*)WMALLOC(VAR_6 + VAR_22 + VAR_19,\n            VAR_0->ctx->heap, VAR_23);\n    if (VAR_10 == NULL) {\n        return VAR_24;\n    }\n\n    VAR_7 = WPREAD(VAR_5, VAR_10 + VAR_19 + VAR_22, VAR_6, VAR_9);\n    if (VAR_7 < 0 || (word32)VAR_7 > VAR_6) {\n        WLOG(VAR_18, \"Error reading from file\");\n        VAR_12  = VAR_13;\n        VAR_15 = VAR_16;\n        VAR_7  = VAR_25;\n    }\n    else {\n        VAR_11 = (word32)VAR_7 + VAR_22 + VAR_19;\n    }\n\n    /* COMMENT_4 */\n    if (VAR_7 == 0) {\n        WLOG(VAR_18, \"Error reading from file, EOF\");\n        VAR_12 = VAR_14;\n        VAR_15 = VAR_26;\n        VAR_7 = VAR_27; /* COMMENT_5 */\n    }\n\n    if (VAR_12 != NULL) {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_15, VAR_1, VAR_12, \"English\", NULL,\n                &VAR_11) != VAR_28) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_23);\n            return VAR_29;\n        }\n        if (VAR_11 > VAR_6) {\n            /* COMMENT_6 */\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_23);\n            VAR_10 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_23);\n            if (VAR_10 == NULL) {\n                return VAR_24;\n            }\n        }\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_15, VAR_1, VAR_12, \"English\", VAR_10,\n                    &VAR_11) != VAR_27) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_23);\n            return VAR_29;\n        }\n    }\n    else {\n        SFTP_CreatePacket(VAR_0, VAR_30, VAR_10, VAR_11, NULL, 0);\n    }\n\n    /* COMMENT_7 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_10, VAR_11);\n    return VAR_7;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,9 @@\n \n     /* get length to be read */\n     ato32(data + idx, &sz);\n+    if (sz > maxSz - WOLFSSH_SFTP_HEADER - UINT32_SZ - idx) {\n+        return WS_BUFFER_E;\n+    }\n \n     /* read from handle and send data back to client */\n     out = (byte*)WMALLOC(sz + WOLFSSH_SFTP_HEADER + UINT32_SZ,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (sz > maxSz - WOLFSSH_SFTP_HEADER - UINT32_SZ - idx) {",
      "        return WS_BUFFER_E;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": {
    "pr_info": {
      "title": "ASAN SFTP Fixes",
      "number": 360
    },
    "comment": [
      "When decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}