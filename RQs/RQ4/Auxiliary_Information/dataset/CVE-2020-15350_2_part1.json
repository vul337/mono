{
  "cve_id": "CVE-2020-15350",
  "cwe_ids": [
    "CWE-119",
    "CWE-131"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "sys/base64: Use void pointer for buffers in API\n\nThis is a non-breaking change, as `unsigned char *` can implicitly be converted\nto `void *`.",
  "commit_hash": "3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303",
  "file_path": "sys/base64/base64.c",
  "func_name": "base64_decode",
  "func_before": "int base64_decode(const unsigned char *base64_in, size_t base64_in_size,\n                  void *data_out, size_t *data_out_size)\n{\n    unsigned char *out = data_out;\n    size_t required_size = base64_estimate_decode_size(base64_in_size);\n\n    if (base64_in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (base64_in_size == 0) {\n        *data_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (base64_in_size < 4) {\n        return BASE64_ERROR_DATA_IN_SIZE;\n    }\n\n    if (*data_out_size < required_size) {\n        *data_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (data_out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_data_buffer = 0;\n    unsigned char nNum = 0;\n    int nLst = getcode(base64_in[0]) << 2;\n    int code = 0;\n\n    int mask = 2;\n\n    for (int i = 1; i < (int)(base64_in_size); i++) {\n        code = getcode(base64_in[i]);\n\n        if (code == BASE64_NOT_DEFINED || code == BASE64_EQUALS) {\n            continue;\n        }\n\n        int nm = (0xFF << (2 * mask));\n\n        nNum = nLst + ((code & (0xFF & nm)) >> (2 * mask));\n        nLst = (code & (0xFF & ~nm)) << (8 - (2 * mask));\n\n        (mask != 3) ? out[iterate_data_buffer++] = nNum : nNum;\n        (mask == 0) ? mask = 3 : mask--;\n    }\n\n    if (code == BASE64_EQUALS) {\n        /* add the last character to the data_out buffer */\n        out[iterate_data_buffer] = nNum;\n    }\n\n    *data_out_size = iterate_data_buffer;\n    return BASE64_SUCCESS;\n}",
  "abstract_func_before": "int base64_decode(const unsigned char *VAR_0, size_t VAR_1,\n                  void *VAR_2, size_t *VAR_3)\n{\n    unsigned char *VAR_4 = VAR_2;\n    size_t VAR_5 = base64_estimate_decode_size(VAR_1);\n\n    if (VAR_0 == NULL) {\n        return VAR_6;\n    }\n\n    if (VAR_1 == 0) {\n        *VAR_3 = 0;\n        return VAR_7;\n    }\n\n    if (VAR_1 < 4) {\n        return VAR_8;\n    }\n\n    if (*VAR_3 < VAR_5) {\n        *VAR_3 = VAR_5;\n        return VAR_9;\n    }\n\n    if (VAR_2 == NULL) {\n        return VAR_10;\n    }\n\n    int VAR_11 = 0;\n    unsigned char VAR_12 = 0;\n    int VAR_13 = getcode(VAR_0[0]) << 2;\n    int VAR_14 = 0;\n\n    int VAR_15 = 2;\n\n    for (int VAR_16 = 1; VAR_16 < (int)(VAR_1); VAR_16++) {\n        VAR_14 = getcode(VAR_0[VAR_16]);\n\n        if (VAR_14 == VAR_17 || VAR_14 == VAR_18) {\n            continue;\n        }\n\n        int VAR_19 = (0xFF << (2 * VAR_15));\n\n        VAR_12 = VAR_13 + ((VAR_14 & (0xFF & VAR_19)) >> (2 * VAR_15));\n        VAR_13 = (VAR_14 & (0xFF & ~VAR_19)) << (8 - (2 * VAR_15));\n\n        (VAR_15 != 3) ? VAR_4[VAR_11++] = VAR_12 : VAR_12;\n        (VAR_15 == 0) ? VAR_15 = 3 : VAR_15--;\n    }\n\n    if (VAR_14 == VAR_18) {\n        /* COMMENT_0 */\n        VAR_4[VAR_11] = VAR_12;\n    }\n\n    *VAR_3 = VAR_11;\n    return VAR_7;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303/base64.c/vul/before/2.json",
  "func": "int base64_decode(const void *base64_in, size_t base64_in_size,\n                  void *data_out, size_t *data_out_size)\n{\n    uint8_t *out = data_out;\n    const uint8_t *in = base64_in;\n    size_t required_size = base64_estimate_decode_size(base64_in_size);\n\n    if (in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (base64_in_size == 0) {\n        *data_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (base64_in_size < 4) {\n        return BASE64_ERROR_DATA_IN_SIZE;\n    }\n\n    if (*data_out_size < required_size) {\n        *data_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (data_out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_data_buffer = 0;\n    uint8_t n_num = 0;\n    int nLst = getcode(in[0]) << 2;\n    int code = 0;\n\n    int mask = 2;\n\n    for (int i = 1; i < (int)(base64_in_size); i++) {\n        code = getcode(in[i]);\n\n        if (code == BASE64_NOT_DEFINED || code == BASE64_EQUALS) {\n            continue;\n        }\n\n        int nm = (0xFF << (2 * mask));\n\n        n_num = nLst + ((code & (0xFF & nm)) >> (2 * mask));\n        nLst = (code & (0xFF & ~nm)) << (8 - (2 * mask));\n\n        (mask != 3) ? out[iterate_data_buffer++] = n_num : n_num;\n        (mask == 0) ? mask = 3 : mask--;\n    }\n\n    if (code == BASE64_EQUALS) {\n        /* add the last character to the data_out buffer */\n        out[iterate_data_buffer] = n_num;\n    }\n\n    *data_out_size = iterate_data_buffer;\n    return BASE64_SUCCESS;\n}",
  "abstract_func": "int base64_decode(const void *VAR_0, size_t VAR_1,\n                  void *VAR_2, size_t *VAR_3)\n{\n    uint8_t *VAR_4 = VAR_2;\n    const uint8_t *VAR_5 = VAR_0;\n    size_t VAR_6 = base64_estimate_decode_size(VAR_1);\n\n    if (VAR_5 == NULL) {\n        return VAR_7;\n    }\n\n    if (VAR_1 == 0) {\n        *VAR_3 = 0;\n        return VAR_8;\n    }\n\n    if (VAR_1 < 4) {\n        return VAR_9;\n    }\n\n    if (*VAR_3 < VAR_6) {\n        *VAR_3 = VAR_6;\n        return VAR_10;\n    }\n\n    if (VAR_2 == NULL) {\n        return VAR_11;\n    }\n\n    int VAR_12 = 0;\n    uint8_t VAR_13 = 0;\n    int VAR_14 = getcode(VAR_5[0]) << 2;\n    int VAR_15 = 0;\n\n    int VAR_16 = 2;\n\n    for (int VAR_17 = 1; VAR_17 < (int)(VAR_1); VAR_17++) {\n        VAR_15 = getcode(VAR_5[VAR_17]);\n\n        if (VAR_15 == VAR_18 || VAR_15 == VAR_19) {\n            continue;\n        }\n\n        int VAR_20 = (0xFF << (2 * VAR_16));\n\n        VAR_13 = VAR_14 + ((VAR_15 & (0xFF & VAR_20)) >> (2 * VAR_16));\n        VAR_14 = (VAR_15 & (0xFF & ~VAR_20)) << (8 - (2 * VAR_16));\n\n        (VAR_16 != 3) ? VAR_4[VAR_12++] = VAR_13 : VAR_13;\n        (VAR_16 == 0) ? VAR_16 = 3 : VAR_16--;\n    }\n\n    if (VAR_15 == VAR_19) {\n        /* COMMENT_0 */\n        VAR_4[VAR_12] = VAR_13;\n    }\n\n    *VAR_3 = VAR_12;\n    return VAR_8;\n}",
  "func_graph_path": "RIOT-OS/RIOT/3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303/base64.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,11 @@\n-int base64_decode(const unsigned char *base64_in, size_t base64_in_size,\n+int base64_decode(const void *base64_in, size_t base64_in_size,\n                   void *data_out, size_t *data_out_size)\n {\n-    unsigned char *out = data_out;\n+    uint8_t *out = data_out;\n+    const uint8_t *in = base64_in;\n     size_t required_size = base64_estimate_decode_size(base64_in_size);\n \n-    if (base64_in == NULL) {\n+    if (in == NULL) {\n         return BASE64_ERROR_DATA_IN;\n     }\n \n@@ -27,14 +28,14 @@\n     }\n \n     int iterate_data_buffer = 0;\n-    unsigned char nNum = 0;\n-    int nLst = getcode(base64_in[0]) << 2;\n+    uint8_t n_num = 0;\n+    int nLst = getcode(in[0]) << 2;\n     int code = 0;\n \n     int mask = 2;\n \n     for (int i = 1; i < (int)(base64_in_size); i++) {\n-        code = getcode(base64_in[i]);\n+        code = getcode(in[i]);\n \n         if (code == BASE64_NOT_DEFINED || code == BASE64_EQUALS) {\n             continue;\n@@ -42,16 +43,16 @@\n \n         int nm = (0xFF << (2 * mask));\n \n-        nNum = nLst + ((code & (0xFF & nm)) >> (2 * mask));\n+        n_num = nLst + ((code & (0xFF & nm)) >> (2 * mask));\n         nLst = (code & (0xFF & ~nm)) << (8 - (2 * mask));\n \n-        (mask != 3) ? out[iterate_data_buffer++] = nNum : nNum;\n+        (mask != 3) ? out[iterate_data_buffer++] = n_num : n_num;\n         (mask == 0) ? mask = 3 : mask--;\n     }\n \n     if (code == BASE64_EQUALS) {\n         /* add the last character to the data_out buffer */\n-        out[iterate_data_buffer] = nNum;\n+        out[iterate_data_buffer] = n_num;\n     }\n \n     *data_out_size = iterate_data_buffer;",
  "diff_line_info": {
    "deleted_lines": [
      "int base64_decode(const unsigned char *base64_in, size_t base64_in_size,",
      "    unsigned char *out = data_out;",
      "    if (base64_in == NULL) {",
      "    unsigned char nNum = 0;",
      "    int nLst = getcode(base64_in[0]) << 2;",
      "        code = getcode(base64_in[i]);",
      "        nNum = nLst + ((code & (0xFF & nm)) >> (2 * mask));",
      "        (mask != 3) ? out[iterate_data_buffer++] = nNum : nNum;",
      "        out[iterate_data_buffer] = nNum;"
    ],
    "added_lines": [
      "int base64_decode(const void *base64_in, size_t base64_in_size,",
      "    uint8_t *out = data_out;",
      "    const uint8_t *in = base64_in;",
      "    if (in == NULL) {",
      "    uint8_t n_num = 0;",
      "    int nLst = getcode(in[0]) << 2;",
      "        code = getcode(in[i]);",
      "        n_num = nLst + ((code & (0xFF & nm)) >> (2 * mask));",
      "        (mask != 3) ? out[iterate_data_buffer++] = n_num : n_num;",
      "        out[iterate_data_buffer] = n_num;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/14400",
  "description": {
    "pr_info": {
      "title": "sys/base64: Fix, unit test cleanup, and benchmark",
      "number": 14400
    },
    "comment": [
      "### Contribution description\r\n\r\n- Cherry-picked [@mjurczak fix](https://github.com/mjurczak/RIOT/commit/d27b048c28ceb1e3d0e0b06faa2f77965b7784d9) for the decode buffer size estimation (which could result in a buffer overflow of up to one byte note being catched)\r\n- Made using the API less pain by accepting `void` pointers for buffers (non-breaking change, as `unsigned char *` is implicitly casted to `void *`)\r\n- Cleaned up the unit test to fix basic code quality issued\r\n- Added a unit test to check the `base64_estimate_{de,en}code_size()`\r\n- Added a benchmark for base64 (this will come in useful to review a follow up PR)\r\n\r\n### Testing procedure\r\n\r\nThe unit tests should no detect an issue in `base64_estimate_{de,en}code_size()`\r\n\r\n### Issues/PRs references\r\n\r\nNone",
      "Somehow the build was previously not queued, toggling `CI: ready for build` seems to have solved the issue.",
      "Looks like the unit test will now fail\r\n\r\n> `base64_tests.test_base64_13_size_estimation (tests/unittests/tests-base64/tests-base64.c 495) exp 3 was 0`",
      "No need to run tests on hardware. The compilation tests include a run of the unit tests on the `native` board.",
      "@mjurczak: I cherry-picked your suggested fix and included it in the PR. This way, the credit for and authorship of the commits stays with you.",
      "With @mjurczak fix included, the unit tests are now passing. I updated the PR title and the description accordingly.",
      "Fixed some style issues, while we're at it.\r\n\r\n(I will let Murdock run again when I have squashed.)",
      "> Should the benchmark have an automatic test?\r\n\r\nI'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n\r\nWhat we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.",
      "> I'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n> \r\n> What we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.\r\n\r\nI was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\". My comment comes mainly from the impression that we now ask for a `01-run.py` for new applications.",
      "> I was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\".\r\n\r\nAh, OK! I added the test.",
      "Please squash @maribu and re-trigger ci.",
      "I fixed a typo in the test input detected by the static tests (and the corresponding base64) and added the missing empty line flake8 complained about. I squashed right away.",
      "Murdock likes it too.",
      "@mjurczak: Thank you very much for reporting and fixing the issue!\r\n\r\nThanks everyone for the reviews.",
      "@maribu  I'm stunned with the fast reaction. Great job everyone!"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "The commit involves modifying the API to use `void *` pointers, which is an improvement in flexibility but doesn't directly address a security issue. While the vulnerability description mentions a buffer overflow fix, the code changes pertain to API adjustments, falling under supporting improvements.\n\n**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 0.6"
}