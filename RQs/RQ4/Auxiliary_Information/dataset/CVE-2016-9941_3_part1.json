{
  "cve_id": "CVE-2016-9941",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "Fix heap overflow in the ultra.c decoder\n\nThe Ultra type tile decoder does not use the _safe variant of the LZO\ndecompress function, which allows a maliciuous server to overwrite parts of the\nheap by sending a larger-than-specified LZO data stream.",
  "commit_hash": "5fff4353f66427b467eb29e5fdc1da4f2be028bb",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/5fff4353f66427b467eb29e5fdc1da4f2be028bb",
  "file_path": "libvncclient/ultra.c",
  "func_name": "HandleUltraBPP",
  "func_before": "static rfbBool\nHandleUltraBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n  rfbZlibHeader hdr;\n  int toRead=0;\n  int inflateResult=0;\n  lzo_uint uncompressedBytes = (( rw * rh ) * ( BPP / 8 ));\n\n  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))\n    return FALSE;\n\n  toRead = rfbClientSwap32IfLE(hdr.nBytes);\n  if (toRead==0) return TRUE;\n\n  if (uncompressedBytes==0)\n  {\n      rfbClientLog(\"ultra error: rectangle has 0 uncomressed bytes ((%dw * %dh) * (%d / 8))\\n\", rw, rh, BPP); \n      return FALSE;\n  }\n\n  /* First make sure we have a large enough raw buffer to hold the\n   * decompressed data.  In practice, with a fixed BPP, fixed frame\n   * buffer size and the first update containing the entire frame\n   * buffer, this buffer allocation should only happen once, on the\n   * first update.\n   */\n  if ( client->raw_buffer_size < (int)uncompressedBytes) {\n    if ( client->raw_buffer != NULL ) {\n      free( client->raw_buffer );\n    }\n    client->raw_buffer_size = uncompressedBytes;\n    /* buffer needs to be aligned on 4-byte boundaries */\n    if ((client->raw_buffer_size % 4)!=0)\n      client->raw_buffer_size += (4-(client->raw_buffer_size % 4));\n    client->raw_buffer = (char*) malloc( client->raw_buffer_size );\n  }\n  \n  /* allocate enough space to store the incoming compressed packet */\n  if ( client->ultra_buffer_size < toRead ) {\n    if ( client->ultra_buffer != NULL ) {\n      free( client->ultra_buffer );\n    }\n    client->ultra_buffer_size = toRead;\n    /* buffer needs to be aligned on 4-byte boundaries */\n    if ((client->ultra_buffer_size % 4)!=0)\n      client->ultra_buffer_size += (4-(client->ultra_buffer_size % 4));\n    client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );\n  }\n\n  /* Fill the buffer, obtaining data from the server. */\n  if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))\n      return FALSE;\n\n  /* uncompress the data */\n  uncompressedBytes = client->raw_buffer_size;\n  inflateResult = lzo1x_decompress(\n              (lzo_byte *)client->ultra_buffer, toRead,\n              (lzo_byte *)client->raw_buffer, (lzo_uintp) &uncompressedBytes,\n              NULL);\n  \n  \n  if ((rw * rh * (BPP / 8)) != uncompressedBytes)\n      rfbClientLog(\"Ultra decompressed too little (%d < %d)\", (rw * rh * (BPP / 8)), uncompressedBytes);\n  \n  /* Put the uncompressed contents of the update on the screen. */\n  if ( inflateResult == LZO_E_OK ) \n  {\n    CopyRectangle(client, (unsigned char *)client->raw_buffer, rx, ry, rw, rh);\n  }\n  else\n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            inflateResult);\n    return FALSE;\n  }\n  return TRUE;\n}",
  "abstract_func_before": "static rfbBool\nHandleUltraBPP (rfbClient* VAR_0, int VAR_1, int VAR_2, int VAR_3, int VAR_4)\n{\n  rfbZlibHeader VAR_5;\n  int VAR_6=0;\n  int VAR_7=0;\n  lzo_uint VAR_8 = (( VAR_3 * VAR_4 ) * ( VAR_9 / 8 ));\n\n  if (!ReadFromRFBServer(VAR_0, (char *)&VAR_5, VAR_10))\n    return FALSE;\n\n  VAR_6 = rfbClientSwap32IfLE(VAR_5.nBytes);\n  if (VAR_6==0) return TRUE;\n\n  if (VAR_8==0)\n  {\n      rfbClientLog(\"ultra error: rectangle has 0 uncomressed bytes ((%dw * %dh) * (%d / 8))\\n\", VAR_3, VAR_4, VAR_9); \n      return FALSE;\n  }\n\n  /* COMMENT_0 */\n                                                                   \n                                                                 \n                                                                   \n                  \n     \n  if ( VAR_0->raw_buffer_size < (int)VAR_8) {\n    if ( VAR_0->raw_buffer != NULL ) {\n      free( VAR_0->raw_buffer );\n    }\n    VAR_0->raw_buffer_size = VAR_8;\n    /* COMMENT_6 */\n    if ((VAR_0->raw_buffer_size % 4)!=0)\n      VAR_0->raw_buffer_size += (4-(VAR_0->raw_buffer_size % 4));\n    VAR_0->raw_buffer = (char*) malloc( VAR_0->raw_buffer_size );\n  }\n  \n  /* COMMENT_7 */\n  if ( VAR_0->ultra_buffer_size < VAR_6 ) {\n    if ( VAR_0->ultra_buffer != NULL ) {\n      free( VAR_0->ultra_buffer );\n    }\n    VAR_0->ultra_buffer_size = VAR_6;\n    /* COMMENT_6 */\n    if ((VAR_0->ultra_buffer_size % 4)!=0)\n      VAR_0->ultra_buffer_size += (4-(VAR_0->ultra_buffer_size % 4));\n    VAR_0->ultra_buffer = (char*) malloc( VAR_0->ultra_buffer_size );\n  }\n\n  /* COMMENT_8 */\n  if (!ReadFromRFBServer(VAR_0, VAR_0->ultra_buffer, VAR_6))\n      return FALSE;\n\n  /* COMMENT_9 */\n  VAR_8 = VAR_0->raw_buffer_size;\n  VAR_7 = lzo1x_decompress(\n              (lzo_byte *)VAR_0->ultra_buffer, VAR_6,\n              (lzo_byte *)VAR_0->raw_buffer, (VAR_11) &VAR_8,\n              NULL);\n  \n  \n  if ((VAR_3 * VAR_4 * (VAR_9 / 8)) != VAR_8)\n      rfbClientLog(\"Ultra decompressed too little (%d < %d)\", (VAR_3 * VAR_4 * (VAR_9 / 8)), VAR_8);\n  \n  /* COMMENT_10 */\n  if ( VAR_7 == VAR_12 ) \n  {\n    CopyRectangle(VAR_0, (unsigned char *)VAR_0->raw_buffer, VAR_1, VAR_2, VAR_3, VAR_4);\n  }\n  else\n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            VAR_7);\n    return FALSE;\n  }\n  return TRUE;\n}",
  "func_graph_path_before": "LibVNC/libvncserver/5fff4353f66427b467eb29e5fdc1da4f2be028bb/ultra.c/vul/before/1.json",
  "func": "static rfbBool\nHandleUltraBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n  rfbZlibHeader hdr;\n  int toRead=0;\n  int inflateResult=0;\n  lzo_uint uncompressedBytes = (( rw * rh ) * ( BPP / 8 ));\n\n  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))\n    return FALSE;\n\n  toRead = rfbClientSwap32IfLE(hdr.nBytes);\n  if (toRead==0) return TRUE;\n\n  if (uncompressedBytes==0)\n  {\n      rfbClientLog(\"ultra error: rectangle has 0 uncomressed bytes ((%dw * %dh) * (%d / 8))\\n\", rw, rh, BPP); \n      return FALSE;\n  }\n\n  /* First make sure we have a large enough raw buffer to hold the\n   * decompressed data.  In practice, with a fixed BPP, fixed frame\n   * buffer size and the first update containing the entire frame\n   * buffer, this buffer allocation should only happen once, on the\n   * first update.\n   */\n  if ( client->raw_buffer_size < (int)uncompressedBytes) {\n    if ( client->raw_buffer != NULL ) {\n      free( client->raw_buffer );\n    }\n    client->raw_buffer_size = uncompressedBytes;\n    /* buffer needs to be aligned on 4-byte boundaries */\n    if ((client->raw_buffer_size % 4)!=0)\n      client->raw_buffer_size += (4-(client->raw_buffer_size % 4));\n    client->raw_buffer = (char*) malloc( client->raw_buffer_size );\n  }\n  \n  /* allocate enough space to store the incoming compressed packet */\n  if ( client->ultra_buffer_size < toRead ) {\n    if ( client->ultra_buffer != NULL ) {\n      free( client->ultra_buffer );\n    }\n    client->ultra_buffer_size = toRead;\n    /* buffer needs to be aligned on 4-byte boundaries */\n    if ((client->ultra_buffer_size % 4)!=0)\n      client->ultra_buffer_size += (4-(client->ultra_buffer_size % 4));\n    client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );\n  }\n\n  /* Fill the buffer, obtaining data from the server. */\n  if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))\n      return FALSE;\n\n  /* uncompress the data */\n  uncompressedBytes = client->raw_buffer_size;\n  inflateResult = lzo1x_decompress_safe(\n              (lzo_byte *)client->ultra_buffer, toRead,\n              (lzo_byte *)client->raw_buffer, (lzo_uintp) &uncompressedBytes,\n              NULL);\n  \n  /* Note that uncompressedBytes will be 0 on output overrun */\n  if ((rw * rh * (BPP / 8)) != uncompressedBytes)\n      rfbClientLog(\"Ultra decompressed unexpected amount of data (%d != %d)\\n\", (rw * rh * (BPP / 8)), uncompressedBytes);\n  \n  /* Put the uncompressed contents of the update on the screen. */\n  if ( inflateResult == LZO_E_OK ) \n  {\n    CopyRectangle(client, (unsigned char *)client->raw_buffer, rx, ry, rw, rh);\n  }\n  else\n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            inflateResult);\n    return FALSE;\n  }\n  return TRUE;\n}",
  "abstract_func": "static rfbBool\nHandleUltraBPP (rfbClient* VAR_0, int VAR_1, int VAR_2, int VAR_3, int VAR_4)\n{\n  rfbZlibHeader VAR_5;\n  int VAR_6=0;\n  int VAR_7=0;\n  lzo_uint VAR_8 = (( VAR_3 * VAR_4 ) * ( VAR_9 / 8 ));\n\n  if (!ReadFromRFBServer(VAR_0, (char *)&VAR_5, VAR_10))\n    return FALSE;\n\n  VAR_6 = rfbClientSwap32IfLE(VAR_5.nBytes);\n  if (VAR_6==0) return TRUE;\n\n  if (VAR_8==0)\n  {\n      rfbClientLog(\"ultra error: rectangle has 0 uncomressed bytes ((%dw * %dh) * (%d / 8))\\n\", VAR_3, VAR_4, VAR_9); \n      return FALSE;\n  }\n\n  /* COMMENT_0 */\n                                                                   \n                                                                 \n                                                                   \n                  \n     \n  if ( VAR_0->raw_buffer_size < (int)VAR_8) {\n    if ( VAR_0->raw_buffer != NULL ) {\n      free( VAR_0->raw_buffer );\n    }\n    VAR_0->raw_buffer_size = VAR_8;\n    /* COMMENT_6 */\n    if ((VAR_0->raw_buffer_size % 4)!=0)\n      VAR_0->raw_buffer_size += (4-(VAR_0->raw_buffer_size % 4));\n    VAR_0->raw_buffer = (char*) malloc( VAR_0->raw_buffer_size );\n  }\n  \n  /* COMMENT_7 */\n  if ( VAR_0->ultra_buffer_size < VAR_6 ) {\n    if ( VAR_0->ultra_buffer != NULL ) {\n      free( VAR_0->ultra_buffer );\n    }\n    VAR_0->ultra_buffer_size = VAR_6;\n    /* COMMENT_6 */\n    if ((VAR_0->ultra_buffer_size % 4)!=0)\n      VAR_0->ultra_buffer_size += (4-(VAR_0->ultra_buffer_size % 4));\n    VAR_0->ultra_buffer = (char*) malloc( VAR_0->ultra_buffer_size );\n  }\n\n  /* COMMENT_8 */\n  if (!ReadFromRFBServer(VAR_0, VAR_0->ultra_buffer, VAR_6))\n      return FALSE;\n\n  /* COMMENT_9 */\n  VAR_8 = VAR_0->raw_buffer_size;\n  VAR_7 = lzo1x_decompress_safe(\n              (lzo_byte *)VAR_0->ultra_buffer, VAR_6,\n              (lzo_byte *)VAR_0->raw_buffer, (VAR_11) &VAR_8,\n              NULL);\n  \n  /* COMMENT_10 */\n  if ((VAR_3 * VAR_4 * (VAR_9 / 8)) != VAR_8)\n      rfbClientLog(\"Ultra decompressed unexpected amount of data (%d != %d)\\n\", (VAR_3 * VAR_4 * (VAR_9 / 8)), VAR_8);\n  \n  /* COMMENT_11 */\n  if ( VAR_7 == VAR_12 ) \n  {\n    CopyRectangle(VAR_0, (unsigned char *)VAR_0->raw_buffer, VAR_1, VAR_2, VAR_3, VAR_4);\n  }\n  else\n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            VAR_7);\n    return FALSE;\n  }\n  return TRUE;\n}",
  "func_graph_path": "LibVNC/libvncserver/5fff4353f66427b467eb29e5fdc1da4f2be028bb/ultra.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -53,14 +53,14 @@\n \n   /* uncompress the data */\n   uncompressedBytes = client->raw_buffer_size;\n-  inflateResult = lzo1x_decompress(\n+  inflateResult = lzo1x_decompress_safe(\n               (lzo_byte *)client->ultra_buffer, toRead,\n               (lzo_byte *)client->raw_buffer, (lzo_uintp) &uncompressedBytes,\n               NULL);\n   \n-  \n+  /* Note that uncompressedBytes will be 0 on output overrun */\n   if ((rw * rh * (BPP / 8)) != uncompressedBytes)\n-      rfbClientLog(\"Ultra decompressed too little (%d < %d)\", (rw * rh * (BPP / 8)), uncompressedBytes);\n+      rfbClientLog(\"Ultra decompressed unexpected amount of data (%d != %d)\\n\", (rw * rh * (BPP / 8)), uncompressedBytes);\n   \n   /* Put the uncompressed contents of the update on the screen. */\n   if ( inflateResult == LZO_E_OK ) ",
  "diff_line_info": {
    "deleted_lines": [
      "  inflateResult = lzo1x_decompress(",
      "  ",
      "      rfbClientLog(\"Ultra decompressed too little (%d < %d)\", (rw * rh * (BPP / 8)), uncompressedBytes);"
    ],
    "added_lines": [
      "  inflateResult = lzo1x_decompress_safe(",
      "  /* Note that uncompressedBytes will be 0 on output overrun */",
      "      rfbClientLog(\"Ultra decompressed unexpected amount of data (%d != %d)\\n\", (rw * rh * (BPP / 8)), uncompressedBytes);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/137",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/LibVNC/libvncserver/pull/137: 403 Client Error: Forbidden for url: https://api.github.com/repos/LibVNC/libvncserver/pulls/137",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch fixes a heap overflow by using a safer decompression function, aligning perfectly with the security vulnerability description.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}