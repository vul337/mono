{
  "cve_id": "CVE-2023-33975",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "gnrc_sixlowpan_frag_rb: fix OOB write in _rbuf_add",
  "commit_hash": "1aeb90ee5555ae78b567a6365ae4ab71bfd1404b",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/1aeb90ee5555ae78b567a6365ae4ab71bfd1404b",
  "file_path": "sys/net/gnrc/network_layer/sixlowpan/frag/rb/gnrc_sixlowpan_frag_rb.c",
  "func_name": "_rbuf_add",
  "func_before": "static int _rbuf_add(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                     size_t offset, unsigned page)\n{\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *super;\n        gnrc_sixlowpan_frag_rb_t *rbuf;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } entry;\n    const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);\n    const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);\n    uint8_t *data = NULL;\n    size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */\n    int res;\n    uint16_t datagram_size;\n    uint16_t datagram_tag;\n\n    /* check if provided offset is the same as in fragment */\n    assert(_valid_offset(pkt, offset));\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {\n        data = _6lo_frag_payload(pkt);\n        frag_size = _6lo_frag_size(pkt, offset, data);\n        if (frag_size == 0) {\n            DEBUG(\"6lo rbuf: integer underflow detected.\\n\");\n            gnrc_pktbuf_release(pkt);\n            return RBUF_ADD_ERROR;\n        }\n        datagram_size = sixlowpan_frag_datagram_size(pkt->data);\n        datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);\n    }\n    else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n             sixlowpan_sfr_rfrag_is(pkt->data)) {\n        sixlowpan_sfr_rfrag_t *rfrag = pkt->data;\n\n        data = _6lo_sfr_payload(pkt);\n        frag_size = _6lo_sfr_frag_size(pkt);\n        /* offset doubles as datagram size in RFRAG header when sequence number\n         * is 0 */\n        datagram_size = _6lo_sfr_datagram_size(pkt, offset);\n        datagram_tag = rfrag->base.tag;\n    }\n    else {\n        /* either one of the if branches above was taken */\n        assert(data != NULL);\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n\n    gnrc_sixlowpan_frag_rb_gc();\n    /* only check VRB for subsequent frags, first frags create and not get VRB\n     * entries below */\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n        (offset > 0) &&\n        sixlowpan_frag_n_is(pkt->data) &&\n        (entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,\n                                                 datagram_tag)) != NULL) {\n        DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");\n        switch (_check_fragments(entry.super, frag_size, offset)) {\n            case RBUF_ADD_REPEAT:\n                DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(entry.vrb);\n                /* we don't repeat for VRB */\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_ERROR;\n            case RBUF_ADD_DUPLICATE:\n                DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_FORWARDED;\n            default:\n                break;\n        }\n        res = RBUF_ADD_ERROR;\n        if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n            DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");\n            entry.super->current_size += (uint16_t)frag_size;\n            if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,\n                              page) < 0) {\n                DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");\n                return RBUF_ADD_ERROR;\n            }\n            res = RBUF_ADD_FORWARDED;\n        }\n        return res;\n    }\n    else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,\n                              dst, netif_hdr->dst_l2addr_len,\n                              datagram_size, datagram_tag, page)) < 0) {\n        DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n    entry.rbuf = &rbuf[res];\n#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)\n    offset += entry.rbuf->offset_diff;\n#endif  /* IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) */\n    if ((offset + frag_size) > entry.super->datagram_size) {\n        DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_pktbuf_release(pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        return RBUF_ADD_ERROR;\n    }\n\n    switch (_check_fragments(entry.super, frag_size, offset)) {\n        case RBUF_ADD_REPEAT:\n            DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");\n            gnrc_pktbuf_release(entry.rbuf->pkt);\n            gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n            return RBUF_ADD_REPEAT;\n        case RBUF_ADD_DUPLICATE:\n            gnrc_pktbuf_release(pkt);\n            return res;\n        default:\n            break;\n    }\n\n    if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n        DEBUG(\"6lo rbuf: add fragment data\\n\");\n        entry.super->current_size += (uint16_t)frag_size;\n        if (offset == 0) {\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&\n                sixlowpan_iphc_is(data)) {\n                DEBUG(\"6lo rbuf: detected IPHC header.\\n\");\n                gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);\n\n                if (frag_hdr == NULL) {\n                    DEBUG(\"6lo rbuf: unable to mark fragment header. \"\n                          \"aborting reassembly.\\n\");\n                    gnrc_pktbuf_release(entry.rbuf->pkt);\n                    gnrc_pktbuf_release(pkt);\n                    gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n                    return RBUF_ADD_ERROR;\n                }\n                else {\n                    DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");\n                    /* `pkt` released in IPHC */\n                    gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);\n                    /* check if entry was deleted in IPHC (error case) */\n                    if (gnrc_sixlowpan_frag_rb_entry_empty(entry.rbuf)) {\n                        res = RBUF_ADD_ERROR;\n                    }\n                    return res;\n                }\n            }\n            else if (data[0] == SIXLOWPAN_UNCOMP) {\n                DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");\n                data++;\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n                    /* only try minimal forwarding when fragment is the only\n                     * fragment in reassembly buffer yet */\n                    sixlowpan_frag_1_is(pkt->data) &&\n                    (entry.super->current_size == frag_size)) {\n                    gnrc_sixlowpan_frag_vrb_t *vrbe;\n                    gnrc_pktsnip_t tmp = {\n                        .data = data,\n                        .size = frag_size,\n                        .users = 1,\n                    };\n\n                    if (_check_hdr(&tmp, page) &&\n                        (vrbe = gnrc_sixlowpan_frag_vrb_from_route(\n                                    entry.super,\n                                    gnrc_netif_hdr_get_netif(netif_hdr),\n                                    &tmp))) {\n                        _adapt_hdr(&tmp, page);\n                        return _forward_uncomp(pkt, rbuf, vrbe, page);\n                    }\n                }\n                else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n                         sixlowpan_sfr_rfrag_is(pkt->data)) {\n                    entry.super->datagram_size--;\n                }\n            }\n        }\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||\n            IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {\n            /* all cases to try forwarding with minfwd or SFR above failed so\n             * just do normal reassembly. For the `minfwd` case however, we need\n             * to resize `entry.rbuf->pkt`, since we kept the packet allocation\n             * with fragment forwarding as minimal as possible in\n             * `_rbuf_get()` */\n            res = _rbuf_resize_for_reassembly(entry.rbuf);\n            if (res == RBUF_ADD_ERROR) {\n                gnrc_pktbuf_release(pkt);\n                return res;\n            }\n        }\n        memcpy(((uint8_t *)entry.rbuf->pkt->data) + offset, data,\n               frag_size);\n    }\n    else {\n        /* no space left in rbuf interval buffer*/\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        res = RBUF_ADD_ERROR;\n    }\n    /* no errors and not consumed => release packet */\n    gnrc_pktbuf_release(pkt);\n    return res;\n}",
  "abstract_func_before": "static int _rbuf_add(gnrc_netif_hdr_t *VAR_0, gnrc_pktsnip_t *VAR_1,\n                     size_t VAR_2, unsigned VAR_3)\n{\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *super;\n        gnrc_sixlowpan_frag_rb_t *rbuf;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } VAR_4;\n    const uint8_t *VAR_5 = gnrc_netif_hdr_get_src_addr(VAR_0);\n    const uint8_t *VAR_6 = gnrc_netif_hdr_get_dst_addr(VAR_0);\n    uint8_t *VAR_7 = NULL;\n    size_t VAR_8 = 0;   /* COMMENT_0 */\n    int VAR_9;\n    uint16_t VAR_10;\n    uint16_t VAR_11;\n\n    /* COMMENT_1 */\n    assert(_valid_offset(VAR_1, VAR_2));\n    if (IS_USED(VAR_12) && sixlowpan_frag_is(VAR_1->data)) {\n        VAR_7 = _6lo_frag_payload(VAR_1);\n        VAR_8 = _6lo_frag_size(VAR_1, VAR_2, VAR_7);\n        if (VAR_8 == 0) {\n            DEBUG(\"6lo rbuf: integer underflow detected.\\n\");\n            gnrc_pktbuf_release(VAR_1);\n            return VAR_13;\n        }\n        VAR_10 = sixlowpan_frag_datagram_size(VAR_1->data);\n        VAR_11 = sixlowpan_frag_datagram_tag(VAR_1->data);\n    }\n    else if (IS_USED(VAR_14) &&\n             sixlowpan_sfr_rfrag_is(VAR_1->data)) {\n        sixlowpan_sfr_rfrag_t *VAR_15 = VAR_1->data;\n\n        VAR_7 = _6lo_sfr_payload(VAR_1);\n        VAR_8 = _6lo_sfr_frag_size(VAR_1);\n        /* COMMENT_2 */\n                  \n        VAR_10 = _6lo_sfr_datagram_size(VAR_1, VAR_2);\n        VAR_11 = VAR_15->base.tag;\n    }\n    else {\n        /* COMMENT_4 */\n        assert(VAR_7 != NULL);\n        gnrc_pktbuf_release(VAR_1);\n        return VAR_13;\n    }\n\n    gnrc_sixlowpan_frag_rb_gc();\n    /* COMMENT_5 */\n                       \n    if (IS_USED(VAR_16) &&\n        (VAR_2 > 0) &&\n        sixlowpan_frag_n_is(VAR_1->data) &&\n        (VAR_4.vrb = gnrc_sixlowpan_frag_vrb_get(VAR_5, VAR_0->src_l2addr_len,\n                                                 VAR_11)) != NULL) {\n        DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");\n        switch (_check_fragments(VAR_4.super, VAR_8, VAR_2)) {\n            case VAR_17:\n                DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(VAR_4.vrb);\n                /* COMMENT_7 */\n                gnrc_pktbuf_release(VAR_1);\n                return VAR_13;\n            case VAR_18:\n                DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");\n                gnrc_pktbuf_release(VAR_1);\n                return VAR_19;\n            default:\n                break;\n        }\n        VAR_9 = VAR_13;\n        if (_rbuf_update_ints(VAR_4.super, VAR_2, VAR_8)) {\n            DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");\n            VAR_4.super->current_size += (uint16_t)VAR_8;\n            if (_forward_frag(VAR_1, sizeof(VAR_20), VAR_4.vrb,\n                              VAR_3) < 0) {\n                DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");\n                return VAR_13;\n            }\n            VAR_9 = VAR_19;\n        }\n        return VAR_9;\n    }\n    else if ((VAR_9 = _rbuf_get(VAR_5, VAR_0->src_l2addr_len,\n                              VAR_6, VAR_0->dst_l2addr_len,\n                              VAR_10, VAR_11, VAR_3)) < 0) {\n        DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");\n        gnrc_pktbuf_release(VAR_1);\n        return VAR_13;\n    }\n    VAR_4.rbuf = &VAR_21[VAR_9];\n#if IS_USED(VAR_14)\n    VAR_2 += VAR_4.rbuf->offset_diff;\n#endif  /* COMMENT_8 */\n    if ((VAR_2 + VAR_8) > VAR_4.super->datagram_size) {\n        DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");\n        gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n        gnrc_pktbuf_release(VAR_1);\n        gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n        return VAR_13;\n    }\n\n    switch (_check_fragments(VAR_4.super, VAR_8, VAR_2)) {\n        case VAR_17:\n            DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");\n            gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n            gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n            return VAR_17;\n        case VAR_18:\n            gnrc_pktbuf_release(VAR_1);\n            return VAR_9;\n        default:\n            break;\n    }\n\n    if (_rbuf_update_ints(VAR_4.super, VAR_2, VAR_8)) {\n        DEBUG(\"6lo rbuf: add fragment data\\n\");\n        VAR_4.super->current_size += (uint16_t)VAR_8;\n        if (VAR_2 == 0) {\n            if (IS_USED(VAR_22) &&\n                sixlowpan_iphc_is(VAR_7)) {\n                DEBUG(\"6lo rbuf: detected IPHC header.\\n\");\n                gnrc_pktsnip_t *VAR_23 = _mark_frag_hdr(VAR_1);\n\n                if (VAR_23 == NULL) {\n                    DEBUG(\"6lo rbuf: unable to mark fragment header. \"\n                          \"aborting reassembly.\\n\");\n                    gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n                    gnrc_pktbuf_release(VAR_1);\n                    gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n                    return VAR_13;\n                }\n                else {\n                    DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");\n                    /* COMMENT_9 */\n                    gnrc_sixlowpan_iphc_recv(VAR_1, VAR_4.rbuf, 0);\n                    /* COMMENT_10 */\n                    if (gnrc_sixlowpan_frag_rb_entry_empty(VAR_4.rbuf)) {\n                        VAR_9 = VAR_13;\n                    }\n                    return VAR_9;\n                }\n            }\n            else if (VAR_7[0] == VAR_24) {\n                DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");\n                VAR_7++;\n                if (IS_USED(VAR_16) &&\n                    /* COMMENT_11 */\n                                                           \n                    sixlowpan_frag_1_is(VAR_1->data) &&\n                    (VAR_4.super->current_size == VAR_8)) {\n                    gnrc_sixlowpan_frag_vrb_t *VAR_25;\n                    gnrc_pktsnip_t VAR_26 = {\n                        .data = VAR_7,\n                        .size = VAR_8,\n                        .users = 1,\n                    };\n\n                    if (_check_hdr(&VAR_26, VAR_3) &&\n                        (VAR_25 = gnrc_sixlowpan_frag_vrb_from_route(\n                                    VAR_4.super,\n                                    gnrc_netif_hdr_get_netif(VAR_0),\n                                    &VAR_26))) {\n                        _adapt_hdr(&VAR_26, VAR_3);\n                        return _forward_uncomp(VAR_1, VAR_21, VAR_25, VAR_3);\n                    }\n                }\n                else if (IS_USED(VAR_14) &&\n                         sixlowpan_sfr_rfrag_is(VAR_1->data)) {\n                    VAR_4.super->datagram_size--;\n                }\n            }\n        }\n        if (IS_USED(VAR_16) ||\n            IS_USED(VAR_14)) {\n            /* COMMENT_13 */\n                                                                                \n                                                                               \n                                                                 \n                               \n            VAR_9 = _rbuf_resize_for_reassembly(VAR_4.rbuf);\n            if (VAR_9 == VAR_13) {\n                gnrc_pktbuf_release(VAR_1);\n                return VAR_9;\n            }\n        }\n        memcpy(((uint8_t *)VAR_4.rbuf->pkt->data) + VAR_2, VAR_7,\n               VAR_8);\n    }\n    else {\n        /* COMMENT_18 */\n        gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n        gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n        VAR_9 = VAR_13;\n    }\n    /* COMMENT_19 */\n    gnrc_pktbuf_release(VAR_1);\n    return VAR_9;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/1aeb90ee5555ae78b567a6365ae4ab71bfd1404b/gnrc_sixlowpan_frag_rb.c/vul/before/0.json",
  "func": "static int _rbuf_add(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                     size_t offset, unsigned page)\n{\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *super;\n        gnrc_sixlowpan_frag_rb_t *rbuf;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } entry;\n    const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);\n    const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);\n    uint8_t *data = NULL;\n    size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */\n    int res;\n    uint16_t datagram_size;\n    uint16_t datagram_tag;\n\n    /* check if provided offset is the same as in fragment */\n    assert(_valid_offset(pkt, offset));\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {\n        data = _6lo_frag_payload(pkt);\n        frag_size = _6lo_frag_size(pkt, offset, data);\n        if (frag_size == 0) {\n            DEBUG(\"6lo rbuf: integer underflow detected.\\n\");\n            gnrc_pktbuf_release(pkt);\n            return RBUF_ADD_ERROR;\n        }\n        datagram_size = sixlowpan_frag_datagram_size(pkt->data);\n        datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);\n    }\n    else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n             sixlowpan_sfr_rfrag_is(pkt->data)) {\n        sixlowpan_sfr_rfrag_t *rfrag = pkt->data;\n\n        data = _6lo_sfr_payload(pkt);\n        frag_size = _6lo_sfr_frag_size(pkt);\n        /* offset doubles as datagram size in RFRAG header when sequence number\n         * is 0 */\n        datagram_size = _6lo_sfr_datagram_size(pkt, offset);\n        datagram_tag = rfrag->base.tag;\n    }\n    else {\n        /* either one of the if branches above was taken */\n        assert(data != NULL);\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n\n    gnrc_sixlowpan_frag_rb_gc();\n    /* only check VRB for subsequent frags, first frags create and not get VRB\n     * entries below */\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n        (offset > 0) &&\n        sixlowpan_frag_n_is(pkt->data) &&\n        (entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,\n                                                 datagram_tag)) != NULL) {\n        DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");\n        switch (_check_fragments(entry.super, frag_size, offset)) {\n            case RBUF_ADD_REPEAT:\n                DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(entry.vrb);\n                /* we don't repeat for VRB */\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_ERROR;\n            case RBUF_ADD_DUPLICATE:\n                DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_FORWARDED;\n            default:\n                break;\n        }\n        res = RBUF_ADD_ERROR;\n        if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n            DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");\n            entry.super->current_size += (uint16_t)frag_size;\n            if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,\n                              page) < 0) {\n                DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");\n                return RBUF_ADD_ERROR;\n            }\n            res = RBUF_ADD_FORWARDED;\n        }\n        return res;\n    }\n    else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,\n                              dst, netif_hdr->dst_l2addr_len,\n                              datagram_size, datagram_tag, page)) < 0) {\n        DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n    entry.rbuf = &rbuf[res];\n#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)\n    offset += entry.rbuf->offset_diff;\n#endif  /* IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) */\n    if ((offset + frag_size) > entry.super->datagram_size) {\n        DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_pktbuf_release(pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        return RBUF_ADD_ERROR;\n    }\n\n    switch (_check_fragments(entry.super, frag_size, offset)) {\n        case RBUF_ADD_REPEAT:\n            DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");\n            gnrc_pktbuf_release(entry.rbuf->pkt);\n            gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n            return RBUF_ADD_REPEAT;\n        case RBUF_ADD_DUPLICATE:\n            gnrc_pktbuf_release(pkt);\n            return res;\n        default:\n            break;\n    }\n\n    if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n        DEBUG(\"6lo rbuf: add fragment data\\n\");\n        entry.super->current_size += (uint16_t)frag_size;\n        if (offset == 0) {\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&\n                sixlowpan_iphc_is(data)) {\n                DEBUG(\"6lo rbuf: detected IPHC header.\\n\");\n                gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);\n\n                if (frag_hdr == NULL) {\n                    DEBUG(\"6lo rbuf: unable to mark fragment header. \"\n                          \"aborting reassembly.\\n\");\n                    gnrc_pktbuf_release(entry.rbuf->pkt);\n                    gnrc_pktbuf_release(pkt);\n                    gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n                    return RBUF_ADD_ERROR;\n                }\n                else {\n                    DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");\n                    /* `pkt` released in IPHC */\n                    gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);\n                    /* check if entry was deleted in IPHC (error case) */\n                    if (gnrc_sixlowpan_frag_rb_entry_empty(entry.rbuf)) {\n                        res = RBUF_ADD_ERROR;\n                    }\n                    return res;\n                }\n            }\n            else if (data[0] == SIXLOWPAN_UNCOMP) {\n                DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");\n                data++;\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n                    /* only try minimal forwarding when fragment is the only\n                     * fragment in reassembly buffer yet */\n                    sixlowpan_frag_1_is(pkt->data) &&\n                    (entry.super->current_size == frag_size)) {\n                    gnrc_sixlowpan_frag_vrb_t *vrbe;\n                    gnrc_pktsnip_t tmp = {\n                        .data = data,\n                        .size = frag_size,\n                        .users = 1,\n                    };\n\n                    if (_check_hdr(&tmp, page) &&\n                        (vrbe = gnrc_sixlowpan_frag_vrb_from_route(\n                                    entry.super,\n                                    gnrc_netif_hdr_get_netif(netif_hdr),\n                                    &tmp))) {\n                        _adapt_hdr(&tmp, page);\n                        return _forward_uncomp(pkt, rbuf, vrbe, page);\n                    }\n                }\n                else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n                         sixlowpan_sfr_rfrag_is(pkt->data)) {\n                    entry.super->datagram_size--;\n                    /* Check, if fragment is still small enough to fit datagram size.\n                     * `offset` is 0, as this is the first fragment so it does not have to be added\n                     * here. */\n                    if (frag_size > entry.super->datagram_size) {\n                        DEBUG_PUTS(\n                           \"6lo rfrag: fragment too big for resulting datagram, \"\n                           \"discarding datagram\\n\"\n                        );\n                        gnrc_pktbuf_release(entry.rbuf->pkt);\n                        gnrc_pktbuf_release(pkt);\n                        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n                        return RBUF_ADD_ERROR;\n                    }\n                }\n            }\n        }\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||\n            IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {\n            /* all cases to try forwarding with minfwd or SFR above failed so\n             * just do normal reassembly. For the `minfwd` case however, we need\n             * to resize `entry.rbuf->pkt`, since we kept the packet allocation\n             * with fragment forwarding as minimal as possible in\n             * `_rbuf_get()` */\n            res = _rbuf_resize_for_reassembly(entry.rbuf);\n            if (res == RBUF_ADD_ERROR) {\n                gnrc_pktbuf_release(pkt);\n                return res;\n            }\n        }\n        memcpy(((uint8_t *)entry.rbuf->pkt->data) + offset, data,\n               frag_size);\n    }\n    else {\n        /* no space left in rbuf interval buffer*/\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        res = RBUF_ADD_ERROR;\n    }\n    /* no errors and not consumed => release packet */\n    gnrc_pktbuf_release(pkt);\n    return res;\n}",
  "abstract_func": "static int _rbuf_add(gnrc_netif_hdr_t *VAR_0, gnrc_pktsnip_t *VAR_1,\n                     size_t VAR_2, unsigned VAR_3)\n{\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *super;\n        gnrc_sixlowpan_frag_rb_t *rbuf;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } VAR_4;\n    const uint8_t *VAR_5 = gnrc_netif_hdr_get_src_addr(VAR_0);\n    const uint8_t *VAR_6 = gnrc_netif_hdr_get_dst_addr(VAR_0);\n    uint8_t *VAR_7 = NULL;\n    size_t VAR_8 = 0;   /* COMMENT_0 */\n    int VAR_9;\n    uint16_t VAR_10;\n    uint16_t VAR_11;\n\n    /* COMMENT_1 */\n    assert(_valid_offset(VAR_1, VAR_2));\n    if (IS_USED(VAR_12) && sixlowpan_frag_is(VAR_1->data)) {\n        VAR_7 = _6lo_frag_payload(VAR_1);\n        VAR_8 = _6lo_frag_size(VAR_1, VAR_2, VAR_7);\n        if (VAR_8 == 0) {\n            DEBUG(\"6lo rbuf: integer underflow detected.\\n\");\n            gnrc_pktbuf_release(VAR_1);\n            return VAR_13;\n        }\n        VAR_10 = sixlowpan_frag_datagram_size(VAR_1->data);\n        VAR_11 = sixlowpan_frag_datagram_tag(VAR_1->data);\n    }\n    else if (IS_USED(VAR_14) &&\n             sixlowpan_sfr_rfrag_is(VAR_1->data)) {\n        sixlowpan_sfr_rfrag_t *VAR_15 = VAR_1->data;\n\n        VAR_7 = _6lo_sfr_payload(VAR_1);\n        VAR_8 = _6lo_sfr_frag_size(VAR_1);\n        /* COMMENT_2 */\n                  \n        VAR_10 = _6lo_sfr_datagram_size(VAR_1, VAR_2);\n        VAR_11 = VAR_15->base.tag;\n    }\n    else {\n        /* COMMENT_4 */\n        assert(VAR_7 != NULL);\n        gnrc_pktbuf_release(VAR_1);\n        return VAR_13;\n    }\n\n    gnrc_sixlowpan_frag_rb_gc();\n    /* COMMENT_5 */\n                       \n    if (IS_USED(VAR_16) &&\n        (VAR_2 > 0) &&\n        sixlowpan_frag_n_is(VAR_1->data) &&\n        (VAR_4.vrb = gnrc_sixlowpan_frag_vrb_get(VAR_5, VAR_0->src_l2addr_len,\n                                                 VAR_11)) != NULL) {\n        DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");\n        switch (_check_fragments(VAR_4.super, VAR_8, VAR_2)) {\n            case VAR_17:\n                DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(VAR_4.vrb);\n                /* COMMENT_7 */\n                gnrc_pktbuf_release(VAR_1);\n                return VAR_13;\n            case VAR_18:\n                DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");\n                gnrc_pktbuf_release(VAR_1);\n                return VAR_19;\n            default:\n                break;\n        }\n        VAR_9 = VAR_13;\n        if (_rbuf_update_ints(VAR_4.super, VAR_2, VAR_8)) {\n            DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");\n            VAR_4.super->current_size += (uint16_t)VAR_8;\n            if (_forward_frag(VAR_1, sizeof(VAR_20), VAR_4.vrb,\n                              VAR_3) < 0) {\n                DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");\n                return VAR_13;\n            }\n            VAR_9 = VAR_19;\n        }\n        return VAR_9;\n    }\n    else if ((VAR_9 = _rbuf_get(VAR_5, VAR_0->src_l2addr_len,\n                              VAR_6, VAR_0->dst_l2addr_len,\n                              VAR_10, VAR_11, VAR_3)) < 0) {\n        DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");\n        gnrc_pktbuf_release(VAR_1);\n        return VAR_13;\n    }\n    VAR_4.rbuf = &VAR_21[VAR_9];\n#if IS_USED(VAR_14)\n    VAR_2 += VAR_4.rbuf->offset_diff;\n#endif  /* COMMENT_8 */\n    if ((VAR_2 + VAR_8) > VAR_4.super->datagram_size) {\n        DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");\n        gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n        gnrc_pktbuf_release(VAR_1);\n        gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n        return VAR_13;\n    }\n\n    switch (_check_fragments(VAR_4.super, VAR_8, VAR_2)) {\n        case VAR_17:\n            DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");\n            gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n            gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n            return VAR_17;\n        case VAR_18:\n            gnrc_pktbuf_release(VAR_1);\n            return VAR_9;\n        default:\n            break;\n    }\n\n    if (_rbuf_update_ints(VAR_4.super, VAR_2, VAR_8)) {\n        DEBUG(\"6lo rbuf: add fragment data\\n\");\n        VAR_4.super->current_size += (uint16_t)VAR_8;\n        if (VAR_2 == 0) {\n            if (IS_USED(VAR_22) &&\n                sixlowpan_iphc_is(VAR_7)) {\n                DEBUG(\"6lo rbuf: detected IPHC header.\\n\");\n                gnrc_pktsnip_t *VAR_23 = _mark_frag_hdr(VAR_1);\n\n                if (VAR_23 == NULL) {\n                    DEBUG(\"6lo rbuf: unable to mark fragment header. \"\n                          \"aborting reassembly.\\n\");\n                    gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n                    gnrc_pktbuf_release(VAR_1);\n                    gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n                    return VAR_13;\n                }\n                else {\n                    DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");\n                    /* COMMENT_9 */\n                    gnrc_sixlowpan_iphc_recv(VAR_1, VAR_4.rbuf, 0);\n                    /* COMMENT_10 */\n                    if (gnrc_sixlowpan_frag_rb_entry_empty(VAR_4.rbuf)) {\n                        VAR_9 = VAR_13;\n                    }\n                    return VAR_9;\n                }\n            }\n            else if (VAR_7[0] == VAR_24) {\n                DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");\n                VAR_7++;\n                if (IS_USED(VAR_16) &&\n                    /* COMMENT_11 */\n                                                           \n                    sixlowpan_frag_1_is(VAR_1->data) &&\n                    (VAR_4.super->current_size == VAR_8)) {\n                    gnrc_sixlowpan_frag_vrb_t *VAR_25;\n                    gnrc_pktsnip_t VAR_26 = {\n                        .data = VAR_7,\n                        .size = VAR_8,\n                        .users = 1,\n                    };\n\n                    if (_check_hdr(&VAR_26, VAR_3) &&\n                        (VAR_25 = gnrc_sixlowpan_frag_vrb_from_route(\n                                    VAR_4.super,\n                                    gnrc_netif_hdr_get_netif(VAR_0),\n                                    &VAR_26))) {\n                        _adapt_hdr(&VAR_26, VAR_3);\n                        return _forward_uncomp(VAR_1, VAR_21, VAR_25, VAR_3);\n                    }\n                }\n                else if (IS_USED(VAR_14) &&\n                         sixlowpan_sfr_rfrag_is(VAR_1->data)) {\n                    VAR_4.super->datagram_size--;\n                    /* COMMENT_13 */\n                                                                                                   \n                               \n                    if (VAR_8 > VAR_4.super->datagram_size) {\n                        DEBUG_PUTS(\n                           \"6lo rfrag: fragment too big for resulting datagram, \"\n                           \"discarding datagram\\n\"\n                        );\n                        gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n                        gnrc_pktbuf_release(VAR_1);\n                        gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n                        return VAR_13;\n                    }\n                }\n            }\n        }\n        if (IS_USED(VAR_16) ||\n            IS_USED(VAR_14)) {\n            /* COMMENT_16 */\n                                                                                \n                                                                               \n                                                                 \n                               \n            VAR_9 = _rbuf_resize_for_reassembly(VAR_4.rbuf);\n            if (VAR_9 == VAR_13) {\n                gnrc_pktbuf_release(VAR_1);\n                return VAR_9;\n            }\n        }\n        memcpy(((uint8_t *)VAR_4.rbuf->pkt->data) + VAR_2, VAR_7,\n               VAR_8);\n    }\n    else {\n        /* COMMENT_21 */\n        gnrc_pktbuf_release(VAR_4.rbuf->pkt);\n        gnrc_sixlowpan_frag_rb_remove(VAR_4.rbuf);\n        VAR_9 = VAR_13;\n    }\n    /* COMMENT_22 */\n    gnrc_pktbuf_release(VAR_1);\n    return VAR_9;\n}",
  "func_graph_path": "RIOT-OS/RIOT/1aeb90ee5555ae78b567a6365ae4ab71bfd1404b/gnrc_sixlowpan_frag_rb.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -168,6 +168,19 @@\n                 else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n                          sixlowpan_sfr_rfrag_is(pkt->data)) {\n                     entry.super->datagram_size--;\n+                    /* Check, if fragment is still small enough to fit datagram size.\n+                     * `offset` is 0, as this is the first fragment so it does not have to be added\n+                     * here. */\n+                    if (frag_size > entry.super->datagram_size) {\n+                        DEBUG_PUTS(\n+                           \"6lo rfrag: fragment too big for resulting datagram, \"\n+                           \"discarding datagram\\n\"\n+                        );\n+                        gnrc_pktbuf_release(entry.rbuf->pkt);\n+                        gnrc_pktbuf_release(pkt);\n+                        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n+                        return RBUF_ADD_ERROR;\n+                    }\n                 }\n             }\n         }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                    /* Check, if fragment is still small enough to fit datagram size.",
      "                     * `offset` is 0, as this is the first fragment so it does not have to be added",
      "                     * here. */",
      "                    if (frag_size > entry.super->datagram_size) {",
      "                        DEBUG_PUTS(",
      "                           \"6lo rfrag: fragment too big for resulting datagram, \"",
      "                           \"discarding datagram\\n\"",
      "                        );",
      "                        gnrc_pktbuf_release(entry.rbuf->pkt);",
      "                        gnrc_pktbuf_release(pkt);",
      "                        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);",
      "                        return RBUF_ADD_ERROR;",
      "                    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/19680",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/RIOT-OS/RIOT/pull/19680: 403 Client Error: Forbidden for url: https://api.github.com/repos/RIOT-OS/RIOT/pulls/19680",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis:** The message explicitly mentions \"fix OOB write,\" indicating a security fix.\n2. **Code Diff Evaluation:** The added code implements a check for fragment size to prevent overflow, a typical security measure.\n3. **Security Fix Confirmation:** The code addresses a buffer overflow vulnerability, which is a known security issue.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}