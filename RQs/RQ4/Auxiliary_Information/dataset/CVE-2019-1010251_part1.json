{
  "cve_id": "CVE-2019-1010251",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "teredo: be stricter on what to consider valid teredo\n\nInvalid Teredo can lead to valid DNS traffic (or other UDP traffic)\nbeing misdetected as Teredo. This leads to false negatives in the\nUDP payload inspection.\n\nMake the teredo code only consider a packet teredo if the encapsulated\ndata was decoded without any 'invalid' events being set.\n\nBug #2736.",
  "commit_hash": "11f3659f64a4e42e90cb3c09fcef66894205aefe",
  "git_url": "https://github.com/OISF/suricata/commit/11f3659f64a4e42e90cb3c09fcef66894205aefe",
  "file_path": "src/decode-ipv6.c",
  "func_name": "DecodeIPV6ExtHdrs",
  "func_before": "static void\nDecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    SCEnter();\n\n    uint8_t *orig_pkt = pkt;\n    uint8_t nh = 0; /* careful, 0 is actually a real type */\n    uint16_t hdrextlen = 0;\n    uint16_t plen;\n    char dstopts = 0;\n    char exthdr_fh_done = 0;\n    int hh = 0;\n    int rh = 0;\n    int eh = 0;\n    int ah = 0;\n\n    nh = IPV6_GET_NH(p);\n    plen = len;\n\n    while(1)\n    {\n        /* No upper layer, but we do have data. Suspicious. */\n        if (nh == IPPROTO_NONE && plen > 0) {\n            ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n            SCReturn;\n        }\n\n        if (plen < 2) { /* minimal needed in a hdr */\n            SCReturn;\n        }\n\n        switch(nh)\n        {\n            case IPPROTO_TCP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeTCP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_UDP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeUDP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ICMPV6:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_SCTP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeSCTP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ROUTING:\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n\n                SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (rh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_RH);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                rh = 1;\n                IPV6_EXTHDR_SET_RH(p);\n\n                uint8_t ip6rh_type = *(pkt + 2);\n                if (ip6rh_type == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_RH_TYPE_0);\n                }\n                p->ip6eh.rh_type = ip6rh_type;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n\n            case IPPROTO_HOPOPTS:\n            case IPPROTO_DSTOPTS:\n            {\n                IPV6OptHAO hao_s, *hao = &hao_s;\n                IPV6OptRA ra_s, *ra = &ra_s;\n                IPV6OptJumbo jumbo_s, *jumbo = &jumbo_s;\n                uint16_t optslen = 0;\n\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen =  (*(pkt+1) + 1) << 3;\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                uint8_t *ptr = pkt + 2; /* +2 to go past nxthdr and len */\n\n                /* point the pointers to right structures\n                 * in Packet. */\n                if (nh == IPPROTO_HOPOPTS) {\n                    if (hh) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_HH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n\n                    hh = 1;\n\n                    optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                }\n                else if (nh == IPPROTO_DSTOPTS)\n                {\n                    if (dstopts == 0) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 1;\n                    } else if (dstopts == 1) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 2;\n                    } else {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_DH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n                }\n\n                if (optslen > plen) {\n                    /* since the packet is long enough (we checked\n                     * plen against hdrlen, the optlen must be malformed. */\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n/** \\todo move into own function to loaded on demand */\n                uint16_t padn_cnt = 0;\n                uint16_t other_cnt = 0;\n                uint16_t offset = 0;\n                while(offset < optslen)\n                {\n                    if (*ptr == IPV6OPT_PAD1)\n                    {\n                        padn_cnt++;\n                        offset++;\n                        ptr++;\n                        continue;\n                    }\n\n                    if (offset + 1 >= optslen) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    /* length field for each opt */\n                    uint8_t ip6_optlen = *(ptr + 1);\n\n                    /* see if the optlen from the packet fits the total optslen */\n                    if ((offset + 1 + ip6_optlen) > optslen) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    if (*ptr == IPV6OPT_PADN) /* PadN */\n                    {\n                        //printf(\"PadN option\\n\");\n                        padn_cnt++;\n\n                        /* a zero padN len would be weird */\n                        if (ip6_optlen == 0)\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_ZERO_LEN_PADN);\n                    }\n                    else if (*ptr == IPV6OPT_RA) /* RA */\n                    {\n                        ra->ip6ra_type = *(ptr);\n                        ra->ip6ra_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));\n                        ra->ip6ra_value = SCNtohs(ra->ip6ra_value);\n                        //printf(\"RA option: type %\" PRIu32 \" len %\" PRIu32 \" value %\" PRIu32 \"\\n\",\n                        //    ra->ip6ra_type, ra->ip6ra_len, ra->ip6ra_value);\n                        other_cnt++;\n                    }\n                    else if (*ptr == IPV6OPT_JUMBO) /* Jumbo */\n                    {\n                        jumbo->ip6j_type = *(ptr);\n                        jumbo->ip6j_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&jumbo->ip6j_payload_len, (ptr+2), sizeof(jumbo->ip6j_payload_len));\n                        jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);\n                        //printf(\"Jumbo option: type %\" PRIu32 \" len %\" PRIu32 \" payload len %\" PRIu32 \"\\n\",\n                        //    jumbo->ip6j_type, jumbo->ip6j_len, jumbo->ip6j_payload_len);\n                    }\n                    else if (*ptr == IPV6OPT_HAO) /* HAO */\n                    {\n                        hao->ip6hao_type = *(ptr);\n                        hao->ip6hao_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&hao->ip6hao_hoa, (ptr+2), sizeof(hao->ip6hao_hoa));\n                        //printf(\"HAO option: type %\" PRIu32 \" len %\" PRIu32 \" \",\n                        //    hao->ip6hao_type, hao->ip6hao_len);\n                        //char addr_buf[46];\n                        //PrintInet(AF_INET6, (char *)&(hao->ip6hao_hoa),\n                        //    addr_buf,sizeof(addr_buf));\n                        //printf(\"home addr %s\\n\", addr_buf);\n                        other_cnt++;\n                    } else {\n                        if (nh == IPPROTO_HOPOPTS)\n                            ENGINE_SET_EVENT(p, IPV6_HOPOPTS_UNKNOWN_OPT);\n                        else\n                            ENGINE_SET_EVENT(p, IPV6_DSTOPTS_UNKNOWN_OPT);\n\n                        other_cnt++;\n                    }\n                    uint16_t optlen = (*(ptr + 1) + 2);\n                    ptr += optlen; /* +2 for opt type and opt len fields */\n                    offset += optlen;\n                }\n                /* flag packets that have only padding */\n                if (padn_cnt > 0 && other_cnt == 0) {\n                    if (nh == IPPROTO_HOPOPTS)\n                        ENGINE_SET_EVENT(p, IPV6_HOPOPTS_ONLY_PADDING);\n                    else\n                        ENGINE_SET_EVENT(p, IPV6_DSTOPTS_ONLY_PADDING);\n                }\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n\n            case IPPROTO_FRAGMENT:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* store the offset of this extension into the packet\n                 * past the ipv6 header. We use it in defrag for creating\n                 * a defragmented packet without the frag header */\n                if (exthdr_fh_done == 0) {\n                    p->ip6eh.fh_offset = pkt - orig_pkt;\n                    exthdr_fh_done = 1;\n                }\n\n                uint16_t prev_hdrextlen = hdrextlen;\n                hdrextlen = sizeof(IPV6FragHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                /* for the frag header, the length field is reserved */\n                if (*(pkt + 1) != 0) {\n                    ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);\n                    /* non fatal, lets try to continue */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(p)) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* set the header flag first */\n                IPV6_EXTHDR_SET_FH(p);\n\n                /* parse the header and setup the vars */\n                DecodeIPV6FragHeader(p, pkt, hdrextlen, plen, prev_hdrextlen);\n\n                /* if FH has offset 0 and no more fragments are coming, we\n                 * parse this packet further right away, no defrag will be\n                 * needed. It is a useless FH then though, so we do set an\n                 * decoder event. */\n                if (p->ip6eh.fh_more_frags_set == 0 && p->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_USELESS_FH);\n\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* the rest is parsed upon reassembly */\n                p->flags |= PKT_IS_FRAGMENT;\n                SCReturn;\n            }\n            case IPPROTO_ESP:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = sizeof(IPV6EspHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (eh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_EH);\n                    SCReturn;\n                }\n\n                eh = 1;\n\n                nh = IPPROTO_NONE;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_AH:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* we need the header as a minimum */\n                hdrextlen = sizeof(IPV6AuthHdr);\n                /* the payload len field is the number of extra 4 byte fields,\n                 * IPV6AuthHdr already contains the first */\n                if (*(pkt+1) > 0)\n                    hdrextlen += ((*(pkt+1) - 1) * 4);\n\n                SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;\n                if (ahhdr->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);\n                }\n\n                if (ah) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                ah = 1;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_IPIP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n            /* none, last header */\n            case IPPROTO_NONE:\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n            case IPPROTO_ICMP:\n                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);\n                SCReturn;\n            /* no parsing yet, just skip it */\n            case IPPROTO_MH:\n            case IPPROTO_HIP:\n            case IPPROTO_SHIM6:\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            default:\n                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n        }\n    }\n\n    SCReturn;\n}",
  "abstract_func_before": "static void\nDecodeIPV6ExtHdrs(ThreadVars *VAR_0, DecodeThreadVars *VAR_1, Packet *VAR_2, uint8_t *VAR_3, uint16_t VAR_4, PacketQueue *VAR_5)\n{\n    SCEnter();\n\n    uint8_t *VAR_6 = VAR_3;\n    uint8_t VAR_7 = 0; /* COMMENT_0 */\n    uint16_t VAR_8 = 0;\n    uint16_t VAR_9;\n    char VAR_10 = 0;\n    char VAR_11 = 0;\n    int VAR_12 = 0;\n    int VAR_13 = 0;\n    int VAR_14 = 0;\n    int VAR_15 = 0;\n\n    VAR_7 = IPV6_GET_NH(VAR_2);\n    VAR_9 = VAR_4;\n\n    while(1)\n    {\n        /* COMMENT_1 */\n        if (VAR_7 == VAR_16 && VAR_9 > 0) {\n            ENGINE_SET_EVENT(VAR_2, VAR_17);\n            VAR_18;\n        }\n\n        if (VAR_9 < 2) { /* COMMENT_2 */\n            VAR_18;\n        }\n\n        switch(VAR_7)\n        {\n            case VAR_19:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeTCP(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_20:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeUDP(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_21:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeICMPV6(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_22:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeSCTP(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_23:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_8 = 8 + (*(VAR_3+1) * 8);  /* COMMENT_3 */\n\n                SCLogDebug(\"hdrextlen %\"VAR_24, VAR_8);\n\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_25);\n                    VAR_18;\n                }\n\n                if (VAR_13) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_26);\n                    /* COMMENT_4 */\n                                       \n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                VAR_13 = 1;\n                IPV6_EXTHDR_SET_RH(VAR_2);\n\n                uint8_t VAR_27 = *(VAR_3 + 2);\n                if (VAR_27 == 0) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_28);\n                }\n                VAR_2->ip6eh.rh_type = VAR_27;\n\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n\n            case VAR_29:\n            case VAR_30:\n            {\n                IPV6OptHAO VAR_31, *VAR_32 = &VAR_31;\n                IPV6OptRA VAR_33, *VAR_34 = &VAR_33;\n                IPV6OptJumbo VAR_35, *VAR_36 = &VAR_35;\n                uint16_t VAR_37 = 0;\n\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_8 =  (*(VAR_3+1) + 1) << 3;\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_25);\n                    VAR_18;\n                }\n\n                uint8_t *VAR_38 = VAR_3 + 2; /* COMMENT_6 */\n\n                /* COMMENT_7 */\n                                \n                if (VAR_7 == VAR_29) {\n                    if (VAR_12) {\n                        ENGINE_SET_EVENT(VAR_2, VAR_39);\n                        /* COMMENT_9 */\n                                           \n                        VAR_7 = *VAR_3;\n                        VAR_3 += VAR_8;\n                        VAR_9 -= VAR_8;\n                        break;\n                    }\n\n                    VAR_12 = 1;\n\n                    VAR_37 = ((*(VAR_3 + 1) + 1 ) << 3) - 2;\n                }\n                else if (VAR_7 == VAR_30)\n                {\n                    if (VAR_10 == 0) {\n                        VAR_37 = ((*(VAR_3 + 1) + 1 ) << 3) - 2;\n                        VAR_10 = 1;\n                    } else if (VAR_10 == 1) {\n                        VAR_37 = ((*(VAR_3 + 1) + 1 ) << 3) - 2;\n                        VAR_10 = 2;\n                    } else {\n                        ENGINE_SET_EVENT(VAR_2, VAR_40);\n                        /* COMMENT_11 */\n                                           \n                        VAR_7 = *VAR_3;\n                        VAR_3 += VAR_8;\n                        VAR_9 -= VAR_8;\n                        break;\n                    }\n                }\n\n                if (VAR_37 > VAR_9) {\n                    /* COMMENT_13 */\n                                                                            \n                    ENGINE_SET_EVENT(VAR_2, VAR_41);\n                    /* COMMENT_15 */\n                                       \n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n/* COMMENT_17 */\n                uint16_t VAR_42 = 0;\n                uint16_t VAR_43 = 0;\n                uint16_t VAR_44 = 0;\n                while(VAR_44 < VAR_37)\n                {\n                    if (*VAR_38 == VAR_45)\n                    {\n                        VAR_42++;\n                        VAR_44++;\n                        VAR_38++;\n                        continue;\n                    }\n\n                    if (VAR_44 + 1 >= VAR_37) {\n                        ENGINE_SET_EVENT(VAR_2, VAR_41);\n                        break;\n                    }\n\n                    /* COMMENT_18 */\n                    uint8_t VAR_46 = *(VAR_38 + 1);\n\n                    /* COMMENT_19 */\n                    if ((VAR_44 + 1 + VAR_46) > VAR_37) {\n                        ENGINE_SET_EVENT(VAR_2, VAR_41);\n                        break;\n                    }\n\n                    if (*VAR_38 == VAR_47) /* COMMENT_20 */\n                    {\n                        /* COMMENT_21 */\n                        VAR_42++;\n\n                        /* COMMENT_22 */\n                        if (VAR_46 == 0)\n                            ENGINE_SET_EVENT(VAR_2, VAR_48);\n                    }\n                    else if (*VAR_38 == VAR_49) /* COMMENT_23 */\n                    {\n                        VAR_34->ip6ra_type = *(VAR_38);\n                        VAR_34->ip6ra_len  = VAR_46;\n\n                        if (VAR_46 < sizeof(VAR_34->ip6ra_value)) {\n                            ENGINE_SET_EVENT(VAR_2, VAR_41);\n                            break;\n                        }\n\n                        memcpy(&VAR_34->ip6ra_value, (VAR_38 + 2), sizeof(VAR_34->ip6ra_value));\n                        VAR_34->ip6ra_value = SCNtohs(VAR_34->ip6ra_value);\n                        /* COMMENT_24 */\n                        /* COMMENT_25 */\n                        VAR_43++;\n                    }\n                    else if (*VAR_38 == VAR_50) /* COMMENT_26 */\n                    {\n                        VAR_36->ip6j_type = *(VAR_38);\n                        VAR_36->ip6j_len  = VAR_46;\n\n                        if (VAR_46 < sizeof(VAR_36->ip6j_payload_len)) {\n                            ENGINE_SET_EVENT(VAR_2, VAR_41);\n                            break;\n                        }\n\n                        memcpy(&VAR_36->ip6j_payload_len, (VAR_38+2), sizeof(VAR_36->ip6j_payload_len));\n                        VAR_36->ip6j_payload_len = SCNtohl(VAR_36->ip6j_payload_len);\n                        /* COMMENT_27 */\n                        /* COMMENT_28 */\n                    }\n                    else if (*VAR_38 == VAR_51) /* COMMENT_29 */\n                    {\n                        VAR_32->ip6hao_type = *(VAR_38);\n                        VAR_32->ip6hao_len  = VAR_46;\n\n                        if (VAR_46 < sizeof(VAR_32->ip6hao_hoa)) {\n                            ENGINE_SET_EVENT(VAR_2, VAR_41);\n                            break;\n                        }\n\n                        memcpy(&VAR_32->ip6hao_hoa, (VAR_38+2), sizeof(VAR_32->ip6hao_hoa));\n                        /* COMMENT_30 */\n                        /* COMMENT_31 */\n                        /* COMMENT_32 */\n                        /* COMMENT_33 */\n                        /* COMMENT_34 */\n                        /* COMMENT_35 */\n                        VAR_43++;\n                    } else {\n                        if (VAR_7 == VAR_29)\n                            ENGINE_SET_EVENT(VAR_2, VAR_52);\n                        else\n                            ENGINE_SET_EVENT(VAR_2, VAR_53);\n\n                        VAR_43++;\n                    }\n                    uint16_t VAR_54 = (*(VAR_38 + 1) + 2);\n                    VAR_38 += VAR_54; /* COMMENT_36 */\n                    VAR_44 += VAR_54;\n                }\n                /* COMMENT_37 */\n                if (VAR_42 > 0 && VAR_43 == 0) {\n                    if (VAR_7 == VAR_29)\n                        ENGINE_SET_EVENT(VAR_2, VAR_55);\n                    else\n                        ENGINE_SET_EVENT(VAR_2, VAR_56);\n                }\n\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            }\n\n            case VAR_57:\n            {\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                /* COMMENT_38 */\n                                                                         \n                                                                   \n                if (VAR_11 == 0) {\n                    VAR_2->ip6eh.fh_offset = VAR_3 - VAR_6;\n                    VAR_11 = 1;\n                }\n\n                uint16_t VAR_58 = VAR_8;\n                VAR_8 = sizeof(VAR_59);\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_25);\n                    VAR_18;\n                }\n\n                /* COMMENT_41 */\n                if (*(VAR_3 + 1) != 0) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_60);\n                    /* COMMENT_42 */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(VAR_2)) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_61);\n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                /* COMMENT_43 */\n                IPV6_EXTHDR_SET_FH(VAR_2);\n\n                /* COMMENT_44 */\n                DecodeIPV6FragHeader(VAR_2, VAR_3, VAR_8, VAR_9, VAR_58);\n\n                /* COMMENT_45 */\n                                                                          \n                                                                          \n                                    \n                if (VAR_2->ip6eh.fh_more_frags_set == 0 && VAR_2->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_62);\n\n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                /* COMMENT_49 */\n                VAR_2->flags |= VAR_63;\n                VAR_18;\n            }\n            case VAR_64:\n            {\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_8 = sizeof(VAR_65);\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_25);\n                    VAR_18;\n                }\n\n                if (VAR_14) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_66);\n                    VAR_18;\n                }\n\n                VAR_14 = 1;\n\n                VAR_7 = VAR_16;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            }\n            case VAR_67:\n            {\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                /* COMMENT_50 */\n                VAR_8 = sizeof(VAR_68);\n                /* COMMENT_51 */\n                                                            \n                if (*(VAR_3+1) > 0)\n                    VAR_8 += ((*(VAR_3+1) - 1) * 4);\n\n                SCLogDebug(\"hdrextlen %\"VAR_24, VAR_8);\n\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_25);\n                    VAR_18;\n                }\n\n                IPV6AuthHdr *VAR_69 = (IPV6AuthHdr *)VAR_3;\n                if (VAR_69->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_70);\n                }\n\n                if (VAR_15) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_71);\n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                VAR_15 = 1;\n\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            }\n            case VAR_72:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeIPv4inIPv6(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n            /* COMMENT_53 */\n            case VAR_16:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_18;\n            case VAR_73:\n                ENGINE_SET_EVENT(VAR_2,VAR_74);\n                VAR_18;\n            /* COMMENT_54 */\n            case VAR_75:\n            case VAR_76:\n            case VAR_77:\n                VAR_8 = 8 + (*(VAR_3+1) * 8);  /* COMMENT_3 */\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_25);\n                    VAR_18;\n                }\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            default:\n                ENGINE_SET_EVENT(VAR_2, VAR_78);\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_18;\n        }\n    }\n\n    VAR_18;\n}",
  "func_graph_path_before": "OISF/suricata/11f3659f64a4e42e90cb3c09fcef66894205aefe/decode-ipv6.c/vul/before/0.json",
  "func": "static void\nDecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    SCEnter();\n\n    uint8_t *orig_pkt = pkt;\n    uint8_t nh = IPV6_GET_NH(p); /* careful, 0 is actually a real type */\n    uint16_t hdrextlen = 0;\n    uint16_t plen = len;\n    char dstopts = 0;\n    char exthdr_fh_done = 0;\n    int hh = 0;\n    int rh = 0;\n    int eh = 0;\n    int ah = 0;\n\n    while(1)\n    {\n        if (nh == IPPROTO_NONE) {\n            if (plen > 0) {\n                /* No upper layer, but we do have data. Suspicious. */\n                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n            }\n            SCReturn;\n        }\n\n        if (plen < 2) { /* minimal needed in a hdr */\n            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n            SCReturn;\n        }\n\n        switch(nh)\n        {\n            case IPPROTO_TCP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeTCP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_UDP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeUDP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ICMPV6:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_SCTP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeSCTP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ROUTING:\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n\n                SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (rh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_RH);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                rh = 1;\n                IPV6_EXTHDR_SET_RH(p);\n\n                uint8_t ip6rh_type = *(pkt + 2);\n                if (ip6rh_type == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_RH_TYPE_0);\n                }\n                p->ip6eh.rh_type = ip6rh_type;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n\n            case IPPROTO_HOPOPTS:\n            case IPPROTO_DSTOPTS:\n            {\n                IPV6OptHAO hao_s, *hao = &hao_s;\n                IPV6OptRA ra_s, *ra = &ra_s;\n                IPV6OptJumbo jumbo_s, *jumbo = &jumbo_s;\n                uint16_t optslen = 0;\n\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen =  (*(pkt+1) + 1) << 3;\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                uint8_t *ptr = pkt + 2; /* +2 to go past nxthdr and len */\n\n                /* point the pointers to right structures\n                 * in Packet. */\n                if (nh == IPPROTO_HOPOPTS) {\n                    if (hh) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_HH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n\n                    hh = 1;\n\n                    optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                }\n                else if (nh == IPPROTO_DSTOPTS)\n                {\n                    if (dstopts == 0) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 1;\n                    } else if (dstopts == 1) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 2;\n                    } else {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_DH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n                }\n\n                if (optslen > plen) {\n                    /* since the packet is long enough (we checked\n                     * plen against hdrlen, the optlen must be malformed. */\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n/** \\todo move into own function to loaded on demand */\n                uint16_t padn_cnt = 0;\n                uint16_t other_cnt = 0;\n                uint16_t offset = 0;\n                while(offset < optslen)\n                {\n                    if (*ptr == IPV6OPT_PAD1)\n                    {\n                        padn_cnt++;\n                        offset++;\n                        ptr++;\n                        continue;\n                    }\n\n                    if (offset + 1 >= optslen) {\n                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    /* length field for each opt */\n                    uint8_t ip6_optlen = *(ptr + 1);\n\n                    /* see if the optlen from the packet fits the total optslen */\n                    if ((offset + 1 + ip6_optlen) > optslen) {\n                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    if (*ptr == IPV6OPT_PADN) /* PadN */\n                    {\n                        //printf(\"PadN option\\n\");\n                        padn_cnt++;\n\n                        /* a zero padN len would be weird */\n                        if (ip6_optlen == 0)\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_ZERO_LEN_PADN);\n                    }\n                    else if (*ptr == IPV6OPT_RA) /* RA */\n                    {\n                        ra->ip6ra_type = *(ptr);\n                        ra->ip6ra_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));\n                        ra->ip6ra_value = SCNtohs(ra->ip6ra_value);\n                        //printf(\"RA option: type %\" PRIu32 \" len %\" PRIu32 \" value %\" PRIu32 \"\\n\",\n                        //    ra->ip6ra_type, ra->ip6ra_len, ra->ip6ra_value);\n                        other_cnt++;\n                    }\n                    else if (*ptr == IPV6OPT_JUMBO) /* Jumbo */\n                    {\n                        jumbo->ip6j_type = *(ptr);\n                        jumbo->ip6j_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&jumbo->ip6j_payload_len, (ptr+2), sizeof(jumbo->ip6j_payload_len));\n                        jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);\n                        //printf(\"Jumbo option: type %\" PRIu32 \" len %\" PRIu32 \" payload len %\" PRIu32 \"\\n\",\n                        //    jumbo->ip6j_type, jumbo->ip6j_len, jumbo->ip6j_payload_len);\n                    }\n                    else if (*ptr == IPV6OPT_HAO) /* HAO */\n                    {\n                        hao->ip6hao_type = *(ptr);\n                        hao->ip6hao_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&hao->ip6hao_hoa, (ptr+2), sizeof(hao->ip6hao_hoa));\n                        //printf(\"HAO option: type %\" PRIu32 \" len %\" PRIu32 \" \",\n                        //    hao->ip6hao_type, hao->ip6hao_len);\n                        //char addr_buf[46];\n                        //PrintInet(AF_INET6, (char *)&(hao->ip6hao_hoa),\n                        //    addr_buf,sizeof(addr_buf));\n                        //printf(\"home addr %s\\n\", addr_buf);\n                        other_cnt++;\n                    } else {\n                        if (nh == IPPROTO_HOPOPTS)\n                            ENGINE_SET_EVENT(p, IPV6_HOPOPTS_UNKNOWN_OPT);\n                        else\n                            ENGINE_SET_EVENT(p, IPV6_DSTOPTS_UNKNOWN_OPT);\n\n                        other_cnt++;\n                    }\n                    uint16_t optlen = (*(ptr + 1) + 2);\n                    ptr += optlen; /* +2 for opt type and opt len fields */\n                    offset += optlen;\n                }\n                /* flag packets that have only padding */\n                if (padn_cnt > 0 && other_cnt == 0) {\n                    if (nh == IPPROTO_HOPOPTS)\n                        ENGINE_SET_EVENT(p, IPV6_HOPOPTS_ONLY_PADDING);\n                    else\n                        ENGINE_SET_EVENT(p, IPV6_DSTOPTS_ONLY_PADDING);\n                }\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n\n            case IPPROTO_FRAGMENT:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* store the offset of this extension into the packet\n                 * past the ipv6 header. We use it in defrag for creating\n                 * a defragmented packet without the frag header */\n                if (exthdr_fh_done == 0) {\n                    p->ip6eh.fh_offset = pkt - orig_pkt;\n                    exthdr_fh_done = 1;\n                }\n\n                uint16_t prev_hdrextlen = hdrextlen;\n                hdrextlen = sizeof(IPV6FragHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                /* for the frag header, the length field is reserved */\n                if (*(pkt + 1) != 0) {\n                    ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);\n                    /* non fatal, lets try to continue */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(p)) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* set the header flag first */\n                IPV6_EXTHDR_SET_FH(p);\n\n                /* parse the header and setup the vars */\n                DecodeIPV6FragHeader(p, pkt, hdrextlen, plen, prev_hdrextlen);\n\n                /* if FH has offset 0 and no more fragments are coming, we\n                 * parse this packet further right away, no defrag will be\n                 * needed. It is a useless FH then though, so we do set an\n                 * decoder event. */\n                if (p->ip6eh.fh_more_frags_set == 0 && p->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_USELESS_FH);\n\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* the rest is parsed upon reassembly */\n                p->flags |= PKT_IS_FRAGMENT;\n                SCReturn;\n            }\n            case IPPROTO_ESP:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = sizeof(IPV6EspHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (eh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_EH);\n                    SCReturn;\n                }\n\n                eh = 1;\n\n                nh = IPPROTO_NONE;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_AH:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* we need the header as a minimum */\n                hdrextlen = sizeof(IPV6AuthHdr);\n                /* the payload len field is the number of extra 4 byte fields,\n                 * IPV6AuthHdr already contains the first */\n                if (*(pkt+1) > 0)\n                    hdrextlen += ((*(pkt+1) - 1) * 4);\n\n                SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;\n                if (ahhdr->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);\n                }\n\n                if (ah) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                ah = 1;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_IPIP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n            /* none, last header */\n            case IPPROTO_NONE:\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n            case IPPROTO_ICMP:\n                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);\n                SCReturn;\n            /* no parsing yet, just skip it */\n            case IPPROTO_MH:\n            case IPPROTO_HIP:\n            case IPPROTO_SHIM6:\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            default:\n                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n        }\n    }\n\n    SCReturn;\n}",
  "abstract_func": "static void\nDecodeIPV6ExtHdrs(ThreadVars *VAR_0, DecodeThreadVars *VAR_1, Packet *VAR_2, uint8_t *VAR_3, uint16_t VAR_4, PacketQueue *VAR_5)\n{\n    SCEnter();\n\n    uint8_t *VAR_6 = VAR_3;\n    uint8_t VAR_7 = IPV6_GET_NH(VAR_2); /* COMMENT_0 */\n    uint16_t VAR_8 = 0;\n    uint16_t VAR_9 = VAR_4;\n    char VAR_10 = 0;\n    char VAR_11 = 0;\n    int VAR_12 = 0;\n    int VAR_13 = 0;\n    int VAR_14 = 0;\n    int VAR_15 = 0;\n\n    while(1)\n    {\n        if (VAR_7 == VAR_16) {\n            if (VAR_9 > 0) {\n                /* COMMENT_1 */\n                ENGINE_SET_EVENT(VAR_2, VAR_17);\n            }\n            VAR_18;\n        }\n\n        if (VAR_9 < 2) { /* COMMENT_2 */\n            ENGINE_SET_INVALID_EVENT(VAR_2, VAR_19);\n            VAR_18;\n        }\n\n        switch(VAR_7)\n        {\n            case VAR_20:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeTCP(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_21:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeUDP(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_22:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeICMPV6(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_23:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeSCTP(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n\n            case VAR_24:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_8 = 8 + (*(VAR_3+1) * 8);  /* COMMENT_3 */\n\n                SCLogDebug(\"hdrextlen %\"VAR_25, VAR_8);\n\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_INVALID_EVENT(VAR_2, VAR_19);\n                    VAR_18;\n                }\n\n                if (VAR_13) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_26);\n                    /* COMMENT_4 */\n                                       \n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                VAR_13 = 1;\n                IPV6_EXTHDR_SET_RH(VAR_2);\n\n                uint8_t VAR_27 = *(VAR_3 + 2);\n                if (VAR_27 == 0) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_28);\n                }\n                VAR_2->ip6eh.rh_type = VAR_27;\n\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n\n            case VAR_29:\n            case VAR_30:\n            {\n                IPV6OptHAO VAR_31, *VAR_32 = &VAR_31;\n                IPV6OptRA VAR_33, *VAR_34 = &VAR_33;\n                IPV6OptJumbo VAR_35, *VAR_36 = &VAR_35;\n                uint16_t VAR_37 = 0;\n\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_8 =  (*(VAR_3+1) + 1) << 3;\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_INVALID_EVENT(VAR_2, VAR_19);\n                    VAR_18;\n                }\n\n                uint8_t *VAR_38 = VAR_3 + 2; /* COMMENT_6 */\n\n                /* COMMENT_7 */\n                                \n                if (VAR_7 == VAR_29) {\n                    if (VAR_12) {\n                        ENGINE_SET_EVENT(VAR_2, VAR_39);\n                        /* COMMENT_9 */\n                                           \n                        VAR_7 = *VAR_3;\n                        VAR_3 += VAR_8;\n                        VAR_9 -= VAR_8;\n                        break;\n                    }\n\n                    VAR_12 = 1;\n\n                    VAR_37 = ((*(VAR_3 + 1) + 1 ) << 3) - 2;\n                }\n                else if (VAR_7 == VAR_30)\n                {\n                    if (VAR_10 == 0) {\n                        VAR_37 = ((*(VAR_3 + 1) + 1 ) << 3) - 2;\n                        VAR_10 = 1;\n                    } else if (VAR_10 == 1) {\n                        VAR_37 = ((*(VAR_3 + 1) + 1 ) << 3) - 2;\n                        VAR_10 = 2;\n                    } else {\n                        ENGINE_SET_EVENT(VAR_2, VAR_40);\n                        /* COMMENT_11 */\n                                           \n                        VAR_7 = *VAR_3;\n                        VAR_3 += VAR_8;\n                        VAR_9 -= VAR_8;\n                        break;\n                    }\n                }\n\n                if (VAR_37 > VAR_9) {\n                    /* COMMENT_13 */\n                                                                            \n                    ENGINE_SET_INVALID_EVENT(VAR_2, VAR_41);\n                    /* COMMENT_15 */\n                                       \n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n/* COMMENT_17 */\n                uint16_t VAR_42 = 0;\n                uint16_t VAR_43 = 0;\n                uint16_t VAR_44 = 0;\n                while(VAR_44 < VAR_37)\n                {\n                    if (*VAR_38 == VAR_45)\n                    {\n                        VAR_42++;\n                        VAR_44++;\n                        VAR_38++;\n                        continue;\n                    }\n\n                    if (VAR_44 + 1 >= VAR_37) {\n                        ENGINE_SET_INVALID_EVENT(VAR_2, VAR_41);\n                        break;\n                    }\n\n                    /* COMMENT_18 */\n                    uint8_t VAR_46 = *(VAR_38 + 1);\n\n                    /* COMMENT_19 */\n                    if ((VAR_44 + 1 + VAR_46) > VAR_37) {\n                        ENGINE_SET_INVALID_EVENT(VAR_2, VAR_41);\n                        break;\n                    }\n\n                    if (*VAR_38 == VAR_47) /* COMMENT_20 */\n                    {\n                        /* COMMENT_21 */\n                        VAR_42++;\n\n                        /* COMMENT_22 */\n                        if (VAR_46 == 0)\n                            ENGINE_SET_EVENT(VAR_2, VAR_48);\n                    }\n                    else if (*VAR_38 == VAR_49) /* COMMENT_23 */\n                    {\n                        VAR_34->ip6ra_type = *(VAR_38);\n                        VAR_34->ip6ra_len  = VAR_46;\n\n                        if (VAR_46 < sizeof(VAR_34->ip6ra_value)) {\n                            ENGINE_SET_INVALID_EVENT(VAR_2, VAR_41);\n                            break;\n                        }\n\n                        memcpy(&VAR_34->ip6ra_value, (VAR_38 + 2), sizeof(VAR_34->ip6ra_value));\n                        VAR_34->ip6ra_value = SCNtohs(VAR_34->ip6ra_value);\n                        /* COMMENT_24 */\n                        /* COMMENT_25 */\n                        VAR_43++;\n                    }\n                    else if (*VAR_38 == VAR_50) /* COMMENT_26 */\n                    {\n                        VAR_36->ip6j_type = *(VAR_38);\n                        VAR_36->ip6j_len  = VAR_46;\n\n                        if (VAR_46 < sizeof(VAR_36->ip6j_payload_len)) {\n                            ENGINE_SET_INVALID_EVENT(VAR_2, VAR_41);\n                            break;\n                        }\n\n                        memcpy(&VAR_36->ip6j_payload_len, (VAR_38+2), sizeof(VAR_36->ip6j_payload_len));\n                        VAR_36->ip6j_payload_len = SCNtohl(VAR_36->ip6j_payload_len);\n                        /* COMMENT_27 */\n                        /* COMMENT_28 */\n                    }\n                    else if (*VAR_38 == VAR_51) /* COMMENT_29 */\n                    {\n                        VAR_32->ip6hao_type = *(VAR_38);\n                        VAR_32->ip6hao_len  = VAR_46;\n\n                        if (VAR_46 < sizeof(VAR_32->ip6hao_hoa)) {\n                            ENGINE_SET_INVALID_EVENT(VAR_2, VAR_41);\n                            break;\n                        }\n\n                        memcpy(&VAR_32->ip6hao_hoa, (VAR_38+2), sizeof(VAR_32->ip6hao_hoa));\n                        /* COMMENT_30 */\n                        /* COMMENT_31 */\n                        /* COMMENT_32 */\n                        /* COMMENT_33 */\n                        /* COMMENT_34 */\n                        /* COMMENT_35 */\n                        VAR_43++;\n                    } else {\n                        if (VAR_7 == VAR_29)\n                            ENGINE_SET_EVENT(VAR_2, VAR_52);\n                        else\n                            ENGINE_SET_EVENT(VAR_2, VAR_53);\n\n                        VAR_43++;\n                    }\n                    uint16_t VAR_54 = (*(VAR_38 + 1) + 2);\n                    VAR_38 += VAR_54; /* COMMENT_36 */\n                    VAR_44 += VAR_54;\n                }\n                /* COMMENT_37 */\n                if (VAR_42 > 0 && VAR_43 == 0) {\n                    if (VAR_7 == VAR_29)\n                        ENGINE_SET_EVENT(VAR_2, VAR_55);\n                    else\n                        ENGINE_SET_EVENT(VAR_2, VAR_56);\n                }\n\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            }\n\n            case VAR_57:\n            {\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                /* COMMENT_38 */\n                                                                         \n                                                                   \n                if (VAR_11 == 0) {\n                    VAR_2->ip6eh.fh_offset = VAR_3 - VAR_6;\n                    VAR_11 = 1;\n                }\n\n                uint16_t VAR_58 = VAR_8;\n                VAR_8 = sizeof(VAR_59);\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_INVALID_EVENT(VAR_2, VAR_19);\n                    VAR_18;\n                }\n\n                /* COMMENT_41 */\n                if (*(VAR_3 + 1) != 0) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_60);\n                    /* COMMENT_42 */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(VAR_2)) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_61);\n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                /* COMMENT_43 */\n                IPV6_EXTHDR_SET_FH(VAR_2);\n\n                /* COMMENT_44 */\n                DecodeIPV6FragHeader(VAR_2, VAR_3, VAR_8, VAR_9, VAR_58);\n\n                /* COMMENT_45 */\n                                                                          \n                                                                          \n                                    \n                if (VAR_2->ip6eh.fh_more_frags_set == 0 && VAR_2->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_62);\n\n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                /* COMMENT_49 */\n                VAR_2->flags |= VAR_63;\n                VAR_18;\n            }\n            case VAR_64:\n            {\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_8 = sizeof(VAR_65);\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_INVALID_EVENT(VAR_2, VAR_19);\n                    VAR_18;\n                }\n\n                if (VAR_14) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_66);\n                    VAR_18;\n                }\n\n                VAR_14 = 1;\n\n                VAR_7 = VAR_16;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            }\n            case VAR_67:\n            {\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                /* COMMENT_50 */\n                VAR_8 = sizeof(VAR_68);\n                /* COMMENT_51 */\n                                                            \n                if (*(VAR_3+1) > 0)\n                    VAR_8 += ((*(VAR_3+1) - 1) * 4);\n\n                SCLogDebug(\"hdrextlen %\"VAR_25, VAR_8);\n\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_INVALID_EVENT(VAR_2, VAR_19);\n                    VAR_18;\n                }\n\n                IPV6AuthHdr *VAR_69 = (IPV6AuthHdr *)VAR_3;\n                if (VAR_69->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_70);\n                }\n\n                if (VAR_15) {\n                    ENGINE_SET_EVENT(VAR_2, VAR_71);\n                    VAR_7 = *VAR_3;\n                    VAR_3 += VAR_8;\n                    VAR_9 -= VAR_8;\n                    break;\n                }\n\n                VAR_15 = 1;\n\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            }\n            case VAR_72:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                DecodeIPv4inIPv6(VAR_0, VAR_1, VAR_2, VAR_3, VAR_9, VAR_5);\n                VAR_18;\n            /* COMMENT_53 */\n            case VAR_16:\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_18;\n            case VAR_73:\n                ENGINE_SET_EVENT(VAR_2,VAR_74);\n                VAR_18;\n            /* COMMENT_54 */\n            case VAR_75:\n            case VAR_76:\n            case VAR_77:\n                VAR_8 = 8 + (*(VAR_3+1) * 8);  /* COMMENT_3 */\n                if (VAR_8 > VAR_9) {\n                    ENGINE_SET_INVALID_EVENT(VAR_2, VAR_19);\n                    VAR_18;\n                }\n                VAR_7 = *VAR_3;\n                VAR_3 += VAR_8;\n                VAR_9 -= VAR_8;\n                break;\n            default:\n                ENGINE_SET_EVENT(VAR_2, VAR_78);\n                IPV6_SET_L4PROTO(VAR_2,VAR_7);\n                VAR_18;\n        }\n    }\n\n    VAR_18;\n}",
  "func_graph_path": "OISF/suricata/11f3659f64a4e42e90cb3c09fcef66894205aefe/decode-ipv6.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,9 @@\n     SCEnter();\n \n     uint8_t *orig_pkt = pkt;\n-    uint8_t nh = 0; /* careful, 0 is actually a real type */\n+    uint8_t nh = IPV6_GET_NH(p); /* careful, 0 is actually a real type */\n     uint16_t hdrextlen = 0;\n-    uint16_t plen;\n+    uint16_t plen = len;\n     char dstopts = 0;\n     char exthdr_fh_done = 0;\n     int hh = 0;\n@@ -14,18 +14,18 @@\n     int eh = 0;\n     int ah = 0;\n \n-    nh = IPV6_GET_NH(p);\n-    plen = len;\n-\n     while(1)\n     {\n-        /* No upper layer, but we do have data. Suspicious. */\n-        if (nh == IPPROTO_NONE && plen > 0) {\n-            ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n+        if (nh == IPPROTO_NONE) {\n+            if (plen > 0) {\n+                /* No upper layer, but we do have data. Suspicious. */\n+                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n+            }\n             SCReturn;\n         }\n \n         if (plen < 2) { /* minimal needed in a hdr */\n+            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n             SCReturn;\n         }\n \n@@ -58,7 +58,7 @@\n                 SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n \n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -97,7 +97,7 @@\n                 IPV6_SET_L4PROTO(p,nh);\n                 hdrextlen =  (*(pkt+1) + 1) << 3;\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -142,7 +142,7 @@\n                 if (optslen > plen) {\n                     /* since the packet is long enough (we checked\n                      * plen against hdrlen, the optlen must be malformed. */\n-                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                     /* skip past this extension so we can continue parsing the rest\n                      * of the packet */\n                     nh = *pkt;\n@@ -165,7 +165,7 @@\n                     }\n \n                     if (offset + 1 >= optslen) {\n-                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                         break;\n                     }\n \n@@ -174,7 +174,7 @@\n \n                     /* see if the optlen from the packet fits the total optslen */\n                     if ((offset + 1 + ip6_optlen) > optslen) {\n-                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                         break;\n                     }\n \n@@ -193,7 +193,7 @@\n                         ra->ip6ra_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n-                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n@@ -209,7 +209,7 @@\n                         jumbo->ip6j_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n-                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n@@ -224,7 +224,7 @@\n                         hao->ip6hao_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n-                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n@@ -276,7 +276,7 @@\n                 uint16_t prev_hdrextlen = hdrextlen;\n                 hdrextlen = sizeof(IPV6FragHdr);\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -322,7 +322,7 @@\n                 IPV6_SET_L4PROTO(p,nh);\n                 hdrextlen = sizeof(IPV6EspHdr);\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -351,7 +351,7 @@\n                 SCLogDebug(\"hdrextlen %\"PRIu8, hdrextlen);\n \n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -392,7 +392,7 @@\n             case IPPROTO_SHIM6:\n                 hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n                 nh = *pkt;",
  "diff_line_info": {
    "deleted_lines": [
      "    uint8_t nh = 0; /* careful, 0 is actually a real type */",
      "    uint16_t plen;",
      "    nh = IPV6_GET_NH(p);",
      "    plen = len;",
      "",
      "        /* No upper layer, but we do have data. Suspicious. */",
      "        if (nh == IPPROTO_NONE && plen > 0) {",
      "            ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);",
      "                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);"
    ],
    "added_lines": [
      "    uint8_t nh = IPV6_GET_NH(p); /* careful, 0 is actually a real type */",
      "    uint16_t plen = len;",
      "        if (nh == IPPROTO_NONE) {",
      "            if (plen > 0) {",
      "                /* No upper layer, but we do have data. Suspicious. */",
      "                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);",
      "            }",
      "            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);",
      "                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);",
      "                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/3590",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OISF/suricata/pull/3590: 403 Client Error: Forbidden for url: https://api.github.com/repos/OISF/suricata/issues/3590/comments",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The changes involve stricter IPv6 validation to prevent misclassification of invalid packets, which addresses a security concern by mitigating potential evasion of UDP payload inspection. This makes it a security vulnerability fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}