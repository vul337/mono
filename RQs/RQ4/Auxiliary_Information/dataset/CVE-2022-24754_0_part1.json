{
  "cve_id": "CVE-2022-24754",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "pjsip/pjproject",
  "commit_msg": "Use PJ_ASSERT_RETURN() on pjsip_auth_create_digest() and pjsua_init_tpselector() (#3009)\n\n* Use PJ_ASSERT_RETURN on pjsip_auth_create_digest\r\n\r\n* Use PJ_ASSERT_RETURN on pjsua_init_tpselector()\r\n\r\n* Fix incorrect check.\r\n\r\n* Add return value to pjsip_auth_create_digest() and pjsip_auth_create_digestSHA256()\r\n\r\n* Modification based on comments.",
  "commit_hash": "d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "git_url": "https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "file_path": "pjsip/src/pjsip/sip_auth_aka.c",
  "func_name": "pjsip_auth_create_aka_response",
  "func_before": "PJ_DEF(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t\t     const pj_str_t *method,\n\t\t\t\t\t     pjsip_digest_credential *auth)\n{\n    pj_str_t nonce_bin;\n    int aka_version;\n    const pj_str_t pjsip_AKAv1_MD5 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t pjsip_AKAv2_MD5 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac;\n    pj_uint8_t k[PJSIP_AKA_KLEN];\n    pj_uint8_t op[PJSIP_AKA_OPLEN];\n    pj_uint8_t amf[PJSIP_AKA_AMFLEN];\n    pj_uint8_t res[PJSIP_AKA_RESLEN];\n    pj_uint8_t ck[PJSIP_AKA_CKLEN];\n    pj_uint8_t ik[PJSIP_AKA_IKLEN];\n    pj_uint8_t ak[PJSIP_AKA_AKLEN];\n    pj_uint8_t sqn[PJSIP_AKA_SQNLEN];\n    pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n    pjsip_cred_info aka_cred;\n    int i, len;\n    pj_status_t status;\n\n    /* Check the algorithm is supported. */\n    if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n\t/*\n\t * A normal MD5 authentication is requested. Fallbackt to the usual\n\t * MD5 digest creation.\n\t */\n\tpjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,\n\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,\n\t\t\t\t &auth->realm, cred, method);\n\treturn PJ_SUCCESS;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) {\n\t/*\n\t * AKA version 1 is requested.\n\t */\n\taka_version = 1;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) {\n\t/*\n\t * AKA version 2 is requested.\n\t */\n\taka_version = 2;\n\n    } else {\n\t/* Unsupported algorithm */\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Decode nonce */\n    nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen);\n    nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1);\n    status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len);\n    nonce_bin.slen = len;\n    if (status != PJ_SUCCESS)\n\treturn PJSIP_EAUTHINNONCE;\n\n    if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN)\n\treturn PJSIP_EAUTHINNONCE;\n\n    /* Get RAND, AUTN, and MAC */\n    chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0);\n    chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN);\n    chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN + \n\t\t\t      PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN);\n\n    /* Copy k. op, and amf */\n    pj_bzero(k, sizeof(k));\n    pj_bzero(op, sizeof(op));\n    pj_bzero(amf, sizeof(amf));\n\n    if (cred->ext.aka.k.slen)\n\tpj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen);\n    if (cred->ext.aka.op.slen)\n\tpj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen);\n    if (cred->ext.aka.amf.slen)\n\tpj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen);\n\n    /* Given key K and random challenge RAND, compute response RES,\n     * confidentiality key CK, integrity key IK and anonymity key AK.\n     */\n    f2345(k, chal_rand, res, ck, ik, ak, op);\n\n    /* Compute sequence number SQN */\n    for (i=0; i<PJSIP_AKA_SQNLEN; ++i)\n\tsqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]);\n\n    /* Verify MAC in the challenge */\n    /* Compute XMAC */\n    f1(k, chal_rand, sqn, amf, xmac, op);\n\n    if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) {\n\treturn PJSIP_EAUTHINNONCE;\n    }\n\n    /* Build a temporary credential info to create MD5 digest, using\n     * \"res\" as the password. \n     */\n    pj_memcpy(&aka_cred, cred, sizeof(aka_cred));\n    aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\n    /* Create a response */\n    if (aka_version == 1) {\n\t/*\n\t * For AKAv1, the password is RES\n\t */\n\taka_cred.data.ptr = (char*)res;\n\taka_cred.data.slen = PJSIP_AKA_RESLEN;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else if (aka_version == 2) {\n\n\t/*\n\t * For AKAv2, password is base64 encoded [1] parameters:\n\t *    PRF(RES||IK||CK,\"http-digest-akav2-password\")\n\t *\n\t * The pseudo-random function (PRF) is HMAC-MD5 in this case.\n\t */\n\n\tpj_str_t resikck;\n\tconst pj_str_t AKAv2_Passwd = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t hmac_digest[16];\n\tchar tmp_buf[48];\n\tint hmac64_len;\n\n\tresikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN;\n\tpj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf));\n\tresikck.ptr = tmp_buf;\n\tpj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN,\n\t          ck, PJSIP_AKA_CKLEN);\n\n\tpj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen,\n\t            (const pj_uint8_t*)resikck.ptr, resikck.slen,\n\t            hmac_digest);\n\n\taka_cred.data.slen = hmac64_len =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest));\n\tpj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf));\n\taka_cred.data.ptr = tmp_buf;\n\tpj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest),\n\t                 aka_cred.data.ptr, &len);\n\taka_cred.data.slen = hmac64_len;\n\n\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn PJ_EBUG;\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}",
  "abstract_func_before": "VAR_0(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *VAR_1,\n\t\t\t\t\t     const pjsip_digest_challenge *VAR_2,\n\t\t\t\t\t     const pjsip_cred_info *VAR_3,\n\t\t\t\t\t     const pj_str_t *VAR_4,\n\t\t\t\t\t     pjsip_digest_credential *VAR_5)\n{\n    pj_str_t VAR_6;\n    int VAR_7;\n    const pj_str_t VAR_8 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t VAR_9 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *VAR_10, *VAR_11, *VAR_12;\n    pj_uint8_t VAR_13[VAR_14];\n    pj_uint8_t VAR_15[VAR_16];\n    pj_uint8_t VAR_17[VAR_18];\n    pj_uint8_t VAR_19[VAR_20];\n    pj_uint8_t VAR_21[VAR_22];\n    pj_uint8_t VAR_23[VAR_24];\n    pj_uint8_t VAR_25[VAR_26];\n    pj_uint8_t VAR_27[VAR_28];\n    pj_uint8_t VAR_29[VAR_30];\n    pjsip_cred_info VAR_31;\n    int VAR_32, VAR_33;\n    pj_status_t VAR_34;\n\n    /* COMMENT_0 */\n    if (VAR_2->algorithm.slen==0 || pj_stricmp2(&VAR_2->algorithm, \"md5\") == 0) {\n\t/* COMMENT_1 */\n                                                                    \n                        \n    \n\tpjsip_auth_create_digest(&VAR_5->response, &VAR_5->nonce, &VAR_5->nc,\n\t\t\t\t &VAR_5->cnonce, &VAR_5->qop, &VAR_5->uri,\n\t\t\t\t &VAR_5->realm, VAR_3, VAR_4);\n\treturn VAR_35;\n\n    } else if (pj_stricmp(&VAR_2->algorithm, &VAR_8) == 0) {\n\t/* COMMENT_5 */\n                               \n    \n\tVAR_7 = 1;\n\n    } else if (pj_stricmp(&VAR_2->algorithm, &VAR_9) == 0) {\n\t/* COMMENT_8 */\n                               \n    \n\tVAR_7 = 2;\n\n    } else {\n\t/* COMMENT_11 */\n\treturn VAR_36;\n    }\n\n    /* COMMENT_12 */\n    VAR_6.slen = VAR_33 = PJ_BASE64_TO_BASE256_LEN(VAR_2->nonce.slen);\n    VAR_6.ptr = pj_pool_alloc(VAR_1, VAR_6.slen + 1);\n    VAR_34 = pj_base64_decode(&VAR_2->nonce, (pj_uint8_t*)VAR_6.ptr, &VAR_33);\n    VAR_6.slen = VAR_33;\n    if (VAR_34 != VAR_35)\n\treturn VAR_37;\n\n    if (VAR_6.slen < VAR_38 + VAR_39)\n\treturn VAR_37;\n\n    /* COMMENT_13 */\n    VAR_10 = (pj_uint8_t*)(VAR_6.ptr + 0);\n    VAR_11 = (pj_uint8_t*) (VAR_6.ptr + VAR_38);\n    VAR_12 = (pj_uint8_t*) (VAR_6.ptr + VAR_38 + \n\t\t\t      VAR_28 + VAR_18);\n\n    /* COMMENT_14 */\n    pj_bzero(VAR_13, sizeof(VAR_13));\n    pj_bzero(VAR_15, sizeof(VAR_15));\n    pj_bzero(VAR_17, sizeof(VAR_17));\n\n    if (VAR_3->ext.aka.k.slen)\n\tpj_memcpy(VAR_13, VAR_3->ext.aka.k.ptr, VAR_3->ext.aka.k.slen);\n    if (VAR_3->ext.aka.op.slen)\n\tpj_memcpy(VAR_15, VAR_3->ext.aka.op.ptr, VAR_3->ext.aka.op.slen);\n    if (VAR_3->ext.aka.amf.slen)\n\tpj_memcpy(VAR_17, VAR_3->ext.aka.amf.ptr, VAR_3->ext.aka.amf.slen);\n\n    /* COMMENT_15 */\n                                                                     \n       \n    f2345(VAR_13, VAR_10, VAR_19, VAR_21, VAR_23, VAR_25, VAR_15);\n\n    /* COMMENT_18 */\n    for (VAR_32=0; VAR_32<VAR_28; ++VAR_32)\n\tVAR_27[VAR_32] = (pj_uint8_t) (VAR_11[VAR_32] ^ VAR_25[VAR_32]);\n\n    /* COMMENT_19 */\n    /* COMMENT_20 */\n    f1(VAR_13, VAR_10, VAR_27, VAR_17, VAR_29, VAR_15);\n\n    if (pj_memcmp(VAR_12, VAR_29, VAR_30) != 0) {\n\treturn VAR_37;\n    }\n\n    /* COMMENT_21 */\n                              \n       \n    pj_memcpy(&VAR_31, VAR_3, sizeof(VAR_31));\n    VAR_31.data_type = VAR_40;\n\n    /* COMMENT_24 */\n    if (VAR_7 == 1) {\n\t/* COMMENT_25 */\n                                  \n    \n\tVAR_31.data.ptr = (char*)VAR_19;\n\tVAR_31.data.slen = VAR_20;\n\n\tpjsip_auth_create_digest(&VAR_5->response, &VAR_2->nonce, \n\t\t\t\t &VAR_5->nc, &VAR_5->cnonce, &VAR_5->qop, \n\t\t\t\t &VAR_5->uri, &VAR_2->realm, &VAR_31, VAR_4);\n\n    } else if (VAR_7 == 2) {\n\n\t/* COMMENT_28 */\n                                                         \n                                                    \n   \n                                                              \n    \n\n\tpj_str_t VAR_41;\n\tconst pj_str_t VAR_42 = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t VAR_43[16];\n\tchar VAR_44[48];\n\tint VAR_45;\n\n\tVAR_41.slen = VAR_20 + VAR_24 + VAR_22;\n\tpj_assert(VAR_41.slen <= PJ_ARRAY_SIZE(VAR_44));\n\tVAR_41.ptr = VAR_44;\n\tpj_memcpy(VAR_41.ptr + 0, VAR_19, VAR_20);\n\tpj_memcpy(VAR_41.ptr + VAR_20, VAR_23, VAR_24);\n\tpj_memcpy(VAR_41.ptr + VAR_20 + VAR_24,\n\t          VAR_21, VAR_22);\n\n\tpj_hmac_md5((const pj_uint8_t*)VAR_42.ptr, VAR_42.slen,\n\t            (const pj_uint8_t*)VAR_41.ptr, VAR_41.slen,\n\t            VAR_43);\n\n\tVAR_31.data.slen = VAR_45 =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(VAR_43));\n\tpj_assert(VAR_31.data.slen+1 <= PJ_ARRAY_SIZE(VAR_44));\n\tVAR_31.data.ptr = VAR_44;\n\tpj_base64_encode(VAR_43, PJ_ARRAY_SIZE(VAR_43),\n\t                 VAR_31.data.ptr, &VAR_33);\n\tVAR_31.data.slen = VAR_45;\n\n\tpjsip_auth_create_digest(&VAR_5->response, &VAR_2->nonce, \n\t\t\t\t &VAR_5->nc, &VAR_5->cnonce, &VAR_5->qop, \n\t\t\t\t &VAR_5->uri, &VAR_2->realm, &VAR_31, VAR_4);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn VAR_46;\n    }\n\n    /* COMMENT_34 */\n    return VAR_35;\n}",
  "func_graph_path_before": null,
  "func": "PJ_DEF(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *pool,\n\t\t\t\t\t     const pjsip_digest_challenge *chal,\n\t\t\t\t\t     const pjsip_cred_info *cred,\n\t\t\t\t\t     const pj_str_t *method,\n\t\t\t\t\t     pjsip_digest_credential *auth)\n{\n    pj_str_t nonce_bin;\n    int aka_version;\n    const pj_str_t pjsip_AKAv1_MD5 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t pjsip_AKAv2_MD5 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac;\n    pj_uint8_t k[PJSIP_AKA_KLEN];\n    pj_uint8_t op[PJSIP_AKA_OPLEN];\n    pj_uint8_t amf[PJSIP_AKA_AMFLEN];\n    pj_uint8_t res[PJSIP_AKA_RESLEN];\n    pj_uint8_t ck[PJSIP_AKA_CKLEN];\n    pj_uint8_t ik[PJSIP_AKA_IKLEN];\n    pj_uint8_t ak[PJSIP_AKA_AKLEN];\n    pj_uint8_t sqn[PJSIP_AKA_SQNLEN];\n    pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n    pjsip_cred_info aka_cred;\n    int i, len;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check the algorithm is supported. */\n    if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n\t/*\n\t * A normal MD5 authentication is requested. Fallback to the usual\n\t * MD5 digest creation.\n\t */\n\tstatus = pjsip_auth_create_digest(&auth->response, &auth->nonce, \n\t\t\t         &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t         &auth->uri, &auth->realm, cred, method);\n\n\treturn status;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) {\n\t/*\n\t * AKA version 1 is requested.\n\t */\n\taka_version = 1;\n\n    } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) {\n\t/*\n\t * AKA version 2 is requested.\n\t */\n\taka_version = 2;\n\n    } else {\n\t/* Unsupported algorithm */\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Decode nonce */\n    nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen);\n    nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1);\n    status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len);\n    nonce_bin.slen = len;\n    if (status != PJ_SUCCESS)\n\treturn PJSIP_EAUTHINNONCE;\n\n    if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN)\n\treturn PJSIP_EAUTHINNONCE;\n\n    /* Get RAND, AUTN, and MAC */\n    chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0);\n    chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN);\n    chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN + \n\t\t\t      PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN);\n\n    /* Copy k. op, and amf */\n    pj_bzero(k, sizeof(k));\n    pj_bzero(op, sizeof(op));\n    pj_bzero(amf, sizeof(amf));\n\n    if (cred->ext.aka.k.slen)\n\tpj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen);\n    if (cred->ext.aka.op.slen)\n\tpj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen);\n    if (cred->ext.aka.amf.slen)\n\tpj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen);\n\n    /* Given key K and random challenge RAND, compute response RES,\n     * confidentiality key CK, integrity key IK and anonymity key AK.\n     */\n    f2345(k, chal_rand, res, ck, ik, ak, op);\n\n    /* Compute sequence number SQN */\n    for (i=0; i<PJSIP_AKA_SQNLEN; ++i)\n\tsqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]);\n\n    /* Verify MAC in the challenge */\n    /* Compute XMAC */\n    f1(k, chal_rand, sqn, amf, xmac, op);\n\n    if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) {\n\treturn PJSIP_EAUTHINNONCE;\n    }\n\n    /* Build a temporary credential info to create MD5 digest, using\n     * \"res\" as the password. \n     */\n    pj_memcpy(&aka_cred, cred, sizeof(aka_cred));\n    aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD;\n\n    /* Create a response */\n    if (aka_version == 1) {\n\t/*\n\t * For AKAv1, the password is RES\n\t */\n\taka_cred.data.ptr = (char*)res;\n\taka_cred.data.slen = PJSIP_AKA_RESLEN;\n\n\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\t\n\n    } else if (aka_version == 2) {\n\n\t/*\n\t * For AKAv2, password is base64 encoded [1] parameters:\n\t *    PRF(RES||IK||CK,\"http-digest-akav2-password\")\n\t *\n\t * The pseudo-random function (PRF) is HMAC-MD5 in this case.\n\t */\n\n\tpj_str_t resikck;\n\tconst pj_str_t AKAv2_Passwd = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t hmac_digest[16];\n\tchar tmp_buf[48];\n\tint hmac64_len;\n\n\tresikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN;\n\tpj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf));\n\tresikck.ptr = tmp_buf;\n\tpj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN);\n\tpj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN,\n\t          ck, PJSIP_AKA_CKLEN);\n\n\tpj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen,\n\t            (const pj_uint8_t*)resikck.ptr, resikck.slen,\n\t            hmac_digest);\n\n\taka_cred.data.slen = hmac64_len =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest));\n\tpj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf));\n\taka_cred.data.ptr = tmp_buf;\n\tpj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest),\n\t                 aka_cred.data.ptr, &len);\n\taka_cred.data.slen = hmac64_len;\n\n\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, \n\t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn PJ_EBUG;\n    }\n\n    /* Done */\n    return status;\n}",
  "abstract_func": "VAR_0(pj_status_t) pjsip_auth_create_aka_response( \n\t\t\t\t\t     pj_pool_t *VAR_1,\n\t\t\t\t\t     const pjsip_digest_challenge *VAR_2,\n\t\t\t\t\t     const pjsip_cred_info *VAR_3,\n\t\t\t\t\t     const pj_str_t *VAR_4,\n\t\t\t\t\t     pjsip_digest_credential *VAR_5)\n{\n    pj_str_t VAR_6;\n    int VAR_7;\n    const pj_str_t VAR_8 = { \"AKAv1-MD5\", 9 };\n    const pj_str_t VAR_9 = { \"AKAv2-MD5\", 9 };\n    pj_uint8_t *VAR_10, *VAR_11, *VAR_12;\n    pj_uint8_t VAR_13[VAR_14];\n    pj_uint8_t VAR_15[VAR_16];\n    pj_uint8_t VAR_17[VAR_18];\n    pj_uint8_t VAR_19[VAR_20];\n    pj_uint8_t VAR_21[VAR_22];\n    pj_uint8_t VAR_23[VAR_24];\n    pj_uint8_t VAR_25[VAR_26];\n    pj_uint8_t VAR_27[VAR_28];\n    pj_uint8_t VAR_29[VAR_30];\n    pjsip_cred_info VAR_31;\n    int VAR_32, VAR_33;\n    pj_status_t VAR_34 = VAR_35;\n\n    /* COMMENT_0 */\n    if (VAR_2->algorithm.slen==0 || pj_stricmp2(&VAR_2->algorithm, \"md5\") == 0) {\n\t/* COMMENT_1 */\n                                                                   \n                        \n    \n\tVAR_34 = pjsip_auth_create_digest(&VAR_5->response, &VAR_5->nonce, \n\t\t\t         &VAR_5->nc, &VAR_5->cnonce, &VAR_5->qop, \n\t\t\t         &VAR_5->uri, &VAR_5->realm, VAR_3, VAR_4);\n\n\treturn VAR_34;\n\n    } else if (pj_stricmp(&VAR_2->algorithm, &VAR_8) == 0) {\n\t/* COMMENT_5 */\n                               \n    \n\tVAR_7 = 1;\n\n    } else if (pj_stricmp(&VAR_2->algorithm, &VAR_9) == 0) {\n\t/* COMMENT_8 */\n                               \n    \n\tVAR_7 = 2;\n\n    } else {\n\t/* COMMENT_11 */\n\treturn VAR_36;\n    }\n\n    /* COMMENT_12 */\n    VAR_6.slen = VAR_33 = PJ_BASE64_TO_BASE256_LEN(VAR_2->nonce.slen);\n    VAR_6.ptr = pj_pool_alloc(VAR_1, VAR_6.slen + 1);\n    VAR_34 = pj_base64_decode(&VAR_2->nonce, (pj_uint8_t*)VAR_6.ptr, &VAR_33);\n    VAR_6.slen = VAR_33;\n    if (VAR_34 != VAR_35)\n\treturn VAR_37;\n\n    if (VAR_6.slen < VAR_38 + VAR_39)\n\treturn VAR_37;\n\n    /* COMMENT_13 */\n    VAR_10 = (pj_uint8_t*)(VAR_6.ptr + 0);\n    VAR_11 = (pj_uint8_t*) (VAR_6.ptr + VAR_38);\n    VAR_12 = (pj_uint8_t*) (VAR_6.ptr + VAR_38 + \n\t\t\t      VAR_28 + VAR_18);\n\n    /* COMMENT_14 */\n    pj_bzero(VAR_13, sizeof(VAR_13));\n    pj_bzero(VAR_15, sizeof(VAR_15));\n    pj_bzero(VAR_17, sizeof(VAR_17));\n\n    if (VAR_3->ext.aka.k.slen)\n\tpj_memcpy(VAR_13, VAR_3->ext.aka.k.ptr, VAR_3->ext.aka.k.slen);\n    if (VAR_3->ext.aka.op.slen)\n\tpj_memcpy(VAR_15, VAR_3->ext.aka.op.ptr, VAR_3->ext.aka.op.slen);\n    if (VAR_3->ext.aka.amf.slen)\n\tpj_memcpy(VAR_17, VAR_3->ext.aka.amf.ptr, VAR_3->ext.aka.amf.slen);\n\n    /* COMMENT_15 */\n                                                                     \n       \n    f2345(VAR_13, VAR_10, VAR_19, VAR_21, VAR_23, VAR_25, VAR_15);\n\n    /* COMMENT_18 */\n    for (VAR_32=0; VAR_32<VAR_28; ++VAR_32)\n\tVAR_27[VAR_32] = (pj_uint8_t) (VAR_11[VAR_32] ^ VAR_25[VAR_32]);\n\n    /* COMMENT_19 */\n    /* COMMENT_20 */\n    f1(VAR_13, VAR_10, VAR_27, VAR_17, VAR_29, VAR_15);\n\n    if (pj_memcmp(VAR_12, VAR_29, VAR_30) != 0) {\n\treturn VAR_37;\n    }\n\n    /* COMMENT_21 */\n                              \n       \n    pj_memcpy(&VAR_31, VAR_3, sizeof(VAR_31));\n    VAR_31.data_type = VAR_40;\n\n    /* COMMENT_24 */\n    if (VAR_7 == 1) {\n\t/* COMMENT_25 */\n                                  \n    \n\tVAR_31.data.ptr = (char*)VAR_19;\n\tVAR_31.data.slen = VAR_20;\n\n\tVAR_34 = pjsip_auth_create_digest(&VAR_5->response, &VAR_2->nonce, \n\t\t\t\t &VAR_5->nc, &VAR_5->cnonce, &VAR_5->qop, \n\t\t\t\t &VAR_5->uri, &VAR_2->realm, &VAR_31, VAR_4);\t\n\n    } else if (VAR_7 == 2) {\n\n\t/* COMMENT_28 */\n                                                         \n                                                    \n   \n                                                              \n    \n\n\tpj_str_t VAR_41;\n\tconst pj_str_t VAR_42 = { \"http-digest-akav2-password\", 26 };\n\tpj_uint8_t VAR_43[16];\n\tchar VAR_44[48];\n\tint VAR_45;\n\n\tVAR_41.slen = VAR_20 + VAR_24 + VAR_22;\n\tpj_assert(VAR_41.slen <= PJ_ARRAY_SIZE(VAR_44));\n\tVAR_41.ptr = VAR_44;\n\tpj_memcpy(VAR_41.ptr + 0, VAR_19, VAR_20);\n\tpj_memcpy(VAR_41.ptr + VAR_20, VAR_23, VAR_24);\n\tpj_memcpy(VAR_41.ptr + VAR_20 + VAR_24,\n\t          VAR_21, VAR_22);\n\n\tpj_hmac_md5((const pj_uint8_t*)VAR_42.ptr, VAR_42.slen,\n\t            (const pj_uint8_t*)VAR_41.ptr, VAR_41.slen,\n\t            VAR_43);\n\n\tVAR_31.data.slen = VAR_45 =\n\t\tPJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(VAR_43));\n\tpj_assert(VAR_31.data.slen+1 <= PJ_ARRAY_SIZE(VAR_44));\n\tVAR_31.data.ptr = VAR_44;\n\tpj_base64_encode(VAR_43, PJ_ARRAY_SIZE(VAR_43),\n\t                 VAR_31.data.ptr, &VAR_33);\n\tVAR_31.data.slen = VAR_45;\n\n\tVAR_34 = pjsip_auth_create_digest(&VAR_5->response, &VAR_2->nonce, \n\t\t\t\t &VAR_5->nc, &VAR_5->cnonce, &VAR_5->qop, \n\t\t\t\t &VAR_5->uri, &VAR_2->realm, &VAR_31, VAR_4);\n\n    } else {\n\tpj_assert(!\"Bug!\");\n\treturn VAR_46;\n    }\n\n    /* COMMENT_34 */\n    return VAR_34;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,18 +21,19 @@\n     pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n     pjsip_cred_info aka_cred;\n     int i, len;\n-    pj_status_t status;\n+    pj_status_t status = PJ_SUCCESS;\n \n     /* Check the algorithm is supported. */\n     if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n \t/*\n-\t * A normal MD5 authentication is requested. Fallbackt to the usual\n+\t * A normal MD5 authentication is requested. Fallback to the usual\n \t * MD5 digest creation.\n \t */\n-\tpjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,\n-\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,\n-\t\t\t\t &auth->realm, cred, method);\n-\treturn PJ_SUCCESS;\n+\tstatus = pjsip_auth_create_digest(&auth->response, &auth->nonce, \n+\t\t\t         &auth->nc, &auth->cnonce, &auth->qop, \n+\t\t\t         &auth->uri, &auth->realm, cred, method);\n+\n+\treturn status;\n \n     } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) {\n \t/*\n@@ -111,9 +112,9 @@\n \taka_cred.data.ptr = (char*)res;\n \taka_cred.data.slen = PJSIP_AKA_RESLEN;\n \n-\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n+\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, \n \t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n-\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n+\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\t\n \n     } else if (aka_version == 2) {\n \n@@ -150,7 +151,7 @@\n \t                 aka_cred.data.ptr, &len);\n \taka_cred.data.slen = hmac64_len;\n \n-\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n+\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, \n \t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n \t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\n \n@@ -160,5 +161,5 @@\n     }\n \n     /* Done */\n-    return PJ_SUCCESS;\n+    return status;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    pj_status_t status;",
      "\t * A normal MD5 authentication is requested. Fallbackt to the usual",
      "\tpjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,",
      "\t\t\t\t &auth->cnonce, &auth->qop, &auth->uri,",
      "\t\t\t\t &auth->realm, cred, method);",
      "\treturn PJ_SUCCESS;",
      "\tpjsip_auth_create_digest(&auth->response, &chal->nonce, ",
      "\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);",
      "\tpjsip_auth_create_digest(&auth->response, &chal->nonce, ",
      "    return PJ_SUCCESS;"
    ],
    "added_lines": [
      "    pj_status_t status = PJ_SUCCESS;",
      "\t * A normal MD5 authentication is requested. Fallback to the usual",
      "\tstatus = pjsip_auth_create_digest(&auth->response, &auth->nonce, ",
      "\t\t\t         &auth->nc, &auth->cnonce, &auth->qop, ",
      "\t\t\t         &auth->uri, &auth->realm, cred, method);",
      "",
      "\treturn status;",
      "\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, ",
      "\t\t\t\t &auth->uri, &chal->realm, &aka_cred, method);\t",
      "\tstatus = pjsip_auth_create_digest(&auth->response, &chal->nonce, ",
      "    return status;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/pjsip/pjproject/pull/3009",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/pjsip/pjproject/pull/3009: 403 Client Error: Forbidden for url: https://api.github.com/repos/pjsip/pjproject/pulls/3009",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.98,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.98"
}