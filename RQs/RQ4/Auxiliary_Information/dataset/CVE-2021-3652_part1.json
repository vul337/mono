{
  "cve_id": "CVE-2021-3652",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "389ds/389-ds-base",
  "commit_msg": "Issue 4817 - BUG - locked crypt accounts on import may allow all passwords\n\nBug Description: Due to mishanding of short dbpwd hashes, the\ncrypt_r algorithm was misused and was only comparing salts\nin some cases, rather than checking the actual content\nof the password.\n\nFix Description: Stricter checks on dbpwd lengths to ensure\nthat content passed to crypt_r has at least 2 salt bytes and\n1 hash byte, as well as stricter checks on ct_memcmp to ensure\nthat compared values are the same length, rather than potentially\nallowing overruns/short comparisons.\n\nfixes: https://github.com/389ds/389-ds-base/issues/4817\n\nAuthor: William Brown <william@blackhats.net.au>\n\nReview by: ???",
  "commit_hash": "ec4d65e5d6c5310c990a2cfe161d52f5f574f337",
  "git_url": "https://github.com/389ds/389-ds-base/commit/ec4d65e5d6c5310c990a2cfe161d52f5f574f337",
  "file_path": "ldap/servers/plugins/pwdstorage/crypt_pwd.c",
  "func_name": "crypt_pw_cmp",
  "func_before": "int\ncrypt_pw_cmp(const char *userpwd, const char *dbpwd)\n{\n    int rc;\n    char *cp;\n    struct crypt_data data;\n    data.initialized = 0;\n\n    /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n    cp = crypt_r(userpwd, dbpwd, &data);\n    if (cp) {\n        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));\n    } else {\n        rc = -1;\n    }\n    return rc;\n}",
  "abstract_func_before": "int\ncrypt_pw_cmp(const char *VAR_0, const char *VAR_1)\n{\n    int VAR_2;\n    char *VAR_3;\n    struct crypt_data VAR_4;\n    VAR_4.initialized = 0;\n\n    /* COMMENT_0 */\n    VAR_3 = crypt_r(VAR_0, VAR_1, &VAR_4);\n    if (VAR_3) {\n        VAR_2 = slapi_ct_memcmp(VAR_1, VAR_3, strlen(VAR_1));\n    } else {\n        VAR_2 = -1;\n    }\n    return VAR_2;\n}",
  "func_graph_path_before": "389ds/389-ds-base/ec4d65e5d6c5310c990a2cfe161d52f5f574f337/crypt_pwd.c/vul/before/0.json",
  "func": "int\ncrypt_pw_cmp(const char *userpwd, const char *dbpwd)\n{\n    int rc = -1;\n    char *cp = NULL;\n    size_t dbpwd_len = strlen(dbpwd);\n    struct crypt_data data;\n    data.initialized = 0;\n\n    /*\n     * there MUST be at least 2 chars of salt and some pw bytes, else this is INVALID and will\n     * allow any password to bind as we then only compare SALTS.\n     */\n    if (dbpwd_len >= 3) {\n        /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n        cp = crypt_r(userpwd, dbpwd, &data);\n    }\n    /* If these are not the same length, we can not proceed safely with memcmp. */\n    if (cp && dbpwd_len == strlen(cp)) {\n        rc = slapi_ct_memcmp(dbpwd, cp, dbpwd_len);\n    } else {\n        rc = -1;\n    }\n    return rc;\n}",
  "abstract_func": "int\ncrypt_pw_cmp(const char *VAR_0, const char *VAR_1)\n{\n    int VAR_2 = -1;\n    char *VAR_3 = NULL;\n    size_t VAR_4 = strlen(VAR_1);\n    struct crypt_data VAR_5;\n    VAR_5.initialized = 0;\n\n    /* COMMENT_0 */\n                                                                                              \n                                                                \n       \n    if (VAR_4 >= 3) {\n        /* COMMENT_4 */\n        VAR_3 = crypt_r(VAR_0, VAR_1, &VAR_5);\n    }\n    /* COMMENT_5 */\n    if (VAR_3 && VAR_4 == strlen(VAR_3)) {\n        VAR_2 = slapi_ct_memcmp(VAR_1, VAR_3, VAR_4);\n    } else {\n        VAR_2 = -1;\n    }\n    return VAR_2;\n}",
  "func_graph_path": "389ds/389-ds-base/ec4d65e5d6c5310c990a2cfe161d52f5f574f337/crypt_pwd.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,23 @@\n int\n crypt_pw_cmp(const char *userpwd, const char *dbpwd)\n {\n-    int rc;\n-    char *cp;\n+    int rc = -1;\n+    char *cp = NULL;\n+    size_t dbpwd_len = strlen(dbpwd);\n     struct crypt_data data;\n     data.initialized = 0;\n \n-    /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n-    cp = crypt_r(userpwd, dbpwd, &data);\n-    if (cp) {\n-        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));\n+    /*\n+     * there MUST be at least 2 chars of salt and some pw bytes, else this is INVALID and will\n+     * allow any password to bind as we then only compare SALTS.\n+     */\n+    if (dbpwd_len >= 3) {\n+        /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n+        cp = crypt_r(userpwd, dbpwd, &data);\n+    }\n+    /* If these are not the same length, we can not proceed safely with memcmp. */\n+    if (cp && dbpwd_len == strlen(cp)) {\n+        rc = slapi_ct_memcmp(dbpwd, cp, dbpwd_len);\n     } else {\n         rc = -1;\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "    int rc;",
      "    char *cp;",
      "    /* we use salt (first 2 chars) of encoded password in call to crypt_r() */",
      "    cp = crypt_r(userpwd, dbpwd, &data);",
      "    if (cp) {",
      "        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));"
    ],
    "added_lines": [
      "    int rc = -1;",
      "    char *cp = NULL;",
      "    size_t dbpwd_len = strlen(dbpwd);",
      "    /*",
      "     * there MUST be at least 2 chars of salt and some pw bytes, else this is INVALID and will",
      "     * allow any password to bind as we then only compare SALTS.",
      "     */",
      "    if (dbpwd_len >= 3) {",
      "        /* we use salt (first 2 chars) of encoded password in call to crypt_r() */",
      "        cp = crypt_r(userpwd, dbpwd, &data);",
      "    }",
      "    /* If these are not the same length, we can not proceed safely with memcmp. */",
      "    if (cp && dbpwd_len == strlen(cp)) {",
      "        rc = slapi_ct_memcmp(dbpwd, cp, dbpwd_len);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/389ds/389-ds-base/pull/4819",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/389ds/389-ds-base/pull/4819: 403 Client Error: Forbidden for url: https://api.github.com/repos/389ds/389-ds-base/pulls/4819",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}