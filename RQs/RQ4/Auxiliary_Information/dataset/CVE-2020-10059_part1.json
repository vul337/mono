{
  "cve_id": "CVE-2020-10059",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "zephyrproject-rtos/zephyr",
  "commit_msg": "updatehub: Require peer verification with DTLS\n\nDTLS without peer verification offers no security whatsoever (and is\narguably worse than not using DTLS in the first place).\n\nChange the verification option to require this peer verification.  To\nuse this, it may be necessary to install and use a root certificate.\n\nSigned-off-by: David Brown <david.brown@linaro.org>",
  "commit_hash": "e79336c896ff4fe51217d9ffd82b22fca8459919",
  "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/e79336c896ff4fe51217d9ffd82b22fca8459919",
  "file_path": "lib/updatehub/updatehub.c",
  "func_name": "start_coap_client",
  "func_before": "static bool start_coap_client(void)\n{\n\tstruct addrinfo *addr;\n\tstruct addrinfo hints;\n\tint resolve_attempts = 10;\n\tint ret = -1;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4)) {\n\t\thints.ai_family = AF_INET;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_NONE;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \"5684\";\n#else\n\tint protocol = IPPROTO_UDP;\n\tchar port[] = \"5683\";\n#endif\n\n\twhile (resolve_attempts--) {\n\t\tret = getaddrinfo(UPDATEHUB_SERVER, port, &hints, &addr);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not resolve dns\");\n\t\treturn false;\n\t}\n\n\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n\tif (ctx.sock < 0) {\n\t\tLOG_ERR(\"Failed to create UDP socket\");\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_SEC_TAG_LIST,\n\t\t       sec_list, sizeof(sec_list)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_TAG option\");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_PEER_VERIFY, &verify, sizeof(int)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_PEER_VERIFY option\");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(ctx.sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\t\tLOG_ERR(\"Cannot connect to UDP remote\");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}",
  "abstract_func_before": "static bool start_coap_client(void)\n{\n\tstruct addrinfo *VAR_0;\n\tstruct addrinfo VAR_1;\n\tint VAR_2 = 10;\n\tint VAR_3 = -1;\n\n\tif (IS_ENABLED(VAR_4)) {\n\t\tVAR_1.ai_family = VAR_5;\n\t\tVAR_1.ai_socktype = VAR_6;\n\t} else if (IS_ENABLED(VAR_7)) {\n\t\tVAR_1.ai_family = VAR_8;\n\t\tVAR_1.ai_socktype = VAR_6;\n\t}\n\n#if defined(VAR_9)\n\tint VAR_10 = VAR_11;\n\tsec_tag_t VAR_12[] = { VAR_13 };\n\tint VAR_14 = VAR_15;\n\tchar VAR_16[] = \"5684\";\n#else\n\tint VAR_14 = VAR_17;\n\tchar VAR_16[] = \"5683\";\n#endif\n\n\twhile (VAR_2--) {\n\t\tVAR_3 = getaddrinfo(VAR_18, VAR_16, &VAR_1, &VAR_0);\n\t\tif (VAR_3 == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (VAR_3 < 0) {\n\t\tLOG_ERR(\"Could not resolve dns\");\n\t\treturn false;\n\t}\n\n\tVAR_19.sock = socket(VAR_0->ai_family, VAR_20, VAR_14);\n\tif (VAR_19.sock < 0) {\n\t\tLOG_ERR(\"Failed to create UDP socket\");\n\t\treturn false;\n\t}\n\n#if defined(VAR_9)\n\tif (setsockopt(VAR_19.sock, VAR_21, VAR_22,\n\t\t       VAR_12, sizeof(VAR_12)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_TAG option\");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(VAR_19.sock, VAR_21, VAR_23, &VAR_10, sizeof(int)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_PEER_VERIFY option\");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(VAR_19.sock, VAR_0->ai_addr, VAR_0->ai_addrlen) < 0) {\n\t\tLOG_ERR(\"Cannot connect to UDP remote\");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}",
  "func_graph_path_before": "zephyrproject-rtos/zephyr/e79336c896ff4fe51217d9ffd82b22fca8459919/updatehub.c/vul/before/0.json",
  "func": "static bool start_coap_client(void)\n{\n\tstruct addrinfo *addr;\n\tstruct addrinfo hints;\n\tint resolve_attempts = 10;\n\tint ret = -1;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4)) {\n\t\thints.ai_family = AF_INET;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_REQUIRED;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \"5684\";\n#else\n\tint protocol = IPPROTO_UDP;\n\tchar port[] = \"5683\";\n#endif\n\n\twhile (resolve_attempts--) {\n\t\tret = getaddrinfo(UPDATEHUB_SERVER, port, &hints, &addr);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not resolve dns\");\n\t\treturn false;\n\t}\n\n\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n\tif (ctx.sock < 0) {\n\t\tLOG_ERR(\"Failed to create UDP socket\");\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_SEC_TAG_LIST,\n\t\t       sec_list, sizeof(sec_list)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_TAG option\");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_PEER_VERIFY, &verify, sizeof(int)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_PEER_VERIFY option\");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(ctx.sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\t\tLOG_ERR(\"Cannot connect to UDP remote\");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}",
  "abstract_func": "static bool start_coap_client(void)\n{\n\tstruct addrinfo *VAR_0;\n\tstruct addrinfo VAR_1;\n\tint VAR_2 = 10;\n\tint VAR_3 = -1;\n\n\tif (IS_ENABLED(VAR_4)) {\n\t\tVAR_1.ai_family = VAR_5;\n\t\tVAR_1.ai_socktype = VAR_6;\n\t} else if (IS_ENABLED(VAR_7)) {\n\t\tVAR_1.ai_family = VAR_8;\n\t\tVAR_1.ai_socktype = VAR_6;\n\t}\n\n#if defined(VAR_9)\n\tint VAR_10 = VAR_11;\n\tsec_tag_t VAR_12[] = { VAR_13 };\n\tint VAR_14 = VAR_15;\n\tchar VAR_16[] = \"5684\";\n#else\n\tint VAR_14 = VAR_17;\n\tchar VAR_16[] = \"5683\";\n#endif\n\n\twhile (VAR_2--) {\n\t\tVAR_3 = getaddrinfo(VAR_18, VAR_16, &VAR_1, &VAR_0);\n\t\tif (VAR_3 == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (VAR_3 < 0) {\n\t\tLOG_ERR(\"Could not resolve dns\");\n\t\treturn false;\n\t}\n\n\tVAR_19.sock = socket(VAR_0->ai_family, VAR_20, VAR_14);\n\tif (VAR_19.sock < 0) {\n\t\tLOG_ERR(\"Failed to create UDP socket\");\n\t\treturn false;\n\t}\n\n#if defined(VAR_9)\n\tif (setsockopt(VAR_19.sock, VAR_21, VAR_22,\n\t\t       VAR_12, sizeof(VAR_12)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_TAG option\");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(VAR_19.sock, VAR_21, VAR_23, &VAR_10, sizeof(int)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_PEER_VERIFY option\");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(VAR_19.sock, VAR_0->ai_addr, VAR_0->ai_addrlen) < 0) {\n\t\tLOG_ERR(\"Cannot connect to UDP remote\");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}",
  "func_graph_path": "zephyrproject-rtos/zephyr/e79336c896ff4fe51217d9ffd82b22fca8459919/updatehub.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \t}\n \n #if defined(CONFIG_UPDATEHUB_DTLS)\n-\tint verify = TLS_PEER_VERIFY_NONE;\n+\tint verify = TLS_PEER_VERIFY_REQUIRED;\n \tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n \tint protocol = IPPROTO_DTLS_1_2;\n \tchar port[] = \"5684\";",
  "diff_line_info": {
    "deleted_lines": [
      "\tint verify = TLS_PEER_VERIFY_NONE;"
    ],
    "added_lines": [
      "\tint verify = TLS_PEER_VERIFY_REQUIRED;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zephyrproject-rtos/zephyr/pull/24954",
  "description": {
    "pr_info": {
      "title": "updatehub: Require peer verification with DTLS",
      "number": 24954
    },
    "comment": [
      "DTLS without peer verification offers no security whatsoever (and is\r\narguably worse than not using DTLS in the first place).\r\n\r\nChange the verification option to require this peer verification.  To\r\nuse this, it may be necessary to install and use a root certificate.\r\n\r\nSigned-off-by: David Brown <david.brown@linaro.org>",
      "Hi David, thank you for this update.\r\nCC @otavio "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}