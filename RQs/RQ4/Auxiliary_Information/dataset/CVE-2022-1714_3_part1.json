{
  "cve_id": "CVE-2022-1714",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix 4 byte oobread in msp430 disassembler ##crash\n\n* Only crashes with asan builds\n* Add missing =SN register\n* Reported by cnitlrt via huntrdev\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0",
  "commit_hash": "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "git_url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "file_path": "libr/bin/format/elf/elf.c",
  "func_name": "init_ehdr",
  "func_before": "static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_ERROR (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,\"\n\t\t\t\" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,\"\n\t\t\t\" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,\"\n\t\t\t\" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,\"\n\t\t\t\" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,\"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,\"\n\t\t\t\" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,\"\n\t\t\t\" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,\"\n\t\t\t\" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,\"\n\t\t\t\" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,\"\n\t\t\t\" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,\"\n\t\t\t\" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,\"\n\t\t\t\" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,\"\n\t\t\t\" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,\"\n\t\t\t\" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,\"\n\t\t\t\" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,\"\n\t\t\t\" EM_TI_ARP32=143, EM_TI_PRU=144,\"\n\t\t\t\" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,\"\n\t\t\t\" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,\"\n\t\t\t\" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,\"\n\t\t\t\" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,\"\n\t\t\t\" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,\"\n\t\t\t\" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,\"\n\t\t\t\" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,\"\n\t\t\t\" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,\"\n\t\t\t\" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,\"\n\t\t\t\" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,\"\n\t\t\t\" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,\"\n\t\t\t\" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,\"\n\t\t\t\" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,\"\n\t\t\t\" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}\", 0);\n\tsdb_set (bin->kv, \"elf_class.cparse\", \"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\", 0);\n\tsdb_set (bin->kv, \"elf_data.cparse\", \"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};\", 0);\n\tsdb_set (bin->kv, \"elf_hdr_version.cparse\", \"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_set (bin->kv, \"elf_obj_version.cparse\", \"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_num_set (bin->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (bin->kv, \"elf_header.size\", sizeof (Elf_(Ehdr)), 0);\n\tsdb_set (bin->kv, \"elf_ident.format\", \"[4]z[1]E[1]E[1]E.::\"\n\t\t\t\" magic (elf_class)class (elf_data)data (elf_hdr_version)version\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]EqqqxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_ERROR (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t// TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);\n\tbin->ehdr.e_machine = READ16 (ehdr, i);\n\tbin->ehdr.e_version = READ32 (ehdr, i);\n#if R_BIN_ELF64\n\tbin->ehdr.e_entry = READ64 (ehdr, i);\n\tbin->ehdr.e_phoff = READ64 (ehdr, i);\n\tbin->ehdr.e_shoff = READ64 (ehdr, i);\n#else\n\tbin->ehdr.e_entry = READ32 (ehdr, i);\n\tbin->ehdr.e_phoff = READ32 (ehdr, i);\n\tbin->ehdr.e_shoff = READ32 (ehdr, i);\n#endif\n\tbin->ehdr.e_flags = READ32 (ehdr, i);\n\tbin->ehdr.e_ehsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_shnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shstrndx = READ16 (ehdr, i);\n\treturn true;\n\t// [Outdated] Usage example:\n\t// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`\n\t// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`\n}",
  "abstract_func_before": "static bool init_ehdr(ELFOBJ *VAR_0) {\n\tut8 VAR_1[VAR_2];\n\tut8 VAR_3[sizeof (Elf_(VAR_4))] = {0};\n\tint VAR_5, VAR_6;\n\tif (r_buf_read_at (VAR_0->b, 0, VAR_1, VAR_2) == -1) {\n\t\tR_LOG_ERROR (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (VAR_0->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (VAR_0->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,\"\n\t\t\t\" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,\"\n\t\t\t\" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,\"\n\t\t\t\" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,\"\n\t\t\t\" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,\"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,\"\n\t\t\t\" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,\"\n\t\t\t\" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,\"\n\t\t\t\" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,\"\n\t\t\t\" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,\"\n\t\t\t\" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,\"\n\t\t\t\" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,\"\n\t\t\t\" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,\"\n\t\t\t\" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,\"\n\t\t\t\" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,\"\n\t\t\t\" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,\"\n\t\t\t\" EM_TI_ARP32=143, EM_TI_PRU=144,\"\n\t\t\t\" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,\"\n\t\t\t\" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,\"\n\t\t\t\" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,\"\n\t\t\t\" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,\"\n\t\t\t\" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,\"\n\t\t\t\" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,\"\n\t\t\t\" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,\"\n\t\t\t\" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,\"\n\t\t\t\" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,\"\n\t\t\t\" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,\"\n\t\t\t\" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,\"\n\t\t\t\" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,\"\n\t\t\t\" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,\"\n\t\t\t\" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}\", 0);\n\tsdb_set (VAR_0->kv, \"elf_class.cparse\", \"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_data.cparse\", \"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_hdr_version.cparse\", \"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_obj_version.cparse\", \"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_num_set (VAR_0->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (VAR_0->kv, \"elf_header.size\", sizeof (Elf_(VAR_4)), 0);\n\tsdb_set (VAR_0->kv, \"elf_ident.format\", \"[4]z[1]E[1]E[1]E.::\"\n\t\t\t\" magic (elf_class)class (elf_data)data (elf_hdr_version)version\", 0);\n#if VAR_7\n\tsdb_set (VAR_0->kv, \"elf_header.format\", \"?[2]E[2]E[4]EqqqxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (VAR_0->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tVAR_0->endian = (VAR_1[VAR_8] == VAR_9)? 1: 0;\n\tmemset (&VAR_0->ehdr, 0, sizeof (Elf_(VAR_4)));\n\tVAR_6 = r_buf_read_at (VAR_0->b, 0, VAR_3, sizeof (VAR_3));\n\tif (VAR_6 < 32) { /* COMMENT_0 */\n\t\tR_LOG_ERROR (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t/* COMMENT_1 */\n\tmemcpy (&VAR_0->ehdr.e_ident, VAR_3, 16);\n\tif (!__is_valid_ident (VAR_0)) {\n\t\treturn false;\n\t}\n\tVAR_5 = 16;\n\t/* COMMENT_2 */\n\tVAR_0->ehdr.e_type = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_machine = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_version = READ32 (VAR_3, VAR_5);\n#if VAR_7\n\tVAR_0->ehdr.e_entry = READ64 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phoff = READ64 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shoff = READ64 (VAR_3, VAR_5);\n#else\n\tVAR_0->ehdr.e_entry = READ32 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phoff = READ32 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shoff = READ32 (VAR_3, VAR_5);\n#endif\n\tVAR_0->ehdr.e_flags = READ32 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_ehsize = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phentsize = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phnum = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shentsize = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shnum = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shstrndx = READ16 (VAR_3, VAR_5);\n\treturn true;\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n}",
  "func_graph_path_before": "radareorg/radare2/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e/elf.c/vul/before/2.json",
  "func": "static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_DEBUG (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,\"\n\t\t\t\" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,\"\n\t\t\t\" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,\"\n\t\t\t\" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,\"\n\t\t\t\" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,\"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,\"\n\t\t\t\" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,\"\n\t\t\t\" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,\"\n\t\t\t\" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,\"\n\t\t\t\" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,\"\n\t\t\t\" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,\"\n\t\t\t\" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,\"\n\t\t\t\" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,\"\n\t\t\t\" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,\"\n\t\t\t\" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,\"\n\t\t\t\" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,\"\n\t\t\t\" EM_TI_ARP32=143, EM_TI_PRU=144,\"\n\t\t\t\" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,\"\n\t\t\t\" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,\"\n\t\t\t\" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,\"\n\t\t\t\" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,\"\n\t\t\t\" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,\"\n\t\t\t\" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,\"\n\t\t\t\" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,\"\n\t\t\t\" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,\"\n\t\t\t\" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,\"\n\t\t\t\" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,\"\n\t\t\t\" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,\"\n\t\t\t\" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,\"\n\t\t\t\" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,\"\n\t\t\t\" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}\", 0);\n\tsdb_set (bin->kv, \"elf_class.cparse\", \"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\", 0);\n\tsdb_set (bin->kv, \"elf_data.cparse\", \"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};\", 0);\n\tsdb_set (bin->kv, \"elf_hdr_version.cparse\", \"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_set (bin->kv, \"elf_obj_version.cparse\", \"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_num_set (bin->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (bin->kv, \"elf_header.size\", sizeof (Elf_(Ehdr)), 0);\n\tsdb_set (bin->kv, \"elf_ident.format\", \"[4]z[1]E[1]E[1]E.::\"\n\t\t\t\" magic (elf_class)class (elf_data)data (elf_hdr_version)version\", 0);\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]EqqqxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_DEBUG (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t// TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);\n\tbin->ehdr.e_machine = READ16 (ehdr, i);\n\tbin->ehdr.e_version = READ32 (ehdr, i);\n#if R_BIN_ELF64\n\tbin->ehdr.e_entry = READ64 (ehdr, i);\n\tbin->ehdr.e_phoff = READ64 (ehdr, i);\n\tbin->ehdr.e_shoff = READ64 (ehdr, i);\n#else\n\tbin->ehdr.e_entry = READ32 (ehdr, i);\n\tbin->ehdr.e_phoff = READ32 (ehdr, i);\n\tbin->ehdr.e_shoff = READ32 (ehdr, i);\n#endif\n\tbin->ehdr.e_flags = READ32 (ehdr, i);\n\tbin->ehdr.e_ehsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_phnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shentsize = READ16 (ehdr, i);\n\tbin->ehdr.e_shnum = READ16 (ehdr, i);\n\tbin->ehdr.e_shstrndx = READ16 (ehdr, i);\n\treturn true;\n\t// [Outdated] Usage example:\n\t// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`\n\t// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`\n}",
  "abstract_func": "static bool init_ehdr(ELFOBJ *VAR_0) {\n\tut8 VAR_1[VAR_2];\n\tut8 VAR_3[sizeof (Elf_(VAR_4))] = {0};\n\tint VAR_5, VAR_6;\n\tif (r_buf_read_at (VAR_0->b, 0, VAR_1, VAR_2) == -1) {\n\t\tR_LOG_DEBUG (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (VAR_0->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (VAR_0->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,\"\n\t\t\t\" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,\"\n\t\t\t\" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,\"\n\t\t\t\" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,\"\n\t\t\t\" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,\"\n\t\t\t\" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,\"\n\t\t\t\" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,\"\n\t\t\t\" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,\"\n\t\t\t\" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,\"\n\t\t\t\" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,\"\n\t\t\t\" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,\"\n\t\t\t\" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,\"\n\t\t\t\" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,\"\n\t\t\t\" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,\"\n\t\t\t\" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,\"\n\t\t\t\" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,\"\n\t\t\t\" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,\"\n\t\t\t\" EM_TI_ARP32=143, EM_TI_PRU=144,\"\n\t\t\t\" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,\"\n\t\t\t\" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,\"\n\t\t\t\" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,\"\n\t\t\t\" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,\"\n\t\t\t\" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,\"\n\t\t\t\" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,\"\n\t\t\t\" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,\"\n\t\t\t\" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,\"\n\t\t\t\" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,\"\n\t\t\t\" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,\"\n\t\t\t\" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,\"\n\t\t\t\" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,\"\n\t\t\t\" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,\"\n\t\t\t\" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}\", 0);\n\tsdb_set (VAR_0->kv, \"elf_class.cparse\", \"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_data.cparse\", \"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_hdr_version.cparse\", \"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_obj_version.cparse\", \"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};\", 0);\n\tsdb_num_set (VAR_0->kv, \"elf_header.offset\", 0, 0);\n\tsdb_num_set (VAR_0->kv, \"elf_header.size\", sizeof (Elf_(VAR_4)), 0);\n\tsdb_set (VAR_0->kv, \"elf_ident.format\", \"[4]z[1]E[1]E[1]E.::\"\n\t\t\t\" magic (elf_class)class (elf_data)data (elf_hdr_version)version\", 0);\n#if VAR_7\n\tsdb_set (VAR_0->kv, \"elf_header.format\", \"?[2]E[2]E[4]EqqqxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (VAR_0->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tVAR_0->endian = (VAR_1[VAR_8] == VAR_9)? 1: 0;\n\tmemset (&VAR_0->ehdr, 0, sizeof (Elf_(VAR_4)));\n\tVAR_6 = r_buf_read_at (VAR_0->b, 0, VAR_3, sizeof (VAR_3));\n\tif (VAR_6 < 32) { /* COMMENT_0 */\n\t\tR_LOG_DEBUG (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t/* COMMENT_1 */\n\tmemcpy (&VAR_0->ehdr.e_ident, VAR_3, 16);\n\tif (!__is_valid_ident (VAR_0)) {\n\t\treturn false;\n\t}\n\tVAR_5 = 16;\n\t/* COMMENT_2 */\n\tVAR_0->ehdr.e_type = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_machine = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_version = READ32 (VAR_3, VAR_5);\n#if VAR_7\n\tVAR_0->ehdr.e_entry = READ64 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phoff = READ64 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shoff = READ64 (VAR_3, VAR_5);\n#else\n\tVAR_0->ehdr.e_entry = READ32 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phoff = READ32 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shoff = READ32 (VAR_3, VAR_5);\n#endif\n\tVAR_0->ehdr.e_flags = READ32 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_ehsize = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phentsize = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_phnum = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shentsize = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shnum = READ16 (VAR_3, VAR_5);\n\tVAR_0->ehdr.e_shstrndx = READ16 (VAR_3, VAR_5);\n\treturn true;\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n}",
  "func_graph_path": "radareorg/radare2/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e/elf.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n \tint i, len;\n \tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n-\t\tR_LOG_ERROR (\"read (magic)\");\n+\t\tR_LOG_DEBUG (\"read (magic)\");\n \t\treturn false;\n \t}\n \tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n@@ -67,7 +67,7 @@\n \tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n \tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n \tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n-\t\tR_LOG_ERROR (\"read (ehdr)\");\n+\t\tR_LOG_DEBUG (\"read (ehdr)\");\n \t\treturn false;\n \t}\n \t// XXX no need to check twice",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tR_LOG_ERROR (\"read (magic)\");",
      "\t\tR_LOG_ERROR (\"read (ehdr)\");"
    ],
    "added_lines": [
      "\t\tR_LOG_DEBUG (\"read (magic)\");",
      "\t\tR_LOG_DEBUG (\"read (ehdr)\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/20097",
  "description": {
    "pr_info": {
      "title": "Fix 4 byte oobread in msp430 disassembler ##crash",
      "number": 20097
    },
    "comment": [
      "* Only crashes with asan builds\r\n* Add missing =SN register\r\n* Reported by cnitlrt via huntrdev\r\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95  \nThe commit message and code changes clearly indicate a fix for an out-of-bounds read vulnerability, which is a security issue.  \n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message mentions \"Fix 4 byte oobread\" and \"crashes with ASAN,\" indicating a security issue. The code diff changes logging levels, likely part of the fix.\n2. **Consistency Check:** The changes align with the issue description, suggesting a security fix.\n3. **Purpose Evaluation:** The purpose is to fix a crash due to an out-of-bounds read, a security vulnerability.\n4. **Security Assessment:** The patch addresses a known security issue with a bounty, confirming it's a security fix.\n5. **Confidence Scoring:** High confidence due to clear alignment between commit message and code changes, with security indicators like ASAN and bounty."
}