{
  "cve_id": "CVE-2021-40529",
  "cwe_ids": [
    "CWE-327"
  ],
  "cvss_vector": "AV:N/AC:H/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "randombit/botan",
  "commit_msg": "Avoid using short exponents with ElGamal\n\nSome off-brand PGP implementation generates keys where p - 1 is\nsmooth, as a result short exponents can leak enough information about\nk to allow decryption.",
  "commit_hash": "9a23e4e3bc3966340531f2ff608fa9d33b5185a2",
  "git_url": "https://github.com/randombit/botan/commit/9a23e4e3bc3966340531f2ff608fa9d33b5185a2",
  "file_path": "src/lib/pubkey/elgamal/elgamal.cpp",
  "func_name": "ElGamal_Encryption_Operation::raw_encrypt",
  "func_before": "secure_vector<uint8_t>\nElGamal_Encryption_Operation::raw_encrypt(const uint8_t msg[], size_t msg_len,\n                                          RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len);\n\n   if(m >= m_group.get_p())\n      throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n\n   const size_t k_bits = m_group.exponent_bits();\n   const BigInt k(rng, k_bits);\n\n   const BigInt a = m_group.power_g_p(k, k_bits);\n   const BigInt b = m_group.multiply_mod_p(m, monty_execute(*m_monty_y_p, k, k_bits));\n\n   return BigInt::encode_fixed_length_int_pair(a, b, m_group.p_bytes());\n   }",
  "abstract_func_before": "secure_vector<uint8_t>\nElGamal_Encryption_Operation::raw_encrypt(const uint8_t VAR_0[], size_t VAR_1,\n                                          RandomNumberGenerator& VAR_2)\n   {\n   BigInt m(msg, msg_len);\n\n   if(VAR_3 >= VAR_4.get_p())\n      throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n\n   const size_t VAR_5 = VAR_4.exponent_bits();\n   const BigInt k(rng, k_bits);\n\n   const BigInt VAR_6 = VAR_4.power_g_p(VAR_7, k_bits);\n   const BigInt VAR_8 = VAR_4.multiply_mod_p(VAR_3, monty_execute(*VAR_9, VAR_7, k_bits));\n\n   return BigInt::encode_fixed_length_int_pair(VAR_6, VAR_8, VAR_4.p_bytes());\n   }",
  "func_graph_path_before": "randombit/botan/9a23e4e3bc3966340531f2ff608fa9d33b5185a2/elgamal.cpp/vul/before/0.json",
  "func": "secure_vector<uint8_t>\nElGamal_Encryption_Operation::raw_encrypt(const uint8_t msg[], size_t msg_len,\n                                          RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len);\n\n   if(m >= m_group.get_p())\n      throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n\n   /*\n   Some ElGamal implementations foolishly use prime fields where p - 1 is\n   smooth, as a result it is unsafe to use short exponents.\n   */\n   const size_t k_bits = m_group.p_bits() - 1;\n   const BigInt k(rng, k_bits, false);\n\n   const BigInt a = m_group.power_g_p(k, k_bits);\n   const BigInt b = m_group.multiply_mod_p(m, monty_execute(*m_monty_y_p, k, k_bits));\n\n   return BigInt::encode_fixed_length_int_pair(a, b, m_group.p_bytes());\n   }",
  "abstract_func": "secure_vector<uint8_t>\nElGamal_Encryption_Operation::raw_encrypt(const uint8_t VAR_0[], size_t VAR_1,\n                                          RandomNumberGenerator& VAR_2)\n   {\n   BigInt m(msg, msg_len);\n\n   if(VAR_3 >= VAR_4.get_p())\n      throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n\n   /* COMMENT_0 */\n                                                                         \n                                                           \n     \n   const size_t VAR_5 = VAR_4.p_bits() - 1;\n   const BigInt k(rng, k_bits, false);\n\n   const BigInt VAR_6 = VAR_4.power_g_p(VAR_7, k_bits);\n   const BigInt VAR_8 = VAR_4.multiply_mod_p(VAR_3, monty_execute(*VAR_9, VAR_7, k_bits));\n\n   return BigInt::encode_fixed_length_int_pair(VAR_6, VAR_8, VAR_4.p_bytes());\n   }",
  "func_graph_path": "randombit/botan/9a23e4e3bc3966340531f2ff608fa9d33b5185a2/elgamal.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,12 @@\n    if(m >= m_group.get_p())\n       throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n \n-   const size_t k_bits = m_group.exponent_bits();\n-   const BigInt k(rng, k_bits);\n+   /*\n+   Some ElGamal implementations foolishly use prime fields where p - 1 is\n+   smooth, as a result it is unsafe to use short exponents.\n+   */\n+   const size_t k_bits = m_group.p_bits() - 1;\n+   const BigInt k(rng, k_bits, false);\n \n    const BigInt a = m_group.power_g_p(k, k_bits);\n    const BigInt b = m_group.multiply_mod_p(m, monty_execute(*m_monty_y_p, k, k_bits));",
  "diff_line_info": {
    "deleted_lines": [
      "   const size_t k_bits = m_group.exponent_bits();",
      "   const BigInt k(rng, k_bits);"
    ],
    "added_lines": [
      "   /*",
      "   Some ElGamal implementations foolishly use prime fields where p - 1 is",
      "   smooth, as a result it is unsafe to use short exponents.",
      "   */",
      "   const size_t k_bits = m_group.p_bits() - 1;",
      "   const BigInt k(rng, k_bits, false);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/randombit/botan/pull/2790",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/randombit/botan/pull/2790: 403 Client Error: Forbidden for url: https://api.github.com/repos/randombit/botan/pulls/2790",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe patch addresses a security vulnerability in the ElGamal encryption method by modifying how exponents are chosen to prevent short exponents, which could be exploited. The commit message and code changes clearly align with the vulnerability description, reinforcing it as a security fix with high confidence."
}