{
  "cve_id": "CVE-2018-20360",
  "cwe_ids": [
    "CWE-119",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "ps_dec: sanitize iid_index before mixing\n\nindex range is supposed to be withing -7 and 7 or -15 and 15 depending on\niid_mode (see Table 8.24, ISO/IEC 14496-3:2005).\n\nIndexes outside these boundaries are likely to be errors and should be\nsanitized to avoid memory corruption. Replace any index under\n-no_iid_steps (-7 or -15 depending on iid_mode) by -no_iid_steps. Replace\nany index above no_iid_steps by no_iid_steps. Try to process further.\n\nThis commit addresses CVE-2019-6956 (fixes #39).",
  "commit_hash": "6823e6610c9af1b0080cb22b9da03efb208d7d57",
  "git_url": "https://github.com/knik0/faad2/commit/6823e6610c9af1b0080cb22b9da03efb208d7d57",
  "file_path": "libfaad/ps_dec.c",
  "func_name": "ps_mix_phase",
  "func_before": "static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],\n                         qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])\n{\n    uint8_t n;\n    uint8_t gr;\n    uint8_t bk = 0;\n    uint8_t sb, maxsb;\n    uint8_t env;\n    uint8_t nr_ipdopd_par;\n    complex_t h11, h12, h21, h22;\n    complex_t H11, H12, H21, H22;\n    complex_t deltaH11, deltaH12, deltaH21, deltaH22;\n    complex_t tempLeft;\n    complex_t tempRight;\n    complex_t phaseLeft;\n    complex_t phaseRight;\n    real_t L;\n    const real_t *sf_iid;\n    uint8_t no_iid_steps;\n\n    if (ps->iid_mode >= 3)\n    {\n        no_iid_steps = 15;\n        sf_iid = sf_iid_fine;\n    } else {\n        no_iid_steps = 7;\n        sf_iid = sf_iid_normal;\n    }\n\n    if (ps->ipd_mode == 0 || ps->ipd_mode == 3)\n    {\n        nr_ipdopd_par = 11; /* resolution */\n    } else {\n        nr_ipdopd_par = ps->nr_ipdopd_par;\n    }\n\n    for (gr = 0; gr < ps->num_groups; gr++)\n    {\n        bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];\n\n        /* use one channel per group in the subqmf domain */\n        maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];\n\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->icc_mode < 3)\n            {\n                /* type 'A' mixing as described in 8.6.4.6.2.1 */\n                real_t c_1, c_2;\n                real_t cosa, sina;\n                real_t cosb, sinb;\n                real_t ab1, ab2;\n                real_t ab3, ab4;\n\n                /*\n                c_1 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps + iid_index] / 10.0)));\n                c_2 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps - iid_index] / 10.0)));\n                alpha = 0.5 * acos(quant_rho[icc_index]);\n                beta = alpha * ( c_1 - c_2 ) / sqrt(2.0);\n                */\n\n                //printf(\"%d\\n\", ps->iid_index[env][bk]);\n\n                /* calculate the scalefactors c_1 and c_2 from the intensity differences */\n                c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];\n                c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];\n\n                /* calculate alpha and beta using the ICC parameters */\n                cosa = cos_alphas[ps->icc_index[env][bk]];\n                sina = sin_alphas[ps->icc_index[env][bk]];\n\n                if (ps->iid_mode >= 3)\n                {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                } else {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                }\n\n                ab1 = MUL_C(cosb, cosa);\n                ab2 = MUL_C(sinb, sina);\n                ab3 = MUL_C(sinb, cosa);\n                ab4 = MUL_C(cosb, sina);\n\n                /* h_xy: COEF */\n                RE(h11) = MUL_C(c_2, (ab1 - ab2));\n                RE(h12) = MUL_C(c_1, (ab1 + ab2));\n                RE(h21) = MUL_C(c_2, (ab3 + ab4));\n                RE(h22) = MUL_C(c_1, (ab3 - ab4));\n            } else {\n                /* type 'B' mixing as described in 8.6.4.6.2.2 */\n                real_t sina, cosa;\n                real_t cosg, sing;\n\n                /*\n                real_t c, rho, mu, alpha, gamma;\n                uint8_t i;\n\n                i = ps->iid_index[env][bk];\n                c = (real_t)pow(10.0, ((i)?(((i>0)?1:-1)*quant_iid[((i>0)?i:-i)-1]):0.)/20.0);\n                rho = quant_rho[ps->icc_index[env][bk]];\n\n                if (rho == 0.0f && c == 1.)\n                {\n                    alpha = (real_t)M_PI/4.0f;\n                    rho = 0.05f;\n                } else {\n                    if (rho <= 0.05f)\n                    {\n                        rho = 0.05f;\n                    }\n                    alpha = 0.5f*(real_t)atan( (2.0f*c*rho) / (c*c-1.0f) );\n\n                    if (alpha < 0.)\n                    {\n                        alpha += (real_t)M_PI/2.0f;\n                    }\n                    if (rho < 0.)\n                    {\n                        alpha += (real_t)M_PI;\n                    }\n                }\n                mu = c+1.0f/c;\n                mu = 1+(4.0f*rho*rho-4.0f)/(mu*mu);\n                gamma = (real_t)atan(sqrt((1.0f-sqrt(mu))/(1.0f+sqrt(mu))));\n                */\n\n                if (ps->iid_mode >= 3)\n                {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                } else {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                }\n\n                RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));\n                RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));\n                RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));\n                RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));\n            }\n\n            /* calculate phase rotation parameters H_xy */\n            /* note that the imaginary part of these parameters are only calculated when\n               IPD and OPD are enabled\n             */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                int8_t i;\n                real_t xy, pq, xypq;\n\n                /* ringbuffer index */\n                i = ps->phase_hist;\n\n                /* previous value */\n#ifdef FIXED_POINT\n                /* divide by 4, shift right 2 bits */\n                RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;\n                IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;\n                RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;\n                IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;\n#else\n                RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n#endif\n\n                /* save current value */\n                RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];\n                IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];\n                RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];\n                IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];\n\n                /* add current value */\n                RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);\n                IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);\n                RE(tempRight) += RE(ps->opd_prev[bk][i]);\n                IM(tempRight) += IM(ps->opd_prev[bk][i]);\n\n                /* ringbuffer index */\n                if (i == 0)\n                {\n                    i = 2;\n                }\n                i--;\n\n                /* get value before previous */\n#ifdef FIXED_POINT\n                /* dividing by 2, shift right 1 bit */\n                RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);\n                IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);\n                RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);\n                IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);\n#else\n                RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* original code */\n                ipd = (float)atan2(IM(tempLeft), RE(tempLeft));\n                opd = (float)atan2(IM(tempRight), RE(tempRight));\n\n                /* phase rotation */\n                RE(phaseLeft) = (float)cos(opd);\n                IM(phaseLeft) = (float)sin(opd);\n                opd -= ipd;\n                RE(phaseRight) = (float)cos(opd);\n                IM(phaseRight) = (float)sin(opd);\n#else\n\n                // x = IM(tempLeft)\n                // y = RE(tempLeft)\n                // p = IM(tempRight)\n                // q = RE(tempRight)\n                // cos(atan2(x,y)) = y/sqrt((x*x) + (y*y))\n                // sin(atan2(x,y)) = x/sqrt((x*x) + (y*y))\n                // cos(atan2(x,y)-atan2(p,q)) = (y*q + x*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n                // sin(atan2(x,y)-atan2(p,q)) = (x*q - y*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n\n                xy = magnitude_c(tempRight);\n                pq = magnitude_c(tempLeft);\n\n                if (xy != 0)\n                {\n                    RE(phaseLeft) = DIV_R(RE(tempRight), xy);\n                    IM(phaseLeft) = DIV_R(IM(tempRight), xy);\n                } else {\n                    RE(phaseLeft) = 0;\n                    IM(phaseLeft) = 0;\n                }\n\n                xypq = MUL_R(xy, pq);\n\n                if (xypq != 0)\n                {\n                    real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));\n                    real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));\n\n                    RE(phaseRight) = DIV_R(tmp1, xypq);\n                    IM(phaseRight) = DIV_R(tmp2, xypq);\n                } else {\n                    RE(phaseRight) = 0;\n                    IM(phaseRight) = 0;\n                }\n\n#endif\n\n                /* MUL_F(COEF, REAL) = COEF */\n                IM(h11) = MUL_R(RE(h11), IM(phaseLeft));\n                IM(h12) = MUL_R(RE(h12), IM(phaseRight));\n                IM(h21) = MUL_R(RE(h21), IM(phaseLeft));\n                IM(h22) = MUL_R(RE(h22), IM(phaseRight));\n\n                RE(h11) = MUL_R(RE(h11), RE(phaseLeft));\n                RE(h12) = MUL_R(RE(h12), RE(phaseRight));\n                RE(h21) = MUL_R(RE(h21), RE(phaseLeft));\n                RE(h22) = MUL_R(RE(h22), RE(phaseRight));\n            }\n\n            /* length of the envelope n_e+1 - n_e (in time samples) */\n            /* 0 < L <= 32: integer */\n            L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);\n\n            /* obtain final H_xy by means of linear interpolation */\n            RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;\n            RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;\n            RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;\n            RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;\n\n            RE(H11) = RE(ps->h11_prev[gr]);\n            RE(H12) = RE(ps->h12_prev[gr]);\n            RE(H21) = RE(ps->h21_prev[gr]);\n            RE(H22) = RE(ps->h22_prev[gr]);\n\n            RE(ps->h11_prev[gr]) = RE(h11);\n            RE(ps->h12_prev[gr]) = RE(h12);\n            RE(ps->h21_prev[gr]) = RE(h21);\n            RE(ps->h22_prev[gr]) = RE(h22);\n\n            /* only calculate imaginary part when needed */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                /* obtain final H_xy by means of linear interpolation */\n                IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;\n                IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;\n                IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;\n                IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;\n\n                IM(H11) = IM(ps->h11_prev[gr]);\n                IM(H12) = IM(ps->h12_prev[gr]);\n                IM(H21) = IM(ps->h21_prev[gr]);\n                IM(H22) = IM(ps->h22_prev[gr]);\n\n                if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)\n                {\n                    IM(deltaH11) = -IM(deltaH11);\n                    IM(deltaH12) = -IM(deltaH12);\n                    IM(deltaH21) = -IM(deltaH21);\n                    IM(deltaH22) = -IM(deltaH22);\n\n                    IM(H11) = -IM(H11);\n                    IM(H12) = -IM(H12);\n                    IM(H21) = -IM(H21);\n                    IM(H22) = -IM(H22);\n                }\n\n                IM(ps->h11_prev[gr]) = IM(h11);\n                IM(ps->h12_prev[gr]) = IM(h12);\n                IM(ps->h21_prev[gr]) = IM(h21);\n                IM(ps->h22_prev[gr]) = IM(h22);\n            }\n\n            /* apply H_xy to the current envelope band of the decorrelated subband */\n            for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)\n            {\n                /* addition finalises the interpolation over every n */\n                RE(H11) += RE(deltaH11);\n                RE(H12) += RE(deltaH12);\n                RE(H21) += RE(deltaH21);\n                RE(H22) += RE(deltaH22);\n                if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                {\n                    IM(H11) += IM(deltaH11);\n                    IM(H12) += IM(deltaH12);\n                    IM(H21) += IM(deltaH21);\n                    IM(H22) += IM(deltaH22);\n                }\n\n                /* channel is an alias to the subband */\n                for (sb = ps->group_border[gr]; sb < maxsb; sb++)\n                {\n                    complex_t inLeft, inRight;\n\n                    /* load decorrelated samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(inLeft) =  RE(X_hybrid_left[n][sb]);\n                        IM(inLeft) =  IM(X_hybrid_left[n][sb]);\n                        RE(inRight) = RE(X_hybrid_right[n][sb]);\n                        IM(inRight) = IM(X_hybrid_right[n][sb]);\n                    } else {\n                        RE(inLeft) =  RE(X_left[n][sb]);\n                        IM(inLeft) =  IM(X_left[n][sb]);\n                        RE(inRight) = RE(X_right[n][sb]);\n                        IM(inRight) = IM(X_right[n][sb]);\n                    }\n\n                    /* apply mixing */\n                    RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));\n                    IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));\n                    RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));\n                    IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));\n\n                    /* only perform imaginary operations when needed */\n                    if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                    {\n                        /* apply rotation */\n                        RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));\n                        IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));\n                        RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));\n                        IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));\n                    }\n\n                    /* store final samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(X_hybrid_left[n][sb])  = RE(tempLeft);\n                        IM(X_hybrid_left[n][sb])  = IM(tempLeft);\n                        RE(X_hybrid_right[n][sb]) = RE(tempRight);\n                        IM(X_hybrid_right[n][sb]) = IM(tempRight);\n                    } else {\n                        RE(X_left[n][sb])  = RE(tempLeft);\n                        IM(X_left[n][sb])  = IM(tempLeft);\n                        RE(X_right[n][sb]) = RE(tempRight);\n                        IM(X_right[n][sb]) = IM(tempRight);\n                    }\n                }\n            }\n\n            /* shift phase smoother's circular buffer index */\n            ps->phase_hist++;\n            if (ps->phase_hist == 2)\n            {\n                ps->phase_hist = 0;\n            }\n        }\n    }\n}",
  "abstract_func_before": "static void ps_mix_phase(ps_info *VAR_0, qmf_t VAR_1[38][64], qmf_t VAR_2[38][64],\n                         qmf_t VAR_3[32][32], qmf_t VAR_4[32][32])\n{\n    uint8_t VAR_5;\n    uint8_t VAR_6;\n    uint8_t VAR_7 = 0;\n    uint8_t VAR_8, VAR_9;\n    uint8_t VAR_10;\n    uint8_t VAR_11;\n    complex_t VAR_12, VAR_13, VAR_14, VAR_15;\n    complex_t VAR_16, VAR_17, VAR_18, VAR_19;\n    complex_t VAR_20, VAR_21, VAR_22, VAR_23;\n    complex_t VAR_24;\n    complex_t VAR_25;\n    complex_t VAR_26;\n    complex_t VAR_27;\n    real_t VAR_28;\n    const real_t *VAR_29;\n    uint8_t VAR_30;\n\n    if (VAR_0->iid_mode >= 3)\n    {\n        VAR_30 = 15;\n        VAR_29 = VAR_31;\n    } else {\n        VAR_30 = 7;\n        VAR_29 = VAR_32;\n    }\n\n    if (VAR_0->ipd_mode == 0 || VAR_0->ipd_mode == 3)\n    {\n        VAR_11 = 11; /* COMMENT_0 */\n    } else {\n        VAR_11 = VAR_0->nr_ipdopd_par;\n    }\n\n    for (VAR_6 = 0; VAR_6 < VAR_0->num_groups; VAR_6++)\n    {\n        VAR_7 = (~VAR_33) & VAR_0->map_group2bk[VAR_6];\n\n        /* COMMENT_1 */\n        VAR_9 = (VAR_6 < VAR_0->num_hybrid_groups) ? VAR_0->group_border[VAR_6] + 1 : VAR_0->group_border[VAR_6 + 1];\n\n        for (VAR_10 = 0; VAR_10 < VAR_0->num_env; VAR_10++)\n        {\n            if (VAR_0->icc_mode < 3)\n            {\n                /* COMMENT_2 */\n                real_t VAR_34, VAR_35;\n                real_t VAR_36, VAR_37;\n                real_t VAR_38, VAR_39;\n                real_t VAR_40, VAR_41;\n                real_t VAR_42, VAR_43;\n\n                /* COMMENT_3 */\n                                                                                                \n                                                                                                \n                                                         \n                                                         \n                  \n\n                /* COMMENT_9 */\n\n                /* COMMENT_10 */\n                VAR_34 = VAR_29[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]];\n                VAR_35 = VAR_29[VAR_30 - VAR_0->iid_index[VAR_10][VAR_7]];\n\n                /* COMMENT_11 */\n                VAR_36 = VAR_44[VAR_0->icc_index[VAR_10][VAR_7]];\n                VAR_37 = VAR_45[VAR_0->icc_index[VAR_10][VAR_7]];\n\n                if (VAR_0->iid_mode >= 3)\n                {\n                    if (VAR_0->iid_index[VAR_10][VAR_7] < 0)\n                    {\n                        VAR_38 =  VAR_46[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = -VAR_47[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    } else {\n                        VAR_38 = VAR_46[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = VAR_47[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    }\n                } else {\n                    if (VAR_0->iid_index[VAR_10][VAR_7] < 0)\n                    {\n                        VAR_38 =  VAR_48[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = -VAR_49[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    } else {\n                        VAR_38 = VAR_48[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = VAR_49[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    }\n                }\n\n                VAR_40 = MUL_C(VAR_38, VAR_36);\n                VAR_41 = MUL_C(VAR_39, VAR_37);\n                VAR_42 = MUL_C(VAR_39, VAR_36);\n                VAR_43 = MUL_C(VAR_38, VAR_37);\n\n                /* COMMENT_12 */\n                RE(VAR_12) = MUL_C(VAR_35, (VAR_40 - VAR_41));\n                RE(VAR_13) = MUL_C(VAR_34, (VAR_40 + VAR_41));\n                RE(VAR_14) = MUL_C(VAR_35, (VAR_42 + VAR_43));\n                RE(VAR_15) = MUL_C(VAR_34, (VAR_42 - VAR_43));\n            } else {\n                /* COMMENT_13 */\n                real_t VAR_37, VAR_36;\n                real_t VAR_50, VAR_51;\n\n                /* COMMENT_14 */\n                                                \n                          \n\n                                           \n                                                                                              \n                                                        \n\n                                           \n                 \n                                              \n                                \n                        \n                                     \n                     \n                                    \n                     \n                                                                           \n\n                                   \n                     \n                                                   \n                     \n                                 \n                     \n                                              \n                     \n                 \n                              \n                                                   \n                                                                            \n                  \n\n                if (VAR_0->iid_mode >= 3)\n                {\n                    uint8_t VAR_52 = abs(VAR_0->iid_index[VAR_10][VAR_7]);\n\n                    VAR_36 = VAR_53[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_37 = VAR_53[30 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_50 = VAR_54[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_51 = VAR_55[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];\n                } else {\n                    uint8_t VAR_52 = abs(VAR_0->iid_index[VAR_10][VAR_7]);\n\n                    VAR_36 = VAR_56[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_37 = VAR_56[14 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_50 = VAR_57[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_51 = VAR_58[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];\n                }\n\n                RE(VAR_12) = MUL_C(VAR_59, MUL_C(VAR_36, VAR_50));\n                RE(VAR_13) = MUL_C(VAR_59, MUL_C(VAR_37, VAR_50));\n                RE(VAR_14) = MUL_C(VAR_59, MUL_C(-VAR_36, VAR_51));\n                RE(VAR_15) = MUL_C(VAR_59, MUL_C(VAR_37, VAR_51));\n            }\n\n            /* COMMENT_40 */\n            /* COMMENT_41 */\n                                      \n               \n            if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n            {\n                int8_t VAR_60;\n                real_t VAR_61, VAR_62, VAR_63;\n\n                /* COMMENT_44 */\n                VAR_60 = VAR_0->phase_hist;\n\n                /* COMMENT_45 */\n#ifdef VAR_64\n                /* COMMENT_46 */\n                RE(VAR_24)  = RE(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 2;\n                IM(VAR_24)  = IM(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 2;\n                RE(VAR_25) = RE(VAR_0->opd_prev[VAR_7][VAR_60]) >> 2;\n                IM(VAR_25) = IM(VAR_0->opd_prev[VAR_7][VAR_60]) >> 2;\n#else\n                RE(VAR_24)  = MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));\n                IM(VAR_24)  = MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));\n                RE(VAR_25) = MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));\n                IM(VAR_25) = MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));\n#endif\n\n                /* COMMENT_47 */\n                RE(VAR_0->ipd_prev[VAR_7][VAR_60]) = VAR_65[abs(VAR_0->ipd_index[VAR_10][VAR_7])];\n                IM(VAR_0->ipd_prev[VAR_7][VAR_60]) = VAR_66[abs(VAR_0->ipd_index[VAR_10][VAR_7])];\n                RE(VAR_0->opd_prev[VAR_7][VAR_60]) = VAR_65[abs(VAR_0->opd_index[VAR_10][VAR_7])];\n                IM(VAR_0->opd_prev[VAR_7][VAR_60]) = VAR_66[abs(VAR_0->opd_index[VAR_10][VAR_7])];\n\n                /* COMMENT_48 */\n                RE(VAR_24)  += RE(VAR_0->ipd_prev[VAR_7][VAR_60]);\n                IM(VAR_24)  += IM(VAR_0->ipd_prev[VAR_7][VAR_60]);\n                RE(VAR_25) += RE(VAR_0->opd_prev[VAR_7][VAR_60]);\n                IM(VAR_25) += IM(VAR_0->opd_prev[VAR_7][VAR_60]);\n\n                /* COMMENT_44 */\n                if (VAR_60 == 0)\n                {\n                    VAR_60 = 2;\n                }\n                VAR_60--;\n\n                /* COMMENT_49 */\n#ifdef VAR_64\n                /* COMMENT_50 */\n                RE(VAR_24)  += (RE(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 1);\n                IM(VAR_24)  += (IM(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 1);\n                RE(VAR_25) += (RE(VAR_0->opd_prev[VAR_7][VAR_60]) >> 1);\n                IM(VAR_25) += (IM(VAR_0->opd_prev[VAR_7][VAR_60]) >> 1);\n#else\n                RE(VAR_24)  += MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));\n                IM(VAR_24)  += MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));\n                RE(VAR_25) += MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));\n                IM(VAR_25) += MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* COMMENT_51 */\n                VAR_67 = (float)atan2(IM(VAR_24), RE(VAR_24));\n                VAR_68 = (float)atan2(IM(VAR_25), RE(VAR_25));\n\n                /* COMMENT_52 */\n                RE(VAR_26) = (float)cos(VAR_68);\n                IM(VAR_26) = (float)sin(VAR_68);\n                VAR_68 -= VAR_67;\n                RE(VAR_27) = (float)cos(VAR_68);\n                IM(VAR_27) = (float)sin(VAR_68);\n#else\n\n                /* COMMENT_53 */\n                /* COMMENT_54 */\n                /* COMMENT_55 */\n                /* COMMENT_56 */\n                /* COMMENT_57 */\n                /* COMMENT_58 */\n                /* COMMENT_59 */\n                /* COMMENT_60 */\n\n                VAR_61 = magnitude_c(VAR_25);\n                VAR_62 = magnitude_c(VAR_24);\n\n                if (VAR_61 != 0)\n                {\n                    RE(VAR_26) = DIV_R(RE(VAR_25), VAR_61);\n                    IM(VAR_26) = DIV_R(IM(VAR_25), VAR_61);\n                } else {\n                    RE(VAR_26) = 0;\n                    IM(VAR_26) = 0;\n                }\n\n                VAR_63 = MUL_R(VAR_61, VAR_62);\n\n                if (VAR_63 != 0)\n                {\n                    real_t VAR_69 = MUL_R(RE(VAR_25), RE(VAR_24)) + MUL_R(IM(VAR_25), IM(VAR_24));\n                    real_t VAR_70 = MUL_R(IM(VAR_25), RE(VAR_24)) - MUL_R(RE(VAR_25), IM(VAR_24));\n\n                    RE(VAR_27) = DIV_R(VAR_69, VAR_63);\n                    IM(VAR_27) = DIV_R(VAR_70, VAR_63);\n                } else {\n                    RE(VAR_27) = 0;\n                    IM(VAR_27) = 0;\n                }\n\n#endif\n\n                /* COMMENT_61 */\n                IM(VAR_12) = MUL_R(RE(VAR_12), IM(VAR_26));\n                IM(VAR_13) = MUL_R(RE(VAR_13), IM(VAR_27));\n                IM(VAR_14) = MUL_R(RE(VAR_14), IM(VAR_26));\n                IM(VAR_15) = MUL_R(RE(VAR_15), IM(VAR_27));\n\n                RE(VAR_12) = MUL_R(RE(VAR_12), RE(VAR_26));\n                RE(VAR_13) = MUL_R(RE(VAR_13), RE(VAR_27));\n                RE(VAR_14) = MUL_R(RE(VAR_14), RE(VAR_26));\n                RE(VAR_15) = MUL_R(RE(VAR_15), RE(VAR_27));\n            }\n\n            /* COMMENT_62 */\n            /* COMMENT_63 */\n            VAR_28 = (real_t)(VAR_0->border_position[VAR_10 + 1] - VAR_0->border_position[VAR_10]);\n\n            /* COMMENT_64 */\n            RE(VAR_20) = (RE(VAR_12) - RE(VAR_0->h11_prev[VAR_6])) / VAR_28;\n            RE(VAR_21) = (RE(VAR_13) - RE(VAR_0->h12_prev[VAR_6])) / VAR_28;\n            RE(VAR_22) = (RE(VAR_14) - RE(VAR_0->h21_prev[VAR_6])) / VAR_28;\n            RE(VAR_23) = (RE(VAR_15) - RE(VAR_0->h22_prev[VAR_6])) / VAR_28;\n\n            RE(VAR_16) = RE(VAR_0->h11_prev[VAR_6]);\n            RE(VAR_17) = RE(VAR_0->h12_prev[VAR_6]);\n            RE(VAR_18) = RE(VAR_0->h21_prev[VAR_6]);\n            RE(VAR_19) = RE(VAR_0->h22_prev[VAR_6]);\n\n            RE(VAR_0->h11_prev[VAR_6]) = RE(VAR_12);\n            RE(VAR_0->h12_prev[VAR_6]) = RE(VAR_13);\n            RE(VAR_0->h21_prev[VAR_6]) = RE(VAR_14);\n            RE(VAR_0->h22_prev[VAR_6]) = RE(VAR_15);\n\n            /* COMMENT_65 */\n            if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n            {\n                /* COMMENT_64 */\n                IM(VAR_20) = (IM(VAR_12) - IM(VAR_0->h11_prev[VAR_6])) / VAR_28;\n                IM(VAR_21) = (IM(VAR_13) - IM(VAR_0->h12_prev[VAR_6])) / VAR_28;\n                IM(VAR_22) = (IM(VAR_14) - IM(VAR_0->h21_prev[VAR_6])) / VAR_28;\n                IM(VAR_23) = (IM(VAR_15) - IM(VAR_0->h22_prev[VAR_6])) / VAR_28;\n\n                IM(VAR_16) = IM(VAR_0->h11_prev[VAR_6]);\n                IM(VAR_17) = IM(VAR_0->h12_prev[VAR_6]);\n                IM(VAR_18) = IM(VAR_0->h21_prev[VAR_6]);\n                IM(VAR_19) = IM(VAR_0->h22_prev[VAR_6]);\n\n                if ((VAR_33 & VAR_0->map_group2bk[VAR_6]) != 0)\n                {\n                    IM(VAR_20) = -IM(VAR_20);\n                    IM(VAR_21) = -IM(VAR_21);\n                    IM(VAR_22) = -IM(VAR_22);\n                    IM(VAR_23) = -IM(VAR_23);\n\n                    IM(VAR_16) = -IM(VAR_16);\n                    IM(VAR_17) = -IM(VAR_17);\n                    IM(VAR_18) = -IM(VAR_18);\n                    IM(VAR_19) = -IM(VAR_19);\n                }\n\n                IM(VAR_0->h11_prev[VAR_6]) = IM(VAR_12);\n                IM(VAR_0->h12_prev[VAR_6]) = IM(VAR_13);\n                IM(VAR_0->h21_prev[VAR_6]) = IM(VAR_14);\n                IM(VAR_0->h22_prev[VAR_6]) = IM(VAR_15);\n            }\n\n            /* COMMENT_66 */\n            for (VAR_5 = VAR_0->border_position[VAR_10]; VAR_5 < VAR_0->border_position[VAR_10 + 1]; VAR_5++)\n            {\n                /* COMMENT_67 */\n                RE(VAR_16) += RE(VAR_20);\n                RE(VAR_17) += RE(VAR_21);\n                RE(VAR_18) += RE(VAR_22);\n                RE(VAR_19) += RE(VAR_23);\n                if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n                {\n                    IM(VAR_16) += IM(VAR_20);\n                    IM(VAR_17) += IM(VAR_21);\n                    IM(VAR_18) += IM(VAR_22);\n                    IM(VAR_19) += IM(VAR_23);\n                }\n\n                /* COMMENT_68 */\n                for (VAR_8 = VAR_0->group_border[VAR_6]; VAR_8 < VAR_9; VAR_8++)\n                {\n                    complex_t VAR_71, VAR_72;\n\n                    /* COMMENT_69 */\n                    if (VAR_6 < VAR_0->num_hybrid_groups)\n                    {\n                        RE(VAR_71) =  RE(VAR_3[VAR_5][VAR_8]);\n                        IM(VAR_71) =  IM(VAR_3[VAR_5][VAR_8]);\n                        RE(VAR_72) = RE(VAR_4[VAR_5][VAR_8]);\n                        IM(VAR_72) = IM(VAR_4[VAR_5][VAR_8]);\n                    } else {\n                        RE(VAR_71) =  RE(VAR_1[VAR_5][VAR_8]);\n                        IM(VAR_71) =  IM(VAR_1[VAR_5][VAR_8]);\n                        RE(VAR_72) = RE(VAR_2[VAR_5][VAR_8]);\n                        IM(VAR_72) = IM(VAR_2[VAR_5][VAR_8]);\n                    }\n\n                    /* COMMENT_70 */\n                    RE(VAR_24) =  MUL_C(RE(VAR_16), RE(VAR_71)) + MUL_C(RE(VAR_18), RE(VAR_72));\n                    IM(VAR_24) =  MUL_C(RE(VAR_16), IM(VAR_71)) + MUL_C(RE(VAR_18), IM(VAR_72));\n                    RE(VAR_25) = MUL_C(RE(VAR_17), RE(VAR_71)) + MUL_C(RE(VAR_19), RE(VAR_72));\n                    IM(VAR_25) = MUL_C(RE(VAR_17), IM(VAR_71)) + MUL_C(RE(VAR_19), IM(VAR_72));\n\n                    /* COMMENT_71 */\n                    if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n                    {\n                        /* COMMENT_72 */\n                        RE(VAR_24)  -= MUL_C(IM(VAR_16), IM(VAR_71)) + MUL_C(IM(VAR_18), IM(VAR_72));\n                        IM(VAR_24)  += MUL_C(IM(VAR_16), RE(VAR_71)) + MUL_C(IM(VAR_18), RE(VAR_72));\n                        RE(VAR_25) -= MUL_C(IM(VAR_17), IM(VAR_71)) + MUL_C(IM(VAR_19), IM(VAR_72));\n                        IM(VAR_25) += MUL_C(IM(VAR_17), RE(VAR_71)) + MUL_C(IM(VAR_19), RE(VAR_72));\n                    }\n\n                    /* COMMENT_73 */\n                    if (VAR_6 < VAR_0->num_hybrid_groups)\n                    {\n                        RE(VAR_3[VAR_5][VAR_8])  = RE(VAR_24);\n                        IM(VAR_3[VAR_5][VAR_8])  = IM(VAR_24);\n                        RE(VAR_4[VAR_5][VAR_8]) = RE(VAR_25);\n                        IM(VAR_4[VAR_5][VAR_8]) = IM(VAR_25);\n                    } else {\n                        RE(VAR_1[VAR_5][VAR_8])  = RE(VAR_24);\n                        IM(VAR_1[VAR_5][VAR_8])  = IM(VAR_24);\n                        RE(VAR_2[VAR_5][VAR_8]) = RE(VAR_25);\n                        IM(VAR_2[VAR_5][VAR_8]) = IM(VAR_25);\n                    }\n                }\n            }\n\n            /* COMMENT_74 */\n            VAR_0->phase_hist++;\n            if (VAR_0->phase_hist == 2)\n            {\n                VAR_0->phase_hist = 0;\n            }\n        }\n    }\n}",
  "func_graph_path_before": "knik0/faad2/6823e6610c9af1b0080cb22b9da03efb208d7d57/ps_dec.c/vul/before/0.json",
  "func": "static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],\n                         qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])\n{\n    uint8_t n;\n    uint8_t gr;\n    uint8_t bk = 0;\n    uint8_t sb, maxsb;\n    uint8_t env;\n    uint8_t nr_ipdopd_par;\n    complex_t h11, h12, h21, h22;\n    complex_t H11, H12, H21, H22;\n    complex_t deltaH11, deltaH12, deltaH21, deltaH22;\n    complex_t tempLeft;\n    complex_t tempRight;\n    complex_t phaseLeft;\n    complex_t phaseRight;\n    real_t L;\n    const real_t *sf_iid;\n    uint8_t no_iid_steps;\n\n    if (ps->iid_mode >= 3)\n    {\n        no_iid_steps = 15;\n        sf_iid = sf_iid_fine;\n    } else {\n        no_iid_steps = 7;\n        sf_iid = sf_iid_normal;\n    }\n\n    if (ps->ipd_mode == 0 || ps->ipd_mode == 3)\n    {\n        nr_ipdopd_par = 11; /* resolution */\n    } else {\n        nr_ipdopd_par = ps->nr_ipdopd_par;\n    }\n\n    for (gr = 0; gr < ps->num_groups; gr++)\n    {\n        bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];\n\n        /* use one channel per group in the subqmf domain */\n        maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];\n\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->icc_mode < 3)\n            {\n                /* type 'A' mixing as described in 8.6.4.6.2.1 */\n                real_t c_1, c_2;\n                real_t cosa, sina;\n                real_t cosb, sinb;\n                real_t ab1, ab2;\n                real_t ab3, ab4;\n\n                /*\n                c_1 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps + iid_index] / 10.0)));\n                c_2 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps - iid_index] / 10.0)));\n                alpha = 0.5 * acos(quant_rho[icc_index]);\n                beta = alpha * ( c_1 - c_2 ) / sqrt(2.0);\n                */\n\n                //printf(\"%d\\n\", ps->iid_index[env][bk]);\n\n                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode\n                   (Table 8.24, ISO/IEC 14496-3:2005).\n                   if it is outside these boundaries, this is most likely an error. sanitize\n                   it and try to process further. */\n                if (ps->iid_index[env][bk] < -no_iid_steps) {\n                    fprintf(stderr, \"Warning: invalid iid_index: %d < %d\\n\", ps->iid_index[env][bk],\n                        -no_iid_steps);\n                    ps->iid_index[env][bk] = -no_iid_steps;\n                } else if (ps->iid_index[env][bk] > no_iid_steps) {\n                    fprintf(stderr, \"Warning: invalid iid_index: %d > %d\\n\", ps->iid_index[env][bk],\n                        no_iid_steps);\n                    ps->iid_index[env][bk] = no_iid_steps;\n                }\n\n                /* calculate the scalefactors c_1 and c_2 from the intensity differences */\n                c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];\n                c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];\n\n                /* calculate alpha and beta using the ICC parameters */\n                cosa = cos_alphas[ps->icc_index[env][bk]];\n                sina = sin_alphas[ps->icc_index[env][bk]];\n\n                if (ps->iid_mode >= 3)\n                {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                } else {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                }\n\n                ab1 = MUL_C(cosb, cosa);\n                ab2 = MUL_C(sinb, sina);\n                ab3 = MUL_C(sinb, cosa);\n                ab4 = MUL_C(cosb, sina);\n\n                /* h_xy: COEF */\n                RE(h11) = MUL_C(c_2, (ab1 - ab2));\n                RE(h12) = MUL_C(c_1, (ab1 + ab2));\n                RE(h21) = MUL_C(c_2, (ab3 + ab4));\n                RE(h22) = MUL_C(c_1, (ab3 - ab4));\n            } else {\n                /* type 'B' mixing as described in 8.6.4.6.2.2 */\n                real_t sina, cosa;\n                real_t cosg, sing;\n\n                /*\n                real_t c, rho, mu, alpha, gamma;\n                uint8_t i;\n\n                i = ps->iid_index[env][bk];\n                c = (real_t)pow(10.0, ((i)?(((i>0)?1:-1)*quant_iid[((i>0)?i:-i)-1]):0.)/20.0);\n                rho = quant_rho[ps->icc_index[env][bk]];\n\n                if (rho == 0.0f && c == 1.)\n                {\n                    alpha = (real_t)M_PI/4.0f;\n                    rho = 0.05f;\n                } else {\n                    if (rho <= 0.05f)\n                    {\n                        rho = 0.05f;\n                    }\n                    alpha = 0.5f*(real_t)atan( (2.0f*c*rho) / (c*c-1.0f) );\n\n                    if (alpha < 0.)\n                    {\n                        alpha += (real_t)M_PI/2.0f;\n                    }\n                    if (rho < 0.)\n                    {\n                        alpha += (real_t)M_PI;\n                    }\n                }\n                mu = c+1.0f/c;\n                mu = 1+(4.0f*rho*rho-4.0f)/(mu*mu);\n                gamma = (real_t)atan(sqrt((1.0f-sqrt(mu))/(1.0f+sqrt(mu))));\n                */\n\n                if (ps->iid_mode >= 3)\n                {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                } else {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                }\n\n                RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));\n                RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));\n                RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));\n                RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));\n            }\n\n            /* calculate phase rotation parameters H_xy */\n            /* note that the imaginary part of these parameters are only calculated when\n               IPD and OPD are enabled\n             */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                int8_t i;\n                real_t xy, pq, xypq;\n\n                /* ringbuffer index */\n                i = ps->phase_hist;\n\n                /* previous value */\n#ifdef FIXED_POINT\n                /* divide by 4, shift right 2 bits */\n                RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;\n                IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;\n                RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;\n                IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;\n#else\n                RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n#endif\n\n                /* save current value */\n                RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];\n                IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];\n                RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];\n                IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];\n\n                /* add current value */\n                RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);\n                IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);\n                RE(tempRight) += RE(ps->opd_prev[bk][i]);\n                IM(tempRight) += IM(ps->opd_prev[bk][i]);\n\n                /* ringbuffer index */\n                if (i == 0)\n                {\n                    i = 2;\n                }\n                i--;\n\n                /* get value before previous */\n#ifdef FIXED_POINT\n                /* dividing by 2, shift right 1 bit */\n                RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);\n                IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);\n                RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);\n                IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);\n#else\n                RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* original code */\n                ipd = (float)atan2(IM(tempLeft), RE(tempLeft));\n                opd = (float)atan2(IM(tempRight), RE(tempRight));\n\n                /* phase rotation */\n                RE(phaseLeft) = (float)cos(opd);\n                IM(phaseLeft) = (float)sin(opd);\n                opd -= ipd;\n                RE(phaseRight) = (float)cos(opd);\n                IM(phaseRight) = (float)sin(opd);\n#else\n\n                // x = IM(tempLeft)\n                // y = RE(tempLeft)\n                // p = IM(tempRight)\n                // q = RE(tempRight)\n                // cos(atan2(x,y)) = y/sqrt((x*x) + (y*y))\n                // sin(atan2(x,y)) = x/sqrt((x*x) + (y*y))\n                // cos(atan2(x,y)-atan2(p,q)) = (y*q + x*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n                // sin(atan2(x,y)-atan2(p,q)) = (x*q - y*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n\n                xy = magnitude_c(tempRight);\n                pq = magnitude_c(tempLeft);\n\n                if (xy != 0)\n                {\n                    RE(phaseLeft) = DIV_R(RE(tempRight), xy);\n                    IM(phaseLeft) = DIV_R(IM(tempRight), xy);\n                } else {\n                    RE(phaseLeft) = 0;\n                    IM(phaseLeft) = 0;\n                }\n\n                xypq = MUL_R(xy, pq);\n\n                if (xypq != 0)\n                {\n                    real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));\n                    real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));\n\n                    RE(phaseRight) = DIV_R(tmp1, xypq);\n                    IM(phaseRight) = DIV_R(tmp2, xypq);\n                } else {\n                    RE(phaseRight) = 0;\n                    IM(phaseRight) = 0;\n                }\n\n#endif\n\n                /* MUL_F(COEF, REAL) = COEF */\n                IM(h11) = MUL_R(RE(h11), IM(phaseLeft));\n                IM(h12) = MUL_R(RE(h12), IM(phaseRight));\n                IM(h21) = MUL_R(RE(h21), IM(phaseLeft));\n                IM(h22) = MUL_R(RE(h22), IM(phaseRight));\n\n                RE(h11) = MUL_R(RE(h11), RE(phaseLeft));\n                RE(h12) = MUL_R(RE(h12), RE(phaseRight));\n                RE(h21) = MUL_R(RE(h21), RE(phaseLeft));\n                RE(h22) = MUL_R(RE(h22), RE(phaseRight));\n            }\n\n            /* length of the envelope n_e+1 - n_e (in time samples) */\n            /* 0 < L <= 32: integer */\n            L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);\n\n            /* obtain final H_xy by means of linear interpolation */\n            RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;\n            RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;\n            RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;\n            RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;\n\n            RE(H11) = RE(ps->h11_prev[gr]);\n            RE(H12) = RE(ps->h12_prev[gr]);\n            RE(H21) = RE(ps->h21_prev[gr]);\n            RE(H22) = RE(ps->h22_prev[gr]);\n\n            RE(ps->h11_prev[gr]) = RE(h11);\n            RE(ps->h12_prev[gr]) = RE(h12);\n            RE(ps->h21_prev[gr]) = RE(h21);\n            RE(ps->h22_prev[gr]) = RE(h22);\n\n            /* only calculate imaginary part when needed */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                /* obtain final H_xy by means of linear interpolation */\n                IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;\n                IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;\n                IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;\n                IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;\n\n                IM(H11) = IM(ps->h11_prev[gr]);\n                IM(H12) = IM(ps->h12_prev[gr]);\n                IM(H21) = IM(ps->h21_prev[gr]);\n                IM(H22) = IM(ps->h22_prev[gr]);\n\n                if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)\n                {\n                    IM(deltaH11) = -IM(deltaH11);\n                    IM(deltaH12) = -IM(deltaH12);\n                    IM(deltaH21) = -IM(deltaH21);\n                    IM(deltaH22) = -IM(deltaH22);\n\n                    IM(H11) = -IM(H11);\n                    IM(H12) = -IM(H12);\n                    IM(H21) = -IM(H21);\n                    IM(H22) = -IM(H22);\n                }\n\n                IM(ps->h11_prev[gr]) = IM(h11);\n                IM(ps->h12_prev[gr]) = IM(h12);\n                IM(ps->h21_prev[gr]) = IM(h21);\n                IM(ps->h22_prev[gr]) = IM(h22);\n            }\n\n            /* apply H_xy to the current envelope band of the decorrelated subband */\n            for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)\n            {\n                /* addition finalises the interpolation over every n */\n                RE(H11) += RE(deltaH11);\n                RE(H12) += RE(deltaH12);\n                RE(H21) += RE(deltaH21);\n                RE(H22) += RE(deltaH22);\n                if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                {\n                    IM(H11) += IM(deltaH11);\n                    IM(H12) += IM(deltaH12);\n                    IM(H21) += IM(deltaH21);\n                    IM(H22) += IM(deltaH22);\n                }\n\n                /* channel is an alias to the subband */\n                for (sb = ps->group_border[gr]; sb < maxsb; sb++)\n                {\n                    complex_t inLeft, inRight;\n\n                    /* load decorrelated samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(inLeft) =  RE(X_hybrid_left[n][sb]);\n                        IM(inLeft) =  IM(X_hybrid_left[n][sb]);\n                        RE(inRight) = RE(X_hybrid_right[n][sb]);\n                        IM(inRight) = IM(X_hybrid_right[n][sb]);\n                    } else {\n                        RE(inLeft) =  RE(X_left[n][sb]);\n                        IM(inLeft) =  IM(X_left[n][sb]);\n                        RE(inRight) = RE(X_right[n][sb]);\n                        IM(inRight) = IM(X_right[n][sb]);\n                    }\n\n                    /* apply mixing */\n                    RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));\n                    IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));\n                    RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));\n                    IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));\n\n                    /* only perform imaginary operations when needed */\n                    if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                    {\n                        /* apply rotation */\n                        RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));\n                        IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));\n                        RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));\n                        IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));\n                    }\n\n                    /* store final samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(X_hybrid_left[n][sb])  = RE(tempLeft);\n                        IM(X_hybrid_left[n][sb])  = IM(tempLeft);\n                        RE(X_hybrid_right[n][sb]) = RE(tempRight);\n                        IM(X_hybrid_right[n][sb]) = IM(tempRight);\n                    } else {\n                        RE(X_left[n][sb])  = RE(tempLeft);\n                        IM(X_left[n][sb])  = IM(tempLeft);\n                        RE(X_right[n][sb]) = RE(tempRight);\n                        IM(X_right[n][sb]) = IM(tempRight);\n                    }\n                }\n            }\n\n            /* shift phase smoother's circular buffer index */\n            ps->phase_hist++;\n            if (ps->phase_hist == 2)\n            {\n                ps->phase_hist = 0;\n            }\n        }\n    }\n}",
  "abstract_func": "static void ps_mix_phase(ps_info *VAR_0, qmf_t VAR_1[38][64], qmf_t VAR_2[38][64],\n                         qmf_t VAR_3[32][32], qmf_t VAR_4[32][32])\n{\n    uint8_t VAR_5;\n    uint8_t VAR_6;\n    uint8_t VAR_7 = 0;\n    uint8_t VAR_8, VAR_9;\n    uint8_t VAR_10;\n    uint8_t VAR_11;\n    complex_t VAR_12, VAR_13, VAR_14, VAR_15;\n    complex_t VAR_16, VAR_17, VAR_18, VAR_19;\n    complex_t VAR_20, VAR_21, VAR_22, VAR_23;\n    complex_t VAR_24;\n    complex_t VAR_25;\n    complex_t VAR_26;\n    complex_t VAR_27;\n    real_t VAR_28;\n    const real_t *VAR_29;\n    uint8_t VAR_30;\n\n    if (VAR_0->iid_mode >= 3)\n    {\n        VAR_30 = 15;\n        VAR_29 = VAR_31;\n    } else {\n        VAR_30 = 7;\n        VAR_29 = VAR_32;\n    }\n\n    if (VAR_0->ipd_mode == 0 || VAR_0->ipd_mode == 3)\n    {\n        VAR_11 = 11; /* COMMENT_0 */\n    } else {\n        VAR_11 = VAR_0->nr_ipdopd_par;\n    }\n\n    for (VAR_6 = 0; VAR_6 < VAR_0->num_groups; VAR_6++)\n    {\n        VAR_7 = (~VAR_33) & VAR_0->map_group2bk[VAR_6];\n\n        /* COMMENT_1 */\n        VAR_9 = (VAR_6 < VAR_0->num_hybrid_groups) ? VAR_0->group_border[VAR_6] + 1 : VAR_0->group_border[VAR_6 + 1];\n\n        for (VAR_10 = 0; VAR_10 < VAR_0->num_env; VAR_10++)\n        {\n            if (VAR_0->icc_mode < 3)\n            {\n                /* COMMENT_2 */\n                real_t VAR_34, VAR_35;\n                real_t VAR_36, VAR_37;\n                real_t VAR_38, VAR_39;\n                real_t VAR_40, VAR_41;\n                real_t VAR_42, VAR_43;\n\n                /* COMMENT_3 */\n                                                                                                \n                                                                                                \n                                                         \n                                                         \n                  \n\n                /* COMMENT_9 */\n\n                /* COMMENT_10 */\n                                                      \n                                                                                            \n                                                    \n                if (VAR_0->iid_index[VAR_10][VAR_7] < -VAR_30) {\n                    fprintf(VAR_44, \"Warning: invalid iid_index: %d < %d\\n\", VAR_0->iid_index[VAR_10][VAR_7],\n                        -VAR_30);\n                    VAR_0->iid_index[VAR_10][VAR_7] = -VAR_30;\n                } else if (VAR_0->iid_index[VAR_10][VAR_7] > VAR_30) {\n                    fprintf(VAR_44, \"Warning: invalid iid_index: %d > %d\\n\", VAR_0->iid_index[VAR_10][VAR_7],\n                        VAR_30);\n                    VAR_0->iid_index[VAR_10][VAR_7] = VAR_30;\n                }\n\n                /* COMMENT_14 */\n                VAR_34 = VAR_29[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]];\n                VAR_35 = VAR_29[VAR_30 - VAR_0->iid_index[VAR_10][VAR_7]];\n\n                /* COMMENT_15 */\n                VAR_36 = VAR_45[VAR_0->icc_index[VAR_10][VAR_7]];\n                VAR_37 = VAR_46[VAR_0->icc_index[VAR_10][VAR_7]];\n\n                if (VAR_0->iid_mode >= 3)\n                {\n                    if (VAR_0->iid_index[VAR_10][VAR_7] < 0)\n                    {\n                        VAR_38 =  VAR_47[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = -VAR_48[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    } else {\n                        VAR_38 = VAR_47[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = VAR_48[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    }\n                } else {\n                    if (VAR_0->iid_index[VAR_10][VAR_7] < 0)\n                    {\n                        VAR_38 =  VAR_49[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = -VAR_50[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    } else {\n                        VAR_38 = VAR_49[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                        VAR_39 = VAR_50[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    }\n                }\n\n                VAR_40 = MUL_C(VAR_38, VAR_36);\n                VAR_41 = MUL_C(VAR_39, VAR_37);\n                VAR_42 = MUL_C(VAR_39, VAR_36);\n                VAR_43 = MUL_C(VAR_38, VAR_37);\n\n                /* COMMENT_16 */\n                RE(VAR_12) = MUL_C(VAR_35, (VAR_40 - VAR_41));\n                RE(VAR_13) = MUL_C(VAR_34, (VAR_40 + VAR_41));\n                RE(VAR_14) = MUL_C(VAR_35, (VAR_42 + VAR_43));\n                RE(VAR_15) = MUL_C(VAR_34, (VAR_42 - VAR_43));\n            } else {\n                /* COMMENT_17 */\n                real_t VAR_37, VAR_36;\n                real_t VAR_51, VAR_52;\n\n                /* COMMENT_18 */\n                                                \n                          \n\n                                           \n                                                                                              \n                                                        \n\n                                           \n                 \n                                              \n                                \n                        \n                                     \n                     \n                                    \n                     \n                                                                           \n\n                                   \n                     \n                                                   \n                     \n                                 \n                     \n                                              \n                     \n                 \n                              \n                                                   \n                                                                            \n                  \n\n                if (VAR_0->iid_mode >= 3)\n                {\n                    uint8_t VAR_53 = abs(VAR_0->iid_index[VAR_10][VAR_7]);\n\n                    VAR_36 = VAR_54[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_37 = VAR_54[30 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_51 = VAR_55[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_52 = VAR_56[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];\n                } else {\n                    uint8_t VAR_53 = abs(VAR_0->iid_index[VAR_10][VAR_7]);\n\n                    VAR_36 = VAR_57[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_37 = VAR_57[14 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_51 = VAR_58[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];\n                    VAR_52 = VAR_59[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];\n                }\n\n                RE(VAR_12) = MUL_C(VAR_60, MUL_C(VAR_36, VAR_51));\n                RE(VAR_13) = MUL_C(VAR_60, MUL_C(VAR_37, VAR_51));\n                RE(VAR_14) = MUL_C(VAR_60, MUL_C(-VAR_36, VAR_52));\n                RE(VAR_15) = MUL_C(VAR_60, MUL_C(VAR_37, VAR_52));\n            }\n\n            /* COMMENT_44 */\n            /* COMMENT_45 */\n                                      \n               \n            if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n            {\n                int8_t VAR_61;\n                real_t VAR_62, VAR_63, VAR_64;\n\n                /* COMMENT_48 */\n                VAR_61 = VAR_0->phase_hist;\n\n                /* COMMENT_49 */\n#ifdef VAR_65\n                /* COMMENT_50 */\n                RE(VAR_24)  = RE(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 2;\n                IM(VAR_24)  = IM(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 2;\n                RE(VAR_25) = RE(VAR_0->opd_prev[VAR_7][VAR_61]) >> 2;\n                IM(VAR_25) = IM(VAR_0->opd_prev[VAR_7][VAR_61]) >> 2;\n#else\n                RE(VAR_24)  = MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));\n                IM(VAR_24)  = MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));\n                RE(VAR_25) = MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));\n                IM(VAR_25) = MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));\n#endif\n\n                /* COMMENT_51 */\n                RE(VAR_0->ipd_prev[VAR_7][VAR_61]) = VAR_66[abs(VAR_0->ipd_index[VAR_10][VAR_7])];\n                IM(VAR_0->ipd_prev[VAR_7][VAR_61]) = VAR_67[abs(VAR_0->ipd_index[VAR_10][VAR_7])];\n                RE(VAR_0->opd_prev[VAR_7][VAR_61]) = VAR_66[abs(VAR_0->opd_index[VAR_10][VAR_7])];\n                IM(VAR_0->opd_prev[VAR_7][VAR_61]) = VAR_67[abs(VAR_0->opd_index[VAR_10][VAR_7])];\n\n                /* COMMENT_52 */\n                RE(VAR_24)  += RE(VAR_0->ipd_prev[VAR_7][VAR_61]);\n                IM(VAR_24)  += IM(VAR_0->ipd_prev[VAR_7][VAR_61]);\n                RE(VAR_25) += RE(VAR_0->opd_prev[VAR_7][VAR_61]);\n                IM(VAR_25) += IM(VAR_0->opd_prev[VAR_7][VAR_61]);\n\n                /* COMMENT_48 */\n                if (VAR_61 == 0)\n                {\n                    VAR_61 = 2;\n                }\n                VAR_61--;\n\n                /* COMMENT_53 */\n#ifdef VAR_65\n                /* COMMENT_54 */\n                RE(VAR_24)  += (RE(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 1);\n                IM(VAR_24)  += (IM(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 1);\n                RE(VAR_25) += (RE(VAR_0->opd_prev[VAR_7][VAR_61]) >> 1);\n                IM(VAR_25) += (IM(VAR_0->opd_prev[VAR_7][VAR_61]) >> 1);\n#else\n                RE(VAR_24)  += MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));\n                IM(VAR_24)  += MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));\n                RE(VAR_25) += MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));\n                IM(VAR_25) += MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* COMMENT_55 */\n                VAR_68 = (float)atan2(IM(VAR_24), RE(VAR_24));\n                VAR_69 = (float)atan2(IM(VAR_25), RE(VAR_25));\n\n                /* COMMENT_56 */\n                RE(VAR_26) = (float)cos(VAR_69);\n                IM(VAR_26) = (float)sin(VAR_69);\n                VAR_69 -= VAR_68;\n                RE(VAR_27) = (float)cos(VAR_69);\n                IM(VAR_27) = (float)sin(VAR_69);\n#else\n\n                /* COMMENT_57 */\n                /* COMMENT_58 */\n                /* COMMENT_59 */\n                /* COMMENT_60 */\n                /* COMMENT_61 */\n                /* COMMENT_62 */\n                /* COMMENT_63 */\n                /* COMMENT_64 */\n\n                VAR_62 = magnitude_c(VAR_25);\n                VAR_63 = magnitude_c(VAR_24);\n\n                if (VAR_62 != 0)\n                {\n                    RE(VAR_26) = DIV_R(RE(VAR_25), VAR_62);\n                    IM(VAR_26) = DIV_R(IM(VAR_25), VAR_62);\n                } else {\n                    RE(VAR_26) = 0;\n                    IM(VAR_26) = 0;\n                }\n\n                VAR_64 = MUL_R(VAR_62, VAR_63);\n\n                if (VAR_64 != 0)\n                {\n                    real_t VAR_70 = MUL_R(RE(VAR_25), RE(VAR_24)) + MUL_R(IM(VAR_25), IM(VAR_24));\n                    real_t VAR_71 = MUL_R(IM(VAR_25), RE(VAR_24)) - MUL_R(RE(VAR_25), IM(VAR_24));\n\n                    RE(VAR_27) = DIV_R(VAR_70, VAR_64);\n                    IM(VAR_27) = DIV_R(VAR_71, VAR_64);\n                } else {\n                    RE(VAR_27) = 0;\n                    IM(VAR_27) = 0;\n                }\n\n#endif\n\n                /* COMMENT_65 */\n                IM(VAR_12) = MUL_R(RE(VAR_12), IM(VAR_26));\n                IM(VAR_13) = MUL_R(RE(VAR_13), IM(VAR_27));\n                IM(VAR_14) = MUL_R(RE(VAR_14), IM(VAR_26));\n                IM(VAR_15) = MUL_R(RE(VAR_15), IM(VAR_27));\n\n                RE(VAR_12) = MUL_R(RE(VAR_12), RE(VAR_26));\n                RE(VAR_13) = MUL_R(RE(VAR_13), RE(VAR_27));\n                RE(VAR_14) = MUL_R(RE(VAR_14), RE(VAR_26));\n                RE(VAR_15) = MUL_R(RE(VAR_15), RE(VAR_27));\n            }\n\n            /* COMMENT_66 */\n            /* COMMENT_67 */\n            VAR_28 = (real_t)(VAR_0->border_position[VAR_10 + 1] - VAR_0->border_position[VAR_10]);\n\n            /* COMMENT_68 */\n            RE(VAR_20) = (RE(VAR_12) - RE(VAR_0->h11_prev[VAR_6])) / VAR_28;\n            RE(VAR_21) = (RE(VAR_13) - RE(VAR_0->h12_prev[VAR_6])) / VAR_28;\n            RE(VAR_22) = (RE(VAR_14) - RE(VAR_0->h21_prev[VAR_6])) / VAR_28;\n            RE(VAR_23) = (RE(VAR_15) - RE(VAR_0->h22_prev[VAR_6])) / VAR_28;\n\n            RE(VAR_16) = RE(VAR_0->h11_prev[VAR_6]);\n            RE(VAR_17) = RE(VAR_0->h12_prev[VAR_6]);\n            RE(VAR_18) = RE(VAR_0->h21_prev[VAR_6]);\n            RE(VAR_19) = RE(VAR_0->h22_prev[VAR_6]);\n\n            RE(VAR_0->h11_prev[VAR_6]) = RE(VAR_12);\n            RE(VAR_0->h12_prev[VAR_6]) = RE(VAR_13);\n            RE(VAR_0->h21_prev[VAR_6]) = RE(VAR_14);\n            RE(VAR_0->h22_prev[VAR_6]) = RE(VAR_15);\n\n            /* COMMENT_69 */\n            if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n            {\n                /* COMMENT_68 */\n                IM(VAR_20) = (IM(VAR_12) - IM(VAR_0->h11_prev[VAR_6])) / VAR_28;\n                IM(VAR_21) = (IM(VAR_13) - IM(VAR_0->h12_prev[VAR_6])) / VAR_28;\n                IM(VAR_22) = (IM(VAR_14) - IM(VAR_0->h21_prev[VAR_6])) / VAR_28;\n                IM(VAR_23) = (IM(VAR_15) - IM(VAR_0->h22_prev[VAR_6])) / VAR_28;\n\n                IM(VAR_16) = IM(VAR_0->h11_prev[VAR_6]);\n                IM(VAR_17) = IM(VAR_0->h12_prev[VAR_6]);\n                IM(VAR_18) = IM(VAR_0->h21_prev[VAR_6]);\n                IM(VAR_19) = IM(VAR_0->h22_prev[VAR_6]);\n\n                if ((VAR_33 & VAR_0->map_group2bk[VAR_6]) != 0)\n                {\n                    IM(VAR_20) = -IM(VAR_20);\n                    IM(VAR_21) = -IM(VAR_21);\n                    IM(VAR_22) = -IM(VAR_22);\n                    IM(VAR_23) = -IM(VAR_23);\n\n                    IM(VAR_16) = -IM(VAR_16);\n                    IM(VAR_17) = -IM(VAR_17);\n                    IM(VAR_18) = -IM(VAR_18);\n                    IM(VAR_19) = -IM(VAR_19);\n                }\n\n                IM(VAR_0->h11_prev[VAR_6]) = IM(VAR_12);\n                IM(VAR_0->h12_prev[VAR_6]) = IM(VAR_13);\n                IM(VAR_0->h21_prev[VAR_6]) = IM(VAR_14);\n                IM(VAR_0->h22_prev[VAR_6]) = IM(VAR_15);\n            }\n\n            /* COMMENT_70 */\n            for (VAR_5 = VAR_0->border_position[VAR_10]; VAR_5 < VAR_0->border_position[VAR_10 + 1]; VAR_5++)\n            {\n                /* COMMENT_71 */\n                RE(VAR_16) += RE(VAR_20);\n                RE(VAR_17) += RE(VAR_21);\n                RE(VAR_18) += RE(VAR_22);\n                RE(VAR_19) += RE(VAR_23);\n                if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n                {\n                    IM(VAR_16) += IM(VAR_20);\n                    IM(VAR_17) += IM(VAR_21);\n                    IM(VAR_18) += IM(VAR_22);\n                    IM(VAR_19) += IM(VAR_23);\n                }\n\n                /* COMMENT_72 */\n                for (VAR_8 = VAR_0->group_border[VAR_6]; VAR_8 < VAR_9; VAR_8++)\n                {\n                    complex_t VAR_72, VAR_73;\n\n                    /* COMMENT_73 */\n                    if (VAR_6 < VAR_0->num_hybrid_groups)\n                    {\n                        RE(VAR_72) =  RE(VAR_3[VAR_5][VAR_8]);\n                        IM(VAR_72) =  IM(VAR_3[VAR_5][VAR_8]);\n                        RE(VAR_73) = RE(VAR_4[VAR_5][VAR_8]);\n                        IM(VAR_73) = IM(VAR_4[VAR_5][VAR_8]);\n                    } else {\n                        RE(VAR_72) =  RE(VAR_1[VAR_5][VAR_8]);\n                        IM(VAR_72) =  IM(VAR_1[VAR_5][VAR_8]);\n                        RE(VAR_73) = RE(VAR_2[VAR_5][VAR_8]);\n                        IM(VAR_73) = IM(VAR_2[VAR_5][VAR_8]);\n                    }\n\n                    /* COMMENT_74 */\n                    RE(VAR_24) =  MUL_C(RE(VAR_16), RE(VAR_72)) + MUL_C(RE(VAR_18), RE(VAR_73));\n                    IM(VAR_24) =  MUL_C(RE(VAR_16), IM(VAR_72)) + MUL_C(RE(VAR_18), IM(VAR_73));\n                    RE(VAR_25) = MUL_C(RE(VAR_17), RE(VAR_72)) + MUL_C(RE(VAR_19), RE(VAR_73));\n                    IM(VAR_25) = MUL_C(RE(VAR_17), IM(VAR_72)) + MUL_C(RE(VAR_19), IM(VAR_73));\n\n                    /* COMMENT_75 */\n                    if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))\n                    {\n                        /* COMMENT_76 */\n                        RE(VAR_24)  -= MUL_C(IM(VAR_16), IM(VAR_72)) + MUL_C(IM(VAR_18), IM(VAR_73));\n                        IM(VAR_24)  += MUL_C(IM(VAR_16), RE(VAR_72)) + MUL_C(IM(VAR_18), RE(VAR_73));\n                        RE(VAR_25) -= MUL_C(IM(VAR_17), IM(VAR_72)) + MUL_C(IM(VAR_19), IM(VAR_73));\n                        IM(VAR_25) += MUL_C(IM(VAR_17), RE(VAR_72)) + MUL_C(IM(VAR_19), RE(VAR_73));\n                    }\n\n                    /* COMMENT_77 */\n                    if (VAR_6 < VAR_0->num_hybrid_groups)\n                    {\n                        RE(VAR_3[VAR_5][VAR_8])  = RE(VAR_24);\n                        IM(VAR_3[VAR_5][VAR_8])  = IM(VAR_24);\n                        RE(VAR_4[VAR_5][VAR_8]) = RE(VAR_25);\n                        IM(VAR_4[VAR_5][VAR_8]) = IM(VAR_25);\n                    } else {\n                        RE(VAR_1[VAR_5][VAR_8])  = RE(VAR_24);\n                        IM(VAR_1[VAR_5][VAR_8])  = IM(VAR_24);\n                        RE(VAR_2[VAR_5][VAR_8]) = RE(VAR_25);\n                        IM(VAR_2[VAR_5][VAR_8]) = IM(VAR_25);\n                    }\n                }\n            }\n\n            /* COMMENT_78 */\n            VAR_0->phase_hist++;\n            if (VAR_0->phase_hist == 2)\n            {\n                VAR_0->phase_hist = 0;\n            }\n        }\n    }\n}",
  "func_graph_path": "knik0/faad2/6823e6610c9af1b0080cb22b9da03efb208d7d57/ps_dec.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -61,6 +61,20 @@\n \n                 //printf(\"%d\\n\", ps->iid_index[env][bk]);\n \n+                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode\n+                   (Table 8.24, ISO/IEC 14496-3:2005).\n+                   if it is outside these boundaries, this is most likely an error. sanitize\n+                   it and try to process further. */\n+                if (ps->iid_index[env][bk] < -no_iid_steps) {\n+                    fprintf(stderr, \"Warning: invalid iid_index: %d < %d\\n\", ps->iid_index[env][bk],\n+                        -no_iid_steps);\n+                    ps->iid_index[env][bk] = -no_iid_steps;\n+                } else if (ps->iid_index[env][bk] > no_iid_steps) {\n+                    fprintf(stderr, \"Warning: invalid iid_index: %d > %d\\n\", ps->iid_index[env][bk],\n+                        no_iid_steps);\n+                    ps->iid_index[env][bk] = no_iid_steps;\n+                }\n+\n                 /* calculate the scalefactors c_1 and c_2 from the intensity differences */\n                 c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];\n                 c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode",
      "                   (Table 8.24, ISO/IEC 14496-3:2005).",
      "                   if it is outside these boundaries, this is most likely an error. sanitize",
      "                   it and try to process further. */",
      "                if (ps->iid_index[env][bk] < -no_iid_steps) {",
      "                    fprintf(stderr, \"Warning: invalid iid_index: %d < %d\\n\", ps->iid_index[env][bk],",
      "                        -no_iid_steps);",
      "                    ps->iid_index[env][bk] = -no_iid_steps;",
      "                } else if (ps->iid_index[env][bk] > no_iid_steps) {",
      "                    fprintf(stderr, \"Warning: invalid iid_index: %d > %d\\n\", ps->iid_index[env][bk],",
      "                        no_iid_steps);",
      "                    ps->iid_index[env][bk] = no_iid_steps;",
      "                }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/38",
  "description": {
    "pr_info": {
      "title": "specrec: better handle unexpected PS (CVE-2018-20360/CVE-2018-20199)",
      "number": 38
    },
    "comment": [
      "Parametric Stereo (PS) can arrive at any moment in input files. PS changes the number of output channels and therefore requires more allocated memory in various structures from hDecoder.\r\n\r\nThe current faad2 code attempts to perform allocation surgery in hDecoder to recover from this. This works well when there is only one frame channel, else it creates large number of memory corruption issues.\r\n\r\nIf there is more than one input channel, return cleanly with error code. It would be nice to handle this, but this is likely to be a lot of work and is beyond the scope of a security fix.\r\n\r\nThis commit addresses CVE-2018-20360 and CVE-2018-20199 (fixes #32, fixes #24).",
      "Please, do not merge this right now, I'd like to make a second review of my code a bit later :-)",
      "Alright, I am waiting for your \"go!\". :+1: ",
      "I had a second look at \"specrec: better handle unexpected PS\", looks fine to me.\r\n\r\nI have pushed a new fix \"ps_dec: sanitize iid_index before mixing\" which addresses #39 (CVE-2019-6956). This is the best I can do with my current knowledge of the standard. It fixes the issue, and I don't expect it to break anything which was already working before.\r\n\r\nIt would be great if you could have a look at it before merging :)",
      "Thanks for that! Now there is not much left to fix, I guess. :grin: ",
      "> Thanks for that! Now there is not much left to fix, I guess.\r\n\r\nGreat ! I'm glad to hear that ! :)\r\n\r\nFabian, are you planning to prepare a Debian testing upload? I will upload a jessie update shortly and will coordinate with the security team for stretch and buster fixes.",
      "> Fabian, are you planning to prepare a Debian testing upload? I will upload a jessie update shortly and will coordinate with the security team for stretch and buster fixes.\r\n\r\nHonestly, no, I didn't have such plans. My idea was to wait until the dust has settled a bit, tag a new release in this repository and upload that to Debian unstable.\r\n",
      "> Honestly, no, I didn't have such plans. My idea was to wait until the dust has settled a bit, tag a new release in this repository and upload that to Debian unstable.\r\n\r\nWell, I don't see clear benefits in waiting, at least in the jessie/stretch/buster cases. I'd like to see some of these issues fixed in Jessie (the stack buffer overflow in particular), and if I am not mistaken the security team also wants to release a DSA (at least they have a dsa-needed entry for faad2, I will discuss it again with them).\r\n\r\nIf you need help, I can provide a NMU for unstable, featuring targeted patches, until you push a new release.",
      "> If you need help, I can provide a NMU for unstable, featuring targeted patches, until you push a new release.\r\n\r\nYes, please, that would be highly appreciated!\r\n",
      "> > If you need help, I can provide a NMU for unstable, featuring targeted patches, until you push a new release.\r\n> \r\n> Yes, please, that would be highly appreciated!\r\n\r\nGreat, I have prepared a NMU, see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=914641 :)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}