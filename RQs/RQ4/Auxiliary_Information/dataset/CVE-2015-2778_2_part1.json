{
  "cve_id": "CVE-2015-2778",
  "cwe_ids": [
    "CWE-399"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "quassel",
  "commit_msg": "Improve the message-splitting algorithm for PRIVMSG and CTCP\n\nThis introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.",
  "commit_hash": "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
  "git_url": "https://github.com/quassel/quassel/commit/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
  "file_path": "src/core/coreuserinputhandler.cpp",
  "func_name": "CoreUserInputHandler::putPrivmsg",
  "func_before": "void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n{\n    // Encrypted messages need special care. There's no clear relation between cleartext and encrypted message length,\n    // so we can't just compute the maxSplitPos. Instead, we need to loop through the splitpoints until the crypted\n    // version is short enough...\n    // TODO: check out how the various possible encryption methods behave length-wise and make\n    //       this clean by predicting the length of the crypted msg.\n    //       For example, blowfish-ebc seems to create 8-char chunks.\n\n    static const char *cmd = \"PRIVMSG\";\n    static const char *splitter = \" .,-!?\";\n\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    forever {\n        QByteArray crypted = message.left(splitPos);\n        bool isEncrypted = false;\n#ifdef HAVE_QCA2\n        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n            isEncrypted = cipher->encrypt(crypted);\n        }\n#endif\n        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n        if (overrun) {\n            // In case this is not an encrypted msg, we can just cut off at the end\n            if (!isEncrypted)\n                maxSplitPos = message.count() - overrun;\n\n            splitPos = -1;\n            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line\n            }\n            if (splitPos <= 0 || splitPos > maxSplitPos)\n                splitPos = maxSplitPos;\n\n            maxSplitPos = splitPos - 1;\n            if (maxSplitPos <= 0) { // this should never happen, but who knows...\n                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n                return;\n            }\n            continue; // we never come back here for !encrypted!\n        }\n\n        // now we have found a valid splitpos (or didn't need to split to begin with)\n        putCmd(cmd, QList<QByteArray>() << target << crypted);\n        if (splitPos < message.count())\n            putPrivmsg(target, message.mid(splitPos), cipher);\n\n        return;\n    }",
  "abstract_func_before": "void CoreUserInputHandler::putPrivmsg(const QByteArray &VAR_0, const QByteArray &VAR_1, Cipher *VAR_2)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n\n    static const char *VAR_3 = \"PRIVMSG\";\n    static const char *VAR_4 = \" .,-!?\";\n\n    int VAR_5 = VAR_1.count();\n    int VAR_6 = VAR_5;\n    forever {\n        QByteArray VAR_7 = VAR_1.left(VAR_6);\n        bool VAR_8 = false;\n#ifdef VAR_9\n        if (VAR_2 && !VAR_2->key().isEmpty() && !VAR_1.isEmpty()) {\n            VAR_8 = VAR_2->encrypt(VAR_7);\n        }\n#endif\n        int VAR_10 = lastParamOverrun(VAR_3, VAR_11<QByteArray>() << VAR_0 << VAR_7);\n        if (VAR_10) {\n            /* COMMENT_6 */\n            if (!VAR_8)\n                VAR_5 = VAR_1.count() - VAR_10;\n\n            VAR_6 = -1;\n            for (const char *VAR_12 = VAR_4; *VAR_12 != 0; VAR_12++) {\n                VAR_6 = qMax(VAR_6, VAR_1.lastIndexOf(*VAR_12, VAR_5) + 1); /* COMMENT_7 */\n            }\n            if (VAR_6 <= 0 || VAR_6 > VAR_5)\n                VAR_6 = VAR_5;\n\n            VAR_5 = VAR_6 - 1;\n            if (VAR_5 <= 0) { /* COMMENT_8 */\n                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(VAR_1.data());\n                return;\n            }\n            continue; /* COMMENT_9 */\n        }\n\n        /* COMMENT_10 */\n        putCmd(VAR_3, VAR_11<QByteArray>() << VAR_0 << VAR_7);\n        if (VAR_6 < VAR_1.count())\n            putPrivmsg(VAR_0, VAR_1.mid(VAR_6), VAR_2);\n\n        return;\n    }",
  "func_graph_path_before": null,
  "func": "void CoreUserInputHandler::putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher)\n{\n    QString cmd(\"PRIVMSG\");\n    QByteArray targetEnc = serverEncode(target);\n\n    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n        QByteArray splitMsgEnc = encodeFunc(target, splitMsg);\n\n#ifdef HAVE_QCA2\n        if (cipher && !cipher->key().isEmpty() && !splitMsg.isEmpty()) {\n            cipher->encrypt(splitMsgEnc);\n        }\n#endif\n        return QList<QByteArray>() << targetEnc << splitMsgEnc;\n    };\n\n    putCmd(cmd, network()->splitMessage(cmd, message, cmdGenerator));\n}",
  "abstract_func": "void CoreUserInputHandler::putPrivmsg(const QString &VAR_0, const QString &VAR_1, std::function<QByteArray(const QString &, const QString &)> VAR_2, Cipher *VAR_3)\n{\n    QString VAR_4(\"PRIVMSG\");\n    QByteArray VAR_5 = serverEncode(VAR_0);\n\n    std::function<QList<QByteArray>(QString &)> VAR_6 = [&] (QString &VAR_7) -> QList<QByteArray> {\n        QByteArray VAR_8 = VAR_2(VAR_0, VAR_7);\n\n#ifdef VAR_9\n        if (VAR_3 && !VAR_3->key().isEmpty() && !VAR_7.isEmpty()) {\n            VAR_3->encrypt(VAR_8);\n        }\n#endif\n        return QList<QByteArray>() << VAR_5 << VAR_8;\n    };\n\n    putCmd(VAR_4, network()->splitMessage(VAR_4, VAR_1, VAR_6));\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,50 +1,18 @@\n-void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n+void CoreUserInputHandler::putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher)\n {\n-    // Encrypted messages need special care. There's no clear relation between cleartext and encrypted message length,\n-    // so we can't just compute the maxSplitPos. Instead, we need to loop through the splitpoints until the crypted\n-    // version is short enough...\n-    // TODO: check out how the various possible encryption methods behave length-wise and make\n-    //       this clean by predicting the length of the crypted msg.\n-    //       For example, blowfish-ebc seems to create 8-char chunks.\n+    QString cmd(\"PRIVMSG\");\n+    QByteArray targetEnc = serverEncode(target);\n \n-    static const char *cmd = \"PRIVMSG\";\n-    static const char *splitter = \" .,-!?\";\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        QByteArray splitMsgEnc = encodeFunc(target, splitMsg);\n \n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n-    forever {\n-        QByteArray crypted = message.left(splitPos);\n-        bool isEncrypted = false;\n #ifdef HAVE_QCA2\n-        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n-            isEncrypted = cipher->encrypt(crypted);\n+        if (cipher && !cipher->key().isEmpty() && !splitMsg.isEmpty()) {\n+            cipher->encrypt(splitMsgEnc);\n         }\n #endif\n-        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n-        if (overrun) {\n-            // In case this is not an encrypted msg, we can just cut off at the end\n-            if (!isEncrypted)\n-                maxSplitPos = message.count() - overrun;\n+        return QList<QByteArray>() << targetEnc << splitMsgEnc;\n+    };\n \n-            splitPos = -1;\n-            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line\n-            }\n-            if (splitPos <= 0 || splitPos > maxSplitPos)\n-                splitPos = maxSplitPos;\n-\n-            maxSplitPos = splitPos - 1;\n-            if (maxSplitPos <= 0) { // this should never happen, but who knows...\n-                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n-                return;\n-            }\n-            continue; // we never come back here for !encrypted!\n-        }\n-\n-        // now we have found a valid splitpos (or didn't need to split to begin with)\n-        putCmd(cmd, QList<QByteArray>() << target << crypted);\n-        if (splitPos < message.count())\n-            putPrivmsg(target, message.mid(splitPos), cipher);\n-\n-        return;\n-    }\n+    putCmd(cmd, network()->splitMessage(cmd, message, cmdGenerator));\n+}",
  "diff_line_info": {
    "deleted_lines": [
      "void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)",
      "    // Encrypted messages need special care. There's no clear relation between cleartext and encrypted message length,",
      "    // so we can't just compute the maxSplitPos. Instead, we need to loop through the splitpoints until the crypted",
      "    // version is short enough...",
      "    // TODO: check out how the various possible encryption methods behave length-wise and make",
      "    //       this clean by predicting the length of the crypted msg.",
      "    //       For example, blowfish-ebc seems to create 8-char chunks.",
      "    static const char *cmd = \"PRIVMSG\";",
      "    static const char *splitter = \" .,-!?\";",
      "    int maxSplitPos = message.count();",
      "    int splitPos = maxSplitPos;",
      "    forever {",
      "        QByteArray crypted = message.left(splitPos);",
      "        bool isEncrypted = false;",
      "        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {",
      "            isEncrypted = cipher->encrypt(crypted);",
      "        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);",
      "        if (overrun) {",
      "            // In case this is not an encrypted msg, we can just cut off at the end",
      "            if (!isEncrypted)",
      "                maxSplitPos = message.count() - overrun;",
      "            splitPos = -1;",
      "            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {",
      "                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line",
      "            }",
      "            if (splitPos <= 0 || splitPos > maxSplitPos)",
      "                splitPos = maxSplitPos;",
      "",
      "            maxSplitPos = splitPos - 1;",
      "            if (maxSplitPos <= 0) { // this should never happen, but who knows...",
      "                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());",
      "                return;",
      "            }",
      "            continue; // we never come back here for !encrypted!",
      "        }",
      "",
      "        // now we have found a valid splitpos (or didn't need to split to begin with)",
      "        putCmd(cmd, QList<QByteArray>() << target << crypted);",
      "        if (splitPos < message.count())",
      "            putPrivmsg(target, message.mid(splitPos), cipher);",
      "",
      "        return;",
      "    }"
    ],
    "added_lines": [
      "void CoreUserInputHandler::putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher)",
      "    QString cmd(\"PRIVMSG\");",
      "    QByteArray targetEnc = serverEncode(target);",
      "    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {",
      "        QByteArray splitMsgEnc = encodeFunc(target, splitMsg);",
      "        if (cipher && !cipher->key().isEmpty() && !splitMsg.isEmpty()) {",
      "            cipher->encrypt(splitMsgEnc);",
      "        return QList<QByteArray>() << targetEnc << splitMsgEnc;",
      "    };",
      "    putCmd(cmd, network()->splitMessage(cmd, message, cmdGenerator));",
      "}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/quassel/quassel/pull/116",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/quassel/quassel/pull/116: 403 Client Error: Forbidden for url: https://api.github.com/repos/quassel/quassel/pulls/116",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}