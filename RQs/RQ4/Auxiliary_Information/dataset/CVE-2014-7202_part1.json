{
  "cve_id": "CVE-2014-7202",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: stream_engine.cpp security can be downgraded\n\nSolution: accept only the mechanism defined by the socket options.\n\nI've not tested this yet, so it's a speculative fix.",
  "commit_hash": "77f14aad95cdf0d2a244ae9b4a025e5ba0adf01a",
  "git_url": "https://github.com/zeromq/libzmq/commit/77f14aad95cdf0d2a244ae9b4a025e5ba0adf01a",
  "file_path": "src/stream_engine.cpp",
  "func_name": "zmq::stream_engine_t::handshake",
  "func_before": "bool zmq::stream_engine_t::handshake ()\n{\n    zmq_assert (handshaking);\n    zmq_assert (greeting_bytes_read < greeting_size);\n    //  Receive the greeting.\n    while (greeting_bytes_read < greeting_size) {\n        const int n = tcp_read (s, greeting_recv + greeting_bytes_read,\n                                greeting_size - greeting_bytes_read);\n        if (n == 0) {\n            error (connection_error);\n            return false;\n        }\n        if (n == -1) {\n            if (errno != EAGAIN)\n                error (connection_error);\n            return false;\n        }\n\n        greeting_bytes_read += n;\n\n        //  We have received at least one byte from the peer.\n        //  If the first byte is not 0xff, we know that the\n        //  peer is using unversioned protocol.\n        if (greeting_recv [0] != 0xff)\n            break;\n\n        if (greeting_bytes_read < signature_size)\n            continue;\n\n        //  Inspect the right-most bit of the 10th byte (which coincides\n        //  with the 'flags' field if a regular message was sent).\n        //  Zero indicates this is a header of identity message\n        //  (i.e. the peer is using the unversioned protocol).\n        if (!(greeting_recv [9] & 0x01))\n            break;\n\n        //  The peer is using versioned protocol.\n        //  Send the major version number.\n        if (outpos + outsize == greeting_send + signature_size) {\n            if (outsize == 0)\n                set_pollout (handle);\n            outpos [outsize++] = 3;     //  Major version number\n        }\n\n        if (greeting_bytes_read > signature_size) {\n            if (outpos + outsize == greeting_send + signature_size + 1) {\n                if (outsize == 0)\n                    set_pollout (handle);\n\n                //  Use ZMTP/2.0 to talk to older peers.\n                if (greeting_recv [10] == ZMTP_1_0\n                ||  greeting_recv [10] == ZMTP_2_0)\n                    outpos [outsize++] = options.type;\n                else {\n                    outpos [outsize++] = 0; //  Minor version number\n                    memset (outpos + outsize, 0, 20);\n\n                    zmq_assert (options.mechanism == ZMQ_NULL\n                            ||  options.mechanism == ZMQ_PLAIN\n                            ||  options.mechanism == ZMQ_CURVE\n                            ||  options.mechanism == ZMQ_GSSAPI);\n\n                    if (options.mechanism == ZMQ_NULL)\n                        memcpy (outpos + outsize, \"NULL\", 4);\n                    else\n                    if (options.mechanism == ZMQ_PLAIN)\n                        memcpy (outpos + outsize, \"PLAIN\", 5);\n                    else\n                    if (options.mechanism == ZMQ_GSSAPI)\n                        memcpy (outpos + outsize, \"GSSAPI\", 6);\n                    else\n                    if (options.mechanism == ZMQ_CURVE)\n                        memcpy (outpos + outsize, \"CURVE\", 5);\n                    outsize += 20;\n                    memset (outpos + outsize, 0, 32);\n                    outsize += 32;\n                    greeting_size = v3_greeting_size;\n                }\n            }\n        }\n    }\n\n    //  Position of the revision field in the greeting.\n    const size_t revision_pos = 10;\n\n    //  Is the peer using ZMTP/1.0 with no revision number?\n    //  If so, we send and receive rest of identity message\n    if (greeting_recv [0] != 0xff || !(greeting_recv [9] & 0x01)) {\n        encoder = new (std::nothrow) v1_encoder_t (out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v1_decoder_t (in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n\n        //  We have already sent the message header.\n        //  Since there is no way to tell the encoder to\n        //  skip the message header, we simply throw that\n        //  header data away.\n        const size_t header_size = options.identity_size + 1 >= 255 ? 10 : 2;\n        unsigned char tmp [10], *bufferp = tmp;\n\n        //  Prepare the identity message and load it into encoder.\n        //  Then consume bytes we have already sent to the peer.\n        const int rc = tx_msg.init_size (options.identity_size);\n        zmq_assert (rc == 0);\n        memcpy (tx_msg.data (), options.identity, options.identity_size);\n        encoder->load_msg (&tx_msg);\n        size_t buffer_size = encoder->encode (&bufferp, header_size);\n        zmq_assert (buffer_size == header_size);\n\n        //  Make sure the decoder sees the data we have already received.\n        inpos = greeting_recv;\n        insize = greeting_bytes_read;\n\n        //  To allow for interoperability with peers that do not forward\n        //  their subscriptions, we inject a phantom subscription message\n        //  message into the incoming message stream.\n        if (options.type == ZMQ_PUB || options.type == ZMQ_XPUB)\n            subscription_required = true;\n\n        //  We are sending our identity now and the next message\n        //  will come from the socket.\n        next_msg = &stream_engine_t::pull_msg_from_session;\n\n        //  We are expecting identity message.\n        process_msg = &stream_engine_t::process_identity_msg;\n    }\n    else\n    if (greeting_recv [revision_pos] == ZMTP_1_0) {\n        encoder = new (std::nothrow) v1_encoder_t (\n            out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v1_decoder_t (\n            in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n    }\n    else\n    if (greeting_recv [revision_pos] == ZMTP_2_0) {\n        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v2_decoder_t (\n            in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n    }\n    else {\n        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v2_decoder_t (\n            in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n\n        if (memcmp (greeting_recv + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            mechanism = new (std::nothrow)\n                null_mechanism_t (session, peer_address, options);\n            alloc_assert (mechanism);\n        }\n        else\n        if (memcmp (greeting_recv + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (options.as_server)\n                mechanism = new (std::nothrow)\n                    plain_server_t (session, peer_address, options);\n            else\n                mechanism = new (std::nothrow)\n                    plain_client_t (options);\n            alloc_assert (mechanism);\n        }\n#ifdef HAVE_LIBSODIUM\n        else\n        if (memcmp (greeting_recv + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (options.as_server)\n                mechanism = new (std::nothrow)\n                    curve_server_t (session, peer_address, options);\n            else\n                mechanism = new (std::nothrow) curve_client_t (options);\n            alloc_assert (mechanism);\n        }\n#endif\n#ifdef HAVE_LIBGSSAPI_KRB5\n        else\n        if (memcmp (greeting_recv + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (options.as_server)\n                mechanism = new (std::nothrow)\n                    gssapi_server_t (session, peer_address, options);\n            else\n                mechanism = new (std::nothrow) gssapi_client_t (options);\n            alloc_assert (mechanism);\n        }\n#endif\n        else {\n            error (protocol_error);\n            return false;\n        }\n        next_msg = &stream_engine_t::next_handshake_command;\n        process_msg = &stream_engine_t::process_handshake_command;\n    }\n\n    // Start polling for output if necessary.\n    if (outsize == 0)\n        set_pollout (handle);\n\n    //  Handshaking was successful.\n    //  Switch into the normal message flow.\n    handshaking = false;\n\n    if (has_handshake_timer) {\n        cancel_timer (handshake_timer_id);\n        has_handshake_timer = false;\n    }\n\n    return true;\n}",
  "abstract_func_before": "bool zmq::stream_engine_t::handshake ()\n{\n    zmq_assert (VAR_0);\n    zmq_assert (VAR_1 < VAR_2);\n    /* COMMENT_0 */\n    while (VAR_1 < VAR_2) {\n        const int VAR_3 = tcp_read (VAR_4, VAR_5 + VAR_1,\n                                VAR_2 - VAR_1);\n        if (VAR_3 == 0) {\n            error (VAR_6);\n            return false;\n        }\n        if (VAR_3 == -1) {\n            if (VAR_7 != VAR_8)\n                error (VAR_6);\n            return false;\n        }\n\n        VAR_1 += VAR_3;\n\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        if (VAR_5 [0] != 0xff)\n            break;\n\n        if (VAR_1 < VAR_9)\n            continue;\n\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        if (!(VAR_5 [9] & 0x01))\n            break;\n\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        if (VAR_10 + VAR_11 == VAR_12 + VAR_9) {\n            if (VAR_11 == 0)\n                set_pollout (VAR_13);\n            VAR_10 [VAR_11++] = 3;     /* COMMENT_10 */\n        }\n\n        if (VAR_1 > VAR_9) {\n            if (VAR_10 + VAR_11 == VAR_12 + VAR_9 + 1) {\n                if (VAR_11 == 0)\n                    set_pollout (VAR_13);\n\n                /* COMMENT_11 */\n                if (VAR_5 [10] == VAR_14\n                ||  VAR_5 [10] == VAR_15)\n                    VAR_10 [VAR_11++] = VAR_16.type;\n                else {\n                    VAR_10 [VAR_11++] = 0; /* COMMENT_12 */\n                    memset (VAR_10 + VAR_11, 0, 20);\n\n                    zmq_assert (VAR_16.mechanism == VAR_17\n                            ||  VAR_16.mechanism == VAR_18\n                            ||  VAR_16.mechanism == VAR_19\n                            ||  VAR_16.mechanism == VAR_20);\n\n                    if (VAR_16.mechanism == VAR_17)\n                        memcpy (VAR_10 + VAR_11, \"NULL\", 4);\n                    else\n                    if (VAR_16.mechanism == VAR_18)\n                        memcpy (VAR_10 + VAR_11, \"PLAIN\", 5);\n                    else\n                    if (VAR_16.mechanism == VAR_20)\n                        memcpy (VAR_10 + VAR_11, \"GSSAPI\", 6);\n                    else\n                    if (VAR_16.mechanism == VAR_19)\n                        memcpy (VAR_10 + VAR_11, \"CURVE\", 5);\n                    VAR_11 += 20;\n                    memset (VAR_10 + VAR_11, 0, 32);\n                    VAR_11 += 32;\n                    VAR_2 = VAR_21;\n                }\n            }\n        }\n    }\n\n    /* COMMENT_13 */\n    const size_t VAR_22 = 10;\n\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    if (VAR_5 [0] != 0xff || !(VAR_5 [9] & 0x01)) {\n        VAR_23 = new (std::nothrow) v1_encoder_t (VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v1_decoder_t (VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        const size_t VAR_27 = VAR_16.identity_size + 1 >= 255 ? 10 : 2;\n        unsigned char VAR_28 [10], *VAR_29 = VAR_28;\n\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        const int VAR_30 = VAR_31.init_size (VAR_16.identity_size);\n        zmq_assert (VAR_30 == 0);\n        memcpy (VAR_31.data (), VAR_16.identity, VAR_16.identity_size);\n        VAR_23->load_msg (&VAR_31);\n        size_t VAR_32 = VAR_23->encode (&VAR_29, VAR_27);\n        zmq_assert (VAR_32 == VAR_27);\n\n        /* COMMENT_22 */\n        VAR_33 = VAR_5;\n        VAR_34 = VAR_1;\n\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        /* COMMENT_25 */\n        if (VAR_16.type == VAR_35 || VAR_16.type == VAR_36)\n            VAR_37 = true;\n\n        /* COMMENT_26 */\n        /* COMMENT_27 */\n        VAR_38 = &stream_engine_t::pull_msg_from_session;\n\n        /* COMMENT_28 */\n        VAR_39 = &stream_engine_t::process_identity_msg;\n    }\n    else\n    if (VAR_5 [VAR_22] == VAR_14) {\n        VAR_23 = new (std::nothrow) v1_encoder_t (\n            VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v1_decoder_t (\n            VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n    }\n    else\n    if (VAR_5 [VAR_22] == VAR_15) {\n        VAR_23 = new (std::nothrow) v2_encoder_t (VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v2_decoder_t (\n            VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n    }\n    else {\n        VAR_23 = new (std::nothrow) v2_encoder_t (VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v2_decoder_t (\n            VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n\n        if (memcmp (VAR_5 + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            VAR_40 = new (std::nothrow)\n                null_mechanism_t (VAR_41, VAR_42, VAR_16);\n            alloc_assert (VAR_40);\n        }\n        else\n        if (memcmp (VAR_5 + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (VAR_16.as_server)\n                VAR_40 = new (std::nothrow)\n                    plain_server_t (VAR_41, VAR_42, VAR_16);\n            else\n                VAR_40 = new (std::nothrow)\n                    plain_client_t (VAR_16);\n            alloc_assert (VAR_40);\n        }\n#ifdef VAR_43\n        else\n        if (memcmp (VAR_5 + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (VAR_16.as_server)\n                VAR_40 = new (std::nothrow)\n                    curve_server_t (VAR_41, VAR_42, VAR_16);\n            else\n                VAR_40 = new (std::nothrow) curve_client_t (VAR_16);\n            alloc_assert (VAR_40);\n        }\n#endif\n#ifdef VAR_44\n        else\n        if (memcmp (VAR_5 + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (VAR_16.as_server)\n                VAR_40 = new (std::nothrow)\n                    gssapi_server_t (VAR_41, VAR_42, VAR_16);\n            else\n                VAR_40 = new (std::nothrow) gssapi_client_t (VAR_16);\n            alloc_assert (VAR_40);\n        }\n#endif\n        else {\n            error (VAR_45);\n            return false;\n        }\n        VAR_38 = &stream_engine_t::next_handshake_command;\n        VAR_39 = &stream_engine_t::process_handshake_command;\n    }\n\n    /* COMMENT_29 */\n    if (VAR_11 == 0)\n        set_pollout (VAR_13);\n\n    /* COMMENT_30 */\n    /* COMMENT_31 */\n    VAR_0 = false;\n\n    if (VAR_46) {\n        cancel_timer (VAR_47);\n        VAR_46 = false;\n    }\n\n    return true;\n}",
  "func_graph_path_before": "zeromq/libzmq/77f14aad95cdf0d2a244ae9b4a025e5ba0adf01a/stream_engine.cpp/vul/before/0.json",
  "func": "bool zmq::stream_engine_t::handshake ()\n{\n    zmq_assert (handshaking);\n    zmq_assert (greeting_bytes_read < greeting_size);\n    //  Receive the greeting.\n    while (greeting_bytes_read < greeting_size) {\n        const int n = tcp_read (s, greeting_recv + greeting_bytes_read,\n                                greeting_size - greeting_bytes_read);\n        if (n == 0) {\n            error (connection_error);\n            return false;\n        }\n        if (n == -1) {\n            if (errno != EAGAIN)\n                error (connection_error);\n            return false;\n        }\n\n        greeting_bytes_read += n;\n\n        //  We have received at least one byte from the peer.\n        //  If the first byte is not 0xff, we know that the\n        //  peer is using unversioned protocol.\n        if (greeting_recv [0] != 0xff)\n            break;\n\n        if (greeting_bytes_read < signature_size)\n            continue;\n\n        //  Inspect the right-most bit of the 10th byte (which coincides\n        //  with the 'flags' field if a regular message was sent).\n        //  Zero indicates this is a header of identity message\n        //  (i.e. the peer is using the unversioned protocol).\n        if (!(greeting_recv [9] & 0x01))\n            break;\n\n        //  The peer is using versioned protocol.\n        //  Send the major version number.\n        if (outpos + outsize == greeting_send + signature_size) {\n            if (outsize == 0)\n                set_pollout (handle);\n            outpos [outsize++] = 3;     //  Major version number\n        }\n\n        if (greeting_bytes_read > signature_size) {\n            if (outpos + outsize == greeting_send + signature_size + 1) {\n                if (outsize == 0)\n                    set_pollout (handle);\n\n                //  Use ZMTP/2.0 to talk to older peers.\n                if (greeting_recv [10] == ZMTP_1_0\n                ||  greeting_recv [10] == ZMTP_2_0)\n                    outpos [outsize++] = options.type;\n                else {\n                    outpos [outsize++] = 0; //  Minor version number\n                    memset (outpos + outsize, 0, 20);\n\n                    zmq_assert (options.mechanism == ZMQ_NULL\n                            ||  options.mechanism == ZMQ_PLAIN\n                            ||  options.mechanism == ZMQ_CURVE\n                            ||  options.mechanism == ZMQ_GSSAPI);\n\n                    if (options.mechanism == ZMQ_NULL)\n                        memcpy (outpos + outsize, \"NULL\", 4);\n                    else\n                    if (options.mechanism == ZMQ_PLAIN)\n                        memcpy (outpos + outsize, \"PLAIN\", 5);\n                    else\n                    if (options.mechanism == ZMQ_GSSAPI)\n                        memcpy (outpos + outsize, \"GSSAPI\", 6);\n                    else\n                    if (options.mechanism == ZMQ_CURVE)\n                        memcpy (outpos + outsize, \"CURVE\", 5);\n                    outsize += 20;\n                    memset (outpos + outsize, 0, 32);\n                    outsize += 32;\n                    greeting_size = v3_greeting_size;\n                }\n            }\n        }\n    }\n\n    //  Position of the revision field in the greeting.\n    const size_t revision_pos = 10;\n\n    //  Is the peer using ZMTP/1.0 with no revision number?\n    //  If so, we send and receive rest of identity message\n    if (greeting_recv [0] != 0xff || !(greeting_recv [9] & 0x01)) {\n        encoder = new (std::nothrow) v1_encoder_t (out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v1_decoder_t (in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n\n        //  We have already sent the message header.\n        //  Since there is no way to tell the encoder to\n        //  skip the message header, we simply throw that\n        //  header data away.\n        const size_t header_size = options.identity_size + 1 >= 255 ? 10 : 2;\n        unsigned char tmp [10], *bufferp = tmp;\n\n        //  Prepare the identity message and load it into encoder.\n        //  Then consume bytes we have already sent to the peer.\n        const int rc = tx_msg.init_size (options.identity_size);\n        zmq_assert (rc == 0);\n        memcpy (tx_msg.data (), options.identity, options.identity_size);\n        encoder->load_msg (&tx_msg);\n        size_t buffer_size = encoder->encode (&bufferp, header_size);\n        zmq_assert (buffer_size == header_size);\n\n        //  Make sure the decoder sees the data we have already received.\n        inpos = greeting_recv;\n        insize = greeting_bytes_read;\n\n        //  To allow for interoperability with peers that do not forward\n        //  their subscriptions, we inject a phantom subscription message\n        //  message into the incoming message stream.\n        if (options.type == ZMQ_PUB || options.type == ZMQ_XPUB)\n            subscription_required = true;\n\n        //  We are sending our identity now and the next message\n        //  will come from the socket.\n        next_msg = &stream_engine_t::pull_msg_from_session;\n\n        //  We are expecting identity message.\n        process_msg = &stream_engine_t::process_identity_msg;\n    }\n    else\n    if (greeting_recv [revision_pos] == ZMTP_1_0) {\n        encoder = new (std::nothrow) v1_encoder_t (\n            out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v1_decoder_t (\n            in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n    }\n    else\n    if (greeting_recv [revision_pos] == ZMTP_2_0) {\n        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v2_decoder_t (\n            in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n    }\n    else {\n        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);\n        alloc_assert (encoder);\n\n        decoder = new (std::nothrow) v2_decoder_t (\n            in_batch_size, options.maxmsgsize);\n        alloc_assert (decoder);\n\n        if (options.mechanism == ZMQ_NULL\n        &&  memcmp (greeting_recv + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            mechanism = new (std::nothrow)\n                null_mechanism_t (session, peer_address, options);\n            alloc_assert (mechanism);\n        }\n        else\n        if (options.mechanism == ZMQ_PLAIN\n        &&  memcmp (greeting_recv + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (options.as_server)\n                mechanism = new (std::nothrow)\n                    plain_server_t (session, peer_address, options);\n            else\n                mechanism = new (std::nothrow)\n                    plain_client_t (options);\n            alloc_assert (mechanism);\n        }\n#ifdef HAVE_LIBSODIUM\n        else\n        if (options.mechanism == ZMQ_CURVE\n        &&  memcmp (greeting_recv + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (options.as_server)\n                mechanism = new (std::nothrow)\n                    curve_server_t (session, peer_address, options);\n            else\n                mechanism = new (std::nothrow) curve_client_t (options);\n            alloc_assert (mechanism);\n        }\n#endif\n#ifdef HAVE_LIBGSSAPI_KRB5\n        else\n        if (options.mechanism == ZMQ_GSSAPI\n        &&  memcmp (greeting_recv + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (options.as_server)\n                mechanism = new (std::nothrow)\n                    gssapi_server_t (session, peer_address, options);\n            else\n                mechanism = new (std::nothrow) gssapi_client_t (options);\n            alloc_assert (mechanism);\n        }\n#endif\n        else {\n            error (protocol_error);\n            return false;\n        }\n        next_msg = &stream_engine_t::next_handshake_command;\n        process_msg = &stream_engine_t::process_handshake_command;\n    }\n\n    // Start polling for output if necessary.\n    if (outsize == 0)\n        set_pollout (handle);\n\n    //  Handshaking was successful.\n    //  Switch into the normal message flow.\n    handshaking = false;\n\n    if (has_handshake_timer) {\n        cancel_timer (handshake_timer_id);\n        has_handshake_timer = false;\n    }\n\n    return true;\n}",
  "abstract_func": "bool zmq::stream_engine_t::handshake ()\n{\n    zmq_assert (VAR_0);\n    zmq_assert (VAR_1 < VAR_2);\n    /* COMMENT_0 */\n    while (VAR_1 < VAR_2) {\n        const int VAR_3 = tcp_read (VAR_4, VAR_5 + VAR_1,\n                                VAR_2 - VAR_1);\n        if (VAR_3 == 0) {\n            error (VAR_6);\n            return false;\n        }\n        if (VAR_3 == -1) {\n            if (VAR_7 != VAR_8)\n                error (VAR_6);\n            return false;\n        }\n\n        VAR_1 += VAR_3;\n\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        if (VAR_5 [0] != 0xff)\n            break;\n\n        if (VAR_1 < VAR_9)\n            continue;\n\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        if (!(VAR_5 [9] & 0x01))\n            break;\n\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        if (VAR_10 + VAR_11 == VAR_12 + VAR_9) {\n            if (VAR_11 == 0)\n                set_pollout (VAR_13);\n            VAR_10 [VAR_11++] = 3;     /* COMMENT_10 */\n        }\n\n        if (VAR_1 > VAR_9) {\n            if (VAR_10 + VAR_11 == VAR_12 + VAR_9 + 1) {\n                if (VAR_11 == 0)\n                    set_pollout (VAR_13);\n\n                /* COMMENT_11 */\n                if (VAR_5 [10] == VAR_14\n                ||  VAR_5 [10] == VAR_15)\n                    VAR_10 [VAR_11++] = VAR_16.type;\n                else {\n                    VAR_10 [VAR_11++] = 0; /* COMMENT_12 */\n                    memset (VAR_10 + VAR_11, 0, 20);\n\n                    zmq_assert (VAR_16.mechanism == VAR_17\n                            ||  VAR_16.mechanism == VAR_18\n                            ||  VAR_16.mechanism == VAR_19\n                            ||  VAR_16.mechanism == VAR_20);\n\n                    if (VAR_16.mechanism == VAR_17)\n                        memcpy (VAR_10 + VAR_11, \"NULL\", 4);\n                    else\n                    if (VAR_16.mechanism == VAR_18)\n                        memcpy (VAR_10 + VAR_11, \"PLAIN\", 5);\n                    else\n                    if (VAR_16.mechanism == VAR_20)\n                        memcpy (VAR_10 + VAR_11, \"GSSAPI\", 6);\n                    else\n                    if (VAR_16.mechanism == VAR_19)\n                        memcpy (VAR_10 + VAR_11, \"CURVE\", 5);\n                    VAR_11 += 20;\n                    memset (VAR_10 + VAR_11, 0, 32);\n                    VAR_11 += 32;\n                    VAR_2 = VAR_21;\n                }\n            }\n        }\n    }\n\n    /* COMMENT_13 */\n    const size_t VAR_22 = 10;\n\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    if (VAR_5 [0] != 0xff || !(VAR_5 [9] & 0x01)) {\n        VAR_23 = new (std::nothrow) v1_encoder_t (VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v1_decoder_t (VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        const size_t VAR_27 = VAR_16.identity_size + 1 >= 255 ? 10 : 2;\n        unsigned char VAR_28 [10], *VAR_29 = VAR_28;\n\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        const int VAR_30 = VAR_31.init_size (VAR_16.identity_size);\n        zmq_assert (VAR_30 == 0);\n        memcpy (VAR_31.data (), VAR_16.identity, VAR_16.identity_size);\n        VAR_23->load_msg (&VAR_31);\n        size_t VAR_32 = VAR_23->encode (&VAR_29, VAR_27);\n        zmq_assert (VAR_32 == VAR_27);\n\n        /* COMMENT_22 */\n        VAR_33 = VAR_5;\n        VAR_34 = VAR_1;\n\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        /* COMMENT_25 */\n        if (VAR_16.type == VAR_35 || VAR_16.type == VAR_36)\n            VAR_37 = true;\n\n        /* COMMENT_26 */\n        /* COMMENT_27 */\n        VAR_38 = &stream_engine_t::pull_msg_from_session;\n\n        /* COMMENT_28 */\n        VAR_39 = &stream_engine_t::process_identity_msg;\n    }\n    else\n    if (VAR_5 [VAR_22] == VAR_14) {\n        VAR_23 = new (std::nothrow) v1_encoder_t (\n            VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v1_decoder_t (\n            VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n    }\n    else\n    if (VAR_5 [VAR_22] == VAR_15) {\n        VAR_23 = new (std::nothrow) v2_encoder_t (VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v2_decoder_t (\n            VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n    }\n    else {\n        VAR_23 = new (std::nothrow) v2_encoder_t (VAR_24);\n        alloc_assert (VAR_23);\n\n        VAR_25 = new (std::nothrow) v2_decoder_t (\n            VAR_26, VAR_16.maxmsgsize);\n        alloc_assert (VAR_25);\n\n        if (VAR_16.mechanism == VAR_17\n        &&  memcmp (VAR_5 + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            VAR_40 = new (std::nothrow)\n                null_mechanism_t (VAR_41, VAR_42, VAR_16);\n            alloc_assert (VAR_40);\n        }\n        else\n        if (VAR_16.mechanism == VAR_18\n        &&  memcmp (VAR_5 + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (VAR_16.as_server)\n                VAR_40 = new (std::nothrow)\n                    plain_server_t (VAR_41, VAR_42, VAR_16);\n            else\n                VAR_40 = new (std::nothrow)\n                    plain_client_t (VAR_16);\n            alloc_assert (VAR_40);\n        }\n#ifdef VAR_43\n        else\n        if (VAR_16.mechanism == VAR_19\n        &&  memcmp (VAR_5 + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (VAR_16.as_server)\n                VAR_40 = new (std::nothrow)\n                    curve_server_t (VAR_41, VAR_42, VAR_16);\n            else\n                VAR_40 = new (std::nothrow) curve_client_t (VAR_16);\n            alloc_assert (VAR_40);\n        }\n#endif\n#ifdef VAR_44\n        else\n        if (VAR_16.mechanism == VAR_20\n        &&  memcmp (VAR_5 + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n            if (VAR_16.as_server)\n                VAR_40 = new (std::nothrow)\n                    gssapi_server_t (VAR_41, VAR_42, VAR_16);\n            else\n                VAR_40 = new (std::nothrow) gssapi_client_t (VAR_16);\n            alloc_assert (VAR_40);\n        }\n#endif\n        else {\n            error (VAR_45);\n            return false;\n        }\n        VAR_38 = &stream_engine_t::next_handshake_command;\n        VAR_39 = &stream_engine_t::process_handshake_command;\n    }\n\n    /* COMMENT_29 */\n    if (VAR_11 == 0)\n        set_pollout (VAR_13);\n\n    /* COMMENT_30 */\n    /* COMMENT_31 */\n    VAR_0 = false;\n\n    if (VAR_46) {\n        cancel_timer (VAR_47);\n        VAR_46 = false;\n    }\n\n    return true;\n}",
  "func_graph_path": "zeromq/libzmq/77f14aad95cdf0d2a244ae9b4a025e5ba0adf01a/stream_engine.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -152,13 +152,15 @@\n             in_batch_size, options.maxmsgsize);\n         alloc_assert (decoder);\n \n-        if (memcmp (greeting_recv + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n+        if (options.mechanism == ZMQ_NULL\n+        &&  memcmp (greeting_recv + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n             mechanism = new (std::nothrow)\n                 null_mechanism_t (session, peer_address, options);\n             alloc_assert (mechanism);\n         }\n         else\n-        if (memcmp (greeting_recv + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n+        if (options.mechanism == ZMQ_PLAIN\n+        &&  memcmp (greeting_recv + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n             if (options.as_server)\n                 mechanism = new (std::nothrow)\n                     plain_server_t (session, peer_address, options);\n@@ -169,7 +171,8 @@\n         }\n #ifdef HAVE_LIBSODIUM\n         else\n-        if (memcmp (greeting_recv + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n+        if (options.mechanism == ZMQ_CURVE\n+        &&  memcmp (greeting_recv + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n             if (options.as_server)\n                 mechanism = new (std::nothrow)\n                     curve_server_t (session, peer_address, options);\n@@ -180,7 +183,8 @@\n #endif\n #ifdef HAVE_LIBGSSAPI_KRB5\n         else\n-        if (memcmp (greeting_recv + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n+        if (options.mechanism == ZMQ_GSSAPI\n+        &&  memcmp (greeting_recv + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {\n             if (options.as_server)\n                 mechanism = new (std::nothrow)\n                     gssapi_server_t (session, peer_address, options);",
  "diff_line_info": {
    "deleted_lines": [
      "        if (memcmp (greeting_recv + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {",
      "        if (memcmp (greeting_recv + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {",
      "        if (memcmp (greeting_recv + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {",
      "        if (memcmp (greeting_recv + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {"
    ],
    "added_lines": [
      "        if (options.mechanism == ZMQ_NULL",
      "        &&  memcmp (greeting_recv + 12, \"NULL\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {",
      "        if (options.mechanism == ZMQ_PLAIN",
      "        &&  memcmp (greeting_recv + 12, \"PLAIN\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {",
      "        if (options.mechanism == ZMQ_CURVE",
      "        &&  memcmp (greeting_recv + 12, \"CURVE\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {",
      "        if (options.mechanism == ZMQ_GSSAPI",
      "        &&  memcmp (greeting_recv + 12, \"GSSAPI\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 20) == 0) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1188",
  "description": {
    "pr_info": {
      "title": "Problem: stream_engine.cpp security can be downgraded",
      "number": 1188
    },
    "comment": [
      "Solution: accept only the mechanism defined by the socket options.\n\nI've not tested this yet, so it's a speculative fix.\n",
      "Fixes #1190.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}