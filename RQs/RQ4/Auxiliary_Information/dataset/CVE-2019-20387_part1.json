{
  "cve_id": "CVE-2019-20387",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openSUSE/libsolv",
  "commit_msg": "repodata_schema2id: fix heap-buffer-overflow in memcmp\n\nWhen the length of last schema in data->schemadata is\nless than length of input schema, we got a read overflow\nin asan test.\n\nSigned-off-by: Zhipeng Xie <xiezhipeng1@huawei.com>",
  "commit_hash": "fdb9c9c03508990e4583046b590c30d958f272da",
  "git_url": "https://github.com/openSUSE/libsolv/commit/fdb9c9c03508990e4583046b590c30d958f272da",
  "file_path": "src/repodata.c",
  "func_name": "repodata_schema2id",
  "func_before": "Id\nrepodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n\n  if (!*schema)\n    return 0;\t/* XXX: allow empty schema? */\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      /* cache conflict, do a slow search */\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  /* a new one */\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  /* add schema */\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}",
  "abstract_func_before": "Id\nrepodata_schema2id(Repodata *VAR_0, Id *VAR_1, int VAR_2)\n{\n  int VAR_3, VAR_4, VAR_5;\n  Id *VAR_6, VAR_7;\n  Id *VAR_8;\n\n  if (!*VAR_1)\n    return 0;\t/* COMMENT_0 */\n  if ((VAR_8 = VAR_0->schematahash) == 0)\n    {\n      VAR_0->schematahash = VAR_8 = solv_calloc(256, sizeof(Id));\n      for (VAR_5 = 1; VAR_5 < VAR_0->nschemata; VAR_5++)\n\t{\n\t  for (VAR_6 = VAR_0->schemadata + VAR_0->schemata[VAR_5], VAR_3 = 0; *VAR_6;)\n\t    VAR_3 = VAR_3 * 7 + *VAR_6++;\n\t  VAR_3 &= 255;\n\t  VAR_8[VAR_3] = VAR_5;\n\t}\n      VAR_0->schemadata = solv_extend_resize(VAR_0->schemadata, VAR_0->schemadatalen, sizeof(Id), VAR_9);\n      VAR_0->schemata = solv_extend_resize(VAR_0->schemata, VAR_0->nschemata, sizeof(Id), VAR_10);\n    }\n\n  for (VAR_6 = VAR_1, VAR_4 = 0, VAR_3 = 0; *VAR_6; VAR_4++)\n    VAR_3 = VAR_3 * 7 + *VAR_6++;\n  VAR_3 &= 255;\n  VAR_4++;\n\n  VAR_7 = VAR_8[VAR_3];\n  if (VAR_7)\n    {\n      if (!memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))\n        return VAR_7;\n      /* COMMENT_1 */\n      for (VAR_7 = 1; VAR_7 < VAR_0->nschemata; VAR_7++)\n        if (!memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))\n          return VAR_7;\n    }\n  /* COMMENT_2 */\n  if (!VAR_2)\n    return 0;\n  VAR_0->schemadata = solv_extend(VAR_0->schemadata, VAR_0->schemadatalen, VAR_4, sizeof(Id), VAR_9);\n  VAR_0->schemata = solv_extend(VAR_0->schemata, VAR_0->nschemata, 1, sizeof(Id), VAR_10);\n  /* COMMENT_3 */\n  memcpy(VAR_0->schemadata + VAR_0->schemadatalen, VAR_1, VAR_4 * sizeof(Id));\n  VAR_0->schemata[VAR_0->nschemata] = VAR_0->schemadatalen;\n  VAR_0->schemadatalen += VAR_4;\n  VAR_8[VAR_3] = VAR_0->nschemata;\n#if 0\nfprintf(VAR_11, \"schema2id: new schema\\n\");\n#endif\n  return VAR_0->nschemata++;\n}",
  "func_graph_path_before": "openSUSE/libsolv/fdb9c9c03508990e4583046b590c30d958f272da/repodata.c/vul/before/0.json",
  "func": "Id\nrepodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n\n  if (!*schema)\n    return 0;\t/* XXX: allow empty schema? */\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n\n  cid = schematahash[h];\n  if (cid)\n    {\n      if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      /* cache conflict, do a slow search */\n      for (cid = 1; cid < data->nschemata; cid++)\n        if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t\t!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  /* a new one */\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  /* add schema */\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}",
  "abstract_func": "Id\nrepodata_schema2id(Repodata *VAR_0, Id *VAR_1, int VAR_2)\n{\n  int VAR_3, VAR_4, VAR_5;\n  Id *VAR_6, VAR_7;\n  Id *VAR_8;\n\n  if (!*VAR_1)\n    return 0;\t/* COMMENT_0 */\n  if ((VAR_8 = VAR_0->schematahash) == 0)\n    {\n      VAR_0->schematahash = VAR_8 = solv_calloc(256, sizeof(Id));\n      for (VAR_5 = 1; VAR_5 < VAR_0->nschemata; VAR_5++)\n\t{\n\t  for (VAR_6 = VAR_0->schemadata + VAR_0->schemata[VAR_5], VAR_3 = 0; *VAR_6;)\n\t    VAR_3 = VAR_3 * 7 + *VAR_6++;\n\t  VAR_3 &= 255;\n\t  VAR_8[VAR_3] = VAR_5;\n\t}\n      VAR_0->schemadata = solv_extend_resize(VAR_0->schemadata, VAR_0->schemadatalen, sizeof(Id), VAR_9);\n      VAR_0->schemata = solv_extend_resize(VAR_0->schemata, VAR_0->nschemata, sizeof(Id), VAR_10);\n    }\n\n  for (VAR_6 = VAR_1, VAR_4 = 0, VAR_3 = 0; *VAR_6; VAR_4++)\n    VAR_3 = VAR_3 * 7 + *VAR_6++;\n  VAR_3 &= 255;\n  VAR_4++;\n\n  VAR_7 = VAR_8[VAR_3];\n  if (VAR_7)\n    {\n      if ((VAR_0->schemata[VAR_7] + VAR_4 <= VAR_0->schemadatalen) &&\n\t\t\t  !memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))\n        return VAR_7;\n      /* COMMENT_1 */\n      for (VAR_7 = 1; VAR_7 < VAR_0->nschemata; VAR_7++)\n        if ((VAR_0->schemata[VAR_7] + VAR_4 <= VAR_0->schemadatalen) &&\n\t\t\t\t!memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))\n          return VAR_7;\n    }\n  /* COMMENT_2 */\n  if (!VAR_2)\n    return 0;\n  VAR_0->schemadata = solv_extend(VAR_0->schemadata, VAR_0->schemadatalen, VAR_4, sizeof(Id), VAR_9);\n  VAR_0->schemata = solv_extend(VAR_0->schemata, VAR_0->nschemata, 1, sizeof(Id), VAR_10);\n  /* COMMENT_3 */\n  memcpy(VAR_0->schemadata + VAR_0->schemadatalen, VAR_1, VAR_4 * sizeof(Id));\n  VAR_0->schemata[VAR_0->nschemata] = VAR_0->schemadatalen;\n  VAR_0->schemadatalen += VAR_4;\n  VAR_8[VAR_3] = VAR_0->nschemata;\n#if 0\nfprintf(VAR_11, \"schema2id: new schema\\n\");\n#endif\n  return VAR_0->nschemata++;\n}",
  "func_graph_path": "openSUSE/libsolv/fdb9c9c03508990e4583046b590c30d958f272da/repodata.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,11 +29,13 @@\n   cid = schematahash[h];\n   if (cid)\n     {\n-      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n+      if ((data->schemata[cid] + len <= data->schemadatalen) &&\n+\t\t\t  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n         return cid;\n       /* cache conflict, do a slow search */\n       for (cid = 1; cid < data->nschemata; cid++)\n-        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n+        if ((data->schemata[cid] + len <= data->schemadatalen) &&\n+\t\t\t\t!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n           return cid;\n     }\n   /* a new one */",
  "diff_line_info": {
    "deleted_lines": [
      "      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))",
      "        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))"
    ],
    "added_lines": [
      "      if ((data->schemata[cid] + len <= data->schemadatalen) &&",
      "\t\t\t  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))",
      "        if ((data->schemata[cid] + len <= data->schemadatalen) &&",
      "\t\t\t\t!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openSUSE/libsolv/pull/344",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/openSUSE/libsolv/pull/344: 403 Client Error: Forbidden for url: https://api.github.com/repos/openSUSE/libsolv/pulls/344",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a heap-buffer-overflow issue, which is a security vulnerability. The code includes a boundary check to prevent out-of-bounds memory access, clearly fixing a security issue.\n\n**Confidence:** 1.0 (All information is consistent, clearly indicating a security fix.)\n\n**Final Classification:** Security Vulnerability Fix. \n\nConfidence: 1.0"
}