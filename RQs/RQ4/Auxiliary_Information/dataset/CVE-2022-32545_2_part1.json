{
  "cve_id": "CVE-2022-32545",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ImageMagick",
  "commit_msg": "fix issue: outside the range of representable values of type 'unsigned int' at coders/psd.c:1025 (#4963)\n\n* fix Division by zero in XMenuWidget() of MagickCore/widget.c\r\n\r\n* Fix memory leak in AnimateImageCommand() of MagickWand/animate.c and DisplayImageCommand() of MagickWand/display.c\r\n\r\n* fix Division by zero in ReadEnhMetaFile() of coders/emf.c\r\n\r\n* Resolve conflicts\r\n\r\n* fix issue: outside the range of representable values of type 'unsigned char' at coders/psd.c:1025\r\n\r\nCo-authored-by: zhailiangliang <zhailiangliang@loongson.cn>",
  "commit_hash": "9c9a84cec4ab28ee0b57c2b9266d6fbe68183512",
  "git_url": "https://github.com/ImageMagick/ImageMagick/commit/9c9a84cec4ab28ee0b57c2b9266d6fbe68183512",
  "file_path": "coders/psd.c",
  "func_name": "ReadPSDChannelPixels",
  "func_before": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
  "abstract_func_before": "static MagickBooleanType ReadPSDChannelPixels(Image *VAR_0,const ssize_t VAR_1,\n  const PixelChannel VAR_2,const unsigned char *VAR_3,\n  ExceptionInfo *VAR_4)\n{\n  Quantum\n    VAR_5;\n\n  const unsigned char\n    *VAR_6;\n\n  Quantum\n    *VAR_7;\n\n  ssize_t\n    VAR_8;\n\n  size_t\n    VAR_9;\n\n  VAR_6=VAR_3;\n  VAR_7=GetAuthenticPixels(VAR_0,0,VAR_1,VAR_0->columns,1,VAR_4);\n  if (VAR_7 == (Quantum *) NULL)\n    return VAR_10;\n  VAR_9=GetPSDPacketSize(VAR_0);\n  for (VAR_8=0; VAR_8 < (ssize_t) VAR_0->columns; VAR_8++)\n  {\n    if (VAR_9 == 1)\n      VAR_5=ScaleCharToQuantum(*VAR_6++);\n    else\n      if (VAR_9 == 2)\n        {\n          unsigned short\n            VAR_11;\n\n          VAR_6=PushShortPixel(VAR_12,VAR_6,&VAR_11);\n          VAR_5=ScaleShortToQuantum(VAR_11);\n        }\n      else\n        {\n          MagickFloatType\n            VAR_11;\n\n          VAR_6=PushFloatPixel(VAR_12,VAR_6,&VAR_11);\n          VAR_5=ClampToQuantum(((MagickRealType) VAR_13)*VAR_11);\n        }\n    if (VAR_0->depth > 1)\n      {\n        SetPSDPixel(VAR_0,VAR_2,VAR_9,VAR_5,VAR_7,VAR_4);\n        VAR_7+=GetPixelChannels(VAR_0);\n      }\n    else\n      {\n        ssize_t\n          VAR_14,\n          VAR_15;\n\n        VAR_15=(ssize_t) VAR_0->columns-VAR_8;\n        if (VAR_15 > 8)\n          VAR_15=8;\n        for (VAR_14 = 0; VAR_14 < (ssize_t) VAR_15; VAR_14++)\n        {\n          SetPSDPixel(VAR_0,VAR_2,VAR_9,(((unsigned char) VAR_5)\n            & (0x01 << (7-VAR_14))) != 0 ? 0 : VAR_13,VAR_7,VAR_4);\n          VAR_7+=GetPixelChannels(VAR_0);\n          VAR_8++;\n        }\n        if (VAR_8 != (ssize_t) VAR_0->columns)\n          VAR_8--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(VAR_0,VAR_4));\n}",
  "func_graph_path_before": "ImageMagick/9c9a84cec4ab28ee0b57c2b9266d6fbe68183512/psd.c/vul/before/0.json",
  "func": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char)((ssize_t)pixel))\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
  "abstract_func": "static MagickBooleanType ReadPSDChannelPixels(Image *VAR_0,const ssize_t VAR_1,\n  const PixelChannel VAR_2,const unsigned char *VAR_3,\n  ExceptionInfo *VAR_4)\n{\n  Quantum\n    VAR_5;\n\n  const unsigned char\n    *VAR_6;\n\n  Quantum\n    *VAR_7;\n\n  ssize_t\n    VAR_8;\n\n  size_t\n    VAR_9;\n\n  VAR_6=VAR_3;\n  VAR_7=GetAuthenticPixels(VAR_0,0,VAR_1,VAR_0->columns,1,VAR_4);\n  if (VAR_7 == (Quantum *) NULL)\n    return VAR_10;\n  VAR_9=GetPSDPacketSize(VAR_0);\n  for (VAR_8=0; VAR_8 < (ssize_t) VAR_0->columns; VAR_8++)\n  {\n    if (VAR_9 == 1)\n      VAR_5=ScaleCharToQuantum(*VAR_6++);\n    else\n      if (VAR_9 == 2)\n        {\n          unsigned short\n            VAR_11;\n\n          VAR_6=PushShortPixel(VAR_12,VAR_6,&VAR_11);\n          VAR_5=ScaleShortToQuantum(VAR_11);\n        }\n      else\n        {\n          MagickFloatType\n            VAR_11;\n\n          VAR_6=PushFloatPixel(VAR_12,VAR_6,&VAR_11);\n          VAR_5=ClampToQuantum(((MagickRealType) VAR_13)*VAR_11);\n        }\n    if (VAR_0->depth > 1)\n      {\n        SetPSDPixel(VAR_0,VAR_2,VAR_9,VAR_5,VAR_7,VAR_4);\n        VAR_7+=GetPixelChannels(VAR_0);\n      }\n    else\n      {\n        ssize_t\n          VAR_14,\n          VAR_15;\n\n        VAR_15=(ssize_t) VAR_0->columns-VAR_8;\n        if (VAR_15 > 8)\n          VAR_15=8;\n        for (VAR_14 = 0; VAR_14 < (ssize_t) VAR_15; VAR_14++)\n        {\n          SetPSDPixel(VAR_0,VAR_2,VAR_9,(((unsigned char)((ssize_t)VAR_5))\n            & (0x01 << (7-VAR_14))) != 0 ? 0 : VAR_13,VAR_7,VAR_4);\n          VAR_7+=GetPixelChannels(VAR_0);\n          VAR_8++;\n        }\n        if (VAR_8 != (ssize_t) VAR_0->columns)\n          VAR_8--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(VAR_0,VAR_4));\n}",
  "func_graph_path": "ImageMagick/9c9a84cec4ab28ee0b57c2b9266d6fbe68183512/psd.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -59,7 +59,7 @@\n           number_bits=8;\n         for (bit = 0; bit < (ssize_t) number_bits; bit++)\n         {\n-          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n+          SetPSDPixel(image,channel,packet_size,(((unsigned char)((ssize_t)pixel))\n             & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n           q+=GetPixelChannels(image);\n           x++;",
  "diff_line_info": {
    "deleted_lines": [
      "          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)"
    ],
    "added_lines": [
      "          SetPSDPixel(image,channel,packet_size,(((unsigned char)((ssize_t)pixel))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ImageMagick/ImageMagick/pull/4963",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/ImageMagick/ImageMagick/pull/4963: 403 Client Error: Forbidden for url: https://api.github.com/repos/ImageMagick/ImageMagick/pulls/4963",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.7\n\n---\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:**\n   - The commit message addresses several potential issues, including integer overflows and division by zero.\n   - The vulnerability description ties specifically to an overflow in 'unsigned char'.\n   - The code diff modifies data casting to prevent overflow.\n\n2. **Consistency Check:**\n   - The code changes match the issues mentioned, focusing on overflow prevention.\n\n3. **Purpose Evaluation:**\n   - The fix modifies core logic to prevent data handling errors, which can lead to security issues.\n\n4. **Security Vulnerability Assessment:**\n   - The patch addresses overflow, which could lead to security risks like buffer overflows, though not explicitly tied to CVE/CWE.\n\n5. **Non-Security Classification (if not security):**\n   - Would fall under 'Defect Remediation', but given the nature, leans towards security.\n\n6. **Confidence Scoring:**\n   - High confidence it addresses a bug with potential security implications but lacks explicit CVE reference.\n\n---\n\n**Final Answer:**\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.6"
}