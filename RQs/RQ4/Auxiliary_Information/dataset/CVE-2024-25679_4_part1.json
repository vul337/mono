{
  "cve_id": "CVE-2024-25679",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "p-quic/pquic",
  "commit_msg": "discard the keys after handshake is done; use the correct original_destination_connection_id; discard the re-transmission packets correctly; limit the active_connection_id",
  "commit_hash": "2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "git_url": "https://github.com/p-quic/pquic/commit/2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "file_path": "picoquic/sender.c",
  "func_name": "picoquic_protect_packet",
  "func_before": "uint32_t picoquic_protect_packet(picoquic_cnx_t* cnx,\n    picoquic_packet_type_enum ptype,\n    uint8_t * bytes,\n    picoquic_path_t* path_x,\n    uint64_t sequence_number,\n    uint32_t length, uint32_t header_length,\n    uint8_t* send_buffer, uint32_t send_buffer_max,\n    picoquic_packet_header *ph,\n    void * aead_context, void* pn_enc)\n{\n    uint32_t send_length;\n    uint32_t h_length;\n    uint32_t pn_offset = 0;\n    size_t sample_offset = 0;\n    uint32_t pn_length = 0;\n    uint32_t aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);\n\n    /* Create the packet header just before encrypting the content */\n    h_length = picoquic_create_packet_header(cnx, ptype, path_x,\n        sequence_number, send_buffer, &pn_offset, &pn_length);\n    /* Make sure that the payload length is encoded in the header */\n    /* Using encryption, the \"payload\" length also includes the encrypted packet length */\n    picoquic_update_payload_length(send_buffer, pn_offset, h_length - pn_length, length + aead_checksum_length);\n\n    picoquic_cnx_t *pcnx = cnx;\n    if (ph != NULL) {\n        picoquic_parse_packet_header(cnx->quic, send_buffer, length + aead_checksum_length, (struct sockaddr *) &path_x->local_addr, ph, &pcnx, false);\n    }\n\n    /* If fuzzing is required, apply it*/\n    if (cnx->quic->fuzz_fn != NULL) {\n        if (h_length == header_length) {\n            memcpy(bytes, send_buffer, header_length);\n        }\n        length = cnx->quic->fuzz_fn(cnx->quic->fuzz_ctx, cnx, bytes,\n            send_buffer_max - aead_checksum_length, length, header_length);\n        if (h_length == header_length) {\n            memcpy(send_buffer, bytes, header_length);\n        }\n    }\n\n    /* Encrypt the packet */\n    send_length = (uint32_t)picoquic_aead_encrypt_generic(send_buffer + /* header_length */ h_length,\n        bytes + header_length, length - header_length,\n        sequence_number, send_buffer, /* header_length */ h_length, aead_context);\n\n    send_length += /* header_length */ h_length;\n\n    /* if needed, log the segment */\n    if (cnx->quic->F_log != NULL) {\n        picoquic_log_outgoing_segment(cnx->quic->F_log, 1, cnx,\n                                      bytes, sequence_number, length,\n                                      send_buffer, send_length);\n    }\n\n    /* Next, encrypt the PN -- The sample is located after the pn_offset */\n    sample_offset = /* header_length */ pn_offset + 4;\n\n    if (pn_offset < sample_offset)\n    {\n        uint8_t first_mask = (ph->ptype == picoquic_packet_1rtt_protected_phi0 || ph->ptype == picoquic_packet_1rtt_protected_phi1) ? 0x1F : 0x0F;\n        /* This is always true, as use pn_length = 4 */\n        uint8_t mask[5] = { 0, 0, 0, 0, 0 };\n        uint8_t pn_l;\n\n        picoquic_hp_encrypt(pn_enc, send_buffer + sample_offset, mask, mask, 5);\n        /* Encode the first byte */\n        pn_l = (send_buffer[0] & 3) + 1;\n        send_buffer[0] ^= (mask[0] & first_mask);\n\n        /* Packet encoding is 1 to 4 bytes */\n        for (uint8_t i = 0; i < pn_l; i++) {\n            send_buffer[pn_offset+i] ^= mask[i+1];\n        }\n    }\n\n\n    return send_length;\n}",
  "abstract_func_before": "uint32_t picoquic_protect_packet(picoquic_cnx_t* VAR_0,\n    picoquic_packet_type_enum VAR_1,\n    uint8_t * VAR_2,\n    picoquic_path_t* VAR_3,\n    uint64_t VAR_4,\n    uint32_t VAR_5, uint32_t VAR_6,\n    uint8_t* VAR_7, uint32_t VAR_8,\n    picoquic_packet_header *VAR_9,\n    void * VAR_10, void* VAR_11)\n{\n    uint32_t VAR_12;\n    uint32_t VAR_13;\n    uint32_t VAR_14 = 0;\n    size_t VAR_15 = 0;\n    uint32_t VAR_16 = 0;\n    uint32_t VAR_17 = (uint32_t)picoquic_aead_get_checksum_length(VAR_10);\n\n    /* COMMENT_0 */\n    VAR_13 = picoquic_create_packet_header(VAR_0, VAR_1, VAR_3,\n        VAR_4, VAR_7, &VAR_14, &VAR_16);\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    picoquic_update_payload_length(VAR_7, VAR_14, VAR_13 - VAR_16, VAR_5 + VAR_17);\n\n    picoquic_cnx_t *VAR_18 = VAR_0;\n    if (VAR_9 != NULL) {\n        picoquic_parse_packet_header(VAR_0->quic, VAR_7, VAR_5 + VAR_17, (struct sockaddr *) &VAR_3->local_addr, VAR_9, &VAR_18, false);\n    }\n\n    /* COMMENT_3 */\n    if (VAR_0->quic->fuzz_fn != NULL) {\n        if (VAR_13 == VAR_6) {\n            memcpy(VAR_2, VAR_7, VAR_6);\n        }\n        VAR_5 = VAR_0->quic->fuzz_fn(VAR_0->quic->fuzz_ctx, VAR_0, VAR_2,\n            VAR_8 - VAR_17, VAR_5, VAR_6);\n        if (VAR_13 == VAR_6) {\n            memcpy(VAR_7, VAR_2, VAR_6);\n        }\n    }\n\n    /* COMMENT_4 */\n    VAR_12 = (uint32_t)picoquic_aead_encrypt_generic(VAR_7 + /* COMMENT_5 */ VAR_13,\n        VAR_2 + VAR_6, VAR_5 - VAR_6,\n        VAR_4, VAR_7, /* COMMENT_5 */ VAR_13, VAR_10);\n\n    VAR_12 += /* COMMENT_5 */ VAR_13;\n\n    /* COMMENT_6 */\n    if (VAR_0->quic->F_log != NULL) {\n        picoquic_log_outgoing_segment(VAR_0->quic->F_log, 1, VAR_0,\n                                      VAR_2, VAR_4, VAR_5,\n                                      VAR_7, VAR_12);\n    }\n\n    /* COMMENT_7 */\n    VAR_15 = /* COMMENT_5 */ VAR_14 + 4;\n\n    if (VAR_14 < VAR_15)\n    {\n        uint8_t VAR_19 = (VAR_9->ptype == VAR_20 || VAR_9->ptype == VAR_21) ? 0x1F : 0x0F;\n        /* COMMENT_8 */\n        uint8_t VAR_22[5] = { 0, 0, 0, 0, 0 };\n        uint8_t VAR_23;\n\n        picoquic_hp_encrypt(VAR_11, VAR_7 + VAR_15, VAR_22, VAR_22, 5);\n        /* COMMENT_9 */\n        VAR_23 = (VAR_7[0] & 3) + 1;\n        VAR_7[0] ^= (VAR_22[0] & VAR_19);\n\n        /* COMMENT_10 */\n        for (uint8_t VAR_24 = 0; VAR_24 < VAR_23; VAR_24++) {\n            VAR_7[VAR_14+VAR_24] ^= VAR_22[VAR_24+1];\n        }\n    }\n\n\n    return VAR_12;\n}",
  "func_graph_path_before": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/sender.c/vul/before/1.json",
  "func": "uint32_t picoquic_protect_packet(picoquic_cnx_t* cnx,\n    picoquic_packet_type_enum ptype,\n    uint8_t * bytes,\n    picoquic_path_t* path_x,\n    uint64_t sequence_number,\n    uint32_t length, uint32_t header_length,\n    uint8_t* send_buffer, uint32_t send_buffer_max,\n    picoquic_packet_header *ph,\n    void * aead_context, void* pn_enc)\n{\n    uint32_t send_length;\n    uint32_t h_length;\n    uint32_t pn_offset = 0;\n    size_t sample_offset = 0;\n    uint32_t pn_length = 0;\n    uint32_t aead_checksum_length;\n    \n    if(aead_context != NULL){\n        aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);\n    }else{\n        return 0;\n    }\n\n    /* Create the packet header just before encrypting the content */\n    h_length = picoquic_create_packet_header(cnx, ptype, path_x,\n        sequence_number, send_buffer, &pn_offset, &pn_length);\n    /* Make sure that the payload length is encoded in the header */\n    /* Using encryption, the \"payload\" length also includes the encrypted packet length */\n    picoquic_update_payload_length(send_buffer, pn_offset, h_length - pn_length, length + aead_checksum_length);\n\n    picoquic_cnx_t *pcnx = cnx;\n    if (ph != NULL) {\n        picoquic_parse_packet_header(cnx->quic, send_buffer, length + aead_checksum_length, (struct sockaddr *) &path_x->local_addr, ph, &pcnx, false);\n    }\n\n    /* If fuzzing is required, apply it*/\n    if (cnx->quic->fuzz_fn != NULL) {\n        if (h_length == header_length) {\n            memcpy(bytes, send_buffer, header_length);\n        }\n        length = cnx->quic->fuzz_fn(cnx->quic->fuzz_ctx, cnx, bytes,\n            send_buffer_max - aead_checksum_length, length, header_length);\n        if (h_length == header_length) {\n            memcpy(send_buffer, bytes, header_length);\n        }\n    }\n\n    /* Encrypt the packet */\n    send_length = (uint32_t)picoquic_aead_encrypt_generic(send_buffer + /* header_length */ h_length,\n        bytes + header_length, length - header_length,\n        sequence_number, send_buffer, /* header_length */ h_length, aead_context);\n\n    send_length += /* header_length */ h_length;\n\n    /* if needed, log the segment */\n    if (cnx->quic->F_log != NULL) {\n        picoquic_log_outgoing_segment(cnx->quic->F_log, 1, cnx,\n                                      bytes, sequence_number, length,\n                                      send_buffer, send_length);\n    }\n\n    /* Next, encrypt the PN -- The sample is located after the pn_offset */\n    sample_offset = /* header_length */ pn_offset + 4;\n\n    if (pn_offset < sample_offset)\n    {\n        uint8_t first_mask = (ph->ptype == picoquic_packet_1rtt_protected_phi0 || ph->ptype == picoquic_packet_1rtt_protected_phi1) ? 0x1F : 0x0F;\n        /* This is always true, as use pn_length = 4 */\n        uint8_t mask[5] = { 0, 0, 0, 0, 0 };\n        uint8_t pn_l;\n\n        picoquic_hp_encrypt(pn_enc, send_buffer + sample_offset, mask, mask, 5);\n        /* Encode the first byte */\n        pn_l = (send_buffer[0] & 3) + 1;\n        send_buffer[0] ^= (mask[0] & first_mask);\n\n        /* Packet encoding is 1 to 4 bytes */\n        for (uint8_t i = 0; i < pn_l; i++) {\n            send_buffer[pn_offset+i] ^= mask[i+1];\n        }\n    }\n\n\n    return send_length;\n}",
  "abstract_func": "uint32_t picoquic_protect_packet(picoquic_cnx_t* VAR_0,\n    picoquic_packet_type_enum VAR_1,\n    uint8_t * VAR_2,\n    picoquic_path_t* VAR_3,\n    uint64_t VAR_4,\n    uint32_t VAR_5, uint32_t VAR_6,\n    uint8_t* VAR_7, uint32_t VAR_8,\n    picoquic_packet_header *VAR_9,\n    void * VAR_10, void* VAR_11)\n{\n    uint32_t VAR_12;\n    uint32_t VAR_13;\n    uint32_t VAR_14 = 0;\n    size_t VAR_15 = 0;\n    uint32_t VAR_16 = 0;\n    uint32_t VAR_17;\n    \n    if(VAR_10 != NULL){\n        VAR_17 = (uint32_t)picoquic_aead_get_checksum_length(VAR_10);\n    }else{\n        return 0;\n    }\n\n    /* COMMENT_0 */\n    VAR_13 = picoquic_create_packet_header(VAR_0, VAR_1, VAR_3,\n        VAR_4, VAR_7, &VAR_14, &VAR_16);\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    picoquic_update_payload_length(VAR_7, VAR_14, VAR_13 - VAR_16, VAR_5 + VAR_17);\n\n    picoquic_cnx_t *VAR_18 = VAR_0;\n    if (VAR_9 != NULL) {\n        picoquic_parse_packet_header(VAR_0->quic, VAR_7, VAR_5 + VAR_17, (struct sockaddr *) &VAR_3->local_addr, VAR_9, &VAR_18, false);\n    }\n\n    /* COMMENT_3 */\n    if (VAR_0->quic->fuzz_fn != NULL) {\n        if (VAR_13 == VAR_6) {\n            memcpy(VAR_2, VAR_7, VAR_6);\n        }\n        VAR_5 = VAR_0->quic->fuzz_fn(VAR_0->quic->fuzz_ctx, VAR_0, VAR_2,\n            VAR_8 - VAR_17, VAR_5, VAR_6);\n        if (VAR_13 == VAR_6) {\n            memcpy(VAR_7, VAR_2, VAR_6);\n        }\n    }\n\n    /* COMMENT_4 */\n    VAR_12 = (uint32_t)picoquic_aead_encrypt_generic(VAR_7 + /* COMMENT_5 */ VAR_13,\n        VAR_2 + VAR_6, VAR_5 - VAR_6,\n        VAR_4, VAR_7, /* COMMENT_5 */ VAR_13, VAR_10);\n\n    VAR_12 += /* COMMENT_5 */ VAR_13;\n\n    /* COMMENT_6 */\n    if (VAR_0->quic->F_log != NULL) {\n        picoquic_log_outgoing_segment(VAR_0->quic->F_log, 1, VAR_0,\n                                      VAR_2, VAR_4, VAR_5,\n                                      VAR_7, VAR_12);\n    }\n\n    /* COMMENT_7 */\n    VAR_15 = /* COMMENT_5 */ VAR_14 + 4;\n\n    if (VAR_14 < VAR_15)\n    {\n        uint8_t VAR_19 = (VAR_9->ptype == VAR_20 || VAR_9->ptype == VAR_21) ? 0x1F : 0x0F;\n        /* COMMENT_8 */\n        uint8_t VAR_22[5] = { 0, 0, 0, 0, 0 };\n        uint8_t VAR_23;\n\n        picoquic_hp_encrypt(VAR_11, VAR_7 + VAR_15, VAR_22, VAR_22, 5);\n        /* COMMENT_9 */\n        VAR_23 = (VAR_7[0] & 3) + 1;\n        VAR_7[0] ^= (VAR_22[0] & VAR_19);\n\n        /* COMMENT_10 */\n        for (uint8_t VAR_24 = 0; VAR_24 < VAR_23; VAR_24++) {\n            VAR_7[VAR_14+VAR_24] ^= VAR_22[VAR_24+1];\n        }\n    }\n\n\n    return VAR_12;\n}",
  "func_graph_path": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/sender.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,13 @@\n     uint32_t pn_offset = 0;\n     size_t sample_offset = 0;\n     uint32_t pn_length = 0;\n-    uint32_t aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);\n+    uint32_t aead_checksum_length;\n+    \n+    if(aead_context != NULL){\n+        aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);\n+    }else{\n+        return 0;\n+    }\n \n     /* Create the packet header just before encrypting the content */\n     h_length = picoquic_create_packet_header(cnx, ptype, path_x,",
  "diff_line_info": {
    "deleted_lines": [
      "    uint32_t aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);"
    ],
    "added_lines": [
      "    uint32_t aead_checksum_length;",
      "    ",
      "    if(aead_context != NULL){",
      "        aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);",
      "    }else{",
      "        return 0;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/p-quic/pquic/pull/39",
  "description": {
    "pr_info": {
      "title": "Minor Fix",
      "number": 39
    },
    "comment": [
      "Hi, I try to fix the bugs in #34 #35 #36 and #38.\r\n\r\nCan you validate these fixes please.\r\n",
      "The code looks good. Have you done any test to ensure it fixes these issues ?"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.85"
}