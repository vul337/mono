{
  "cve_id": "CVE-2021-32844",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "moby/hyperkit",
  "commit_msg": "Fix vi_pci_write null vc_cfgwrite function pointer dereference (GHSL-2021-055)\n\nThis is a backport of what is done in bhyve.\n\nSigned-off-by: Frederic Dalleau <frederic.dalleau@docker.com>",
  "commit_hash": "451558fe8aaa8b24e02e34106e3bb9fe41d7ad13",
  "git_url": "https://github.com/moby/hyperkit/commit/451558fe8aaa8b24e02e34106e3bb9fe41d7ad13",
  "file_path": "src/lib/virtio.c",
  "func_name": "vi_pci_write",
  "func_before": "void\nvi_pci_write(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size, uint64_t value)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct vqueue_info *vq;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\tpci_emul_msix_twrite(pi, offset, size, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n\t\t\t((uint32_t) value));\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size || cr->cr_ro) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, wrong size and/or reg is R/O */\n\t\t\tif (cr->cr_size != size)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    name, cr->cr_name, size);\n\t\t\tif (cr->cr_ro)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    name, cr->cr_name);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_GUESTCAP:\n\t\tvs->vs_negotiated_caps = (uint32_t) (value & vc->vc_hv_caps);\n\t\tif (vc->vc_apply_features)\n\t\t\t(*vc->vc_apply_features)(DEV_SOFTC(vs),\n\t\t\t    vs->vs_negotiated_caps);\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(vs, ((uint32_t) value));\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\t/*\n\t\t * Note that the guest is allowed to select an\n\t\t * invalid queue; we just need to return a QNUM\n\t\t * of 0 while the bad queue is selected.\n\t\t */\n\t\tvs->vs_curq = (int) value;\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tif (value >= ((uint64_t) vc->vc_nvq)) {\n\t\t\tfprintf(stderr, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\t\tgoto done;\n\t\t}\n\t\tvq = &vs->vs_queues[value];\n\t\tif (vq->vq_notify)\n\t\t\t(*vq->vq_notify)(DEV_SOFTC(vs), vq);\n\t\telse if (vc->vc_qnotify)\n\t\t\t(*vc->vc_qnotify)(DEV_SOFTC(vs), vq);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvs->vs_status = (uint8_t) value;\n\t\tif (value == 0)\n\t\t\t(*vc->vc_reset)(DEV_SOFTC(vs));\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvs->vs_msix_cfg_idx = (uint16_t) value;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvq = &vs->vs_queues[vs->vs_curq];\n\t\tvq->vq_msix_idx = (uint16_t) value;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(stderr,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    name, cr->cr_name, vs->vs_curq, vc->vc_nvq);\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n}",
  "abstract_func_before": "void\nvi_pci_write(UNUSED int VAR_0, struct pci_devinst *VAR_1, int VAR_2,\n\tuint64_t VAR_3, int VAR_4, uint64_t VAR_5)\n{\n\tstruct virtio_softc *VAR_6 = VAR_1->pi_arg;\n\tstruct vqueue_info *VAR_7;\n\tstruct virtio_consts *VAR_8;\n\tstruct config_reg *VAR_9;\n\tuint64_t VAR_10, VAR_11;\n\tconst char *VAR_12;\n\tuint32_t VAR_13;\n\tint VAR_14;\n\n\tif (VAR_6->vs_flags & VAR_15) {\n\t\tif (VAR_2 == pci_msix_table_bar(VAR_1) ||\n\t\t    VAR_2 == pci_msix_pba_bar(VAR_1)) {\n\t\t\tpci_emul_msix_twrite(VAR_1, VAR_3, VAR_4, VAR_5);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n\tassert(VAR_2 == 0);\n\n\tif (VAR_6->vs_mtx)\n\t\tpthread_mutex_lock(VAR_6->vs_mtx);\n\n\tVAR_8 = VAR_6->vs_vc;\n\tVAR_12 = VAR_8->vc_name;\n\n\tif (VAR_4 != 1 && VAR_4 != 2 && VAR_4 != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(VAR_1))\n\t\tVAR_10 = VAR_16;\n\telse\n\t\tVAR_10 = VAR_17;\n\n\tif (VAR_3 >= VAR_10) {\n\t\t/* COMMENT_1 */\n                                                    \n                                                             \n     \n\t\tVAR_13 = (uint32_t) (VAR_3 - VAR_10);\n\t\tVAR_11 = VAR_8->vc_cfgsize ? VAR_8->vc_cfgsize : 0x100000000;\n\t\tif ((VAR_13 + ((unsigned) VAR_4)) > VAR_11)\n\t\t\tgoto bad;\n\t\tVAR_14 = (*VAR_8->vc_cfgwrite)(DEV_SOFTC(VAR_6), ((int) VAR_13), VAR_4,\n\t\t\t((uint32_t) VAR_5));\n\t\tif (!VAR_14)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tVAR_9 = vi_find_cr((int) VAR_3);\n\tif (VAR_9 == NULL || VAR_9->cr_size != VAR_4 || VAR_9->cr_ro) {\n\t\tif (VAR_9 != NULL) {\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_9->cr_size != VAR_4)\n\t\t\t\tfprintf(VAR_18,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    VAR_12, VAR_9->cr_name, VAR_4);\n\t\t\tif (VAR_9->cr_ro)\n\t\t\t\tfprintf(VAR_18,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    VAR_12, VAR_9->cr_name);\n\t\t} else {\n\t\t\tfprintf(VAR_18,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    VAR_12, (uintmax_t)VAR_3, VAR_4);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (VAR_3) {\n\tcase VAR_19:\n\t\tVAR_6->vs_negotiated_caps = (uint32_t) (VAR_5 & VAR_8->vc_hv_caps);\n\t\tif (VAR_8->vc_apply_features)\n\t\t\t(*VAR_8->vc_apply_features)(DEV_SOFTC(VAR_6),\n\t\t\t    VAR_6->vs_negotiated_caps);\n\t\tbreak;\n\tcase VAR_20:\n\t\tif (VAR_6->vs_curq >= VAR_8->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(VAR_6, ((uint32_t) VAR_5));\n\t\tbreak;\n\tcase VAR_21:\n\t\t/* COMMENT_6 */\n                                                \n                                                 \n                                          \n     \n\t\tVAR_6->vs_curq = (int) VAR_5;\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (VAR_5 >= ((uint64_t) VAR_8->vc_nvq)) {\n\t\t\tfprintf(VAR_18, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tVAR_12, (int)VAR_5);\n\t\t\tgoto done;\n\t\t}\n\t\tVAR_7 = &VAR_6->vs_queues[VAR_5];\n\t\tif (VAR_7->vq_notify)\n\t\t\t(*VAR_7->vq_notify)(DEV_SOFTC(VAR_6), VAR_7);\n\t\telse if (VAR_8->vc_qnotify)\n\t\t\t(*VAR_8->vc_qnotify)(DEV_SOFTC(VAR_6), VAR_7);\n\t\telse\n\t\t\tfprintf(VAR_18,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tVAR_12, (int)VAR_5);\n\t\tbreak;\n\tcase VAR_23:\n\t\tVAR_6->vs_status = (uint8_t) VAR_5;\n\t\tif (VAR_5 == 0)\n\t\t\t(*VAR_8->vc_reset)(DEV_SOFTC(VAR_6));\n\t\tbreak;\n\tcase VAR_24:\n\t\tVAR_6->vs_msix_cfg_idx = (uint16_t) VAR_5;\n\t\tbreak;\n\tcase VAR_25:\n\t\tif (VAR_6->vs_curq >= VAR_8->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tVAR_7 = &VAR_6->vs_queues[VAR_6->vs_curq];\n\t\tVAR_7->vq_msix_idx = (uint16_t) VAR_5;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(VAR_18,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    VAR_12, VAR_9->cr_name, VAR_6->vs_curq, VAR_8->vc_nvq);\ndone:\n\tif (VAR_6->vs_mtx)\n\t\tpthread_mutex_unlock(VAR_6->vs_mtx);\n}",
  "func_graph_path_before": null,
  "func": "void\nvi_pci_write(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size, uint64_t value)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct vqueue_info *vq;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\tpci_emul_msix_twrite(pi, offset, size, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgwrite != NULL)\n\t\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n\t\t\t\t((uint32_t) value));\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size || cr->cr_ro) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, wrong size and/or reg is R/O */\n\t\t\tif (cr->cr_size != size)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    name, cr->cr_name, size);\n\t\t\tif (cr->cr_ro)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    name, cr->cr_name);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_GUESTCAP:\n\t\tvs->vs_negotiated_caps = (uint32_t) (value & vc->vc_hv_caps);\n\t\tif (vc->vc_apply_features)\n\t\t\t(*vc->vc_apply_features)(DEV_SOFTC(vs),\n\t\t\t    vs->vs_negotiated_caps);\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(vs, ((uint32_t) value));\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\t/*\n\t\t * Note that the guest is allowed to select an\n\t\t * invalid queue; we just need to return a QNUM\n\t\t * of 0 while the bad queue is selected.\n\t\t */\n\t\tvs->vs_curq = (int) value;\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tif (value >= ((uint64_t) vc->vc_nvq)) {\n\t\t\tfprintf(stderr, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\t\tgoto done;\n\t\t}\n\t\tvq = &vs->vs_queues[value];\n\t\tif (vq->vq_notify)\n\t\t\t(*vq->vq_notify)(DEV_SOFTC(vs), vq);\n\t\telse if (vc->vc_qnotify)\n\t\t\t(*vc->vc_qnotify)(DEV_SOFTC(vs), vq);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tname, (int)value);\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvs->vs_status = (uint8_t) value;\n\t\tif (value == 0)\n\t\t\t(*vc->vc_reset)(DEV_SOFTC(vs));\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvs->vs_msix_cfg_idx = (uint16_t) value;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tif (vs->vs_curq >= vc->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvq = &vs->vs_queues[vs->vs_curq];\n\t\tvq->vq_msix_idx = (uint16_t) value;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(stderr,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    name, cr->cr_name, vs->vs_curq, vc->vc_nvq);\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n}",
  "abstract_func": "void\nvi_pci_write(UNUSED int VAR_0, struct pci_devinst *VAR_1, int VAR_2,\n\tuint64_t VAR_3, int VAR_4, uint64_t VAR_5)\n{\n\tstruct virtio_softc *VAR_6 = VAR_1->pi_arg;\n\tstruct vqueue_info *VAR_7;\n\tstruct virtio_consts *VAR_8;\n\tstruct config_reg *VAR_9;\n\tuint64_t VAR_10, VAR_11;\n\tconst char *VAR_12;\n\tuint32_t VAR_13;\n\tint VAR_14;\n\n\tif (VAR_6->vs_flags & VAR_15) {\n\t\tif (VAR_2 == pci_msix_table_bar(VAR_1) ||\n\t\t    VAR_2 == pci_msix_pba_bar(VAR_1)) {\n\t\t\tpci_emul_msix_twrite(VAR_1, VAR_3, VAR_4, VAR_5);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n\tassert(VAR_2 == 0);\n\n\tif (VAR_6->vs_mtx)\n\t\tpthread_mutex_lock(VAR_6->vs_mtx);\n\n\tVAR_8 = VAR_6->vs_vc;\n\tVAR_12 = VAR_8->vc_name;\n\n\tif (VAR_4 != 1 && VAR_4 != 2 && VAR_4 != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(VAR_1))\n\t\tVAR_10 = VAR_16;\n\telse\n\t\tVAR_10 = VAR_17;\n\n\tif (VAR_3 >= VAR_10) {\n\t\t/* COMMENT_1 */\n                                                    \n                                                             \n     \n\t\tVAR_13 = (uint32_t) (VAR_3 - VAR_10);\n\t\tVAR_11 = VAR_8->vc_cfgsize ? VAR_8->vc_cfgsize : 0x100000000;\n\t\tif ((VAR_13 + ((unsigned) VAR_4)) > VAR_11)\n\t\t\tgoto bad;\n\t\tif (VAR_8->vc_cfgwrite != NULL)\n\t\t\tVAR_14 = (*VAR_8->vc_cfgwrite)(DEV_SOFTC(VAR_6), ((int) VAR_13), VAR_4,\n\t\t\t\t((uint32_t) VAR_5));\n\t\telse\n\t\t\tVAR_14 = 0;\n\t\tif (!VAR_14)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tVAR_9 = vi_find_cr((int) VAR_3);\n\tif (VAR_9 == NULL || VAR_9->cr_size != VAR_4 || VAR_9->cr_ro) {\n\t\tif (VAR_9 != NULL) {\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_9->cr_size != VAR_4)\n\t\t\t\tfprintf(VAR_18,\n\t\t\t\t    \"%s: write to %s: bad size %d\\r\\n\",\n\t\t\t\t    VAR_12, VAR_9->cr_name, VAR_4);\n\t\t\tif (VAR_9->cr_ro)\n\t\t\t\tfprintf(VAR_18,\n\t\t\t\t    \"%s: write to read-only reg %s\\r\\n\",\n\t\t\t\t    VAR_12, VAR_9->cr_name);\n\t\t} else {\n\t\t\tfprintf(VAR_18,\n\t\t\t    \"%s: write to bad offset/size %jd/%d\\r\\n\",\n\t\t\t    VAR_12, (uintmax_t)VAR_3, VAR_4);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (VAR_3) {\n\tcase VAR_19:\n\t\tVAR_6->vs_negotiated_caps = (uint32_t) (VAR_5 & VAR_8->vc_hv_caps);\n\t\tif (VAR_8->vc_apply_features)\n\t\t\t(*VAR_8->vc_apply_features)(DEV_SOFTC(VAR_6),\n\t\t\t    VAR_6->vs_negotiated_caps);\n\t\tbreak;\n\tcase VAR_20:\n\t\tif (VAR_6->vs_curq >= VAR_8->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tvi_vq_init(VAR_6, ((uint32_t) VAR_5));\n\t\tbreak;\n\tcase VAR_21:\n\t\t/* COMMENT_6 */\n                                                \n                                                 \n                                          \n     \n\t\tVAR_6->vs_curq = (int) VAR_5;\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (VAR_5 >= ((uint64_t) VAR_8->vc_nvq)) {\n\t\t\tfprintf(VAR_18, \"%s: queue %d notify out of range\\r\\n\",\n\t\t\t\tVAR_12, (int)VAR_5);\n\t\t\tgoto done;\n\t\t}\n\t\tVAR_7 = &VAR_6->vs_queues[VAR_5];\n\t\tif (VAR_7->vq_notify)\n\t\t\t(*VAR_7->vq_notify)(DEV_SOFTC(VAR_6), VAR_7);\n\t\telse if (VAR_8->vc_qnotify)\n\t\t\t(*VAR_8->vc_qnotify)(DEV_SOFTC(VAR_6), VAR_7);\n\t\telse\n\t\t\tfprintf(VAR_18,\n\t\t\t    \"%s: qnotify queue %d: missing vq/vc notify\\r\\n\",\n\t\t\t\tVAR_12, (int)VAR_5);\n\t\tbreak;\n\tcase VAR_23:\n\t\tVAR_6->vs_status = (uint8_t) VAR_5;\n\t\tif (VAR_5 == 0)\n\t\t\t(*VAR_8->vc_reset)(DEV_SOFTC(VAR_6));\n\t\tbreak;\n\tcase VAR_24:\n\t\tVAR_6->vs_msix_cfg_idx = (uint16_t) VAR_5;\n\t\tbreak;\n\tcase VAR_25:\n\t\tif (VAR_6->vs_curq >= VAR_8->vc_nvq)\n\t\t\tgoto bad_qindex;\n\t\tVAR_7 = &VAR_6->vs_queues[VAR_6->vs_curq];\n\t\tVAR_7->vq_msix_idx = (uint16_t) VAR_5;\n\t\tbreak;\n\t}\n\tgoto done;\n\nbad_qindex:\n\tfprintf(VAR_18,\n\t    \"%s: write config reg %s: curq %d >= max %d\\r\\n\",\n\t    VAR_12, VAR_9->cr_name, VAR_6->vs_curq, VAR_8->vc_nvq);\ndone:\n\tif (VAR_6->vs_mtx)\n\t\tpthread_mutex_unlock(VAR_6->vs_mtx);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,8 +45,11 @@\n \t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n \t\tif ((newoff + ((unsigned) size)) > max)\n \t\t\tgoto bad;\n-\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n-\t\t\t((uint32_t) value));\n+\t\tif (vc->vc_cfgwrite != NULL)\n+\t\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n+\t\t\t\t((uint32_t) value));\n+\t\telse\n+\t\t\terror = 0;\n \t\tif (!error)\n \t\t\tgoto done;\n \t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,",
      "\t\t\t((uint32_t) value));"
    ],
    "added_lines": [
      "\t\tif (vc->vc_cfgwrite != NULL)",
      "\t\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,",
      "\t\t\t\t((uint32_t) value));",
      "\t\telse",
      "\t\t\terror = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/moby/hyperkit/pull/313",
  "description": {
    "pr_info": {
      "title": "Various fixes",
      "number": 313
    },
    "comment": [
      "This series add some fixes for various cases that have been reported that allow the guest to trigger a crash of the virtual machine.\r\n\r\nThe first two are NULL pointer dereference and are already handled in bhyve.\r\nhttps://cgit.freebsd.org/src/tree/usr.sbin/bhyve/virtio.c#n606\r\nhttps://cgit.freebsd.org/src/tree/usr.sbin/bhyve/virtio.c#n725\r\n\r\nThe other two are unhandled returned errors in vq_getchain. For now, trace and return as in pci_vt9p_notify.\r\n\r\nLet me know what you think."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}