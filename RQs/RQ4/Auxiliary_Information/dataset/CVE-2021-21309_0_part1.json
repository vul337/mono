{
  "cve_id": "CVE-2021-21309",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix integer overflow (CVE-2021-21309). (#8522)\n\nOn 32-bit systems, setting the proto-max-bulk-len config parameter to a high value may result with integer overflow and a subsequent heap overflow when parsing an input bulk (CVE-2021-21309).\n\nThis fix has two parts:\n\nSet a reasonable limit to the config parameter.\nAdd additional checks to prevent the problem in other potential but unknown code paths.\n\n(cherry picked from commit d32f2e9999ce003bad0bd2c3bca29f64dcce4433)",
  "commit_hash": "c992857618db99776917f10bf4f2345a5fdc78b0",
  "git_url": "https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0",
  "file_path": "src/sds.c",
  "func_name": "sdsMakeRoomFor",
  "func_before": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}",
  "abstract_func_before": "sds sdsMakeRoomFor(sds VAR_0, size_t VAR_1) {\n    void *VAR_2, *VAR_3;\n    size_t VAR_4 = sdsavail(VAR_0);\n    size_t VAR_5, VAR_6;\n    char VAR_7, VAR_8 = VAR_0[-1] & VAR_9;\n    int VAR_10;\n\n    /* COMMENT_0 */\n    if (VAR_4 >= VAR_1) return VAR_0;\n\n    VAR_5 = sdslen(VAR_0);\n    VAR_2 = (char*)VAR_0-sdsHdrSize(VAR_8);\n    VAR_6 = (VAR_5+VAR_1);\n    if (VAR_6 < VAR_11)\n        VAR_6 *= 2;\n    else\n        VAR_6 += VAR_11;\n\n    VAR_7 = sdsReqType(VAR_6);\n\n    /* COMMENT_1 */\n                                                                           \n                                       \n    if (VAR_7 == VAR_12) VAR_7 = VAR_13;\n\n    VAR_10 = sdsHdrSize(VAR_7);\n    if (VAR_8==VAR_7) {\n        VAR_3 = s_realloc(VAR_2, VAR_10+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        VAR_0 = (char*)VAR_3+VAR_10;\n    } else {\n        /* COMMENT_4 */\n                                   \n        VAR_3 = s_malloc(VAR_10+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        memcpy((char*)VAR_3+VAR_10, VAR_0, VAR_5+1);\n        s_free(VAR_2);\n        VAR_0 = (char*)VAR_3+VAR_10;\n        VAR_0[-1] = VAR_7;\n        sdssetlen(VAR_0, VAR_5);\n    }\n    sdssetalloc(VAR_0, VAR_6);\n    return VAR_0;\n}",
  "func_graph_path_before": "redis/c992857618db99776917f10bf4f2345a5fdc78b0/sds.c/vul/before/1.json",
  "func": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}",
  "abstract_func": "sds sdsMakeRoomFor(sds VAR_0, size_t VAR_1) {\n    void *VAR_2, *VAR_3;\n    size_t VAR_4 = sdsavail(VAR_0);\n    size_t VAR_5, VAR_6;\n    char VAR_7, VAR_8 = VAR_0[-1] & VAR_9;\n    int VAR_10;\n\n    /* COMMENT_0 */\n    if (VAR_4 >= VAR_1) return VAR_0;\n\n    VAR_5 = sdslen(VAR_0);\n    VAR_2 = (char*)VAR_0-sdsHdrSize(VAR_8);\n    VAR_6 = (VAR_5+VAR_1);\n    assert(VAR_6 > VAR_5);   /* COMMENT_1 */\n    if (VAR_6 < VAR_11)\n        VAR_6 *= 2;\n    else\n        VAR_6 += VAR_11;\n\n    VAR_7 = sdsReqType(VAR_6);\n\n    /* COMMENT_2 */\n                                                                           \n                                       \n    if (VAR_7 == VAR_12) VAR_7 = VAR_13;\n\n    VAR_10 = sdsHdrSize(VAR_7);\n    assert(VAR_10 + VAR_6 + 1 > VAR_5);  /* COMMENT_1 */\n    if (VAR_8==VAR_7) {\n        VAR_3 = s_realloc(VAR_2, VAR_10+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        VAR_0 = (char*)VAR_3+VAR_10;\n    } else {\n        /* COMMENT_5 */\n                                   \n        VAR_3 = s_malloc(VAR_10+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        memcpy((char*)VAR_3+VAR_10, VAR_0, VAR_5+1);\n        s_free(VAR_2);\n        VAR_0 = (char*)VAR_3+VAR_10;\n        VAR_0[-1] = VAR_7;\n        sdssetlen(VAR_0, VAR_5);\n    }\n    sdssetalloc(VAR_0, VAR_6);\n    return VAR_0;\n}",
  "func_graph_path": "redis/c992857618db99776917f10bf4f2345a5fdc78b0/sds.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n     len = sdslen(s);\n     sh = (char*)s-sdsHdrSize(oldtype);\n     newlen = (len+addlen);\n+    assert(newlen > len);   /* Catch size_t overflow */\n     if (newlen < SDS_MAX_PREALLOC)\n         newlen *= 2;\n     else\n@@ -24,6 +25,7 @@\n     if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n \n     hdrlen = sdsHdrSize(type);\n+    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n     if (oldtype==type) {\n         newsh = s_realloc(sh, hdrlen+newlen+1);\n         if (newsh == NULL) return NULL;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    assert(newlen > len);   /* Catch size_t overflow */",
      "    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/8527",
  "description": {
    "pr_info": {
      "title": "Release 6.0.11",
      "number": 8527
    },
    "comment": [
      "Upgrade urgency: SECURITY if you use 32bit build of redis (see bellow), LOW\r\notherwise.\r\n\r\nInteger overflow on 32-bit systems (CVE-2021-21309):\r\nRedis 4.0 or newer uses a configurable limit for the maximum supported bulk\r\ninput size. By default, it is 512MB which is a safe value for all platforms.\r\nIf the limit is significantly increased, receiving a large request from a client\r\nmay trigger several integer overflow scenarios, which would result with buffer\r\noverflow and heap corruption.\r\n\r\nBug fixes:\r\n* Avoid 32-bit overflows when proto-max-bulk-len is set high (#8522)\r\n* Fix handling of threaded IO and CLIENT PAUSE (failover), could lead to data loss or a crash (#8520)\r\n* Fix the selection of a random element from large hash tables (#8133)\r\n* Fix broken protocol in client tracking tracking-redir-broken message (#8456)\r\n* XINFO able to access expired keys on a replica (#8436)\r\n* Fix broken protocol in redis-benchmark when used with -a or --dbnum (#8486)\r\n* Avoid assertions (on older kernels) when testing arm64 CoW bug (#8405)\r\n* CONFIG REWRITE should honor umask settings (#8371)\r\n* Fix firstkey,lastkey,step in COMMAND command for some commands (#8367)\r\n\r\nModules:\r\n* RM_ZsetRem: Delete key if empty, the bug could leave empty zset keys (#8453)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}