{
  "cve_id": "CVE-2020-12762",
  "cwe_ids": [
    "CWE-190",
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "json-c",
  "commit_msg": "Fix integer overflows.\n\nThe data structures linkhash and printbuf are limited to 2 GB in size\ndue to a signed integer being used to track their current size.\n\nIf too much data is added, then size variable can overflow, which is\nan undefined behaviour in C programming language.\n\nAssuming that a signed int overflow just leads to a negative value,\nlike it happens on many sytems (Linux i686/amd64 with gcc), then\nprintbuf is vulnerable to an out of boundary write on 64 bit systems.",
  "commit_hash": "d07b91014986900a3a75f306d302e13e005e9d67",
  "git_url": "https://github.com/json-c/json-c/commit/d07b91014986900a3a75f306d302e13e005e9d67",
  "file_path": "linkhash.c",
  "func_name": "lh_table_insert_w_hash",
  "func_before": "int lh_table_insert_w_hash(struct lh_table *t, const void *k, const void *v, const unsigned long h,\n                           const unsigned opts)\n{\n\tunsigned long n;\n\n\tif (t->count >= t->size * LH_LOAD_FACTOR)\n\t\tif (lh_table_resize(t, t->size * 2) != 0)\n\t\t\treturn -1;\n\n\tn = h % t->size;\n\n\twhile (1)\n\t{\n\t\tif (t->table[n].k == LH_EMPTY || t->table[n].k == LH_FREED)\n\t\t\tbreak;\n\t\tif ((int)++n == t->size)\n\t\t\tn = 0;\n\t}\n\n\tt->table[n].k = k;\n\tt->table[n].k_is_constant = (opts & JSON_C_OBJECT_KEY_IS_CONSTANT);\n\tt->table[n].v = v;\n\tt->count++;\n\n\tif (t->head == NULL)\n\t{\n\t\tt->head = t->tail = &t->table[n];\n\t\tt->table[n].next = t->table[n].prev = NULL;\n\t}\n\telse\n\t{\n\t\tt->tail->next = &t->table[n];\n\t\tt->table[n].prev = t->tail;\n\t\tt->table[n].next = NULL;\n\t\tt->tail = &t->table[n];\n\t}\n\n\treturn 0;\n}",
  "abstract_func_before": "int lh_table_insert_w_hash(struct lh_table *VAR_0, const void *VAR_1, const void *VAR_2, const unsigned long VAR_3,\n                           const unsigned VAR_4)\n{\n\tunsigned long VAR_5;\n\n\tif (VAR_0->count >= VAR_0->size * VAR_6)\n\t\tif (lh_table_resize(VAR_0, VAR_0->size * 2) != 0)\n\t\t\treturn -1;\n\n\tVAR_5 = VAR_3 % VAR_0->size;\n\n\twhile (1)\n\t{\n\t\tif (VAR_0->table[VAR_5].k == VAR_7 || VAR_0->table[VAR_5].k == VAR_8)\n\t\t\tbreak;\n\t\tif ((int)++VAR_5 == VAR_0->size)\n\t\t\tVAR_5 = 0;\n\t}\n\n\tVAR_0->table[VAR_5].k = VAR_1;\n\tVAR_0->table[VAR_5].k_is_constant = (VAR_4 & VAR_9);\n\tVAR_0->table[VAR_5].v = VAR_2;\n\tVAR_0->count++;\n\n\tif (VAR_0->head == NULL)\n\t{\n\t\tVAR_0->head = VAR_0->tail = &VAR_0->table[VAR_5];\n\t\tVAR_0->table[VAR_5].next = VAR_0->table[VAR_5].prev = NULL;\n\t}\n\telse\n\t{\n\t\tVAR_0->tail->next = &VAR_0->table[VAR_5];\n\t\tVAR_0->table[VAR_5].prev = VAR_0->tail;\n\t\tVAR_0->table[VAR_5].next = NULL;\n\t\tVAR_0->tail = &VAR_0->table[VAR_5];\n\t}\n\n\treturn 0;\n}",
  "func_graph_path_before": "json-c/d07b91014986900a3a75f306d302e13e005e9d67/linkhash.c/vul/before/0.json",
  "func": "int lh_table_insert_w_hash(struct lh_table *t, const void *k, const void *v, const unsigned long h,\n                           const unsigned opts)\n{\n\tunsigned long n;\n\n\tif (t->count >= t->size * LH_LOAD_FACTOR) {\n\t\t/* Avoid signed integer overflow with large tables. */\n\t\tint new_size = INT_MAX / 2 < t->size ? t->size * 2 : INT_MAX;\n\t\tif (t->size == INT_MAX || lh_table_resize(t, new_size) != 0)\n\t\t\treturn -1;\n\t}\n\n\tn = h % t->size;\n\n\twhile (1)\n\t{\n\t\tif (t->table[n].k == LH_EMPTY || t->table[n].k == LH_FREED)\n\t\t\tbreak;\n\t\tif ((int)++n == t->size)\n\t\t\tn = 0;\n\t}\n\n\tt->table[n].k = k;\n\tt->table[n].k_is_constant = (opts & JSON_C_OBJECT_KEY_IS_CONSTANT);\n\tt->table[n].v = v;\n\tt->count++;\n\n\tif (t->head == NULL)\n\t{\n\t\tt->head = t->tail = &t->table[n];\n\t\tt->table[n].next = t->table[n].prev = NULL;\n\t}\n\telse\n\t{\n\t\tt->tail->next = &t->table[n];\n\t\tt->table[n].prev = t->tail;\n\t\tt->table[n].next = NULL;\n\t\tt->tail = &t->table[n];\n\t}\n\n\treturn 0;\n}",
  "abstract_func": "int lh_table_insert_w_hash(struct lh_table *VAR_0, const void *VAR_1, const void *VAR_2, const unsigned long VAR_3,\n                           const unsigned VAR_4)\n{\n\tunsigned long VAR_5;\n\n\tif (VAR_0->count >= VAR_0->size * VAR_6) {\n\t\t/* COMMENT_0 */\n\t\tint VAR_7 = VAR_8 / 2 < VAR_0->size ? VAR_0->size * 2 : VAR_8;\n\t\tif (VAR_0->size == VAR_8 || lh_table_resize(VAR_0, VAR_7) != 0)\n\t\t\treturn -1;\n\t}\n\n\tVAR_5 = VAR_3 % VAR_0->size;\n\n\twhile (1)\n\t{\n\t\tif (VAR_0->table[VAR_5].k == VAR_9 || VAR_0->table[VAR_5].k == VAR_10)\n\t\t\tbreak;\n\t\tif ((int)++VAR_5 == VAR_0->size)\n\t\t\tVAR_5 = 0;\n\t}\n\n\tVAR_0->table[VAR_5].k = VAR_1;\n\tVAR_0->table[VAR_5].k_is_constant = (VAR_4 & VAR_11);\n\tVAR_0->table[VAR_5].v = VAR_2;\n\tVAR_0->count++;\n\n\tif (VAR_0->head == NULL)\n\t{\n\t\tVAR_0->head = VAR_0->tail = &VAR_0->table[VAR_5];\n\t\tVAR_0->table[VAR_5].next = VAR_0->table[VAR_5].prev = NULL;\n\t}\n\telse\n\t{\n\t\tVAR_0->tail->next = &VAR_0->table[VAR_5];\n\t\tVAR_0->table[VAR_5].prev = VAR_0->tail;\n\t\tVAR_0->table[VAR_5].next = NULL;\n\t\tVAR_0->tail = &VAR_0->table[VAR_5];\n\t}\n\n\treturn 0;\n}",
  "func_graph_path": "json-c/d07b91014986900a3a75f306d302e13e005e9d67/linkhash.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,12 @@\n {\n \tunsigned long n;\n \n-\tif (t->count >= t->size * LH_LOAD_FACTOR)\n-\t\tif (lh_table_resize(t, t->size * 2) != 0)\n+\tif (t->count >= t->size * LH_LOAD_FACTOR) {\n+\t\t/* Avoid signed integer overflow with large tables. */\n+\t\tint new_size = INT_MAX / 2 < t->size ? t->size * 2 : INT_MAX;\n+\t\tif (t->size == INT_MAX || lh_table_resize(t, new_size) != 0)\n \t\t\treturn -1;\n+\t}\n \n \tn = h % t->size;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (t->count >= t->size * LH_LOAD_FACTOR)",
      "\t\tif (lh_table_resize(t, t->size * 2) != 0)"
    ],
    "added_lines": [
      "\tif (t->count >= t->size * LH_LOAD_FACTOR) {",
      "\t\t/* Avoid signed integer overflow with large tables. */",
      "\t\tint new_size = INT_MAX / 2 < t->size ? t->size * 2 : INT_MAX;",
      "\t\tif (t->size == INT_MAX || lh_table_resize(t, new_size) != 0)",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/json-c/json-c/pull/592",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/json-c/json-c/pull/592: 403 Client Error: Forbidden for url: https://api.github.com/repos/json-c/json-c/pulls/592",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses an integer overflow issue in the linkhash and printbuf structures, which can lead to out-of-bounds writes, a clear security vulnerability. The code changes directly fix this by preventing integer overflow, making it a security fix with high confidence.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}