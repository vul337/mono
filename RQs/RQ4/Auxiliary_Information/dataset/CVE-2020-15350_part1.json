{
  "cve_id": "CVE-2020-15350",
  "cwe_ids": [
    "CWE-119",
    "CWE-131"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "base64: Fixed decode buffer size estimation\n\nFixed required result buffer size underestimation in base64_estimate_decode_size() function.",
  "commit_hash": "f8ac003bbfe11956578dd2189827686c27374d06",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/f8ac003bbfe11956578dd2189827686c27374d06",
  "file_path": "sys/include/base64.h",
  "func_name": "base64_estimate_decode_size",
  "func_before": "static inline size_t base64_estimate_decode_size(size_t base64_in_size)\n{\n    return ((base64_in_size / 4) * 3);\n}",
  "abstract_func_before": "static inline size_t base64_estimate_decode_size(size_t VAR_0)\n{\n    return ((VAR_0 / 4) * 3);\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/f8ac003bbfe11956578dd2189827686c27374d06/base64.h/vul/before/0.json",
  "func": "static inline size_t base64_estimate_decode_size(size_t base64_in_size)\n{\n    return (((base64_in_size + 3) / 4) * 3);\n}",
  "abstract_func": "static inline size_t base64_estimate_decode_size(size_t VAR_0)\n{\n    return (((VAR_0 + 3) / 4) * 3);\n}",
  "func_graph_path": "RIOT-OS/RIOT/f8ac003bbfe11956578dd2189827686c27374d06/base64.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n static inline size_t base64_estimate_decode_size(size_t base64_in_size)\n {\n-    return ((base64_in_size / 4) * 3);\n+    return (((base64_in_size + 3) / 4) * 3);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    return ((base64_in_size / 4) * 3);"
    ],
    "added_lines": [
      "    return (((base64_in_size + 3) / 4) * 3);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/14400",
  "description": {
    "pr_info": {
      "title": "sys/base64: Fix, unit test cleanup, and benchmark",
      "number": 14400
    },
    "comment": [
      "### Contribution description\r\n\r\n- Cherry-picked [@mjurczak fix](https://github.com/mjurczak/RIOT/commit/d27b048c28ceb1e3d0e0b06faa2f77965b7784d9) for the decode buffer size estimation (which could result in a buffer overflow of up to one byte note being catched)\r\n- Made using the API less pain by accepting `void` pointers for buffers (non-breaking change, as `unsigned char *` is implicitly casted to `void *`)\r\n- Cleaned up the unit test to fix basic code quality issued\r\n- Added a unit test to check the `base64_estimate_{de,en}code_size()`\r\n- Added a benchmark for base64 (this will come in useful to review a follow up PR)\r\n\r\n### Testing procedure\r\n\r\nThe unit tests should no detect an issue in `base64_estimate_{de,en}code_size()`\r\n\r\n### Issues/PRs references\r\n\r\nNone",
      "Somehow the build was previously not queued, toggling `CI: ready for build` seems to have solved the issue.",
      "Looks like the unit test will now fail\r\n\r\n> `base64_tests.test_base64_13_size_estimation (tests/unittests/tests-base64/tests-base64.c 495) exp 3 was 0`",
      "No need to run tests on hardware. The compilation tests include a run of the unit tests on the `native` board.",
      "@mjurczak: I cherry-picked your suggested fix and included it in the PR. This way, the credit for and authorship of the commits stays with you.",
      "With @mjurczak fix included, the unit tests are now passing. I updated the PR title and the description accordingly.",
      "Fixed some style issues, while we're at it.\r\n\r\n(I will let Murdock run again when I have squashed.)",
      "> Should the benchmark have an automatic test?\r\n\r\nI'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n\r\nWhat we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.",
      "> I'm not sure what an automatic test should do. A single benchmark run will provide a raw number, that lacks context. (Or two raw numbers, one for encode and one for decode.) IMO, at least a second benchmark result from the same hardware is needed to have any meaningful information.\r\n> \r\n> What we could do (if we want to run automatic tests), is to feed a database with the raw results to see how performance changes over time. But maybe such considerations should be done independently form this PR and applied later on to all benchmarks.\r\n\r\nI was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\". My comment comes mainly from the impression that we now ask for a `01-run.py` for new applications.",
      "> I was just thinking on the most basic check, what we do for other benches `tests/bench_xtimer/tests/01-run.py`, just a simple test that says \"the application works\".\r\n\r\nAh, OK! I added the test.",
      "Please squash @maribu and re-trigger ci.",
      "I fixed a typo in the test input detected by the static tests (and the corresponding base64) and added the missing empty line flake8 complained about. I squashed right away.",
      "Murdock likes it too.",
      "@mjurczak: Thank you very much for reporting and fixing the issue!\r\n\r\nThanks everyone for the reviews.",
      "@maribu  I'm stunned with the fast reaction. Great job everyone!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}