{
  "cve_id": "CVE-2022-24704",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "accel-ppp",
  "commit_msg": "fix buffer overflow when receive radius packet\nThis patch fixes buffer overflow if radius packet contains invalid atribute length\nand attrubute type from the following list: ipv4addr, ipv6addr, ipv6prefix or ifid\n\nReported-by: Chloe Ong\nReported-by: Eugene Lim <spaceraccoon@users.noreply.github.com>\nReported-by: Kar Wei Loh\n\nSigned-off-by: Sergey V. Lobanov <sergey@lobanov.in>",
  "commit_hash": "d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615",
  "git_url": "https://github.com/accel-ppp/accel-ppp/commit/d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615",
  "file_path": "accel-pppd/radius/packet.c",
  "func_name": "rad_packet_recv",
  "func_before": "int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t\tif (len < 0) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (2 + len > n) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", id, len);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}",
  "abstract_func_before": "int rad_packet_recv(int VAR_0, struct rad_packet_t **VAR_1, struct sockaddr_in *VAR_2)\n{\n\tstruct rad_packet_t *VAR_3;\n\tstruct rad_attr_t *VAR_4;\n\tstruct rad_dict_attr_t *VAR_5;\n\tstruct rad_dict_vendor_t *VAR_6;\n\tuint8_t *VAR_7;\n\tint VAR_8, VAR_9, VAR_10, VAR_11;\n\tsocklen_t VAR_12 = sizeof(*VAR_2);\n\n\t*VAR_1 = NULL;\n\n\tVAR_3 = rad_packet_alloc(0);\n\tif (!VAR_3)\n\t\treturn 0;\n\n\t/* COMMENT_0 */\n\tVAR_7 = mempool_alloc(VAR_13);\n\tif (VAR_7 == VAR_14) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tVAR_3->buf = VAR_7;\n\tclock_gettime(VAR_15, &VAR_3->tv);\n\n\twhile (1) {\n\t\tif (VAR_2)\n\t\t\tVAR_8 = recvfrom(VAR_0, VAR_3->buf, VAR_16, 0, VAR_2, &VAR_12);\n\t\telse\n\t\t\tVAR_8 = read(VAR_0, VAR_3->buf, VAR_16);\n\t\tif (VAR_8 < 0) {\n\t\t\trad_packet_free(VAR_3);\n\t\t\tif (VAR_17 == VAR_18)\n\t\t\t\treturn 1;\n\n\t\t\tif (VAR_17 != VAR_19)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(VAR_17));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (VAR_8 < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", VAR_8);\n\t\tgoto out_err;\n\t}\n\n\tVAR_3->code = *VAR_7; VAR_7++;\n\tVAR_3->id = *VAR_7; VAR_7++;\n\tVAR_3->len = ntohs(*(uint16_t*)VAR_7); VAR_7 += 2;\n\n\tif (VAR_3->len > VAR_8) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", VAR_3->len, VAR_8);\n\t\tgoto out_err;\n\t}\n\n\tVAR_7 += 16;\n\tVAR_8 -= 20;\n\n\twhile (VAR_8>0) {\n\t\tVAR_9 = *VAR_7; VAR_7++;\n\t\tVAR_10 = *VAR_7 - 2; VAR_7++;\n\t\tif (VAR_10 < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + VAR_10 > VAR_8) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", VAR_9, VAR_10);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (VAR_9 == 26) {\n\t\t\tVAR_11 = ntohl(*(uint32_t *)VAR_7);\n\t\t\tVAR_6 = rad_dict_find_vendor_id(VAR_11);\n\t\t\tif (VAR_6) {\n\t\t\t\tVAR_7 += 4;\n\n\t\t\t\tif (VAR_6->tag == 2)\n\t\t\t\t\tVAR_9 = (uint16_t)ntohs(*(uint16_t *)VAR_7);\n\t\t\t\telse\n\t\t\t\t\tVAR_9 = *VAR_7;\n\n\t\t\t\tVAR_7 += VAR_6->tag;\n\n\t\t\t\tif (VAR_6->len == 2)\n\t\t\t\t\tVAR_10 = (uint16_t)ntohs(*(uint16_t *)VAR_7);\n\t\t\t\telse\n\t\t\t\t\tVAR_10 = *VAR_7;\n\n\t\t\t\tVAR_7 += VAR_6->len;\n\n\t\t\t\tVAR_10 -= VAR_6->tag + VAR_6->len;\n\n\t\t\t\tVAR_8 -= 4 + VAR_6->tag + VAR_6->len;\n\t\t\t\tif (VAR_10 < 0) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (2 + VAR_10 > VAR_8) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", VAR_9, VAR_10);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", VAR_9);\n\t\t} else\n\t\t\tVAR_6 = NULL;\n\t\tVAR_5 = rad_dict_find_attr_id(VAR_6, VAR_9);\n\t\tif (VAR_5) {\n\t\t\tVAR_4 = mempool_alloc(VAR_20);\n\t\t\tif (!VAR_4) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(VAR_4, 0, sizeof(*VAR_4));\n\t\t\tVAR_4->vendor = VAR_6;\n\t\t\tVAR_4->attr = VAR_5;\n\t\t\tVAR_4->len = VAR_10;\n\t\t\tVAR_4->raw = VAR_7;\n\n\t\t\tif (!VAR_5->array) {\n\t\t\t\tswitch (VAR_5->type) {\n\t\t\t\t\tcase VAR_21:\n\t\t\t\t\t\tVAR_4->alloc = 1;\n\t\t\t\t\t\tVAR_4->val.string = _malloc(VAR_10 + 1);\n\t\t\t\t\t\tmemcpy(VAR_4->val.string, VAR_7, VAR_10);\n\t\t\t\t\t\tVAR_4->val.string[VAR_10] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_22:\n\t\t\t\t\tcase VAR_23:\n\t\t\t\t\tcase VAR_24:\n\t\t\t\t\t\tVAR_4->val.octets = VAR_7;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_25:\n\t\t\t\t\t\tif (VAR_10 != VAR_5->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", VAR_5->name, VAR_10, VAR_5->size);\n\t\t\t\t\tcase VAR_26:\n\t\t\t\t\t\tif (VAR_10 == 4)\n\t\t\t\t\t\t\tVAR_4->val.integer = ntohl(*(uint32_t*)VAR_7);\n\t\t\t\t\t\telse if (VAR_10 == 2)\n\t\t\t\t\t\t\tVAR_4->val.integer = ntohs(*(uint16_t*)VAR_7);\n\t\t\t\t\t\telse if (VAR_10 == 1)\n\t\t\t\t\t\t\tVAR_4->val.integer = *VAR_7;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_27:\n\t\t\t\t\tcase VAR_28:\n\t\t\t\t\tcase VAR_29:\n\t\t\t\t\t\tmemcpy(&VAR_4->val.integer, VAR_7, VAR_10);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_30:\n\t\t\t\t\t\tVAR_4->val.ipv6prefix.len = VAR_7[1];\n\t\t\t\t\t\tmemset(&VAR_4->val.ipv6prefix.prefix, 0, sizeof(VAR_4->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&VAR_4->val.ipv6prefix.prefix, VAR_7 + 2, VAR_10 - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&VAR_4->entry, &VAR_3->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", VAR_6 ? VAR_6->id : 0, VAR_9);\n\t\tVAR_7 += VAR_10;\n\t\tVAR_8 -= 2 + VAR_10;\n\t}\n\n\t*VAR_1 = VAR_3;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(VAR_3);\n\treturn 1;\n}",
  "func_graph_path_before": "accel-ppp/d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615/packet.c/vul/before/0.json",
  "func": "int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t\tif (len < 0) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (2 + len > n) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", id, len);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tif (len == da->size)\n\t\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tif (len < 2 || len > 18) { /* RFC 8044 §3.10 ipv6prefix */\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be from 2 to 18)\\n\", da->name, len);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ptr[1] > 128) {\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid prefix length %u (must be from 0 to 128)\\n\", da->name, ptr[1]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}",
  "abstract_func": "int rad_packet_recv(int VAR_0, struct rad_packet_t **VAR_1, struct sockaddr_in *VAR_2)\n{\n\tstruct rad_packet_t *VAR_3;\n\tstruct rad_attr_t *VAR_4;\n\tstruct rad_dict_attr_t *VAR_5;\n\tstruct rad_dict_vendor_t *VAR_6;\n\tuint8_t *VAR_7;\n\tint VAR_8, VAR_9, VAR_10, VAR_11;\n\tsocklen_t VAR_12 = sizeof(*VAR_2);\n\n\t*VAR_1 = NULL;\n\n\tVAR_3 = rad_packet_alloc(0);\n\tif (!VAR_3)\n\t\treturn 0;\n\n\t/* COMMENT_0 */\n\tVAR_7 = mempool_alloc(VAR_13);\n\tif (VAR_7 == VAR_14) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tVAR_3->buf = VAR_7;\n\tclock_gettime(VAR_15, &VAR_3->tv);\n\n\twhile (1) {\n\t\tif (VAR_2)\n\t\t\tVAR_8 = recvfrom(VAR_0, VAR_3->buf, VAR_16, 0, VAR_2, &VAR_12);\n\t\telse\n\t\t\tVAR_8 = read(VAR_0, VAR_3->buf, VAR_16);\n\t\tif (VAR_8 < 0) {\n\t\t\trad_packet_free(VAR_3);\n\t\t\tif (VAR_17 == VAR_18)\n\t\t\t\treturn 1;\n\n\t\t\tif (VAR_17 != VAR_19)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(VAR_17));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (VAR_8 < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", VAR_8);\n\t\tgoto out_err;\n\t}\n\n\tVAR_3->code = *VAR_7; VAR_7++;\n\tVAR_3->id = *VAR_7; VAR_7++;\n\tVAR_3->len = ntohs(*(uint16_t*)VAR_7); VAR_7 += 2;\n\n\tif (VAR_3->len > VAR_8) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", VAR_3->len, VAR_8);\n\t\tgoto out_err;\n\t}\n\n\tVAR_7 += 16;\n\tVAR_8 -= 20;\n\n\twhile (VAR_8>0) {\n\t\tVAR_9 = *VAR_7; VAR_7++;\n\t\tVAR_10 = *VAR_7 - 2; VAR_7++;\n\t\tif (VAR_10 < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + VAR_10 > VAR_8) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", VAR_9, VAR_10);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (VAR_9 == 26) {\n\t\t\tVAR_11 = ntohl(*(uint32_t *)VAR_7);\n\t\t\tVAR_6 = rad_dict_find_vendor_id(VAR_11);\n\t\t\tif (VAR_6) {\n\t\t\t\tVAR_7 += 4;\n\n\t\t\t\tif (VAR_6->tag == 2)\n\t\t\t\t\tVAR_9 = (uint16_t)ntohs(*(uint16_t *)VAR_7);\n\t\t\t\telse\n\t\t\t\t\tVAR_9 = *VAR_7;\n\n\t\t\t\tVAR_7 += VAR_6->tag;\n\n\t\t\t\tif (VAR_6->len == 2)\n\t\t\t\t\tVAR_10 = (uint16_t)ntohs(*(uint16_t *)VAR_7);\n\t\t\t\telse\n\t\t\t\t\tVAR_10 = *VAR_7;\n\n\t\t\t\tVAR_7 += VAR_6->len;\n\n\t\t\t\tVAR_10 -= VAR_6->tag + VAR_6->len;\n\n\t\t\t\tVAR_8 -= 4 + VAR_6->tag + VAR_6->len;\n\t\t\t\tif (VAR_10 < 0) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (2 + VAR_10 > VAR_8) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", VAR_9, VAR_10);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", VAR_9);\n\t\t} else\n\t\t\tVAR_6 = NULL;\n\t\tVAR_5 = rad_dict_find_attr_id(VAR_6, VAR_9);\n\t\tif (VAR_5) {\n\t\t\tVAR_4 = mempool_alloc(VAR_20);\n\t\t\tif (!VAR_4) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(VAR_4, 0, sizeof(*VAR_4));\n\t\t\tVAR_4->vendor = VAR_6;\n\t\t\tVAR_4->attr = VAR_5;\n\t\t\tVAR_4->len = VAR_10;\n\t\t\tVAR_4->raw = VAR_7;\n\n\t\t\tif (!VAR_5->array) {\n\t\t\t\tswitch (VAR_5->type) {\n\t\t\t\t\tcase VAR_21:\n\t\t\t\t\t\tVAR_4->alloc = 1;\n\t\t\t\t\t\tVAR_4->val.string = _malloc(VAR_10 + 1);\n\t\t\t\t\t\tmemcpy(VAR_4->val.string, VAR_7, VAR_10);\n\t\t\t\t\t\tVAR_4->val.string[VAR_10] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_22:\n\t\t\t\t\tcase VAR_23:\n\t\t\t\t\tcase VAR_24:\n\t\t\t\t\t\tVAR_4->val.octets = VAR_7;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_25:\n\t\t\t\t\t\tif (VAR_10 != VAR_5->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", VAR_5->name, VAR_10, VAR_5->size);\n\t\t\t\t\tcase VAR_26:\n\t\t\t\t\t\tif (VAR_10 == 4)\n\t\t\t\t\t\t\tVAR_4->val.integer = ntohl(*(uint32_t*)VAR_7);\n\t\t\t\t\t\telse if (VAR_10 == 2)\n\t\t\t\t\t\t\tVAR_4->val.integer = ntohs(*(uint16_t*)VAR_7);\n\t\t\t\t\t\telse if (VAR_10 == 1)\n\t\t\t\t\t\t\tVAR_4->val.integer = *VAR_7;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_27:\n\t\t\t\t\tcase VAR_28:\n\t\t\t\t\tcase VAR_29:\n\t\t\t\t\t\tif (VAR_10 == VAR_5->size)\n\t\t\t\t\t\t\tmemcpy(&VAR_4->val.integer, VAR_7, VAR_10);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", VAR_5->name, VAR_10, VAR_5->size);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VAR_30:\n\t\t\t\t\t\tif (VAR_10 < 2 || VAR_10 > 18) { /* COMMENT_1 */\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be from 2 to 18)\\n\", VAR_5->name, VAR_10);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (VAR_7[1] > 128) {\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid prefix length %u (must be from 0 to 128)\\n\", VAR_5->name, VAR_7[1]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_4->val.ipv6prefix.len = VAR_7[1];\n\t\t\t\t\t\tmemset(&VAR_4->val.ipv6prefix.prefix, 0, sizeof(VAR_4->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&VAR_4->val.ipv6prefix.prefix, VAR_7 + 2, VAR_10 - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&VAR_4->entry, &VAR_3->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", VAR_6 ? VAR_6->id : 0, VAR_9);\n\t\tVAR_7 += VAR_10;\n\t\tVAR_8 -= 2 + VAR_10;\n\t}\n\n\t*VAR_1 = VAR_3;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(VAR_3);\n\treturn 1;\n}",
  "func_graph_path": "accel-ppp/d4cb89721cc8e5b3dd3fbefaf173eb77ecb85615/packet.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -145,9 +145,20 @@\n \t\t\t\t\tcase ATTR_TYPE_IPADDR:\n \t\t\t\t\tcase ATTR_TYPE_IFID:\n \t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n-\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n+\t\t\t\t\t\tif (len == da->size)\n+\t\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n+\t\t\t\t\t\tif (len < 2 || len > 18) { /* RFC 8044 §3.10 ipv6prefix */\n+\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be from 2 to 18)\\n\", da->name, len);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (ptr[1] > 128) {\n+\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid prefix length %u (must be from 0 to 128)\\n\", da->name, ptr[1]);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n \t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n \t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);"
    ],
    "added_lines": [
      "\t\t\t\t\t\tif (len == da->size)",
      "\t\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);",
      "\t\t\t\t\t\telse",
      "\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);",
      "\t\t\t\t\t\tif (len < 2 || len > 18) { /* RFC 8044 §3.10 ipv6prefix */",
      "\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be from 2 to 18)\\n\", da->name, len);",
      "\t\t\t\t\t\t\tbreak;",
      "\t\t\t\t\t\t}",
      "\t\t\t\t\t\tif (ptr[1] > 128) {",
      "\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid prefix length %u (must be from 0 to 128)\\n\", da->name, ptr[1]);",
      "\t\t\t\t\t\t\tbreak;",
      "\t\t\t\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/accel-ppp/accel-ppp/pull/35",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/accel-ppp/accel-ppp/pull/35: 403 Client Error: Forbidden for url: https://api.github.com/repos/accel-ppp/accel-ppp/pulls/35",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit addresses a buffer overflow issue by validating attribute lengths in radius packets, preventing potential security exploits. The code changes include necessary checks and logging, confirming it's a security fix."
}