{
  "cve_id": "CVE-2023-26769",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "liblouis",
  "commit_msg": "fix format:\n1. define MAX_TABLEFILE_SIZE\n2. parse the magic number",
  "commit_hash": "6f39e88745e8ec602ccc46042c305a6188f28b0a",
  "git_url": "https://github.com/liblouis/liblouis/commit/6f39e88745e8ec602ccc46042c305a6188f28b0a",
  "file_path": "liblouis/compileTranslationTable.c",
  "func_name": "resolveSubtable",
  "func_before": "static char *\nresolveSubtable(const char *table, const char *base, const char *searchPath) {\n\tchar *tableFile;\n\tstatic struct stat info;\n\n\tif (table == NULL || table[0] == '\\0' ||\n\t\t\tstrlen(table) >= MAXSTRING * sizeof(char) * 2)\n\t\treturn NULL;\n\ttableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2);\n\n\t//\n\t// First try to resolve against base\n\t//\n\tif (base) {\n\t\tint k;\n\t\tif (strlen(base) >= MAXSTRING * sizeof(char) * 2) goto failure;\n\t\tstrcpy(tableFile, base);\n\t\tk = (int)strlen(tableFile);\n\t\twhile (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\\\') k--;\n\t\ttableFile[++k] = '\\0';\n\t\tif (strlen(tableFile) + strlen(table) >= MAXSTRING * sizeof(char) * 2)\n\t\t\tgoto failure;\n\t\tstrcat(tableFile, table);\n\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\treturn tableFile;\n\t\t}\n\t}\n\n\t//\n\t// It could be an absolute path, or a path relative to the current working\n\t// directory\n\t//\n\tstrcpy(tableFile, table);\n\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\treturn tableFile;\n\t}\n\n\t//\n\t// Then search `LOUIS_TABLEPATH`, `dataPath` and `programPath`\n\t//\n\tif (searchPath[0] != '\\0') {\n\t\tchar *dir;\n\t\tint last;\n\t\tchar *cp;\n\t\tchar *searchPath_copy = strdup(searchPath);\n\t\tfor (dir = searchPath_copy;; dir = cp + 1) {\n\t\t\tfor (cp = dir; *cp != '\\0' && *cp != ','; cp++)\n\t\t\t\t;\n\t\t\tlast = (*cp == '\\0');\n\t\t\t*cp = '\\0';\n\t\t\tif (dir == cp) dir = \".\";\n\t\t\tif (strlen(dir) + strlen(table) + 1 >= MAXSTRING * sizeof(char) * 2) {\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(tableFile, \"%s%c%s\", dir, DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t\tif (strlen(dir) + strlen(table) + 16 >= MAXSTRING * sizeof(char) * 2) {\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(tableFile, \"%s%c%s%c%s%c%s\", dir, DIR_SEP, \"liblouis\", DIR_SEP,\n\t\t\t\t\t\"tables\", DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t}\n\t\tfree(searchPath_copy);\n\t}\nfailure:\n\tfree(tableFile);\n\treturn NULL;\n}",
  "abstract_func_before": "static char *\nresolveSubtable(const char *VAR_0, const char *VAR_1, const char *VAR_2) {\n\tchar *VAR_3;\n\tstatic struct stat VAR_4;\n\n\tif (VAR_0 == NULL || VAR_0[0] == '\\0' ||\n\t\t\tstrlen(VAR_0) >= VAR_5 * sizeof(char) * 2)\n\t\treturn NULL;\n\tVAR_3 = (char *)malloc(VAR_5 * sizeof(char) * 2);\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\t/* COMMENT_0 */\n\tif (VAR_1) {\n\t\tint VAR_6;\n\t\tif (strlen(VAR_1) >= VAR_5 * sizeof(char) * 2) goto failure;\n\t\tstrcpy(VAR_3, VAR_1);\n\t\tVAR_6 = (int)strlen(VAR_3);\n\t\twhile (VAR_6 >= 0 && VAR_3[VAR_6] != '/' && VAR_3[VAR_6] != '\\\\') VAR_6--;\n\t\tVAR_3[++VAR_6] = '\\0';\n\t\tif (strlen(VAR_3) + strlen(VAR_0) >= VAR_5 * sizeof(char) * 2)\n\t\t\tgoto failure;\n\t\tstrcat(VAR_3, VAR_0);\n\t\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\t\treturn VAR_3;\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_0 */\n\tstrcpy(VAR_3, VAR_0);\n\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\treturn VAR_3;\n\t}\n\n\t/* COMMENT_0 */\n\t/* COMMENT_4 */\n\t/* COMMENT_0 */\n\tif (VAR_2[0] != '\\0') {\n\t\tchar *VAR_9;\n\t\tint VAR_10;\n\t\tchar *VAR_11;\n\t\tchar *VAR_12 = strdup(VAR_2);\n\t\tfor (VAR_9 = VAR_12;; VAR_9 = VAR_11 + 1) {\n\t\t\tfor (VAR_11 = VAR_9; *VAR_11 != '\\0' && *VAR_11 != ','; VAR_11++)\n\t\t\t\t;\n\t\t\tVAR_10 = (*VAR_11 == '\\0');\n\t\t\t*VAR_11 = '\\0';\n\t\t\tif (VAR_9 == VAR_11) VAR_9 = \".\";\n\t\t\tif (strlen(VAR_9) + strlen(VAR_0) + 1 >= VAR_5 * sizeof(char) * 2) {\n\t\t\t\tfree(VAR_12);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(VAR_3, \"%s%c%s\", VAR_9, VAR_13, VAR_0);\n\t\t\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\t\t\tfree(VAR_12);\n\t\t\t\treturn VAR_3;\n\t\t\t}\n\t\t\tif (VAR_10) break;\n\t\t\tif (strlen(VAR_9) + strlen(VAR_0) + 16 >= VAR_5 * sizeof(char) * 2) {\n\t\t\t\tfree(VAR_12);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(VAR_3, \"%s%c%s%c%s%c%s\", VAR_9, VAR_13, \"liblouis\", VAR_13,\n\t\t\t\t\t\"tables\", VAR_13, VAR_0);\n\t\t\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\t\t\tfree(VAR_12);\n\t\t\t\treturn VAR_3;\n\t\t\t}\n\t\t\tif (VAR_10) break;\n\t\t}\n\t\tfree(VAR_12);\n\t}\nfailure:\n\tfree(VAR_3);\n\treturn NULL;\n}",
  "func_graph_path_before": "liblouis/6f39e88745e8ec602ccc46042c305a6188f28b0a/compileTranslationTable.c/vul/before/0.json",
  "func": "static char *\nresolveSubtable(const char *table, const char *base, const char *searchPath) {\n\tchar *tableFile;\n\tstatic struct stat info;\n\n#define MAX_TABLEFILE_SIZE MAXSTRING * sizeof(char) * 2\n\tif (table == NULL || table[0] == '\\0') return NULL;\n\ttableFile = (char *)malloc(MAX_TABLEFILE_SIZE);\n\n\t//\n\t// First try to resolve against base\n\t//\n\tif (base) {\n\t\tint k;\n\t\tif (strlen(base) >= MAX_TABLEFILE_SIZE) goto failure;\n\t\tstrcpy(tableFile, base);\n\t\tk = (int)strlen(tableFile);\n\t\twhile (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\\\') k--;\n\t\ttableFile[++k] = '\\0';\n\t\tif (strlen(tableFile) + strlen(table) >= MAX_TABLEFILE_SIZE) goto failure;\n\t\tstrcat(tableFile, table);\n\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\treturn tableFile;\n\t\t}\n\t}\n\n\t//\n\t// It could be an absolute path, or a path relative to the current working\n\t// directory\n\t//\n\tif (strlen(table) >= MAX_TABLEFILE_SIZE) goto failure;\n\tstrcpy(tableFile, table);\n\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\treturn tableFile;\n\t}\n\n\t//\n\t// Then search `LOUIS_TABLEPATH`, `dataPath` and `programPath`\n\t//\n\tif (searchPath[0] != '\\0') {\n\t\tchar *dir;\n\t\tint last;\n\t\tchar *cp;\n\t\tchar *searchPath_copy = strdup(searchPath);\n\t\tfor (dir = searchPath_copy;; dir = cp + 1) {\n\t\t\tfor (cp = dir; *cp != '\\0' && *cp != ','; cp++)\n\t\t\t\t;\n\t\t\tlast = (*cp == '\\0');\n\t\t\t*cp = '\\0';\n\t\t\tif (dir == cp) dir = \".\";\n\t\t\tif (strlen(dir) + strlen(table) + 1 >= MAX_TABLEFILE_SIZE) {\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(tableFile, \"%s%c%s\", dir, DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t\tif (strlen(dir) + strlen(\"liblouis\") + strlen(\"tables\") + strlen(table) + 3 >=\n\t\t\t\t\tMAX_TABLEFILE_SIZE) {\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(tableFile, \"%s%c%s%c%s%c%s\", dir, DIR_SEP, \"liblouis\", DIR_SEP,\n\t\t\t\t\t\"tables\", DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t}\n\t\tfree(searchPath_copy);\n\t}\nfailure:\n\tfree(tableFile);\n\treturn NULL;\n}",
  "abstract_func": "static char *\nresolveSubtable(const char *VAR_0, const char *VAR_1, const char *VAR_2) {\n\tchar *VAR_3;\n\tstatic struct stat VAR_4;\n\n#define VAR_5 MAXSTRING * sizeof(char) * 2\n\tif (VAR_0 == NULL || VAR_0[0] == '\\0') return NULL;\n\tVAR_3 = (char *)malloc(VAR_5);\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\t/* COMMENT_0 */\n\tif (VAR_1) {\n\t\tint VAR_6;\n\t\tif (strlen(VAR_1) >= VAR_5) goto failure;\n\t\tstrcpy(VAR_3, VAR_1);\n\t\tVAR_6 = (int)strlen(VAR_3);\n\t\twhile (VAR_6 >= 0 && VAR_3[VAR_6] != '/' && VAR_3[VAR_6] != '\\\\') VAR_6--;\n\t\tVAR_3[++VAR_6] = '\\0';\n\t\tif (strlen(VAR_3) + strlen(VAR_0) >= VAR_5) goto failure;\n\t\tstrcat(VAR_3, VAR_0);\n\t\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\t\treturn VAR_3;\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_0 */\n\tif (strlen(VAR_0) >= VAR_5) goto failure;\n\tstrcpy(VAR_3, VAR_0);\n\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\treturn VAR_3;\n\t}\n\n\t/* COMMENT_0 */\n\t/* COMMENT_4 */\n\t/* COMMENT_0 */\n\tif (VAR_2[0] != '\\0') {\n\t\tchar *VAR_9;\n\t\tint VAR_10;\n\t\tchar *VAR_11;\n\t\tchar *VAR_12 = strdup(VAR_2);\n\t\tfor (VAR_9 = VAR_12;; VAR_9 = VAR_11 + 1) {\n\t\t\tfor (VAR_11 = VAR_9; *VAR_11 != '\\0' && *VAR_11 != ','; VAR_11++)\n\t\t\t\t;\n\t\t\tVAR_10 = (*VAR_11 == '\\0');\n\t\t\t*VAR_11 = '\\0';\n\t\t\tif (VAR_9 == VAR_11) VAR_9 = \".\";\n\t\t\tif (strlen(VAR_9) + strlen(VAR_0) + 1 >= VAR_5) {\n\t\t\t\tfree(VAR_12);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(VAR_3, \"%s%c%s\", VAR_9, VAR_13, VAR_0);\n\t\t\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\t\t\tfree(VAR_12);\n\t\t\t\treturn VAR_3;\n\t\t\t}\n\t\t\tif (VAR_10) break;\n\t\t\tif (strlen(VAR_9) + strlen(\"liblouis\") + strlen(\"tables\") + strlen(VAR_0) + 3 >=\n\t\t\t\t\tVAR_5) {\n\t\t\t\tfree(VAR_12);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\tsprintf(VAR_3, \"%s%c%s%c%s%c%s\", VAR_9, VAR_13, \"liblouis\", VAR_13,\n\t\t\t\t\t\"tables\", VAR_13, VAR_0);\n\t\t\tif (stat(VAR_3, &VAR_4) == 0 && !(VAR_4.st_mode & VAR_7)) {\n\t\t\t\t_lou_logMessage(VAR_8, \"found table %s\", VAR_3);\n\t\t\t\tfree(VAR_12);\n\t\t\t\treturn VAR_3;\n\t\t\t}\n\t\t\tif (VAR_10) break;\n\t\t}\n\t\tfree(VAR_12);\n\t}\nfailure:\n\tfree(VAR_3);\n\treturn NULL;\n}",
  "func_graph_path": "liblouis/6f39e88745e8ec602ccc46042c305a6188f28b0a/compileTranslationTable.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,23 +3,21 @@\n \tchar *tableFile;\n \tstatic struct stat info;\n \n-\tif (table == NULL || table[0] == '\\0' ||\n-\t\t\tstrlen(table) >= MAXSTRING * sizeof(char) * 2)\n-\t\treturn NULL;\n-\ttableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2);\n+#define MAX_TABLEFILE_SIZE MAXSTRING * sizeof(char) * 2\n+\tif (table == NULL || table[0] == '\\0') return NULL;\n+\ttableFile = (char *)malloc(MAX_TABLEFILE_SIZE);\n \n \t//\n \t// First try to resolve against base\n \t//\n \tif (base) {\n \t\tint k;\n-\t\tif (strlen(base) >= MAXSTRING * sizeof(char) * 2) goto failure;\n+\t\tif (strlen(base) >= MAX_TABLEFILE_SIZE) goto failure;\n \t\tstrcpy(tableFile, base);\n \t\tk = (int)strlen(tableFile);\n \t\twhile (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\\\') k--;\n \t\ttableFile[++k] = '\\0';\n-\t\tif (strlen(tableFile) + strlen(table) >= MAXSTRING * sizeof(char) * 2)\n-\t\t\tgoto failure;\n+\t\tif (strlen(tableFile) + strlen(table) >= MAX_TABLEFILE_SIZE) goto failure;\n \t\tstrcat(tableFile, table);\n \t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n \t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n@@ -31,6 +29,7 @@\n \t// It could be an absolute path, or a path relative to the current working\n \t// directory\n \t//\n+\tif (strlen(table) >= MAX_TABLEFILE_SIZE) goto failure;\n \tstrcpy(tableFile, table);\n \tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n \t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n@@ -51,7 +50,7 @@\n \t\t\tlast = (*cp == '\\0');\n \t\t\t*cp = '\\0';\n \t\t\tif (dir == cp) dir = \".\";\n-\t\t\tif (strlen(dir) + strlen(table) + 1 >= MAXSTRING * sizeof(char) * 2) {\n+\t\t\tif (strlen(dir) + strlen(table) + 1 >= MAX_TABLEFILE_SIZE) {\n \t\t\t\tfree(searchPath_copy);\n \t\t\t\tgoto failure;\n \t\t\t}\n@@ -62,7 +61,8 @@\n \t\t\t\treturn tableFile;\n \t\t\t}\n \t\t\tif (last) break;\n-\t\t\tif (strlen(dir) + strlen(table) + 16 >= MAXSTRING * sizeof(char) * 2) {\n+\t\t\tif (strlen(dir) + strlen(\"liblouis\") + strlen(\"tables\") + strlen(table) + 3 >=\n+\t\t\t\t\tMAX_TABLEFILE_SIZE) {\n \t\t\t\tfree(searchPath_copy);\n \t\t\t\tgoto failure;\n \t\t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (table == NULL || table[0] == '\\0' ||",
      "\t\t\tstrlen(table) >= MAXSTRING * sizeof(char) * 2)",
      "\t\treturn NULL;",
      "\ttableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2);",
      "\t\tif (strlen(base) >= MAXSTRING * sizeof(char) * 2) goto failure;",
      "\t\tif (strlen(tableFile) + strlen(table) >= MAXSTRING * sizeof(char) * 2)",
      "\t\t\tgoto failure;",
      "\t\t\tif (strlen(dir) + strlen(table) + 1 >= MAXSTRING * sizeof(char) * 2) {",
      "\t\t\tif (strlen(dir) + strlen(table) + 16 >= MAXSTRING * sizeof(char) * 2) {"
    ],
    "added_lines": [
      "#define MAX_TABLEFILE_SIZE MAXSTRING * sizeof(char) * 2",
      "\tif (table == NULL || table[0] == '\\0') return NULL;",
      "\ttableFile = (char *)malloc(MAX_TABLEFILE_SIZE);",
      "\t\tif (strlen(base) >= MAX_TABLEFILE_SIZE) goto failure;",
      "\t\tif (strlen(tableFile) + strlen(table) >= MAX_TABLEFILE_SIZE) goto failure;",
      "\tif (strlen(table) >= MAX_TABLEFILE_SIZE) goto failure;",
      "\t\t\tif (strlen(dir) + strlen(table) + 1 >= MAX_TABLEFILE_SIZE) {",
      "\t\t\tif (strlen(dir) + strlen(\"liblouis\") + strlen(\"tables\") + strlen(table) + 3 >=",
      "\t\t\t\t\tMAX_TABLEFILE_SIZE) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/liblouis/liblouis/pull/1300",
  "description": {
    "pr_info": {
      "title": "Check the path length before coping into tableFile",
      "number": 1300
    },
    "comment": [
      "Fix #1291.\r\n\r\nAdd check for path length before every string-related functions."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}