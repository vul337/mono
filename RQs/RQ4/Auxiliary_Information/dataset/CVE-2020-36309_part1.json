{
  "cve_id": "CVE-2020-36309",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "openresty/lua-nginx-module",
  "commit_msg": "bugfix: ensured arguments of APIs mutating uri or request/response headers do not contain unsafe characters.\n\nSigned-off-by: Thibault Charbonnier <thibaultcha@me.com>",
  "commit_hash": "041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "git_url": "https://github.com/openresty/lua-nginx-module/commit/041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "file_path": "src/ngx_http_lua_uri.c",
  "func_name": "ngx_http_lua_ngx_req_set_uri",
  "func_before": "static int\nngx_http_lua_ngx_req_set_uri(lua_State *L)\n{\n    ngx_http_request_t          *r;\n    size_t                       len;\n    u_char                      *p;\n    int                          n;\n    int                          jump = 0;\n    ngx_http_lua_ctx_t          *ctx;\n\n    n = lua_gettop(L);\n\n    if (n != 1 && n != 2) {\n        return luaL_error(L, \"expecting 1 or 2 arguments but seen %d\", n);\n    }\n\n    r = ngx_http_lua_get_req(L);\n    if (r == NULL) {\n        return luaL_error(L, \"no request found\");\n    }\n\n    ngx_http_lua_check_fake_request(L, r);\n\n    p = (u_char *) luaL_checklstring(L, 1, &len);\n\n    if (len == 0) {\n        return luaL_error(L, \"attempt to use zero-length uri\");\n    }\n\n    if (n == 2) {\n\n        luaL_checktype(L, 2, LUA_TBOOLEAN);\n        jump = lua_toboolean(L, 2);\n\n        if (jump) {\n\n            ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n            if (ctx == NULL) {\n                return luaL_error(L, \"no ctx found\");\n            }\n\n            dd(\"rewrite: %d, access: %d, content: %d\",\n               (int) ctx->entered_rewrite_phase,\n               (int) ctx->entered_access_phase,\n               (int) ctx->entered_content_phase);\n\n            ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE);\n\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"lua set uri jump to \\\"%*s\\\"\", len, p);\n\n            ngx_http_lua_check_if_abortable(L, ctx);\n        }\n    }\n\n    r->uri.data = ngx_palloc(r->pool, len);\n    if (r->uri.data == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    ngx_memcpy(r->uri.data, p, len);\n\n    r->uri.len = len;\n\n    r->internal = 1;\n    r->valid_unparsed_uri = 0;\n\n    ngx_http_set_exten(r);\n\n    if (jump) {\n        r->uri_changed = 1;\n\n        return lua_yield(L, 0);\n    }\n\n    r->valid_location = 0;\n    r->uri_changed = 0;\n\n    return 0;\n}",
  "abstract_func_before": "static int\nngx_http_lua_ngx_req_set_uri(lua_State *VAR_0)\n{\n    ngx_http_request_t          *VAR_1;\n    size_t                       VAR_2;\n    u_char                      *VAR_3;\n    int                          VAR_4;\n    int                          VAR_5 = 0;\n    ngx_http_lua_ctx_t          *VAR_6;\n\n    VAR_4 = lua_gettop(VAR_0);\n\n    if (VAR_4 != 1 && VAR_4 != 2) {\n        return luaL_error(VAR_0, \"expecting 1 or 2 arguments but seen %d\", VAR_4);\n    }\n\n    VAR_1 = ngx_http_lua_get_req(VAR_0);\n    if (VAR_1 == NULL) {\n        return luaL_error(VAR_0, \"no request found\");\n    }\n\n    ngx_http_lua_check_fake_request(VAR_0, VAR_1);\n\n    VAR_3 = (u_char *) luaL_checklstring(VAR_0, 1, &VAR_2);\n\n    if (VAR_2 == 0) {\n        return luaL_error(VAR_0, \"attempt to use zero-length uri\");\n    }\n\n    if (VAR_4 == 2) {\n\n        luaL_checktype(VAR_0, 2, VAR_7);\n        VAR_5 = lua_toboolean(VAR_0, 2);\n\n        if (VAR_5) {\n\n            VAR_6 = ngx_http_get_module_ctx(VAR_1, VAR_8);\n            if (VAR_6 == NULL) {\n                return luaL_error(VAR_0, \"no ctx found\");\n            }\n\n            dd(\"rewrite: %d, access: %d, content: %d\",\n               (int) VAR_6->entered_rewrite_phase,\n               (int) VAR_6->entered_access_phase,\n               (int) VAR_6->entered_content_phase);\n\n            ngx_http_lua_check_context(VAR_0, VAR_6, VAR_9);\n\n            ngx_log_debug2(VAR_10, VAR_1->connection->log, 0,\n                           \"lua set uri jump to \\\"%*s\\\"\", VAR_2, VAR_3);\n\n            ngx_http_lua_check_if_abortable(VAR_0, VAR_6);\n        }\n    }\n\n    VAR_1->uri.data = ngx_palloc(VAR_1->pool, VAR_2);\n    if (VAR_1->uri.data == NULL) {\n        return luaL_error(VAR_0, \"no memory\");\n    }\n\n    ngx_memcpy(VAR_1->uri.data, VAR_3, VAR_2);\n\n    VAR_1->uri.len = VAR_2;\n\n    VAR_1->internal = 1;\n    VAR_1->valid_unparsed_uri = 0;\n\n    ngx_http_set_exten(VAR_1);\n\n    if (VAR_5) {\n        VAR_1->uri_changed = 1;\n\n        return lua_yield(VAR_0, 0);\n    }\n\n    VAR_1->valid_location = 0;\n    VAR_1->uri_changed = 0;\n\n    return 0;\n}",
  "func_graph_path_before": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_uri.c/vul/before/0.json",
  "func": "static int\nngx_http_lua_ngx_req_set_uri(lua_State *L)\n{\n    ngx_http_request_t          *r;\n    size_t                       len;\n    u_char                      *p;\n    int                          n;\n    int                          jump = 0;\n    ngx_http_lua_ctx_t          *ctx;\n\n    n = lua_gettop(L);\n\n    if (n != 1 && n != 2) {\n        return luaL_error(L, \"expecting 1 or 2 arguments but seen %d\", n);\n    }\n\n    r = ngx_http_lua_get_req(L);\n    if (r == NULL) {\n        return luaL_error(L, \"no request found\");\n    }\n\n    ngx_http_lua_check_fake_request(L, r);\n\n    p = (u_char *) luaL_checklstring(L, 1, &len);\n\n    if (len == 0) {\n        return luaL_error(L, \"attempt to use zero-length uri\");\n    }\n\n    if (ngx_http_lua_check_uri_safe(r, p, len) != NGX_OK) {\n        return luaL_error(L, \"attempt to use unsafe uri\");\n    }\n\n    if (n == 2) {\n\n        luaL_checktype(L, 2, LUA_TBOOLEAN);\n        jump = lua_toboolean(L, 2);\n\n        if (jump) {\n\n            ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n            if (ctx == NULL) {\n                return luaL_error(L, \"no ctx found\");\n            }\n\n            dd(\"rewrite: %d, access: %d, content: %d\",\n               (int) ctx->entered_rewrite_phase,\n               (int) ctx->entered_access_phase,\n               (int) ctx->entered_content_phase);\n\n            ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE);\n\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"lua set uri jump to \\\"%*s\\\"\", len, p);\n\n            ngx_http_lua_check_if_abortable(L, ctx);\n        }\n    }\n\n    r->uri.data = ngx_palloc(r->pool, len);\n    if (r->uri.data == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    ngx_memcpy(r->uri.data, p, len);\n\n    r->uri.len = len;\n\n    r->internal = 1;\n    r->valid_unparsed_uri = 0;\n\n    ngx_http_set_exten(r);\n\n    if (jump) {\n        r->uri_changed = 1;\n\n        return lua_yield(L, 0);\n    }\n\n    r->valid_location = 0;\n    r->uri_changed = 0;\n\n    return 0;\n}",
  "abstract_func": "static int\nngx_http_lua_ngx_req_set_uri(lua_State *VAR_0)\n{\n    ngx_http_request_t          *VAR_1;\n    size_t                       VAR_2;\n    u_char                      *VAR_3;\n    int                          VAR_4;\n    int                          VAR_5 = 0;\n    ngx_http_lua_ctx_t          *VAR_6;\n\n    VAR_4 = lua_gettop(VAR_0);\n\n    if (VAR_4 != 1 && VAR_4 != 2) {\n        return luaL_error(VAR_0, \"expecting 1 or 2 arguments but seen %d\", VAR_4);\n    }\n\n    VAR_1 = ngx_http_lua_get_req(VAR_0);\n    if (VAR_1 == NULL) {\n        return luaL_error(VAR_0, \"no request found\");\n    }\n\n    ngx_http_lua_check_fake_request(VAR_0, VAR_1);\n\n    VAR_3 = (u_char *) luaL_checklstring(VAR_0, 1, &VAR_2);\n\n    if (VAR_2 == 0) {\n        return luaL_error(VAR_0, \"attempt to use zero-length uri\");\n    }\n\n    if (ngx_http_lua_check_uri_safe(VAR_1, VAR_3, VAR_2) != VAR_7) {\n        return luaL_error(VAR_0, \"attempt to use unsafe uri\");\n    }\n\n    if (VAR_4 == 2) {\n\n        luaL_checktype(VAR_0, 2, VAR_8);\n        VAR_5 = lua_toboolean(VAR_0, 2);\n\n        if (VAR_5) {\n\n            VAR_6 = ngx_http_get_module_ctx(VAR_1, VAR_9);\n            if (VAR_6 == NULL) {\n                return luaL_error(VAR_0, \"no ctx found\");\n            }\n\n            dd(\"rewrite: %d, access: %d, content: %d\",\n               (int) VAR_6->entered_rewrite_phase,\n               (int) VAR_6->entered_access_phase,\n               (int) VAR_6->entered_content_phase);\n\n            ngx_http_lua_check_context(VAR_0, VAR_6, VAR_10);\n\n            ngx_log_debug2(VAR_11, VAR_1->connection->log, 0,\n                           \"lua set uri jump to \\\"%*s\\\"\", VAR_2, VAR_3);\n\n            ngx_http_lua_check_if_abortable(VAR_0, VAR_6);\n        }\n    }\n\n    VAR_1->uri.data = ngx_palloc(VAR_1->pool, VAR_2);\n    if (VAR_1->uri.data == NULL) {\n        return luaL_error(VAR_0, \"no memory\");\n    }\n\n    ngx_memcpy(VAR_1->uri.data, VAR_3, VAR_2);\n\n    VAR_1->uri.len = VAR_2;\n\n    VAR_1->internal = 1;\n    VAR_1->valid_unparsed_uri = 0;\n\n    ngx_http_set_exten(VAR_1);\n\n    if (VAR_5) {\n        VAR_1->uri_changed = 1;\n\n        return lua_yield(VAR_0, 0);\n    }\n\n    VAR_1->valid_location = 0;\n    VAR_1->uri_changed = 0;\n\n    return 0;\n}",
  "func_graph_path": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_uri.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,10 @@\n \n     if (len == 0) {\n         return luaL_error(L, \"attempt to use zero-length uri\");\n+    }\n+\n+    if (ngx_http_lua_check_uri_safe(r, p, len) != NGX_OK) {\n+        return luaL_error(L, \"attempt to use unsafe uri\");\n     }\n \n     if (n == 2) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    }",
      "",
      "    if (ngx_http_lua_check_uri_safe(r, p, len) != NGX_OK) {",
      "        return luaL_error(L, \"attempt to use unsafe uri\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openresty/lua-nginx-module/pull/1654",
  "description": {
    "pr_info": {
      "title": "bugfix: ensured arguments of APIs mutating uri or request/response headers do not contain unsafe characters.",
      "number": 1654
    },
    "comment": [
      "I hereby granted the copyright of the changes in this pull request\nto the authors of this lua-nginx-module project.",
      "(Rebased on top of master due to a newly failing tests caused by changes in openresty.org's accepted ciphers)",
      "Just pushed an additional commit with more fixes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\nThe commit addresses unsafe URI characters, preventing potential security risks through a check, though lacks explicit CVE reference."
}