{
  "cve_id": "CVE-2016-3120",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Fix S4U2Self KDC crash when anon is restricted\n\nIn validate_as_request(), when enforcing restrict_anonymous_to_tgt,\nuse client.princ instead of request->client; the latter is NULL when\nvalidating S4U2Self requests.\n\nCVE-2016-3120:\n\nIn MIT krb5 1.9 and later, an authenticated attacker can cause krb5kdc\nto dereference a null pointer if the restrict_anonymous_to_tgt option\nis set to true, by making an S4U2Self request.\n\n  CVSSv2 Vector: AV:N/AC:H/Au:S/C:N/I:N/A:C/E:H/RL:OF/RC:C\n\nticket: 8458 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next",
  "commit_hash": "93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7",
  "git_url": "https://github.com/krb5/krb5/commit/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7",
  "file_path": "src/kdc/kdc_util.c",
  "func_name": "validate_as_request",
  "func_before": "int\nvalidate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
  "abstract_func_before": "int\nvalidate_as_request(kdc_realm_t *VAR_0,\n                    register krb5_kdc_req *VAR_1, krb5_db_entry VAR_2,\n                    krb5_db_entry VAR_3, krb5_timestamp VAR_4,\n                    const char **VAR_5, krb5_pa_data ***VAR_6)\n{\n    int VAR_7;\n    krb5_error_code VAR_8;\n\n    /* COMMENT_0 */\n                                                                          \n       \n    if (VAR_1->kdc_options & VAR_9) {\n        *VAR_5 = \"INVALID AS OPTIONS\";\n        return VAR_10;\n    }\n\n    /* COMMENT_3 */\n    if (VAR_2.expiration && VAR_2.expiration < VAR_4) {\n        *VAR_5 = \"CLIENT EXPIRED\";\n        if (VAR_11)\n            return(VAR_12);\n        else\n            return(VAR_13);\n    }\n\n    /* COMMENT_4 */\n                                      \n    if (VAR_2.pw_expiration && VAR_2.pw_expiration < VAR_4 &&\n        !isflagset(VAR_3.attributes, VAR_14)) {\n        *VAR_5 = \"CLIENT KEY EXPIRED\";\n        if (VAR_11)\n            return(VAR_12);\n        else\n            return(VAR_15);\n    }\n\n    /* COMMENT_6 */\n    if (VAR_3.expiration && VAR_3.expiration < VAR_4) {\n        *VAR_5 = \"SERVICE EXPIRED\";\n        return(VAR_16);\n    }\n\n    /* COMMENT_7 */\n                                                                    \n                        \n       \n    if (isflagset(VAR_2.attributes, VAR_17) &&\n        !isflagset(VAR_3.attributes, VAR_14)) {\n        *VAR_5 = \"REQUIRED PWCHANGE\";\n        return(VAR_15);\n    }\n\n    /* COMMENT_11 */\n    if ((isflagset(VAR_1->kdc_options, VAR_18) ||\n         isflagset(VAR_1->kdc_options, VAR_19)) &&\n        (isflagset(VAR_2.attributes, VAR_20) ||\n         isflagset(VAR_3.attributes, VAR_20))) {\n        *VAR_5 = \"POSTDATE NOT ALLOWED\";\n        return(VAR_21);\n    }\n\n    /* COMMENT_12 */\n                                                                    \n                                            \n      \n                                                             \n                                                               \n                       \n                                                               \n                                                           \n      \n                                                                 \n                                                                \n                                                \n       \n\n    /* COMMENT_25 */\n    if (isflagset(VAR_1->kdc_options, VAR_22) &&\n        (isflagset(VAR_2.attributes, VAR_23) ||\n         isflagset(VAR_3.attributes, VAR_23))) {\n        *VAR_5 = \"PROXIABLE NOT ALLOWED\";\n        return(VAR_24);\n    }\n\n    /* COMMENT_26 */\n    if (isflagset(VAR_2.attributes, VAR_25)) {\n        *VAR_5 = \"CLIENT LOCKED OUT\";\n        return(VAR_26);\n    }\n\n    /* COMMENT_27 */\n    if (isflagset(VAR_3.attributes, VAR_25)) {\n        *VAR_5 = \"SERVICE LOCKED OUT\";\n        return(VAR_27);\n    }\n\n    /* COMMENT_28 */\n    if (isflagset(VAR_3.attributes, VAR_28)) {\n        *VAR_5 = \"SERVICE NOT ALLOWED\";\n        return(VAR_29);\n    }\n\n    if (check_anon(VAR_0, VAR_1->client, VAR_1->server) != 0) {\n        *VAR_5 = \"ANONYMOUS NOT ALLOWED\";\n        return(VAR_24);\n    }\n\n    /* COMMENT_29 */\n    VAR_8 = krb5_db_check_policy_as(VAR_30, VAR_1, &VAR_2, &VAR_3,\n                                  VAR_4, VAR_5, VAR_6);\n    if (VAR_8 && VAR_8 != VAR_31)\n        return errcode_to_protocol(VAR_8);\n\n    /* COMMENT_30 */\n    VAR_7 = against_local_policy_as(VAR_1, VAR_2, VAR_3,\n                                      VAR_4, VAR_5, VAR_6);\n    if (VAR_7)\n        return VAR_7;\n\n    return 0;\n}",
  "func_graph_path_before": "krb5/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7/kdc_util.c/vul/before/0.json",
  "func": "int\nvalidate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}",
  "abstract_func": "int\nvalidate_as_request(kdc_realm_t *VAR_0,\n                    register krb5_kdc_req *VAR_1, krb5_db_entry VAR_2,\n                    krb5_db_entry VAR_3, krb5_timestamp VAR_4,\n                    const char **VAR_5, krb5_pa_data ***VAR_6)\n{\n    int VAR_7;\n    krb5_error_code VAR_8;\n\n    /* COMMENT_0 */\n                                                                          \n       \n    if (VAR_1->kdc_options & VAR_9) {\n        *VAR_5 = \"INVALID AS OPTIONS\";\n        return VAR_10;\n    }\n\n    /* COMMENT_3 */\n    if (VAR_2.expiration && VAR_2.expiration < VAR_4) {\n        *VAR_5 = \"CLIENT EXPIRED\";\n        if (VAR_11)\n            return(VAR_12);\n        else\n            return(VAR_13);\n    }\n\n    /* COMMENT_4 */\n                                      \n    if (VAR_2.pw_expiration && VAR_2.pw_expiration < VAR_4 &&\n        !isflagset(VAR_3.attributes, VAR_14)) {\n        *VAR_5 = \"CLIENT KEY EXPIRED\";\n        if (VAR_11)\n            return(VAR_12);\n        else\n            return(VAR_15);\n    }\n\n    /* COMMENT_6 */\n    if (VAR_3.expiration && VAR_3.expiration < VAR_4) {\n        *VAR_5 = \"SERVICE EXPIRED\";\n        return(VAR_16);\n    }\n\n    /* COMMENT_7 */\n                                                                    \n                        \n       \n    if (isflagset(VAR_2.attributes, VAR_17) &&\n        !isflagset(VAR_3.attributes, VAR_14)) {\n        *VAR_5 = \"REQUIRED PWCHANGE\";\n        return(VAR_15);\n    }\n\n    /* COMMENT_11 */\n    if ((isflagset(VAR_1->kdc_options, VAR_18) ||\n         isflagset(VAR_1->kdc_options, VAR_19)) &&\n        (isflagset(VAR_2.attributes, VAR_20) ||\n         isflagset(VAR_3.attributes, VAR_20))) {\n        *VAR_5 = \"POSTDATE NOT ALLOWED\";\n        return(VAR_21);\n    }\n\n    /* COMMENT_12 */\n                                                                    \n                                            \n      \n                                                             \n                                                               \n                       \n                                                               \n                                                           \n      \n                                                                 \n                                                                \n                                                \n       \n\n    /* COMMENT_25 */\n    if (isflagset(VAR_1->kdc_options, VAR_22) &&\n        (isflagset(VAR_2.attributes, VAR_23) ||\n         isflagset(VAR_3.attributes, VAR_23))) {\n        *VAR_5 = \"PROXIABLE NOT ALLOWED\";\n        return(VAR_24);\n    }\n\n    /* COMMENT_26 */\n    if (isflagset(VAR_2.attributes, VAR_25)) {\n        *VAR_5 = \"CLIENT LOCKED OUT\";\n        return(VAR_26);\n    }\n\n    /* COMMENT_27 */\n    if (isflagset(VAR_3.attributes, VAR_25)) {\n        *VAR_5 = \"SERVICE LOCKED OUT\";\n        return(VAR_27);\n    }\n\n    /* COMMENT_28 */\n    if (isflagset(VAR_3.attributes, VAR_28)) {\n        *VAR_5 = \"SERVICE NOT ALLOWED\";\n        return(VAR_29);\n    }\n\n    if (check_anon(VAR_0, VAR_2.princ, VAR_1->server) != 0) {\n        *VAR_5 = \"ANONYMOUS NOT ALLOWED\";\n        return(VAR_24);\n    }\n\n    /* COMMENT_29 */\n    VAR_8 = krb5_db_check_policy_as(VAR_30, VAR_1, &VAR_2, &VAR_3,\n                                  VAR_4, VAR_5, VAR_6);\n    if (VAR_8 && VAR_8 != VAR_31)\n        return errcode_to_protocol(VAR_8);\n\n    /* COMMENT_30 */\n    VAR_7 = against_local_policy_as(VAR_1, VAR_2, VAR_3,\n                                      VAR_4, VAR_5, VAR_6);\n    if (VAR_7)\n        return VAR_7;\n\n    return 0;\n}",
  "func_graph_path": "krb5/93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7/kdc_util.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -101,7 +101,7 @@\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n-    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n+    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {"
    ],
    "added_lines": [
      "    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/485",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/krb5/krb5/pull/485: 403 Client Error: Forbidden for url: https://api.github.com/repos/krb5/krb5/pulls/485",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\nThe patch addresses a known security vulnerability (CVE-2016-3120) by preventing a null pointer dereference in the KDC when handling S4U2Self requests. The code change ensures the correct principal is used, resolving the crash and mitigating the security risk."
}