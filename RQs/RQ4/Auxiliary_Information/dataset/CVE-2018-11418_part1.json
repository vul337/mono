{
  "cve_id": "CVE-2018-11418",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Fix heap buffer overflow in re_parse_char_class\n\nThis patch fixes #2230 and fixes #2237.\nTest cases are added for both issues and also adds new cases which caused the same error.\n\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik frobert@inf.u-szeged.hu",
  "commit_hash": "7c3f2bc8c7ed0c28a1ea097d7177363f8998a566",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/7c3f2bc8c7ed0c28a1ea097d7177363f8998a566",
  "file_path": "jerry-core/parser/regexp/re-parser.c",
  "func_name": "re_parse_char_class",
  "func_before": "ecma_value_t\nre_parse_char_class (re_parser_ctx_t *parser_ctx_p, /**< number of classes */\n                     re_char_class_callback append_char_class, /**< callback function,\n                                                                *   which adds the char-ranges\n                                                                *   to the bytecode */\n                     void *re_ctx_p, /**< regexp compiler context */\n                     re_token_t *out_token_p) /**< [out] output token */\n{\n  re_token_type_t token_type = ((re_compiler_ctx_t *) re_ctx_p)->current_token.type;\n  out_token_p->qmax = out_token_p->qmin = 1;\n  ecma_char_t start = LIT_CHAR_UNDEF;\n  bool is_range = false;\n  parser_ctx_p->num_of_classes = 0;\n\n  const ecma_char_t prev_char = lit_utf8_peek_prev (parser_ctx_p->input_curr_p);\n  if (prev_char != LIT_CHAR_LEFT_SQUARE && prev_char != LIT_CHAR_CIRCUMFLEX)\n  {\n    lit_utf8_decr (&parser_ctx_p->input_curr_p);\n    lit_utf8_decr (&parser_ctx_p->input_curr_p);\n  }\n\n  do\n  {\n    if (parser_ctx_p->input_curr_p >= parser_ctx_p->input_end_p)\n    {\n      return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string\"));\n    }\n\n    ecma_char_t ch = lit_utf8_read_next (&parser_ctx_p->input_curr_p);\n\n    if (ch == LIT_CHAR_RIGHT_SQUARE)\n    {\n      if (start != LIT_CHAR_UNDEF)\n      {\n        append_char_class (re_ctx_p, start, start);\n      }\n      break;\n    }\n    else if (ch == LIT_CHAR_MINUS)\n    {\n      if (parser_ctx_p->input_curr_p >= parser_ctx_p->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '-'\"));\n      }\n\n      if (start != LIT_CHAR_UNDEF\n          && !is_range\n          && *parser_ctx_p->input_curr_p != LIT_CHAR_RIGHT_SQUARE)\n      {\n        is_range = true;\n        continue;\n      }\n    }\n    else if (ch == LIT_CHAR_BACKSLASH)\n    {\n      if (parser_ctx_p->input_curr_p >= parser_ctx_p->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\'\"));\n      }\n\n      ch = lit_utf8_read_next (&parser_ctx_p->input_curr_p);\n\n      if (ch == LIT_CHAR_LOWERCASE_B)\n      {\n        ch = LIT_CHAR_BS;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_F)\n      {\n        ch = LIT_CHAR_FF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_N)\n      {\n        ch = LIT_CHAR_LF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_T)\n      {\n        ch = LIT_CHAR_TAB;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_R)\n      {\n        ch = LIT_CHAR_CR;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_V)\n      {\n        ch = LIT_CHAR_VTAB;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_C)\n      {\n        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p)\n        {\n          ch = *parser_ctx_p->input_curr_p;\n\n          if ((ch >= LIT_CHAR_ASCII_UPPERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_UPPERCASE_LETTERS_END)\n              || (ch >= LIT_CHAR_ASCII_LOWERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_LOWERCASE_LETTERS_END)\n              || (ch >= LIT_CHAR_0 && ch <= LIT_CHAR_9))\n          {\n            /* See ECMA-262 v5, 15.10.2.10 (Point 3) */\n            ch = (ch % 32);\n            parser_ctx_p->input_curr_p++;\n          }\n          else\n          {\n            ch = LIT_CHAR_LOWERCASE_C;\n          }\n        }\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_X)\n      {\n        ecma_char_t code_unit;\n\n        if (!lit_read_code_unit_from_hex (parser_ctx_p->input_curr_p, 2, &code_unit))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\x'\"));\n        }\n\n        parser_ctx_p->input_curr_p += 2;\n        if (is_range == false && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n        {\n          start = code_unit;\n          continue;\n        }\n\n        ch = code_unit;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_U)\n      {\n        ecma_char_t code_unit;\n\n        if (!lit_read_code_unit_from_hex (parser_ctx_p->input_curr_p, 4, &code_unit))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\u'\"));\n        }\n\n        parser_ctx_p->input_curr_p += 4;\n        if (is_range == false && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n        {\n          start = code_unit;\n          continue;\n        }\n\n        ch = code_unit;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_D)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_ASCII_DIGITS_BEGIN, LIT_CHAR_ASCII_DIGITS_END);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_UPPERCASE_D)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_NULL, LIT_CHAR_ASCII_DIGITS_BEGIN - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_ASCII_DIGITS_END + 1, LIT_UTF16_CODE_UNIT_MAX);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_S)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_TAB, LIT_CHAR_CR);\n        append_char_class (re_ctx_p, LIT_CHAR_SP, LIT_CHAR_SP);\n        append_char_class (re_ctx_p, LIT_CHAR_NBSP, LIT_CHAR_NBSP);\n        append_char_class (re_ctx_p, 0x1680UL, 0x1680UL); /* Ogham Space Mark */\n        append_char_class (re_ctx_p, 0x180EUL, 0x180EUL); /* Mongolian Vowel Separator */\n        append_char_class (re_ctx_p, 0x2000UL, 0x200AUL); /* En Quad - Hair Space */\n        append_char_class (re_ctx_p, LIT_CHAR_LS, LIT_CHAR_PS);\n        append_char_class (re_ctx_p, 0x202FUL, 0x202FUL); /* Narrow No-Break Space */\n        append_char_class (re_ctx_p, 0x205FUL, 0x205FUL); /* Medium Mathematical Space */\n        append_char_class (re_ctx_p, 0x3000UL, 0x3000UL); /* Ideographic Space */\n        append_char_class (re_ctx_p, LIT_CHAR_BOM, LIT_CHAR_BOM);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_UPPERCASE_S)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_NULL, LIT_CHAR_TAB - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_CR + 1, LIT_CHAR_SP - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_SP + 1, LIT_CHAR_NBSP - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_NBSP + 1, 0x167FUL);\n        append_char_class (re_ctx_p, 0x1681UL, 0x180DUL);\n        append_char_class (re_ctx_p, 0x180FUL, 0x1FFFUL);\n        append_char_class (re_ctx_p, 0x200BUL, LIT_CHAR_LS - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_PS + 1, 0x202EUL);\n        append_char_class (re_ctx_p, 0x2030UL, 0x205EUL);\n        append_char_class (re_ctx_p, 0x2060UL, 0x2FFFUL);\n        append_char_class (re_ctx_p, 0x3001UL, LIT_CHAR_BOM - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_BOM + 1, LIT_UTF16_CODE_UNIT_MAX);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_W)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_0, LIT_CHAR_9);\n        append_char_class (re_ctx_p, LIT_CHAR_UPPERCASE_A, LIT_CHAR_UPPERCASE_Z);\n        append_char_class (re_ctx_p, LIT_CHAR_UNDERSCORE, LIT_CHAR_UNDERSCORE);\n        append_char_class (re_ctx_p, LIT_CHAR_LOWERCASE_A, LIT_CHAR_LOWERCASE_Z);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_UPPERCASE_W)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_NULL, LIT_CHAR_0 - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_9 + 1, LIT_CHAR_UPPERCASE_A - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_UPPERCASE_Z + 1, LIT_CHAR_UNDERSCORE - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_UNDERSCORE + 1, LIT_CHAR_LOWERCASE_A - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_LOWERCASE_Z + 1, LIT_UTF16_CODE_UNIT_MAX);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (lit_char_is_octal_digit ((ecma_char_t) ch)\n               && ch != LIT_CHAR_0)\n      {\n        lit_utf8_decr (&parser_ctx_p->input_curr_p);\n        ch = (ecma_char_t) re_parse_octal (parser_ctx_p);\n      }\n    } /* ch == LIT_CHAR_BACKSLASH */\n\n    if (start != LIT_CHAR_UNDEF)\n    {\n      if (is_range)\n      {\n        if (start > ch)\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, wrong order\"));\n        }\n        else\n        {\n          append_char_class (re_ctx_p, start, ch);\n          start = LIT_CHAR_UNDEF;\n          is_range = false;\n        }\n      }\n      else\n      {\n        append_char_class (re_ctx_p, start, start);\n        start = ch;\n      }\n    }\n    else\n    {\n      start = ch;\n    }\n  }\n  while (token_type == RE_TOK_START_CHAR_CLASS || token_type == RE_TOK_START_INV_CHAR_CLASS);\n\n  return re_parse_iterator (parser_ctx_p, out_token_p);\n}",
  "abstract_func_before": "ecma_value_t\nre_parse_char_class (re_parser_ctx_t *VAR_0, /* COMMENT_0 */\n                     re_char_class_callback VAR_1, /* COMMENT_1 */\n                                                                                              \n                                                                                      \n                     void *VAR_2, /* COMMENT_4 */\n                     re_token_t *VAR_3) /* COMMENT_5 */\n{\n  re_token_type_t VAR_4 = ((re_compiler_ctx_t *) VAR_2)->current_token.type;\n  VAR_3->qmax = VAR_3->qmin = 1;\n  ecma_char_t VAR_5 = VAR_6;\n  bool VAR_7 = false;\n  VAR_0->num_of_classes = 0;\n\n  const ecma_char_t VAR_8 = lit_utf8_peek_prev (VAR_0->input_curr_p);\n  if (VAR_8 != VAR_9 && VAR_8 != VAR_10)\n  {\n    lit_utf8_decr (&VAR_0->input_curr_p);\n    lit_utf8_decr (&VAR_0->input_curr_p);\n  }\n\n  do\n  {\n    if (VAR_0->input_curr_p >= VAR_0->input_end_p)\n    {\n      return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string\"));\n    }\n\n    ecma_char_t VAR_11 = lit_utf8_read_next (&VAR_0->input_curr_p);\n\n    if (VAR_11 == VAR_12)\n    {\n      if (VAR_5 != VAR_6)\n      {\n        VAR_1 (VAR_2, VAR_5, VAR_5);\n      }\n      break;\n    }\n    else if (VAR_11 == VAR_13)\n    {\n      if (VAR_0->input_curr_p >= VAR_0->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '-'\"));\n      }\n\n      if (VAR_5 != VAR_6\n          && !VAR_7\n          && *VAR_0->input_curr_p != VAR_12)\n      {\n        VAR_7 = true;\n        continue;\n      }\n    }\n    else if (VAR_11 == VAR_14)\n    {\n      if (VAR_0->input_curr_p >= VAR_0->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\'\"));\n      }\n\n      VAR_11 = lit_utf8_read_next (&VAR_0->input_curr_p);\n\n      if (VAR_11 == VAR_15)\n      {\n        VAR_11 = VAR_16;\n      }\n      else if (VAR_11 == VAR_17)\n      {\n        VAR_11 = VAR_18;\n      }\n      else if (VAR_11 == VAR_19)\n      {\n        VAR_11 = VAR_20;\n      }\n      else if (VAR_11 == VAR_21)\n      {\n        VAR_11 = VAR_22;\n      }\n      else if (VAR_11 == VAR_23)\n      {\n        VAR_11 = VAR_24;\n      }\n      else if (VAR_11 == VAR_25)\n      {\n        VAR_11 = VAR_26;\n      }\n      else if (VAR_11 == VAR_27)\n      {\n        if (VAR_0->input_curr_p < VAR_0->input_end_p)\n        {\n          VAR_11 = *VAR_0->input_curr_p;\n\n          if ((VAR_11 >= VAR_28 && VAR_11 <= VAR_29)\n              || (VAR_11 >= VAR_30 && VAR_11 <= VAR_31)\n              || (VAR_11 >= VAR_32 && VAR_11 <= VAR_33))\n          {\n            /* COMMENT_6 */\n            VAR_11 = (VAR_11 % 32);\n            VAR_0->input_curr_p++;\n          }\n          else\n          {\n            VAR_11 = VAR_27;\n          }\n        }\n      }\n      else if (VAR_11 == VAR_34)\n      {\n        ecma_char_t VAR_35;\n\n        if (!lit_read_code_unit_from_hex (VAR_0->input_curr_p, 2, &VAR_35))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\x'\"));\n        }\n\n        VAR_0->input_curr_p += 2;\n        if (VAR_7 == false && lit_utf8_peek_next (VAR_0->input_curr_p) == VAR_13)\n        {\n          VAR_5 = VAR_35;\n          continue;\n        }\n\n        VAR_11 = VAR_35;\n      }\n      else if (VAR_11 == VAR_36)\n      {\n        ecma_char_t VAR_35;\n\n        if (!lit_read_code_unit_from_hex (VAR_0->input_curr_p, 4, &VAR_35))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\u'\"));\n        }\n\n        VAR_0->input_curr_p += 4;\n        if (VAR_7 == false && lit_utf8_peek_next (VAR_0->input_curr_p) == VAR_13)\n        {\n          VAR_5 = VAR_35;\n          continue;\n        }\n\n        VAR_11 = VAR_35;\n      }\n      else if (VAR_11 == VAR_37)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_38, VAR_39);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_40)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_41, VAR_38 - 1);\n        VAR_1 (VAR_2, VAR_39 + 1, VAR_42);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_43)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_22, VAR_24);\n        VAR_1 (VAR_2, VAR_44, VAR_44);\n        VAR_1 (VAR_2, VAR_45, VAR_45);\n        VAR_1 (VAR_2, 0x1680UL, 0x1680UL); /* COMMENT_8 */\n        VAR_1 (VAR_2, 0x180EUL, 0x180EUL); /* COMMENT_9 */\n        VAR_1 (VAR_2, 0x2000UL, 0x200AUL); /* COMMENT_10 */\n        VAR_1 (VAR_2, VAR_46, VAR_47);\n        VAR_1 (VAR_2, 0x202FUL, 0x202FUL); /* COMMENT_11 */\n        VAR_1 (VAR_2, 0x205FUL, 0x205FUL); /* COMMENT_12 */\n        VAR_1 (VAR_2, 0x3000UL, 0x3000UL); /* COMMENT_13 */\n        VAR_1 (VAR_2, VAR_48, VAR_48);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_49)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_41, VAR_22 - 1);\n        VAR_1 (VAR_2, VAR_24 + 1, VAR_44 - 1);\n        VAR_1 (VAR_2, VAR_44 + 1, VAR_45 - 1);\n        VAR_1 (VAR_2, VAR_45 + 1, 0x167FUL);\n        VAR_1 (VAR_2, 0x1681UL, 0x180DUL);\n        VAR_1 (VAR_2, 0x180FUL, 0x1FFFUL);\n        VAR_1 (VAR_2, 0x200BUL, VAR_46 - 1);\n        VAR_1 (VAR_2, VAR_47 + 1, 0x202EUL);\n        VAR_1 (VAR_2, 0x2030UL, 0x205EUL);\n        VAR_1 (VAR_2, 0x2060UL, 0x2FFFUL);\n        VAR_1 (VAR_2, 0x3001UL, VAR_48 - 1);\n        VAR_1 (VAR_2, VAR_48 + 1, VAR_42);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_50)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_32, VAR_33);\n        VAR_1 (VAR_2, VAR_51, VAR_52);\n        VAR_1 (VAR_2, VAR_53, VAR_53);\n        VAR_1 (VAR_2, VAR_54, VAR_55);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_56)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_41, VAR_32 - 1);\n        VAR_1 (VAR_2, VAR_33 + 1, VAR_51 - 1);\n        VAR_1 (VAR_2, VAR_52 + 1, VAR_53 - 1);\n        VAR_1 (VAR_2, VAR_53 + 1, VAR_54 - 1);\n        VAR_1 (VAR_2, VAR_55 + 1, VAR_42);\n        VAR_11 = VAR_6;\n      }\n      else if (lit_char_is_octal_digit ((ecma_char_t) VAR_11)\n               && VAR_11 != VAR_32)\n      {\n        lit_utf8_decr (&VAR_0->input_curr_p);\n        VAR_11 = (ecma_char_t) re_parse_octal (VAR_0);\n      }\n    } /* COMMENT_14 */\n\n    if (VAR_5 != VAR_6)\n    {\n      if (VAR_7)\n      {\n        if (VAR_5 > VAR_11)\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, wrong order\"));\n        }\n        else\n        {\n          VAR_1 (VAR_2, VAR_5, VAR_11);\n          VAR_5 = VAR_6;\n          VAR_7 = false;\n        }\n      }\n      else\n      {\n        VAR_1 (VAR_2, VAR_5, VAR_5);\n        VAR_5 = VAR_11;\n      }\n    }\n    else\n    {\n      VAR_5 = VAR_11;\n    }\n  }\n  while (VAR_4 == VAR_57 || VAR_4 == VAR_58);\n\n  return re_parse_iterator (VAR_0, VAR_3);\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/7c3f2bc8c7ed0c28a1ea097d7177363f8998a566/re-parser.c/vul/before/0.json",
  "func": "ecma_value_t\nre_parse_char_class (re_parser_ctx_t *parser_ctx_p, /**< number of classes */\n                     re_char_class_callback append_char_class, /**< callback function,\n                                                                *   which adds the char-ranges\n                                                                *   to the bytecode */\n                     void *re_ctx_p, /**< regexp compiler context */\n                     re_token_t *out_token_p) /**< [out] output token */\n{\n  re_token_type_t token_type = ((re_compiler_ctx_t *) re_ctx_p)->current_token.type;\n  out_token_p->qmax = out_token_p->qmin = 1;\n  ecma_char_t start = LIT_CHAR_UNDEF;\n  bool is_range = false;\n  parser_ctx_p->num_of_classes = 0;\n\n  const ecma_char_t prev_char = lit_utf8_peek_prev (parser_ctx_p->input_curr_p);\n  if (prev_char != LIT_CHAR_LEFT_SQUARE && prev_char != LIT_CHAR_CIRCUMFLEX)\n  {\n    lit_utf8_decr (&parser_ctx_p->input_curr_p);\n    lit_utf8_decr (&parser_ctx_p->input_curr_p);\n  }\n\n  do\n  {\n    if (parser_ctx_p->input_curr_p >= parser_ctx_p->input_end_p)\n    {\n      return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string\"));\n    }\n\n    ecma_char_t ch = lit_utf8_read_next (&parser_ctx_p->input_curr_p);\n\n    if (ch == LIT_CHAR_RIGHT_SQUARE)\n    {\n      if (start != LIT_CHAR_UNDEF)\n      {\n        append_char_class (re_ctx_p, start, start);\n      }\n      break;\n    }\n    else if (ch == LIT_CHAR_MINUS)\n    {\n      if (parser_ctx_p->input_curr_p >= parser_ctx_p->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '-'\"));\n      }\n\n      if (start != LIT_CHAR_UNDEF\n          && !is_range\n          && *parser_ctx_p->input_curr_p != LIT_CHAR_RIGHT_SQUARE)\n      {\n        is_range = true;\n        continue;\n      }\n    }\n    else if (ch == LIT_CHAR_BACKSLASH)\n    {\n      if (parser_ctx_p->input_curr_p >= parser_ctx_p->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\'\"));\n      }\n\n      ch = lit_utf8_read_next (&parser_ctx_p->input_curr_p);\n\n      if (ch == LIT_CHAR_LOWERCASE_B)\n      {\n        ch = LIT_CHAR_BS;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_F)\n      {\n        ch = LIT_CHAR_FF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_N)\n      {\n        ch = LIT_CHAR_LF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_T)\n      {\n        ch = LIT_CHAR_TAB;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_R)\n      {\n        ch = LIT_CHAR_CR;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_V)\n      {\n        ch = LIT_CHAR_VTAB;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_C)\n      {\n        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p)\n        {\n          ch = *parser_ctx_p->input_curr_p;\n\n          if ((ch >= LIT_CHAR_ASCII_UPPERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_UPPERCASE_LETTERS_END)\n              || (ch >= LIT_CHAR_ASCII_LOWERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_LOWERCASE_LETTERS_END)\n              || (ch >= LIT_CHAR_0 && ch <= LIT_CHAR_9))\n          {\n            /* See ECMA-262 v5, 15.10.2.10 (Point 3) */\n            ch = (ch % 32);\n            parser_ctx_p->input_curr_p++;\n          }\n          else\n          {\n            ch = LIT_CHAR_LOWERCASE_C;\n          }\n        }\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_X && re_hex_lookup (parser_ctx_p, 2))\n      {\n        ecma_char_t code_unit;\n\n        if (!lit_read_code_unit_from_hex (parser_ctx_p->input_curr_p, 2, &code_unit))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\x'\"));\n        }\n\n        parser_ctx_p->input_curr_p += 2;\n        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p\n            && is_range == false\n            && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n        {\n          start = code_unit;\n          continue;\n        }\n\n        ch = code_unit;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_U && re_hex_lookup (parser_ctx_p, 4))\n      {\n        ecma_char_t code_unit;\n\n        if (!lit_read_code_unit_from_hex (parser_ctx_p->input_curr_p, 4, &code_unit))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\u'\"));\n        }\n\n        parser_ctx_p->input_curr_p += 4;\n        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p\n            && is_range == false\n            && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n        {\n          start = code_unit;\n          continue;\n        }\n\n        ch = code_unit;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_D)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_ASCII_DIGITS_BEGIN, LIT_CHAR_ASCII_DIGITS_END);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_UPPERCASE_D)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_NULL, LIT_CHAR_ASCII_DIGITS_BEGIN - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_ASCII_DIGITS_END + 1, LIT_UTF16_CODE_UNIT_MAX);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_S)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_TAB, LIT_CHAR_CR);\n        append_char_class (re_ctx_p, LIT_CHAR_SP, LIT_CHAR_SP);\n        append_char_class (re_ctx_p, LIT_CHAR_NBSP, LIT_CHAR_NBSP);\n        append_char_class (re_ctx_p, 0x1680UL, 0x1680UL); /* Ogham Space Mark */\n        append_char_class (re_ctx_p, 0x180EUL, 0x180EUL); /* Mongolian Vowel Separator */\n        append_char_class (re_ctx_p, 0x2000UL, 0x200AUL); /* En Quad - Hair Space */\n        append_char_class (re_ctx_p, LIT_CHAR_LS, LIT_CHAR_PS);\n        append_char_class (re_ctx_p, 0x202FUL, 0x202FUL); /* Narrow No-Break Space */\n        append_char_class (re_ctx_p, 0x205FUL, 0x205FUL); /* Medium Mathematical Space */\n        append_char_class (re_ctx_p, 0x3000UL, 0x3000UL); /* Ideographic Space */\n        append_char_class (re_ctx_p, LIT_CHAR_BOM, LIT_CHAR_BOM);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_UPPERCASE_S)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_NULL, LIT_CHAR_TAB - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_CR + 1, LIT_CHAR_SP - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_SP + 1, LIT_CHAR_NBSP - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_NBSP + 1, 0x167FUL);\n        append_char_class (re_ctx_p, 0x1681UL, 0x180DUL);\n        append_char_class (re_ctx_p, 0x180FUL, 0x1FFFUL);\n        append_char_class (re_ctx_p, 0x200BUL, LIT_CHAR_LS - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_PS + 1, 0x202EUL);\n        append_char_class (re_ctx_p, 0x2030UL, 0x205EUL);\n        append_char_class (re_ctx_p, 0x2060UL, 0x2FFFUL);\n        append_char_class (re_ctx_p, 0x3001UL, LIT_CHAR_BOM - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_BOM + 1, LIT_UTF16_CODE_UNIT_MAX);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_LOWERCASE_W)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_0, LIT_CHAR_9);\n        append_char_class (re_ctx_p, LIT_CHAR_UPPERCASE_A, LIT_CHAR_UPPERCASE_Z);\n        append_char_class (re_ctx_p, LIT_CHAR_UNDERSCORE, LIT_CHAR_UNDERSCORE);\n        append_char_class (re_ctx_p, LIT_CHAR_LOWERCASE_A, LIT_CHAR_LOWERCASE_Z);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (ch == LIT_CHAR_UPPERCASE_W)\n      {\n        /* See ECMA-262 v5, 15.10.2.12 */\n        append_char_class (re_ctx_p, LIT_CHAR_NULL, LIT_CHAR_0 - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_9 + 1, LIT_CHAR_UPPERCASE_A - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_UPPERCASE_Z + 1, LIT_CHAR_UNDERSCORE - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_UNDERSCORE + 1, LIT_CHAR_LOWERCASE_A - 1);\n        append_char_class (re_ctx_p, LIT_CHAR_LOWERCASE_Z + 1, LIT_UTF16_CODE_UNIT_MAX);\n        ch = LIT_CHAR_UNDEF;\n      }\n      else if (lit_char_is_octal_digit ((ecma_char_t) ch)\n               && ch != LIT_CHAR_0)\n      {\n        lit_utf8_decr (&parser_ctx_p->input_curr_p);\n        ch = (ecma_char_t) re_parse_octal (parser_ctx_p);\n      }\n    } /* ch == LIT_CHAR_BACKSLASH */\n\n    if (start != LIT_CHAR_UNDEF)\n    {\n      if (is_range)\n      {\n        if (start > ch)\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, wrong order\"));\n        }\n        else\n        {\n          append_char_class (re_ctx_p, start, ch);\n          start = LIT_CHAR_UNDEF;\n          is_range = false;\n        }\n      }\n      else\n      {\n        append_char_class (re_ctx_p, start, start);\n        start = ch;\n      }\n    }\n    else\n    {\n      start = ch;\n    }\n  }\n  while (token_type == RE_TOK_START_CHAR_CLASS || token_type == RE_TOK_START_INV_CHAR_CLASS);\n\n  return re_parse_iterator (parser_ctx_p, out_token_p);\n}",
  "abstract_func": "ecma_value_t\nre_parse_char_class (re_parser_ctx_t *VAR_0, /* COMMENT_0 */\n                     re_char_class_callback VAR_1, /* COMMENT_1 */\n                                                                                              \n                                                                                      \n                     void *VAR_2, /* COMMENT_4 */\n                     re_token_t *VAR_3) /* COMMENT_5 */\n{\n  re_token_type_t VAR_4 = ((re_compiler_ctx_t *) VAR_2)->current_token.type;\n  VAR_3->qmax = VAR_3->qmin = 1;\n  ecma_char_t VAR_5 = VAR_6;\n  bool VAR_7 = false;\n  VAR_0->num_of_classes = 0;\n\n  const ecma_char_t VAR_8 = lit_utf8_peek_prev (VAR_0->input_curr_p);\n  if (VAR_8 != VAR_9 && VAR_8 != VAR_10)\n  {\n    lit_utf8_decr (&VAR_0->input_curr_p);\n    lit_utf8_decr (&VAR_0->input_curr_p);\n  }\n\n  do\n  {\n    if (VAR_0->input_curr_p >= VAR_0->input_end_p)\n    {\n      return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string\"));\n    }\n\n    ecma_char_t VAR_11 = lit_utf8_read_next (&VAR_0->input_curr_p);\n\n    if (VAR_11 == VAR_12)\n    {\n      if (VAR_5 != VAR_6)\n      {\n        VAR_1 (VAR_2, VAR_5, VAR_5);\n      }\n      break;\n    }\n    else if (VAR_11 == VAR_13)\n    {\n      if (VAR_0->input_curr_p >= VAR_0->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '-'\"));\n      }\n\n      if (VAR_5 != VAR_6\n          && !VAR_7\n          && *VAR_0->input_curr_p != VAR_12)\n      {\n        VAR_7 = true;\n        continue;\n      }\n    }\n    else if (VAR_11 == VAR_14)\n    {\n      if (VAR_0->input_curr_p >= VAR_0->input_end_p)\n      {\n        return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\'\"));\n      }\n\n      VAR_11 = lit_utf8_read_next (&VAR_0->input_curr_p);\n\n      if (VAR_11 == VAR_15)\n      {\n        VAR_11 = VAR_16;\n      }\n      else if (VAR_11 == VAR_17)\n      {\n        VAR_11 = VAR_18;\n      }\n      else if (VAR_11 == VAR_19)\n      {\n        VAR_11 = VAR_20;\n      }\n      else if (VAR_11 == VAR_21)\n      {\n        VAR_11 = VAR_22;\n      }\n      else if (VAR_11 == VAR_23)\n      {\n        VAR_11 = VAR_24;\n      }\n      else if (VAR_11 == VAR_25)\n      {\n        VAR_11 = VAR_26;\n      }\n      else if (VAR_11 == VAR_27)\n      {\n        if (VAR_0->input_curr_p < VAR_0->input_end_p)\n        {\n          VAR_11 = *VAR_0->input_curr_p;\n\n          if ((VAR_11 >= VAR_28 && VAR_11 <= VAR_29)\n              || (VAR_11 >= VAR_30 && VAR_11 <= VAR_31)\n              || (VAR_11 >= VAR_32 && VAR_11 <= VAR_33))\n          {\n            /* COMMENT_6 */\n            VAR_11 = (VAR_11 % 32);\n            VAR_0->input_curr_p++;\n          }\n          else\n          {\n            VAR_11 = VAR_27;\n          }\n        }\n      }\n      else if (VAR_11 == VAR_34 && re_hex_lookup (VAR_0, 2))\n      {\n        ecma_char_t VAR_35;\n\n        if (!lit_read_code_unit_from_hex (VAR_0->input_curr_p, 2, &VAR_35))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\x'\"));\n        }\n\n        VAR_0->input_curr_p += 2;\n        if (VAR_0->input_curr_p < VAR_0->input_end_p\n            && VAR_7 == false\n            && lit_utf8_peek_next (VAR_0->input_curr_p) == VAR_13)\n        {\n          VAR_5 = VAR_35;\n          continue;\n        }\n\n        VAR_11 = VAR_35;\n      }\n      else if (VAR_11 == VAR_36 && re_hex_lookup (VAR_0, 4))\n      {\n        ecma_char_t VAR_35;\n\n        if (!lit_read_code_unit_from_hex (VAR_0->input_curr_p, 4, &VAR_35))\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, end of string after '\\\\u'\"));\n        }\n\n        VAR_0->input_curr_p += 4;\n        if (VAR_0->input_curr_p < VAR_0->input_end_p\n            && VAR_7 == false\n            && lit_utf8_peek_next (VAR_0->input_curr_p) == VAR_13)\n        {\n          VAR_5 = VAR_35;\n          continue;\n        }\n\n        VAR_11 = VAR_35;\n      }\n      else if (VAR_11 == VAR_37)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_38, VAR_39);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_40)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_41, VAR_38 - 1);\n        VAR_1 (VAR_2, VAR_39 + 1, VAR_42);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_43)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_22, VAR_24);\n        VAR_1 (VAR_2, VAR_44, VAR_44);\n        VAR_1 (VAR_2, VAR_45, VAR_45);\n        VAR_1 (VAR_2, 0x1680UL, 0x1680UL); /* COMMENT_8 */\n        VAR_1 (VAR_2, 0x180EUL, 0x180EUL); /* COMMENT_9 */\n        VAR_1 (VAR_2, 0x2000UL, 0x200AUL); /* COMMENT_10 */\n        VAR_1 (VAR_2, VAR_46, VAR_47);\n        VAR_1 (VAR_2, 0x202FUL, 0x202FUL); /* COMMENT_11 */\n        VAR_1 (VAR_2, 0x205FUL, 0x205FUL); /* COMMENT_12 */\n        VAR_1 (VAR_2, 0x3000UL, 0x3000UL); /* COMMENT_13 */\n        VAR_1 (VAR_2, VAR_48, VAR_48);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_49)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_41, VAR_22 - 1);\n        VAR_1 (VAR_2, VAR_24 + 1, VAR_44 - 1);\n        VAR_1 (VAR_2, VAR_44 + 1, VAR_45 - 1);\n        VAR_1 (VAR_2, VAR_45 + 1, 0x167FUL);\n        VAR_1 (VAR_2, 0x1681UL, 0x180DUL);\n        VAR_1 (VAR_2, 0x180FUL, 0x1FFFUL);\n        VAR_1 (VAR_2, 0x200BUL, VAR_46 - 1);\n        VAR_1 (VAR_2, VAR_47 + 1, 0x202EUL);\n        VAR_1 (VAR_2, 0x2030UL, 0x205EUL);\n        VAR_1 (VAR_2, 0x2060UL, 0x2FFFUL);\n        VAR_1 (VAR_2, 0x3001UL, VAR_48 - 1);\n        VAR_1 (VAR_2, VAR_48 + 1, VAR_42);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_50)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_32, VAR_33);\n        VAR_1 (VAR_2, VAR_51, VAR_52);\n        VAR_1 (VAR_2, VAR_53, VAR_53);\n        VAR_1 (VAR_2, VAR_54, VAR_55);\n        VAR_11 = VAR_6;\n      }\n      else if (VAR_11 == VAR_56)\n      {\n        /* COMMENT_7 */\n        VAR_1 (VAR_2, VAR_41, VAR_32 - 1);\n        VAR_1 (VAR_2, VAR_33 + 1, VAR_51 - 1);\n        VAR_1 (VAR_2, VAR_52 + 1, VAR_53 - 1);\n        VAR_1 (VAR_2, VAR_53 + 1, VAR_54 - 1);\n        VAR_1 (VAR_2, VAR_55 + 1, VAR_42);\n        VAR_11 = VAR_6;\n      }\n      else if (lit_char_is_octal_digit ((ecma_char_t) VAR_11)\n               && VAR_11 != VAR_32)\n      {\n        lit_utf8_decr (&VAR_0->input_curr_p);\n        VAR_11 = (ecma_char_t) re_parse_octal (VAR_0);\n      }\n    } /* COMMENT_14 */\n\n    if (VAR_5 != VAR_6)\n    {\n      if (VAR_7)\n      {\n        if (VAR_5 > VAR_11)\n        {\n          return ecma_raise_syntax_error (ECMA_ERR_MSG (\"invalid character class, wrong order\"));\n        }\n        else\n        {\n          VAR_1 (VAR_2, VAR_5, VAR_11);\n          VAR_5 = VAR_6;\n          VAR_7 = false;\n        }\n      }\n      else\n      {\n        VAR_1 (VAR_2, VAR_5, VAR_5);\n        VAR_5 = VAR_11;\n      }\n    }\n    else\n    {\n      VAR_5 = VAR_11;\n    }\n  }\n  while (VAR_4 == VAR_57 || VAR_4 == VAR_58);\n\n  return re_parse_iterator (VAR_0, VAR_3);\n}",
  "func_graph_path": "jerryscript-project/jerryscript/7c3f2bc8c7ed0c28a1ea097d7177363f8998a566/re-parser.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -104,7 +104,7 @@\n           }\n         }\n       }\n-      else if (ch == LIT_CHAR_LOWERCASE_X)\n+      else if (ch == LIT_CHAR_LOWERCASE_X && re_hex_lookup (parser_ctx_p, 2))\n       {\n         ecma_char_t code_unit;\n \n@@ -114,7 +114,9 @@\n         }\n \n         parser_ctx_p->input_curr_p += 2;\n-        if (is_range == false && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n+        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p\n+            && is_range == false\n+            && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n         {\n           start = code_unit;\n           continue;\n@@ -122,7 +124,7 @@\n \n         ch = code_unit;\n       }\n-      else if (ch == LIT_CHAR_LOWERCASE_U)\n+      else if (ch == LIT_CHAR_LOWERCASE_U && re_hex_lookup (parser_ctx_p, 4))\n       {\n         ecma_char_t code_unit;\n \n@@ -132,7 +134,9 @@\n         }\n \n         parser_ctx_p->input_curr_p += 4;\n-        if (is_range == false && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n+        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p\n+            && is_range == false\n+            && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)\n         {\n           start = code_unit;\n           continue;",
  "diff_line_info": {
    "deleted_lines": [
      "      else if (ch == LIT_CHAR_LOWERCASE_X)",
      "        if (is_range == false && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)",
      "      else if (ch == LIT_CHAR_LOWERCASE_U)",
      "        if (is_range == false && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)"
    ],
    "added_lines": [
      "      else if (ch == LIT_CHAR_LOWERCASE_X && re_hex_lookup (parser_ctx_p, 2))",
      "        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p",
      "            && is_range == false",
      "            && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)",
      "      else if (ch == LIT_CHAR_LOWERCASE_U && re_hex_lookup (parser_ctx_p, 4))",
      "        if (parser_ctx_p->input_curr_p < parser_ctx_p->input_end_p",
      "            && is_range == false",
      "            && lit_utf8_peek_next (parser_ctx_p->input_curr_p) == LIT_CHAR_MINUS)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/2352",
  "description": {
    "pr_info": {
      "title": "Fix heap buffer overflow in re_parse_char_class",
      "number": 2352
    },
    "comment": [
      "This patch fixes #2230 and fixes #2237.\r\nTest cases are added for both issues and also adds new cases which caused the same error.\r\n\r\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik frobert@inf.u-szeged.hu",
      "@akosthekiss Thanks for the review, I've applied your suggestions."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Output:**  \n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\n**Step-by-Step Explanation:**  \n1. **Input Analysis:** The commit message indicates a fix for a heap buffer overflow, a security issue. The code changes add bounds checking, typical for security patches.  \n2. **Consistency Check:** The commit and code changes align, addressing buffer overflow in re.Parse_char_class.  \n3. **Purpose Evaluation:** The fix directly tackles a security risk by preventing overflow.  \n4. **Security Assessment:** Heap buffer overflow is a known security issue; the fix adds necessary checks.  \n5. **Confidence:** High due to clear evidence of a security fix.  \n\n**Answer:**  \n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}