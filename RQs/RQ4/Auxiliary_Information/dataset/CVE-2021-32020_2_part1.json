{
  "cve_id": "CVE-2021-32020",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "FreeRTOS/FreeRTOS-Kernel",
  "commit_msg": "Improve heap2 bounds checking (#224)\n\n* Improve heap bounds checking in pvPortMalloc",
  "commit_hash": "c7a9a01c94987082b223d3e59969ede64363da63",
  "git_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63",
  "file_path": "portable/MemMang/heap_4.c",
  "func_name": "pvPortMalloc",
  "func_before": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    void * pvReturn = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* If this is the first call to malloc then the heap will require\n         * initialisation to setup the list of free blocks. */\n        if( pxEnd == NULL )\n        {\n            prvHeapInit();\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        /* Check the requested block size is not so large that the top bit is\n         * set.  The top bit of the block size member of the BlockLink_t structure\n         * is used to determine who owns the block - the application or the\n         * kernel, so it must be free. */\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\n        {\n            /* The wanted size is increased so it can contain a BlockLink_t\n             * structure in addition to the requested amount of bytes. */\n            if( xWantedSize > 0 )\n            {\n                xWantedSize += xHeapStructSize;\n\n                /* Ensure that blocks are always aligned to the required number\n                 * of bytes. */\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\n                {\n                    /* Byte alignment required. */\n                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\n            {\n                /* Traverse the list from the start\t(lowest address) block until\n                 * one\tof adequate size is found. */\n                pxPreviousBlock = &xStart;\n                pxBlock = xStart.pxNextFreeBlock;\n\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n                {\n                    pxPreviousBlock = pxBlock;\n                    pxBlock = pxBlock->pxNextFreeBlock;\n                }\n\n                /* If the end marker was reached then a block of adequate size\n                 * was\tnot found. */\n                if( pxBlock != pxEnd )\n                {\n                    /* Return the memory space pointed to - jumping over the\n                     * BlockLink_t structure at its start. */\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\n\n                    /* This block is being returned for use so must be taken out\n                     * of the list of free blocks. */\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n                    /* If the block is larger than required it can be split into\n                     * two. */\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                    {\n                        /* This block is to be split into two.  Create a new\n                         * block following the number of bytes requested. The void\n                         * cast is used to prevent byte alignment warnings from the\n                         * compiler. */\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );\n\n                        /* Calculate the sizes of two blocks split from the\n                         * single block. */\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                        pxBlock->xBlockSize = xWantedSize;\n\n                        /* Insert the new block into the list of free blocks. */\n                        prvInsertBlockIntoFreeList( pxNewBlockLink );\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\n\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\n                    {\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    /* The block is being returned - it is allocated and owned\n                     * by the application and has no \"next\" block. */\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\n                    pxBlock->pxNextFreeBlock = NULL;\n                    xNumberOfSuccessfulAllocations++;\n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\n\n    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );\n    return pvReturn;\n}",
  "abstract_func_before": "void * pvPortMalloc( size_t VAR_0 )\n{\n    BlockLink_t * VAR_1, * VAR_2, * VAR_3;\n    void * VAR_4 = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* COMMENT_0 */\n                                                              \n        if( VAR_5 == NULL )\n        {\n            prvHeapInit();\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        /* COMMENT_2 */\n                                                                                  \n                                                                           \n                                         \n        if( ( VAR_0 & VAR_6 ) == 0 )\n        {\n            /* COMMENT_6 */\n                                                                         \n            if( VAR_0 > 0 )\n            {\n                VAR_0 += VAR_7;\n\n                /* COMMENT_8 */\n                               \n                if( ( VAR_0 & VAR_8 ) != 0x00 )\n                {\n                    /* COMMENT_10 */\n                    VAR_0 += ( VAR_9 - ( VAR_0 & VAR_8 ) );\n                    configASSERT( ( VAR_0 & VAR_8 ) == 0 );\n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n\n            if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_10 ) )\n            {\n                /* COMMENT_11 */\n                                                    \n                VAR_2 = &VAR_11;\n                VAR_1 = VAR_11.pxNextFreeBlock;\n\n                while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )\n                {\n                    VAR_2 = VAR_1;\n                    VAR_1 = VAR_1->pxNextFreeBlock;\n                }\n\n                /* COMMENT_13 */\n                                    \n                if( VAR_1 != VAR_5 )\n                {\n                    /* COMMENT_15 */\n                                                             \n                    VAR_4 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_7 );\n\n                    /* COMMENT_17 */\n                                                     \n                    VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;\n\n                    /* COMMENT_19 */\n                              \n                    if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_12 )\n                    {\n                        /* COMMENT_21 */\n                                                                                  \n                                                                                   \n                                       \n                        VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );\n                        configASSERT( ( ( ( size_t ) VAR_3 ) & VAR_8 ) == 0 );\n\n                        /* COMMENT_25 */\n                                           \n                        VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;\n                        VAR_1->xBlockSize = VAR_0;\n\n                        /* COMMENT_27 */\n                        prvInsertBlockIntoFreeList( VAR_3 );\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    VAR_10 -= VAR_1->xBlockSize;\n\n                    if( VAR_10 < VAR_13 )\n                    {\n                        VAR_13 = VAR_10;\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    /* COMMENT_28 */\n                                                                     \n                    VAR_1->xBlockSize |= VAR_6;\n                    VAR_1->pxNextFreeBlock = NULL;\n                    VAR_14++;\n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        traceMALLOC( VAR_4, VAR_0 );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( VAR_15 == 1 )\n        {\n            if( VAR_4 == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n    #endif /* COMMENT_30 */\n\n    configASSERT( ( ( ( size_t ) VAR_4 ) & ( size_t ) VAR_8 ) == 0 );\n    return VAR_4;\n}",
  "func_graph_path_before": "FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_4.c/vul/before/0.json",
  "func": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    void * pvReturn = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* If this is the first call to malloc then the heap will require\n         * initialisation to setup the list of free blocks. */\n        if( pxEnd == NULL )\n        {\n            prvHeapInit();\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        /* Check the requested block size is not so large that the top bit is\n         * set.  The top bit of the block size member of the BlockLink_t structure\n         * is used to determine who owns the block - the application or the\n         * kernel, so it must be free. */\n        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\n        {\n            /* The wanted size must be increased so it can contain a BlockLink_t\n             * structure in addition to the requested amount of bytes. */\n            if( ( xWantedSize > 0 ) && \n                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */\n            {\n                xWantedSize += xHeapStructSize;\n\n                /* Ensure that blocks are always aligned. */\n                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\n                {\n                    /* Byte alignment required. Check for overflow. */\n                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \n                            > xWantedSize )\n                    {\n                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n                    }\n                    else\n                    {\n                        xWantedSize = 0;\n                    }  \n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            } \n            else \n            {\n                xWantedSize = 0;\n            }\n\n            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\n            {\n                /* Traverse the list from the start\t(lowest address) block until\n                 * one of adequate size is found. */\n                pxPreviousBlock = &xStart;\n                pxBlock = xStart.pxNextFreeBlock;\n\n                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n                {\n                    pxPreviousBlock = pxBlock;\n                    pxBlock = pxBlock->pxNextFreeBlock;\n                }\n\n                /* If the end marker was reached then a block of adequate size\n                 * was not found. */\n                if( pxBlock != pxEnd )\n                {\n                    /* Return the memory space pointed to - jumping over the\n                     * BlockLink_t structure at its start. */\n                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\n\n                    /* This block is being returned for use so must be taken out\n                     * of the list of free blocks. */\n                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n                    /* If the block is larger than required it can be split into\n                     * two. */\n                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                    {\n                        /* This block is to be split into two.  Create a new\n                         * block following the number of bytes requested. The void\n                         * cast is used to prevent byte alignment warnings from the\n                         * compiler. */\n                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );\n\n                        /* Calculate the sizes of two blocks split from the\n                         * single block. */\n                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                        pxBlock->xBlockSize = xWantedSize;\n\n                        /* Insert the new block into the list of free blocks. */\n                        prvInsertBlockIntoFreeList( pxNewBlockLink );\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    xFreeBytesRemaining -= pxBlock->xBlockSize;\n\n                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\n                    {\n                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    /* The block is being returned - it is allocated and owned\n                     * by the application and has no \"next\" block. */\n                    pxBlock->xBlockSize |= xBlockAllocatedBit;\n                    pxBlock->pxNextFreeBlock = NULL;\n                    xNumberOfSuccessfulAllocations++;\n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */\n\n    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );\n    return pvReturn;\n}",
  "abstract_func": "void * pvPortMalloc( size_t VAR_0 )\n{\n    BlockLink_t * VAR_1, * VAR_2, * VAR_3;\n    void * VAR_4 = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* COMMENT_0 */\n                                                              \n        if( VAR_5 == NULL )\n        {\n            prvHeapInit();\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        /* COMMENT_2 */\n                                                                                  \n                                                                           \n                                         \n        if( ( VAR_0 & VAR_6 ) == 0 )\n        {\n            /* COMMENT_6 */\n                                                                         \n            if( ( VAR_0 > 0 ) && \n                ( ( VAR_0 + VAR_7 ) >  VAR_0 ) ) /* COMMENT_8 */\n            {\n                VAR_0 += VAR_7;\n\n                /* COMMENT_9 */\n                if( ( VAR_0 & VAR_8 ) != 0x00 )\n                {\n                    /* COMMENT_10 */\n                    if( ( VAR_0 + ( VAR_9 - ( VAR_0 & VAR_8 ) ) ) \n                            > VAR_0 )\n                    {\n                        VAR_0 += ( VAR_9 - ( VAR_0 & VAR_8 ) );\n                        configASSERT( ( VAR_0 & VAR_8 ) == 0 );\n                    }\n                    else\n                    {\n                        VAR_0 = 0;\n                    }  \n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            } \n            else \n            {\n                VAR_0 = 0;\n            }\n\n            if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_10 ) )\n            {\n                /* COMMENT_11 */\n                                                    \n                VAR_2 = &VAR_11;\n                VAR_1 = VAR_11.pxNextFreeBlock;\n\n                while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )\n                {\n                    VAR_2 = VAR_1;\n                    VAR_1 = VAR_1->pxNextFreeBlock;\n                }\n\n                /* COMMENT_13 */\n                                    \n                if( VAR_1 != VAR_5 )\n                {\n                    /* COMMENT_15 */\n                                                             \n                    VAR_4 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_7 );\n\n                    /* COMMENT_17 */\n                                                     \n                    VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;\n\n                    /* COMMENT_19 */\n                              \n                    if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_12 )\n                    {\n                        /* COMMENT_21 */\n                                                                                  \n                                                                                   \n                                       \n                        VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );\n                        configASSERT( ( ( ( size_t ) VAR_3 ) & VAR_8 ) == 0 );\n\n                        /* COMMENT_25 */\n                                           \n                        VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;\n                        VAR_1->xBlockSize = VAR_0;\n\n                        /* COMMENT_27 */\n                        prvInsertBlockIntoFreeList( VAR_3 );\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    VAR_10 -= VAR_1->xBlockSize;\n\n                    if( VAR_10 < VAR_13 )\n                    {\n                        VAR_13 = VAR_10;\n                    }\n                    else\n                    {\n                        mtCOVERAGE_TEST_MARKER();\n                    }\n\n                    /* COMMENT_28 */\n                                                                     \n                    VAR_1->xBlockSize |= VAR_6;\n                    VAR_1->pxNextFreeBlock = NULL;\n                    VAR_14++;\n                }\n                else\n                {\n                    mtCOVERAGE_TEST_MARKER();\n                }\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n        else\n        {\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        traceMALLOC( VAR_4, VAR_0 );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( VAR_15 == 1 )\n        {\n            if( VAR_4 == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n            else\n            {\n                mtCOVERAGE_TEST_MARKER();\n            }\n        }\n    #endif /* COMMENT_30 */\n\n    configASSERT( ( ( ( size_t ) VAR_4 ) & ( size_t ) VAR_8 ) == 0 );\n    return VAR_4;\n}",
  "func_graph_path": "FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_4.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,34 +22,42 @@\n          * kernel, so it must be free. */\n         if( ( xWantedSize & xBlockAllocatedBit ) == 0 )\n         {\n-            /* The wanted size is increased so it can contain a BlockLink_t\n+            /* The wanted size must be increased so it can contain a BlockLink_t\n              * structure in addition to the requested amount of bytes. */\n-            if( xWantedSize > 0 )\n+            if( ( xWantedSize > 0 ) && \n+                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */\n             {\n                 xWantedSize += xHeapStructSize;\n \n-                /* Ensure that blocks are always aligned to the required number\n-                 * of bytes. */\n+                /* Ensure that blocks are always aligned. */\n                 if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\n                 {\n-                    /* Byte alignment required. */\n-                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n-                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n+                    /* Byte alignment required. Check for overflow. */\n+                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \n+                            > xWantedSize )\n+                    {\n+                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n+                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n+                    }\n+                    else\n+                    {\n+                        xWantedSize = 0;\n+                    }  \n                 }\n                 else\n                 {\n                     mtCOVERAGE_TEST_MARKER();\n                 }\n-            }\n-            else\n+            } \n+            else \n             {\n-                mtCOVERAGE_TEST_MARKER();\n+                xWantedSize = 0;\n             }\n \n             if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\n             {\n                 /* Traverse the list from the start\t(lowest address) block until\n-                 * one\tof adequate size is found. */\n+                 * one of adequate size is found. */\n                 pxPreviousBlock = &xStart;\n                 pxBlock = xStart.pxNextFreeBlock;\n \n@@ -60,7 +68,7 @@\n                 }\n \n                 /* If the end marker was reached then a block of adequate size\n-                 * was\tnot found. */\n+                 * was not found. */\n                 if( pxBlock != pxEnd )\n                 {\n                     /* Return the memory space pointed to - jumping over the",
  "diff_line_info": {
    "deleted_lines": [
      "            /* The wanted size is increased so it can contain a BlockLink_t",
      "            if( xWantedSize > 0 )",
      "                /* Ensure that blocks are always aligned to the required number",
      "                 * of bytes. */",
      "                    /* Byte alignment required. */",
      "                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );",
      "                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );",
      "            }",
      "            else",
      "                mtCOVERAGE_TEST_MARKER();",
      "                 * one\tof adequate size is found. */",
      "                 * was\tnot found. */"
    ],
    "added_lines": [
      "            /* The wanted size must be increased so it can contain a BlockLink_t",
      "            if( ( xWantedSize > 0 ) && ",
      "                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */",
      "                /* Ensure that blocks are always aligned. */",
      "                    /* Byte alignment required. Check for overflow. */",
      "                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) ",
      "                            > xWantedSize )",
      "                    {",
      "                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );",
      "                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );",
      "                    }",
      "                    else",
      "                    {",
      "                        xWantedSize = 0;",
      "                    }  ",
      "            } ",
      "            else ",
      "                xWantedSize = 0;",
      "                 * one of adequate size is found. */",
      "                 * was not found. */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/224",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/224: 403 Client Error: Forbidden for url: https://api.github.com/repos/FreeRTOS/FreeRTOS-Kernel/pulls/224",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0  \n\nThe patch addresses a potential integer overflow in the heap allocation function, which could lead to security vulnerabilities. The changes implement overflow checks, consistent with the described vulnerability."
}