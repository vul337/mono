{
  "cve_id": "CVE-2018-20360",
  "cwe_ids": [
    "CWE-119",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "specrec: better handle unexpected PS\n\nParametric Stereo (PS) can arrive at any moment in input files. PS\nchanges the number of output channels and therefore requires more\nallocated memory in various structures from hDecoder.\n\nThe current faad2 code attempts to perform allocation surgery in\nhDecoder to recover from this. This works well when there is only one\nframe channel, else it creates large number of memory corruption\nissues.\n\nIf there is more than one input channel, return cleanly with error\ncode. It would be nice to handle this, but this is likely to be a lot\nof work and is beyond the scope of a security fix.\n\nThis commit addresses CVE-2018-20360 and CVE-2018-20199 (fixes #32,\nfixes #24).",
  "commit_hash": "3b80a57483a6bc822d3ce3cc640fa81737a87c54",
  "git_url": "https://github.com/knik0/faad2/commit/3b80a57483a6bc822d3ce3cc640fa81737a87c54",
  "file_path": "libfaad/specrec.c",
  "func_name": "reconstruct_single_channel",
  "func_before": "uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \"suddenly\" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency */\n\n        /* this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        /* reset the allocation */\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n\n        //return 21;\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func_before": "uint8_t reconstruct_single_channel(NeAACDecStruct *VAR_0, ic_stream *VAR_1,\n                                   element *VAR_2, int16_t *VAR_3)\n{\n    uint8_t VAR_4;\n    int VAR_5;\n    ALIGN VAR_6 VAR_7[1024];\n\n#ifdef VAR_8\n    int64_t VAR_9 = faad_get_ts();\n#endif\n\n\n    /* COMMENT_0 */\n#if ( (defined(VAR_10) && defined(VAR_11)) )\n    VAR_5 = 2;\n#elif defined(VAR_12)\n    if (VAR_0->ps_used[VAR_0->fr_ch_ele])\n        VAR_5 = 2;\n    else\n        VAR_5 = 1;\n#else\n    VAR_5 = 1;\n#endif\n\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n    {\n        /* COMMENT_1 */\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n    } else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != VAR_5) {\n        /* COMMENT_2 */\n\n        /* COMMENT_3 */\n                                                             \n           \n\n        /* COMMENT_6 */\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 0;\n\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n\n        /* COMMENT_7 */\n    }\n\n    if (VAR_0->element_alloced[VAR_0->fr_ch_ele] == 0)\n    {\n        VAR_4 = allocate_single_channel(VAR_0, VAR_2->channel, VAR_5);\n        if (VAR_4 > 0)\n            return VAR_4;\n\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 1;\n    }\n\n\n    /* COMMENT_8 */\n    VAR_4 = quant_to_spec(VAR_0, VAR_1, VAR_3, VAR_7, VAR_0->frameLength);\n    if (VAR_4 > 0)\n        return VAR_4;\n\n#ifdef VAR_8\n    VAR_9 = faad_get_ts() - VAR_9;\n    VAR_0->requant_cycles += VAR_9;\n#endif\n\n\n    /* COMMENT_9 */\n    pns_decode(VAR_1, NULL, VAR_7, NULL, VAR_0->frameLength, 0, VAR_0->object_type,\n        &(VAR_0->__r1), &(VAR_0->__r2));\n\n#ifdef VAR_13\n    /* COMMENT_10 */\n    if (VAR_0->object_type == VAR_14)\n    {\n\t\tif (!VAR_0->pred_stat[VAR_2->channel])\n\t\t\treturn 33;\n\n        /* COMMENT_11 */\n        ic_prediction(VAR_1, VAR_7, VAR_0->pred_stat[VAR_2->channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n\n        /* COMMENT_12 */\n                                                             \n                                                         \n          \n        pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_2->channel]);\n    }\n#endif\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n#ifdef VAR_16\n        if (VAR_0->object_type == VAR_17)\n        {\n            if (VAR_1->ltp.data_present)\n            {\n                if (VAR_1->ltp.lag_update)\n                    VAR_0->ltp_lag[VAR_2->channel] = VAR_1->ltp.lag;\n            }\n            VAR_1->ltp.lag = VAR_0->ltp_lag[VAR_2->channel];\n        }\n#endif\n\n        /* COMMENT_16 */\n        lt_prediction(VAR_1, &(VAR_1->ltp), VAR_7, VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->fb,\n            VAR_1->window_shape, VAR_0->window_shape_prev[VAR_2->channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_17 */\n    tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_7, VAR_0->frameLength);\n\n    /* COMMENT_18 */\n    if (VAR_0->drc->present)\n    {\n        if (!VAR_0->drc->exclude_mask[VAR_2->channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_7);\n    }\n\n    /* COMMENT_19 */\n#ifdef VAR_18\n    if (VAR_0->object_type != VAR_19)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7,\n            VAR_0->time_out[VAR_2->channel], VAR_0->fb_intermed[VAR_2->channel],\n            VAR_0->object_type, VAR_0->frameLength);\n#ifdef VAR_18\n    } else {\n        ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7, VAR_0->time_out[VAR_2->channel],\n            VAR_0->ssr_overlap[VAR_2->channel], VAR_0->ipqf_buffer[VAR_2->channel], VAR_0->prev_fmd[VAR_2->channel],\n            VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_20 */\n    VAR_0->window_shape_prev[VAR_2->channel] = VAR_1->window_shape;\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        lt_update_state(VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->time_out[VAR_2->channel],\n            VAR_0->fb_intermed[VAR_2->channel], VAR_0->frameLength, VAR_0->object_type);\n    }\n#endif\n\n#ifdef VAR_20\n    if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n\n        /* COMMENT_21 */\n        if (VAR_0->sbr[VAR_21] == NULL)\n        {\n            VAR_0->sbr[VAR_21] = sbrDecodeInit(VAR_0->frameLength,\n                VAR_0->element_id[VAR_21], 2*get_sample_rate(VAR_0->sf_index),\n                VAR_0->downSampledSBR\n#ifdef VAR_10\n                , 0\n#endif\n                );\n        }\n\n        if (VAR_2->ics1.window_sequence == VAR_23)\n            VAR_0->sbr[VAR_21]->maxAACLine = 8*min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n        else\n            VAR_0->sbr[VAR_21]->maxAACLine = min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n\n        /* COMMENT_22 */\n#if (defined(VAR_12) || defined(VAR_11))\n        if (VAR_0->ps_used[VAR_21] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);\n#if (defined(VAR_12) || defined(VAR_11))\n        } else {\n            VAR_4 = sbrDecodeSingleFramePS(VAR_0->sbr[VAR_21], VAR_0->time_out[VAR_22],\n                VAR_0->time_out[VAR_22+1], VAR_0->postSeekResetFlag,\n                VAR_0->downSampledSBR);\n        }\n#endif\n        if (VAR_4 > 0)\n            return VAR_4;\n    } else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* COMMENT_23 */\n#if (defined(VAR_12) || defined(VAR_11))\n    if ((VAR_0->ps_used[VAR_0->fr_ch_ele] == 0) &&\n        (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2))\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n        int VAR_24 = (VAR_0->sbr_alloced[VAR_21]) ? 2 : 1;\n        VAR_24 *= VAR_0->frameLength*sizeof(VAR_6);\n\n        memcpy(VAR_0->time_out[VAR_22+1], VAR_0->time_out[VAR_22], VAR_24);\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path_before": "knik0/faad2/3b80a57483a6bc822d3ce3cc640fa81737a87c54/specrec.c/vul/before/0.json",
  "func": "uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \"suddenly\" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency\n         * this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        if (hDecoder->fr_channels == 1) {\n            /* reset the allocation */\n            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n        } else {\n            return 21;\n        }\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func": "uint8_t reconstruct_single_channel(NeAACDecStruct *VAR_0, ic_stream *VAR_1,\n                                   element *VAR_2, int16_t *VAR_3)\n{\n    uint8_t VAR_4;\n    int VAR_5;\n    ALIGN VAR_6 VAR_7[1024];\n\n#ifdef VAR_8\n    int64_t VAR_9 = faad_get_ts();\n#endif\n\n\n    /* COMMENT_0 */\n#if ( (defined(VAR_10) && defined(VAR_11)) )\n    VAR_5 = 2;\n#elif defined(VAR_12)\n    if (VAR_0->ps_used[VAR_0->fr_ch_ele])\n        VAR_5 = 2;\n    else\n        VAR_5 = 1;\n#else\n    VAR_5 = 1;\n#endif\n\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n    {\n        /* COMMENT_1 */\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n    } else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != VAR_5) {\n        /* COMMENT_2 */\n                                                                               \n                                                             \n           \n\n        if (VAR_0->fr_channels == 1) {\n            /* COMMENT_6 */\n            VAR_0->element_alloced[VAR_0->fr_ch_ele] = 0;\n            VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n        } else {\n            return 21;\n        }\n    }\n\n    if (VAR_0->element_alloced[VAR_0->fr_ch_ele] == 0)\n    {\n        VAR_4 = allocate_single_channel(VAR_0, VAR_2->channel, VAR_5);\n        if (VAR_4 > 0)\n            return VAR_4;\n\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 1;\n    }\n\n\n    /* COMMENT_7 */\n    VAR_4 = quant_to_spec(VAR_0, VAR_1, VAR_3, VAR_7, VAR_0->frameLength);\n    if (VAR_4 > 0)\n        return VAR_4;\n\n#ifdef VAR_8\n    VAR_9 = faad_get_ts() - VAR_9;\n    VAR_0->requant_cycles += VAR_9;\n#endif\n\n\n    /* COMMENT_8 */\n    pns_decode(VAR_1, NULL, VAR_7, NULL, VAR_0->frameLength, 0, VAR_0->object_type,\n        &(VAR_0->__r1), &(VAR_0->__r2));\n\n#ifdef VAR_13\n    /* COMMENT_9 */\n    if (VAR_0->object_type == VAR_14)\n    {\n\t\tif (!VAR_0->pred_stat[VAR_2->channel])\n\t\t\treturn 33;\n\n        /* COMMENT_10 */\n        ic_prediction(VAR_1, VAR_7, VAR_0->pred_stat[VAR_2->channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n\n        /* COMMENT_11 */\n                                                             \n                                                         \n          \n        pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_2->channel]);\n    }\n#endif\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n#ifdef VAR_16\n        if (VAR_0->object_type == VAR_17)\n        {\n            if (VAR_1->ltp.data_present)\n            {\n                if (VAR_1->ltp.lag_update)\n                    VAR_0->ltp_lag[VAR_2->channel] = VAR_1->ltp.lag;\n            }\n            VAR_1->ltp.lag = VAR_0->ltp_lag[VAR_2->channel];\n        }\n#endif\n\n        /* COMMENT_15 */\n        lt_prediction(VAR_1, &(VAR_1->ltp), VAR_7, VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->fb,\n            VAR_1->window_shape, VAR_0->window_shape_prev[VAR_2->channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_16 */\n    tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_7, VAR_0->frameLength);\n\n    /* COMMENT_17 */\n    if (VAR_0->drc->present)\n    {\n        if (!VAR_0->drc->exclude_mask[VAR_2->channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_7);\n    }\n\n    /* COMMENT_18 */\n#ifdef VAR_18\n    if (VAR_0->object_type != VAR_19)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7,\n            VAR_0->time_out[VAR_2->channel], VAR_0->fb_intermed[VAR_2->channel],\n            VAR_0->object_type, VAR_0->frameLength);\n#ifdef VAR_18\n    } else {\n        ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7, VAR_0->time_out[VAR_2->channel],\n            VAR_0->ssr_overlap[VAR_2->channel], VAR_0->ipqf_buffer[VAR_2->channel], VAR_0->prev_fmd[VAR_2->channel],\n            VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_19 */\n    VAR_0->window_shape_prev[VAR_2->channel] = VAR_1->window_shape;\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        lt_update_state(VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->time_out[VAR_2->channel],\n            VAR_0->fb_intermed[VAR_2->channel], VAR_0->frameLength, VAR_0->object_type);\n    }\n#endif\n\n#ifdef VAR_20\n    if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n\n        /* COMMENT_20 */\n        if (VAR_0->sbr[VAR_21] == NULL)\n        {\n            VAR_0->sbr[VAR_21] = sbrDecodeInit(VAR_0->frameLength,\n                VAR_0->element_id[VAR_21], 2*get_sample_rate(VAR_0->sf_index),\n                VAR_0->downSampledSBR\n#ifdef VAR_10\n                , 0\n#endif\n                );\n        }\n\n        if (VAR_2->ics1.window_sequence == VAR_23)\n            VAR_0->sbr[VAR_21]->maxAACLine = 8*min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n        else\n            VAR_0->sbr[VAR_21]->maxAACLine = min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n\n        /* COMMENT_21 */\n#if (defined(VAR_12) || defined(VAR_11))\n        if (VAR_0->ps_used[VAR_21] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);\n#if (defined(VAR_12) || defined(VAR_11))\n        } else {\n            VAR_4 = sbrDecodeSingleFramePS(VAR_0->sbr[VAR_21], VAR_0->time_out[VAR_22],\n                VAR_0->time_out[VAR_22+1], VAR_0->postSeekResetFlag,\n                VAR_0->downSampledSBR);\n        }\n#endif\n        if (VAR_4 > 0)\n            return VAR_4;\n    } else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* COMMENT_22 */\n#if (defined(VAR_12) || defined(VAR_11))\n    if ((VAR_0->ps_used[VAR_0->fr_ch_ele] == 0) &&\n        (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2))\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n        int VAR_24 = (VAR_0->sbr_alloced[VAR_21]) ? 2 : 1;\n        VAR_24 *= VAR_0->frameLength*sizeof(VAR_6);\n\n        memcpy(VAR_0->time_out[VAR_22+1], VAR_0->time_out[VAR_22], VAR_24);\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path": "knik0/faad2/3b80a57483a6bc822d3ce3cc640fa81737a87c54/specrec.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,18 +27,18 @@\n         /* element_output_channels not set yet */\n         hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n     } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n-        /* element inconsistency */\n-\n-        /* this only happens if PS is actually found but not in the first frame\n+        /* element inconsistency\n+         * this only happens if PS is actually found but not in the first frame\n          * this means that there is only 1 bitstream element!\n          */\n \n-        /* reset the allocation */\n-        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n-\n-        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n-\n-        //return 21;\n+        if (hDecoder->fr_channels == 1) {\n+            /* reset the allocation */\n+            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n+            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n+        } else {\n+            return 21;\n+        }\n     }\n \n     if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)",
  "diff_line_info": {
    "deleted_lines": [
      "        /* element inconsistency */",
      "",
      "        /* this only happens if PS is actually found but not in the first frame",
      "        /* reset the allocation */",
      "        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;",
      "",
      "        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;",
      "",
      "        //return 21;"
    ],
    "added_lines": [
      "        /* element inconsistency",
      "         * this only happens if PS is actually found but not in the first frame",
      "        if (hDecoder->fr_channels == 1) {",
      "            /* reset the allocation */",
      "            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;",
      "            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;",
      "        } else {",
      "            return 21;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/38",
  "description": {
    "pr_info": {
      "title": "specrec: better handle unexpected PS (CVE-2018-20360/CVE-2018-20199)",
      "number": 38
    },
    "comment": [
      "Parametric Stereo (PS) can arrive at any moment in input files. PS changes the number of output channels and therefore requires more allocated memory in various structures from hDecoder.\r\n\r\nThe current faad2 code attempts to perform allocation surgery in hDecoder to recover from this. This works well when there is only one frame channel, else it creates large number of memory corruption issues.\r\n\r\nIf there is more than one input channel, return cleanly with error code. It would be nice to handle this, but this is likely to be a lot of work and is beyond the scope of a security fix.\r\n\r\nThis commit addresses CVE-2018-20360 and CVE-2018-20199 (fixes #32, fixes #24).",
      "Please, do not merge this right now, I'd like to make a second review of my code a bit later :-)",
      "Alright, I am waiting for your \"go!\". :+1: ",
      "I had a second look at \"specrec: better handle unexpected PS\", looks fine to me.\r\n\r\nI have pushed a new fix \"ps_dec: sanitize iid_index before mixing\" which addresses #39 (CVE-2019-6956). This is the best I can do with my current knowledge of the standard. It fixes the issue, and I don't expect it to break anything which was already working before.\r\n\r\nIt would be great if you could have a look at it before merging :)",
      "Thanks for that! Now there is not much left to fix, I guess. :grin: ",
      "> Thanks for that! Now there is not much left to fix, I guess.\r\n\r\nGreat ! I'm glad to hear that ! :)\r\n\r\nFabian, are you planning to prepare a Debian testing upload? I will upload a jessie update shortly and will coordinate with the security team for stretch and buster fixes.",
      "> Fabian, are you planning to prepare a Debian testing upload? I will upload a jessie update shortly and will coordinate with the security team for stretch and buster fixes.\r\n\r\nHonestly, no, I didn't have such plans. My idea was to wait until the dust has settled a bit, tag a new release in this repository and upload that to Debian unstable.\r\n",
      "> Honestly, no, I didn't have such plans. My idea was to wait until the dust has settled a bit, tag a new release in this repository and upload that to Debian unstable.\r\n\r\nWell, I don't see clear benefits in waiting, at least in the jessie/stretch/buster cases. I'd like to see some of these issues fixed in Jessie (the stack buffer overflow in particular), and if I am not mistaken the security team also wants to release a DSA (at least they have a dsa-needed entry for faad2, I will discuss it again with them).\r\n\r\nIf you need help, I can provide a NMU for unstable, featuring targeted patches, until you push a new release.",
      "> If you need help, I can provide a NMU for unstable, featuring targeted patches, until you push a new release.\r\n\r\nYes, please, that would be highly appreciated!\r\n",
      "> > If you need help, I can provide a NMU for unstable, featuring targeted patches, until you push a new release.\r\n> \r\n> Yes, please, that would be highly appreciated!\r\n\r\nGreat, I have prepared a NMU, see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=914641 :)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message and vulnerability description reference specific CVEs (CVE-2018-20360 and CVE-2018-20199), indicating the patch is intended to fix security issues related to memory corruption.\n\n2. **Consistency Check:** The code changes match the description. The function modifies how memory allocation is handled when Parametric Stereo is detected, preventing corruption when multiple channels are present.\n\n3. **Purpose Evaluation:** The intent is to fix a security issue by preventing memory corruption in specific error conditions.\n\n4. **Security Assessment:** The patch addresses known vulnerabilities (CVEs) and corrects a memory management issue, making it a security fix.\n\n5. **Confidence Score:** High confidence due to explicit CVE references and clear alignment between description and code changes."
}