{
  "cve_id": "CVE-2021-42073",
  "cwe_ids": [
    "CWE-384"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "debauchee/barrier",
  "commit_msg": "Implement client identity verification\n\nThis commit fixes two security vulnerabilities: CVE-2021-42072 and\nCVE-2021-42073.\n\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
  "commit_hash": "229abab99f39f11624e5651f819e7f1f8eddedcc",
  "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
  "file_path": "src/lib/client/Client.cpp",
  "func_name": "Client::connect",
  "func_before": "void\nClient::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n    }\n\n    try {\n        // resolve the server hostname.  do this every time we connect\n        // in case we couldn't resolve the address earlier or the address\n        // has changed (which can happen frequently if this is a laptop\n        // being shuttled between various networks).  patch by Brent\n        // Priddy.\n        m_serverAddress.resolve();\n\n        // m_serverAddress will be null if the hostname address is not reolved\n        if (m_serverAddress.getAddress() != NULL) {\n          // to help users troubleshoot, show server host name (issue: 60)\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n\n        // create the socket\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n\n        // filter socket messages, including a packetizing filter\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n\n        // connect\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}",
  "abstract_func_before": "void\nClient::connect()\n{\n    if (VAR_0 != NULL) {\n        return;\n    }\n    if (VAR_1) {\n        VAR_2 = true;\n        return;\n    }\n\n    auto VAR_3 = ConnectionSecurityLevel::PLAINTEXT;\n    if (VAR_4) {\n        VAR_3 = ConnectionSecurityLevel::ENCRYPTED;\n    }\n\n    try {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        VAR_5.resolve();\n\n        /* COMMENT_5 */\n        if (VAR_5.getAddress() != NULL) {\n          /* COMMENT_6 */\n          LOG((VAR_6 \"connecting to '%s': %s:%i\",\n          VAR_5.getHostname().c_str(),\n          VAR_7->addrToString(VAR_5.getAddress()).c_str(),\n          VAR_5.getPort()));\n        }\n\n        /* COMMENT_7 */\n        IDataSocket* VAR_8 = VAR_9->create(VAR_7->getAddrFamily(VAR_5.getAddress()),\n                                                      VAR_3);\n        VAR_10 = VAR_11<TCPSocket*>(VAR_8);\n\n        /* COMMENT_8 */\n        VAR_0 = VAR_8;\n        VAR_0 = new PacketStreamFilter(VAR_12, VAR_0, true);\n\n        /* COMMENT_9 */\n        LOG((VAR_13 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        VAR_8->connect(VAR_5);\n    }\n    catch (XBase& VAR_14) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((VAR_13 \"connection failed\"));\n        sendConnectionFailedEvent(VAR_14.what());\n        return;\n    }\n}",
  "func_graph_path_before": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/Client.cpp/vul/before/0.json",
  "func": "void\nClient::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        // client always authenticates server\n        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n    }\n\n    try {\n        // resolve the server hostname.  do this every time we connect\n        // in case we couldn't resolve the address earlier or the address\n        // has changed (which can happen frequently if this is a laptop\n        // being shuttled between various networks).  patch by Brent\n        // Priddy.\n        m_serverAddress.resolve();\n\n        // m_serverAddress will be null if the hostname address is not reolved\n        if (m_serverAddress.getAddress() != NULL) {\n          // to help users troubleshoot, show server host name (issue: 60)\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n\n        // create the socket\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n\n        // filter socket messages, including a packetizing filter\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n\n        // connect\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}",
  "abstract_func": "void\nClient::connect()\n{\n    if (VAR_0 != NULL) {\n        return;\n    }\n    if (VAR_1) {\n        VAR_2 = true;\n        return;\n    }\n\n    auto VAR_3 = ConnectionSecurityLevel::PLAINTEXT;\n    if (VAR_4) {\n        /* COMMENT_0 */\n        VAR_3 = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n    }\n\n    try {\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        VAR_5.resolve();\n\n        /* COMMENT_6 */\n        if (VAR_5.getAddress() != NULL) {\n          /* COMMENT_7 */\n          LOG((VAR_6 \"connecting to '%s': %s:%i\",\n          VAR_5.getHostname().c_str(),\n          VAR_7->addrToString(VAR_5.getAddress()).c_str(),\n          VAR_5.getPort()));\n        }\n\n        /* COMMENT_8 */\n        IDataSocket* VAR_8 = VAR_9->create(VAR_7->getAddrFamily(VAR_5.getAddress()),\n                                                      VAR_3);\n        VAR_10 = VAR_11<TCPSocket*>(VAR_8);\n\n        /* COMMENT_9 */\n        VAR_0 = VAR_8;\n        VAR_0 = new PacketStreamFilter(VAR_12, VAR_0, true);\n\n        /* COMMENT_10 */\n        LOG((VAR_13 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        VAR_8->connect(VAR_5);\n    }\n    catch (XBase& VAR_14) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((VAR_13 \"connection failed\"));\n        sendConnectionFailedEvent(VAR_14.what());\n        return;\n    }\n}",
  "func_graph_path": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/Client.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,8 @@\n \n     auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n     if (m_useSecureNetwork) {\n-        security_level = ConnectionSecurityLevel::ENCRYPTED;\n+        // client always authenticates server\n+        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n     }\n \n     try {",
  "diff_line_info": {
    "deleted_lines": [
      "        security_level = ConnectionSecurityLevel::ENCRYPTED;"
    ],
    "added_lines": [
      "        // client always authenticates server",
      "        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/debauchee/barrier/pull/1346",
  "description": {
    "pr_info": {
      "title": "Implement client identity verification [SECURITY VULNERABILITIES CVE-2021-42072, CVE-2021-42073]",
      "number": 1346
    },
    "comment": [
      "This PR implements client identity verification. Essentially server gets the same process of accepting and rejecting clients like the clients can accept or reject the server. This is important because even though the client can't move the mouse on the server, it can still receive input and potentially set the clipboard.\r\n\r\nThis PR fixes the following security vulnerabilities:\r\n\r\n - CVE-2021-42072 server does not verify client identity (certificate fingerprint)\r\n - CVE-2021-42073 By guessing/listening in on valid client names server clipboard content can be manipulated.\r\n\r\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de> @mgerstner. Matthias also provided insights into how best to fix the issues, precise reproduction steps and any used tools and made the maintainer's life as pleasant as possible. Thank you!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0**"
}