{
  "cve_id": "CVE-2021-32687",
  "cwe_ids": [
    "CWE-190",
    "CWE-680"
  ],
  "cvss_vector": "AV:N/AC:M/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix Integer overflow issue with intsets (CVE-2021-32687)\n\nThe vulnerability involves changing the default set-max-intset-entries\nconfiguration parameter to a very large value and constructing specially\ncrafted commands to manipulate sets",
  "commit_hash": "a30d367a71b7017581cf1ca104242a3c644dec0f",
  "git_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
  "file_path": "src/t_set.c",
  "func_name": "setTypeAdd",
  "func_before": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
  "abstract_func_before": "int setTypeAdd(robj *VAR_0, sds VAR_1) {\n    long long VAR_2;\n    if (VAR_0->encoding == VAR_3) {\n        dict *VAR_4 = VAR_0->ptr;\n        dictEntry *VAR_5 = dictAddRaw(VAR_4,VAR_1,NULL);\n        if (VAR_5) {\n            dictSetKey(VAR_4,VAR_5,sdsdup(VAR_1));\n            dictSetVal(VAR_4,VAR_5,NULL);\n            return 1;\n        }\n    } else if (VAR_0->encoding == VAR_6) {\n        if (isSdsRepresentableAsLongLong(VAR_1,&VAR_2) == VAR_7) {\n            uint8_t VAR_8 = 0;\n            VAR_0->ptr = intsetAdd(VAR_0->ptr,VAR_2,&VAR_8);\n            if (VAR_8) {\n                /* COMMENT_0 */\n                                       \n                if (intsetLen(VAR_0->ptr) > VAR_9.set_max_intset_entries)\n                    setTypeConvert(VAR_0,VAR_3);\n                return 1;\n            }\n        } else {\n            /* COMMENT_2 */\n            setTypeConvert(VAR_0,VAR_3);\n\n            /* COMMENT_3 */\n                                                           \n            serverAssert(dictAdd(VAR_0->ptr,sdsdup(VAR_1),NULL) == VAR_10);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
  "func_graph_path_before": "redis/a30d367a71b7017581cf1ca104242a3c644dec0f/t_set.c/vul/before/0.json",
  "func": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                size_t max_entries = server.set_max_intset_entries;\n                /* limit to 1G entries due to intset internals. */\n                if (max_entries >= 1<<30) max_entries = 1<<30;\n                if (intsetLen(subject->ptr) > max_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
  "abstract_func": "int setTypeAdd(robj *VAR_0, sds VAR_1) {\n    long long VAR_2;\n    if (VAR_0->encoding == VAR_3) {\n        dict *VAR_4 = VAR_0->ptr;\n        dictEntry *VAR_5 = dictAddRaw(VAR_4,VAR_1,NULL);\n        if (VAR_5) {\n            dictSetKey(VAR_4,VAR_5,sdsdup(VAR_1));\n            dictSetVal(VAR_4,VAR_5,NULL);\n            return 1;\n        }\n    } else if (VAR_0->encoding == VAR_6) {\n        if (isSdsRepresentableAsLongLong(VAR_1,&VAR_2) == VAR_7) {\n            uint8_t VAR_8 = 0;\n            VAR_0->ptr = intsetAdd(VAR_0->ptr,VAR_2,&VAR_8);\n            if (VAR_8) {\n                /* COMMENT_0 */\n                                       \n                size_t VAR_9 = VAR_10.set_max_intset_entries;\n                /* COMMENT_2 */\n                if (VAR_9 >= 1<<30) VAR_9 = 1<<30;\n                if (intsetLen(VAR_0->ptr) > VAR_9)\n                    setTypeConvert(VAR_0,VAR_3);\n                return 1;\n            }\n        } else {\n            /* COMMENT_3 */\n            setTypeConvert(VAR_0,VAR_3);\n\n            /* COMMENT_4 */\n                                                           \n            serverAssert(dictAdd(VAR_0->ptr,sdsdup(VAR_1),NULL) == VAR_11);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
  "func_graph_path": "redis/a30d367a71b7017581cf1ca104242a3c644dec0f/t_set.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,10 @@\n             if (success) {\n                 /* Convert to regular set when the intset contains\n                  * too many entries. */\n-                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n+                size_t max_entries = server.set_max_intset_entries;\n+                /* limit to 1G entries due to intset internals. */\n+                if (max_entries >= 1<<30) max_entries = 1<<30;\n+                if (intsetLen(subject->ptr) > max_entries)\n                     setTypeConvert(subject,OBJ_ENCODING_HT);\n                 return 1;\n             }",
  "diff_line_info": {
    "deleted_lines": [
      "                if (intsetLen(subject->ptr) > server.set_max_intset_entries)"
    ],
    "added_lines": [
      "                size_t max_entries = server.set_max_intset_entries;",
      "                /* limit to 1G entries due to intset internals. */",
      "                if (max_entries >= 1<<30) max_entries = 1<<30;",
      "                if (intsetLen(subject->ptr) > max_entries)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}