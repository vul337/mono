{
  "cve_id": "CVE-2016-10129",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",
  "commit_hash": "2fdef641fd0dd2828bd948234ae86de75221a11a",
  "git_url": "https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a",
  "file_path": "src/transports/smart_pkt.c",
  "func_name": "git_pkt_parse_line",
  "func_before": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
  "abstract_func_before": "int git_pkt_parse_line(\n\tgit_pkt **VAR_0, const char *VAR_1, const char **VAR_2, size_t VAR_3)\n{\n\tint VAR_4;\n\tint32_t VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_3 > 0 && VAR_3 < VAR_6)\n\t\treturn VAR_7;\n\n\tVAR_5 = parse_len(VAR_1);\n\tif (VAR_5 < 0) {\n\t\t/* COMMENT_1 */\n                                                            \n                                                      \n     \n\t\tif (VAR_3 >= 4 && !git__prefixcmp(VAR_1, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*VAR_2 = VAR_1;\n\t\t\treturn pack_pkt(VAR_0);\n\t\t}\n\n\t\treturn (int)VAR_5;\n\t}\n\n\t/* COMMENT_5 */\n                                                             \n                                             \n    \n\tif (VAR_3 > 0 && VAR_3 < (size_t)VAR_5)\n\t\treturn VAR_7;\n\n\t/* COMMENT_9 */\n                                                     \n                                                       \n                                                         \n    \n\tif (VAR_5 != 0 && VAR_5 < VAR_6)\n\t\treturn VAR_8;\n\n\tVAR_1 += VAR_6;\n\t/* COMMENT_14 */\n                                                                   \n         \n    \n\tif (VAR_5 == VAR_6) {\n\t\t*VAR_0 = NULL;\n\t\t*VAR_2 = VAR_1;\n\t\treturn 0;\n\t}\n\n\tif (VAR_5 == 0) { /* COMMENT_18 */\n\t\t*VAR_2 = VAR_1;\n\t\treturn flush_pkt(VAR_0);\n\t}\n\n\tVAR_5 -= VAR_6; /* COMMENT_19 */\n\n\tif (*VAR_1 == VAR_9)\n\t\tVAR_4 = data_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (*VAR_1 == VAR_10)\n\t\tVAR_4 = sideband_progress_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (*VAR_1 == VAR_11)\n\t\tVAR_4 = sideband_error_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"ACK\"))\n\t\tVAR_4 = ack_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"NAK\"))\n\t\tVAR_4 = nak_pkt(VAR_0);\n\telse if (!git__prefixcmp(VAR_1, \"ERR \"))\n\t\tVAR_4 = err_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (*VAR_1 == '#')\n\t\tVAR_4 = comment_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"ok\"))\n\t\tVAR_4 = ok_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"ng\"))\n\t\tVAR_4 = ng_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"unpack\"))\n\t\tVAR_4 = unpack_pkt(VAR_0, VAR_1, VAR_5);\n\telse\n\t\tVAR_4 = ref_pkt(VAR_0, VAR_1, VAR_5);\n\n\t*VAR_2 = VAR_1 + VAR_5;\n\n\treturn VAR_4;\n}",
  "func_graph_path_before": "libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a/smart_pkt.c/vul/before/0.json",
  "func": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}",
  "abstract_func": "int git_pkt_parse_line(\n\tgit_pkt **VAR_0, const char *VAR_1, const char **VAR_2, size_t VAR_3)\n{\n\tint VAR_4;\n\tint32_t VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_3 > 0 && VAR_3 < VAR_6)\n\t\treturn VAR_7;\n\n\tVAR_5 = parse_len(VAR_1);\n\tif (VAR_5 < 0) {\n\t\t/* COMMENT_1 */\n                                                            \n                                                      \n     \n\t\tif (VAR_3 >= 4 && !git__prefixcmp(VAR_1, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*VAR_2 = VAR_1;\n\t\t\treturn pack_pkt(VAR_0);\n\t\t}\n\n\t\treturn (int)VAR_5;\n\t}\n\n\t/* COMMENT_5 */\n                                                             \n                                             \n    \n\tif (VAR_3 > 0 && VAR_3 < (size_t)VAR_5)\n\t\treturn VAR_7;\n\n\t/* COMMENT_9 */\n                                                     \n                                                       \n                                                         \n    \n\tif (VAR_5 != 0 && VAR_5 < VAR_6)\n\t\treturn VAR_8;\n\n\tVAR_1 += VAR_6;\n\t/* COMMENT_14 */\n                                                         \n                                                         \n                                                     \n    \n\tif (VAR_5 == VAR_6) {\n\t\tgiterr_set_str(VAR_9, \"Invalid empty packet\");\n\t\treturn VAR_8;\n\t}\n\n\tif (VAR_5 == 0) { /* COMMENT_19 */\n\t\t*VAR_2 = VAR_1;\n\t\treturn flush_pkt(VAR_0);\n\t}\n\n\tVAR_5 -= VAR_6; /* COMMENT_20 */\n\n\tif (*VAR_1 == VAR_10)\n\t\tVAR_4 = data_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (*VAR_1 == VAR_11)\n\t\tVAR_4 = sideband_progress_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (*VAR_1 == VAR_12)\n\t\tVAR_4 = sideband_error_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"ACK\"))\n\t\tVAR_4 = ack_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"NAK\"))\n\t\tVAR_4 = nak_pkt(VAR_0);\n\telse if (!git__prefixcmp(VAR_1, \"ERR \"))\n\t\tVAR_4 = err_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (*VAR_1 == '#')\n\t\tVAR_4 = comment_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"ok\"))\n\t\tVAR_4 = ok_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"ng\"))\n\t\tVAR_4 = ng_pkt(VAR_0, VAR_1, VAR_5);\n\telse if (!git__prefixcmp(VAR_1, \"unpack\"))\n\t\tVAR_4 = unpack_pkt(VAR_0, VAR_1, VAR_5);\n\telse\n\t\tVAR_4 = ref_pkt(VAR_0, VAR_1, VAR_5);\n\n\t*VAR_2 = VAR_1 + VAR_5;\n\n\treturn VAR_4;\n}",
  "func_graph_path": "libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a/smart_pkt.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -40,13 +40,13 @@\n \n \tline += PKT_LEN_SIZE;\n \t/*\n-\t * TODO: How do we deal with empty lines? Try again? with the next\n-\t * line?\n+\t * The Git protocol does not specify empty lines as part\n+\t * of the protocol. Not knowing what to do with an empty\n+\t * line, we should return an error upon hitting one.\n \t */\n \tif (len == PKT_LEN_SIZE) {\n-\t\t*head = NULL;\n-\t\t*out = line;\n-\t\treturn 0;\n+\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n+\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { /* Flush pkt */",
  "diff_line_info": {
    "deleted_lines": [
      "\t * TODO: How do we deal with empty lines? Try again? with the next",
      "\t * line?",
      "\t\t*head = NULL;",
      "\t\t*out = line;",
      "\t\treturn 0;"
    ],
    "added_lines": [
      "\t * The Git protocol does not specify empty lines as part",
      "\t * of the protocol. Not knowing what to do with an empty",
      "\t * line, we should return an error upon hitting one.",
      "\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");",
      "\t\treturn GIT_ERROR;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4076",
  "description": {
    "pr_info": {
      "title": "security updates for v0.25",
      "number": 4076
    },
    "comment": [
      "This fixes a buffer boundary check error and a certificate validity check which can be bogus under certain conditions."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}