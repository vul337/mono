{
  "cve_id": "CVE-2020-22218",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "libssh2",
  "commit_msg": "fix use-of-uninitialized-value\n\nreturn error if malloc(0)",
  "commit_hash": "41533173d27140400a17c49314efde6df54abdeb",
  "git_url": "https://github.com/libssh2/libssh2/commit/41533173d27140400a17c49314efde6df54abdeb",
  "file_path": "src/transport.c",
  "func_name": "_libssh2_transport_read",
  "func_before": "int _libssh2_transport_read(LIBSSH2_SESSION * session)\n{\n    int rc;\n    struct transportpacket *p = &session->packet;\n    int remainbuf;\n    int remainpack;\n    int numbytes;\n    int numdecrypt;\n    unsigned char block[MAX_BLOCKSIZE];\n    int blocksize;\n    int encrypted = 1;\n\n    /* default clear the bit */\n    session->socket_block_directions &= ~LIBSSH2_SESSION_BLOCK_INBOUND;\n\n    /*\n     * All channels, systems, subsystems, etc eventually make it down here\n     * when looking for more incoming data. If a key exchange is going on\n     * (LIBSSH2_STATE_EXCHANGING_KEYS bit is set) then the remote end will\n     * ONLY send key exchange related traffic. In non-blocking mode, there is\n     * a chance to break out of the kex_exchange function with an EAGAIN\n     * status, and never come back to it. If LIBSSH2_STATE_EXCHANGING_KEYS is\n     * active, then we must redirect to the key exchange. However, if\n     * kex_exchange is active (as in it is the one that calls this execution\n     * of packet_read, then don't redirect, as that would be an infinite loop!\n     */\n\n    if(session->state & LIBSSH2_STATE_EXCHANGING_KEYS &&\n        !(session->state & LIBSSH2_STATE_KEX_ACTIVE)) {\n\n        /* Whoever wants a packet won't get anything until the key re-exchange\n         * is done!\n         */\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Redirecting into the\"\n                       \" key re-exchange from _libssh2_transport_read\");\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc)\n            return rc;\n    }\n\n    /*\n     * =============================== NOTE ===============================\n     * I know this is very ugly and not a really good use of \"goto\", but\n     * this case statement would be even uglier to do it any other way\n     */\n    if(session->readPack_state == libssh2_NB_state_jump1) {\n        session->readPack_state = libssh2_NB_state_idle;\n        encrypted = session->readPack_encrypted;\n        goto libssh2_transport_read_point1;\n    }\n\n    do {\n        if(session->socket_state == LIBSSH2_SOCKET_DISCONNECTED) {\n            return LIBSSH2_ERROR_NONE;\n        }\n\n        if(session->state & LIBSSH2_STATE_NEWKEYS) {\n            blocksize = session->remote.crypt->blocksize;\n        }\n        else {\n            encrypted = 0;      /* not encrypted */\n            blocksize = 5;      /* not strictly true, but we can use 5 here to\n                                   make the checks below work fine still */\n        }\n\n        /* read/use a whole big chunk into a temporary area stored in\n           the LIBSSH2_SESSION struct. We will decrypt data from that\n           buffer into the packet buffer so this temp one doesn't have\n           to be able to keep a whole SSH packet, just be large enough\n           so that we can read big chunks from the network layer. */\n\n        /* how much data there is remaining in the buffer to deal with\n           before we should read more from the network */\n        remainbuf = p->writeidx - p->readidx;\n\n        /* if remainbuf turns negative we have a bad internal error */\n        assert(remainbuf >= 0);\n\n        if(remainbuf < blocksize) {\n            /* If we have less than a blocksize left, it is too\n               little data to deal with, read more */\n            ssize_t nread;\n\n            /* move any remainder to the start of the buffer so\n               that we can do a full refill */\n            if(remainbuf) {\n                memmove(p->buf, &p->buf[p->readidx], remainbuf);\n                p->readidx = 0;\n                p->writeidx = remainbuf;\n            }\n            else {\n                /* nothing to move, just zero the indexes */\n                p->readidx = p->writeidx = 0;\n            }\n\n            /* now read a big chunk from the network into the temp buffer */\n            nread =\n                LIBSSH2_RECV(session, &p->buf[remainbuf],\n                              PACKETBUFSIZE - remainbuf,\n                              LIBSSH2_SOCKET_RECV_FLAGS(session));\n            if(nread <= 0) {\n                /* check if this is due to EAGAIN and return the special\n                   return code if so, error out normally otherwise */\n                if((nread < 0) && (nread == -EAGAIN)) {\n                    session->socket_block_directions |=\n                        LIBSSH2_SESSION_BLOCK_INBOUND;\n                    return LIBSSH2_ERROR_EAGAIN;\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\n                               \"Error recving %d bytes (got %d)\",\n                               PACKETBUFSIZE - remainbuf, -nread);\n                return LIBSSH2_ERROR_SOCKET_RECV;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\n                           \"Recved %d/%d bytes to %p+%d\", nread,\n                           PACKETBUFSIZE - remainbuf, p->buf, remainbuf);\n\n            debugdump(session, \"libssh2_transport_read() raw\",\n                      &p->buf[remainbuf], nread);\n            /* advance write pointer */\n            p->writeidx += nread;\n\n            /* update remainbuf counter */\n            remainbuf = p->writeidx - p->readidx;\n        }\n\n        /* how much data to deal with from the buffer */\n        numbytes = remainbuf;\n\n        if(!p->total_num) {\n            size_t total_num;\n\n            /* No payload package area allocated yet. To know the\n               size of this payload, we need to decrypt the first\n               blocksize data. */\n\n            if(numbytes < blocksize) {\n                /* we can't act on anything less than blocksize, but this\n                   check is only done for the initial block since once we have\n                   got the start of a block we can in fact deal with fractions\n                */\n                session->socket_block_directions |=\n                    LIBSSH2_SESSION_BLOCK_INBOUND;\n                return LIBSSH2_ERROR_EAGAIN;\n            }\n\n            if(encrypted) {\n                rc = decrypt(session, &p->buf[p->readidx], block, blocksize);\n                if(rc != LIBSSH2_ERROR_NONE) {\n                    return rc;\n                }\n                /* save the first 5 bytes of the decrypted package, to be\n                   used in the hash calculation later down. */\n                memcpy(p->init, block, 5);\n            }\n            else {\n                /* the data is plain, just copy it verbatim to\n                   the working block buffer */\n                memcpy(block, &p->buf[p->readidx], blocksize);\n            }\n\n            /* advance the read pointer */\n            p->readidx += blocksize;\n\n            /* we now have the initial blocksize bytes decrypted,\n             * and we can extract packet and padding length from it\n             */\n            p->packet_length = _libssh2_ntohu32(block);\n            if(p->packet_length < 1) {\n                return LIBSSH2_ERROR_DECRYPT;\n            }\n            else if(p->packet_length > LIBSSH2_PACKET_MAXPAYLOAD) {\n                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n            }\n\n            p->padding_length = block[4];\n            if(p->padding_length > p->packet_length - 1) {\n                return LIBSSH2_ERROR_DECRYPT;\n            }\n\n\n            /* total_num is the number of bytes following the initial\n               (5 bytes) packet length and padding length fields */\n            total_num =\n                p->packet_length - 1 +\n                (encrypted ? session->remote.mac->mac_len : 0);\n\n            /* RFC4253 section 6.1 Maximum Packet Length says:\n             *\n             * \"All implementations MUST be able to process\n             * packets with uncompressed payload length of 32768\n             * bytes or less and total packet size of 35000 bytes\n             * or less (including length, padding length, payload,\n             * padding, and MAC.).\"\n             */\n            if(total_num > LIBSSH2_PACKET_MAXPAYLOAD) {\n                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n            }\n\n            /* Get a packet handle put data into. We get one to\n               hold all data, including padding and MAC. */\n            p->payload = LIBSSH2_ALLOC(session, total_num);\n            if(!p->payload) {\n                return LIBSSH2_ERROR_ALLOC;\n            }\n            p->total_num = total_num;\n            /* init write pointer to start of payload buffer */\n            p->wptr = p->payload;\n\n            if(blocksize > 5) {\n                /* copy the data from index 5 to the end of\n                   the blocksize from the temporary buffer to\n                   the start of the decrypted buffer */\n                if(blocksize - 5 <= (int) total_num) {\n                    memcpy(p->wptr, &block[5], blocksize - 5);\n                    p->wptr += blocksize - 5;       /* advance write pointer */\n                }\n                else {\n                    return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n                }\n            }\n\n            /* init the data_num field to the number of bytes of\n               the package read so far */\n            p->data_num = p->wptr - p->payload;\n\n            /* we already dealt with a blocksize worth of data */\n            numbytes -= blocksize;\n        }\n\n        /* how much there is left to add to the current payload\n           package */\n        remainpack = p->total_num - p->data_num;\n\n        if(numbytes > remainpack) {\n            /* if we have more data in the buffer than what is going into this\n               particular packet, we limit this round to this packet only */\n            numbytes = remainpack;\n        }\n\n        if(encrypted) {\n            /* At the end of the incoming stream, there is a MAC,\n               and we don't want to decrypt that since we need it\n               \"raw\". We MUST however decrypt the padding data\n               since it is used for the hash later on. */\n            int skip = session->remote.mac->mac_len;\n\n            /* if what we have plus numbytes is bigger than the\n               total minus the skip margin, we should lower the\n               amount to decrypt even more */\n            if((p->data_num + numbytes) > (p->total_num - skip)) {\n                numdecrypt = (p->total_num - skip) - p->data_num;\n            }\n            else {\n                int frac;\n                numdecrypt = numbytes;\n                frac = numdecrypt % blocksize;\n                if(frac) {\n                    /* not an aligned amount of blocks,\n                       align it */\n                    numdecrypt -= frac;\n                    /* and make it no unencrypted data\n                       after it */\n                    numbytes = 0;\n                }\n            }\n        }\n        else {\n            /* unencrypted data should not be decrypted at all */\n            numdecrypt = 0;\n        }\n\n        /* if there are bytes to decrypt, do that */\n        if(numdecrypt > 0) {\n            /* now decrypt the lot */\n            rc = decrypt(session, &p->buf[p->readidx], p->wptr, numdecrypt);\n            if(rc != LIBSSH2_ERROR_NONE) {\n                p->total_num = 0;   /* no packet buffer available */\n                return rc;\n            }\n\n            /* advance the read pointer */\n            p->readidx += numdecrypt;\n            /* advance write pointer */\n            p->wptr += numdecrypt;\n            /* increase data_num */\n            p->data_num += numdecrypt;\n\n            /* bytes left to take care of without decryption */\n            numbytes -= numdecrypt;\n        }\n\n        /* if there are bytes to copy that aren't decrypted, simply\n           copy them as-is to the target buffer */\n        if(numbytes > 0) {\n\n            if(numbytes <= (int)(p->total_num - (p->wptr - p->payload))) {\n                memcpy(p->wptr, &p->buf[p->readidx], numbytes);\n            }\n            else {\n                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n            }\n\n            /* advance the read pointer */\n            p->readidx += numbytes;\n            /* advance write pointer */\n            p->wptr += numbytes;\n            /* increase data_num */\n            p->data_num += numbytes;\n        }\n\n        /* now check how much data there's left to read to finish the\n           current packet */\n        remainpack = p->total_num - p->data_num;\n\n        if(!remainpack) {\n            /* we have a full packet */\n          libssh2_transport_read_point1:\n            rc = fullpacket(session, encrypted);\n            if(rc == LIBSSH2_ERROR_EAGAIN) {\n\n                if(session->packAdd_state != libssh2_NB_state_idle) {\n                    /* fullpacket only returns LIBSSH2_ERROR_EAGAIN if\n                     * libssh2_packet_add returns LIBSSH2_ERROR_EAGAIN. If\n                     * that returns LIBSSH2_ERROR_EAGAIN but the packAdd_state\n                     * is idle, then the packet has been added to the brigade,\n                     * but some immediate action that was taken based on the\n                     * packet type (such as key re-exchange) is not yet\n                     * complete.  Clear the way for a new packet to be read\n                     * in.\n                     */\n                    session->readPack_encrypted = encrypted;\n                    session->readPack_state = libssh2_NB_state_jump1;\n                }\n\n                return rc;\n            }\n\n            p->total_num = 0;   /* no packet buffer available */\n\n            return rc;\n        }\n    } while(1);                /* loop */\n\n    return LIBSSH2_ERROR_SOCKET_RECV; /* we never reach this point */\n}",
  "abstract_func_before": "int _libssh2_transport_read(LIBSSH2_SESSION * VAR_0)\n{\n    int VAR_1;\n    struct transportpacket *VAR_2 = &VAR_0->packet;\n    int VAR_3;\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    unsigned char VAR_7[VAR_8];\n    int VAR_9;\n    int VAR_10 = 1;\n\n    /* COMMENT_0 */\n    VAR_0->socket_block_directions &= ~VAR_11;\n\n    /* COMMENT_1 */\n                                                                          \n                                                                         \n                                                                          \n                                                                             \n                                                                        \n                                                                             \n                                                                     \n                                                                            \n                                                                              \n       \n\n    if(VAR_0->state & VAR_12 &&\n        !(VAR_0->state & VAR_13)) {\n\n        /* COMMENT_12 */\n                   \n           \n        _libssh2_debug(VAR_0, VAR_14, \"Redirecting into the\"\n                       \" key re-exchange from _libssh2_transport_read\");\n        VAR_1 = _libssh2_kex_exchange(VAR_0, 1, &VAR_0->startup_key_state);\n        if(VAR_1)\n            return VAR_1;\n    }\n\n    /* COMMENT_15 */\n                                                                           \n                                                                        \n                                                                      \n       \n    if(VAR_0->readPack_state == VAR_15) {\n        VAR_0->readPack_state = VAR_16;\n        VAR_10 = VAR_0->readPack_encrypted;\n        goto libssh2_transport_read_point1;\n    }\n\n    do {\n        if(VAR_0->socket_state == VAR_17) {\n            return VAR_18;\n        }\n\n        if(VAR_0->state & VAR_19) {\n            VAR_9 = VAR_0->remote.crypt->blocksize;\n        }\n        else {\n            VAR_10 = 0;      /* COMMENT_20 */\n            VAR_9 = 5;      /* COMMENT_21 */\n                                                                           \n        }\n\n        /* COMMENT_23 */\n                                                                     \n                                                                      \n                                                                      \n                                                                    \n\n        /* COMMENT_28 */\n                                                         \n        VAR_3 = VAR_2->writeidx - VAR_2->readidx;\n\n        /* COMMENT_30 */\n        assert(VAR_3 >= 0);\n\n        if(VAR_3 < VAR_9) {\n            /* COMMENT_31 */\n                                                     \n            ssize_t VAR_20;\n\n            /* COMMENT_33 */\n                                              \n            if(VAR_3) {\n                memmove(VAR_2->buf, &VAR_2->buf[VAR_2->readidx], VAR_3);\n                VAR_2->readidx = 0;\n                VAR_2->writeidx = VAR_3;\n            }\n            else {\n                /* COMMENT_35 */\n                VAR_2->readidx = VAR_2->writeidx = 0;\n            }\n\n            /* COMMENT_36 */\n            VAR_20 =\n                LIBSSH2_RECV(VAR_0, &VAR_2->buf[VAR_3],\n                              VAR_21 - VAR_3,\n                              LIBSSH2_SOCKET_RECV_FLAGS(VAR_0));\n            if(VAR_20 <= 0) {\n                /* COMMENT_37 */\n                                                                     \n                if((VAR_20 < 0) && (VAR_20 == -VAR_22)) {\n                    VAR_0->socket_block_directions |=\n                        VAR_11;\n                    return VAR_23;\n                }\n                _libssh2_debug(VAR_0, VAR_24,\n                               \"Error recving %d bytes (got %d)\",\n                               VAR_21 - VAR_3, -VAR_20);\n                return VAR_25;\n            }\n            _libssh2_debug(VAR_0, VAR_24,\n                           \"Recved %d/%d bytes to %p+%d\", VAR_20,\n                           VAR_21 - VAR_3, VAR_2->buf, VAR_3);\n\n            debugdump(VAR_0, \"libssh2_transport_read() raw\",\n                      &VAR_2->buf[VAR_3], VAR_20);\n            /* COMMENT_39 */\n            VAR_2->writeidx += VAR_20;\n\n            /* COMMENT_40 */\n            VAR_3 = VAR_2->writeidx - VAR_2->readidx;\n        }\n\n        /* COMMENT_41 */\n        VAR_5 = VAR_3;\n\n        if(!VAR_2->total_num) {\n            size_t VAR_26;\n\n            /* COMMENT_42 */\n                                                                 \n                                 \n\n            if(VAR_5 < VAR_9) {\n                /* COMMENT_45 */\n                                                                              \n                                                                              \n                  \n                VAR_0->socket_block_directions |=\n                    VAR_11;\n                return VAR_23;\n            }\n\n            if(VAR_10) {\n                VAR_1 = decrypt(VAR_0, &VAR_2->buf[VAR_2->readidx], VAR_7, VAR_9);\n                if(VAR_1 != VAR_18) {\n                    return VAR_1;\n                }\n                /* COMMENT_49 */\n                                                              \n                memcpy(VAR_2->init, VAR_7, 5);\n            }\n            else {\n                /* COMMENT_51 */\n                                              \n                memcpy(VAR_7, &VAR_2->buf[VAR_2->readidx], VAR_9);\n            }\n\n            /* COMMENT_53 */\n            VAR_2->readidx += VAR_9;\n\n            /* COMMENT_54 */\n                                                                   \n               \n            VAR_2->packet_length = _libssh2_ntohu32(VAR_7);\n            if(VAR_2->packet_length < 1) {\n                return VAR_27;\n            }\n            else if(VAR_2->packet_length > VAR_28) {\n                return VAR_29;\n            }\n\n            VAR_2->padding_length = VAR_7[4];\n            if(VAR_2->padding_length > VAR_2->packet_length - 1) {\n                return VAR_27;\n            }\n\n\n            /* COMMENT_57 */\n                                                                   \n            VAR_26 =\n                VAR_2->packet_length - 1 +\n                (VAR_10 ? VAR_0->remote.mac->mac_len : 0);\n\n            /* COMMENT_59 */\n              \n                                                           \n                                                                \n                                                                 \n                                                                  \n                                   \n               \n            if(VAR_26 > VAR_28) {\n                return VAR_29;\n            }\n\n            /* COMMENT_67 */\n                                                           \n            VAR_2->payload = LIBSSH2_ALLOC(VAR_0, VAR_26);\n            if(!VAR_2->payload) {\n                return VAR_30;\n            }\n            VAR_2->total_num = VAR_26;\n            /* COMMENT_69 */\n            VAR_2->wptr = VAR_2->payload;\n\n            if(VAR_9 > 5) {\n                /* COMMENT_70 */\n                                                             \n                                                       \n                if(VAR_9 - 5 <= (int) VAR_26) {\n                    memcpy(VAR_2->wptr, &VAR_7[5], VAR_9 - 5);\n                    VAR_2->wptr += VAR_9 - 5;       /* COMMENT_39 */\n                }\n                else {\n                    return VAR_29;\n                }\n            }\n\n            /* COMMENT_73 */\n                                         \n            VAR_2->data_num = VAR_2->wptr - VAR_2->payload;\n\n            /* COMMENT_75 */\n            VAR_5 -= VAR_9;\n        }\n\n        /* COMMENT_76 */\n                     \n        VAR_4 = VAR_2->total_num - VAR_2->data_num;\n\n        if(VAR_5 > VAR_4) {\n            /* COMMENT_78 */\n                                                                            \n            VAR_5 = VAR_4;\n        }\n\n        if(VAR_10) {\n            /* COMMENT_80 */\n                                                                 \n                                                              \n                                                         \n            int VAR_31 = VAR_0->remote.mac->mac_len;\n\n            /* COMMENT_84 */\n                                                               \n                                             \n            if((VAR_2->data_num + VAR_5) > (VAR_2->total_num - VAR_31)) {\n                VAR_6 = (VAR_2->total_num - VAR_31) - VAR_2->data_num;\n            }\n            else {\n                int VAR_32;\n                VAR_6 = VAR_5;\n                VAR_32 = VAR_6 % VAR_9;\n                if(VAR_32) {\n                    /* COMMENT_87 */\n                                  \n                    VAR_6 -= VAR_32;\n                    /* COMMENT_89 */\n                                  \n                    VAR_5 = 0;\n                }\n            }\n        }\n        else {\n            /* COMMENT_91 */\n            VAR_6 = 0;\n        }\n\n        /* COMMENT_92 */\n        if(VAR_6 > 0) {\n            /* COMMENT_93 */\n            VAR_1 = decrypt(VAR_0, &VAR_2->buf[VAR_2->readidx], VAR_2->wptr, VAR_6);\n            if(VAR_1 != VAR_18) {\n                VAR_2->total_num = 0;   /* COMMENT_94 */\n                return VAR_1;\n            }\n\n            /* COMMENT_53 */\n            VAR_2->readidx += VAR_6;\n            /* COMMENT_39 */\n            VAR_2->wptr += VAR_6;\n            /* COMMENT_95 */\n            VAR_2->data_num += VAR_6;\n\n            /* COMMENT_96 */\n            VAR_5 -= VAR_6;\n        }\n\n        /* COMMENT_97 */\n                                                  \n        if(VAR_5 > 0) {\n\n            if(VAR_5 <= (int)(VAR_2->total_num - (VAR_2->wptr - VAR_2->payload))) {\n                memcpy(VAR_2->wptr, &VAR_2->buf[VAR_2->readidx], VAR_5);\n            }\n            else {\n                return VAR_29;\n            }\n\n            /* COMMENT_53 */\n            VAR_2->readidx += VAR_5;\n            /* COMMENT_39 */\n            VAR_2->wptr += VAR_5;\n            /* COMMENT_95 */\n            VAR_2->data_num += VAR_5;\n        }\n\n        /* COMMENT_99 */\n                            \n        VAR_4 = VAR_2->total_num - VAR_2->data_num;\n\n        if(!VAR_4) {\n            /* COMMENT_101 */\n          libssh2_transport_read_point1:\n            VAR_1 = fullpacket(VAR_0, VAR_10);\n            if(VAR_1 == VAR_23) {\n\n                if(VAR_0->packAdd_state != VAR_16) {\n                    /* COMMENT_102 */\n                                                                          \n                                                                              \n                                                                              \n                                                                            \n                                                                       \n                                                                           \n                          \n                       \n                    VAR_0->readPack_encrypted = VAR_10;\n                    VAR_0->readPack_state = VAR_15;\n                }\n\n                return VAR_1;\n            }\n\n            VAR_2->total_num = 0;   /* COMMENT_94 */\n\n            return VAR_1;\n        }\n    } while(1);                /* COMMENT_111 */\n\n    return VAR_25; /* COMMENT_112 */\n}",
  "func_graph_path_before": "libssh2/41533173d27140400a17c49314efde6df54abdeb/transport.c/vul/before/0.json",
  "func": "int _libssh2_transport_read(LIBSSH2_SESSION * session)\n{\n    int rc;\n    struct transportpacket *p = &session->packet;\n    int remainbuf;\n    int remainpack;\n    int numbytes;\n    int numdecrypt;\n    unsigned char block[MAX_BLOCKSIZE];\n    int blocksize;\n    int encrypted = 1;\n\n    /* default clear the bit */\n    session->socket_block_directions &= ~LIBSSH2_SESSION_BLOCK_INBOUND;\n\n    /*\n     * All channels, systems, subsystems, etc eventually make it down here\n     * when looking for more incoming data. If a key exchange is going on\n     * (LIBSSH2_STATE_EXCHANGING_KEYS bit is set) then the remote end will\n     * ONLY send key exchange related traffic. In non-blocking mode, there is\n     * a chance to break out of the kex_exchange function with an EAGAIN\n     * status, and never come back to it. If LIBSSH2_STATE_EXCHANGING_KEYS is\n     * active, then we must redirect to the key exchange. However, if\n     * kex_exchange is active (as in it is the one that calls this execution\n     * of packet_read, then don't redirect, as that would be an infinite loop!\n     */\n\n    if(session->state & LIBSSH2_STATE_EXCHANGING_KEYS &&\n        !(session->state & LIBSSH2_STATE_KEX_ACTIVE)) {\n\n        /* Whoever wants a packet won't get anything until the key re-exchange\n         * is done!\n         */\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Redirecting into the\"\n                       \" key re-exchange from _libssh2_transport_read\");\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc)\n            return rc;\n    }\n\n    /*\n     * =============================== NOTE ===============================\n     * I know this is very ugly and not a really good use of \"goto\", but\n     * this case statement would be even uglier to do it any other way\n     */\n    if(session->readPack_state == libssh2_NB_state_jump1) {\n        session->readPack_state = libssh2_NB_state_idle;\n        encrypted = session->readPack_encrypted;\n        goto libssh2_transport_read_point1;\n    }\n\n    do {\n        if(session->socket_state == LIBSSH2_SOCKET_DISCONNECTED) {\n            return LIBSSH2_ERROR_NONE;\n        }\n\n        if(session->state & LIBSSH2_STATE_NEWKEYS) {\n            blocksize = session->remote.crypt->blocksize;\n        }\n        else {\n            encrypted = 0;      /* not encrypted */\n            blocksize = 5;      /* not strictly true, but we can use 5 here to\n                                   make the checks below work fine still */\n        }\n\n        /* read/use a whole big chunk into a temporary area stored in\n           the LIBSSH2_SESSION struct. We will decrypt data from that\n           buffer into the packet buffer so this temp one doesn't have\n           to be able to keep a whole SSH packet, just be large enough\n           so that we can read big chunks from the network layer. */\n\n        /* how much data there is remaining in the buffer to deal with\n           before we should read more from the network */\n        remainbuf = p->writeidx - p->readidx;\n\n        /* if remainbuf turns negative we have a bad internal error */\n        assert(remainbuf >= 0);\n\n        if(remainbuf < blocksize) {\n            /* If we have less than a blocksize left, it is too\n               little data to deal with, read more */\n            ssize_t nread;\n\n            /* move any remainder to the start of the buffer so\n               that we can do a full refill */\n            if(remainbuf) {\n                memmove(p->buf, &p->buf[p->readidx], remainbuf);\n                p->readidx = 0;\n                p->writeidx = remainbuf;\n            }\n            else {\n                /* nothing to move, just zero the indexes */\n                p->readidx = p->writeidx = 0;\n            }\n\n            /* now read a big chunk from the network into the temp buffer */\n            nread =\n                LIBSSH2_RECV(session, &p->buf[remainbuf],\n                              PACKETBUFSIZE - remainbuf,\n                              LIBSSH2_SOCKET_RECV_FLAGS(session));\n            if(nread <= 0) {\n                /* check if this is due to EAGAIN and return the special\n                   return code if so, error out normally otherwise */\n                if((nread < 0) && (nread == -EAGAIN)) {\n                    session->socket_block_directions |=\n                        LIBSSH2_SESSION_BLOCK_INBOUND;\n                    return LIBSSH2_ERROR_EAGAIN;\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\n                               \"Error recving %d bytes (got %d)\",\n                               PACKETBUFSIZE - remainbuf, -nread);\n                return LIBSSH2_ERROR_SOCKET_RECV;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_SOCKET,\n                           \"Recved %d/%d bytes to %p+%d\", nread,\n                           PACKETBUFSIZE - remainbuf, p->buf, remainbuf);\n\n            debugdump(session, \"libssh2_transport_read() raw\",\n                      &p->buf[remainbuf], nread);\n            /* advance write pointer */\n            p->writeidx += nread;\n\n            /* update remainbuf counter */\n            remainbuf = p->writeidx - p->readidx;\n        }\n\n        /* how much data to deal with from the buffer */\n        numbytes = remainbuf;\n\n        if(!p->total_num) {\n            size_t total_num;\n\n            /* No payload package area allocated yet. To know the\n               size of this payload, we need to decrypt the first\n               blocksize data. */\n\n            if(numbytes < blocksize) {\n                /* we can't act on anything less than blocksize, but this\n                   check is only done for the initial block since once we have\n                   got the start of a block we can in fact deal with fractions\n                */\n                session->socket_block_directions |=\n                    LIBSSH2_SESSION_BLOCK_INBOUND;\n                return LIBSSH2_ERROR_EAGAIN;\n            }\n\n            if(encrypted) {\n                rc = decrypt(session, &p->buf[p->readidx], block, blocksize);\n                if(rc != LIBSSH2_ERROR_NONE) {\n                    return rc;\n                }\n                /* save the first 5 bytes of the decrypted package, to be\n                   used in the hash calculation later down. */\n                memcpy(p->init, block, 5);\n            }\n            else {\n                /* the data is plain, just copy it verbatim to\n                   the working block buffer */\n                memcpy(block, &p->buf[p->readidx], blocksize);\n            }\n\n            /* advance the read pointer */\n            p->readidx += blocksize;\n\n            /* we now have the initial blocksize bytes decrypted,\n             * and we can extract packet and padding length from it\n             */\n            p->packet_length = _libssh2_ntohu32(block);\n            if(p->packet_length < 1) {\n                return LIBSSH2_ERROR_DECRYPT;\n            }\n            else if(p->packet_length > LIBSSH2_PACKET_MAXPAYLOAD) {\n                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n            }\n\n            p->padding_length = block[4];\n            if(p->padding_length > p->packet_length - 1) {\n                return LIBSSH2_ERROR_DECRYPT;\n            }\n\n\n            /* total_num is the number of bytes following the initial\n               (5 bytes) packet length and padding length fields */\n            total_num =\n                p->packet_length - 1 +\n                (encrypted ? session->remote.mac->mac_len : 0);\n\n            /* RFC4253 section 6.1 Maximum Packet Length says:\n             *\n             * \"All implementations MUST be able to process\n             * packets with uncompressed payload length of 32768\n             * bytes or less and total packet size of 35000 bytes\n             * or less (including length, padding length, payload,\n             * padding, and MAC.).\"\n             */\n            if(total_num > LIBSSH2_PACKET_MAXPAYLOAD) {\n                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n            }\n\n            /* Get a packet handle put data into. We get one to\n               hold all data, including padding and MAC. */\n            p->payload = LIBSSH2_ALLOC(session, total_num);\n            if(total_num == 0 || !p->payload) {\n                return LIBSSH2_ERROR_ALLOC;\n            }\n            p->total_num = total_num;\n            /* init write pointer to start of payload buffer */\n            p->wptr = p->payload;\n\n            if(blocksize > 5) {\n                /* copy the data from index 5 to the end of\n                   the blocksize from the temporary buffer to\n                   the start of the decrypted buffer */\n                if(blocksize - 5 <= (int) total_num) {\n                    memcpy(p->wptr, &block[5], blocksize - 5);\n                    p->wptr += blocksize - 5;       /* advance write pointer */\n                }\n                else {\n                    return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n                }\n            }\n\n            /* init the data_num field to the number of bytes of\n               the package read so far */\n            p->data_num = p->wptr - p->payload;\n\n            /* we already dealt with a blocksize worth of data */\n            numbytes -= blocksize;\n        }\n\n        /* how much there is left to add to the current payload\n           package */\n        remainpack = p->total_num - p->data_num;\n\n        if(numbytes > remainpack) {\n            /* if we have more data in the buffer than what is going into this\n               particular packet, we limit this round to this packet only */\n            numbytes = remainpack;\n        }\n\n        if(encrypted) {\n            /* At the end of the incoming stream, there is a MAC,\n               and we don't want to decrypt that since we need it\n               \"raw\". We MUST however decrypt the padding data\n               since it is used for the hash later on. */\n            int skip = session->remote.mac->mac_len;\n\n            /* if what we have plus numbytes is bigger than the\n               total minus the skip margin, we should lower the\n               amount to decrypt even more */\n            if((p->data_num + numbytes) > (p->total_num - skip)) {\n                numdecrypt = (p->total_num - skip) - p->data_num;\n            }\n            else {\n                int frac;\n                numdecrypt = numbytes;\n                frac = numdecrypt % blocksize;\n                if(frac) {\n                    /* not an aligned amount of blocks,\n                       align it */\n                    numdecrypt -= frac;\n                    /* and make it no unencrypted data\n                       after it */\n                    numbytes = 0;\n                }\n            }\n        }\n        else {\n            /* unencrypted data should not be decrypted at all */\n            numdecrypt = 0;\n        }\n\n        /* if there are bytes to decrypt, do that */\n        if(numdecrypt > 0) {\n            /* now decrypt the lot */\n            rc = decrypt(session, &p->buf[p->readidx], p->wptr, numdecrypt);\n            if(rc != LIBSSH2_ERROR_NONE) {\n                p->total_num = 0;   /* no packet buffer available */\n                return rc;\n            }\n\n            /* advance the read pointer */\n            p->readidx += numdecrypt;\n            /* advance write pointer */\n            p->wptr += numdecrypt;\n            /* increase data_num */\n            p->data_num += numdecrypt;\n\n            /* bytes left to take care of without decryption */\n            numbytes -= numdecrypt;\n        }\n\n        /* if there are bytes to copy that aren't decrypted, simply\n           copy them as-is to the target buffer */\n        if(numbytes > 0) {\n\n            if(numbytes <= (int)(p->total_num - (p->wptr - p->payload))) {\n                memcpy(p->wptr, &p->buf[p->readidx], numbytes);\n            }\n            else {\n                return LIBSSH2_ERROR_OUT_OF_BOUNDARY;\n            }\n\n            /* advance the read pointer */\n            p->readidx += numbytes;\n            /* advance write pointer */\n            p->wptr += numbytes;\n            /* increase data_num */\n            p->data_num += numbytes;\n        }\n\n        /* now check how much data there's left to read to finish the\n           current packet */\n        remainpack = p->total_num - p->data_num;\n\n        if(!remainpack) {\n            /* we have a full packet */\n          libssh2_transport_read_point1:\n            rc = fullpacket(session, encrypted);\n            if(rc == LIBSSH2_ERROR_EAGAIN) {\n\n                if(session->packAdd_state != libssh2_NB_state_idle) {\n                    /* fullpacket only returns LIBSSH2_ERROR_EAGAIN if\n                     * libssh2_packet_add returns LIBSSH2_ERROR_EAGAIN. If\n                     * that returns LIBSSH2_ERROR_EAGAIN but the packAdd_state\n                     * is idle, then the packet has been added to the brigade,\n                     * but some immediate action that was taken based on the\n                     * packet type (such as key re-exchange) is not yet\n                     * complete.  Clear the way for a new packet to be read\n                     * in.\n                     */\n                    session->readPack_encrypted = encrypted;\n                    session->readPack_state = libssh2_NB_state_jump1;\n                }\n\n                return rc;\n            }\n\n            p->total_num = 0;   /* no packet buffer available */\n\n            return rc;\n        }\n    } while(1);                /* loop */\n\n    return LIBSSH2_ERROR_SOCKET_RECV; /* we never reach this point */\n}",
  "abstract_func": "int _libssh2_transport_read(LIBSSH2_SESSION * VAR_0)\n{\n    int VAR_1;\n    struct transportpacket *VAR_2 = &VAR_0->packet;\n    int VAR_3;\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    unsigned char VAR_7[VAR_8];\n    int VAR_9;\n    int VAR_10 = 1;\n\n    /* COMMENT_0 */\n    VAR_0->socket_block_directions &= ~VAR_11;\n\n    /* COMMENT_1 */\n                                                                          \n                                                                         \n                                                                          \n                                                                             \n                                                                        \n                                                                             \n                                                                     \n                                                                            \n                                                                              \n       \n\n    if(VAR_0->state & VAR_12 &&\n        !(VAR_0->state & VAR_13)) {\n\n        /* COMMENT_12 */\n                   \n           \n        _libssh2_debug(VAR_0, VAR_14, \"Redirecting into the\"\n                       \" key re-exchange from _libssh2_transport_read\");\n        VAR_1 = _libssh2_kex_exchange(VAR_0, 1, &VAR_0->startup_key_state);\n        if(VAR_1)\n            return VAR_1;\n    }\n\n    /* COMMENT_15 */\n                                                                           \n                                                                        \n                                                                      \n       \n    if(VAR_0->readPack_state == VAR_15) {\n        VAR_0->readPack_state = VAR_16;\n        VAR_10 = VAR_0->readPack_encrypted;\n        goto libssh2_transport_read_point1;\n    }\n\n    do {\n        if(VAR_0->socket_state == VAR_17) {\n            return VAR_18;\n        }\n\n        if(VAR_0->state & VAR_19) {\n            VAR_9 = VAR_0->remote.crypt->blocksize;\n        }\n        else {\n            VAR_10 = 0;      /* COMMENT_20 */\n            VAR_9 = 5;      /* COMMENT_21 */\n                                                                           \n        }\n\n        /* COMMENT_23 */\n                                                                     \n                                                                      \n                                                                      \n                                                                    \n\n        /* COMMENT_28 */\n                                                         \n        VAR_3 = VAR_2->writeidx - VAR_2->readidx;\n\n        /* COMMENT_30 */\n        assert(VAR_3 >= 0);\n\n        if(VAR_3 < VAR_9) {\n            /* COMMENT_31 */\n                                                     \n            ssize_t VAR_20;\n\n            /* COMMENT_33 */\n                                              \n            if(VAR_3) {\n                memmove(VAR_2->buf, &VAR_2->buf[VAR_2->readidx], VAR_3);\n                VAR_2->readidx = 0;\n                VAR_2->writeidx = VAR_3;\n            }\n            else {\n                /* COMMENT_35 */\n                VAR_2->readidx = VAR_2->writeidx = 0;\n            }\n\n            /* COMMENT_36 */\n            VAR_20 =\n                LIBSSH2_RECV(VAR_0, &VAR_2->buf[VAR_3],\n                              VAR_21 - VAR_3,\n                              LIBSSH2_SOCKET_RECV_FLAGS(VAR_0));\n            if(VAR_20 <= 0) {\n                /* COMMENT_37 */\n                                                                     \n                if((VAR_20 < 0) && (VAR_20 == -VAR_22)) {\n                    VAR_0->socket_block_directions |=\n                        VAR_11;\n                    return VAR_23;\n                }\n                _libssh2_debug(VAR_0, VAR_24,\n                               \"Error recving %d bytes (got %d)\",\n                               VAR_21 - VAR_3, -VAR_20);\n                return VAR_25;\n            }\n            _libssh2_debug(VAR_0, VAR_24,\n                           \"Recved %d/%d bytes to %p+%d\", VAR_20,\n                           VAR_21 - VAR_3, VAR_2->buf, VAR_3);\n\n            debugdump(VAR_0, \"libssh2_transport_read() raw\",\n                      &VAR_2->buf[VAR_3], VAR_20);\n            /* COMMENT_39 */\n            VAR_2->writeidx += VAR_20;\n\n            /* COMMENT_40 */\n            VAR_3 = VAR_2->writeidx - VAR_2->readidx;\n        }\n\n        /* COMMENT_41 */\n        VAR_5 = VAR_3;\n\n        if(!VAR_2->total_num) {\n            size_t VAR_26;\n\n            /* COMMENT_42 */\n                                                                 \n                                 \n\n            if(VAR_5 < VAR_9) {\n                /* COMMENT_45 */\n                                                                              \n                                                                              \n                  \n                VAR_0->socket_block_directions |=\n                    VAR_11;\n                return VAR_23;\n            }\n\n            if(VAR_10) {\n                VAR_1 = decrypt(VAR_0, &VAR_2->buf[VAR_2->readidx], VAR_7, VAR_9);\n                if(VAR_1 != VAR_18) {\n                    return VAR_1;\n                }\n                /* COMMENT_49 */\n                                                              \n                memcpy(VAR_2->init, VAR_7, 5);\n            }\n            else {\n                /* COMMENT_51 */\n                                              \n                memcpy(VAR_7, &VAR_2->buf[VAR_2->readidx], VAR_9);\n            }\n\n            /* COMMENT_53 */\n            VAR_2->readidx += VAR_9;\n\n            /* COMMENT_54 */\n                                                                   \n               \n            VAR_2->packet_length = _libssh2_ntohu32(VAR_7);\n            if(VAR_2->packet_length < 1) {\n                return VAR_27;\n            }\n            else if(VAR_2->packet_length > VAR_28) {\n                return VAR_29;\n            }\n\n            VAR_2->padding_length = VAR_7[4];\n            if(VAR_2->padding_length > VAR_2->packet_length - 1) {\n                return VAR_27;\n            }\n\n\n            /* COMMENT_57 */\n                                                                   \n            VAR_26 =\n                VAR_2->packet_length - 1 +\n                (VAR_10 ? VAR_0->remote.mac->mac_len : 0);\n\n            /* COMMENT_59 */\n              \n                                                           \n                                                                \n                                                                 \n                                                                  \n                                   \n               \n            if(VAR_26 > VAR_28) {\n                return VAR_29;\n            }\n\n            /* COMMENT_67 */\n                                                           \n            VAR_2->payload = LIBSSH2_ALLOC(VAR_0, VAR_26);\n            if(VAR_26 == 0 || !VAR_2->payload) {\n                return VAR_30;\n            }\n            VAR_2->total_num = VAR_26;\n            /* COMMENT_69 */\n            VAR_2->wptr = VAR_2->payload;\n\n            if(VAR_9 > 5) {\n                /* COMMENT_70 */\n                                                             \n                                                       \n                if(VAR_9 - 5 <= (int) VAR_26) {\n                    memcpy(VAR_2->wptr, &VAR_7[5], VAR_9 - 5);\n                    VAR_2->wptr += VAR_9 - 5;       /* COMMENT_39 */\n                }\n                else {\n                    return VAR_29;\n                }\n            }\n\n            /* COMMENT_73 */\n                                         \n            VAR_2->data_num = VAR_2->wptr - VAR_2->payload;\n\n            /* COMMENT_75 */\n            VAR_5 -= VAR_9;\n        }\n\n        /* COMMENT_76 */\n                     \n        VAR_4 = VAR_2->total_num - VAR_2->data_num;\n\n        if(VAR_5 > VAR_4) {\n            /* COMMENT_78 */\n                                                                            \n            VAR_5 = VAR_4;\n        }\n\n        if(VAR_10) {\n            /* COMMENT_80 */\n                                                                 \n                                                              \n                                                         \n            int VAR_31 = VAR_0->remote.mac->mac_len;\n\n            /* COMMENT_84 */\n                                                               \n                                             \n            if((VAR_2->data_num + VAR_5) > (VAR_2->total_num - VAR_31)) {\n                VAR_6 = (VAR_2->total_num - VAR_31) - VAR_2->data_num;\n            }\n            else {\n                int VAR_32;\n                VAR_6 = VAR_5;\n                VAR_32 = VAR_6 % VAR_9;\n                if(VAR_32) {\n                    /* COMMENT_87 */\n                                  \n                    VAR_6 -= VAR_32;\n                    /* COMMENT_89 */\n                                  \n                    VAR_5 = 0;\n                }\n            }\n        }\n        else {\n            /* COMMENT_91 */\n            VAR_6 = 0;\n        }\n\n        /* COMMENT_92 */\n        if(VAR_6 > 0) {\n            /* COMMENT_93 */\n            VAR_1 = decrypt(VAR_0, &VAR_2->buf[VAR_2->readidx], VAR_2->wptr, VAR_6);\n            if(VAR_1 != VAR_18) {\n                VAR_2->total_num = 0;   /* COMMENT_94 */\n                return VAR_1;\n            }\n\n            /* COMMENT_53 */\n            VAR_2->readidx += VAR_6;\n            /* COMMENT_39 */\n            VAR_2->wptr += VAR_6;\n            /* COMMENT_95 */\n            VAR_2->data_num += VAR_6;\n\n            /* COMMENT_96 */\n            VAR_5 -= VAR_6;\n        }\n\n        /* COMMENT_97 */\n                                                  \n        if(VAR_5 > 0) {\n\n            if(VAR_5 <= (int)(VAR_2->total_num - (VAR_2->wptr - VAR_2->payload))) {\n                memcpy(VAR_2->wptr, &VAR_2->buf[VAR_2->readidx], VAR_5);\n            }\n            else {\n                return VAR_29;\n            }\n\n            /* COMMENT_53 */\n            VAR_2->readidx += VAR_5;\n            /* COMMENT_39 */\n            VAR_2->wptr += VAR_5;\n            /* COMMENT_95 */\n            VAR_2->data_num += VAR_5;\n        }\n\n        /* COMMENT_99 */\n                            \n        VAR_4 = VAR_2->total_num - VAR_2->data_num;\n\n        if(!VAR_4) {\n            /* COMMENT_101 */\n          libssh2_transport_read_point1:\n            VAR_1 = fullpacket(VAR_0, VAR_10);\n            if(VAR_1 == VAR_23) {\n\n                if(VAR_0->packAdd_state != VAR_16) {\n                    /* COMMENT_102 */\n                                                                          \n                                                                              \n                                                                              \n                                                                            \n                                                                       \n                                                                           \n                          \n                       \n                    VAR_0->readPack_encrypted = VAR_10;\n                    VAR_0->readPack_state = VAR_15;\n                }\n\n                return VAR_1;\n            }\n\n            VAR_2->total_num = 0;   /* COMMENT_94 */\n\n            return VAR_1;\n        }\n    } while(1);                /* COMMENT_111 */\n\n    return VAR_25; /* COMMENT_112 */\n}",
  "func_graph_path": "libssh2/41533173d27140400a17c49314efde6df54abdeb/transport.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -200,7 +200,7 @@\n             /* Get a packet handle put data into. We get one to\n                hold all data, including padding and MAC. */\n             p->payload = LIBSSH2_ALLOC(session, total_num);\n-            if(!p->payload) {\n+            if(total_num == 0 || !p->payload) {\n                 return LIBSSH2_ERROR_ALLOC;\n             }\n             p->total_num = total_num;",
  "diff_line_info": {
    "deleted_lines": [
      "            if(!p->payload) {"
    ],
    "added_lines": [
      "            if(total_num == 0 || !p->payload) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libssh2/libssh2/pull/476",
  "description": {
    "pr_info": {
      "title": "fix use-of-uninitialized-value",
      "number": 476
    },
    "comment": [
      "malloc(0) may not always return NULL, return error if 'total_num = 0' in _libssh2_transport_read in case of 'payload' will be used later",
      "Looks good, thanks!",
      "CVE-2020-22218 was assigned to this, and NVD scored it as \"high\" severity.\r\n\r\nI had not involvement in the assignment. I'm commenting here for reference. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step 1: Input Analysis**  \n- The commit message \"fix use-of-uninitialized-value\" and the description mention handling malloc(0), indicating a potential issue with uninitialized memory.\n- The code diff modifies a condition to check if `total_num` is 0 or if `p->payload` is null, returning an error in such cases.\n\n**Step 2: Consistency Check**  \n- The commit message and diff align in addressing uninitialized value usage by modifying the allocation logic.\n\n**Step 3: Purpose Evaluation**  \n- The change modifies core logic to fix a bug related to memory usage, specifically preventing the use of potentially uninitialized memory.\n\n**Step 4: Security Vulnerability Assessment**  \n- The patch addresses a scenario where `malloc(0)` might not return NULL, which could lead to undefined behavior or security issues. It prevents using uninitialized memory, a security weakness.\n\n**Step 5: Non-Security Classification**  \n- Not applicable since it's identified as a security fix.\n\n**Step 6: Confidence Scoring**  \n- The changes clearly fix a security issue with a direct link to the commit message.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}