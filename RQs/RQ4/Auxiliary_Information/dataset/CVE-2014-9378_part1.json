{
  "cve_id": "CVE-2014-9378",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Ettercap/ettercap",
  "commit_msg": "Fix ignored dn_expand error",
  "commit_hash": "cb7b2028dc03c628aa0a1a5130ca41421ddebcb2",
  "git_url": "https://github.com/Ettercap/ettercap/commit/cb7b2028dc03c628aa0a1a5130ca41421ddebcb2",
  "file_path": "plug-ins/mdns_spoof/mdns_spoof.c",
  "func_name": "mdns_spoof",
  "func_before": "static void mdns_spoof(struct packet_object *po)\n {\n    po->flags |= PO_DROPPED; /* Do not forward query */\n\n    struct mdns_header *mdns;\n    char name[NS_MAXDNAME];\n    int name_len;\n    u_char *q, *data, *end;;\n    u_int16 class;\n    u_int16 type;\n    int x;\n\n    mdns = (struct mdns_header *)po->DATA.data;\n    data = (u_char *)(mdns+1);\n    end = (u_char *)mdns + po->DATA.len;\n\n    q = data;\n\n    if (mdns->flags == 0x8400 || mdns->answer_rrs > 0)\n    {\n        //We only want queries.\n        return;\n    }\n\n    /* process all the questions */\n    for (x = 0; x < mdns->questions; x++) {\n\n      name_len = dn_expand((u_char*)mdns, end, q, name, sizeof(name));\n\n      q = data + name_len;\n\n      if (q >= end || name_len == 0)\n        return;\n\n      NS_GET16(type, q);\n      NS_GET16(class, q);\n\n      /* handle only internet class - unmask the QU flag */\n      if ((class & ~MDNS_QU_FLAG) != ns_c_in)\n         return;\n\n      if(type == ns_t_a) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 10 + 4];\n         u_char *p = answer + name_len;\n         char tmp[MAX_ASCII_ADDR_LEN];\n         \n         /* found the reply in the list */\n         if (get_spoofed_a(name, &reply) != E_SUCCESS)\n            return;\n\n         /* check if the family matches the record type */\n         if (ntohs(reply->addr_type) != AF_INET) {\n            USER_MSG(\"mdns_spoof: can not spoof A record for %s \"\n                     \"because the value is not a IPv4 address\\n\", name);\n            return;\n         }\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);                  /* name */\n         memcpy(p    , \"\\x00\\x01\", 2);                    /* type A */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                    /* cache-flush-bit + class */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* TTL (1 hour) */\n         memcpy(p + 8, \"\\x00\\x04\", 2);                    /* datalen */\n         ip_addr_cpy(p + 10, reply);                      /* data */\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the reply back to the multicast or unicast address \n          * and set the faked address as the source address for the transport\n          */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, sizeof(answer), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", name, type_str(type), ip_addr_ntoa(reply, tmp));\n      }\n      if(type == ns_t_aaaa) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 10 + 16];\n         u_char *p = answer + name_len;\n         char tmp[MAX_ASCII_ADDR_LEN];\n         \n         /* found the reply in the list */\n         if (get_spoofed_aaaa(name, &reply) != E_SUCCESS)\n            return;\n\n         /* check if the family matches the record type */\n         if (ntohs(reply->addr_type) != AF_INET6) {\n            USER_MSG(\"mdns_spoof: can not spoof AAAA record for %s \"\n                     \"because the value is not a IPv6 address\\n\", name);\n            return;\n         }\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);                  /* name */\n         memcpy(p    , \"\\x00\\x1c\", 2);                    /* type AAAA */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                    /* cache-flush-bit + class */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* TTL (1 hour) */\n         memcpy(p + 8, \"\\x00\\x10\", 2);                    /* datalen */\n         ip_addr_cpy(p + 10, reply);                      /* data */\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the reply back to the multicast or unicast address \n          * and set the faked address as the source address for the transport\n          */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, sizeof(answer), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", name, type_str(type), ip_addr_ntoa(reply, tmp));\n       }\n       else if (type == ns_t_ptr) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 256];\n         char *a, *p = (char*)answer + name_len;\n         int rlen;\n         \n         /* found the reply in the list */\n         if (get_spoofed_ptr(name, &a, &reply) != E_SUCCESS)\n            return;\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);                  /* name */\n         memcpy(p    , \"\\x00\\x0c\", 2);                    /* type PTR */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                    /* cache-flush-bit + class */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* TTL (1 hour) */\n         /* compress the string into the buffer */\n         rlen = dn_comp(a, (u_char*)p + 10, 256, NULL, NULL);\n         /* put the length before the dn_comp'd string */\n         p += 8;\n         NS_PUT16(rlen, p);\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the fake reply */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, name_len + 10 + rlen, 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", name, type_str(type), a);\n      }\n      else if (type == ns_t_srv) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 22 + 12 + 16];\n         char *p = (char *)answer + name_len;\n         char tmp[MAX_ASCII_ADDR_LEN];\n         char srvoffset[2];\n         char tgtoffset[2];\n         u_int16 port;\n         int dn_offset = 0;\n\n\n         /* found the reply in the list */\n         if (get_spoofed_srv(name, &reply, &port) != E_SUCCESS) \n            return;\n\n         /*\n          * to refer the target to a proper domain name, we have to strip the\n          * service and protocol label from the questioned domain name\n          */\n         dn_offset += *(data+dn_offset) + 1; /* first label (e.g. _ldap)*/\n         dn_offset += *(data+dn_offset) + 1; /* second label (e.g. _tcp) */\n\n         /* avoid offset overrun */\n         if (dn_offset + 12 > 255) {\n            dn_offset = 0;\n         }\n\n         tgtoffset[0] = 0xc0; /* offset byte */\n         tgtoffset[1] = 12 + dn_offset; /* offset to the actual domain name */\n\n         /*\n          * to inject the spoofed IP address in the additional section, \n          * we have set the offset pointing to the spoofed domain name set \n          * below (in turn, after the domain name [variable length] in the \n          * question section)\n          */\n         srvoffset[0] = 0xc0; /* offset byte */\n         srvoffset[1] = 12 + name_len + 16; /* offset to the answer */\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);              /* name */\n         memcpy(p    , \"\\x00\\x21\", 2);                /* type SRV */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                /* class IN */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);        /* TTL (1 hour) */\n         memcpy(p + 8, \"\\x00\\x0c\", 2);                /* data length */\n         memcpy(p + 10, \"\\x00\\x00\", 2);               /* priority */\n         memcpy(p + 12, \"\\x00\\x00\", 2);               /* weight */\n         p+=14; \n         NS_PUT16(port, p);                           /* port */ \n         p-=16;             \n         /* \n          * add \"srv.\" in front of the stripped domain\n          * name and resolve it in the additional \n          * record (here `srvoffset' is pointing at)\n          */\n         memcpy(p + 16, \"\\x03\\x73\\x72\\x76\", 4);       /* target */\n         memcpy(p + 20, tgtoffset,2);                 /* compressed name offset */\n     \n         /* add the additional record for the spoofed IPv4 address*/\n         if (ntohs(reply->addr_type) == AF_INET) {\n             memcpy(p + 22, srvoffset, 2);            /* compressed name offset */\n             memcpy(p + 24, \"\\x00\\x01\", 2);           /* type A */\n             memcpy(p + 26, \"\\x80\\x01\", 2);           /* class */\n             memcpy(p + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* TTL (1 hour) */\n             memcpy(p + 32, \"\\x00\\x04\", 2);           /* datalen */\n             ip_addr_cpy(p + 34, reply);              /* data */\n             memset(p + 38, 0, 12);                   /* padding */\n         }\n         /* add the additional record for the spoofed IPv6 address*/\n         else if (ntohs(reply->addr_type) == AF_INET6) {\n             memcpy(p + 22, srvoffset, 2);            /* compressed name offset */\n             memcpy(p + 24, \"\\x00\\x1c\", 2);           /* type AAAA */\n             memcpy(p + 26, \"\\x80\\x01\", 2);           /* class */\n             memcpy(p + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* TTL (1 hour) */\n             memcpy(p + 32, \"\\x00\\x10\", 2);           /* datalen */\n             ip_addr_cpy(p + 34, reply);              /* data */\n         }\n         else {\n             /* IP address not valid - abort */\n             return;\n         }\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the reply back to the multicast or unicast address \n          * and set the faked address as the source address for the transport\n          */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, sizeof(answer), 2, 0, 0);\n\n         USER_MSG(\"mdns_spoof: SRV [%s] spoofed to [%s:%d]\\n\", name, ip_addr_ntoa(reply, tmp), port);\n      }\n    }\n\n\n }",
  "abstract_func_before": "static void mdns_spoof(struct packet_object *VAR_0)\n {\n    VAR_0->flags |= VAR_1; /* COMMENT_0 */\n\n    struct mdns_header *VAR_2;\n    char VAR_3[VAR_4];\n    int VAR_5;\n    u_char *VAR_6, *VAR_7, *VAR_8;;\n    u_int16 VAR_9;\n    u_int16 VAR_10;\n    int VAR_11;\n\n    VAR_2 = (struct mdns_header *)VAR_0->DATA.data;\n    VAR_7 = (u_char *)(VAR_2+1);\n    VAR_8 = (u_char *)VAR_2 + VAR_0->DATA.len;\n\n    VAR_6 = VAR_7;\n\n    if (VAR_2->flags == 0x8400 || VAR_2->answer_rrs > 0)\n    {\n        /* COMMENT_1 */\n        return;\n    }\n\n    /* COMMENT_2 */\n    for (VAR_11 = 0; VAR_11 < VAR_2->questions; VAR_11++) {\n\n      VAR_5 = dn_expand((u_char*)VAR_2, VAR_8, VAR_6, VAR_3, sizeof(VAR_3));\n\n      VAR_6 = VAR_7 + VAR_5;\n\n      if (VAR_6 >= VAR_8 || VAR_5 == 0)\n        return;\n\n      NS_GET16(VAR_10, VAR_6);\n      NS_GET16(VAR_9, VAR_6);\n\n      /* COMMENT_3 */\n      if ((VAR_9 & ~VAR_12) != VAR_13)\n         return;\n\n      if(VAR_10 == VAR_14) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 10 + 4];\n         u_char *VAR_20 = VAR_19 + VAR_5;\n         char VAR_21[VAR_22];\n         \n         /* COMMENT_4 */\n         if (get_spoofed_a(VAR_3, &VAR_15) != VAR_23)\n            return;\n\n         /* COMMENT_5 */\n         if (ntohs(VAR_15->addr_type) != VAR_24) {\n            USER_MSG(\"mdns_spoof: can not spoof A record for %s \"\n                     \"because the value is not a IPv4 address\\n\", VAR_3);\n            return;\n         }\n\n        /* COMMENT_6 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);                  /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x01\", 2);                    /* COMMENT_13 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                    /* COMMENT_14 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* COMMENT_15 */\n         memcpy(VAR_20 + 8, \"\\x00\\x04\", 2);                    /* COMMENT_16 */\n         ip_addr_cpy(VAR_20 + 10, VAR_15);                      /* COMMENT_17 */\n\n         /* COMMENT_18 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_24 */\n                                                                             \n            \n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, sizeof(VAR_19), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", VAR_3, type_str(VAR_10), ip_addr_ntoa(VAR_15, VAR_21));\n      }\n      if(VAR_10 == VAR_25) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 10 + 16];\n         u_char *VAR_20 = VAR_19 + VAR_5;\n         char VAR_21[VAR_22];\n         \n         /* COMMENT_4 */\n         if (get_spoofed_aaaa(VAR_3, &VAR_15) != VAR_23)\n            return;\n\n         /* COMMENT_5 */\n         if (ntohs(VAR_15->addr_type) != VAR_26) {\n            USER_MSG(\"mdns_spoof: can not spoof AAAA record for %s \"\n                     \"because the value is not a IPv6 address\\n\", VAR_3);\n            return;\n         }\n\n        /* COMMENT_27 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);                  /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x1c\", 2);                    /* COMMENT_33 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                    /* COMMENT_14 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* COMMENT_15 */\n         memcpy(VAR_20 + 8, \"\\x00\\x10\", 2);                    /* COMMENT_16 */\n         ip_addr_cpy(VAR_20 + 10, VAR_15);                      /* COMMENT_17 */\n\n         /* COMMENT_34 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_40 */\n                                                                             \n            \n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, sizeof(VAR_19), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", VAR_3, type_str(VAR_10), ip_addr_ntoa(VAR_15, VAR_21));\n       }\n       else if (VAR_10 == VAR_27) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 256];\n         char *VAR_28, *VAR_20 = (char*)VAR_19 + VAR_5;\n         int VAR_29;\n         \n         /* COMMENT_4 */\n         if (get_spoofed_ptr(VAR_3, &VAR_28, &VAR_15) != VAR_23)\n            return;\n\n        /* COMMENT_43 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);                  /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x0c\", 2);                    /* COMMENT_49 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                    /* COMMENT_14 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* COMMENT_15 */\n         /* COMMENT_50 */\n         VAR_29 = dn_comp(VAR_28, (u_char*)VAR_20 + 10, 256, NULL, NULL);\n         /* COMMENT_51 */\n         VAR_20 += 8;\n         NS_PUT16(VAR_29, VAR_20);\n\n         /* COMMENT_52 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_58 */\n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, VAR_5 + 10 + VAR_29, 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", VAR_3, type_str(VAR_10), VAR_28);\n      }\n      else if (VAR_10 == VAR_30) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 22 + 12 + 16];\n         char *VAR_20 = (char *)VAR_19 + VAR_5;\n         char VAR_21[VAR_22];\n         char VAR_31[2];\n         char VAR_32[2];\n         u_int16 VAR_33;\n         int VAR_34 = 0;\n\n\n         /* COMMENT_4 */\n         if (get_spoofed_srv(VAR_3, &VAR_15, &VAR_33) != VAR_23) \n            return;\n\n         /* COMMENT_59 */\n                                                                             \n                                                                      \n            \n         VAR_34 += *(VAR_7+VAR_34) + 1; /* COMMENT_63 */\n         VAR_34 += *(VAR_7+VAR_34) + 1; /* COMMENT_64 */\n\n         /* COMMENT_65 */\n         if (VAR_34 + 12 > 255) {\n            VAR_34 = 0;\n         }\n\n         VAR_32[0] = 0xc0; /* COMMENT_66 */\n         VAR_32[1] = 12 + VAR_34; /* COMMENT_67 */\n\n         /* COMMENT_68 */\n                                                                        \n                                                                           \n                                                                           \n                             \n            \n         VAR_31[0] = 0xc0; /* COMMENT_66 */\n         VAR_31[1] = 12 + VAR_5 + 16; /* COMMENT_74 */\n\n        /* COMMENT_75 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);              /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x21\", 2);                /* COMMENT_81 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                /* COMMENT_82 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);        /* COMMENT_15 */\n         memcpy(VAR_20 + 8, \"\\x00\\x0c\", 2);                /* COMMENT_83 */\n         memcpy(VAR_20 + 10, \"\\x00\\x00\", 2);               /* COMMENT_84 */\n         memcpy(VAR_20 + 12, \"\\x00\\x00\", 2);               /* COMMENT_85 */\n         VAR_20+=14; \n         NS_PUT16(VAR_33, VAR_20);                           /* COMMENT_86 */ \n         VAR_20-=16;             \n         /* COMMENT_87 */\n                                                      \n                                                  \n                                                    \n            \n         memcpy(VAR_20 + 16, \"\\x03\\x73\\x72\\x76\", 4);       /* COMMENT_92 */\n         memcpy(VAR_20 + 20, VAR_32,2);                 /* COMMENT_93 */\n     \n         /* COMMENT_94 */\n         if (ntohs(VAR_15->addr_type) == VAR_24) {\n             memcpy(VAR_20 + 22, VAR_31, 2);            /* COMMENT_93 */\n             memcpy(VAR_20 + 24, \"\\x00\\x01\", 2);           /* COMMENT_13 */\n             memcpy(VAR_20 + 26, \"\\x80\\x01\", 2);           /* COMMENT_95 */\n             memcpy(VAR_20 + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* COMMENT_15 */\n             memcpy(VAR_20 + 32, \"\\x00\\x04\", 2);           /* COMMENT_16 */\n             ip_addr_cpy(VAR_20 + 34, VAR_15);              /* COMMENT_17 */\n             memset(VAR_20 + 38, 0, 12);                   /* COMMENT_96 */\n         }\n         /* COMMENT_97 */\n         else if (ntohs(VAR_15->addr_type) == VAR_26) {\n             memcpy(VAR_20 + 22, VAR_31, 2);            /* COMMENT_93 */\n             memcpy(VAR_20 + 24, \"\\x00\\x1c\", 2);           /* COMMENT_33 */\n             memcpy(VAR_20 + 26, \"\\x80\\x01\", 2);           /* COMMENT_95 */\n             memcpy(VAR_20 + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* COMMENT_15 */\n             memcpy(VAR_20 + 32, \"\\x00\\x10\", 2);           /* COMMENT_16 */\n             ip_addr_cpy(VAR_20 + 34, VAR_15);              /* COMMENT_17 */\n         }\n         else {\n             /* COMMENT_98 */\n             return;\n         }\n\n         /* COMMENT_99 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_105 */\n                                                                             \n            \n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, sizeof(VAR_19), 2, 0, 0);\n\n         USER_MSG(\"mdns_spoof: SRV [%s] spoofed to [%s:%d]\\n\", VAR_3, ip_addr_ntoa(VAR_15, VAR_21), VAR_33);\n      }\n    }\n\n\n }",
  "func_graph_path_before": "Ettercap/ettercap/cb7b2028dc03c628aa0a1a5130ca41421ddebcb2/mdns_spoof.c/vul/before/0.json",
  "func": "static void mdns_spoof(struct packet_object *po)\n {\n    po->flags |= PO_DROPPED; /* Do not forward query */\n\n    struct mdns_header *mdns;\n    char name[NS_MAXDNAME];\n    int name_len;\n    u_char *q, *data, *end;;\n    u_int16 class;\n    u_int16 type;\n    int x;\n\n    mdns = (struct mdns_header *)po->DATA.data;\n    data = (u_char *)(mdns+1);\n    end = (u_char *)mdns + po->DATA.len;\n\n    q = data;\n\n    if (mdns->flags == 0x8400 || mdns->answer_rrs > 0)\n    {\n        //We only want queries.\n        return;\n    }\n\n    /* process all the questions */\n    for (x = 0; x < mdns->questions; x++) {\n\n      name_len = dn_expand((u_char*)mdns, end, q, name, sizeof(name));\n      if (name_len == -1)\n          return;\n      q = data + name_len;\n\n      if (q >= end || name_len == 0)\n        return;\n\n      NS_GET16(type, q);\n      NS_GET16(class, q);\n\n      /* handle only internet class - unmask the QU flag */\n      if ((class & ~MDNS_QU_FLAG) != ns_c_in)\n         return;\n\n      if(type == ns_t_a) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 10 + 4];\n         u_char *p = answer + name_len;\n         char tmp[MAX_ASCII_ADDR_LEN];\n         \n         /* found the reply in the list */\n         if (get_spoofed_a(name, &reply) != E_SUCCESS)\n            return;\n\n         /* check if the family matches the record type */\n         if (ntohs(reply->addr_type) != AF_INET) {\n            USER_MSG(\"mdns_spoof: can not spoof A record for %s \"\n                     \"because the value is not a IPv4 address\\n\", name);\n            return;\n         }\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);                  /* name */\n         memcpy(p    , \"\\x00\\x01\", 2);                    /* type A */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                    /* cache-flush-bit + class */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* TTL (1 hour) */\n         memcpy(p + 8, \"\\x00\\x04\", 2);                    /* datalen */\n         ip_addr_cpy(p + 10, reply);                      /* data */\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the reply back to the multicast or unicast address \n          * and set the faked address as the source address for the transport\n          */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, sizeof(answer), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", name, type_str(type), ip_addr_ntoa(reply, tmp));\n      }\n      if(type == ns_t_aaaa) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 10 + 16];\n         u_char *p = answer + name_len;\n         char tmp[MAX_ASCII_ADDR_LEN];\n         \n         /* found the reply in the list */\n         if (get_spoofed_aaaa(name, &reply) != E_SUCCESS)\n            return;\n\n         /* check if the family matches the record type */\n         if (ntohs(reply->addr_type) != AF_INET6) {\n            USER_MSG(\"mdns_spoof: can not spoof AAAA record for %s \"\n                     \"because the value is not a IPv6 address\\n\", name);\n            return;\n         }\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);                  /* name */\n         memcpy(p    , \"\\x00\\x1c\", 2);                    /* type AAAA */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                    /* cache-flush-bit + class */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* TTL (1 hour) */\n         memcpy(p + 8, \"\\x00\\x10\", 2);                    /* datalen */\n         ip_addr_cpy(p + 10, reply);                      /* data */\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the reply back to the multicast or unicast address \n          * and set the faked address as the source address for the transport\n          */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, sizeof(answer), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", name, type_str(type), ip_addr_ntoa(reply, tmp));\n       }\n       else if (type == ns_t_ptr) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 256];\n         char *a, *p = (char*)answer + name_len;\n         int rlen;\n         \n         /* found the reply in the list */\n         if (get_spoofed_ptr(name, &a, &reply) != E_SUCCESS)\n            return;\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);                  /* name */\n         memcpy(p    , \"\\x00\\x0c\", 2);                    /* type PTR */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                    /* cache-flush-bit + class */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* TTL (1 hour) */\n         /* compress the string into the buffer */\n         rlen = dn_comp(a, (u_char*)p + 10, 256, NULL, NULL);\n         /* put the length before the dn_comp'd string */\n         p += 8;\n         NS_PUT16(rlen, p);\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the fake reply */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, name_len + 10 + rlen, 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", name, type_str(type), a);\n      }\n      else if (type == ns_t_srv) {\n         struct ip_addr *reply;\n         struct ip_addr *sender;\n         struct ip_addr *target;\n         u_int8 *tmac;\n         u_int8 answer[name_len + 22 + 12 + 16];\n         char *p = (char *)answer + name_len;\n         char tmp[MAX_ASCII_ADDR_LEN];\n         char srvoffset[2];\n         char tgtoffset[2];\n         u_int16 port;\n         int dn_offset = 0;\n\n\n         /* found the reply in the list */\n         if (get_spoofed_srv(name, &reply, &port) != E_SUCCESS) \n            return;\n\n         /*\n          * to refer the target to a proper domain name, we have to strip the\n          * service and protocol label from the questioned domain name\n          */\n         dn_offset += *(data+dn_offset) + 1; /* first label (e.g. _ldap)*/\n         dn_offset += *(data+dn_offset) + 1; /* second label (e.g. _tcp) */\n\n         /* avoid offset overrun */\n         if (dn_offset + 12 > 255) {\n            dn_offset = 0;\n         }\n\n         tgtoffset[0] = 0xc0; /* offset byte */\n         tgtoffset[1] = 12 + dn_offset; /* offset to the actual domain name */\n\n         /*\n          * to inject the spoofed IP address in the additional section, \n          * we have set the offset pointing to the spoofed domain name set \n          * below (in turn, after the domain name [variable length] in the \n          * question section)\n          */\n         srvoffset[0] = 0xc0; /* offset byte */\n         srvoffset[1] = 12 + name_len + 16; /* offset to the answer */\n\n        /* \n         * in MDNS the original question is not included \n         * into the reply packet as with pure DNS - \n         * fill the buffer with the questioned name of the request\n         * we will append the answer just after the quoted name \n         */\n         memcpy(answer, data, name_len);              /* name */\n         memcpy(p    , \"\\x00\\x21\", 2);                /* type SRV */\n         memcpy(p + 2, \"\\x80\\x01\", 2);                /* class IN */\n         memcpy(p + 4, \"\\x00\\x00\\x0e\\x10\", 4);        /* TTL (1 hour) */\n         memcpy(p + 8, \"\\x00\\x0c\", 2);                /* data length */\n         memcpy(p + 10, \"\\x00\\x00\", 2);               /* priority */\n         memcpy(p + 12, \"\\x00\\x00\", 2);               /* weight */\n         p+=14; \n         NS_PUT16(port, p);                           /* port */ \n         p-=16;             \n         /* \n          * add \"srv.\" in front of the stripped domain\n          * name and resolve it in the additional \n          * record (here `srvoffset' is pointing at)\n          */\n         memcpy(p + 16, \"\\x03\\x73\\x72\\x76\", 4);       /* target */\n         memcpy(p + 20, tgtoffset,2);                 /* compressed name offset */\n     \n         /* add the additional record for the spoofed IPv4 address*/\n         if (ntohs(reply->addr_type) == AF_INET) {\n             memcpy(p + 22, srvoffset, 2);            /* compressed name offset */\n             memcpy(p + 24, \"\\x00\\x01\", 2);           /* type A */\n             memcpy(p + 26, \"\\x80\\x01\", 2);           /* class */\n             memcpy(p + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* TTL (1 hour) */\n             memcpy(p + 32, \"\\x00\\x04\", 2);           /* datalen */\n             ip_addr_cpy(p + 34, reply);              /* data */\n             memset(p + 38, 0, 12);                   /* padding */\n         }\n         /* add the additional record for the spoofed IPv6 address*/\n         else if (ntohs(reply->addr_type) == AF_INET6) {\n             memcpy(p + 22, srvoffset, 2);            /* compressed name offset */\n             memcpy(p + 24, \"\\x00\\x1c\", 2);           /* type AAAA */\n             memcpy(p + 26, \"\\x80\\x01\", 2);           /* class */\n             memcpy(p + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* TTL (1 hour) */\n             memcpy(p + 32, \"\\x00\\x10\", 2);           /* datalen */\n             ip_addr_cpy(p + 34, reply);              /* data */\n         }\n         else {\n             /* IP address not valid - abort */\n             return;\n         }\n\n         /*\n          * depending on the MDNS question, the target address has to be redefined;\n          * we also can not use the multicast address as the source but also;\n          * don't want to reveal our own IP, so the sender needs also be redefined;\n          * hence the variables for the transport of the reply need to be prepared.\n          */\n         prep_mdns_reply(po, class, &sender, &target, &tmac, reply);\n\n         /* send the reply back to the multicast or unicast address \n          * and set the faked address as the source address for the transport\n          */\n         send_mdns_reply(po->L4.src, sender, target, tmac, \n                         ntohs(mdns->id), answer, sizeof(answer), 2, 0, 0);\n\n         USER_MSG(\"mdns_spoof: SRV [%s] spoofed to [%s:%d]\\n\", name, ip_addr_ntoa(reply, tmp), port);\n      }\n    }\n\n\n }",
  "abstract_func": "static void mdns_spoof(struct packet_object *VAR_0)\n {\n    VAR_0->flags |= VAR_1; /* COMMENT_0 */\n\n    struct mdns_header *VAR_2;\n    char VAR_3[VAR_4];\n    int VAR_5;\n    u_char *VAR_6, *VAR_7, *VAR_8;;\n    u_int16 VAR_9;\n    u_int16 VAR_10;\n    int VAR_11;\n\n    VAR_2 = (struct mdns_header *)VAR_0->DATA.data;\n    VAR_7 = (u_char *)(VAR_2+1);\n    VAR_8 = (u_char *)VAR_2 + VAR_0->DATA.len;\n\n    VAR_6 = VAR_7;\n\n    if (VAR_2->flags == 0x8400 || VAR_2->answer_rrs > 0)\n    {\n        /* COMMENT_1 */\n        return;\n    }\n\n    /* COMMENT_2 */\n    for (VAR_11 = 0; VAR_11 < VAR_2->questions; VAR_11++) {\n\n      VAR_5 = dn_expand((u_char*)VAR_2, VAR_8, VAR_6, VAR_3, sizeof(VAR_3));\n      if (VAR_5 == -1)\n          return;\n      VAR_6 = VAR_7 + VAR_5;\n\n      if (VAR_6 >= VAR_8 || VAR_5 == 0)\n        return;\n\n      NS_GET16(VAR_10, VAR_6);\n      NS_GET16(VAR_9, VAR_6);\n\n      /* COMMENT_3 */\n      if ((VAR_9 & ~VAR_12) != VAR_13)\n         return;\n\n      if(VAR_10 == VAR_14) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 10 + 4];\n         u_char *VAR_20 = VAR_19 + VAR_5;\n         char VAR_21[VAR_22];\n         \n         /* COMMENT_4 */\n         if (get_spoofed_a(VAR_3, &VAR_15) != VAR_23)\n            return;\n\n         /* COMMENT_5 */\n         if (ntohs(VAR_15->addr_type) != VAR_24) {\n            USER_MSG(\"mdns_spoof: can not spoof A record for %s \"\n                     \"because the value is not a IPv4 address\\n\", VAR_3);\n            return;\n         }\n\n        /* COMMENT_6 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);                  /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x01\", 2);                    /* COMMENT_13 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                    /* COMMENT_14 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* COMMENT_15 */\n         memcpy(VAR_20 + 8, \"\\x00\\x04\", 2);                    /* COMMENT_16 */\n         ip_addr_cpy(VAR_20 + 10, VAR_15);                      /* COMMENT_17 */\n\n         /* COMMENT_18 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_24 */\n                                                                             \n            \n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, sizeof(VAR_19), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", VAR_3, type_str(VAR_10), ip_addr_ntoa(VAR_15, VAR_21));\n      }\n      if(VAR_10 == VAR_25) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 10 + 16];\n         u_char *VAR_20 = VAR_19 + VAR_5;\n         char VAR_21[VAR_22];\n         \n         /* COMMENT_4 */\n         if (get_spoofed_aaaa(VAR_3, &VAR_15) != VAR_23)\n            return;\n\n         /* COMMENT_5 */\n         if (ntohs(VAR_15->addr_type) != VAR_26) {\n            USER_MSG(\"mdns_spoof: can not spoof AAAA record for %s \"\n                     \"because the value is not a IPv6 address\\n\", VAR_3);\n            return;\n         }\n\n        /* COMMENT_27 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);                  /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x1c\", 2);                    /* COMMENT_33 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                    /* COMMENT_14 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* COMMENT_15 */\n         memcpy(VAR_20 + 8, \"\\x00\\x10\", 2);                    /* COMMENT_16 */\n         ip_addr_cpy(VAR_20 + 10, VAR_15);                      /* COMMENT_17 */\n\n         /* COMMENT_34 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_40 */\n                                                                             \n            \n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, sizeof(VAR_19), 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", VAR_3, type_str(VAR_10), ip_addr_ntoa(VAR_15, VAR_21));\n       }\n       else if (VAR_10 == VAR_27) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 256];\n         char *VAR_28, *VAR_20 = (char*)VAR_19 + VAR_5;\n         int VAR_29;\n         \n         /* COMMENT_4 */\n         if (get_spoofed_ptr(VAR_3, &VAR_28, &VAR_15) != VAR_23)\n            return;\n\n        /* COMMENT_43 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);                  /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x0c\", 2);                    /* COMMENT_49 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                    /* COMMENT_14 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);            /* COMMENT_15 */\n         /* COMMENT_50 */\n         VAR_29 = dn_comp(VAR_28, (u_char*)VAR_20 + 10, 256, NULL, NULL);\n         /* COMMENT_51 */\n         VAR_20 += 8;\n         NS_PUT16(VAR_29, VAR_20);\n\n         /* COMMENT_52 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_58 */\n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, VAR_5 + 10 + VAR_29, 1, 0, 0);\n         \n         USER_MSG(\"mdns_spoof: [%s %s] spoofed to [%s]\\n\", VAR_3, type_str(VAR_10), VAR_28);\n      }\n      else if (VAR_10 == VAR_30) {\n         struct ip_addr *VAR_15;\n         struct ip_addr *VAR_16;\n         struct ip_addr *VAR_17;\n         u_int8 *VAR_18;\n         u_int8 VAR_19[VAR_5 + 22 + 12 + 16];\n         char *VAR_20 = (char *)VAR_19 + VAR_5;\n         char VAR_21[VAR_22];\n         char VAR_31[2];\n         char VAR_32[2];\n         u_int16 VAR_33;\n         int VAR_34 = 0;\n\n\n         /* COMMENT_4 */\n         if (get_spoofed_srv(VAR_3, &VAR_15, &VAR_33) != VAR_23) \n            return;\n\n         /* COMMENT_59 */\n                                                                             \n                                                                      \n            \n         VAR_34 += *(VAR_7+VAR_34) + 1; /* COMMENT_63 */\n         VAR_34 += *(VAR_7+VAR_34) + 1; /* COMMENT_64 */\n\n         /* COMMENT_65 */\n         if (VAR_34 + 12 > 255) {\n            VAR_34 = 0;\n         }\n\n         VAR_32[0] = 0xc0; /* COMMENT_66 */\n         VAR_32[1] = 12 + VAR_34; /* COMMENT_67 */\n\n         /* COMMENT_68 */\n                                                                        \n                                                                           \n                                                                           \n                             \n            \n         VAR_31[0] = 0xc0; /* COMMENT_66 */\n         VAR_31[1] = 12 + VAR_5 + 16; /* COMMENT_74 */\n\n        /* COMMENT_75 */\n                                                         \n                                                    \n                                                                  \n                                                                \n           \n         memcpy(VAR_19, VAR_7, VAR_5);              /* COMMENT_12 */\n         memcpy(VAR_20    , \"\\x00\\x21\", 2);                /* COMMENT_81 */\n         memcpy(VAR_20 + 2, \"\\x80\\x01\", 2);                /* COMMENT_82 */\n         memcpy(VAR_20 + 4, \"\\x00\\x00\\x0e\\x10\", 4);        /* COMMENT_15 */\n         memcpy(VAR_20 + 8, \"\\x00\\x0c\", 2);                /* COMMENT_83 */\n         memcpy(VAR_20 + 10, \"\\x00\\x00\", 2);               /* COMMENT_84 */\n         memcpy(VAR_20 + 12, \"\\x00\\x00\", 2);               /* COMMENT_85 */\n         VAR_20+=14; \n         NS_PUT16(VAR_33, VAR_20);                           /* COMMENT_86 */ \n         VAR_20-=16;             \n         /* COMMENT_87 */\n                                                      \n                                                  \n                                                    \n            \n         memcpy(VAR_20 + 16, \"\\x03\\x73\\x72\\x76\", 4);       /* COMMENT_92 */\n         memcpy(VAR_20 + 20, VAR_32,2);                 /* COMMENT_93 */\n     \n         /* COMMENT_94 */\n         if (ntohs(VAR_15->addr_type) == VAR_24) {\n             memcpy(VAR_20 + 22, VAR_31, 2);            /* COMMENT_93 */\n             memcpy(VAR_20 + 24, \"\\x00\\x01\", 2);           /* COMMENT_13 */\n             memcpy(VAR_20 + 26, \"\\x80\\x01\", 2);           /* COMMENT_95 */\n             memcpy(VAR_20 + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* COMMENT_15 */\n             memcpy(VAR_20 + 32, \"\\x00\\x04\", 2);           /* COMMENT_16 */\n             ip_addr_cpy(VAR_20 + 34, VAR_15);              /* COMMENT_17 */\n             memset(VAR_20 + 38, 0, 12);                   /* COMMENT_96 */\n         }\n         /* COMMENT_97 */\n         else if (ntohs(VAR_15->addr_type) == VAR_26) {\n             memcpy(VAR_20 + 22, VAR_31, 2);            /* COMMENT_93 */\n             memcpy(VAR_20 + 24, \"\\x00\\x1c\", 2);           /* COMMENT_33 */\n             memcpy(VAR_20 + 26, \"\\x80\\x01\", 2);           /* COMMENT_95 */\n             memcpy(VAR_20 + 28, \"\\x00\\x00\\x0e\\x10\", 4);   /* COMMENT_15 */\n             memcpy(VAR_20 + 32, \"\\x00\\x10\", 2);           /* COMMENT_16 */\n             ip_addr_cpy(VAR_20 + 34, VAR_15);              /* COMMENT_17 */\n         }\n         else {\n             /* COMMENT_98 */\n             return;\n         }\n\n         /* COMMENT_99 */\n                                                                                   \n                                                                             \n                                                                                   \n                                                                                   \n            \n         prep_mdns_reply(VAR_0, VAR_9, &VAR_16, &VAR_17, &VAR_18, VAR_15);\n\n         /* COMMENT_105 */\n                                                                             \n            \n         send_mdns_reply(VAR_0->L4.src, VAR_16, VAR_17, VAR_18, \n                         ntohs(VAR_2->id), VAR_19, sizeof(VAR_19), 2, 0, 0);\n\n         USER_MSG(\"mdns_spoof: SRV [%s] spoofed to [%s:%d]\\n\", VAR_3, ip_addr_ntoa(VAR_15, VAR_21), VAR_33);\n      }\n    }\n\n\n }",
  "func_graph_path": "Ettercap/ettercap/cb7b2028dc03c628aa0a1a5130ca41421ddebcb2/mdns_spoof.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,8 @@\n     for (x = 0; x < mdns->questions; x++) {\n \n       name_len = dn_expand((u_char*)mdns, end, q, name, sizeof(name));\n-\n+      if (name_len == -1)\n+          return;\n       q = data + name_len;\n \n       if (q >= end || name_len == 0)",
  "diff_line_info": {
    "deleted_lines": [
      ""
    ],
    "added_lines": [
      "      if (name_len == -1)",
      "          return;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Ettercap/ettercap/pull/604",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Ettercap/ettercap/pull/604: 403 Client Error: Forbidden for url: https://api.github.com/repos/Ettercap/ettercap/pulls/604",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\nThe code change addresses an exploit where ignoring the return value of dn_expand causes a stack overflow. The added check prevents this security issue."
}