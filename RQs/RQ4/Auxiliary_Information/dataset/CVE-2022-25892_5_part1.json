{
  "cve_id": "CVE-2022-25892",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "galkahana/HummusJS",
  "commit_msg": "corrections",
  "commit_hash": "a9bf2520ab5abb69f9328906e406fbebfb36159a",
  "git_url": "https://github.com/galkahana/HummusJS/commit/a9bf2520ab5abb69f9328906e406fbebfb36159a",
  "file_path": "src/deps/PDFWriter/PDFDocumentHandler.cpp",
  "func_name": "PDFDocumentHandler::WriteStreamObject",
  "func_before": "EStatusCode PDFDocumentHandler::WriteStreamObject(PDFStreamInput* inStream, IObjectWritePolicy* inWritePolicy)\n{\n\t/*\n\t1. Create stream dictionary, copy all elements of input stream but Length (which may be the same...but due to internals may not)\n\t2. Create PDFStream with this dictionary and use its output stream to write the result\n\t*/\n\tRefCountPtr<PDFDictionary> streamDictionary(inStream->QueryStreamDictionary());\n\tDictionaryContext* newStreamDictionary = mObjectsContext->StartDictionary();\n\n\tMapIterator<PDFNameToPDFObjectMap> it(streamDictionary->GetIterator());\n\tEStatusCode status = PDFHummus::eSuccess;\n\tbool readingDecrypted = false;\n\tIByteReader* streamReader = NULL;\n\n\t/*\n\t*\tTo support unencrypted pdf output, mostly used for debugging, (and maybe i should put a general flag there),\n\t*\tadd ability here to copy by rewriting the streams...when possible.\n\t*/\n\tif(!mObjectsContext->IsCompressingStreams()) {\n\t\tstreamReader = mParser->StartReadingFromStream(inStream);\n\t\treadingDecrypted = streamReader != NULL;\n\t}\t\n\tif(!readingDecrypted) {\n\t\tstreamReader = mParser->StartReadingFromStreamForPlainCopying(inStream);\n\t}\n\t\n\twhile (it.MoveNext() && PDFHummus::eSuccess == status)\n\t{\n\t\tif (it.GetKey()->GetValue() != \"Length\" && (!readingDecrypted || it.GetKey()->GetValue() != \"Filter\")) {\n\t\t\tstatus = newStreamDictionary->WriteKey(it.GetKey()->GetValue());\n\t\t\tif (PDFHummus::eSuccess == status)\n\t\t\t\tstatus = WriteObjectByType(it.GetValue(), eTokenSeparatorEndLine, inWritePolicy);\n\t\t}\n\t}\n\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to write stream dictionary\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tPDFStream* newStream = readingDecrypted ? \n\t\tmObjectsContext->StartPDFStream(newStreamDictionary) :\n\t\tmObjectsContext->StartUnfilteredPDFStream(newStreamDictionary);\n\tOutputStreamTraits outputTraits(newStream->GetWriteStream());\n\n\tstatus = outputTraits.CopyToOutputStream(streamReader);\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to copy stream\");\n\t\tdelete newStream;\n\t\tdelete streamReader;\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tmObjectsContext->EndPDFStream(newStream);\n\tdelete newStream;\n\tdelete streamReader;\n\treturn status;\n}",
  "abstract_func_before": "EStatusCode PDFDocumentHandler::WriteStreamObject(PDFStreamInput* VAR_0, IObjectWritePolicy* VAR_1)\n{\n\t/* COMMENT_0 */\n                                                                                                                                 \n                                                                                       \n   \n\tRefCountPtr<PDFDictionary> VAR_2(VAR_0->QueryStreamDictionary());\n\tDictionaryContext* VAR_3 = VAR_4->StartDictionary();\n\n\tMapIterator<PDFNameToPDFObjectMap> VAR_5(VAR_2->GetIterator());\n\tEStatusCode VAR_6 = PDFHummus::eSuccess;\n\tbool VAR_7 = false;\n\tIByteReader* VAR_8 = NULL;\n\n\t/* COMMENT_4 */\n                                                                                                               \n                                                                     \n   \n\tif(!VAR_4->IsCompressingStreams()) {\n\t\tVAR_8 = VAR_9->StartReadingFromStream(VAR_0);\n\t\tVAR_7 = VAR_8 != NULL;\n\t}\t\n\tif(!VAR_7) {\n\t\tVAR_8 = VAR_9->StartReadingFromStreamForPlainCopying(VAR_0);\n\t}\n\t\n\twhile (VAR_5.MoveNext() && PDFHummus::eSuccess == VAR_6)\n\t{\n\t\tif (VAR_5.GetKey()->GetValue() != \"Length\" && (!VAR_7 || VAR_5.GetKey()->GetValue() != \"Filter\")) {\n\t\t\tVAR_6 = VAR_3->WriteKey(VAR_5.GetKey()->GetValue());\n\t\t\tif (PDFHummus::eSuccess == VAR_6)\n\t\t\t\tVAR_6 = WriteObjectByType(VAR_5.GetValue(), VAR_10, VAR_1);\n\t\t}\n\t}\n\n\tif (VAR_6 != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to write stream dictionary\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tPDFStream* VAR_11 = VAR_7 ? \n\t\tVAR_4->StartPDFStream(VAR_3) :\n\t\tVAR_4->StartUnfilteredPDFStream(VAR_3);\n\tOutputStreamTraits VAR_12(VAR_11->GetWriteStream());\n\n\tVAR_6 = VAR_12.CopyToOutputStream(VAR_8);\n\tif (VAR_6 != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to copy stream\");\n\t\tdelete VAR_11;\n\t\tdelete VAR_8;\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tVAR_4->EndPDFStream(VAR_11);\n\tdelete VAR_11;\n\tdelete VAR_8;\n\treturn VAR_6;\n}",
  "func_graph_path_before": "galkahana/HummusJS/a9bf2520ab5abb69f9328906e406fbebfb36159a/PDFDocumentHandler.cpp/vul/before/0.json",
  "func": "EStatusCode PDFDocumentHandler::WriteStreamObject(PDFStreamInput* inStream, IObjectWritePolicy* inWritePolicy)\n{\n\t/*\n\t1. Create stream dictionary, copy all elements of input stream but Length (which may be the same...but due to internals may not)\n\t2. Create PDFStream with this dictionary and use its output stream to write the result\n\t*/\n\tRefCountPtr<PDFDictionary> streamDictionary(inStream->QueryStreamDictionary());\n\tDictionaryContext* newStreamDictionary = mObjectsContext->StartDictionary();\n\n\tMapIterator<PDFNameToPDFObjectMap> it(streamDictionary->GetIterator());\n\tEStatusCode status = PDFHummus::eSuccess;\n\tbool readingDecrypted = false;\n\tIByteReader* streamReader = NULL;\n\n\t/*\n\t*\tTo support unencrypted pdf output, mostly used for debugging, (and maybe i should put a general flag there),\n\t*\tadd ability here to copy by rewriting the streams...when possible.\n\t*/\n\tif(!mObjectsContext->IsCompressingStreams()) {\n\t\tstreamReader = mParser->StartReadingFromStream(inStream);\n\t\treadingDecrypted = streamReader != NULL;\n\t}\t\n\tif(!readingDecrypted) {\n\t\tstreamReader = mParser->StartReadingFromStreamForPlainCopying(inStream);\n\t}\n\n\tif (streamReader == NULL) {\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, unable to start reading stream object\");\n\t\tstatus = PDFHummus::eFailure;\n\t}\t\n\t\n\twhile (it.MoveNext() && PDFHummus::eSuccess == status)\n\t{\n\t\tif (it.GetKey()->GetValue() != \"Length\" && (!readingDecrypted || it.GetKey()->GetValue() != \"Filter\")) {\n\t\t\tstatus = newStreamDictionary->WriteKey(it.GetKey()->GetValue());\n\t\t\tif (PDFHummus::eSuccess == status)\n\t\t\t\tstatus = WriteObjectByType(it.GetValue(), eTokenSeparatorEndLine, inWritePolicy);\n\t\t}\n\t}\n\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to write stream dictionary\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tPDFStream* newStream = readingDecrypted ? \n\t\tmObjectsContext->StartPDFStream(newStreamDictionary) :\n\t\tmObjectsContext->StartUnfilteredPDFStream(newStreamDictionary);\n\tOutputStreamTraits outputTraits(newStream->GetWriteStream());\n\n\tstatus = outputTraits.CopyToOutputStream(streamReader);\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to copy stream\");\n\t\tdelete newStream;\n\t\tdelete streamReader;\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tmObjectsContext->EndPDFStream(newStream);\n\tdelete newStream;\n\tdelete streamReader;\n\treturn status;\n}",
  "abstract_func": "EStatusCode PDFDocumentHandler::WriteStreamObject(PDFStreamInput* VAR_0, IObjectWritePolicy* VAR_1)\n{\n\t/* COMMENT_0 */\n                                                                                                                                 \n                                                                                       \n   \n\tRefCountPtr<PDFDictionary> VAR_2(VAR_0->QueryStreamDictionary());\n\tDictionaryContext* VAR_3 = VAR_4->StartDictionary();\n\n\tMapIterator<PDFNameToPDFObjectMap> VAR_5(VAR_2->GetIterator());\n\tEStatusCode VAR_6 = PDFHummus::eSuccess;\n\tbool VAR_7 = false;\n\tIByteReader* VAR_8 = NULL;\n\n\t/* COMMENT_4 */\n                                                                                                               \n                                                                     \n   \n\tif(!VAR_4->IsCompressingStreams()) {\n\t\tVAR_8 = VAR_9->StartReadingFromStream(VAR_0);\n\t\tVAR_7 = VAR_8 != NULL;\n\t}\t\n\tif(!VAR_7) {\n\t\tVAR_8 = VAR_9->StartReadingFromStreamForPlainCopying(VAR_0);\n\t}\n\n\tif (VAR_8 == NULL) {\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, unable to start reading stream object\");\n\t\tVAR_6 = PDFHummus::eFailure;\n\t}\t\n\t\n\twhile (VAR_5.MoveNext() && PDFHummus::eSuccess == VAR_6)\n\t{\n\t\tif (VAR_5.GetKey()->GetValue() != \"Length\" && (!VAR_7 || VAR_5.GetKey()->GetValue() != \"Filter\")) {\n\t\t\tVAR_6 = VAR_3->WriteKey(VAR_5.GetKey()->GetValue());\n\t\t\tif (PDFHummus::eSuccess == VAR_6)\n\t\t\t\tVAR_6 = WriteObjectByType(VAR_5.GetValue(), VAR_10, VAR_1);\n\t\t}\n\t}\n\n\tif (VAR_6 != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to write stream dictionary\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tPDFStream* VAR_11 = VAR_7 ? \n\t\tVAR_4->StartPDFStream(VAR_3) :\n\t\tVAR_4->StartUnfilteredPDFStream(VAR_3);\n\tOutputStreamTraits VAR_12(VAR_11->GetWriteStream());\n\n\tVAR_6 = VAR_12.CopyToOutputStream(VAR_8);\n\tif (VAR_6 != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to copy stream\");\n\t\tdelete VAR_11;\n\t\tdelete VAR_8;\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tVAR_4->EndPDFStream(VAR_11);\n\tdelete VAR_11;\n\tdelete VAR_8;\n\treturn VAR_6;\n}",
  "func_graph_path": "galkahana/HummusJS/a9bf2520ab5abb69f9328906e406fbebfb36159a/PDFDocumentHandler.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,11 @@\n \tif(!readingDecrypted) {\n \t\tstreamReader = mParser->StartReadingFromStreamForPlainCopying(inStream);\n \t}\n+\n+\tif (streamReader == NULL) {\n+\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, unable to start reading stream object\");\n+\t\tstatus = PDFHummus::eFailure;\n+\t}\t\n \t\n \twhile (it.MoveNext() && PDFHummus::eSuccess == status)\n \t{",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\tif (streamReader == NULL) {",
      "\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, unable to start reading stream object\");",
      "\t\tstatus = PDFHummus::eFailure;",
      "\t}\t"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/galkahana/HummusJS/pull/464",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/galkahana/HummusJS/pull/464: 403 Client Error: Forbidden for url: https://api.github.com/repos/galkahana/HummusJS/pulls/464",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "The commit message is vague, but the code change adds error handling, indicating it's fixing a defect. The confidence is high but slightly reduced due to mismatched description.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}