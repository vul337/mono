{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvSTAT",
  "func_before": "int wolfSSH_SFTP_RecvSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    WS_SFTP_FILEATRB atr;\n    char* name = NULL;\n    int   ret = WS_SUCCESS;\n\n    word32 sz;\n    word32 idx = 0;\n\n    byte*  out = NULL;\n    word32 outSz = 0;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_STAT\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (name == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(name, data + idx, sz);\n    name[sz] = '\\0';\n\n    /* try to get file attributes and send back to client */\n    if (wolfSSH_CleanPath(ssh, name) < 0) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n            WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB));\n        if (SFTP_GetAttributes(ssh->fs, name, &atr, 0, ssh->ctx->heap)\n            != WS_SUCCESS) {\n            WLOG(WS_LOG_SFTP, \"Unable to get stat of file/directory\");\n            if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                    \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n                return WS_FATAL_ERROR;\n            }\n            ret = WS_BAD_FILE_E;\n        }\n        else {\n            sz = SFTP_AtributesSz(ssh, &atr);\n            outSz = sz + WOLFSSH_SFTP_HEADER;\n        }\n    }\n    WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != WS_SUCCESS) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", out, &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        if (SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_ATTRS, sz, out) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        SFTP_SetAttributes(ssh, out + WOLFSSH_SFTP_HEADER, sz, &atr);\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func_before": "int wolfSSH_SFTP_RecvSTAT(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n{\n    WS_SFTP_FILEATRB VAR_4;\n    char* VAR_5 = NULL;\n    int   VAR_6 = VAR_7;\n\n    word32 VAR_8;\n    word32 VAR_9 = 0;\n\n    byte*  VAR_10 = NULL;\n    word32 VAR_11 = 0;\n\n    if (VAR_0 == NULL) {\n        return VAR_12;\n    }\n\n    WLOG(VAR_13, \"Receiving WOLFSSH_FTP_STAT\");\n\n    ato32(VAR_2 + VAR_9, &VAR_8); VAR_9 += VAR_14;\n    if (VAR_8 + VAR_9 > VAR_3) {\n        return VAR_15;\n    }\n\n    /* COMMENT_0 */\n    VAR_5 = (char*)WMALLOC(VAR_8 + 1, VAR_0->ctx->heap, VAR_16);\n    if (VAR_5 == NULL) {\n        return VAR_17;\n    }\n    WMEMCPY(VAR_5, VAR_2 + VAR_9, VAR_8);\n    VAR_5[VAR_8] = '\\0';\n\n    /* COMMENT_1 */\n    if (wolfSSH_CleanPath(VAR_0, VAR_5) < 0) {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_18, VAR_1,\n                \"STAT error\", \"English\", NULL, &VAR_11) != VAR_19) {\n            WFREE(VAR_5, VAR_0->ctx->heap, VAR_16);\n            return VAR_20;\n        }\n        VAR_6 = VAR_20;\n    }\n\n    if (VAR_6 == VAR_7) {\n        WMEMSET((byte*)&VAR_4, 0, sizeof(WS_SFTP_FILEATRB));\n        if (SFTP_GetAttributes(VAR_0->fs, VAR_5, &VAR_4, 0, VAR_0->ctx->heap)\n            != VAR_7) {\n            WLOG(VAR_13, \"Unable to get stat of file/directory\");\n            if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_18, VAR_1,\n                    \"STAT error\", \"English\", NULL, &VAR_11) != VAR_19) {\n                WFREE(VAR_5, VAR_0->ctx->heap, VAR_16);\n                return VAR_20;\n            }\n            VAR_6 = VAR_21;\n        }\n        else {\n            VAR_8 = SFTP_AtributesSz(VAR_0, &VAR_4);\n            VAR_11 = VAR_8 + VAR_22;\n        }\n    }\n    WFREE(VAR_5, VAR_0->ctx->heap, VAR_16);\n\n    VAR_10 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_16);\n    if (VAR_10 == NULL) {\n        return VAR_17;\n    }\n\n    if (VAR_6 != VAR_7) {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_18, VAR_1,\n                \"STAT error\", \"English\", VAR_10, &VAR_11) != VAR_7) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_16);\n            return VAR_20;\n        }\n    }\n    else {\n        if (SFTP_SetHeader(VAR_0, VAR_1, VAR_23, VAR_8, VAR_10) != VAR_7) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_16);\n            return VAR_20;\n        }\n        SFTP_SetAttributes(VAR_0, VAR_10 + VAR_22, VAR_8, &VAR_4);\n    }\n\n    /* COMMENT_2 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_10, VAR_11);\n    return VAR_6;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/0.json",
  "func": "int wolfSSH_SFTP_RecvSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    WS_SFTP_FILEATRB atr;\n    char* name = NULL;\n    int   ret = WS_SUCCESS;\n\n    word32 sz;\n    word32 idx = 0;\n\n    byte*  out = NULL;\n    word32 outSz = 0;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_STAT\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (name == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(name, data + idx, sz);\n    name[sz] = '\\0';\n\n    /* try to get file attributes and send back to client */\n    if (wolfSSH_CleanPath(ssh, name) < 0) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n            WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB));\n        if (SFTP_GetAttributes(ssh->fs, name, &atr, 0, ssh->ctx->heap)\n            != WS_SUCCESS) {\n            WLOG(WS_LOG_SFTP, \"Unable to get stat of file/directory\");\n            if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                    \"STAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n                return WS_FATAL_ERROR;\n            }\n            ret = WS_BAD_FILE_E;\n        }\n        else {\n            sz = SFTP_AtributesSz(ssh, &atr);\n            outSz = sz + WOLFSSH_SFTP_HEADER;\n        }\n    }\n    WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != WS_SUCCESS) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"STAT error\", \"English\", out, &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        if (SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_ATTRS, sz, out) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        SFTP_SetAttributes(ssh, out + WOLFSSH_SFTP_HEADER, sz, &atr);\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func": "int wolfSSH_SFTP_RecvSTAT(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n{\n    WS_SFTP_FILEATRB VAR_4;\n    char* VAR_5 = NULL;\n    int   VAR_6 = VAR_7;\n\n    word32 VAR_8;\n    word32 VAR_9 = 0;\n\n    byte*  VAR_10 = NULL;\n    word32 VAR_11 = 0;\n\n    if (VAR_0 == NULL) {\n        return VAR_12;\n    }\n\n    WLOG(VAR_13, \"Receiving WOLFSSH_FTP_STAT\");\n\n    ato32(VAR_2 + VAR_9, &VAR_8); VAR_9 += VAR_14;\n    if (VAR_8 > VAR_3 - VAR_9) {\n        return VAR_15;\n    }\n\n    /* COMMENT_0 */\n    VAR_5 = (char*)WMALLOC(VAR_8 + 1, VAR_0->ctx->heap, VAR_16);\n    if (VAR_5 == NULL) {\n        return VAR_17;\n    }\n    WMEMCPY(VAR_5, VAR_2 + VAR_9, VAR_8);\n    VAR_5[VAR_8] = '\\0';\n\n    /* COMMENT_1 */\n    if (wolfSSH_CleanPath(VAR_0, VAR_5) < 0) {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_18, VAR_1,\n                \"STAT error\", \"English\", NULL, &VAR_11) != VAR_19) {\n            WFREE(VAR_5, VAR_0->ctx->heap, VAR_16);\n            return VAR_20;\n        }\n        VAR_6 = VAR_20;\n    }\n\n    if (VAR_6 == VAR_7) {\n        WMEMSET((byte*)&VAR_4, 0, sizeof(WS_SFTP_FILEATRB));\n        if (SFTP_GetAttributes(VAR_0->fs, VAR_5, &VAR_4, 0, VAR_0->ctx->heap)\n            != VAR_7) {\n            WLOG(VAR_13, \"Unable to get stat of file/directory\");\n            if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_18, VAR_1,\n                    \"STAT error\", \"English\", NULL, &VAR_11) != VAR_19) {\n                WFREE(VAR_5, VAR_0->ctx->heap, VAR_16);\n                return VAR_20;\n            }\n            VAR_6 = VAR_21;\n        }\n        else {\n            VAR_8 = SFTP_AtributesSz(VAR_0, &VAR_4);\n            VAR_11 = VAR_8 + VAR_22;\n        }\n    }\n    WFREE(VAR_5, VAR_0->ctx->heap, VAR_16);\n\n    VAR_10 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_16);\n    if (VAR_10 == NULL) {\n        return VAR_17;\n    }\n\n    if (VAR_6 != VAR_7) {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_18, VAR_1,\n                \"STAT error\", \"English\", VAR_10, &VAR_11) != VAR_7) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_16);\n            return VAR_20;\n        }\n    }\n    else {\n        if (SFTP_SetHeader(VAR_0, VAR_1, VAR_23, VAR_8, VAR_10) != VAR_7) {\n            WFREE(VAR_10, VAR_0->ctx->heap, VAR_16);\n            return VAR_20;\n        }\n        SFTP_SetAttributes(VAR_0, VAR_10 + VAR_22, VAR_8, &VAR_4);\n    }\n\n    /* COMMENT_2 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_10, VAR_11);\n    return VAR_6;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n     WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_STAT\");\n \n     ato32(data + idx, &sz); idx += UINT32_SZ;\n-    if (sz + idx > maxSz) {\n+    if (sz > maxSz - idx) {\n         return WS_BUFFER_E;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    if (sz + idx > maxSz) {"
    ],
    "added_lines": [
      "    if (sz > maxSz - idx) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/wolfSSL/wolfssh/pull/360: 403 Client Error: Forbidden for url: https://api.github.com/repos/wolfSSL/wolfssh/pulls/360",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}