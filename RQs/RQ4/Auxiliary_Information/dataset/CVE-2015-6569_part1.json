{
  "cve_id": "CVE-2015-6569",
  "cwe_ids": [
    "CWE-362",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "floodlight",
  "commit_msg": "fix data races bug in LoadBalancer module",
  "commit_hash": "7f5bedb625eec3ff4d29987c31cef2553a962b36",
  "git_url": "https://github.com/floodlight/floodlight/commit/7f5bedb625eec3ff4d29987c31cef2553a962b36",
  "file_path": "src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java",
  "func_name": "processPacketIn",
  "func_before": "private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    LBMember member = members.get(pool.pickMember(client));\n\n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }",
  "abstract_func_before": "private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch VAR_0, OFPacketIn VAR_1, FloodlightContext VAR_2) {\n        \n        Ethernet VAR_3 = VAR_4.bcStore.get(VAR_2, VAR_4.CONTEXT_PI_PAYLOAD);\n        IPacket VAR_5 = VAR_3.getPayload(); \n \n        if (VAR_3.isBroadcast() || VAR_3.isMulticast()) {\n            /* COMMENT_0 */\n            if (VAR_5 instanceof ARP) {\n                /* COMMENT_1 */\n                ARP VAR_6 = (ARP) VAR_3.getPayload();\n\n                IPv4Address VAR_7 = VAR_6.getTargetProtocolAddress();\n\n                if (VAR_8.containsKey(VAR_7.getInt())) {\n                    String VAR_9 = VAR_8.get(VAR_7.getInt());\n                    vipProxyArpReply(VAR_0, VAR_1, VAR_2, VAR_9);\n                    return VAR_10.STOP;\n                }\n            }\n        } else {\n            /* COMMENT_2 */\n            if (VAR_5 instanceof IPv4) {\n                IPv4 VAR_11 = (IPv4) VAR_5;\n                \n                /* COMMENT_3 */\n                int VAR_12 = VAR_11.getDestinationAddress().getInt();\n                \n                if (VAR_8.containsKey(VAR_12)){\n                    IPClient VAR_13 = new IPClient();\n                    VAR_13.ipAddress = VAR_11.getSourceAddress();\n                    VAR_13.nw_proto = VAR_11.getProtocol();\n                    if (VAR_11.getPayload() instanceof TCP) {\n                        TCP VAR_14 = (TCP) VAR_11.getPayload();\n                        VAR_13.srcPort = VAR_14.getSourcePort();\n                        VAR_13.targetPort = VAR_14.getDestinationPort();\n                    }\n                    if (VAR_11.getPayload() instanceof UDP) {\n                        UDP VAR_15 = (UDP) VAR_11.getPayload();\n                        VAR_13.srcPort = VAR_15.getSourcePort();\n                        VAR_13.targetPort = VAR_15.getDestinationPort();\n                    }\n                    if (VAR_11.getPayload() instanceof ICMP) {\n                        VAR_13.srcPort = VAR_16.of(8); \n                        VAR_13.targetPort = VAR_16.of(0); \n                    }\n                    \n                    LBVip VAR_17 = VAR_18.get(VAR_8.get(VAR_12));\n                    LBPool VAR_19 = VAR_20.get(VAR_17.pickPool(VAR_13));\n                    LBMember VAR_21 = VAR_22.get(VAR_19.pickMember(VAR_13));\n\n                    /* COMMENT_4 */\n                    pushBidirectionalVipRoutes(VAR_0, VAR_1, VAR_2, VAR_13, VAR_21);\n                   \n                    /* COMMENT_5 */\n                    pushPacket(VAR_5, VAR_0, VAR_1.getBufferId(), (VAR_1.getVersion().compareTo(VAR_23.OF_12) < 0) ? VAR_1.getInPort() : VAR_1.getMatch().get(VAR_24.IN_PORT), VAR_25.TABLE,\n                                VAR_2, true);\n\n                    return VAR_10.STOP;\n                }\n            }\n        }\n        /* COMMENT_6 */\n        return VAR_10.CONTINUE;\n    }",
  "func_graph_path_before": "floodlight/7f5bedb625eec3ff4d29987c31cef2553a962b36/LoadBalancer.java/vul/before/0.json",
  "func": "private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    if (vip == null)\t\t\t// fix deference violations           \n                    \treturn Command.CONTINUE;\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    if (pool == null)\t\t\t// fix deference violations\n                    \treturn Command.CONTINUE;\n                    LBMember member = members.get(pool.pickMember(client));\n                    if(member == null)\t\t\t//fix deference violations\n                    \treturn Command.CONTINUE;\n                    \n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }",
  "abstract_func": "private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch VAR_0, OFPacketIn VAR_1, FloodlightContext VAR_2) {\n        \n        Ethernet VAR_3 = VAR_4.bcStore.get(VAR_2, VAR_4.CONTEXT_PI_PAYLOAD);\n        IPacket VAR_5 = VAR_3.getPayload(); \n \n        if (VAR_3.isBroadcast() || VAR_3.isMulticast()) {\n            /* COMMENT_0 */\n            if (VAR_5 instanceof ARP) {\n                /* COMMENT_1 */\n                ARP VAR_6 = (ARP) VAR_3.getPayload();\n\n                IPv4Address VAR_7 = VAR_6.getTargetProtocolAddress();\n\n                if (VAR_8.containsKey(VAR_7.getInt())) {\n                    String VAR_9 = VAR_8.get(VAR_7.getInt());\n                    vipProxyArpReply(VAR_0, VAR_1, VAR_2, VAR_9);\n                    return VAR_10.STOP;\n                }\n            }\n        } else {\n            /* COMMENT_2 */\n            if (VAR_5 instanceof IPv4) {\n                IPv4 VAR_11 = (IPv4) VAR_5;\n                \n                /* COMMENT_3 */\n                int VAR_12 = VAR_11.getDestinationAddress().getInt();\n                \n                if (VAR_8.containsKey(VAR_12)){\n                    IPClient VAR_13 = new IPClient();\n                    VAR_13.ipAddress = VAR_11.getSourceAddress();\n                    VAR_13.nw_proto = VAR_11.getProtocol();\n                    if (VAR_11.getPayload() instanceof TCP) {\n                        TCP VAR_14 = (TCP) VAR_11.getPayload();\n                        VAR_13.srcPort = VAR_14.getSourcePort();\n                        VAR_13.targetPort = VAR_14.getDestinationPort();\n                    }\n                    if (VAR_11.getPayload() instanceof UDP) {\n                        UDP VAR_15 = (UDP) VAR_11.getPayload();\n                        VAR_13.srcPort = VAR_15.getSourcePort();\n                        VAR_13.targetPort = VAR_15.getDestinationPort();\n                    }\n                    if (VAR_11.getPayload() instanceof ICMP) {\n                        VAR_13.srcPort = VAR_16.of(8); \n                        VAR_13.targetPort = VAR_16.of(0); \n                    }\n                    \n                    LBVip VAR_17 = VAR_18.get(VAR_8.get(VAR_12));\n                    if (VAR_17 == null)\t\t\t/* COMMENT_4 */\n                    \treturn VAR_10.CONTINUE;\n                    LBPool VAR_19 = VAR_20.get(VAR_17.pickPool(VAR_13));\n                    if (VAR_19 == null)\t\t\t/* COMMENT_5 */\n                    \treturn VAR_10.CONTINUE;\n                    LBMember VAR_21 = VAR_22.get(VAR_19.pickMember(VAR_13));\n                    if(VAR_21 == null)\t\t\t/* COMMENT_6 */\n                    \treturn VAR_10.CONTINUE;\n                    \n                    /* COMMENT_7 */\n                    pushBidirectionalVipRoutes(VAR_0, VAR_1, VAR_2, VAR_13, VAR_21);\n                   \n                    /* COMMENT_8 */\n                    pushPacket(VAR_5, VAR_0, VAR_1.getBufferId(), (VAR_1.getVersion().compareTo(VAR_23.OF_12) < 0) ? VAR_1.getInPort() : VAR_1.getMatch().get(VAR_24.IN_PORT), VAR_25.TABLE,\n                                VAR_2, true);\n\n                    return VAR_10.STOP;\n                }\n            }\n        }\n        /* COMMENT_9 */\n        return VAR_10.CONTINUE;\n    }",
  "func_graph_path": "floodlight/7f5bedb625eec3ff4d29987c31cef2553a962b36/LoadBalancer.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,9 +45,15 @@\n                     }\n                     \n                     LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n+                    if (vip == null)\t\t\t// fix deference violations           \n+                    \treturn Command.CONTINUE;\n                     LBPool pool = pools.get(vip.pickPool(client));\n+                    if (pool == null)\t\t\t// fix deference violations\n+                    \treturn Command.CONTINUE;\n                     LBMember member = members.get(pool.pickMember(client));\n-\n+                    if(member == null)\t\t\t//fix deference violations\n+                    \treturn Command.CONTINUE;\n+                    \n                     // for chosen member, check device manager and find and push routes, in both directions                    \n                     pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                    ",
  "diff_line_info": {
    "deleted_lines": [
      ""
    ],
    "added_lines": [
      "                    if (vip == null)\t\t\t// fix deference violations           ",
      "                    \treturn Command.CONTINUE;",
      "                    if (pool == null)\t\t\t// fix deference violations",
      "                    \treturn Command.CONTINUE;",
      "                    if(member == null)\t\t\t//fix deference violations",
      "                    \treturn Command.CONTINUE;",
      "                    "
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/floodlight/floodlight/pull/563",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/floodlight/floodlight/pull/563: 403 Client Error: Forbidden for url: https://api.github.com/repos/floodlight/floodlight/pulls/563",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}