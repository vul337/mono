{
  "cve_id": "CVE-2023-28867",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "graphql-java",
  "commit_msg": "Preventing stack overflow exceptions via limiting the depth of the parser rules",
  "commit_hash": "8a1c884c81c0b656db201cfd95881feb0f430a55",
  "git_url": "https://github.com/graphql-java/graphql-java/commit/8a1c884c81c0b656db201cfd95881feb0f430a55",
  "file_path": "src/main/java/graphql/parser/Parser.java",
  "func_name": "setupParserListener",
  "func_before": "private void setupParserListener(ParserEnvironment environment, MultiSourceReader multiSourceReader, GraphqlParser parser, GraphqlAntlrToLanguage toLanguage) {\n        ParserOptions parserOptions = toLanguage.getParserOptions();\n        ParsingListener parsingListener = parserOptions.getParsingListener();\n        int maxTokens = parserOptions.getMaxTokens();\n        // prevent a billion laugh attacks by restricting how many tokens we allow\n        ParseTreeListener listener = new GraphqlBaseListener() {\n            int count = 0;\n\n            @Override\n            public void visitTerminal(TerminalNode node) {\n\n                final Token token = node.getSymbol();\n                parsingListener.onToken(new ParsingListener.Token() {\n                    @Override\n                    public String getText() {\n                        return token == null ? null : token.getText();\n                    }\n\n                    @Override\n                    public int getLine() {\n                        return token == null ? -1 : token.getLine();\n                    }\n\n                    @Override\n                    public int getCharPositionInLine() {\n                        return token == null ? -1 : token.getCharPositionInLine();\n                    }\n                });\n\n                count++;\n                if (count > maxTokens) {\n                    throwCancelParseIfTooManyTokens(environment, token, maxTokens, multiSourceReader);\n                }\n            }\n        };\n        parser.addParseListener(listener);\n    }",
  "abstract_func_before": "private void setupParserListener(ParserEnvironment VAR_0, MultiSourceReader VAR_1, GraphqlParser VAR_2, GraphqlAntlrToLanguage VAR_3) {\n        ParserOptions VAR_4 = VAR_3.getParserOptions();\n        ParsingListener VAR_5 = VAR_4.getParsingListener();\n        int VAR_6 = VAR_4.getMaxTokens();\n        /* COMMENT_0 */\n        ParseTreeListener VAR_7 = new GraphqlBaseListener() {\n            int VAR_8 = 0;\n\n            @Override\n            public void visitTerminal(TerminalNode VAR_9) {\n\n                final Token VAR_10 = VAR_9.getSymbol();\n                VAR_5.onToken(new ParsingListener.Token() {\n                    @Override\n                    public String getText() {\n                        return VAR_10 == null ? null : VAR_10.getText();\n                    }\n\n                    @Override\n                    public int getLine() {\n                        return VAR_10 == null ? -1 : VAR_10.getLine();\n                    }\n\n                    @Override\n                    public int getCharPositionInLine() {\n                        return VAR_10 == null ? -1 : VAR_10.getCharPositionInLine();\n                    }\n                });\n\n                VAR_8++;\n                if (VAR_8 > VAR_6) {\n                    throwCancelParseIfTooManyTokens(VAR_0, VAR_10, VAR_6, VAR_1);\n                }\n            }\n        };\n        VAR_2.addParseListener(VAR_7);\n    }",
  "func_graph_path_before": "graphql-java/8a1c884c81c0b656db201cfd95881feb0f430a55/Parser.java/vul/before/1.json",
  "func": "private void setupParserListener(ParserEnvironment environment, MultiSourceReader multiSourceReader, GraphqlParser parser, GraphqlAntlrToLanguage toLanguage) {\n        ParserOptions parserOptions = toLanguage.getParserOptions();\n        ParsingListener parsingListener = parserOptions.getParsingListener();\n        int maxTokens = parserOptions.getMaxTokens();\n        int maxRuleDepth = parserOptions.getMaxRuleDepth();\n        // prevent a billion laugh attacks by restricting how many tokens we allow\n        ParseTreeListener listener = new GraphqlBaseListener() {\n            int count = 0;\n            int depth = 0;\n\n\n            @Override\n            public void enterEveryRule(ParserRuleContext ctx) {\n                depth++;\n                if (depth > maxRuleDepth) {\n                    throwIfTokenProblems(\n                            environment,\n                            ctx.getStart(),\n                            maxRuleDepth,\n                            multiSourceReader,\n                            ParseCancelledTooDeepException.class\n                    );\n                }\n            }\n\n            @Override\n            public void exitEveryRule(ParserRuleContext ctx) {\n                depth--;\n            }\n\n            @Override\n            public void visitTerminal(TerminalNode node) {\n\n                final Token token = node.getSymbol();\n                parsingListener.onToken(new ParsingListener.Token() {\n                    @Override\n                    public String getText() {\n                        return token == null ? null : token.getText();\n                    }\n\n                    @Override\n                    public int getLine() {\n                        return token == null ? -1 : token.getLine();\n                    }\n\n                    @Override\n                    public int getCharPositionInLine() {\n                        return token == null ? -1 : token.getCharPositionInLine();\n                    }\n                });\n\n                count++;\n                if (count > maxTokens) {\n                    throwIfTokenProblems(\n                            environment,\n                            token,\n                            maxTokens,\n                            multiSourceReader,\n                            ParseCancelledException.class\n                    );\n                }\n            }\n        };\n        parser.addParseListener(listener);\n    }",
  "abstract_func": "private void setupParserListener(ParserEnvironment VAR_0, MultiSourceReader VAR_1, GraphqlParser VAR_2, GraphqlAntlrToLanguage VAR_3) {\n        ParserOptions VAR_4 = VAR_3.getParserOptions();\n        ParsingListener VAR_5 = VAR_4.getParsingListener();\n        int VAR_6 = VAR_4.getMaxTokens();\n        int VAR_7 = VAR_4.getMaxRuleDepth();\n        /* COMMENT_0 */\n        ParseTreeListener VAR_8 = new GraphqlBaseListener() {\n            int VAR_9 = 0;\n            int VAR_10 = 0;\n\n\n            @Override\n            public void enterEveryRule(ParserRuleContext VAR_11) {\n                VAR_10++;\n                if (VAR_10 > VAR_7) {\n                    throwIfTokenProblems(\n                            VAR_0,\n                            VAR_11.getStart(),\n                            VAR_7,\n                            VAR_1,\n                            ParseCancelledTooDeepException.class\n                    );\n                }\n            }\n\n            @Override\n            public void exitEveryRule(ParserRuleContext VAR_11) {\n                VAR_10--;\n            }\n\n            @Override\n            public void visitTerminal(TerminalNode VAR_12) {\n\n                final Token VAR_13 = VAR_12.getSymbol();\n                VAR_5.onToken(new ParsingListener.Token() {\n                    @Override\n                    public String getText() {\n                        return VAR_13 == null ? null : VAR_13.getText();\n                    }\n\n                    @Override\n                    public int getLine() {\n                        return VAR_13 == null ? -1 : VAR_13.getLine();\n                    }\n\n                    @Override\n                    public int getCharPositionInLine() {\n                        return VAR_13 == null ? -1 : VAR_13.getCharPositionInLine();\n                    }\n                });\n\n                VAR_9++;\n                if (VAR_9 > VAR_6) {\n                    throwIfTokenProblems(\n                            VAR_0,\n                            VAR_13,\n                            VAR_6,\n                            VAR_1,\n                            ParseCancelledException.class\n                    );\n                }\n            }\n        };\n        VAR_2.addParseListener(VAR_8);\n    }",
  "func_graph_path": "graphql-java/8a1c884c81c0b656db201cfd95881feb0f430a55/Parser.java/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,31 @@\n         ParserOptions parserOptions = toLanguage.getParserOptions();\n         ParsingListener parsingListener = parserOptions.getParsingListener();\n         int maxTokens = parserOptions.getMaxTokens();\n+        int maxRuleDepth = parserOptions.getMaxRuleDepth();\n         // prevent a billion laugh attacks by restricting how many tokens we allow\n         ParseTreeListener listener = new GraphqlBaseListener() {\n             int count = 0;\n+            int depth = 0;\n+\n+\n+            @Override\n+            public void enterEveryRule(ParserRuleContext ctx) {\n+                depth++;\n+                if (depth > maxRuleDepth) {\n+                    throwIfTokenProblems(\n+                            environment,\n+                            ctx.getStart(),\n+                            maxRuleDepth,\n+                            multiSourceReader,\n+                            ParseCancelledTooDeepException.class\n+                    );\n+                }\n+            }\n+\n+            @Override\n+            public void exitEveryRule(ParserRuleContext ctx) {\n+                depth--;\n+            }\n \n             @Override\n             public void visitTerminal(TerminalNode node) {\n@@ -29,7 +51,13 @@\n \n                 count++;\n                 if (count > maxTokens) {\n-                    throwCancelParseIfTooManyTokens(environment, token, maxTokens, multiSourceReader);\n+                    throwIfTokenProblems(\n+                            environment,\n+                            token,\n+                            maxTokens,\n+                            multiSourceReader,\n+                            ParseCancelledException.class\n+                    );\n                 }\n             }\n         };",
  "diff_line_info": {
    "deleted_lines": [
      "                    throwCancelParseIfTooManyTokens(environment, token, maxTokens, multiSourceReader);"
    ],
    "added_lines": [
      "        int maxRuleDepth = parserOptions.getMaxRuleDepth();",
      "            int depth = 0;",
      "",
      "",
      "            @Override",
      "            public void enterEveryRule(ParserRuleContext ctx) {",
      "                depth++;",
      "                if (depth > maxRuleDepth) {",
      "                    throwIfTokenProblems(",
      "                            environment,",
      "                            ctx.getStart(),",
      "                            maxRuleDepth,",
      "                            multiSourceReader,",
      "                            ParseCancelledTooDeepException.class",
      "                    );",
      "                }",
      "            }",
      "",
      "            @Override",
      "            public void exitEveryRule(ParserRuleContext ctx) {",
      "                depth--;",
      "            }",
      "                    throwIfTokenProblems(",
      "                            environment,",
      "                            token,",
      "                            maxTokens,",
      "                            multiSourceReader,",
      "                            ParseCancelledException.class",
      "                    );"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/graphql-java/graphql-java/pull/3112",
  "description": {
    "pr_info": {
      "title": "Preventing stack overflow exceptions via limiting the depth of the parser rules",
      "number": 3112
    },
    "comment": [
      "This puts in a limit on how deep grammar rules can get.  \r\n\r\nAs ANLTR is a **recursive-descent parser** it will build up a call stack as it moves along.  This stack is limited and can blow up with just the wrong input.  Even if the max tokens checking is in place, it can still blow the JVM stack before the max tokens are reached.\r\n\r\nRight now it's 500 deep as presented here.  Is this the right value?  More?? Less ??  I changed it from 1000"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}