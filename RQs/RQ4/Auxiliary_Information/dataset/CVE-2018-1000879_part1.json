{
  "cve_id": "CVE-2018-1000879",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "Skip 0-length ACL fields\n\nCurrently, it is possible to create an archive that crashes bsdtar\nwith a malformed ACL:\n\nProgram received signal SIGSEGV, Segmentation fault.\narchive_acl_from_text_l (acl=<optimised out>, text=0x7e2e92 \"\", want_type=<optimised out>, sc=<optimised out>) at libarchive/archive_acl.c:1726\n1726\t\t\t\tswitch (*s) {\n(gdb) p n\n$1 = 1\n(gdb) p field[n]\n$2 = {start = 0x0, end = 0x0}\n\nStop this by checking that the length is not zero before beginning\nthe switch statement.\n\nI am pretty sure this is the bug mentioned in the qsym paper [1],\nand I was able to replicate it with a qsym + AFL + afl-rb setup.\n\n[1] https://www.usenix.org/conference/usenixsecurity18/presentation/yun",
  "commit_hash": "15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175",
  "git_url": "https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175",
  "file_path": "libarchive/archive_acl.c",
  "func_name": "archive_acl_from_text_l",
  "func_before": "int\narchive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:user::rwx\"\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \"defaultuser::rwx\" is the default ACL corresponding\n\t\t\t * to \"user::rwx\", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ser\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"roup\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"ther\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ask\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \"other:rwx\" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \"user\", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \"group\", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \"deny\", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \"allow\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}",
  "abstract_func_before": "int\narchive_acl_from_text_l(struct archive_acl *VAR_0, const char *VAR_1,\n    int VAR_2, struct archive_string_conv *VAR_3)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} VAR_4[6], VAR_5;\n\n\tconst char *VAR_6, *VAR_7;\n\tint VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13;\n\tint VAR_14, VAR_15, VAR_16, VAR_17, VAR_18;\n\tsize_t VAR_19;\n\tchar VAR_20;\n\n\tswitch (VAR_2) {\n\tcase VAR_21:\n\t\tVAR_2 = VAR_22;\n\t\tVAR_23;\n\tcase VAR_22:\n\tcase VAR_24:\n\t\tVAR_8 = 5;\n\t\tbreak;\n\tcase VAR_25:\n\t\tVAR_8 = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (VAR_26);\n\t}\n\n\tVAR_13 = VAR_27;\n\tVAR_15 = 0;\n\n\twhile (VAR_1 != NULL &&  *VAR_1 != '\\0') {\n\t\t/* COMMENT_0 */\n                                            \n                                           \n     \n\t\tVAR_9 = 0;\n\t\tdo {\n\t\t\tconst char *VAR_28, *VAR_29;\n\t\t\tnext_field(&VAR_1, &VAR_28, &VAR_29, &VAR_20);\n\t\t\tif (VAR_9 < VAR_8) {\n\t\t\t\tVAR_4[VAR_9].start = VAR_28;\n\t\t\t\tVAR_4[VAR_9].end = VAR_29;\n\t\t\t}\n\t\t\t++VAR_9;\n\t\t} while (VAR_20 == ':');\n\n\t\t/* COMMENT_4 */\n\t\tfor (VAR_10 = VAR_9; VAR_10 < VAR_8; ++VAR_10)\n\t\t\tVAR_4[VAR_10].start = VAR_4[VAR_10].end = NULL;\n\n\t\tif (VAR_4[0].start != NULL && *(VAR_4[0].start) == '#') {\n\t\t\t/* COMMENT_5 */\n\t\t\tcontinue;\n\t\t}\n\n\t\tVAR_10 = 0;\n\t\tVAR_12 = 0;\n\t\tVAR_18 = -1;\n\t\tVAR_17 = 0;\n\t\tVAR_5.start = VAR_5.end = NULL;\n\n\t\tif (VAR_2 != VAR_25) {\n\t\t\t/* COMMENT_6 */\n\t\t\t/* COMMENT_7 */\n                                         \n                                      \n     \n                                            \n                                                         \n                                                     \n      \n\t\t\tVAR_6 = VAR_4[0].start;\n\t\t\tVAR_19 = VAR_4[0].end - VAR_4[0].start;\n\t\t\tif (*VAR_6 == 'd' && (VAR_19 == 1 || (VAR_19 >= 7\n\t\t\t    && memcmp((VAR_6 + 1), \"efault\", 6) == 0))) {\n\t\t\t\tVAR_14 = VAR_24;\n\t\t\t\tif (VAR_19 > 7)\n\t\t\t\t\tVAR_4[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tVAR_10 = 1;\n\t\t\t} else\n\t\t\t\tVAR_14 = VAR_2;\n\n\t\t\t/* COMMENT_15 */\n\t\t\tisint(VAR_4[VAR_10 + 1].start, VAR_4[VAR_10 + 1].end, &VAR_18);\n\t\t\t/* COMMENT_16 */\n\t\t\tif (VAR_18 == -1 && VAR_9 > (VAR_10 + 3))\n\t\t\t\tisint(VAR_4[VAR_10 + 3].start, VAR_4[VAR_10 + 3].end,\n\t\t\t\t    &VAR_18);\n\n\t\t\tVAR_16 = 0;\n\t\t\tVAR_6 = VAR_4[VAR_10].start;\n\t\t\tVAR_7 = VAR_4[VAR_10].start + 1;\n\t\t\tVAR_19 = VAR_4[VAR_10].end - VAR_4[VAR_10].start;\n\n\t\t\tswitch (*VAR_6) {\n\t\t\tcase 'u':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 4\n\t\t\t\t    && memcmp(VAR_7, \"ser\", 3) == 0))\n\t\t\t\t\tVAR_16 = VAR_30;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 5\n\t\t\t\t    && memcmp(VAR_7, \"roup\", 4) == 0))\n\t\t\t\t\tVAR_16 = VAR_31;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 5\n\t\t\t\t    && memcmp(VAR_7, \"ther\", 4) == 0))\n\t\t\t\t\tVAR_16 = VAR_32;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 4\n\t\t\t\t    && memcmp(VAR_7, \"ask\", 3) == 0))\n\t\t\t\t\tVAR_16 = VAR_33;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (VAR_16) {\n\t\t\tcase VAR_32:\n\t\t\tcase VAR_33:\n\t\t\t\tif (VAR_9 == (VAR_10 + 2)\n\t\t\t\t    && VAR_4[VAR_10 + 1].start < VAR_4[VAR_10 + 1].end\n\t\t\t\t    && ismode(VAR_4[VAR_10 + 1].start,\n\t\t\t\t    VAR_4[VAR_10 + 1].end, &VAR_17)) {\n\t\t\t\t\t/* COMMENT_17 */\n\t\t\t\t\tVAR_12 = 1;\n\t\t\t\t} else if (VAR_9 == (VAR_10 + 3) &&\n\t\t\t\t    VAR_4[VAR_10 + 1].start < VAR_4[VAR_10 + 1].end) {\n\t\t\t\t\t/* COMMENT_18 */\n\t\t\t\t\tVAR_13 = VAR_34;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_30:\n\t\t\tcase VAR_31:\n\t\t\t\tif (VAR_18 != -1 ||\n\t\t\t\t    VAR_4[VAR_10 + 1].start < VAR_4[VAR_10 + 1].end) {\n\t\t\t\t\tVAR_5 = VAR_4[VAR_10 + 1];\n\t\t\t\t\tif (VAR_16 == VAR_30)\n\t\t\t\t\t\tVAR_16 = VAR_35;\n\t\t\t\t\telse\n\t\t\t\t\t\tVAR_16 = VAR_36;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tVAR_13 = VAR_34;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* COMMENT_20 */\n                                                  \n                                              \n      \n\t\t\tif (VAR_17 == 0 && !ismode(VAR_4[VAR_10 + 2 - VAR_12].start,\n\t\t\t    VAR_4[VAR_10 + 2 - VAR_12].end, &VAR_17)) {\n\t\t\t\t/* COMMENT_24 */\n\t\t\t\tVAR_13 = VAR_34;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* COMMENT_25 */\n\t\t\tVAR_6 = VAR_4[0].start;\n\t\t\tVAR_19 = VAR_4[0].end - VAR_4[0].start;\n\t\t\tVAR_16 = 0;\n\n\t\t\tswitch (VAR_19) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(VAR_6, \"user\", 4) == 0)\n\t\t\t\t\tVAR_16 = VAR_35;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(VAR_6, \"group\", 5) == 0)\n\t\t\t\t\tVAR_16 = VAR_36;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(VAR_6, \"owner@\", 6) == 0)\n\t\t\t\t\tVAR_16 = VAR_30;\n\t\t\t\telse if (memcmp(VAR_6, \"group@\", 6) == 0)\n\t\t\t\t\tVAR_16 = VAR_31;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(VAR_6, \"everyone@\", 9) == 0)\n\t\t\t\t\tVAR_16 = VAR_37;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (VAR_16 == 0) {\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tVAR_13 = VAR_34;\n\t\t\t\tcontinue;\n\t\t\t} else if (VAR_16 == VAR_35 ||\n\t\t\t    VAR_16 == VAR_36) {\n\t\t\t\tVAR_10 = 1;\n\t\t\t\tVAR_5 = VAR_4[1];\n\t\t\t\tisint(VAR_5.start, VAR_5.end, &VAR_18);\n\t\t\t} else\n\t\t\t\tVAR_10 = 0;\n\n\t\t\tif (!is_nfs4_perms(VAR_4[1 + VAR_10].start,\n\t\t\t    VAR_4[1 + VAR_10].end, &VAR_17)) {\n\t\t\t\t/* COMMENT_26 */\n\t\t\t\tVAR_13 = VAR_34;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(VAR_4[2 + VAR_10].start,\n\t\t\t    VAR_4[2 + VAR_10].end, &VAR_17)) {\n\t\t\t\t/* COMMENT_27 */\n\t\t\t\tVAR_13 = VAR_34;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_6 = VAR_4[3 + VAR_10].start;\n\t\t\tVAR_19 = VAR_4[3 + VAR_10].end - VAR_4[3 + VAR_10].start;\n\t\t\tVAR_14 = 0;\n\t\t\tif (VAR_19 == 4) {\n\t\t\t\tif (memcmp(VAR_6, \"deny\", 4) == 0)\n\t\t\t\t\tVAR_14 = VAR_38;\n\t\t\t} else if (VAR_19 == 5) {\n\t\t\t\tif (memcmp(VAR_6, \"allow\", 5) == 0)\n\t\t\t\t\tVAR_14 = VAR_39;\n\t\t\t\telse if (memcmp(VAR_6, \"audit\", 5) == 0)\n\t\t\t\t\tVAR_14 = VAR_40;\n\t\t\t\telse if (memcmp(VAR_6, \"alarm\", 5) == 0)\n\t\t\t\t\tVAR_14 = VAR_41;\n\t\t\t}\n\t\t\tif (VAR_14 == 0) {\n\t\t\t\t/* COMMENT_28 */\n\t\t\t\tVAR_13 = VAR_34;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(VAR_4[4 + VAR_10].start, VAR_4[4 + VAR_10].end,\n\t\t\t    &VAR_18);\n\t\t}\n\n\t\t/* COMMENT_29 */\n\t\tVAR_11 = archive_acl_add_entry_len_l(VAR_0, VAR_14, VAR_17,\n\t\t    VAR_16, VAR_18, VAR_5.start, VAR_5.end - VAR_5.start, VAR_3);\n\t\tif (VAR_11 < VAR_34)\n\t\t\treturn (VAR_11);\n\t\tif (VAR_11 != VAR_27)\n\t\t\tVAR_13 = VAR_34;\n\t\tVAR_15 |= VAR_14;\n\t}\n\n\t/* COMMENT_30 */\n\tarchive_acl_reset(VAR_0, VAR_15);\n\n\treturn (VAR_13);\n}",
  "func_graph_path_before": "libarchive/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175/archive_acl.c/vul/before/0.json",
  "func": "int\narchive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \"default:user::rwx\"\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \"defaultuser::rwx\" is the default ACL corresponding\n\t\t\t * to \"user::rwx\", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \"efault\", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tif (len == 0) {\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ser\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"roup\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \"ther\", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \"ask\", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \"other:rwx\" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \"default:\" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \"user\", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \"group\", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \"owner@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \"group@\", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \"everyone@\", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \"deny\", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \"allow\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \"audit\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \"alarm\", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}",
  "abstract_func": "int\narchive_acl_from_text_l(struct archive_acl *VAR_0, const char *VAR_1,\n    int VAR_2, struct archive_string_conv *VAR_3)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} VAR_4[6], VAR_5;\n\n\tconst char *VAR_6, *VAR_7;\n\tint VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13;\n\tint VAR_14, VAR_15, VAR_16, VAR_17, VAR_18;\n\tsize_t VAR_19;\n\tchar VAR_20;\n\n\tswitch (VAR_2) {\n\tcase VAR_21:\n\t\tVAR_2 = VAR_22;\n\t\tVAR_23;\n\tcase VAR_22:\n\tcase VAR_24:\n\t\tVAR_8 = 5;\n\t\tbreak;\n\tcase VAR_25:\n\t\tVAR_8 = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (VAR_26);\n\t}\n\n\tVAR_13 = VAR_27;\n\tVAR_15 = 0;\n\n\twhile (VAR_1 != NULL &&  *VAR_1 != '\\0') {\n\t\t/* COMMENT_0 */\n                                            \n                                           \n     \n\t\tVAR_9 = 0;\n\t\tdo {\n\t\t\tconst char *VAR_28, *VAR_29;\n\t\t\tnext_field(&VAR_1, &VAR_28, &VAR_29, &VAR_20);\n\t\t\tif (VAR_9 < VAR_8) {\n\t\t\t\tVAR_4[VAR_9].start = VAR_28;\n\t\t\t\tVAR_4[VAR_9].end = VAR_29;\n\t\t\t}\n\t\t\t++VAR_9;\n\t\t} while (VAR_20 == ':');\n\n\t\t/* COMMENT_4 */\n\t\tfor (VAR_10 = VAR_9; VAR_10 < VAR_8; ++VAR_10)\n\t\t\tVAR_4[VAR_10].start = VAR_4[VAR_10].end = NULL;\n\n\t\tif (VAR_4[0].start != NULL && *(VAR_4[0].start) == '#') {\n\t\t\t/* COMMENT_5 */\n\t\t\tcontinue;\n\t\t}\n\n\t\tVAR_10 = 0;\n\t\tVAR_12 = 0;\n\t\tVAR_18 = -1;\n\t\tVAR_17 = 0;\n\t\tVAR_5.start = VAR_5.end = NULL;\n\n\t\tif (VAR_2 != VAR_25) {\n\t\t\t/* COMMENT_6 */\n\t\t\t/* COMMENT_7 */\n                                         \n                                      \n     \n                                            \n                                                         \n                                                     \n      \n\t\t\tVAR_6 = VAR_4[0].start;\n\t\t\tVAR_19 = VAR_4[0].end - VAR_4[0].start;\n\t\t\tif (*VAR_6 == 'd' && (VAR_19 == 1 || (VAR_19 >= 7\n\t\t\t    && memcmp((VAR_6 + 1), \"efault\", 6) == 0))) {\n\t\t\t\tVAR_14 = VAR_24;\n\t\t\t\tif (VAR_19 > 7)\n\t\t\t\t\tVAR_4[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tVAR_10 = 1;\n\t\t\t} else\n\t\t\t\tVAR_14 = VAR_2;\n\n\t\t\t/* COMMENT_15 */\n\t\t\tisint(VAR_4[VAR_10 + 1].start, VAR_4[VAR_10 + 1].end, &VAR_18);\n\t\t\t/* COMMENT_16 */\n\t\t\tif (VAR_18 == -1 && VAR_9 > (VAR_10 + 3))\n\t\t\t\tisint(VAR_4[VAR_10 + 3].start, VAR_4[VAR_10 + 3].end,\n\t\t\t\t    &VAR_18);\n\n\t\t\tVAR_16 = 0;\n\t\t\tVAR_6 = VAR_4[VAR_10].start;\n\t\t\tVAR_7 = VAR_4[VAR_10].start + 1;\n\t\t\tVAR_19 = VAR_4[VAR_10].end - VAR_4[VAR_10].start;\n\n\t\t\tif (VAR_19 == 0) {\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (*VAR_6) {\n\t\t\tcase 'u':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 4\n\t\t\t\t    && memcmp(VAR_7, \"ser\", 3) == 0))\n\t\t\t\t\tVAR_16 = VAR_31;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 5\n\t\t\t\t    && memcmp(VAR_7, \"roup\", 4) == 0))\n\t\t\t\t\tVAR_16 = VAR_32;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 5\n\t\t\t\t    && memcmp(VAR_7, \"ther\", 4) == 0))\n\t\t\t\t\tVAR_16 = VAR_33;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (VAR_19 == 1 || (VAR_19 == 4\n\t\t\t\t    && memcmp(VAR_7, \"ask\", 3) == 0))\n\t\t\t\t\tVAR_16 = VAR_34;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (VAR_16) {\n\t\t\tcase VAR_33:\n\t\t\tcase VAR_34:\n\t\t\t\tif (VAR_9 == (VAR_10 + 2)\n\t\t\t\t    && VAR_4[VAR_10 + 1].start < VAR_4[VAR_10 + 1].end\n\t\t\t\t    && ismode(VAR_4[VAR_10 + 1].start,\n\t\t\t\t    VAR_4[VAR_10 + 1].end, &VAR_17)) {\n\t\t\t\t\t/* COMMENT_17 */\n\t\t\t\t\tVAR_12 = 1;\n\t\t\t\t} else if (VAR_9 == (VAR_10 + 3) &&\n\t\t\t\t    VAR_4[VAR_10 + 1].start < VAR_4[VAR_10 + 1].end) {\n\t\t\t\t\t/* COMMENT_18 */\n\t\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_31:\n\t\t\tcase VAR_32:\n\t\t\t\tif (VAR_18 != -1 ||\n\t\t\t\t    VAR_4[VAR_10 + 1].start < VAR_4[VAR_10 + 1].end) {\n\t\t\t\t\tVAR_5 = VAR_4[VAR_10 + 1];\n\t\t\t\t\tif (VAR_16 == VAR_31)\n\t\t\t\t\t\tVAR_16 = VAR_35;\n\t\t\t\t\telse\n\t\t\t\t\t\tVAR_16 = VAR_36;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* COMMENT_20 */\n                                                  \n                                              \n      \n\t\t\tif (VAR_17 == 0 && !ismode(VAR_4[VAR_10 + 2 - VAR_12].start,\n\t\t\t    VAR_4[VAR_10 + 2 - VAR_12].end, &VAR_17)) {\n\t\t\t\t/* COMMENT_24 */\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* COMMENT_25 */\n\t\t\tVAR_6 = VAR_4[0].start;\n\t\t\tVAR_19 = VAR_4[0].end - VAR_4[0].start;\n\t\t\tVAR_16 = 0;\n\n\t\t\tswitch (VAR_19) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(VAR_6, \"user\", 4) == 0)\n\t\t\t\t\tVAR_16 = VAR_35;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(VAR_6, \"group\", 5) == 0)\n\t\t\t\t\tVAR_16 = VAR_36;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(VAR_6, \"owner@\", 6) == 0)\n\t\t\t\t\tVAR_16 = VAR_31;\n\t\t\t\telse if (memcmp(VAR_6, \"group@\", 6) == 0)\n\t\t\t\t\tVAR_16 = VAR_32;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(VAR_6, \"everyone@\", 9) == 0)\n\t\t\t\t\tVAR_16 = VAR_37;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (VAR_16 == 0) {\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tcontinue;\n\t\t\t} else if (VAR_16 == VAR_35 ||\n\t\t\t    VAR_16 == VAR_36) {\n\t\t\t\tVAR_10 = 1;\n\t\t\t\tVAR_5 = VAR_4[1];\n\t\t\t\tisint(VAR_5.start, VAR_5.end, &VAR_18);\n\t\t\t} else\n\t\t\t\tVAR_10 = 0;\n\n\t\t\tif (!is_nfs4_perms(VAR_4[1 + VAR_10].start,\n\t\t\t    VAR_4[1 + VAR_10].end, &VAR_17)) {\n\t\t\t\t/* COMMENT_26 */\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(VAR_4[2 + VAR_10].start,\n\t\t\t    VAR_4[2 + VAR_10].end, &VAR_17)) {\n\t\t\t\t/* COMMENT_27 */\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_6 = VAR_4[3 + VAR_10].start;\n\t\t\tVAR_19 = VAR_4[3 + VAR_10].end - VAR_4[3 + VAR_10].start;\n\t\t\tVAR_14 = 0;\n\t\t\tif (VAR_19 == 4) {\n\t\t\t\tif (memcmp(VAR_6, \"deny\", 4) == 0)\n\t\t\t\t\tVAR_14 = VAR_38;\n\t\t\t} else if (VAR_19 == 5) {\n\t\t\t\tif (memcmp(VAR_6, \"allow\", 5) == 0)\n\t\t\t\t\tVAR_14 = VAR_39;\n\t\t\t\telse if (memcmp(VAR_6, \"audit\", 5) == 0)\n\t\t\t\t\tVAR_14 = VAR_40;\n\t\t\t\telse if (memcmp(VAR_6, \"alarm\", 5) == 0)\n\t\t\t\t\tVAR_14 = VAR_41;\n\t\t\t}\n\t\t\tif (VAR_14 == 0) {\n\t\t\t\t/* COMMENT_28 */\n\t\t\t\tVAR_13 = VAR_30;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(VAR_4[4 + VAR_10].start, VAR_4[4 + VAR_10].end,\n\t\t\t    &VAR_18);\n\t\t}\n\n\t\t/* COMMENT_29 */\n\t\tVAR_11 = archive_acl_add_entry_len_l(VAR_0, VAR_14, VAR_17,\n\t\t    VAR_16, VAR_18, VAR_5.start, VAR_5.end - VAR_5.start, VAR_3);\n\t\tif (VAR_11 < VAR_30)\n\t\t\treturn (VAR_11);\n\t\tif (VAR_11 != VAR_27)\n\t\t\tVAR_13 = VAR_30;\n\t\tVAR_15 |= VAR_14;\n\t}\n\n\t/* COMMENT_30 */\n\tarchive_acl_reset(VAR_0, VAR_15);\n\n\treturn (VAR_13);\n}",
  "func_graph_path": "libarchive/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175/archive_acl.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -96,6 +96,11 @@\n \t\t\tst = field[n].start + 1;\n \t\t\tlen = field[n].end - field[n].start;\n \n+\t\t\tif (len == 0) {\n+\t\t\t\tret = ARCHIVE_WARN;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\tswitch (*s) {\n \t\t\tcase 'u':\n \t\t\t\tif (len == 1 || (len == 4",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t\tif (len == 0) {",
      "\t\t\t\tret = ARCHIVE_WARN;",
      "\t\t\t\tcontinue;",
      "\t\t\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/1105",
  "description": {
    "pr_info": {
      "title": "Fix various crash, memory corruption and infinite loop conditions",
      "number": 1105
    },
    "comment": [
      "I have found some hangs, crashes and memory corruption issues in libarchive.\r\n\r\nTwo are in the RAR decoder. The first (patch 1) is a double-free via a `realloc(area, 0)`. This leads to a crash.\r\n\r\nThe second (patch 2) is memory corruption which seems to arise in ppmd7 decoding. The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives. (This can be done even with a single archive file.) My gut feeling is that someone more skilled than I could cause arbitrary code execution with this, but I cannot say for certain.\r\n\r\nThere is a crash in ACL parsing for tar archives (patch 3). This is a simple NULL dereference leading to a crash.\r\n\r\nThe last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.\r\n\r\nThese were found with a combination of AFL, afl-rb and qsym.",
      "There are some test cases at https://bugs.launchpad.net/ubuntu/+source/libarchive/+bug/1794909\r\n\r\n",
      "I have requested CVEs for these issues through the Distributed Weakness Filing project.",
      "In case someone else is looking for the CVEs, it looks like the assignments are :\r\n- CVE-2018-1000877 for https://github.com/libarchive/libarchive/commit/021efa522ad729ff0f5806c4ce53e4a6cc1daa31\r\n- CVE-2018-1000878 for https://github.com/libarchive/libarchive/commit/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28\r\n- CVE-2018-1000879 for https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175\r\n- CVE-2018-1000880 for https://github.com/libarchive/libarchive/commit/9c84b7426660c09c18cc349f6d70b5f8168b5680"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message addresses a segmentation fault in ACL parsing due to a 0-length field. The code adds a check to skip such cases.\n\n2. **Consistency Check:** The commit message aligns with the code change, which introduces the `len == 0` check to prevent the crash.\n\n3. **Purpose Evaluation:** The change modifies the core logic to handle a crash condition, indicating a bug fix.\n\n4. **Security Vulnerability Assessment:** The patch addresses a crash caused by malformed input, which is a security risk. It was identified using AFL and qsym, tools for finding security issues.\n\n5. **Confidence Scoring:** The information is clear, and the code change directly addresses a security-related crash.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}