{
  "cve_id": "CVE-2019-13226",
  "cwe_ids": [
    "CWE-362",
    "CWE-59"
  ],
  "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "linuxdeepin/deepin-clone",
  "commit_msg": "fix: Do not use the \"/tmp\" directory\n\nhttps://github.com/linuxdeepin/deepin-clone/issues/16\nhttps://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
  "commit_hash": "e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
  "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
  "file_path": "app/src/corelib/helper.cpp",
  "func_name": "Helper::processExec",
  "func_before": "int Helper::processExec(QProcess *process, const QString &command, int timeout, QIODevice::OpenMode mode)\n{\n    m_processStandardOutput.clear();\n    m_processStandardError.clear();\n\n    QEventLoop loop;\n    QTimer timer;\n\n    timer.setSingleShot(true);\n    timer.setInterval(timeout);\n\n    timer.connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);\n    loop.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &loop, &QEventLoop::exit);\n\n    // 防止子进程输出信息将管道塞满导致进程阻塞\n    process->connect(process, &QProcess::readyReadStandardError, process, [process] {\n        m_processStandardError.append(process->readAllStandardError());\n    });\n    process->connect(process, &QProcess::readyReadStandardOutput, process, [process] {\n        m_processStandardOutput.append(process->readAllStandardOutput());\n    });\n\n    if (timeout > 0) {\n        timer.start();\n    } else {\n        QTimer::singleShot(10000, process, [process] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(process->program()), qPrintable(process->arguments().join(\" \")),\n                      (int)process->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(process->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(command), timeout);\n\n    process->start(command, mode);\n    process->waitForStarted();\n\n    if (process->error() != QProcess::UnknownError) {\n        dCError(process->errorString());\n\n        return -1;\n    }\n\n    if (process->state() == QProcess::Running) {\n        loop.exec();\n    }\n\n    if (process->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n\n        if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n            process->terminate();\n            process->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    m_processStandardOutput.append(process->readAllStandardOutput());\n    m_processStandardError.append(process->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(command), process->exitCode());\n\n        if (process->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(m_processStandardError), qPrintable(m_processStandardOutput));\n        }\n    }\n\n    return process->exitCode();\n}",
  "abstract_func_before": "int Helper::processExec(QProcess *VAR_0, const QString &VAR_1, int VAR_2, QIODevice::OpenMode VAR_3)\n{\n    VAR_4.clear();\n    VAR_5.clear();\n\n    QEventLoop VAR_6;\n    QTimer VAR_7;\n\n    VAR_7.setSingleShot(true);\n    VAR_7.setInterval(VAR_2);\n\n    VAR_7.connect(&VAR_7, &QTimer::timeout, &VAR_6, &QEventLoop::quit);\n    VAR_6.connect(VAR_0, VAR_8<void(QProcess::*)(int)>(&QProcess::finished), &VAR_6, &QEventLoop::exit);\n\n    /* COMMENT_0 */\n    VAR_0->connect(VAR_0, &QProcess::readyReadStandardError, VAR_0, [VAR_0] {\n        VAR_5.append(VAR_0->readAllStandardError());\n    });\n    VAR_0->connect(VAR_0, &QProcess::readyReadStandardOutput, VAR_0, [VAR_0] {\n        VAR_4.append(VAR_0->readAllStandardOutput());\n    });\n\n    if (VAR_2 > 0) {\n        VAR_7.start();\n    } else {\n        QTimer::singleShot(10000, VAR_0, [VAR_0] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(VAR_0->program()), qPrintable(VAR_0->arguments().join(\" \")),\n                      (int)VAR_0->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(VAR_0->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(VAR_1), VAR_2);\n\n    VAR_0->start(VAR_1, VAR_3);\n    VAR_0->waitForStarted();\n\n    if (VAR_0->error() != QProcess::UnknownError) {\n        dCError(VAR_0->errorString());\n\n        return -1;\n    }\n\n    if (VAR_0->state() == QProcess::Running) {\n        VAR_6.exec();\n    }\n\n    if (VAR_0->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(VAR_1), VAR_2);\n\n        if (QFile::exists(QString(\"/proc/%1\").arg(VAR_0->pid()))) {\n            VAR_0->terminate();\n            VAR_0->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    VAR_4.append(VAR_0->readAllStandardOutput());\n    VAR_5.append(VAR_0->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(VAR_1), VAR_0->exitCode());\n\n        if (VAR_0->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(VAR_5), qPrintable(VAR_4));\n        }\n    }\n\n    return VAR_0->exitCode();\n}",
  "func_graph_path_before": "linuxdeepin/deepin-clone/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab/helper.cpp/vul/before/1.json",
  "func": "int Helper::processExec(QProcess *process, const QString &command, int timeout, QIODevice::OpenMode mode)\n{\n    m_processStandardOutput.clear();\n    m_processStandardError.clear();\n\n    QEventLoop loop;\n    QTimer timer;\n\n    timer.setSingleShot(true);\n    timer.setInterval(timeout);\n\n    timer.connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);\n    loop.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &loop, &QEventLoop::exit);\n\n    // 防止子进程输出信息将管道塞满导致进程阻塞\n    process->connect(process, &QProcess::readyReadStandardError, process, [process] {\n        m_processStandardError.append(process->readAllStandardError());\n    });\n    process->connect(process, &QProcess::readyReadStandardOutput, process, [process] {\n        m_processStandardOutput.append(process->readAllStandardOutput());\n    });\n\n    if (timeout > 0) {\n        timer.start();\n    } else {\n        QTimer::singleShot(10000, process, [process] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(process->program()), qPrintable(process->arguments().join(\" \")),\n                      (int)process->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(process->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(command), timeout);\n\n    process->start(command, mode);\n    process->waitForStarted();\n\n    if (process->error() != QProcess::UnknownError) {\n        dCError(process->errorString());\n\n        return -1;\n    }\n\n    if (process->state() == QProcess::Running) {\n        loop.exec();\n    }\n\n    if (process->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n\n        // QT Bug，某种情况下(未知) QProcess::state 返回的状态有误，导致进程已退出却未能正确获取到其当前状态\n        // 因此,额外通过系统文件判断进程是否还存在\n        if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n            process->terminate();\n            process->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    m_processStandardOutput.append(process->readAllStandardOutput());\n    m_processStandardError.append(process->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(command), process->exitCode());\n\n        if (process->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(m_processStandardError), qPrintable(m_processStandardOutput));\n        }\n    }\n\n    return process->exitCode();\n}",
  "abstract_func": "int Helper::processExec(QProcess *VAR_0, const QString &VAR_1, int VAR_2, QIODevice::OpenMode VAR_3)\n{\n    VAR_4.clear();\n    VAR_5.clear();\n\n    QEventLoop VAR_6;\n    QTimer VAR_7;\n\n    VAR_7.setSingleShot(true);\n    VAR_7.setInterval(VAR_2);\n\n    VAR_7.connect(&VAR_7, &QTimer::timeout, &VAR_6, &QEventLoop::quit);\n    VAR_6.connect(VAR_0, VAR_8<void(QProcess::*)(int)>(&QProcess::finished), &VAR_6, &QEventLoop::exit);\n\n    /* COMMENT_0 */\n    VAR_0->connect(VAR_0, &QProcess::readyReadStandardError, VAR_0, [VAR_0] {\n        VAR_5.append(VAR_0->readAllStandardError());\n    });\n    VAR_0->connect(VAR_0, &QProcess::readyReadStandardOutput, VAR_0, [VAR_0] {\n        VAR_4.append(VAR_0->readAllStandardOutput());\n    });\n\n    if (VAR_2 > 0) {\n        VAR_7.start();\n    } else {\n        QTimer::singleShot(10000, VAR_0, [VAR_0] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(VAR_0->program()), qPrintable(VAR_0->arguments().join(\" \")),\n                      (int)VAR_0->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(VAR_0->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(VAR_1), VAR_2);\n\n    VAR_0->start(VAR_1, VAR_3);\n    VAR_0->waitForStarted();\n\n    if (VAR_0->error() != QProcess::UnknownError) {\n        dCError(VAR_0->errorString());\n\n        return -1;\n    }\n\n    if (VAR_0->state() == QProcess::Running) {\n        VAR_6.exec();\n    }\n\n    if (VAR_0->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(VAR_1), VAR_2);\n\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        if (QFile::exists(QString(\"/proc/%1\").arg(VAR_0->pid()))) {\n            VAR_0->terminate();\n            VAR_0->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    VAR_4.append(VAR_0->readAllStandardOutput());\n    VAR_5.append(VAR_0->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(VAR_1), VAR_0->exitCode());\n\n        if (VAR_0->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(VAR_5), qPrintable(VAR_4));\n        }\n    }\n\n    return VAR_0->exitCode();\n}",
  "func_graph_path": "linuxdeepin/deepin-clone/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab/helper.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,8 @@\n     if (process->state() != QProcess::NotRunning) {\n         dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n \n+        // QT Bug，某种情况下(未知) QProcess::state 返回的状态有误，导致进程已退出却未能正确获取到其当前状态\n+        // 因此,额外通过系统文件判断进程是否还存在\n         if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n             process->terminate();\n             process->waitForFinished();",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        // QT Bug，某种情况下(未知) QProcess::state 返回的状态有误，导致进程已退出却未能正确获取到其当前状态",
      "        // 因此,额外通过系统文件判断进程是否还存在"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/linuxdeepin/deepin-clone/pull/18",
  "description": {
    "pr_info": {
      "title": "修复隐藏的安全隐患",
      "number": 18
    },
    "comment": [
      "任何位置都不在使用 /tmp 目录\r\n所有的命令调用都把命令和参数分开传递给QProcess\n\n<!-- Reviewable:start -->\n---\nThis change is [<img src=\"https://reviewable.io/review_button.svg\" height=\"34\" align=\"absmiddle\" alt=\"Reviewable\"/>](https://reviewable.io/reviews/linuxdeepin/deepin-clone/18)\n<!-- Reviewable:end -->\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 0.8"
}