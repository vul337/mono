{
  "cve_id": "CVE-2024-25679",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "p-quic/pquic",
  "commit_msg": "discard the keys after handshake is done; use the correct original_destination_connection_id; discard the re-transmission packets correctly; limit the active_connection_id",
  "commit_hash": "2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "git_url": "https://github.com/p-quic/pquic/commit/2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "file_path": "picoquic/packet.c",
  "func_name": "picoquic_incoming_segment",
  "func_before": "int picoquic_incoming_segment(\n    picoquic_quic_t* quic,\n    uint8_t* bytes,\n    uint32_t length,\n    uint32_t packet_length,\n    uint32_t * consumed,\n    struct sockaddr* addr_from,\n    struct sockaddr* addr_to,\n    int if_index_to,\n    uint64_t current_time,\n    picoquic_connection_id_t * previous_dest_id,\n    int *new_context_created)\n{\n    int ret = 0;\n    picoquic_cnx_t* cnx = NULL;\n    picoquic_packet_header ph;\n    *new_context_created = 0;\n\n    /* Parse the header and decrypt the packet */\n    ret = picoquic_parse_header_and_decrypt(quic, bytes, length, packet_length, addr_from,\n        current_time, &ph, &cnx, consumed, new_context_created);\n\n    if (cnx != NULL) LOG {\n        PUSH_LOG_CTX(cnx, \"\\\"packet_type\\\": \\\"%s\\\", \\\"pn\\\": %\" PRIu64, picoquic_log_ptype_name(ph.ptype), ph.pn64);\n    }\n\n    /* Verify that the segment coalescing is for the same destination ID */\n    if (ret == 0) {\n        if (picoquic_is_connection_id_null(*previous_dest_id)) {\n            *previous_dest_id = ph.dest_cnx_id;\n        }\n        /* This is commented out because with multipath, we can have coalescing of several destination IDs without having issues... */\n        /*\n        else if (picoquic_compare_connection_id(previous_dest_id, &ph.dest_cnx_id) != 0) {\n            ret = PICOQUIC_ERROR_CNXID_SEGMENT;\n\n        }\n        */\n    }\n\n    /* Log the incoming packet */\n    picoquic_log_decrypted_segment(quic->F_log, 1, cnx, 1, &ph, bytes, (uint32_t)*consumed, ret);\n\n    if (ret == 0) {\n        if (cnx == NULL) {\n            if (ph.version_index < 0 && ph.vn != 0) {\n                /* use the result of parsing to consider version negotiation */\n                picoquic_prepare_version_negotiation(quic, addr_from, addr_to, if_index_to, &ph);\n            }\n            else {\n                /* Unexpected packet. Reject, drop and log. */\n                if (!picoquic_is_connection_id_null(ph.dest_cnx_id)) {\n                    picoquic_process_unexpected_cnxid(quic, length, addr_from, addr_to, if_index_to, &ph);\n                }\n                ret = PICOQUIC_ERROR_DETECTED;\n            }\n        }\n        else {\n            /* TO DO: Find the incoming path */\n            /* TO DO: update each of the incoming functions, since the packet is already decrypted. */\n            /* Hook for performing action when connection received new packet */\n            picoquic_received_packet(cnx, quic->rcv_socket, quic->rcv_tos);\n            picoquic_path_t *path = (picoquic_path_t *) protoop_prepare_and_run_noparam(cnx, &PROTOOP_NOPARAM_GET_INCOMING_PATH, NULL, &ph);\n            picoquic_header_parsed(cnx, &ph, path, *consumed);\n            if (cnx != NULL) LOG {\n                PUSH_LOG_CTX(cnx, \"\\\"path\\\": \\\"%p\\\"\", path);\n            }\n\n            switch (ph.ptype) {\n            case picoquic_packet_version_negotiation:\n                if (cnx->cnx_state == picoquic_state_client_init_sent) {\n                    /* Proceed with version negotiation*/\n                    ret = picoquic_incoming_version_negotiation(\n                        cnx, bytes, length, addr_from, &ph, current_time);\n                }\n                else {\n                    /* This is an unexpected packet. Log and drop.*/\n                    DBG_PRINTF(\"Unexpected packet (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int) ph.pn);\n                    ret = PICOQUIC_ERROR_DETECTED;\n                }\n                break;\n            case picoquic_packet_initial:\n                /* Initial packet: either crypto handshakes or acks. */\n                if (picoquic_compare_connection_id(&ph.dest_cnx_id, &cnx->initial_cnxid) == 0 ||\n                    picoquic_compare_connection_id(&ph.dest_cnx_id, &cnx->path[0]->local_cnxid) == 0) {\n                    /* Verify that the source CID matches expectation */\n                    if (picoquic_is_connection_id_null(cnx->path[0]->remote_cnxid)) {\n                        cnx->path[0]->remote_cnxid = ph.srce_cnx_id;\n                        cnx->path[0]->local_addr_len = (addr_to->sa_family == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);\n                        memcpy(&cnx->path[0]->local_addr, addr_to, cnx->path[0]->local_addr_len);\n                    } else if (picoquic_compare_connection_id(&cnx->path[0]->remote_cnxid, &ph.srce_cnx_id) != 0) {\n                        DBG_PRINTF(\"Error wrong srce cnxid (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                            cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn);\n                        ret = PICOQUIC_ERROR_UNEXPECTED_PACKET;\n                    }\n                    if (ret == 0) {\n                        if (cnx->client_mode == 0) {\n                            /* TODO: finish processing initial connection packet */\n                            cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;\n                            ret = picoquic_incoming_initial(&cnx, bytes,\n                                addr_from, addr_to, if_index_to, &ph, current_time, *new_context_created);\n                        }\n                        else {\n                            /* TODO: this really depends on the current receive epoch */\n                            ret = picoquic_incoming_server_cleartext(cnx, bytes, addr_to, if_index_to, &ph, current_time);\n                        }\n                    }\n                } else {\n                    DBG_PRINTF(\"Error detected (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn);\n                    ret = PICOQUIC_ERROR_DETECTED;\n                }\n                break;\n            case picoquic_packet_retry:\n                /* TODO: server retry is completely revised in the new version. */\n                ret = picoquic_incoming_retry(cnx, bytes, &ph, current_time);\n                break;\n            case picoquic_packet_handshake:\n                if (cnx->client_mode)\n                {\n                    ret = picoquic_incoming_server_cleartext(cnx, bytes, addr_to, if_index_to, &ph, current_time);\n                }\n                else\n                {\n                    ret = picoquic_incoming_client_cleartext(cnx, bytes, &ph, current_time);\n                }\n                break;\n            case picoquic_packet_0rtt_protected:\n                /* TODO : decrypt with 0RTT key */\n                ret = picoquic_incoming_0rtt(cnx, bytes, &ph, current_time);\n                break;\n            case picoquic_packet_1rtt_protected_phi0:\n            case picoquic_packet_1rtt_protected_phi1:\n                ret = picoquic_incoming_encrypted(cnx, bytes, &ph, addr_from, current_time);\n                /* TODO : roll key based on PHI */\n                break;\n            default:\n                /* Packet type error. Log and ignore */\n                DBG_PRINTF(\"Unexpected packet type (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                    cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int) ph.pn);\n                ret = PICOQUIC_ERROR_DETECTED;\n                break;\n            }\n            if (cnx != NULL) LOG {\n                POP_LOG_CTX(cnx);\n            }\n        }\n    } else if (ret == PICOQUIC_ERROR_STATELESS_RESET) {\n        ret = picoquic_incoming_stateless_reset(cnx);\n    }\n\n    if (ret == 0 || ret == PICOQUIC_ERROR_SPURIOUS_REPEAT) {\n        if (cnx != NULL && cnx->cnx_state != picoquic_state_disconnected &&\n            ph.ptype != picoquic_packet_version_negotiation) {\n            /* Mark the sequence number as received */\n            /* FIXME */\n            picoquic_path_t* path_x = picoquic_get_incoming_path(cnx, &ph);\n            ret = picoquic_record_pn_received(cnx, path_x, ph.pc, ph.pn64, current_time);\n        }\n        if (cnx != NULL) {\n            picoquic_cnx_set_next_wake_time(cnx, current_time);\n        }\n    } else if (ret == PICOQUIC_ERROR_DUPLICATE) {\n        /* Bad packets are dropped silently, but duplicates should be acknowledged */\n        if (cnx != NULL) {\n            /* FIXME */\n            picoquic_path_t* path_x = picoquic_get_incoming_path(cnx, &ph);\n            path_x->pkt_ctx[ph.pc].ack_needed = 1;\n        }\n        ret = -1;\n    } else if (ret == PICOQUIC_ERROR_AEAD_CHECK || ret == PICOQUIC_ERROR_INITIAL_TOO_SHORT ||\n        ret == PICOQUIC_ERROR_UNEXPECTED_PACKET || ret == PICOQUIC_ERROR_FNV1A_CHECK ||\n        ret == PICOQUIC_ERROR_CNXID_CHECK ||\n        ret == PICOQUIC_ERROR_RETRY || ret == PICOQUIC_ERROR_DETECTED ||\n        ret == PICOQUIC_ERROR_CONNECTION_DELETED ||\n        ret == PICOQUIC_ERROR_CNXID_SEGMENT) {\n        /* Bad packets are dropped silently */\n\n        DBG_PRINTF(\"Packet (%d) dropped, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (cnx == NULL) ? -1 : cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn,\n            length, ret);\n        ret = -1;\n    } else if (ret == 1) {\n        /* wonder what happened ! */\n        DBG_PRINTF(\"Packet (%d) get ret=1, t: %d, e: %d, pc: %d, pn: %d, l: %d\\n\",\n            (cnx == NULL) ? -1 : cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn, length);\n        ret = -1;\n    } else if (ret != 0) {\n        DBG_PRINTF(\"Packet (%d) error, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (cnx == NULL) ? -1 : cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn, length, ret);\n        ret = -1;\n    }\n\n    if (cnx != NULL) LOG {\n        POP_LOG_CTX(cnx);\n    }\n\n    if (cnx != NULL) {\n        if (!cnx->processed_transport_parameter && cnx->remote_parameters_received) {\n            picoquic_handle_plugin_negotiation(cnx);\n            cnx->processed_transport_parameter = 1;\n        }\n    }\n\n    return ret;\n}",
  "abstract_func_before": "int picoquic_incoming_segment(\n    picoquic_quic_t* VAR_0,\n    uint8_t* VAR_1,\n    uint32_t VAR_2,\n    uint32_t VAR_3,\n    uint32_t * VAR_4,\n    struct sockaddr* VAR_5,\n    struct sockaddr* VAR_6,\n    int VAR_7,\n    uint64_t VAR_8,\n    picoquic_connection_id_t * VAR_9,\n    int *VAR_10)\n{\n    int VAR_11 = 0;\n    picoquic_cnx_t* VAR_12 = NULL;\n    picoquic_packet_header VAR_13;\n    *VAR_10 = 0;\n\n    /* COMMENT_0 */\n    VAR_11 = picoquic_parse_header_and_decrypt(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5,\n        VAR_8, &VAR_13, &VAR_12, VAR_4, VAR_10);\n\n    if (VAR_12 != NULL) VAR_14 {\n        PUSH_LOG_CTX(VAR_12, \"\\\"packet_type\\\": \\\"%s\\\", \\\"pn\\\": %\" VAR_15, picoquic_log_ptype_name(VAR_13.ptype), VAR_13.pn64);\n    }\n\n    /* COMMENT_1 */\n    if (VAR_11 == 0) {\n        if (picoquic_is_connection_id_null(*VAR_9)) {\n            *VAR_9 = VAR_13.dest_cnx_id;\n        }\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n                                                                                          \n                                               \n\n         \n          \n    }\n\n    /* COMMENT_9 */\n    picoquic_log_decrypted_segment(VAR_0->F_log, 1, VAR_12, 1, &VAR_13, VAR_1, (uint32_t)*VAR_4, VAR_11);\n\n    if (VAR_11 == 0) {\n        if (VAR_12 == NULL) {\n            if (VAR_13.version_index < 0 && VAR_13.vn != 0) {\n                /* COMMENT_10 */\n                picoquic_prepare_version_negotiation(VAR_0, VAR_5, VAR_6, VAR_7, &VAR_13);\n            }\n            else {\n                /* COMMENT_11 */\n                if (!picoquic_is_connection_id_null(VAR_13.dest_cnx_id)) {\n                    picoquic_process_unexpected_cnxid(VAR_0, VAR_2, VAR_5, VAR_6, VAR_7, &VAR_13);\n                }\n                VAR_11 = VAR_16;\n            }\n        }\n        else {\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            /* COMMENT_14 */\n            picoquic_received_packet(VAR_12, VAR_0->rcv_socket, VAR_0->rcv_tos);\n            picoquic_path_t *VAR_17 = (picoquic_path_t *) protoop_prepare_and_run_noparam(VAR_12, &VAR_18, NULL, &VAR_13);\n            picoquic_header_parsed(VAR_12, &VAR_13, VAR_17, *VAR_4);\n            if (VAR_12 != NULL) VAR_14 {\n                PUSH_LOG_CTX(VAR_12, \"\\\"path\\\": \\\"%p\\\"\", VAR_17);\n            }\n\n            switch (VAR_13.ptype) {\n            case VAR_19:\n                if (VAR_12->cnx_state == VAR_20) {\n                    /* COMMENT_15 */\n                    VAR_11 = picoquic_incoming_version_negotiation(\n                        VAR_12, VAR_1, VAR_2, VAR_5, &VAR_13, VAR_8);\n                }\n                else {\n                    /* COMMENT_16 */\n                    DBG_PRINTF(\"Unexpected packet (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int) VAR_13.pn);\n                    VAR_11 = VAR_16;\n                }\n                break;\n            case VAR_21:\n                /* COMMENT_17 */\n                if (picoquic_compare_connection_id(&VAR_13.dest_cnx_id, &VAR_12->initial_cnxid) == 0 ||\n                    picoquic_compare_connection_id(&VAR_13.dest_cnx_id, &VAR_12->path[0]->local_cnxid) == 0) {\n                    /* COMMENT_18 */\n                    if (picoquic_is_connection_id_null(VAR_12->path[0]->remote_cnxid)) {\n                        VAR_12->path[0]->remote_cnxid = VAR_13.srce_cnx_id;\n                        VAR_12->path[0]->local_addr_len = (VAR_6->sa_family == VAR_22) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);\n                        memcpy(&VAR_12->path[0]->local_addr, VAR_6, VAR_12->path[0]->local_addr_len);\n                    } else if (picoquic_compare_connection_id(&VAR_12->path[0]->remote_cnxid, &VAR_13.srce_cnx_id) != 0) {\n                        DBG_PRINTF(\"Error wrong srce cnxid (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                            VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn);\n                        VAR_11 = VAR_23;\n                    }\n                    if (VAR_11 == 0) {\n                        if (VAR_12->client_mode == 0) {\n                            /* COMMENT_19 */\n                            VAR_12->local_parameters.original_destination_connection_id = VAR_13.dest_cnx_id;\n                            VAR_11 = picoquic_incoming_initial(&VAR_12, VAR_1,\n                                VAR_5, VAR_6, VAR_7, &VAR_13, VAR_8, *VAR_10);\n                        }\n                        else {\n                            /* COMMENT_20 */\n                            VAR_11 = picoquic_incoming_server_cleartext(VAR_12, VAR_1, VAR_6, VAR_7, &VAR_13, VAR_8);\n                        }\n                    }\n                } else {\n                    DBG_PRINTF(\"Error detected (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn);\n                    VAR_11 = VAR_16;\n                }\n                break;\n            case VAR_24:\n                /* COMMENT_21 */\n                VAR_11 = picoquic_incoming_retry(VAR_12, VAR_1, &VAR_13, VAR_8);\n                break;\n            case VAR_25:\n                if (VAR_12->client_mode)\n                {\n                    VAR_11 = picoquic_incoming_server_cleartext(VAR_12, VAR_1, VAR_6, VAR_7, &VAR_13, VAR_8);\n                }\n                else\n                {\n                    VAR_11 = picoquic_incoming_client_cleartext(VAR_12, VAR_1, &VAR_13, VAR_8);\n                }\n                break;\n            case VAR_26:\n                /* COMMENT_22 */\n                VAR_11 = picoquic_incoming_0rtt(VAR_12, VAR_1, &VAR_13, VAR_8);\n                break;\n            case VAR_27:\n            case VAR_28:\n                VAR_11 = picoquic_incoming_encrypted(VAR_12, VAR_1, &VAR_13, VAR_5, VAR_8);\n                /* COMMENT_23 */\n                break;\n            default:\n                /* COMMENT_24 */\n                DBG_PRINTF(\"Unexpected packet type (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                    VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int) VAR_13.pn);\n                VAR_11 = VAR_16;\n                break;\n            }\n            if (VAR_12 != NULL) VAR_14 {\n                POP_LOG_CTX(VAR_12);\n            }\n        }\n    } else if (VAR_11 == VAR_29) {\n        VAR_11 = picoquic_incoming_stateless_reset(VAR_12);\n    }\n\n    if (VAR_11 == 0 || VAR_11 == VAR_30) {\n        if (VAR_12 != NULL && VAR_12->cnx_state != VAR_31 &&\n            VAR_13.ptype != VAR_19) {\n            /* COMMENT_25 */\n            /* COMMENT_26 */\n            picoquic_path_t* VAR_32 = picoquic_get_incoming_path(VAR_12, &VAR_13);\n            VAR_11 = picoquic_record_pn_received(VAR_12, VAR_32, VAR_13.pc, VAR_13.pn64, VAR_8);\n        }\n        if (VAR_12 != NULL) {\n            picoquic_cnx_set_next_wake_time(VAR_12, VAR_8);\n        }\n    } else if (VAR_11 == VAR_33) {\n        /* COMMENT_27 */\n        if (VAR_12 != NULL) {\n            /* COMMENT_26 */\n            picoquic_path_t* VAR_32 = picoquic_get_incoming_path(VAR_12, &VAR_13);\n            VAR_32->pkt_ctx[VAR_13.pc].ack_needed = 1;\n        }\n        VAR_11 = -1;\n    } else if (VAR_11 == VAR_34 || VAR_11 == VAR_35 ||\n        VAR_11 == VAR_23 || VAR_11 == VAR_36 ||\n        VAR_11 == VAR_37 ||\n        VAR_11 == VAR_38 || VAR_11 == VAR_16 ||\n        VAR_11 == VAR_39 ||\n        VAR_11 == VAR_40) {\n        /* COMMENT_28 */\n\n        DBG_PRINTF(\"Packet (%d) dropped, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (VAR_12 == NULL) ? -1 : VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn,\n            VAR_2, VAR_11);\n        VAR_11 = -1;\n    } else if (VAR_11 == 1) {\n        /* COMMENT_29 */\n        DBG_PRINTF(\"Packet (%d) get ret=1, t: %d, e: %d, pc: %d, pn: %d, l: %d\\n\",\n            (VAR_12 == NULL) ? -1 : VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn, VAR_2);\n        VAR_11 = -1;\n    } else if (VAR_11 != 0) {\n        DBG_PRINTF(\"Packet (%d) error, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (VAR_12 == NULL) ? -1 : VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn, VAR_2, VAR_11);\n        VAR_11 = -1;\n    }\n\n    if (VAR_12 != NULL) VAR_14 {\n        POP_LOG_CTX(VAR_12);\n    }\n\n    if (VAR_12 != NULL) {\n        if (!VAR_12->processed_transport_parameter && VAR_12->remote_parameters_received) {\n            picoquic_handle_plugin_negotiation(VAR_12);\n            VAR_12->processed_transport_parameter = 1;\n        }\n    }\n\n    return VAR_11;\n}",
  "func_graph_path_before": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/packet.c/vul/before/1.json",
  "func": "int picoquic_incoming_segment(\n    picoquic_quic_t* quic,\n    uint8_t* bytes,\n    uint32_t length,\n    uint32_t packet_length,\n    uint32_t * consumed,\n    struct sockaddr* addr_from,\n    struct sockaddr* addr_to,\n    int if_index_to,\n    uint64_t current_time,\n    picoquic_connection_id_t * previous_dest_id,\n    int *new_context_created)\n{\n    int ret = 0;\n    picoquic_cnx_t* cnx = NULL;\n    picoquic_packet_header ph;\n    *new_context_created = 0;\n\n    /* Parse the header and decrypt the packet */\n    ret = picoquic_parse_header_and_decrypt(quic, bytes, length, packet_length, addr_from,\n        current_time, &ph, &cnx, consumed, new_context_created);\n\n    if (cnx != NULL) LOG {\n        PUSH_LOG_CTX(cnx, \"\\\"packet_type\\\": \\\"%s\\\", \\\"pn\\\": %\" PRIu64, picoquic_log_ptype_name(ph.ptype), ph.pn64);\n    }\n\n    /* Verify that the segment coalescing is for the same destination ID */\n    if (ret == 0) {\n        if (picoquic_is_connection_id_null(*previous_dest_id)) {\n            *previous_dest_id = ph.dest_cnx_id;\n        }\n        /* This is commented out because with multipath, we can have coalescing of several destination IDs without having issues... */\n        /*\n        else if (picoquic_compare_connection_id(previous_dest_id, &ph.dest_cnx_id) != 0) {\n            ret = PICOQUIC_ERROR_CNXID_SEGMENT;\n\n        }\n        */\n    }\n\n    /* Log the incoming packet */\n    picoquic_log_decrypted_segment(quic->F_log, 1, cnx, 1, &ph, bytes, (uint32_t)*consumed, ret);\n\n    if (ret == 0) {\n        if (cnx == NULL) {\n            if (ph.version_index < 0 && ph.vn != 0) {\n                /* use the result of parsing to consider version negotiation */\n                picoquic_prepare_version_negotiation(quic, addr_from, addr_to, if_index_to, &ph);\n            }\n            else {\n                /* Unexpected packet. Reject, drop and log. */\n                if (!picoquic_is_connection_id_null(ph.dest_cnx_id)) {\n                    picoquic_process_unexpected_cnxid(quic, length, addr_from, addr_to, if_index_to, &ph);\n                }\n                ret = PICOQUIC_ERROR_DETECTED;\n            }\n        }\n        else {\n            /* TO DO: Find the incoming path */\n            /* TO DO: update each of the incoming functions, since the packet is already decrypted. */\n            /* Hook for performing action when connection received new packet */\n            picoquic_received_packet(cnx, quic->rcv_socket, quic->rcv_tos);\n            picoquic_path_t *path = (picoquic_path_t *) protoop_prepare_and_run_noparam(cnx, &PROTOOP_NOPARAM_GET_INCOMING_PATH, NULL, &ph);\n            picoquic_header_parsed(cnx, &ph, path, *consumed);\n            if (cnx != NULL) LOG {\n                PUSH_LOG_CTX(cnx, \"\\\"path\\\": \\\"%p\\\"\", path);\n            }\n\n            switch (ph.ptype) {\n            case picoquic_packet_version_negotiation:\n                if (cnx->cnx_state == picoquic_state_client_init_sent) {\n                    /* Proceed with version negotiation*/\n                    ret = picoquic_incoming_version_negotiation(\n                        cnx, bytes, length, addr_from, &ph, current_time);\n                }\n                else {\n                    /* This is an unexpected packet. Log and drop.*/\n                    DBG_PRINTF(\"Unexpected packet (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int) ph.pn);\n                    ret = PICOQUIC_ERROR_DETECTED;\n                }\n                break;\n            case picoquic_packet_initial:\n                /* Initial packet: either crypto handshakes or acks. */\n                if (picoquic_compare_connection_id(&ph.dest_cnx_id, &cnx->initial_cnxid) == 0 ||\n                    picoquic_compare_connection_id(&ph.dest_cnx_id, &cnx->path[0]->local_cnxid) == 0) {\n                    /* Verify that the source CID matches expectation */\n                    if (picoquic_is_connection_id_null(cnx->path[0]->remote_cnxid)) {\n                        cnx->path[0]->remote_cnxid = ph.srce_cnx_id;\n                        cnx->path[0]->local_addr_len = (addr_to->sa_family == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);\n                        memcpy(&cnx->path[0]->local_addr, addr_to, cnx->path[0]->local_addr_len);\n                    } else if (picoquic_compare_connection_id(&cnx->path[0]->remote_cnxid, &ph.srce_cnx_id) != 0) {\n                        DBG_PRINTF(\"Error wrong srce cnxid (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                            cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn);\n                        ret = PICOQUIC_ERROR_UNEXPECTED_PACKET;\n                    }\n                    if (ret == 0) {\n                        if (cnx->client_mode == 0) {\n                            /* TODO: finish processing initial connection packet */\n                            if(cnx->local_parameters.original_destination_connection_id.id_len == 0){\n                                cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;\n                            }\n\n                            ret = picoquic_incoming_initial(&cnx, bytes,\n                                addr_from, addr_to, if_index_to, &ph, current_time, *new_context_created);\n                        }\n                        else {\n                            /* TODO: this really depends on the current receive epoch */\n                            ret = picoquic_incoming_server_cleartext(cnx, bytes, addr_to, if_index_to, &ph, current_time);\n                        }\n                    }\n                } else {\n                    DBG_PRINTF(\"Error detected (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn);\n                    ret = PICOQUIC_ERROR_DETECTED;\n                }\n                break;\n            case picoquic_packet_retry:\n                /* TODO: server retry is completely revised in the new version. */\n                ret = picoquic_incoming_retry(cnx, bytes, &ph, current_time);\n                break;\n            case picoquic_packet_handshake:\n                if (cnx->client_mode)\n                {\n                    ret = picoquic_incoming_server_cleartext(cnx, bytes, addr_to, if_index_to, &ph, current_time);\n                }\n                else\n                {\n                    ret = picoquic_incoming_client_cleartext(cnx, bytes, &ph, current_time);\n                    \n                    if (ret == 0 && cnx->crypto_context[2].aead_decrypt != NULL && cnx->crypto_context[2].aead_encrypt != NULL)\n                    {\n                        picoquic_implicit_handshake_ack(cnx, cnx->path[0], picoquic_packet_context_initial, current_time);\n                        picoquic_crypto_context_free(&cnx->crypto_context[0]);\n                    }\n                }\n                break;\n            case picoquic_packet_0rtt_protected:\n                /* TODO : decrypt with 0RTT key */\n                ret = picoquic_incoming_0rtt(cnx, bytes, &ph, current_time);\n                break;\n            case picoquic_packet_1rtt_protected_phi0:\n            case picoquic_packet_1rtt_protected_phi1:\n                ret = picoquic_incoming_encrypted(cnx, bytes, &ph, addr_from, current_time);\n                /* TODO : roll key based on PHI */\n                break;\n            default:\n                /* Packet type error. Log and ignore */\n                DBG_PRINTF(\"Unexpected packet type (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                    cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int) ph.pn);\n                ret = PICOQUIC_ERROR_DETECTED;\n                break;\n            }\n            if (cnx != NULL) LOG {\n                POP_LOG_CTX(cnx);\n            }\n        }\n    } else if (ret == PICOQUIC_ERROR_STATELESS_RESET) {\n        ret = picoquic_incoming_stateless_reset(cnx);\n    }\n\n    if (ret == 0 || ret == PICOQUIC_ERROR_SPURIOUS_REPEAT) {\n        if (cnx != NULL && cnx->cnx_state != picoquic_state_disconnected &&\n            ph.ptype != picoquic_packet_version_negotiation) {\n            /* Mark the sequence number as received */\n            /* FIXME */\n            picoquic_path_t* path_x = picoquic_get_incoming_path(cnx, &ph);\n            ret = picoquic_record_pn_received(cnx, path_x, ph.pc, ph.pn64, current_time);\n        }\n        if (cnx != NULL) {\n            picoquic_cnx_set_next_wake_time(cnx, current_time);\n        }\n    } else if (ret == PICOQUIC_ERROR_DUPLICATE) {\n        /* Bad packets are dropped silently, but duplicates should be acknowledged */\n        if (cnx != NULL) {\n            /* FIXME */\n            picoquic_path_t* path_x = picoquic_get_incoming_path(cnx, &ph);\n            path_x->pkt_ctx[ph.pc].ack_needed = 1;\n        }\n        ret = -1;\n    } else if (ret == PICOQUIC_ERROR_AEAD_CHECK || ret == PICOQUIC_ERROR_INITIAL_TOO_SHORT ||\n        ret == PICOQUIC_ERROR_UNEXPECTED_PACKET || ret == PICOQUIC_ERROR_FNV1A_CHECK ||\n        ret == PICOQUIC_ERROR_CNXID_CHECK ||\n        ret == PICOQUIC_ERROR_RETRY || ret == PICOQUIC_ERROR_DETECTED ||\n        ret == PICOQUIC_ERROR_CONNECTION_DELETED ||\n        ret == PICOQUIC_ERROR_CNXID_SEGMENT) {\n        /* Bad packets are dropped silently */\n\n        DBG_PRINTF(\"Packet (%d) dropped, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (cnx == NULL) ? -1 : cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn,\n            length, ret);\n        ret = -1;\n    } else if (ret == 1) {\n        /* wonder what happened ! */\n        DBG_PRINTF(\"Packet (%d) get ret=1, t: %d, e: %d, pc: %d, pn: %d, l: %d\\n\",\n            (cnx == NULL) ? -1 : cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn, length);\n        ret = -1;\n    } else if (ret != 0) {\n        DBG_PRINTF(\"Packet (%d) error, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (cnx == NULL) ? -1 : cnx->client_mode, ph.ptype, ph.epoch, ph.pc, (int)ph.pn, length, ret);\n        ret = -1;\n    }\n\n    if (cnx != NULL) LOG {\n        POP_LOG_CTX(cnx);\n    }\n\n    if (cnx != NULL) {\n        if (!cnx->processed_transport_parameter && cnx->remote_parameters_received) {\n            picoquic_handle_plugin_negotiation(cnx);\n            cnx->processed_transport_parameter = 1;\n        }\n    }\n\n    return ret;\n}",
  "abstract_func": "int picoquic_incoming_segment(\n    picoquic_quic_t* VAR_0,\n    uint8_t* VAR_1,\n    uint32_t VAR_2,\n    uint32_t VAR_3,\n    uint32_t * VAR_4,\n    struct sockaddr* VAR_5,\n    struct sockaddr* VAR_6,\n    int VAR_7,\n    uint64_t VAR_8,\n    picoquic_connection_id_t * VAR_9,\n    int *VAR_10)\n{\n    int VAR_11 = 0;\n    picoquic_cnx_t* VAR_12 = NULL;\n    picoquic_packet_header VAR_13;\n    *VAR_10 = 0;\n\n    /* COMMENT_0 */\n    VAR_11 = picoquic_parse_header_and_decrypt(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5,\n        VAR_8, &VAR_13, &VAR_12, VAR_4, VAR_10);\n\n    if (VAR_12 != NULL) VAR_14 {\n        PUSH_LOG_CTX(VAR_12, \"\\\"packet_type\\\": \\\"%s\\\", \\\"pn\\\": %\" VAR_15, picoquic_log_ptype_name(VAR_13.ptype), VAR_13.pn64);\n    }\n\n    /* COMMENT_1 */\n    if (VAR_11 == 0) {\n        if (picoquic_is_connection_id_null(*VAR_9)) {\n            *VAR_9 = VAR_13.dest_cnx_id;\n        }\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n                                                                                          \n                                               \n\n         \n          \n    }\n\n    /* COMMENT_9 */\n    picoquic_log_decrypted_segment(VAR_0->F_log, 1, VAR_12, 1, &VAR_13, VAR_1, (uint32_t)*VAR_4, VAR_11);\n\n    if (VAR_11 == 0) {\n        if (VAR_12 == NULL) {\n            if (VAR_13.version_index < 0 && VAR_13.vn != 0) {\n                /* COMMENT_10 */\n                picoquic_prepare_version_negotiation(VAR_0, VAR_5, VAR_6, VAR_7, &VAR_13);\n            }\n            else {\n                /* COMMENT_11 */\n                if (!picoquic_is_connection_id_null(VAR_13.dest_cnx_id)) {\n                    picoquic_process_unexpected_cnxid(VAR_0, VAR_2, VAR_5, VAR_6, VAR_7, &VAR_13);\n                }\n                VAR_11 = VAR_16;\n            }\n        }\n        else {\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            /* COMMENT_14 */\n            picoquic_received_packet(VAR_12, VAR_0->rcv_socket, VAR_0->rcv_tos);\n            picoquic_path_t *VAR_17 = (picoquic_path_t *) protoop_prepare_and_run_noparam(VAR_12, &VAR_18, NULL, &VAR_13);\n            picoquic_header_parsed(VAR_12, &VAR_13, VAR_17, *VAR_4);\n            if (VAR_12 != NULL) VAR_14 {\n                PUSH_LOG_CTX(VAR_12, \"\\\"path\\\": \\\"%p\\\"\", VAR_17);\n            }\n\n            switch (VAR_13.ptype) {\n            case VAR_19:\n                if (VAR_12->cnx_state == VAR_20) {\n                    /* COMMENT_15 */\n                    VAR_11 = picoquic_incoming_version_negotiation(\n                        VAR_12, VAR_1, VAR_2, VAR_5, &VAR_13, VAR_8);\n                }\n                else {\n                    /* COMMENT_16 */\n                    DBG_PRINTF(\"Unexpected packet (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int) VAR_13.pn);\n                    VAR_11 = VAR_16;\n                }\n                break;\n            case VAR_21:\n                /* COMMENT_17 */\n                if (picoquic_compare_connection_id(&VAR_13.dest_cnx_id, &VAR_12->initial_cnxid) == 0 ||\n                    picoquic_compare_connection_id(&VAR_13.dest_cnx_id, &VAR_12->path[0]->local_cnxid) == 0) {\n                    /* COMMENT_18 */\n                    if (picoquic_is_connection_id_null(VAR_12->path[0]->remote_cnxid)) {\n                        VAR_12->path[0]->remote_cnxid = VAR_13.srce_cnx_id;\n                        VAR_12->path[0]->local_addr_len = (VAR_6->sa_family == VAR_22) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);\n                        memcpy(&VAR_12->path[0]->local_addr, VAR_6, VAR_12->path[0]->local_addr_len);\n                    } else if (picoquic_compare_connection_id(&VAR_12->path[0]->remote_cnxid, &VAR_13.srce_cnx_id) != 0) {\n                        DBG_PRINTF(\"Error wrong srce cnxid (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                            VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn);\n                        VAR_11 = VAR_23;\n                    }\n                    if (VAR_11 == 0) {\n                        if (VAR_12->client_mode == 0) {\n                            /* COMMENT_19 */\n                            if(VAR_12->local_parameters.original_destination_connection_id.id_len == 0){\n                                VAR_12->local_parameters.original_destination_connection_id = VAR_13.dest_cnx_id;\n                            }\n\n                            VAR_11 = picoquic_incoming_initial(&VAR_12, VAR_1,\n                                VAR_5, VAR_6, VAR_7, &VAR_13, VAR_8, *VAR_10);\n                        }\n                        else {\n                            /* COMMENT_20 */\n                            VAR_11 = picoquic_incoming_server_cleartext(VAR_12, VAR_1, VAR_6, VAR_7, &VAR_13, VAR_8);\n                        }\n                    }\n                } else {\n                    DBG_PRINTF(\"Error detected (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                        VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn);\n                    VAR_11 = VAR_16;\n                }\n                break;\n            case VAR_24:\n                /* COMMENT_21 */\n                VAR_11 = picoquic_incoming_retry(VAR_12, VAR_1, &VAR_13, VAR_8);\n                break;\n            case VAR_25:\n                if (VAR_12->client_mode)\n                {\n                    VAR_11 = picoquic_incoming_server_cleartext(VAR_12, VAR_1, VAR_6, VAR_7, &VAR_13, VAR_8);\n                }\n                else\n                {\n                    VAR_11 = picoquic_incoming_client_cleartext(VAR_12, VAR_1, &VAR_13, VAR_8);\n                    \n                    if (VAR_11 == 0 && VAR_12->crypto_context[2].aead_decrypt != NULL && VAR_12->crypto_context[2].aead_encrypt != NULL)\n                    {\n                        picoquic_implicit_handshake_ack(VAR_12, VAR_12->path[0], VAR_26, VAR_8);\n                        picoquic_crypto_context_free(&VAR_12->crypto_context[0]);\n                    }\n                }\n                break;\n            case VAR_27:\n                /* COMMENT_22 */\n                VAR_11 = picoquic_incoming_0rtt(VAR_12, VAR_1, &VAR_13, VAR_8);\n                break;\n            case VAR_28:\n            case VAR_29:\n                VAR_11 = picoquic_incoming_encrypted(VAR_12, VAR_1, &VAR_13, VAR_5, VAR_8);\n                /* COMMENT_23 */\n                break;\n            default:\n                /* COMMENT_24 */\n                DBG_PRINTF(\"Unexpected packet type (%d), type: %d, epoch: %d, pc: %d, pn: %d\\n\",\n                    VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int) VAR_13.pn);\n                VAR_11 = VAR_16;\n                break;\n            }\n            if (VAR_12 != NULL) VAR_14 {\n                POP_LOG_CTX(VAR_12);\n            }\n        }\n    } else if (VAR_11 == VAR_30) {\n        VAR_11 = picoquic_incoming_stateless_reset(VAR_12);\n    }\n\n    if (VAR_11 == 0 || VAR_11 == VAR_31) {\n        if (VAR_12 != NULL && VAR_12->cnx_state != VAR_32 &&\n            VAR_13.ptype != VAR_19) {\n            /* COMMENT_25 */\n            /* COMMENT_26 */\n            picoquic_path_t* VAR_33 = picoquic_get_incoming_path(VAR_12, &VAR_13);\n            VAR_11 = picoquic_record_pn_received(VAR_12, VAR_33, VAR_13.pc, VAR_13.pn64, VAR_8);\n        }\n        if (VAR_12 != NULL) {\n            picoquic_cnx_set_next_wake_time(VAR_12, VAR_8);\n        }\n    } else if (VAR_11 == VAR_34) {\n        /* COMMENT_27 */\n        if (VAR_12 != NULL) {\n            /* COMMENT_26 */\n            picoquic_path_t* VAR_33 = picoquic_get_incoming_path(VAR_12, &VAR_13);\n            VAR_33->pkt_ctx[VAR_13.pc].ack_needed = 1;\n        }\n        VAR_11 = -1;\n    } else if (VAR_11 == VAR_35 || VAR_11 == VAR_36 ||\n        VAR_11 == VAR_23 || VAR_11 == VAR_37 ||\n        VAR_11 == VAR_38 ||\n        VAR_11 == VAR_39 || VAR_11 == VAR_16 ||\n        VAR_11 == VAR_40 ||\n        VAR_11 == VAR_41) {\n        /* COMMENT_28 */\n\n        DBG_PRINTF(\"Packet (%d) dropped, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (VAR_12 == NULL) ? -1 : VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn,\n            VAR_2, VAR_11);\n        VAR_11 = -1;\n    } else if (VAR_11 == 1) {\n        /* COMMENT_29 */\n        DBG_PRINTF(\"Packet (%d) get ret=1, t: %d, e: %d, pc: %d, pn: %d, l: %d\\n\",\n            (VAR_12 == NULL) ? -1 : VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn, VAR_2);\n        VAR_11 = -1;\n    } else if (VAR_11 != 0) {\n        DBG_PRINTF(\"Packet (%d) error, t: %d, e: %d, pc: %d, pn: %d, l: %d, ret : %x\\n\",\n            (VAR_12 == NULL) ? -1 : VAR_12->client_mode, VAR_13.ptype, VAR_13.epoch, VAR_13.pc, (int)VAR_13.pn, VAR_2, VAR_11);\n        VAR_11 = -1;\n    }\n\n    if (VAR_12 != NULL) VAR_14 {\n        POP_LOG_CTX(VAR_12);\n    }\n\n    if (VAR_12 != NULL) {\n        if (!VAR_12->processed_transport_parameter && VAR_12->remote_parameters_received) {\n            picoquic_handle_plugin_negotiation(VAR_12);\n            VAR_12->processed_transport_parameter = 1;\n        }\n    }\n\n    return VAR_11;\n}",
  "func_graph_path": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/packet.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -97,7 +97,10 @@\n                     if (ret == 0) {\n                         if (cnx->client_mode == 0) {\n                             /* TODO: finish processing initial connection packet */\n-                            cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;\n+                            if(cnx->local_parameters.original_destination_connection_id.id_len == 0){\n+                                cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;\n+                            }\n+\n                             ret = picoquic_incoming_initial(&cnx, bytes,\n                                 addr_from, addr_to, if_index_to, &ph, current_time, *new_context_created);\n                         }\n@@ -124,6 +127,12 @@\n                 else\n                 {\n                     ret = picoquic_incoming_client_cleartext(cnx, bytes, &ph, current_time);\n+                    \n+                    if (ret == 0 && cnx->crypto_context[2].aead_decrypt != NULL && cnx->crypto_context[2].aead_encrypt != NULL)\n+                    {\n+                        picoquic_implicit_handshake_ack(cnx, cnx->path[0], picoquic_packet_context_initial, current_time);\n+                        picoquic_crypto_context_free(&cnx->crypto_context[0]);\n+                    }\n                 }\n                 break;\n             case picoquic_packet_0rtt_protected:",
  "diff_line_info": {
    "deleted_lines": [
      "                            cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;"
    ],
    "added_lines": [
      "                            if(cnx->local_parameters.original_destination_connection_id.id_len == 0){",
      "                                cnx->local_parameters.original_destination_connection_id = ph.dest_cnx_id;",
      "                            }",
      "",
      "                    ",
      "                    if (ret == 0 && cnx->crypto_context[2].aead_decrypt != NULL && cnx->crypto_context[2].aead_encrypt != NULL)",
      "                    {",
      "                        picoquic_implicit_handshake_ack(cnx, cnx->path[0], picoquic_packet_context_initial, current_time);",
      "                        picoquic_crypto_context_free(&cnx->crypto_context[0]);",
      "                    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/p-quic/pquic/pull/39",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/p-quic/pquic/pull/39: 403 Client Error: Forbidden for url: https://api.github.com/repos/p-quic/pquic/pulls/39",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.6"
}