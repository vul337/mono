{
  "cve_id": "CVE-2023-27590",
  "cwe_ids": [
    "CWE-120",
    "CWE-121"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rizinorg/rizin",
  "commit_msg": "Fix conversion from GDB register profile to rizin profile",
  "commit_hash": "d6196703d89c84467b600ba2692534579dc25ed4",
  "git_url": "https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4",
  "file_path": "librz/reg/profile.c",
  "func_name": "gdb_to_rz_profile",
  "func_before": "static char *gdb_to_rz_profile(const char *gdb) {\n\trz_return_val_if_fail(gdb, NULL);\n\tRzStrBuf *sb = rz_strbuf_new(\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tchar *ptr1, *gptr, *gptr1;\n\tchar name[16], groups[128], type[16];\n\tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n\t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n\tint number, rel, offset, size, type_bits, ret;\n\t// Every line is -\n\t// Name Number Rel Offset Size Type Groups\n\tconst char *ptr = rz_str_trim_head_ro(gdb);\n\n\t// It's possible someone includes the heading line too. Skip it\n\tif (rz_str_startswith(ptr, \"Name\")) {\n\t\tif (!(ptr = strchr(ptr, '\\n'))) {\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr++;\n\t}\n\tfor (;;) {\n\t\t// Skip whitespace at beginning of line and empty lines\n\t\twhile (isspace((ut8)*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ptr1 = strchr(ptr, '\\n'))) {\n\t\t\t*ptr1 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", ptr);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn false;\n\t\t}\n\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name, &number, &rel,\n\t\t\t&offset, &size, type, groups);\n\t\t// Groups is optional, others not\n\t\tif (ret < 6) {\n\t\t\tif (*ptr != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", ptr);\n\t\t\t\trz_strbuf_free(sb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If name is '', then skip\n\t\tif (rz_str_startswith(name, \"''\")) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If size is 0, skip\n\t\tif (size == 0) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\ttype_bits = 0;\n\t\t// Parse group\n\t\tif (ret >= 7) {\n\t\t\tgptr = groups;\n\t\t\twhile (1) {\n\t\t\t\tif ((gptr1 = strchr(gptr, ','))) {\n\t\t\t\t\t*gptr1 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(gptr, \"general\")) {\n\t\t\t\t\ttype_bits |= gpr;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"all\")) {\n\t\t\t\t\ttype_bits |= all;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"save\")) {\n\t\t\t\t\ttype_bits |= save;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"restore\")) {\n\t\t\t\t\ttype_bits |= restore;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"float\")) {\n\t\t\t\t\ttype_bits |= float_;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"sse\")) {\n\t\t\t\t\ttype_bits |= sse;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"mmx\")) {\n\t\t\t\t\ttype_bits |= mmx;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"vector\")) {\n\t\t\t\t\ttype_bits |= vector;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"system\")) {\n\t\t\t\t\ttype_bits |= system;\n\t\t\t\t}\n\t\t\t\tif (!gptr1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgptr = gptr1 + 1;\n\t\t\t}\n\t\t}\n\t\t// If type is not defined, skip\n\t\tif (!*type) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: More mappings between gdb and rizin reg groups. For now, either fpu or gpr\n\t\tif (!(type_bits & sse) && !(type_bits & float_)) {\n\t\t\ttype_bits |= gpr;\n\t\t}\n\t\t// Print line\n\t\trz_strbuf_appendf(sb, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t// Ref: Comment above about more register type mappings\n\t\t\t((type_bits & mmx) || (type_bits & float_) || (type_bits & sse)) ? \"fpu\" : \"gpr\",\n\t\t\tname, size * 8, offset);\n\t\t// Go to next line\n\t\tif (!ptr1) {\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr1 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(sb);\n}",
  "abstract_func_before": "static char *gdb_to_rz_profile(const char *VAR_0) {\n\trz_return_val_if_fail(VAR_0, NULL);\n\tRzStrBuf *VAR_1 = rz_strbuf_new(\"\");\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\tchar *VAR_2, *VAR_3, *VAR_4;\n\tchar VAR_5[16], VAR_6[128], VAR_7[16];\n\tconst int VAR_8 = 1, VAR_9 = 2, VAR_10 = 4, VAR_11 = 8, VAR_12 = 16,\n\t\t  VAR_13 = 32, VAR_14 = 64, VAR_15 = 128, VAR_16 = 256;\n\tint VAR_17, VAR_18, VAR_19, VAR_20, VAR_21, VAR_22;\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tconst char *VAR_23 = rz_str_trim_head_ro(VAR_0);\n\n\t/* COMMENT_2 */\n\tif (rz_str_startswith(VAR_23, \"Name\")) {\n\t\tif (!(VAR_23 = strchr(VAR_23, '\\n'))) {\n\t\t\trz_strbuf_free(VAR_1);\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_23++;\n\t}\n\tfor (;;) {\n\t\t/* COMMENT_3 */\n\t\twhile (isspace((VAR_24)*VAR_23)) {\n\t\t\tVAR_23++;\n\t\t}\n\t\tif (!*VAR_23) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((VAR_2 = strchr(VAR_23, '\\n'))) {\n\t\t\t*VAR_2 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", VAR_23);\n\t\t\trz_strbuf_free(VAR_1);\n\t\t\treturn false;\n\t\t}\n\t\tVAR_22 = sscanf(VAR_23, \" %s %d %d %d %d %s %s\", VAR_5, &VAR_17, &VAR_18,\n\t\t\t&VAR_19, &VAR_20, VAR_7, VAR_6);\n\t\t/* COMMENT_4 */\n\t\tif (VAR_22 < 6) {\n\t\t\tif (*VAR_23 != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", VAR_23);\n\t\t\t\trz_strbuf_free(VAR_1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_23 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* COMMENT_5 */\n\t\tif (rz_str_startswith(VAR_5, \"''\")) {\n\t\t\tif (!VAR_2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_23 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* COMMENT_6 */\n\t\tif (VAR_20 == 0) {\n\t\t\tif (!VAR_2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_23 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_21 = 0;\n\t\t/* COMMENT_7 */\n\t\tif (VAR_22 >= 7) {\n\t\t\tVAR_3 = VAR_6;\n\t\t\twhile (1) {\n\t\t\t\tif ((VAR_4 = strchr(VAR_3, ','))) {\n\t\t\t\t\t*VAR_4 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(VAR_3, \"general\")) {\n\t\t\t\t\tVAR_21 |= VAR_9;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"all\")) {\n\t\t\t\t\tVAR_21 |= VAR_8;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"save\")) {\n\t\t\t\t\tVAR_21 |= VAR_10;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"restore\")) {\n\t\t\t\t\tVAR_21 |= VAR_11;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"float\")) {\n\t\t\t\t\tVAR_21 |= VAR_12;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"sse\")) {\n\t\t\t\t\tVAR_21 |= VAR_13;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"mmx\")) {\n\t\t\t\t\tVAR_21 |= VAR_16;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"vector\")) {\n\t\t\t\t\tVAR_21 |= VAR_14;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"system\")) {\n\t\t\t\t\tVAR_21 |= VAR_15;\n\t\t\t\t}\n\t\t\t\tif (!VAR_4) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_3 = VAR_4 + 1;\n\t\t\t}\n\t\t}\n\t\t/* COMMENT_8 */\n\t\tif (!*VAR_7) {\n\t\t\tif (!VAR_2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_23 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* COMMENT_9 */\n\t\tif (!(VAR_21 & VAR_13) && !(VAR_21 & VAR_12)) {\n\t\t\tVAR_21 |= VAR_9;\n\t\t}\n\t\t/* COMMENT_10 */\n\t\trz_strbuf_appendf(VAR_1, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t/* COMMENT_11 */\n\t\t\t((VAR_21 & VAR_16) || (VAR_21 & VAR_12) || (VAR_21 & VAR_13)) ? \"fpu\" : \"gpr\",\n\t\t\tVAR_5, VAR_20 * 8, VAR_19);\n\t\t/* COMMENT_12 */\n\t\tif (!VAR_2) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_23 = VAR_2 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(VAR_1);\n}",
  "func_graph_path_before": "rizinorg/rizin/d6196703d89c84467b600ba2692534579dc25ed4/profile.c/vul/before/0.json",
  "func": "static char *gdb_to_rz_profile(const char *gdb) {\n\trz_return_val_if_fail(gdb, NULL);\n\tRzStrBuf *sb = rz_strbuf_new(\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tchar *ptr1, *gptr, *gptr1;\n\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ + 1], type[GDB_TYPE_SZ + 1];\n\tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n\t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n\tint number, rel, offset, size, type_bits, ret;\n\t// Every line is -\n\t// Name Number Rel Offset Size Type Groups\n\tconst char *ptr = rz_str_trim_head_ro(gdb);\n\n\t// It's possible someone includes the heading line too. Skip it\n\tif (rz_str_startswith(ptr, \"Name\")) {\n\t\tif (!(ptr = strchr(ptr, '\\n'))) {\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr++;\n\t}\n\tfor (;;) {\n\t\t// Skip whitespace at beginning of line and empty lines\n\t\twhile (isspace((ut8)*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ptr1 = strchr(ptr, '\\n'))) {\n\t\t\t*ptr1 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", ptr);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn false;\n\t\t}\n\t\tret = sscanf(ptr, \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",\n\t\t\tname, &number, &rel, &offset, &size, type, groups);\n\t\t// Groups is optional, others not\n\t\tif (ret < 6) {\n\t\t\tif (*ptr != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", ptr);\n\t\t\t\trz_strbuf_free(sb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If name is '', then skip\n\t\tif (rz_str_startswith(name, \"''\")) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If size is 0, skip\n\t\tif (size == 0) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\ttype_bits = 0;\n\t\t// Parse group\n\t\tif (ret >= 7) {\n\t\t\tgptr = groups;\n\t\t\twhile (1) {\n\t\t\t\tif ((gptr1 = strchr(gptr, ','))) {\n\t\t\t\t\t*gptr1 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(gptr, \"general\")) {\n\t\t\t\t\ttype_bits |= gpr;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"all\")) {\n\t\t\t\t\ttype_bits |= all;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"save\")) {\n\t\t\t\t\ttype_bits |= save;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"restore\")) {\n\t\t\t\t\ttype_bits |= restore;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"float\")) {\n\t\t\t\t\ttype_bits |= float_;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"sse\")) {\n\t\t\t\t\ttype_bits |= sse;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"mmx\")) {\n\t\t\t\t\ttype_bits |= mmx;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"vector\")) {\n\t\t\t\t\ttype_bits |= vector;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"system\")) {\n\t\t\t\t\ttype_bits |= system;\n\t\t\t\t}\n\t\t\t\tif (!gptr1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgptr = gptr1 + 1;\n\t\t\t}\n\t\t}\n\t\t// If type is not defined, skip\n\t\tif (!*type) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: More mappings between gdb and rizin reg groups. For now, either fpu or gpr\n\t\tif (!(type_bits & sse) && !(type_bits & float_)) {\n\t\t\ttype_bits |= gpr;\n\t\t}\n\t\t// Print line\n\t\trz_strbuf_appendf(sb, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t// Ref: Comment above about more register type mappings\n\t\t\t((type_bits & mmx) || (type_bits & float_) || (type_bits & sse)) ? \"fpu\" : \"gpr\",\n\t\t\tname, size * 8, offset);\n\t\t// Go to next line\n\t\tif (!ptr1) {\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr1 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(sb);\n}",
  "abstract_func": "static char *gdb_to_rz_profile(const char *VAR_0) {\n\trz_return_val_if_fail(VAR_0, NULL);\n\tRzStrBuf *VAR_1 = rz_strbuf_new(\"\");\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\tchar *VAR_2, *VAR_3, *VAR_4;\n\tchar VAR_5[VAR_6 + 1], VAR_7[VAR_8 + 1], VAR_9[VAR_10 + 1];\n\tconst int VAR_11 = 1, VAR_12 = 2, VAR_13 = 4, VAR_14 = 8, VAR_15 = 16,\n\t\t  VAR_16 = 32, VAR_17 = 64, VAR_18 = 128, VAR_19 = 256;\n\tint VAR_20, VAR_21, VAR_22, VAR_23, VAR_24, VAR_25;\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tconst char *VAR_26 = rz_str_trim_head_ro(VAR_0);\n\n\t/* COMMENT_2 */\n\tif (rz_str_startswith(VAR_26, \"Name\")) {\n\t\tif (!(VAR_26 = strchr(VAR_26, '\\n'))) {\n\t\t\trz_strbuf_free(VAR_1);\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_26++;\n\t}\n\tfor (;;) {\n\t\t/* COMMENT_3 */\n\t\twhile (isspace((VAR_27)*VAR_26)) {\n\t\t\tVAR_26++;\n\t\t}\n\t\tif (!*VAR_26) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((VAR_2 = strchr(VAR_26, '\\n'))) {\n\t\t\t*VAR_2 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", VAR_26);\n\t\t\trz_strbuf_free(VAR_1);\n\t\t\treturn false;\n\t\t}\n\t\tVAR_25 = sscanf(VAR_26, \" %\" RZ_STR_DEF(VAR_6) \"VAR_28 %VAR_29 %VAR_29 %VAR_29 %VAR_29 %\" RZ_STR_DEF(GDB_TYPE_SZ) \"VAR_28 %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"VAR_28\",\n\t\t\tVAR_5, &VAR_20, &VAR_21, &VAR_22, &VAR_23, VAR_9, VAR_7);\n\t\t/* COMMENT_4 */\n\t\tif (VAR_25 < 6) {\n\t\t\tif (*VAR_26 != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", VAR_26);\n\t\t\t\trz_strbuf_free(VAR_1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_26 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* COMMENT_5 */\n\t\tif (rz_str_startswith(VAR_5, \"''\")) {\n\t\t\tif (!VAR_2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_26 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* COMMENT_6 */\n\t\tif (VAR_23 == 0) {\n\t\t\tif (!VAR_2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_26 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_24 = 0;\n\t\t/* COMMENT_7 */\n\t\tif (VAR_25 >= 7) {\n\t\t\tVAR_3 = VAR_7;\n\t\t\twhile (1) {\n\t\t\t\tif ((VAR_4 = strchr(VAR_3, ','))) {\n\t\t\t\t\t*VAR_4 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(VAR_3, \"general\")) {\n\t\t\t\t\tVAR_24 |= VAR_12;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"all\")) {\n\t\t\t\t\tVAR_24 |= VAR_11;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"save\")) {\n\t\t\t\t\tVAR_24 |= VAR_13;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"restore\")) {\n\t\t\t\t\tVAR_24 |= VAR_14;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"float\")) {\n\t\t\t\t\tVAR_24 |= VAR_15;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"sse\")) {\n\t\t\t\t\tVAR_24 |= VAR_16;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"mmx\")) {\n\t\t\t\t\tVAR_24 |= VAR_19;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"vector\")) {\n\t\t\t\t\tVAR_24 |= VAR_17;\n\t\t\t\t} else if (rz_str_startswith(VAR_3, \"system\")) {\n\t\t\t\t\tVAR_24 |= VAR_18;\n\t\t\t\t}\n\t\t\t\tif (!VAR_4) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_3 = VAR_4 + 1;\n\t\t\t}\n\t\t}\n\t\t/* COMMENT_8 */\n\t\tif (!*VAR_9) {\n\t\t\tif (!VAR_2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_26 = VAR_2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* COMMENT_9 */\n\t\tif (!(VAR_24 & VAR_16) && !(VAR_24 & VAR_15)) {\n\t\t\tVAR_24 |= VAR_12;\n\t\t}\n\t\t/* COMMENT_10 */\n\t\trz_strbuf_appendf(VAR_1, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t/* COMMENT_11 */\n\t\t\t((VAR_24 & VAR_19) || (VAR_24 & VAR_15) || (VAR_24 & VAR_16)) ? \"fpu\" : \"gpr\",\n\t\t\tVAR_5, VAR_23 * 8, VAR_22);\n\t\t/* COMMENT_12 */\n\t\tif (!VAR_2) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_26 = VAR_2 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(VAR_1);\n}",
  "func_graph_path": "rizinorg/rizin/d6196703d89c84467b600ba2692534579dc25ed4/profile.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \t\treturn NULL;\n \t}\n \tchar *ptr1, *gptr, *gptr1;\n-\tchar name[16], groups[128], type[16];\n+\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ + 1], type[GDB_TYPE_SZ + 1];\n \tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n \t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n \tint number, rel, offset, size, type_bits, ret;\n@@ -36,8 +36,8 @@\n \t\t\trz_strbuf_free(sb);\n \t\t\treturn false;\n \t\t}\n-\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name, &number, &rel,\n-\t\t\t&offset, &size, type, groups);\n+\t\tret = sscanf(ptr, \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",\n+\t\t\tname, &number, &rel, &offset, &size, type, groups);\n \t\t// Groups is optional, others not\n \t\tif (ret < 6) {\n \t\t\tif (*ptr != '*') {",
  "diff_line_info": {
    "deleted_lines": [
      "\tchar name[16], groups[128], type[16];",
      "\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name, &number, &rel,",
      "\t\t\t&offset, &size, type, groups);"
    ],
    "added_lines": [
      "\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ + 1], type[GDB_TYPE_SZ + 1];",
      "\t\tret = sscanf(ptr, \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",",
      "\t\t\tname, &number, &rel, &offset, &size, type, groups);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rizinorg/rizin/pull/3422",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/rizinorg/rizin/pull/3422: 403 Client Error: Forbidden for url: https://api.github.com/repos/rizinorg/rizin/pulls/3422",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}