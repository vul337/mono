{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/jcl/common/sun_reflect_ConstantPool.c",
  "func_name": "getMethodAt",
  "func_before": "static jobject\ngetMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjmethodID methodID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9Method *method = NULL;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_HANDLE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INSTANCE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_INSTANCE_METHOD:\n\t\t\t\t/* Check for resolved special first, then try to resolve as virtual, then special and then static */\n\t\t\t\tmethod = ((J9RAMMethodRef *) ramConstantRef)->method;\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tif (0 == vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method)) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tmethod = vmFunctions->resolveSpecialMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\t/* Do not update the cp entry for type J9CPTYPE_INSTANCE_METHOD when resolving the method ref as\n\t\t\t\t\t\t * a static method as this may crash if an invokespecial bytecode targets this cpEntry.  The\n\t\t\t\t\t\t * contract for J9CPTYPE_INSTANCE_METHOD requires that the cpEntry->method will only be a\n\t\t\t\t\t\t * non-static method.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_STATIC_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_STATIC_METHOD:\n\t\t\t\tmethod = ((J9RAMStaticMethodRef *) ramConstantRef)->method;\n\t\t\t\t/* TODO is this the right check for an unresolved method? Can I check against vm->initialMethods.initialStaticMethod */\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tvmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_INTERFACE_METHOD:\n\t\t\t\t/* TODO check for resolved and lookup in itable */\n\t\t\t\tmethod = vmFunctions->resolveInterfaceMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != method) {\n\t\t\t\tmethodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method);\n\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != methodID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\tconst jboolean isStatic = (J9CPTYPE_STATIC_METHOD == cpType) || (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType);\n\t\t\t\treturnValue = (*env)->ToReflectedMethod(env, jlClass, methodID, isStatic);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
  "abstract_func_before": "static jobject\ngetMethodAt(JNIEnv *VAR_0, jobject VAR_1, jint VAR_2, UDATA VAR_3)\n{\n\tjobject VAR_4 = NULL;\n\tJ9VMThread *VAR_5 = (J9VMThread *) VAR_0;\n\tJ9InternalVMFunctions *VAR_6 = VAR_5->javaVM->internalVMFunctions;\n\tSunReflectCPResult VAR_7 = VAR_8;\n\tjmethodID VAR_9 = NULL;\n\tUDATA VAR_10 = VAR_11;\n\n\tif (NULL != VAR_1) {\n\t\tJ9RAMConstantRef *VAR_12 = NULL;\n\t\tjclass VAR_13 = NULL;\n\n\t\tVAR_6->internalEnterVMFromJNI(VAR_5);\n\t\tVAR_7 = getRAMConstantRefAndType(VAR_5, VAR_1, VAR_2, &VAR_10, &VAR_12);\n\t\tif (VAR_14 == VAR_7) {\n\t\t\tJ9Method *VAR_15 = NULL;\n\t\t\tJ9Class *VAR_16 = J9CLASS_FROMCPINTERNALRAMCLASS(VAR_5, VAR_1);\n\t\t\tJ9ConstantPool *VAR_17 = J9_CP_FROM_CLASS(VAR_16);\n\t\t\tswitch (VAR_10) {\n\t\t\tcase VAR_18: /* COMMENT_0 */\n\t\t\tcase VAR_19: /* COMMENT_0 */\n\t\t\tcase VAR_20:\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tVAR_15 = ((J9RAMMethodRef *) VAR_12)->method;\n\t\t\t\tif ((NULL == VAR_15) || (NULL == VAR_15->constantPool)) {\n\t\t\t\t\tif (0 == VAR_6->resolveVirtualMethodRef(VAR_5, VAR_17, VAR_2, VAR_3, &VAR_15)) {\n\t\t\t\t\t\tclearException(VAR_5);\n\t\t\t\t\t\tVAR_15 = VAR_6->resolveSpecialMethodRef(VAR_5, VAR_17, VAR_2, VAR_3);\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL == VAR_15) {\n\t\t\t\t\t\tclearException(VAR_5);\n\t\t\t\t\t\t/* COMMENT_2 */\n                                                                                                  \n                                                                                               \n                           \n         \n\t\t\t\t\t\tVAR_15 = VAR_6->resolveStaticMethodRefInto(VAR_5, VAR_17, VAR_2, VAR_3, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_21: /* COMMENT_0 */\n\t\t\tcase VAR_22:\n\t\t\t\tVAR_15 = ((J9RAMStaticMethodRef *) VAR_12)->method;\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tif ((NULL == VAR_15) || (NULL == VAR_15->constantPool)) {\n\t\t\t\t\tVAR_15 = VAR_6->resolveStaticMethodRef(VAR_5, VAR_17, VAR_2, VAR_3);\n\t\t\t\t\tif (NULL == VAR_15) {\n\t\t\t\t\t\tclearException(VAR_5);\n\t\t\t\t\t\tVAR_6->resolveVirtualMethodRef(VAR_5, VAR_17, VAR_2, VAR_3, &VAR_15);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_23:\n\t\t\t\t/* COMMENT_8 */\n\t\t\t\tVAR_15 = VAR_6->resolveInterfaceMethodRef(VAR_5, VAR_17, VAR_2, VAR_3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tVAR_7 = VAR_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != VAR_15) {\n\t\t\t\tVAR_9 = (jmethodID) VAR_6->getJNIMethodID(VAR_5, VAR_15);\n\t\t\t\tVAR_13 = VAR_6->j9jni_createLocalRef(VAR_0, VAR_16->classObject);\n\t\t\t}\n\t\t}\n\n\t\tVAR_6->internalExitVMToJNI(VAR_5);\n\n\t\tif (NULL != VAR_9) {\n\t\t\tif (NULL != VAR_13) {\n\t\t\t\tconst jboolean VAR_25 = (VAR_21 == VAR_10) || (VAR_22 == VAR_10);\n\t\t\t\tVAR_4 = (*VAR_0)->ToReflectedMethod(VAR_0, VAR_13, VAR_9, VAR_25);\n\t\t\t} else {\n\t\t\t\tVAR_6->throwNativeOOMError(VAR_0, 0, 0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcheckResult(VAR_0, VAR_7);\n\n\treturn VAR_4;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/sun_reflect_ConstantPool.c/vul/before/2.json",
  "func": "static jobject\ngetMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjmethodID methodID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9Method *method = NULL;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_HANDLE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INSTANCE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_INSTANCE_METHOD:\n\t\t\t\t/* Check for resolved special first, then try to resolve as virtual, then special and then static */\n\t\t\t\tmethod = ((J9RAMMethodRef *) ramConstantRef)->method;\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tif (0 == vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method)) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tmethod = vmFunctions->resolveSpecialMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\t/* Do not update the cp entry for type J9CPTYPE_INSTANCE_METHOD when resolving the method ref as\n\t\t\t\t\t\t * a static method as this may crash if an invokespecial bytecode targets this cpEntry.  The\n\t\t\t\t\t\t * contract for J9CPTYPE_INSTANCE_METHOD requires that the cpEntry->method will only be a\n\t\t\t\t\t\t * non-static method.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_STATIC_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_STATIC_METHOD:\n\t\t\t\tmethod = ((J9RAMStaticMethodRef *) ramConstantRef)->method;\n\t\t\t\t/* TODO is this the right check for an unresolved method? Can I check against vm->initialMethods.initialStaticMethod */\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tvmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_INTERFACE_METHOD:\n\t\t\t\t/* TODO check for resolved and lookup in itable */\n\t\t\t\tmethod = vmFunctions->resolveInterfaceMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != method) {\n\t\t\t\tmethodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method);\n\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != methodID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\tconst jboolean isStatic = (J9CPTYPE_STATIC_METHOD == cpType) || (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType);\n\t\t\t\treturnValue = (*env)->ToReflectedMethod(env, jlClass, methodID, isStatic);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
  "abstract_func": "static jobject\ngetMethodAt(JNIEnv *VAR_0, jobject VAR_1, jint VAR_2, UDATA VAR_3)\n{\n\tjobject VAR_4 = NULL;\n\tJ9VMThread *VAR_5 = (J9VMThread *) VAR_0;\n\tJ9InternalVMFunctions *VAR_6 = VAR_5->javaVM->internalVMFunctions;\n\tSunReflectCPResult VAR_7 = VAR_8;\n\tjmethodID VAR_9 = NULL;\n\tUDATA VAR_10 = VAR_11;\n\n\tif (NULL != VAR_1) {\n\t\tJ9RAMConstantRef *VAR_12 = NULL;\n\t\tjclass VAR_13 = NULL;\n\n\t\tVAR_6->internalEnterVMFromJNI(VAR_5);\n\t\tVAR_3 |= (VAR_14 | VAR_15 | VAR_16);\n\t\tVAR_7 = getRAMConstantRefAndType(VAR_5, VAR_1, VAR_2, &VAR_10, &VAR_12);\n\t\tif (VAR_17 == VAR_7) {\n\t\t\tJ9Method *VAR_18 = NULL;\n\t\t\tJ9Class *VAR_19 = J9CLASS_FROMCPINTERNALRAMCLASS(VAR_5, VAR_1);\n\t\t\tJ9ConstantPool *VAR_20 = J9_CP_FROM_CLASS(VAR_19);\n\t\t\tswitch (VAR_10) {\n\t\t\tcase VAR_21: /* COMMENT_0 */\n\t\t\tcase VAR_22: /* COMMENT_0 */\n\t\t\tcase VAR_23:\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tVAR_18 = ((J9RAMMethodRef *) VAR_12)->method;\n\t\t\t\tif ((NULL == VAR_18) || (NULL == VAR_18->constantPool)) {\n\t\t\t\t\tif (0 == VAR_6->resolveVirtualMethodRef(VAR_5, VAR_20, VAR_2, VAR_3, &VAR_18)) {\n\t\t\t\t\t\tclearException(VAR_5);\n\t\t\t\t\t\tVAR_18 = VAR_6->resolveSpecialMethodRef(VAR_5, VAR_20, VAR_2, VAR_3);\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL == VAR_18) {\n\t\t\t\t\t\tclearException(VAR_5);\n\t\t\t\t\t\t/* COMMENT_2 */\n                                                                                                  \n                                                                                               \n                           \n         \n\t\t\t\t\t\tVAR_18 = VAR_6->resolveStaticMethodRefInto(VAR_5, VAR_20, VAR_2, VAR_3, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_24: /* COMMENT_0 */\n\t\t\tcase VAR_25:\n\t\t\t\tVAR_18 = ((J9RAMStaticMethodRef *) VAR_12)->method;\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tif ((NULL == VAR_18) || (NULL == VAR_18->constantPool)) {\n\t\t\t\t\tVAR_18 = VAR_6->resolveStaticMethodRefInto(VAR_5, VAR_20, VAR_2, VAR_3, NULL);\n\t\t\t\t\tif (NULL == VAR_18) {\n\t\t\t\t\t\tclearException(VAR_5);\n\t\t\t\t\t\tVAR_6->resolveVirtualMethodRef(VAR_5, VAR_20, VAR_2, VAR_3, &VAR_18);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_26:\n\t\t\t\t/* COMMENT_8 */\n\t\t\t\tVAR_18 = VAR_6->resolveInterfaceMethodRef(VAR_5, VAR_20, VAR_2, VAR_3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tVAR_7 = VAR_27;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != VAR_18) {\n\t\t\t\tVAR_9 = (jmethodID) VAR_6->getJNIMethodID(VAR_5, VAR_18);\n\t\t\t\tVAR_13 = VAR_6->j9jni_createLocalRef(VAR_0, VAR_19->classObject);\n\t\t\t}\n\t\t}\n\n\t\tVAR_6->internalExitVMToJNI(VAR_5);\n\n\t\tif (NULL != VAR_9) {\n\t\t\tif (NULL != VAR_13) {\n\t\t\t\tconst jboolean VAR_28 = (VAR_24 == VAR_10) || (VAR_25 == VAR_10);\n\t\t\t\tVAR_4 = (*VAR_0)->ToReflectedMethod(VAR_0, VAR_13, VAR_9, VAR_28);\n\t\t\t} else {\n\t\t\t\tVAR_6->throwNativeOOMError(VAR_0, 0, 0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcheckResult(VAR_0, VAR_7);\n\n\treturn VAR_4;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/sun_reflect_ConstantPool.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \t\tjclass jlClass = NULL;\n \n \t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n+\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n \t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n \t\tif (OK == result) {\n \t\t\tJ9Method *method = NULL;\n@@ -45,7 +46,7 @@\n \t\t\t\tmethod = ((J9RAMStaticMethodRef *) ramConstantRef)->method;\n \t\t\t\t/* TODO is this the right check for an unresolved method? Can I check against vm->initialMethods.initialStaticMethod */\n \t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n-\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n+\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n \t\t\t\t\tif (NULL == method) {\n \t\t\t\t\t\tclearException(vmThread);\n \t\t\t\t\t\tvmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags);"
    ],
    "added_lines": [
      "\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);",
      "\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/eclipse-openj9/openj9/pull/12148: 403 Client Error: Forbidden for url: https://api.github.com/repos/eclipse-openj9/openj9/pulls/12148",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}