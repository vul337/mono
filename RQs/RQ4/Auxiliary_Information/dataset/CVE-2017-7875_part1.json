{
  "cve_id": "CVE-2017-7875",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "derf/feh",
  "commit_msg": "Fix double-free/OOB-write while receiving IPC data\n\nIf a malicious client pretends to be the E17 window manager, it is\npossible to trigger an out of boundary heap write while receiving an\nIPC message.\n\nThe length of the already received message is stored in an unsigned\nshort, which overflows after receiving 64 KB of data. It's comparably\nsmall amount of data and therefore achievable for an attacker.\n\nWhen len overflows, realloc() will either be called with a small value\nand therefore chars will be appended out of bounds, or len + 1 will be\nexactly 0, in which case realloc() behaves like free(). This could be\nabused for a later double-free attack as it's even possible to overwrite\nthe free information -- but this depends on the malloc implementation.\n\nSigned-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>",
  "commit_hash": "f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d",
  "git_url": "https://github.com/derf/feh/commit/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d",
  "file_path": "src/wallpaper.c",
  "func_name": "enl_ipc_get",
  "func_before": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}",
  "abstract_func_before": "char *enl_ipc_get(const char *VAR_0)\n{\n\n\tstatic char *VAR_1 = NULL;\n\tstatic unsigned short VAR_2 = 0;\n\tchar VAR_3[13], *VAR_4 = NULL;\n\tregister unsigned char VAR_5;\n\tunsigned char VAR_6;\n\n\tif (VAR_0 == VAR_7) {\n\t\treturn(VAR_7);\n\t}\n\tfor (VAR_5 = 0; VAR_5 < 12; VAR_5++) {\n\t\tVAR_3[VAR_5] = VAR_0[VAR_5];\n\t}\n\tVAR_3[12] = 0;\n\tVAR_6 = strlen(VAR_3);\n\tif (VAR_1 != NULL) {\n\t\tVAR_2 += VAR_6;\n\t\tVAR_1 = (char *) erealloc(VAR_1, VAR_2 + 1);\n\t\tstrcat(VAR_1, VAR_3);\n\t} else {\n\t\tVAR_2 = VAR_6;\n\t\tVAR_1 = (char *) emalloc(VAR_2 + 1);\n\t\tstrcpy(VAR_1, VAR_3);\n\t}\n\tif (VAR_6 < 12) {\n\t\tVAR_4 = VAR_1;\n\t\tVAR_1 = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", VAR_4));\n\t}\n\treturn(VAR_4);\n}",
  "func_graph_path_before": "derf/feh/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d/wallpaper.c/vul/before/0.json",
  "func": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic size_t len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}",
  "abstract_func": "char *enl_ipc_get(const char *VAR_0)\n{\n\n\tstatic char *VAR_1 = NULL;\n\tstatic size_t VAR_2 = 0;\n\tchar VAR_3[13], *VAR_4 = NULL;\n\tregister unsigned char VAR_5;\n\tunsigned char VAR_6;\n\n\tif (VAR_0 == VAR_7) {\n\t\treturn(VAR_7);\n\t}\n\tfor (VAR_5 = 0; VAR_5 < 12; VAR_5++) {\n\t\tVAR_3[VAR_5] = VAR_0[VAR_5];\n\t}\n\tVAR_3[12] = 0;\n\tVAR_6 = strlen(VAR_3);\n\tif (VAR_1 != NULL) {\n\t\tVAR_2 += VAR_6;\n\t\tVAR_1 = (char *) erealloc(VAR_1, VAR_2 + 1);\n\t\tstrcat(VAR_1, VAR_3);\n\t} else {\n\t\tVAR_2 = VAR_6;\n\t\tVAR_1 = (char *) emalloc(VAR_2 + 1);\n\t\tstrcpy(VAR_1, VAR_3);\n\t}\n\tif (VAR_6 < 12) {\n\t\tVAR_4 = VAR_1;\n\t\tVAR_1 = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", VAR_4));\n\t}\n\treturn(VAR_4);\n}",
  "func_graph_path": "derf/feh/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d/wallpaper.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \n \tstatic char *message = NULL;\n-\tstatic unsigned short len = 0;\n+\tstatic size_t len = 0;\n \tchar buff[13], *ret_msg = NULL;\n \tregister unsigned char i;\n \tunsigned char blen;",
  "diff_line_info": {
    "deleted_lines": [
      "\tstatic unsigned short len = 0;"
    ],
    "added_lines": [
      "\tstatic size_t len = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/derf/feh/pull/286",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/derf/feh/pull/286: 403 Client Error: Forbidden for url: https://api.github.com/repos/derf/feh/pulls/286",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses a buffer overflow vulnerability by changing the variable type to prevent overflow, thus fixing a security issue.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}