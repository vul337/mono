{
  "cve_id": "CVE-2018-20406",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "python/cpython",
  "commit_msg": "closes bpo-34656: Avoid relying on signed overflow in _pickle memos. (GH-9261)",
  "commit_hash": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
  "git_url": "https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
  "file_path": "Modules/_pickle.c",
  "func_name": "Unpickler_set_memo",
  "func_before": "static int\nUnpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n{\n    PyObject **new_memo;\n    Py_ssize_t new_memo_size = 0;\n    Py_ssize_t i;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &UnpicklerMemoProxyType) {\n        UnpicklerObject *unpickler =\n            ((UnpicklerMemoProxyObject *)obj)->unpickler;\n\n        new_memo_size = unpickler->memo_size;\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        for (i = 0; i < new_memo_size; i++) {\n            Py_XINCREF(unpickler->memo[i]);\n            new_memo[i] = unpickler->memo[i];\n        }\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo_size = PyDict_GET_SIZE(obj);\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &i, &key, &value)) {\n            Py_ssize_t idx;\n            if (!PyLong_Check(key)) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"memo key must be integers\");\n                goto error;\n            }\n            idx = PyLong_AsSsize_t(key);\n            if (idx == -1 && PyErr_Occurred())\n                goto error;\n            if (idx < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"memo key must be positive integers.\");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(self, idx, value) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"'memo' attribute must be an UnpicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    self->memo_size = new_memo_size;\n    self->memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo_size) {\n        i = new_memo_size;\n        while (--i >= 0) {\n            Py_XDECREF(new_memo[i]);\n        }\n        PyMem_FREE(new_memo);\n    }\n    return -1;\n}",
  "abstract_func_before": "static int\nUnpickler_set_memo(UnpicklerObject *VAR_0, PyObject *VAR_1)\n{\n    PyObject **VAR_2;\n    Py_ssize_t VAR_3 = 0;\n    Py_ssize_t VAR_4;\n\n    if (VAR_1 == NULL) {\n        PyErr_SetString(VAR_5,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(VAR_1) == &VAR_6) {\n        UnpicklerObject *VAR_7 =\n            ((UnpicklerMemoProxyObject *)VAR_1)->unpickler;\n\n        VAR_3 = VAR_7->memo_size;\n        VAR_2 = _Unpickler_NewMemo(VAR_3);\n        if (VAR_2 == NULL)\n            return -1;\n\n        for (VAR_4 = 0; VAR_4 < VAR_3; VAR_4++) {\n            Py_XINCREF(VAR_7->memo[VAR_4]);\n            VAR_2[VAR_4] = VAR_7->memo[VAR_4];\n        }\n    }\n    else if (PyDict_Check(VAR_1)) {\n        Py_ssize_t VAR_4 = 0;\n        PyObject *VAR_8, *VAR_9;\n\n        VAR_3 = PyDict_GET_SIZE(VAR_1);\n        VAR_2 = _Unpickler_NewMemo(VAR_3);\n        if (VAR_2 == NULL)\n            return -1;\n\n        while (PyDict_Next(VAR_1, &VAR_4, &VAR_8, &VAR_9)) {\n            Py_ssize_t VAR_10;\n            if (!PyLong_Check(VAR_8)) {\n                PyErr_SetString(VAR_5,\n                                \"memo key must be integers\");\n                goto error;\n            }\n            VAR_10 = PyLong_AsSsize_t(VAR_8);\n            if (VAR_10 == -1 && PyErr_Occurred())\n                goto error;\n            if (VAR_10 < 0) {\n                PyErr_SetString(VAR_11,\n                                \"memo key must be positive integers.\");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(VAR_0, VAR_10, VAR_9) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(VAR_5,\n                     \"'memo' attribute must be an UnpicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(VAR_1)->tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(VAR_0);\n    VAR_0->memo_size = VAR_3;\n    VAR_0->memo = VAR_2;\n\n    return 0;\n\n  error:\n    if (VAR_3) {\n        VAR_4 = VAR_3;\n        while (--VAR_4 >= 0) {\n            Py_XDECREF(VAR_2[VAR_4]);\n        }\n        PyMem_FREE(VAR_2);\n    }\n    return -1;\n}",
  "func_graph_path_before": "python/cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd/_pickle.c/vul/before/1.json",
  "func": "static int\nUnpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n{\n    PyObject **new_memo;\n    size_t new_memo_size = 0;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &UnpicklerMemoProxyType) {\n        UnpicklerObject *unpickler =\n            ((UnpicklerMemoProxyObject *)obj)->unpickler;\n\n        new_memo_size = unpickler->memo_size;\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        for (size_t i = 0; i < new_memo_size; i++) {\n            Py_XINCREF(unpickler->memo[i]);\n            new_memo[i] = unpickler->memo[i];\n        }\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo_size = PyDict_GET_SIZE(obj);\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &i, &key, &value)) {\n            Py_ssize_t idx;\n            if (!PyLong_Check(key)) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"memo key must be integers\");\n                goto error;\n            }\n            idx = PyLong_AsSsize_t(key);\n            if (idx == -1 && PyErr_Occurred())\n                goto error;\n            if (idx < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"memo key must be positive integers.\");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(self, idx, value) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"'memo' attribute must be an UnpicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    self->memo_size = new_memo_size;\n    self->memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo_size) {\n        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {\n            Py_XDECREF(new_memo[i]);\n        }\n        PyMem_FREE(new_memo);\n    }\n    return -1;\n}",
  "abstract_func": "static int\nUnpickler_set_memo(UnpicklerObject *VAR_0, PyObject *VAR_1)\n{\n    PyObject **VAR_2;\n    size_t VAR_3 = 0;\n\n    if (VAR_1 == NULL) {\n        PyErr_SetString(VAR_4,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(VAR_1) == &VAR_5) {\n        UnpicklerObject *VAR_6 =\n            ((UnpicklerMemoProxyObject *)VAR_1)->unpickler;\n\n        VAR_3 = VAR_6->memo_size;\n        VAR_2 = _Unpickler_NewMemo(VAR_3);\n        if (VAR_2 == NULL)\n            return -1;\n\n        for (size_t VAR_7 = 0; VAR_7 < VAR_3; VAR_7++) {\n            Py_XINCREF(VAR_6->memo[VAR_7]);\n            VAR_2[VAR_7] = VAR_6->memo[VAR_7];\n        }\n    }\n    else if (PyDict_Check(VAR_1)) {\n        Py_ssize_t VAR_7 = 0;\n        PyObject *VAR_8, *VAR_9;\n\n        VAR_3 = PyDict_GET_SIZE(VAR_1);\n        VAR_2 = _Unpickler_NewMemo(VAR_3);\n        if (VAR_2 == NULL)\n            return -1;\n\n        while (PyDict_Next(VAR_1, &VAR_7, &VAR_8, &VAR_9)) {\n            Py_ssize_t VAR_10;\n            if (!PyLong_Check(VAR_8)) {\n                PyErr_SetString(VAR_4,\n                                \"memo key must be integers\");\n                goto error;\n            }\n            VAR_10 = PyLong_AsSsize_t(VAR_8);\n            if (VAR_10 == -1 && PyErr_Occurred())\n                goto error;\n            if (VAR_10 < 0) {\n                PyErr_SetString(VAR_11,\n                                \"memo key must be positive integers.\");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(VAR_0, VAR_10, VAR_9) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(VAR_4,\n                     \"'memo' attribute must be an UnpicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(VAR_1)->tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(VAR_0);\n    VAR_0->memo_size = VAR_3;\n    VAR_0->memo = VAR_2;\n\n    return 0;\n\n  error:\n    if (VAR_3) {\n        for (size_t VAR_7 = VAR_3 - 1; VAR_7 != VAR_12; VAR_7--) {\n            Py_XDECREF(VAR_2[VAR_7]);\n        }\n        PyMem_FREE(VAR_2);\n    }\n    return -1;\n}",
  "func_graph_path": "python/cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd/_pickle.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,7 @@\n Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n {\n     PyObject **new_memo;\n-    Py_ssize_t new_memo_size = 0;\n-    Py_ssize_t i;\n+    size_t new_memo_size = 0;\n \n     if (obj == NULL) {\n         PyErr_SetString(PyExc_TypeError,\n@@ -20,7 +19,7 @@\n         if (new_memo == NULL)\n             return -1;\n \n-        for (i = 0; i < new_memo_size; i++) {\n+        for (size_t i = 0; i < new_memo_size; i++) {\n             Py_XINCREF(unpickler->memo[i]);\n             new_memo[i] = unpickler->memo[i];\n         }\n@@ -68,8 +67,7 @@\n \n   error:\n     if (new_memo_size) {\n-        i = new_memo_size;\n-        while (--i >= 0) {\n+        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {\n             Py_XDECREF(new_memo[i]);\n         }\n         PyMem_FREE(new_memo);",
  "diff_line_info": {
    "deleted_lines": [
      "    Py_ssize_t new_memo_size = 0;",
      "    Py_ssize_t i;",
      "        for (i = 0; i < new_memo_size; i++) {",
      "        i = new_memo_size;",
      "        while (--i >= 0) {"
    ],
    "added_lines": [
      "    size_t new_memo_size = 0;",
      "        for (size_t i = 0; i < new_memo_size; i++) {",
      "        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/cpython/pull/9261",
  "description": {
    "pr_info": {
      "title": "bpo-34656: Avoid relying on signed overflow in _pickle memos.",
      "number": 9261
    },
    "comment": [
      "<!--\r\nThanks for your contribution!\r\nPlease read this comment in its entirety. It's quite important.\r\n\r\n# Pull Request title\r\n\r\nIt should be in the following format:\r\n\r\n```\r\nbpo-NNNN: Summary of the changes made\r\n```\r\n\r\nWhere: bpo-NNNN refers to the issue number in the https://bugs.python.org.\r\n\r\nMost PRs will require an issue number. Trivial changes, like fixing a typo, do not need an issue.\r\n\r\n# Backport Pull Request title\r\n\r\nIf this is a backport PR (PR made against branches other than `master`),\r\nplease ensure that the PR title is in the following format:\r\n\r\n```\r\n[X.Y] <title from the original PR> (GH-NNNN)\r\n```\r\n\r\nWhere: [X.Y] is the branch name, e.g. [3.6].\r\n\r\nGH-NNNN refers to the PR number from `master`.\r\n\r\n-->\r\n\n\n<!-- issue-number: [bpo-1621](https://www.bugs.python.org/issue1621) -->\nhttps://bugs.python.org/issue1621\n<!-- /issue-number -->\n",
      "Thanks @benjaminp for the PR 🌮🎉.. I'm working now to backport this PR to: 3.6, 3.7.\n🐍🍒⛏🤖 ",
      "[GH-9465](https://github.com/python/cpython/pull/9465) is a backport of this pull request to the [3.7 branch](https://github.com/python/cpython/tree/3.7).",
      "[GH-9466](https://github.com/python/cpython/pull/9466) is a backport of this pull request to the [3.6 branch](https://github.com/python/cpython/tree/3.6)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}