{
  "cve_id": "CVE-2022-0476",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix DoS in the minidump parser ##crash\n\n* Reported by lazymio via huntr.dev\n* Reproducer: mdmp-dos",
  "commit_hash": "27fe8031782d3a06c3998eaa94354867864f9f1b",
  "git_url": "https://github.com/radareorg/radare2/commit/27fe8031782d3a06c3998eaa94354867864f9f1b",
  "file_path": "libr/bin/format/mdmp/mdmp.c",
  "func_name": "r_bin_mdmp_init_directory_entry",
  "func_before": "static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tr_strf_buffer (128);\n\tstruct minidump_handle_operation_list handle_operation_list;\n\tstruct minidump_memory_list memory_list;\n\tstruct minidump_memory64_list memory64_list;\n\tstruct minidump_memory_info_list memory_info_list;\n\tstruct minidump_module_list module_list;\n\tstruct minidump_thread_list thread_list;\n\tstruct minidump_thread_ex_list thread_ex_list;\n\tstruct minidump_thread_info_list thread_info_list;\n\tstruct minidump_token_info_list token_info_list;\n\tstruct minidump_unloaded_module_list unloaded_module_list;\n\tut64 offset;\n\tint i, r;\n\n\t/* We could confirm data sizes but a malcious MDMP will always get around\n\t** this! But we can ensure that the data is not outside of the file */\n\tif ((ut64)entry->location.rva + entry->location.data_size > r_buf_size (obj->b)) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_list, sizeof (thread_list));\n\t\tif (r != sizeof (thread_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list.number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list.number_of_modules = r_buf_read_le32_at (obj->b, entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list.number_of_modules),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (module_list);\n\t\tfor (i = 0; i < module_list.number_of_modules; i++) {\n\t\t\tstruct minidump_module *module = R_NEW (struct minidump_module);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_module (obj->b, offset, module);\n\t\t\tr_list_append (obj->streams.modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));\n\t\tif (r != sizeof (memory_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_list);\n\t\tfor (i = 0; i < memory_list.number_of_memory_ranges; i++) {\n\t\t\tstruct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)desc, sizeof (*desc));\n\t\t\tif (r != sizeof (*desc)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = R_NEW (struct minidump_exception_stream);\n\t\tif (!obj->streams.exception) {\n\t\t\tbreak;\n\t\t}\n\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.exception, sizeof (*obj->streams.exception));\n\t\tif (r != sizeof (*obj->streams.exception)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\t\t\t\t   \"ExceptionRecord ExceptionAddress \"\n\t\t\t\t\t\t\t   \"NumberParameters __UnusedAlignment \"\n\t\t\t\t\t\t\t   \"ExceptionInformation\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\t\t\t\t\t  \"ThreadId __Alignment \"\n\t\t\t\t\t\t\t\t  \"(mdmp_exception)ExceptionRecord \"\n\t\t\t\t\t\t\t\t  \"(mdmp_location_descriptor)ThreadContext\",\n\t\t\t0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = R_NEW (struct minidump_system_info);\n\t\tif (!obj->streams.system_info) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));\n\t\tif (r != sizeof (*obj->streams.system_info)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));\n\t\tif (r != sizeof (thread_ex_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tr_strf (\"d[%d]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list.number_of_threads),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (thread_ex_list);\n\t\tfor (i = 0; i < thread_ex_list.number_of_threads; i++) {\n\t\t\tstruct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);\n\t\t\tif (!thread) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)thread, sizeof (*thread));\n\t\t\tif (r != sizeof (*thread)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.ex_threads, thread);\n\t\t\toffset += sizeof (*thread);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tread_memory64_list (obj->b, entry->location.rva, &memory64_list);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tr_strf (\"qq[%\"PFMT64d\"]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list.base_rva;\n\t\toffset = entry->location.rva + sizeof (memory64_list);\n\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges; i++) {\n\t\t\tstruct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_desc (obj->b, offset, desc);\n\t\t\tr_list_append (obj->streams.memories64.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_a) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_a, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_w) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_w, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = R_NEW (struct minidump_handle_data_stream);\n\t\tif (!obj->streams.handle_data) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.handle_data, sizeof (*obj->streams.handle_data));\n\t\tif (r != sizeof (*obj->streams.handle_data)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = R_NEW (struct minidump_function_table_stream);\n\t\tif (!obj->streams.function_table) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.function_table, sizeof (*obj->streams.function_table));\n\t\tif (r != sizeof (*obj->streams.function_table)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));\n\t\tif (r != sizeof (unloaded_module_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (unloaded_module_list);\n\t\tfor (i = 0; i < unloaded_module_list.number_of_entries; i++) {\n\t\t\tstruct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)module, sizeof (*module));\n\t\t\tif (r != sizeof (*module)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.unloaded_modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = R_NEW (struct minidump_misc_info);\n\t\tif (!obj->streams.misc_info.misc_info_1) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.misc_info.misc_info_1, sizeof (*obj->streams.misc_info.misc_info_1));\n\t\tif (r != sizeof (*obj->streams.misc_info.misc_info_1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_info_list, sizeof (memory_info_list));\n\t\tif (r != sizeof (memory_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tr_strf (\"ddq[%\"PFMT64d\"]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list.number_of_entries),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_info_list);\n\t\tfor (i = 0; i < memory_info_list.number_of_entries; i++) {\n\t\t\tstruct minidump_memory_info *info = R_NEW (struct minidump_memory_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memory_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_info_list, sizeof (thread_info_list));\n\t\tif (r != sizeof (thread_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (thread_info_list);\n\t\tfor (i = 0; i < thread_info_list.number_of_entries; i++) {\n\t\t\tstruct minidump_thread_info *info = R_NEW (struct minidump_thread_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.thread_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&handle_operation_list, sizeof (handle_operation_list));\n\t\tif (r != sizeof (handle_operation_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\toffset = entry->location.rva + sizeof (handle_operation_list);\n\t\tfor (i = 0; i < handle_operation_list.number_of_entries; i++) {\n\t\t\tstruct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)op, sizeof (*op));\n\t\t\tif (r != sizeof (*op)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.operations, op);\n\t\t\toffset += sizeof (*op);\n\t\t}\n\n\t\tbreak;\n\tcase TOKEN_STREAM:\n\t\t/* TODO: Not fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));\n\t\tif (r != sizeof (token_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_token_info.format\", \"ddq \"\n\t\t\t\"TokenSize TokenId TokenHandle\", 0);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_token_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_token_info_list.format\", \"dddd \"\n\t\t\t\"TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize\", 0);\n\n\t\toffset = entry->location.rva + sizeof (token_info_list);\n\t\tfor (i = 0; i < token_info_list.number_of_entries; i++) {\n\t\t\tstruct minidump_token_info *info = R_NEW (struct minidump_token_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.token_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %d\\n\", entry->stream_type);\n\t\tbreak;\n\t}\n\treturn true;\n}",
  "abstract_func_before": "static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *VAR_0, struct minidump_directory *VAR_1) {\n\tr_strf_buffer (128);\n\tstruct minidump_handle_operation_list VAR_2;\n\tstruct minidump_memory_list VAR_3;\n\tstruct minidump_memory64_list VAR_4;\n\tstruct minidump_memory_info_list VAR_5;\n\tstruct minidump_module_list VAR_6;\n\tstruct minidump_thread_list VAR_7;\n\tstruct minidump_thread_ex_list VAR_8;\n\tstruct minidump_thread_info_list VAR_9;\n\tstruct minidump_token_info_list VAR_10;\n\tstruct minidump_unloaded_module_list VAR_11;\n\tut64 VAR_12;\n\tint VAR_13, VAR_14;\n\n\t/* COMMENT_0 */\n                                                                       \n\tif ((ut64)VAR_1->location.rva + VAR_1->location.data_size > r_buf_size (VAR_0->b)) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (VAR_1->stream_type) {\n\tcase VAR_15:\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_7, sizeof (VAR_7));\n\t\tif (VAR_14 != sizeof (VAR_7)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_thread_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tVAR_7.number_of_threads),\n\t\t\t0);\n\n\t\t/* COMMENT_2 */\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_6.number_of_modules = r_buf_read_le32_at (VAR_0->b, VAR_1->location.rva);\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_module_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_module_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tVAR_6.number_of_modules),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_6);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_6.number_of_modules; VAR_13++) {\n\t\t\tstruct minidump_module *VAR_17 = R_NEW (struct minidump_module);\n\t\t\tif (!VAR_17) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_module (VAR_0->b, VAR_12, VAR_17);\n\t\t\tr_list_append (VAR_0->streams.modules, VAR_17);\n\t\t\tVAR_12 += sizeof (*VAR_17);\n\t\t}\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_3, sizeof (VAR_3));\n\t\tif (VAR_14 != sizeof (VAR_3)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_memory_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tVAR_3.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_3);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_3.number_of_memory_ranges; VAR_13++) {\n\t\t\tstruct minidump_memory_descriptor *VAR_19 = R_NEW (struct minidump_memory_descriptor);\n\t\t\tif (!VAR_19) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_19, sizeof (*VAR_19));\n\t\t\tif (VAR_14 != sizeof (*VAR_19)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.memories, VAR_19);\n\t\t\tVAR_12 += sizeof (*VAR_19);\n\t\t}\n\t\tbreak;\n\tcase VAR_20:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.exception = R_NEW (struct VAR_21);\n\t\tif (!VAR_0->streams.exception) {\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.exception, sizeof (*VAR_0->streams.exception));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.exception)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\t\t\t\t   \"ExceptionRecord ExceptionAddress \"\n\t\t\t\t\t\t\t   \"NumberParameters __UnusedAlignment \"\n\t\t\t\t\t\t\t   \"ExceptionInformation\",\n\t\t\t0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_exception_stream.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\t\t\t\t\t  \"ThreadId __Alignment \"\n\t\t\t\t\t\t\t\t  \"(mdmp_exception)ExceptionRecord \"\n\t\t\t\t\t\t\t\t  \"(mdmp_location_descriptor)ThreadContext\",\n\t\t\t0);\n\n\t\tbreak;\n\tcase VAR_22:\n\t\tVAR_0->streams.system_info = R_NEW (struct VAR_23);\n\t\tif (!VAR_0->streams.system_info) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.system_info, sizeof (*VAR_0->streams.system_info));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.system_info)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_system_info.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\t/* COMMENT_3 */\n\t\tsdb_set (VAR_0->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase VAR_24:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_8, sizeof (VAR_8));\n\t\tif (VAR_14 != sizeof (VAR_8)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tr_strf (\"d[%d]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tVAR_8.number_of_threads),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_8);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_8.number_of_threads; VAR_13++) {\n\t\t\tstruct minidump_thread_ex *VAR_25 = R_NEW (struct minidump_thread_ex);\n\t\t\tif (!VAR_25) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_25, sizeof (*VAR_25));\n\t\t\tif (VAR_14 != sizeof (*VAR_25)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.ex_threads, VAR_25);\n\t\t\tVAR_12 += sizeof (*VAR_25);\n\t\t}\n\t\tbreak;\n\tcase VAR_26:\n\t\tread_memory64_list (VAR_0->b, VAR_1->location.rva, &VAR_4);\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_memory64_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory64_list.format\",\n\t\t\tr_strf (\"qq[%\"VAR_27\"]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tVAR_4.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tVAR_0->streams.memories64.base_rva = VAR_4.base_rva;\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_4);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_4.number_of_memory_ranges; VAR_13++) {\n\t\t\tstruct minidump_memory_descriptor64 *VAR_19 = R_NEW (struct minidump_memory_descriptor64);\n\t\t\tif (!VAR_19) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_desc (VAR_0->b, VAR_12, VAR_19);\n\t\t\tr_list_append (VAR_0->streams.memories64.memories, VAR_19);\n\t\t\tVAR_12 += sizeof (*VAR_19);\n\t\t}\n\t\tbreak;\n\tcase VAR_28:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.comments_a = R_NEWS (ut8, VAR_29);\n\t\tif (!VAR_0->streams.comments_a) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_a, VAR_29);\n\t\tif (VAR_14 != VAR_29) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase VAR_30:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.comments_w = R_NEWS (ut8, VAR_29);\n\t\tif (!VAR_0->streams.comments_w) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_w, VAR_29);\n\t\tif (VAR_14 != VAR_29) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase VAR_31:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.handle_data = R_NEW (struct VAR_32);\n\t\tif (!VAR_0->streams.handle_data) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.handle_data, sizeof (*VAR_0->streams.handle_data));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.handle_data)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase VAR_33:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.function_table = R_NEW (struct VAR_34);\n\t\tif (!VAR_0->streams.function_table) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.function_table, sizeof (*VAR_0->streams.function_table));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.function_table)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase VAR_35:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_11, sizeof (VAR_11));\n\t\tif (VAR_14 != sizeof (VAR_11)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_11);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_11.number_of_entries; VAR_13++) {\n\t\t\tstruct minidump_unloaded_module *VAR_17 = R_NEW (struct minidump_unloaded_module);\n\t\t\tif (!VAR_17) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_17, sizeof (*VAR_17));\n\t\t\tif (VAR_14 != sizeof (*VAR_17)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.unloaded_modules, VAR_17);\n\t\t\tVAR_12 += sizeof (*VAR_17);\n\t\t}\n\t\tbreak;\n\tcase VAR_36:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.misc_info.misc_info_1 = R_NEW (struct VAR_37);\n\t\tif (!VAR_0->streams.misc_info.misc_info_1) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.misc_info.misc_info_1, sizeof (*VAR_0->streams.misc_info.misc_info_1));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.misc_info.misc_info_1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_misc_info.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase VAR_38:\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_5, sizeof (VAR_5));\n\t\tif (VAR_14 != sizeof (VAR_5)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory_info_list.format\",\n\t\t\tr_strf (\"ddq[%\"VAR_27\"]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tVAR_5.number_of_entries),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_5);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_5.number_of_entries; VAR_13++) {\n\t\t\tstruct minidump_memory_info *VAR_39 = R_NEW (struct minidump_memory_info);\n\t\t\tif (!VAR_39) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));\n\t\t\tif (VAR_14 != sizeof (*VAR_39)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.memory_infos, VAR_39);\n\t\t\tVAR_12 += sizeof (*VAR_39);\n\t\t}\n\t\tbreak;\n\tcase VAR_40:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_9, sizeof (VAR_9));\n\t\tif (VAR_14 != sizeof (VAR_9)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_9);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_9.number_of_entries; VAR_13++) {\n\t\t\tstruct minidump_thread_info *VAR_39 = R_NEW (struct minidump_thread_info);\n\t\t\tif (!VAR_39) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));\n\t\t\tif (VAR_14 != sizeof (*VAR_39)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.thread_infos, VAR_39);\n\t\t\tVAR_12 += sizeof (*VAR_39);\n\t\t}\n\t\tbreak;\n\tcase VAR_41:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_2, sizeof (VAR_2));\n\t\tif (VAR_14 != sizeof (VAR_2)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_2);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_2.number_of_entries; VAR_13++) {\n\t\t\tstruct avrf_handle_operation *VAR_42 = R_NEW (struct avrf_handle_operation);\n\t\t\tif (!VAR_42) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_42, sizeof (*VAR_42));\n\t\t\tif (VAR_14 != sizeof (*VAR_42)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.operations, VAR_42);\n\t\t\tVAR_12 += sizeof (*VAR_42);\n\t\t}\n\n\t\tbreak;\n\tcase VAR_43:\n\t\t/* COMMENT_5 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_10, sizeof (VAR_10));\n\t\tif (VAR_14 != sizeof (VAR_10)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_token_info.format\", \"ddq \"\n\t\t\t\"TokenSize TokenId TokenHandle\", 0);\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_token_info_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_token_info_list.format\", \"dddd \"\n\t\t\t\"TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_10);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_10.number_of_entries; VAR_13++) {\n\t\t\tstruct minidump_token_info *VAR_39 = R_NEW (struct minidump_token_info);\n\t\t\tif (!VAR_39) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));\n\t\t\tif (VAR_14 != sizeof (*VAR_39)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.token_infos, VAR_39);\n\t\t\tVAR_12 += sizeof (*VAR_39);\n\t\t}\n\t\tbreak;\n\n\tcase VAR_44:\n\t\t/* COMMENT_2 */\n\t\tbreak;\n\tcase VAR_45:\n\tcase VAR_46:\n\tcase VAR_47:\n\t\t/* COMMENT_6 */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %d\\n\", VAR_1->stream_type);\n\t\tbreak;\n\t}\n\treturn true;\n}",
  "func_graph_path_before": "radareorg/radare2/27fe8031782d3a06c3998eaa94354867864f9f1b/mdmp.c/vul/before/1.json",
  "func": "static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {\n\tr_strf_buffer (128);\n\tstruct minidump_handle_operation_list handle_operation_list;\n\tstruct minidump_memory_list memory_list;\n\tstruct minidump_memory64_list memory64_list;\n\tstruct minidump_memory_info_list memory_info_list;\n\tstruct minidump_module_list module_list;\n\tstruct minidump_thread_list thread_list;\n\tstruct minidump_thread_ex_list thread_ex_list;\n\tstruct minidump_thread_info_list thread_info_list;\n\tstruct minidump_token_info_list token_info_list;\n\tstruct minidump_unloaded_module_list unloaded_module_list;\n\tut64 offset;\n\tint i, r;\n\n\t/* We could confirm data sizes but a malcious MDMP will always get around\n\t** this! But we can ensure that the data is not outside of the file */\n\tif ((ut64)entry->location.rva + entry->location.data_size > r_buf_size (obj->b)) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (entry->stream_type) {\n\tcase THREAD_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_list, sizeof (thread_list));\n\t\tif (r != sizeof (thread_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tthread_list.number_of_threads),\n\t\t\t0);\n\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase MODULE_LIST_STREAM:\n\t\tmodule_list.number_of_modules = r_buf_read_le32_at (obj->b, entry->location.rva);\n\n\t\tsdb_set (obj->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_module_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tmodule_list.number_of_modules),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (module_list);\n\t\tfor (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {\n\t\t\tstruct minidump_module *module = read_module (obj->b, offset);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tr_list_append (obj->streams.modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));\n\t\tif (r != sizeof (memory_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tmemory_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_list);\n\t\tfor (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {\n\t\t\tstruct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)desc, sizeof (*desc));\n\t\t\tif (r != sizeof (*desc)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase EXCEPTION_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.exception = R_NEW (struct minidump_exception_stream);\n\t\tif (!obj->streams.exception) {\n\t\t\tbreak;\n\t\t}\n\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.exception, sizeof (*obj->streams.exception));\n\t\tif (r != sizeof (*obj->streams.exception)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\t\t\t\t   \"ExceptionRecord ExceptionAddress \"\n\t\t\t\t\t\t\t   \"NumberParameters __UnusedAlignment \"\n\t\t\t\t\t\t\t   \"ExceptionInformation\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_exception_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\t\t\t\t\t  \"ThreadId __Alignment \"\n\t\t\t\t\t\t\t\t  \"(mdmp_exception)ExceptionRecord \"\n\t\t\t\t\t\t\t\t  \"(mdmp_location_descriptor)ThreadContext\",\n\t\t\t0);\n\n\t\tbreak;\n\tcase SYSTEM_INFO_STREAM:\n\t\tobj->streams.system_info = R_NEW (struct minidump_system_info);\n\t\tif (!obj->streams.system_info) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));\n\t\tif (r != sizeof (*obj->streams.system_info)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_system_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\t/* TODO: We need E as a byte! */\n\t\tsdb_set (obj->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase THREAD_EX_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));\n\t\tif (r != sizeof (thread_ex_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tr_strf (\"d[%d]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tthread_ex_list.number_of_threads),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (thread_ex_list);\n\t\tfor (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {\n\t\t\tstruct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);\n\t\t\tif (!thread) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)thread, sizeof (*thread));\n\t\t\tif (r != sizeof (*thread)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.ex_threads, thread);\n\t\t\toffset += sizeof (*thread);\n\t\t}\n\t\tbreak;\n\tcase MEMORY_64_LIST_STREAM:\n\t\tread_memory64_list (obj->b, entry->location.rva, &memory64_list);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_memory64_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory64_list.format\",\n\t\t\tr_strf (\"qq[%\"PFMT64d\"]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tmemory64_list.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tobj->streams.memories64.base_rva = memory64_list.base_rva;\n\t\toffset = entry->location.rva + sizeof (memory64_list);\n\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {\n\t\t\tstruct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);\n\t\t\tif (!desc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_desc (obj->b, offset, desc);\n\t\t\tr_list_append (obj->streams.memories64.memories, desc);\n\t\t\toffset += sizeof (*desc);\n\t\t}\n\t\tbreak;\n\tcase COMMENT_STREAM_A:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_a = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_a) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_a, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase COMMENT_STREAM_W:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.comments_w = R_NEWS (ut8, COMMENTS_SIZE);\n\t\tif (!obj->streams.comments_w) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_w, COMMENTS_SIZE);\n\t\tif (r != COMMENTS_SIZE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase HANDLE_DATA_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.handle_data = R_NEW (struct minidump_handle_data_stream);\n\t\tif (!obj->streams.handle_data) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.handle_data, sizeof (*obj->streams.handle_data));\n\t\tif (r != sizeof (*obj->streams.handle_data)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase FUNCTION_TABLE_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.function_table = R_NEW (struct minidump_function_table_stream);\n\t\tif (!obj->streams.function_table) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.function_table, sizeof (*obj->streams.function_table));\n\t\tif (r != sizeof (*obj->streams.function_table)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase UNLOADED_MODULE_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));\n\t\tif (r != sizeof (unloaded_module_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (unloaded_module_list);\n\t\tfor (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);\n\t\t\tif (!module) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)module, sizeof (*module));\n\t\t\tif (r != sizeof (*module)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.unloaded_modules, module);\n\t\t\toffset += sizeof (*module);\n\t\t}\n\t\tbreak;\n\tcase MISC_INFO_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tobj->streams.misc_info.misc_info_1 = R_NEW (struct minidump_misc_info);\n\t\tif (!obj->streams.misc_info.misc_info_1) {\n\t\t\tbreak;\n\t\t}\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.misc_info.misc_info_1, sizeof (*obj->streams.misc_info.misc_info_1));\n\t\tif (r != sizeof (*obj->streams.misc_info.misc_info_1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO: Handle different sizes */\n\t\tsdb_num_set (obj->kv, \"mdmp_misc_info.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase MEMORY_INFO_LIST_STREAM:\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_info_list, sizeof (memory_info_list));\n\t\tif (r != sizeof (memory_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (obj->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_memory_info_list.format\",\n\t\t\tr_strf (\"ddq[%\"PFMT64d\"]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tmemory_info_list.number_of_entries),\n\t\t\t0);\n\n\t\toffset = entry->location.rva + sizeof (memory_info_list);\n\t\tfor (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_memory_info *info = R_NEW (struct minidump_memory_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.memory_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase THREAD_INFO_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_info_list, sizeof (thread_info_list));\n\t\tif (r != sizeof (thread_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (obj->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\toffset = entry->location.rva + sizeof (thread_info_list);\n\t\tfor (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_thread_info *info = R_NEW (struct minidump_thread_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.thread_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\tcase HANDLE_OPERATION_LIST_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&handle_operation_list, sizeof (handle_operation_list));\n\t\tif (r != sizeof (handle_operation_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (obj->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\toffset = entry->location.rva + sizeof (handle_operation_list);\n\t\tfor (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);\n\t\t\tif (!op) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)op, sizeof (*op));\n\t\t\tif (r != sizeof (*op)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.operations, op);\n\t\t\toffset += sizeof (*op);\n\t\t}\n\n\t\tbreak;\n\tcase TOKEN_STREAM:\n\t\t/* TODO: Not fully parsed or utilised */\n\t\tr = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));\n\t\tif (r != sizeof (token_info_list)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (obj->kv, \"mdmp_token_info.format\", \"ddq \"\n\t\t\t\"TokenSize TokenId TokenHandle\", 0);\n\n\t\tsdb_num_set (obj->kv, \"mdmp_token_info_list.offset\",\n\t\t\tentry->location.rva, 0);\n\t\tsdb_set (obj->kv, \"mdmp_token_info_list.format\", \"dddd \"\n\t\t\t\"TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize\", 0);\n\n\t\toffset = entry->location.rva + sizeof (token_info_list);\n\t\tfor (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {\n\t\t\tstruct minidump_token_info *info = R_NEW (struct minidump_token_info);\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));\n\t\t\tif (r != sizeof (*info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (obj->streams.token_infos, info);\n\t\t\toffset += sizeof (*info);\n\t\t}\n\t\tbreak;\n\n\tcase LAST_RESERVED_STREAM:\n\t\t/* TODO: Not yet fully parsed or utilised */\n\t\tbreak;\n\tcase UNUSED_STREAM:\n\tcase RESERVED_STREAM_0:\n\tcase RESERVED_STREAM_1:\n\t\t/* Silently ignore reserved streams */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %d\\n\", entry->stream_type);\n\t\tbreak;\n\t}\n\treturn true;\n}",
  "abstract_func": "static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *VAR_0, struct minidump_directory *VAR_1) {\n\tr_strf_buffer (128);\n\tstruct minidump_handle_operation_list VAR_2;\n\tstruct minidump_memory_list VAR_3;\n\tstruct minidump_memory64_list VAR_4;\n\tstruct minidump_memory_info_list VAR_5;\n\tstruct minidump_module_list VAR_6;\n\tstruct minidump_thread_list VAR_7;\n\tstruct minidump_thread_ex_list VAR_8;\n\tstruct minidump_thread_info_list VAR_9;\n\tstruct minidump_token_info_list VAR_10;\n\tstruct minidump_unloaded_module_list VAR_11;\n\tut64 VAR_12;\n\tint VAR_13, VAR_14;\n\n\t/* COMMENT_0 */\n                                                                       \n\tif ((ut64)VAR_1->location.rva + VAR_1->location.data_size > r_buf_size (VAR_0->b)) {\n\t\teprintf (\"[ERROR] Size Mismatch - Stream data is larger than file size!\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (VAR_1->stream_type) {\n\tcase VAR_15:\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_7, sizeof (VAR_7));\n\t\tif (VAR_14 != sizeof (VAR_7)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread.format\", \"ddddq?? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_thread_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfThreads (mdmp_thread)Threads\",\n\t\t\t\tVAR_7.number_of_threads),\n\t\t\t0);\n\n\t\t/* COMMENT_2 */\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_6.number_of_modules = r_buf_read_le32_at (VAR_0->b, VAR_1->location.rva);\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_module.format\", \"qddtd???qq \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum \"\n\t\t\t\"TimeDateStamp ModuleNameRVA \"\n\t\t\t\"(mdmp_vs_fixedfileinfo)VersionInfo \"\n\t\t\t\"(mdmp_location_descriptor)CvRecord \"\n\t\t\t\"(mdmp_location_descriptor)MiscRecord \"\n\t\t\t\"Reserved0 Reserved1\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_module_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_module_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfModule (mdmp_module)Modules\",\n\t\t\t\tVAR_6.number_of_modules),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_6);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_6.number_of_modules && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_module *VAR_17 = read_module (VAR_0->b, VAR_12);\n\t\t\tif (!VAR_17) {\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.modules, VAR_17);\n\t\t\tVAR_12 += sizeof (*VAR_17);\n\t\t}\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_3, sizeof (VAR_3));\n\t\tif (VAR_14 != sizeof (VAR_3)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_memory_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory_list.format\",\n\t\t\tr_strf (\"d[%d]? \"\n\t\t\t\t\"NumberOfMemoryRanges \"\n\t\t\t\t\"(mdmp_memory_descriptor)MemoryRanges \",\n\t\t\t\tVAR_3.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_3);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_3.number_of_memory_ranges && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_memory_descriptor *VAR_19 = R_NEW (struct minidump_memory_descriptor);\n\t\t\tif (!VAR_19) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_19, sizeof (*VAR_19));\n\t\t\tif (VAR_14 != sizeof (*VAR_19)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.memories, VAR_19);\n\t\t\tVAR_12 += sizeof (*VAR_19);\n\t\t}\n\t\tbreak;\n\tcase VAR_20:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.exception = R_NEW (struct VAR_21);\n\t\tif (!VAR_0->streams.exception) {\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.exception, sizeof (*VAR_0->streams.exception));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.exception)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_exception.format\", \"[4]E[4]Eqqdd[15]q \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_code)ExceptionCode \"\n\t\t\t\t\t\t\t   \"(mdmp_exception_flags)ExceptionFlags \"\n\t\t\t\t\t\t\t   \"ExceptionRecord ExceptionAddress \"\n\t\t\t\t\t\t\t   \"NumberParameters __UnusedAlignment \"\n\t\t\t\t\t\t\t   \"ExceptionInformation\",\n\t\t\t0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_exception_stream.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_exception_stream.format\", \"dd?? \"\n\t\t\t\t\t\t\t\t  \"ThreadId __Alignment \"\n\t\t\t\t\t\t\t\t  \"(mdmp_exception)ExceptionRecord \"\n\t\t\t\t\t\t\t\t  \"(mdmp_location_descriptor)ThreadContext\",\n\t\t\t0);\n\n\t\tbreak;\n\tcase VAR_22:\n\t\tVAR_0->streams.system_info = R_NEW (struct VAR_23);\n\t\tif (!VAR_0->streams.system_info) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.system_info, sizeof (*VAR_0->streams.system_info));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.system_info)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_system_info.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\t/* COMMENT_3 */\n\t\tsdb_set (VAR_0->kv, \"mdmp_system_info.format\", \"[2]EwwbBddd[4]Ed[2]Ew[2]q \"\n\t\t\t\"(mdmp_processor_architecture)ProcessorArchitecture \"\n\t\t\t\"ProcessorLevel ProcessorRevision NumberOfProcessors \"\n\t\t\t\"(mdmp_product_type)ProductType \"\n\t\t\t\"MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId \"\n\t\t\t\"CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures\", 0);\n\n\t\tbreak;\n\tcase VAR_24:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_8, sizeof (VAR_8));\n\t\tif (VAR_14 != sizeof (VAR_8)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_ex.format\", \"ddddq??? \"\n\t\t\t\"ThreadId SuspendCount PriorityClass Priority \"\n\t\t\t\"Teb (mdmp_memory_descriptor)Stack \"\n\t\t\t\"(mdmp_location_descriptor)ThreadContext \"\n\t\t\t\"(mdmp_memory_descriptor)BackingStore\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_thread_ex_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_ex_list.format\",\n\t\t\tr_strf (\"d[%d]? NumberOfThreads \"\n\t\t\t\t\"(mdmp_thread_ex)Threads\",\n\t\t\t\tVAR_8.number_of_threads),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_8);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_8.number_of_threads && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_thread_ex *VAR_25 = R_NEW (struct minidump_thread_ex);\n\t\t\tif (!VAR_25) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_25, sizeof (*VAR_25));\n\t\t\tif (VAR_14 != sizeof (*VAR_25)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.ex_threads, VAR_25);\n\t\t\tVAR_12 += sizeof (*VAR_25);\n\t\t}\n\t\tbreak;\n\tcase VAR_26:\n\t\tread_memory64_list (VAR_0->b, VAR_1->location.rva, &VAR_4);\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_memory64_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory64_list.format\",\n\t\t\tr_strf (\"qq[%\"VAR_27\"]? NumberOfMemoryRanges \"\n\t\t\t\t\"BaseRva \"\n\t\t\t\t\"(mdmp_memory_descriptor64)MemoryRanges\",\n\t\t\t\tVAR_4.number_of_memory_ranges),\n\t\t\t0);\n\n\t\tVAR_0->streams.memories64.base_rva = VAR_4.base_rva;\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_4);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_4.number_of_memory_ranges && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_memory_descriptor64 *VAR_19 = R_NEW (struct minidump_memory_descriptor64);\n\t\t\tif (!VAR_19) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_desc (VAR_0->b, VAR_12, VAR_19);\n\t\t\tr_list_append (VAR_0->streams.memories64.memories, VAR_19);\n\t\t\tVAR_12 += sizeof (*VAR_19);\n\t\t}\n\t\tbreak;\n\tcase VAR_28:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.comments_a = R_NEWS (ut8, VAR_29);\n\t\tif (!VAR_0->streams.comments_a) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_a, VAR_29);\n\t\tif (VAR_14 != VAR_29) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_comment_stream_a.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_comment_stream_a.format\",\n\t\t\t\"s CommentA\", 0);\n\n\t\tbreak;\n\tcase VAR_30:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.comments_w = R_NEWS (ut8, VAR_29);\n\t\tif (!VAR_0->streams.comments_w) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, VAR_0->streams.comments_w, VAR_29);\n\t\tif (VAR_14 != VAR_29) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_comment_stream_w.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_comment_stream_w.format\",\n\t\t\t\t\"s CommentW\", 0);\n\n\t\tbreak;\n\tcase VAR_31:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.handle_data = R_NEW (struct VAR_32);\n\t\tif (!VAR_0->streams.handle_data) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.handle_data, sizeof (*VAR_0->streams.handle_data));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.handle_data)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_handle_data_stream.offset\",\n\t\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_handle_data_stream.format\", \"dddd \"\n\t\t\t\t\"SizeOfHeader SizeOfDescriptor \"\n\t\t\t\t\"NumberOfDescriptors Reserved\", 0);\n\t\tbreak;\n\tcase VAR_33:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.function_table = R_NEW (struct VAR_34);\n\t\tif (!VAR_0->streams.function_table) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.function_table, sizeof (*VAR_0->streams.function_table));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.function_table)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_function_table_stream.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_function_table_stream.format\", \"dddddd \"\n\t\t\t\"SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor \"\n\t\t\t\"SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad\",\n\t\t\t0);\n\t\tbreak;\n\tcase VAR_35:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_11, sizeof (VAR_11));\n\t\tif (VAR_14 != sizeof (VAR_11)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_unloaded_module.format\", \"qddtd \"\n\t\t\t\"BaseOfImage SizeOfImage CheckSum TimeDateStamp \"\n\t\t\t\"ModuleNameRva\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_unloaded_module_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_unloaded_module_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_11);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_11.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_unloaded_module *VAR_17 = R_NEW (struct minidump_unloaded_module);\n\t\t\tif (!VAR_17) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_17, sizeof (*VAR_17));\n\t\t\tif (VAR_14 != sizeof (*VAR_17)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.unloaded_modules, VAR_17);\n\t\t\tVAR_12 += sizeof (*VAR_17);\n\t\t}\n\t\tbreak;\n\tcase VAR_36:\n\t\t/* COMMENT_2 */\n\t\tVAR_0->streams.misc_info.misc_info_1 = R_NEW (struct VAR_37);\n\t\tif (!VAR_0->streams.misc_info.misc_info_1) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)VAR_0->streams.misc_info.misc_info_1, sizeof (*VAR_0->streams.misc_info.misc_info_1));\n\t\tif (VAR_14 != sizeof (*VAR_0->streams.misc_info.misc_info_1)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_misc_info.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_misc_info.format\", \"d[4]Bdtttddddd \"\n\t\t\t\"SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId \"\n\t\t\t\"ProcessCreateTime ProcessUserTime ProcessKernelTime \"\n\t\t\t\"ProcessorMaxMhz ProcessorCurrentMhz \"\n\t\t\t\"ProcessorMhzLimit ProcessorMaxIdleState \"\n\t\t\t\"ProcessorCurrentIdleState\", 0);\n\n\t\tbreak;\n\tcase VAR_38:\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_5, sizeof (VAR_5));\n\t\tif (VAR_14 != sizeof (VAR_5)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory_info.format\",\n\t\t\t\"qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase \"\n\t\t\t\"(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize \"\n\t\t\t\"(mdmp_mem_state)State (mdmp_page_protect)Protect \"\n\t\t\t\"(mdmp_mem_type)Type __Alignment2\", 0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_memory_info_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_memory_info_list.format\",\n\t\t\tr_strf (\"ddq[%\"VAR_27\"]? SizeOfHeader SizeOfEntry \"\n\t\t\t\t\"NumberOfEntries (mdmp_memory_info)MemoryInfo\",\n\t\t\t\tVAR_5.number_of_entries),\n\t\t\t0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_5);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_5.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_memory_info *VAR_39 = R_NEW (struct minidump_memory_info);\n\t\t\tif (!VAR_39) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));\n\t\t\tif (VAR_14 != sizeof (*VAR_39)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.memory_infos, VAR_39);\n\t\t\tVAR_12 += sizeof (*VAR_39);\n\t\t}\n\t\tbreak;\n\tcase VAR_40:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_9, sizeof (VAR_9));\n\t\tif (VAR_14 != sizeof (VAR_9)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_info.format\", \"ddddttttqq \"\n\t\t\t\"ThreadId DumpFlags DumpError ExitStatus CreateTime \"\n\t\t\t\"ExitTime KernelTime UserTime StartAddress Affinity\",\n\t\t\t0);\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_thread_info_list.offset\",\n\t\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_thread_info_list.format\", \"ddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_9);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_9.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_thread_info *VAR_39 = R_NEW (struct minidump_thread_info);\n\t\t\tif (!VAR_39) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));\n\t\t\tif (VAR_14 != sizeof (*VAR_39)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.thread_infos, VAR_39);\n\t\t\tVAR_12 += sizeof (*VAR_39);\n\t\t}\n\t\tbreak;\n\tcase VAR_41:\n\t\t/* COMMENT_2 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_2, sizeof (VAR_2));\n\t\tif (VAR_14 != sizeof (VAR_2)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_handle_operation_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_handle_operation_list.format\", \"dddd \"\n\t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_2);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_2.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct avrf_handle_operation *VAR_42 = R_NEW (struct avrf_handle_operation);\n\t\t\tif (!VAR_42) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_42, sizeof (*VAR_42));\n\t\t\tif (VAR_14 != sizeof (*VAR_42)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.operations, VAR_42);\n\t\t\tVAR_12 += sizeof (*VAR_42);\n\t\t}\n\n\t\tbreak;\n\tcase VAR_43:\n\t\t/* COMMENT_5 */\n\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_1->location.rva, (ut8 *)&VAR_10, sizeof (VAR_10));\n\t\tif (VAR_14 != sizeof (VAR_10)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_set (VAR_0->kv, \"mdmp_token_info.format\", \"ddq \"\n\t\t\t\"TokenSize TokenId TokenHandle\", 0);\n\n\t\tsdb_num_set (VAR_0->kv, \"mdmp_token_info_list.offset\",\n\t\t\tVAR_1->location.rva, 0);\n\t\tsdb_set (VAR_0->kv, \"mdmp_token_info_list.format\", \"dddd \"\n\t\t\t\"TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize\", 0);\n\n\t\tVAR_12 = VAR_1->location.rva + sizeof (VAR_10);\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_10.number_of_entries && VAR_12 < VAR_0->size; VAR_13++) {\n\t\t\tstruct minidump_token_info *VAR_39 = R_NEW (struct minidump_token_info);\n\t\t\tif (!VAR_39) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12, (ut8 *)VAR_39, sizeof (*VAR_39));\n\t\t\tif (VAR_14 != sizeof (*VAR_39)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (VAR_0->streams.token_infos, VAR_39);\n\t\t\tVAR_12 += sizeof (*VAR_39);\n\t\t}\n\t\tbreak;\n\n\tcase VAR_44:\n\t\t/* COMMENT_2 */\n\t\tbreak;\n\tcase VAR_45:\n\tcase VAR_46:\n\tcase VAR_47:\n\t\t/* COMMENT_6 */\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"[WARN] Invalid or unsupported enumeration encountered %d\\n\", VAR_1->stream_type);\n\t\tbreak;\n\t}\n\treturn true;\n}",
  "func_graph_path": "radareorg/radare2/27fe8031782d3a06c3998eaa94354867864f9f1b/mdmp.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -60,12 +60,11 @@\n \t\t\t0);\n \n \t\toffset = entry->location.rva + sizeof (module_list);\n-\t\tfor (i = 0; i < module_list.number_of_modules; i++) {\n-\t\t\tstruct minidump_module *module = R_NEW (struct minidump_module);\n+\t\tfor (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {\n+\t\t\tstruct minidump_module *module = read_module (obj->b, offset);\n \t\t\tif (!module) {\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tread_module (obj->b, offset, module);\n+\t\t\t\tbreak;\t\n+\t\t\t}\n \t\t\tr_list_append (obj->streams.modules, module);\n \t\t\toffset += sizeof (*module);\n \t\t}\n@@ -86,7 +85,7 @@\n \t\t\t0);\n \n \t\toffset = entry->location.rva + sizeof (memory_list);\n-\t\tfor (i = 0; i < memory_list.number_of_memory_ranges; i++) {\n+\t\tfor (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {\n \t\t\tstruct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);\n \t\t\tif (!desc) {\n \t\t\t\tbreak;\n@@ -169,7 +168,7 @@\n \t\t\t0);\n \n \t\toffset = entry->location.rva + sizeof (thread_ex_list);\n-\t\tfor (i = 0; i < thread_ex_list.number_of_threads; i++) {\n+\t\tfor (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {\n \t\t\tstruct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);\n \t\t\tif (!thread) {\n \t\t\t\tbreak;\n@@ -196,7 +195,7 @@\n \n \t\tobj->streams.memories64.base_rva = memory64_list.base_rva;\n \t\toffset = entry->location.rva + sizeof (memory64_list);\n-\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges; i++) {\n+\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {\n \t\t\tstruct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);\n \t\t\tif (!desc) {\n \t\t\t\tbreak;\n@@ -291,7 +290,7 @@\n \t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n \n \t\toffset = entry->location.rva + sizeof (unloaded_module_list);\n-\t\tfor (i = 0; i < unloaded_module_list.number_of_entries; i++) {\n+\t\tfor (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {\n \t\t\tstruct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);\n \t\t\tif (!module) {\n \t\t\t\tbreak;\n@@ -346,7 +345,7 @@\n \t\t\t0);\n \n \t\toffset = entry->location.rva + sizeof (memory_info_list);\n-\t\tfor (i = 0; i < memory_info_list.number_of_entries; i++) {\n+\t\tfor (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {\n \t\t\tstruct minidump_memory_info *info = R_NEW (struct minidump_memory_info);\n \t\t\tif (!info) {\n \t\t\t\tbreak;\n@@ -376,7 +375,7 @@\n \t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n \n \t\toffset = entry->location.rva + sizeof (thread_info_list);\n-\t\tfor (i = 0; i < thread_info_list.number_of_entries; i++) {\n+\t\tfor (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {\n \t\t\tstruct minidump_thread_info *info = R_NEW (struct minidump_thread_info);\n \t\t\tif (!info) {\n \t\t\t\tbreak;\n@@ -402,7 +401,7 @@\n \t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n \n \t\toffset = entry->location.rva + sizeof (handle_operation_list);\n-\t\tfor (i = 0; i < handle_operation_list.number_of_entries; i++) {\n+\t\tfor (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {\n \t\t\tstruct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);\n \t\t\tif (!op) {\n \t\t\t\tbreak;\n@@ -432,7 +431,7 @@\n \t\t\t\"TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize\", 0);\n \n \t\toffset = entry->location.rva + sizeof (token_info_list);\n-\t\tfor (i = 0; i < token_info_list.number_of_entries; i++) {\n+\t\tfor (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {\n \t\t\tstruct minidump_token_info *info = R_NEW (struct minidump_token_info);\n \t\t\tif (!info) {\n \t\t\t\tbreak;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tfor (i = 0; i < module_list.number_of_modules; i++) {",
      "\t\t\tstruct minidump_module *module = R_NEW (struct minidump_module);",
      "\t\t\t\tbreak;",
      "\t\t\t}",
      "\t\t\tread_module (obj->b, offset, module);",
      "\t\tfor (i = 0; i < memory_list.number_of_memory_ranges; i++) {",
      "\t\tfor (i = 0; i < thread_ex_list.number_of_threads; i++) {",
      "\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges; i++) {",
      "\t\tfor (i = 0; i < unloaded_module_list.number_of_entries; i++) {",
      "\t\tfor (i = 0; i < memory_info_list.number_of_entries; i++) {",
      "\t\tfor (i = 0; i < thread_info_list.number_of_entries; i++) {",
      "\t\tfor (i = 0; i < handle_operation_list.number_of_entries; i++) {",
      "\t\tfor (i = 0; i < token_info_list.number_of_entries; i++) {"
    ],
    "added_lines": [
      "\t\tfor (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {",
      "\t\t\tstruct minidump_module *module = read_module (obj->b, offset);",
      "\t\t\t\tbreak;\t",
      "\t\t\t}",
      "\t\tfor (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {",
      "\t\tfor (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {",
      "\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {",
      "\t\tfor (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {",
      "\t\tfor (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {",
      "\t\tfor (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {",
      "\t\tfor (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {",
      "\t\tfor (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19744",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19744: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19744",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nThe commit addresses a Denial of Service (DoS) vulnerability by adding bounds checks to prevent buffer overflows in the minidump parser, consistent with the commit message and code changes."
}