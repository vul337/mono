{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_server.cpp",
  "func_name": "zmq::curve_server_t::process_hello",
  "func_before": "int zmq::curve_server_t::process_hello (msg_t *msg_)\n{\n    if (msg_->size () != 200) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client HELLO is not correct size\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t * const hello = static_cast <uint8_t *> (msg_->data ());\n    if (memcmp (hello, \"\\x05HELLO\", 6)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client HELLO has invalid command name\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t major = hello [6];\n    const uint8_t minor = hello [7];\n\n    if (major != 1 || minor != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client HELLO has unknown version number\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  Save client's short-term public key (C')\n    memcpy (cn_client, hello + 80, 32);\n\n    uint8_t hello_nonce [crypto_box_NONCEBYTES];\n    uint8_t hello_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t hello_box [crypto_box_BOXZEROBYTES + 80];\n\n    memcpy (hello_nonce, \"CurveZMQHELLO---\", 16);\n    memcpy (hello_nonce + 16, hello + 112, 8);\n\n    memset (hello_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (hello_box + crypto_box_BOXZEROBYTES, hello + 120, 80);\n\n    //  Open Box [64 * %x0](C'->S)\n    int rc = crypto_box_open (hello_plaintext, hello_box,\n                              sizeof hello_box,\n                              hello_nonce, cn_client, secret_key);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client HELLO -- wrong server key?\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    state = send_welcome;\n    return rc;\n}",
  "abstract_func_before": "int zmq::curve_server_t::process_hello (msg_t *VAR_0)\n{\n    if (VAR_0->size () != 200) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client HELLO is not correct size\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t * const VAR_3 = VAR_4 <uint8_t *> (VAR_0->data ());\n    if (memcmp (VAR_3, \"\\x05HELLO\", 6)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client HELLO has invalid command name\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t VAR_5 = VAR_3 [6];\n    const uint8_t VAR_6 = VAR_3 [7];\n\n    if (VAR_5 != 1 || VAR_6 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client HELLO has unknown version number\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_1 */\n    memcpy (VAR_7, VAR_3 + 80, 32);\n\n    uint8_t VAR_8 [VAR_9];\n    uint8_t VAR_10 [VAR_11 + 64];\n    uint8_t VAR_12 [VAR_13 + 80];\n\n    memcpy (VAR_8, \"CurveZMQHELLO---\", 16);\n    memcpy (VAR_8 + 16, VAR_3 + 112, 8);\n\n    memset (VAR_12, 0, VAR_13);\n    memcpy (VAR_12 + VAR_13, VAR_3 + 120, 80);\n\n    /* COMMENT_2 */\n    int VAR_14 = crypto_box_open (VAR_10, VAR_12,\n                              sizeof VAR_12,\n                              VAR_8, VAR_7, VAR_15);\n    if (VAR_14 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client HELLO -- wrong server key?\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    VAR_16 = VAR_17;\n    return VAR_14;\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/before/4.json",
  "func": "int zmq::curve_server_t::process_hello (msg_t *msg_)\n{\n    if (msg_->size () != 200) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client HELLO is not correct size\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t * const hello = static_cast <uint8_t *> (msg_->data ());\n    if (memcmp (hello, \"\\x05HELLO\", 6)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client HELLO has invalid command name\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t major = hello [6];\n    const uint8_t minor = hello [7];\n\n    if (major != 1 || minor != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client HELLO has unknown version number\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  Save client's short-term public key (C')\n    memcpy (cn_client, hello + 80, 32);\n\n    uint8_t hello_nonce [crypto_box_NONCEBYTES];\n    uint8_t hello_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t hello_box [crypto_box_BOXZEROBYTES + 80];\n\n    memcpy (hello_nonce, \"CurveZMQHELLO---\", 16);\n    memcpy (hello_nonce + 16, hello + 112, 8);\n    cn_peer_nonce = get_uint64(hello + 112);\n\n    memset (hello_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (hello_box + crypto_box_BOXZEROBYTES, hello + 120, 80);\n\n    //  Open Box [64 * %x0](C'->S)\n    int rc = crypto_box_open (hello_plaintext, hello_box,\n                              sizeof hello_box,\n                              hello_nonce, cn_client, secret_key);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client HELLO -- wrong server key?\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    state = send_welcome;\n    return rc;\n}",
  "abstract_func": "int zmq::curve_server_t::process_hello (msg_t *VAR_0)\n{\n    if (VAR_0->size () != 200) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client HELLO is not correct size\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t * const VAR_3 = VAR_4 <uint8_t *> (VAR_0->data ());\n    if (memcmp (VAR_3, \"\\x05HELLO\", 6)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client HELLO has invalid command name\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t VAR_5 = VAR_3 [6];\n    const uint8_t VAR_6 = VAR_3 [7];\n\n    if (VAR_5 != 1 || VAR_6 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client HELLO has unknown version number\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_1 */\n    memcpy (VAR_7, VAR_3 + 80, 32);\n\n    uint8_t VAR_8 [VAR_9];\n    uint8_t VAR_10 [VAR_11 + 64];\n    uint8_t VAR_12 [VAR_13 + 80];\n\n    memcpy (VAR_8, \"CurveZMQHELLO---\", 16);\n    memcpy (VAR_8 + 16, VAR_3 + 112, 8);\n    VAR_14 = get_uint64(VAR_3 + 112);\n\n    memset (VAR_12, 0, VAR_13);\n    memcpy (VAR_12 + VAR_13, VAR_3 + 120, 80);\n\n    /* COMMENT_2 */\n    int VAR_15 = crypto_box_open (VAR_10, VAR_12,\n                              sizeof VAR_12,\n                              VAR_8, VAR_7, VAR_16);\n    if (VAR_15 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client HELLO -- wrong server key?\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    VAR_17 = VAR_18;\n    return VAR_15;\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,7 @@\n \n     memcpy (hello_nonce, \"CurveZMQHELLO---\", 16);\n     memcpy (hello_nonce + 16, hello + 112, 8);\n+    cn_peer_nonce = get_uint64(hello + 112);\n \n     memset (hello_box, 0, crypto_box_BOXZEROBYTES);\n     memcpy (hello_box + crypto_box_BOXZEROBYTES, hello + 120, 80);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    cn_peer_nonce = get_uint64(hello + 112);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": {
    "pr_info": {
      "title": "Problem: curve messages can be replayed",
      "number": 1189
    },
    "comment": [
      "Solution: ensure message short nonces are strictly increasing and validate them\n",
      "Fixes #1191.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}