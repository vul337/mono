{
  "cve_id": "CVE-2021-46878",
  "cwe_ids": [
    "CWE-843"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "fluent/fluent-bit",
  "commit_msg": "pack: fix type confusion bugs. Amongst other OSS-Fuzz 5136174263566336\n\nSigned-off-by: davkor <david@adalogics.com>",
  "commit_hash": "8040e0b04e48d2cf1a2853e8ac2c2561e18c4a11",
  "git_url": "https://github.com/fluent/fluent-bit/commit/8040e0b04e48d2cf1a2853e8ac2c2561e18c4a11",
  "file_path": "src/flb_pack.c",
  "func_name": "flb_pack_msgpack_to_json_format",
  "func_before": "flb_sds_t flb_pack_msgpack_to_json_format(const char *data, uint64_t bytes,\n                                          int json_format, int date_format,\n                                          flb_sds_t date_key)\n{\n    int i;\n    int len;\n    int ok = MSGPACK_UNPACK_SUCCESS;\n    int records = 0;\n    int map_size;\n    size_t off = 0;\n    char time_formatted[32];\n    size_t s;\n    flb_sds_t out_tmp;\n    flb_sds_t out_js;\n    flb_sds_t out_buf = NULL;\n    msgpack_unpacked result;\n    msgpack_object root;\n    msgpack_object map;\n    msgpack_sbuffer tmp_sbuf;\n    msgpack_packer tmp_pck;\n    msgpack_object *obj;\n    msgpack_object *k;\n    msgpack_object *v;\n    struct tm tm;\n    struct flb_time tms;\n\n    /* Iterate the original buffer and perform adjustments */\n    records = flb_mp_count(data, bytes);\n    if (records <= 0) {\n        return NULL;\n    }\n\n    /* For json lines and streams mode we need a pre-allocated buffer */\n    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n        json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n        out_buf = flb_sds_create_size(bytes + bytes / 4);\n        if (!out_buf) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* Create temporary msgpack buffer */\n    msgpack_sbuffer_init(&tmp_sbuf);\n    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);\n\n    /*\n     * If the format is the original msgpack style of one big array,\n     * registrate the array, otherwise is not necessary. FYI, original format:\n     *\n     * [\n     *   [timestamp, map],\n     *   [timestamp, map],\n     *   [T, M]...\n     * ]\n     */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        msgpack_pack_array(&tmp_pck, records);\n    }\n\n    msgpack_unpacked_init(&result);\n    while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n        /* Each array must have two entries: time and record */\n        root = result.data;\n        if (root.via.array.size != 2) {\n            continue;\n        }\n\n        /* Unpack time */\n        flb_time_pop_from_msgpack(&tms, &result, &obj);\n\n        /* Get the record/map */\n        map = root.via.array.ptr[1];\n        map_size = map.via.map.size;\n\n        if (date_key != NULL) {\n            msgpack_pack_map(&tmp_pck, map_size + 1);\n        }\n        else {\n            msgpack_pack_map(&tmp_pck, map_size);\n        }\n\n        if (date_key != NULL) {\n            /* Append date key */\n            msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));\n            msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));\n\n            /* Append date value */\n            switch (date_format) {\n            case FLB_PACK_JSON_DATE_DOUBLE:\n                msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));\n                break;\n            case FLB_PACK_JSON_DATE_ISO8601:\n            /* Format the time, use microsecond precision not nanoseconds */\n                gmtime_r(&tms.tm.tv_sec, &tm);\n                s = strftime(time_formatted, sizeof(time_formatted) - 1,\n                             FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);\n\n                len = snprintf(time_formatted + s,\n                               sizeof(time_formatted) - 1 - s,\n                               \".%06\" PRIu64 \"Z\",\n                               (uint64_t) tms.tm.tv_nsec / 1000);\n                s += len;\n                msgpack_pack_str(&tmp_pck, s);\n                msgpack_pack_str_body(&tmp_pck, time_formatted, s);\n                break;\n            case FLB_PACK_JSON_DATE_EPOCH:\n                msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* Append remaining keys/values */\n        for (i = 0; i < map_size; i++) {\n            k = &map.via.map.ptr[i].key;\n            v = &map.via.map.ptr[i].val;\n            msgpack_pack_object(&tmp_pck, *k);\n            msgpack_pack_object(&tmp_pck, *v);\n        }\n\n        /*\n         * If the format is the original msgpack style, just continue since\n         * we don't care about separator or JSON convertion at this point.\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n            continue;\n        }\n\n        /*\n         * Here we handle two types of records concatenation:\n         *\n         * FLB_PACK_JSON_FORMAT_LINES: add  breakline (\\n) after each record\n         *\n         *\n         *     {'ts':abc,'k1':1}\n         *     {'ts':abc,'k1':2}\n         *     {N}\n         *\n         * FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:\n         *\n         *     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n            json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n\n            /* Encode current record into JSON in a temporary variable */\n            out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n            if (!out_js) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /*\n             * One map record has been converted, now append it to the\n             * outgoing out_buf sds variable.\n             */\n            out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));\n            if (!out_tmp) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_js);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /* Release temporary json sds buffer */\n            flb_sds_destroy(out_js);\n\n            /* If a realloc happened, check the returned address */\n            if (out_tmp != out_buf) {\n                out_buf = out_tmp;\n            }\n\n            /* Append the breakline only for json lines mode */\n            if (json_format == FLB_PACK_JSON_FORMAT_LINES) {\n                out_tmp = flb_sds_cat(out_buf, \"\\n\", 1);\n                if (!out_tmp) {\n                    msgpack_sbuffer_destroy(&tmp_sbuf);\n                    flb_sds_destroy(out_buf);\n                    return NULL;\n                }\n                if (out_tmp != out_buf) {\n                    out_buf = out_tmp;\n                }\n            }\n            msgpack_sbuffer_clear(&tmp_sbuf);\n        }\n    }\n\n    /* Release the unpacker */\n    msgpack_unpacked_destroy(&result);\n\n    /* Format to JSON */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        out_buf = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n\n        if (!out_buf) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n    }\n\n    if (out_buf && flb_sds_len(out_buf) == 0) {\n        flb_sds_destroy(out_buf);\n        return NULL;\n    }\n\n    return out_buf;\n}",
  "abstract_func_before": "flb_sds_t flb_pack_msgpack_to_json_format(const char *VAR_0, uint64_t VAR_1,\n                                          int VAR_2, int VAR_3,\n                                          flb_sds_t VAR_4)\n{\n    int VAR_5;\n    int VAR_6;\n    int VAR_7 = VAR_8;\n    int VAR_9 = 0;\n    int VAR_10;\n    size_t VAR_11 = 0;\n    char VAR_12[32];\n    size_t VAR_13;\n    flb_sds_t VAR_14;\n    flb_sds_t VAR_15;\n    flb_sds_t VAR_16 = NULL;\n    msgpack_unpacked VAR_17;\n    msgpack_object VAR_18;\n    msgpack_object VAR_19;\n    msgpack_sbuffer VAR_20;\n    msgpack_packer VAR_21;\n    msgpack_object *VAR_22;\n    msgpack_object *VAR_23;\n    msgpack_object *VAR_24;\n    struct tm tm;\n    struct flb_time VAR_25;\n\n    /* COMMENT_0 */\n    VAR_9 = flb_mp_count(VAR_0, VAR_1);\n    if (VAR_9 <= 0) {\n        return NULL;\n    }\n\n    /* COMMENT_1 */\n    if (VAR_2 == VAR_26 ||\n        VAR_2 == VAR_27) {\n        VAR_16 = flb_sds_create_size(VAR_1 + VAR_1 / 4);\n        if (!VAR_16) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* COMMENT_2 */\n    msgpack_sbuffer_init(&VAR_20);\n    msgpack_packer_init(&VAR_21, &VAR_20, VAR_28);\n\n    /* COMMENT_3 */\n                                                                    \n                                                                              \n      \n        \n                          \n                          \n                  \n        \n       \n    if (VAR_2 == VAR_29) {\n        msgpack_pack_array(&VAR_21, VAR_9);\n    }\n\n    msgpack_unpacked_init(&VAR_17);\n    while (msgpack_unpack_next(&VAR_17, VAR_0, VAR_1, &VAR_11) == VAR_7) {\n        /* COMMENT_12 */\n        VAR_18 = VAR_17.data;\n        if (VAR_18.via.array.size != 2) {\n            continue;\n        }\n\n        /* COMMENT_13 */\n        flb_time_pop_from_msgpack(&VAR_25, &VAR_17, &VAR_22);\n\n        /* COMMENT_14 */\n        VAR_19 = VAR_18.via.array.ptr[1];\n        VAR_10 = VAR_19.via.map.size;\n\n        if (VAR_4 != NULL) {\n            msgpack_pack_map(&VAR_21, VAR_10 + 1);\n        }\n        else {\n            msgpack_pack_map(&VAR_21, VAR_10);\n        }\n\n        if (VAR_4 != NULL) {\n            /* COMMENT_15 */\n            msgpack_pack_str(&VAR_21, flb_sds_len(VAR_4));\n            msgpack_pack_str_body(&VAR_21, VAR_4, flb_sds_len(VAR_4));\n\n            /* COMMENT_16 */\n            switch (VAR_3) {\n            case VAR_30:\n                msgpack_pack_double(&VAR_21, flb_time_to_double(&VAR_25));\n                break;\n            case VAR_31:\n            /* COMMENT_17 */\n                gmtime_r(&VAR_25.tm.tv_sec, &tm);\n                VAR_13 = strftime(VAR_12, sizeof(VAR_12) - 1,\n                             VAR_32, &tm);\n\n                VAR_6 = snprintf(VAR_12 + VAR_13,\n                               sizeof(VAR_12) - 1 - VAR_13,\n                               \".%06\" VAR_33 \"Z\",\n                               (uint64_t) VAR_25.tm.tv_nsec / 1000);\n                VAR_13 += VAR_6;\n                msgpack_pack_str(&VAR_21, VAR_13);\n                msgpack_pack_str_body(&VAR_21, VAR_12, VAR_13);\n                break;\n            case VAR_34:\n                msgpack_pack_uint64(&VAR_21, (long long unsigned)(VAR_25.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* COMMENT_18 */\n        for (VAR_5 = 0; VAR_5 < VAR_10; VAR_5++) {\n            VAR_23 = &VAR_19.via.map.ptr[VAR_5].key;\n            VAR_24 = &VAR_19.via.map.ptr[VAR_5].val;\n            msgpack_pack_object(&VAR_21, *VAR_23);\n            msgpack_pack_object(&VAR_21, *VAR_24);\n        }\n\n        /* COMMENT_19 */\n                                                                           \n                                                                          \n           \n        if (VAR_2 == VAR_29) {\n            continue;\n        }\n\n        /* COMMENT_23 */\n                                                             \n          \n                                                                            \n          \n          \n                                \n                                \n                  \n          \n                                                           \n          \n                                                    \n           \n        if (VAR_2 == VAR_26 ||\n            VAR_2 == VAR_27) {\n\n            /* COMMENT_33 */\n            VAR_15 = flb_msgpack_raw_to_json_sds(VAR_20.data, VAR_20.size);\n            if (!VAR_15) {\n                msgpack_sbuffer_destroy(&VAR_20);\n                flb_sds_destroy(VAR_16);\n                return NULL;\n            }\n\n            /* COMMENT_34 */\n                                                                      \n                                             \n               \n            VAR_14 = flb_sds_cat(VAR_16, VAR_15, flb_sds_len(VAR_15));\n            if (!VAR_14) {\n                msgpack_sbuffer_destroy(&VAR_20);\n                flb_sds_destroy(VAR_15);\n                flb_sds_destroy(VAR_16);\n                return NULL;\n            }\n\n            /* COMMENT_38 */\n            flb_sds_destroy(VAR_15);\n\n            /* COMMENT_39 */\n            if (VAR_14 != VAR_16) {\n                VAR_16 = VAR_14;\n            }\n\n            /* COMMENT_40 */\n            if (VAR_2 == VAR_26) {\n                VAR_14 = flb_sds_cat(VAR_16, \"\\n\", 1);\n                if (!VAR_14) {\n                    msgpack_sbuffer_destroy(&VAR_20);\n                    flb_sds_destroy(VAR_16);\n                    return NULL;\n                }\n                if (VAR_14 != VAR_16) {\n                    VAR_16 = VAR_14;\n                }\n            }\n            msgpack_sbuffer_clear(&VAR_20);\n        }\n    }\n\n    /* COMMENT_41 */\n    msgpack_unpacked_destroy(&VAR_17);\n\n    /* COMMENT_42 */\n    if (VAR_2 == VAR_29) {\n        VAR_16 = flb_msgpack_raw_to_json_sds(VAR_20.data, VAR_20.size);\n        msgpack_sbuffer_destroy(&VAR_20);\n\n        if (!VAR_16) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&VAR_20);\n    }\n\n    if (VAR_16 && flb_sds_len(VAR_16) == 0) {\n        flb_sds_destroy(VAR_16);\n        return NULL;\n    }\n\n    return VAR_16;\n}",
  "func_graph_path_before": "fluent/fluent-bit/8040e0b04e48d2cf1a2853e8ac2c2561e18c4a11/flb_pack.c/vul/before/0.json",
  "func": "flb_sds_t flb_pack_msgpack_to_json_format(const char *data, uint64_t bytes,\n                                          int json_format, int date_format,\n                                          flb_sds_t date_key)\n{\n    int i;\n    int len;\n    int ok = MSGPACK_UNPACK_SUCCESS;\n    int records = 0;\n    int map_size;\n    size_t off = 0;\n    char time_formatted[32];\n    size_t s;\n    flb_sds_t out_tmp;\n    flb_sds_t out_js;\n    flb_sds_t out_buf = NULL;\n    msgpack_unpacked result;\n    msgpack_object root;\n    msgpack_object map;\n    msgpack_sbuffer tmp_sbuf;\n    msgpack_packer tmp_pck;\n    msgpack_object *obj;\n    msgpack_object *k;\n    msgpack_object *v;\n    struct tm tm;\n    struct flb_time tms;\n\n    /* Iterate the original buffer and perform adjustments */\n    records = flb_mp_count(data, bytes);\n    if (records <= 0) {\n        return NULL;\n    }\n\n    /* For json lines and streams mode we need a pre-allocated buffer */\n    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n        json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n        out_buf = flb_sds_create_size(bytes + bytes / 4);\n        if (!out_buf) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* Create temporary msgpack buffer */\n    msgpack_sbuffer_init(&tmp_sbuf);\n    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);\n\n    /*\n     * If the format is the original msgpack style of one big array,\n     * registrate the array, otherwise is not necessary. FYI, original format:\n     *\n     * [\n     *   [timestamp, map],\n     *   [timestamp, map],\n     *   [T, M]...\n     * ]\n     */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        msgpack_pack_array(&tmp_pck, records);\n    }\n\n    msgpack_unpacked_init(&result);\n    while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n        /* Each array must have two entries: time and record */\n        root = result.data;\n        if (root.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (root.via.array.size != 2) {\n            continue;\n        }\n\n        /* Unpack time */\n        flb_time_pop_from_msgpack(&tms, &result, &obj);\n\n        /* Get the record/map */\n        map = root.via.array.ptr[1];\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            continue;\n        }\n        map_size = map.via.map.size;\n\n        if (date_key != NULL) {\n            msgpack_pack_map(&tmp_pck, map_size + 1);\n        }\n        else {\n            msgpack_pack_map(&tmp_pck, map_size);\n        }\n\n        if (date_key != NULL) {\n            /* Append date key */\n            msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));\n            msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));\n\n            /* Append date value */\n            switch (date_format) {\n            case FLB_PACK_JSON_DATE_DOUBLE:\n                msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));\n                break;\n            case FLB_PACK_JSON_DATE_ISO8601:\n            /* Format the time, use microsecond precision not nanoseconds */\n                gmtime_r(&tms.tm.tv_sec, &tm);\n                s = strftime(time_formatted, sizeof(time_formatted) - 1,\n                             FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);\n\n                len = snprintf(time_formatted + s,\n                               sizeof(time_formatted) - 1 - s,\n                               \".%06\" PRIu64 \"Z\",\n                               (uint64_t) tms.tm.tv_nsec / 1000);\n                s += len;\n                msgpack_pack_str(&tmp_pck, s);\n                msgpack_pack_str_body(&tmp_pck, time_formatted, s);\n                break;\n            case FLB_PACK_JSON_DATE_EPOCH:\n                msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* Append remaining keys/values */\n        for (i = 0; i < map_size; i++) {\n            k = &map.via.map.ptr[i].key;\n            v = &map.via.map.ptr[i].val;\n            msgpack_pack_object(&tmp_pck, *k);\n            msgpack_pack_object(&tmp_pck, *v);\n        }\n\n        /*\n         * If the format is the original msgpack style, just continue since\n         * we don't care about separator or JSON convertion at this point.\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n            continue;\n        }\n\n        /*\n         * Here we handle two types of records concatenation:\n         *\n         * FLB_PACK_JSON_FORMAT_LINES: add  breakline (\\n) after each record\n         *\n         *\n         *     {'ts':abc,'k1':1}\n         *     {'ts':abc,'k1':2}\n         *     {N}\n         *\n         * FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:\n         *\n         *     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n            json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n\n            /* Encode current record into JSON in a temporary variable */\n            out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n            if (!out_js) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /*\n             * One map record has been converted, now append it to the\n             * outgoing out_buf sds variable.\n             */\n            out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));\n            if (!out_tmp) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_js);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /* Release temporary json sds buffer */\n            flb_sds_destroy(out_js);\n\n            /* If a realloc happened, check the returned address */\n            if (out_tmp != out_buf) {\n                out_buf = out_tmp;\n            }\n\n            /* Append the breakline only for json lines mode */\n            if (json_format == FLB_PACK_JSON_FORMAT_LINES) {\n                out_tmp = flb_sds_cat(out_buf, \"\\n\", 1);\n                if (!out_tmp) {\n                    msgpack_sbuffer_destroy(&tmp_sbuf);\n                    flb_sds_destroy(out_buf);\n                    return NULL;\n                }\n                if (out_tmp != out_buf) {\n                    out_buf = out_tmp;\n                }\n            }\n            msgpack_sbuffer_clear(&tmp_sbuf);\n        }\n    }\n\n    /* Release the unpacker */\n    msgpack_unpacked_destroy(&result);\n\n    /* Format to JSON */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        out_buf = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n\n        if (!out_buf) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n    }\n\n    if (out_buf && flb_sds_len(out_buf) == 0) {\n        flb_sds_destroy(out_buf);\n        return NULL;\n    }\n\n    return out_buf;\n}",
  "abstract_func": "flb_sds_t flb_pack_msgpack_to_json_format(const char *VAR_0, uint64_t VAR_1,\n                                          int VAR_2, int VAR_3,\n                                          flb_sds_t VAR_4)\n{\n    int VAR_5;\n    int VAR_6;\n    int VAR_7 = VAR_8;\n    int VAR_9 = 0;\n    int VAR_10;\n    size_t VAR_11 = 0;\n    char VAR_12[32];\n    size_t VAR_13;\n    flb_sds_t VAR_14;\n    flb_sds_t VAR_15;\n    flb_sds_t VAR_16 = NULL;\n    msgpack_unpacked VAR_17;\n    msgpack_object VAR_18;\n    msgpack_object VAR_19;\n    msgpack_sbuffer VAR_20;\n    msgpack_packer VAR_21;\n    msgpack_object *VAR_22;\n    msgpack_object *VAR_23;\n    msgpack_object *VAR_24;\n    struct tm tm;\n    struct flb_time VAR_25;\n\n    /* COMMENT_0 */\n    VAR_9 = flb_mp_count(VAR_0, VAR_1);\n    if (VAR_9 <= 0) {\n        return NULL;\n    }\n\n    /* COMMENT_1 */\n    if (VAR_2 == VAR_26 ||\n        VAR_2 == VAR_27) {\n        VAR_16 = flb_sds_create_size(VAR_1 + VAR_1 / 4);\n        if (!VAR_16) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* COMMENT_2 */\n    msgpack_sbuffer_init(&VAR_20);\n    msgpack_packer_init(&VAR_21, &VAR_20, VAR_28);\n\n    /* COMMENT_3 */\n                                                                    \n                                                                              \n      \n        \n                          \n                          \n                  \n        \n       \n    if (VAR_2 == VAR_29) {\n        msgpack_pack_array(&VAR_21, VAR_9);\n    }\n\n    msgpack_unpacked_init(&VAR_17);\n    while (msgpack_unpack_next(&VAR_17, VAR_0, VAR_1, &VAR_11) == VAR_7) {\n        /* COMMENT_12 */\n        VAR_18 = VAR_17.data;\n        if (VAR_18.type != VAR_30) {\n            continue;\n        }\n        if (VAR_18.via.array.size != 2) {\n            continue;\n        }\n\n        /* COMMENT_13 */\n        flb_time_pop_from_msgpack(&VAR_25, &VAR_17, &VAR_22);\n\n        /* COMMENT_14 */\n        VAR_19 = VAR_18.via.array.ptr[1];\n        if (VAR_19.type != VAR_31) {\n            continue;\n        }\n        VAR_10 = VAR_19.via.map.size;\n\n        if (VAR_4 != NULL) {\n            msgpack_pack_map(&VAR_21, VAR_10 + 1);\n        }\n        else {\n            msgpack_pack_map(&VAR_21, VAR_10);\n        }\n\n        if (VAR_4 != NULL) {\n            /* COMMENT_15 */\n            msgpack_pack_str(&VAR_21, flb_sds_len(VAR_4));\n            msgpack_pack_str_body(&VAR_21, VAR_4, flb_sds_len(VAR_4));\n\n            /* COMMENT_16 */\n            switch (VAR_3) {\n            case VAR_32:\n                msgpack_pack_double(&VAR_21, flb_time_to_double(&VAR_25));\n                break;\n            case VAR_33:\n            /* COMMENT_17 */\n                gmtime_r(&VAR_25.tm.tv_sec, &tm);\n                VAR_13 = strftime(VAR_12, sizeof(VAR_12) - 1,\n                             VAR_34, &tm);\n\n                VAR_6 = snprintf(VAR_12 + VAR_13,\n                               sizeof(VAR_12) - 1 - VAR_13,\n                               \".%06\" VAR_35 \"Z\",\n                               (uint64_t) VAR_25.tm.tv_nsec / 1000);\n                VAR_13 += VAR_6;\n                msgpack_pack_str(&VAR_21, VAR_13);\n                msgpack_pack_str_body(&VAR_21, VAR_12, VAR_13);\n                break;\n            case VAR_36:\n                msgpack_pack_uint64(&VAR_21, (long long unsigned)(VAR_25.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* COMMENT_18 */\n        for (VAR_5 = 0; VAR_5 < VAR_10; VAR_5++) {\n            VAR_23 = &VAR_19.via.map.ptr[VAR_5].key;\n            VAR_24 = &VAR_19.via.map.ptr[VAR_5].val;\n            msgpack_pack_object(&VAR_21, *VAR_23);\n            msgpack_pack_object(&VAR_21, *VAR_24);\n        }\n\n        /* COMMENT_19 */\n                                                                           \n                                                                          \n           \n        if (VAR_2 == VAR_29) {\n            continue;\n        }\n\n        /* COMMENT_23 */\n                                                             \n          \n                                                                            \n          \n          \n                                \n                                \n                  \n          \n                                                           \n          \n                                                    \n           \n        if (VAR_2 == VAR_26 ||\n            VAR_2 == VAR_27) {\n\n            /* COMMENT_33 */\n            VAR_15 = flb_msgpack_raw_to_json_sds(VAR_20.data, VAR_20.size);\n            if (!VAR_15) {\n                msgpack_sbuffer_destroy(&VAR_20);\n                flb_sds_destroy(VAR_16);\n                return NULL;\n            }\n\n            /* COMMENT_34 */\n                                                                      \n                                             \n               \n            VAR_14 = flb_sds_cat(VAR_16, VAR_15, flb_sds_len(VAR_15));\n            if (!VAR_14) {\n                msgpack_sbuffer_destroy(&VAR_20);\n                flb_sds_destroy(VAR_15);\n                flb_sds_destroy(VAR_16);\n                return NULL;\n            }\n\n            /* COMMENT_38 */\n            flb_sds_destroy(VAR_15);\n\n            /* COMMENT_39 */\n            if (VAR_14 != VAR_16) {\n                VAR_16 = VAR_14;\n            }\n\n            /* COMMENT_40 */\n            if (VAR_2 == VAR_26) {\n                VAR_14 = flb_sds_cat(VAR_16, \"\\n\", 1);\n                if (!VAR_14) {\n                    msgpack_sbuffer_destroy(&VAR_20);\n                    flb_sds_destroy(VAR_16);\n                    return NULL;\n                }\n                if (VAR_14 != VAR_16) {\n                    VAR_16 = VAR_14;\n                }\n            }\n            msgpack_sbuffer_clear(&VAR_20);\n        }\n    }\n\n    /* COMMENT_41 */\n    msgpack_unpacked_destroy(&VAR_17);\n\n    /* COMMENT_42 */\n    if (VAR_2 == VAR_29) {\n        VAR_16 = flb_msgpack_raw_to_json_sds(VAR_20.data, VAR_20.size);\n        msgpack_sbuffer_destroy(&VAR_20);\n\n        if (!VAR_16) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&VAR_20);\n    }\n\n    if (VAR_16 && flb_sds_len(VAR_16) == 0) {\n        flb_sds_destroy(VAR_16);\n        return NULL;\n    }\n\n    return VAR_16;\n}",
  "func_graph_path": "fluent/fluent-bit/8040e0b04e48d2cf1a2853e8ac2c2561e18c4a11/flb_pack.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -62,6 +62,9 @@\n     while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n         /* Each array must have two entries: time and record */\n         root = result.data;\n+        if (root.type != MSGPACK_OBJECT_ARRAY) {\n+            continue;\n+        }\n         if (root.via.array.size != 2) {\n             continue;\n         }\n@@ -71,6 +74,9 @@\n \n         /* Get the record/map */\n         map = root.via.array.ptr[1];\n+        if (map.type != MSGPACK_OBJECT_MAP) {\n+            continue;\n+        }\n         map_size = map.via.map.size;\n \n         if (date_key != NULL) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (root.type != MSGPACK_OBJECT_ARRAY) {",
      "            continue;",
      "        }",
      "        if (map.type != MSGPACK_OBJECT_MAP) {",
      "            continue;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fluent/fluent-bit/pull/3115",
  "description": {
    "pr_info": {
      "title": "pack: fix type confusion bugs. Amongst other OSS-Fuzz 5136174263566336",
      "number": 3115
    },
    "comment": [
      "This a fairly important fix, in that many plugins call `flb_pack_msgpack_to_json_format`, however there are some important bugs in this function due to missing checking of the type of msgpack objects. This leads to type confusion bugs that interprets whatever is on the stack as msgpack maps and arrays. This leads to all sorts of trouble.\r\n\r\nSigned-off-by: davkor <david@adalogics.com>\r\n\r\n<!-- Provide summary of changes -->\r\n\r\n<!-- Issue number, if available. E.g. \"Fixes #31\", \"Addresses #42, #77\" -->\r\n\r\n----\r\nEnter `[N/A]` in the box, if an item is not applicable to your change.\r\n\r\n**Testing**\r\nBefore we can approve your change; please submit the following in a comment:\r\n- [N/A] Example configuration file for the change\r\n- [N/A] Debug log output from testing the change\r\n<!-- Invoke Fluent Bit and Valgrind as: $ valgrind ./bin/fluent-bit <args> -->\r\n- [N/A] Attached [Valgrind](https://valgrind.org/docs/manual/quick-start.html) output that shows no leaks or memory corruption was found\r\n\r\n**Documentation**\r\n<!-- Docs can be edited at https://github.com/fluent/fluent-bit-docs -->\r\n- [N/A] Documentation required for this feature\r\n\r\n<!--  Doc PR (not required but highly recommended) -->\r\n\r\n----\r\n\r\nFluent Bit is licensed under Apache 2.0, by submitting this pull request I understand that this code will be released under the terms of that license.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}