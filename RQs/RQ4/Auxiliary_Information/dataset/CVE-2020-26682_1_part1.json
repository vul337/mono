{
  "cve_id": "CVE-2020-26682",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "outline: fix overflows in outline processing\n\nThis commit enforces strict invariant on ASS_Outline\nto contain point coordinates into predetermined range.\n\nFixes https://github.com/libass/libass/issues/431.",
  "commit_hash": "676f9dc5b52ef406c5527bdadbcb947f11392929",
  "git_url": "https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929",
  "file_path": "libass/ass_outline.c",
  "func_name": "outline_convert",
  "func_before": "bool outline_convert(ASS_Outline *outline, const FT_Outline *source)\n{\n    if (!source || !source->n_points) {\n        outline_clear(outline);\n        return true;\n    }\n\n    if (!outline_alloc(outline, 2 * source->n_points, source->n_points))\n        return false;\n\n    enum Status {\n        S_ON, S_Q, S_C1, S_C2\n    };\n\n    for (size_t i = 0, j = 0; i < source->n_contours; i++) {\n        ASS_Vector pt;\n        bool skip_last = false;\n        enum Status st;\n\n        int last = source->contours[i];\n        if (j > last || last >= source->n_points)\n            goto fail;\n\n        // skip degenerate 2-point contours from broken fonts\n        if (last - j < 2) {\n            j = last + 1;\n            continue;\n        }\n\n        switch (FT_CURVE_TAG(source->tags[j])) {\n        case FT_CURVE_TAG_ON:\n            st = S_ON;\n            break;\n\n        case FT_CURVE_TAG_CONIC:\n            pt.x =  source->points[last].x;\n            pt.y = -source->points[last].y;\n            switch (FT_CURVE_TAG(source->tags[last])) {\n            case FT_CURVE_TAG_ON:\n                skip_last = true;\n                break;\n\n            case FT_CURVE_TAG_CONIC:\n                pt.x = (pt.x + source->points[j].x) >> 1;\n                pt.y = (pt.y - source->points[j].y) >> 1;\n                break;\n\n            default:\n                goto fail;\n            }\n            outline->points[outline->n_points++] = pt;\n            st = S_Q;\n            break;\n\n        default:\n            goto fail;\n        }\n        pt.x =  source->points[j].x;\n        pt.y = -source->points[j].y;\n        outline->points[outline->n_points++] = pt;\n\n        for (j++; j <= last; j++) {\n            switch (FT_CURVE_TAG(source->tags[j])) {\n            case FT_CURVE_TAG_ON:\n                switch (st) {\n                case S_ON:\n                    outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;\n                    break;\n\n                case S_Q:\n                    outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;\n                    break;\n\n                case S_C2:\n                    outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                st = S_ON;\n                break;\n\n            case FT_CURVE_TAG_CONIC:\n                switch (st) {\n                case S_ON:\n                    st = S_Q;\n                    break;\n\n                case S_Q:\n                    outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;\n                    pt.x = (pt.x + source->points[j].x) >> 1;\n                    pt.y = (pt.y - source->points[j].y) >> 1;\n                    outline->points[outline->n_points++] = pt;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            case FT_CURVE_TAG_CUBIC:\n                switch (st) {\n                case S_ON:\n                    st = S_C1;\n                    break;\n\n                case S_C1:\n                    st = S_C2;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            default:\n                goto fail;\n            }\n            pt.x =  source->points[j].x;\n            pt.y = -source->points[j].y;\n            outline->points[outline->n_points++] = pt;\n        }\n\n        switch (st) {\n        case S_ON:\n            if (skip_last) {\n                outline->n_points--;\n                break;\n            }\n            outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;\n            break;\n\n        case S_Q:\n            outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;\n            break;\n\n        case S_C2:\n            outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;\n            break;\n\n        default:\n            goto fail;\n        }\n        outline->segments[outline->n_segments - 1] |= OUTLINE_CONTOUR_END;\n    }\n    return true;\n\nfail:\n    outline_free(outline);\n    return false;\n}",
  "abstract_func_before": "bool outline_convert(ASS_Outline *VAR_0, const FT_Outline *VAR_1)\n{\n    if (!VAR_1 || !VAR_1->n_points) {\n        outline_clear(VAR_0);\n        return true;\n    }\n\n    if (!outline_alloc(VAR_0, 2 * VAR_1->n_points, VAR_1->n_points))\n        return false;\n\n    enum Status {\n        VAR_2, VAR_3, VAR_4, VAR_5\n    };\n\n    for (size_t VAR_6 = 0, VAR_7 = 0; VAR_6 < VAR_1->n_contours; VAR_6++) {\n        ASS_Vector VAR_8;\n        bool VAR_9 = false;\n        enum Status VAR_10;\n\n        int VAR_11 = VAR_1->contours[VAR_6];\n        if (VAR_7 > VAR_11 || VAR_11 >= VAR_1->n_points)\n            goto fail;\n\n        /* COMMENT_0 */\n        if (VAR_11 - VAR_7 < 2) {\n            VAR_7 = VAR_11 + 1;\n            continue;\n        }\n\n        switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {\n        case VAR_12:\n            VAR_10 = VAR_2;\n            break;\n\n        case VAR_13:\n            VAR_8.x =  VAR_1->points[VAR_11].x;\n            VAR_8.y = -VAR_1->points[VAR_11].y;\n            switch (FT_CURVE_TAG(VAR_1->tags[VAR_11])) {\n            case VAR_12:\n                VAR_9 = true;\n                break;\n\n            case VAR_13:\n                VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;\n                VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;\n                break;\n\n            default:\n                goto fail;\n            }\n            VAR_0->points[VAR_0->n_points++] = VAR_8;\n            VAR_10 = VAR_3;\n            break;\n\n        default:\n            goto fail;\n        }\n        VAR_8.x =  VAR_1->points[VAR_7].x;\n        VAR_8.y = -VAR_1->points[VAR_7].y;\n        VAR_0->points[VAR_0->n_points++] = VAR_8;\n\n        for (VAR_7++; VAR_7 <= VAR_11; VAR_7++) {\n            switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {\n            case VAR_12:\n                switch (VAR_10) {\n                case VAR_2:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_14;\n                    break;\n\n                case VAR_3:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_15;\n                    break;\n\n                case VAR_5:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_16;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                VAR_10 = VAR_2;\n                break;\n\n            case VAR_13:\n                switch (VAR_10) {\n                case VAR_2:\n                    VAR_10 = VAR_3;\n                    break;\n\n                case VAR_3:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_15;\n                    VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;\n                    VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;\n                    VAR_0->points[VAR_0->n_points++] = VAR_8;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            case VAR_17:\n                switch (VAR_10) {\n                case VAR_2:\n                    VAR_10 = VAR_4;\n                    break;\n\n                case VAR_4:\n                    VAR_10 = VAR_5;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            default:\n                goto fail;\n            }\n            VAR_8.x =  VAR_1->points[VAR_7].x;\n            VAR_8.y = -VAR_1->points[VAR_7].y;\n            VAR_0->points[VAR_0->n_points++] = VAR_8;\n        }\n\n        switch (VAR_10) {\n        case VAR_2:\n            if (VAR_9) {\n                VAR_0->n_points--;\n                break;\n            }\n            VAR_0->segments[VAR_0->n_segments++] = VAR_14;\n            break;\n\n        case VAR_3:\n            VAR_0->segments[VAR_0->n_segments++] = VAR_15;\n            break;\n\n        case VAR_5:\n            VAR_0->segments[VAR_0->n_segments++] = VAR_16;\n            break;\n\n        default:\n            goto fail;\n        }\n        VAR_0->segments[VAR_0->n_segments - 1] |= VAR_18;\n    }\n    return true;\n\nfail:\n    outline_free(VAR_0);\n    return false;\n}",
  "func_graph_path_before": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/2.json",
  "func": "bool outline_convert(ASS_Outline *outline, const FT_Outline *source)\n{\n    if (!source || !source->n_points) {\n        outline_clear(outline);\n        return true;\n    }\n\n    if (!outline_alloc(outline, 2 * source->n_points, source->n_points))\n        return false;\n\n    enum Status {\n        S_ON, S_Q, S_C1, S_C2\n    };\n\n    for (size_t i = 0, j = 0; i < source->n_contours; i++) {\n        ASS_Vector pt;\n        bool skip_last = false;\n        enum Status st;\n\n        int last = source->contours[i];\n        if (j > last || last >= source->n_points)\n            goto fail;\n\n        // skip degenerate 2-point contours from broken fonts\n        if (last - j < 2) {\n            j = last + 1;\n            continue;\n        }\n\n        if (!valid_point(source->points + j))\n            goto fail;\n        switch (FT_CURVE_TAG(source->tags[j])) {\n        case FT_CURVE_TAG_ON:\n            st = S_ON;\n            break;\n\n        case FT_CURVE_TAG_CONIC:\n            if (!valid_point(source->points + last))\n                goto fail;\n            pt.x =  source->points[last].x;\n            pt.y = -source->points[last].y;\n            switch (FT_CURVE_TAG(source->tags[last])) {\n            case FT_CURVE_TAG_ON:\n                skip_last = true;\n                break;\n\n            case FT_CURVE_TAG_CONIC:\n                pt.x = (pt.x + source->points[j].x) >> 1;\n                pt.y = (pt.y - source->points[j].y) >> 1;\n                break;\n\n            default:\n                goto fail;\n            }\n            outline->points[outline->n_points++] = pt;\n            st = S_Q;\n            break;\n\n        default:\n            goto fail;\n        }\n        pt.x =  source->points[j].x;\n        pt.y = -source->points[j].y;\n        outline->points[outline->n_points++] = pt;\n\n        for (j++; j <= last; j++) {\n            if (!valid_point(source->points + j))\n                goto fail;\n            switch (FT_CURVE_TAG(source->tags[j])) {\n            case FT_CURVE_TAG_ON:\n                switch (st) {\n                case S_ON:\n                    outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;\n                    break;\n\n                case S_Q:\n                    outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;\n                    break;\n\n                case S_C2:\n                    outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                st = S_ON;\n                break;\n\n            case FT_CURVE_TAG_CONIC:\n                switch (st) {\n                case S_ON:\n                    st = S_Q;\n                    break;\n\n                case S_Q:\n                    outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;\n                    pt.x = (pt.x + source->points[j].x) >> 1;\n                    pt.y = (pt.y - source->points[j].y) >> 1;\n                    outline->points[outline->n_points++] = pt;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            case FT_CURVE_TAG_CUBIC:\n                switch (st) {\n                case S_ON:\n                    st = S_C1;\n                    break;\n\n                case S_C1:\n                    st = S_C2;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            default:\n                goto fail;\n            }\n            pt.x =  source->points[j].x;\n            pt.y = -source->points[j].y;\n            outline->points[outline->n_points++] = pt;\n        }\n\n        switch (st) {\n        case S_ON:\n            if (skip_last) {\n                outline->n_points--;\n                break;\n            }\n            outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;\n            break;\n\n        case S_Q:\n            outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;\n            break;\n\n        case S_C2:\n            outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;\n            break;\n\n        default:\n            goto fail;\n        }\n        outline->segments[outline->n_segments - 1] |= OUTLINE_CONTOUR_END;\n    }\n    return true;\n\nfail:\n    outline_free(outline);\n    return false;\n}",
  "abstract_func": "bool outline_convert(ASS_Outline *VAR_0, const FT_Outline *VAR_1)\n{\n    if (!VAR_1 || !VAR_1->n_points) {\n        outline_clear(VAR_0);\n        return true;\n    }\n\n    if (!outline_alloc(VAR_0, 2 * VAR_1->n_points, VAR_1->n_points))\n        return false;\n\n    enum Status {\n        VAR_2, VAR_3, VAR_4, VAR_5\n    };\n\n    for (size_t VAR_6 = 0, VAR_7 = 0; VAR_6 < VAR_1->n_contours; VAR_6++) {\n        ASS_Vector VAR_8;\n        bool VAR_9 = false;\n        enum Status VAR_10;\n\n        int VAR_11 = VAR_1->contours[VAR_6];\n        if (VAR_7 > VAR_11 || VAR_11 >= VAR_1->n_points)\n            goto fail;\n\n        /* COMMENT_0 */\n        if (VAR_11 - VAR_7 < 2) {\n            VAR_7 = VAR_11 + 1;\n            continue;\n        }\n\n        if (!valid_point(VAR_1->points + VAR_7))\n            goto fail;\n        switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {\n        case VAR_12:\n            VAR_10 = VAR_2;\n            break;\n\n        case VAR_13:\n            if (!valid_point(VAR_1->points + VAR_11))\n                goto fail;\n            VAR_8.x =  VAR_1->points[VAR_11].x;\n            VAR_8.y = -VAR_1->points[VAR_11].y;\n            switch (FT_CURVE_TAG(VAR_1->tags[VAR_11])) {\n            case VAR_12:\n                VAR_9 = true;\n                break;\n\n            case VAR_13:\n                VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;\n                VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;\n                break;\n\n            default:\n                goto fail;\n            }\n            VAR_0->points[VAR_0->n_points++] = VAR_8;\n            VAR_10 = VAR_3;\n            break;\n\n        default:\n            goto fail;\n        }\n        VAR_8.x =  VAR_1->points[VAR_7].x;\n        VAR_8.y = -VAR_1->points[VAR_7].y;\n        VAR_0->points[VAR_0->n_points++] = VAR_8;\n\n        for (VAR_7++; VAR_7 <= VAR_11; VAR_7++) {\n            if (!valid_point(VAR_1->points + VAR_7))\n                goto fail;\n            switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {\n            case VAR_12:\n                switch (VAR_10) {\n                case VAR_2:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_14;\n                    break;\n\n                case VAR_3:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_15;\n                    break;\n\n                case VAR_5:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_16;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                VAR_10 = VAR_2;\n                break;\n\n            case VAR_13:\n                switch (VAR_10) {\n                case VAR_2:\n                    VAR_10 = VAR_3;\n                    break;\n\n                case VAR_3:\n                    VAR_0->segments[VAR_0->n_segments++] = VAR_15;\n                    VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;\n                    VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;\n                    VAR_0->points[VAR_0->n_points++] = VAR_8;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            case VAR_17:\n                switch (VAR_10) {\n                case VAR_2:\n                    VAR_10 = VAR_4;\n                    break;\n\n                case VAR_4:\n                    VAR_10 = VAR_5;\n                    break;\n\n                default:\n                    goto fail;\n                }\n                break;\n\n            default:\n                goto fail;\n            }\n            VAR_8.x =  VAR_1->points[VAR_7].x;\n            VAR_8.y = -VAR_1->points[VAR_7].y;\n            VAR_0->points[VAR_0->n_points++] = VAR_8;\n        }\n\n        switch (VAR_10) {\n        case VAR_2:\n            if (VAR_9) {\n                VAR_0->n_points--;\n                break;\n            }\n            VAR_0->segments[VAR_0->n_segments++] = VAR_14;\n            break;\n\n        case VAR_3:\n            VAR_0->segments[VAR_0->n_segments++] = VAR_15;\n            break;\n\n        case VAR_5:\n            VAR_0->segments[VAR_0->n_segments++] = VAR_16;\n            break;\n\n        default:\n            goto fail;\n        }\n        VAR_0->segments[VAR_0->n_segments - 1] |= VAR_18;\n    }\n    return true;\n\nfail:\n    outline_free(VAR_0);\n    return false;\n}",
  "func_graph_path": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,12 +27,16 @@\n             continue;\n         }\n \n+        if (!valid_point(source->points + j))\n+            goto fail;\n         switch (FT_CURVE_TAG(source->tags[j])) {\n         case FT_CURVE_TAG_ON:\n             st = S_ON;\n             break;\n \n         case FT_CURVE_TAG_CONIC:\n+            if (!valid_point(source->points + last))\n+                goto fail;\n             pt.x =  source->points[last].x;\n             pt.y = -source->points[last].y;\n             switch (FT_CURVE_TAG(source->tags[last])) {\n@@ -60,6 +64,8 @@\n         outline->points[outline->n_points++] = pt;\n \n         for (j++; j <= last; j++) {\n+            if (!valid_point(source->points + j))\n+                goto fail;\n             switch (FT_CURVE_TAG(source->tags[j])) {\n             case FT_CURVE_TAG_ON:\n                 switch (st) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (!valid_point(source->points + j))",
      "            goto fail;",
      "            if (!valid_point(source->points + last))",
      "                goto fail;",
      "            if (!valid_point(source->points + j))",
      "                goto fail;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/432",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libass/libass/pull/432: 403 Client Error: Forbidden for url: https://api.github.com/repos/libass/libass/pulls/432",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}