{
  "cve_id": "CVE-2017-9431",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "grpc",
  "commit_msg": "Fix error overflow bug",
  "commit_hash": "c6ec1155d026c91b1badb07ef1605bb747cff064",
  "git_url": "https://github.com/grpc/grpc/commit/c6ec1155d026c91b1badb07ef1605bb747cff064",
  "file_path": "src/core/lib/iomgr/error.c",
  "func_name": "internal_set_str",
  "func_before": "static void internal_set_str(grpc_error **err, grpc_error_strs which,\n                             grpc_slice value) {\n  // GPR_ASSERT((*err)->strs[which] == UINT8_MAX); // TODO, enforce this\n  uint8_t slot = (*err)->strs[which];\n  if (slot == UINT8_MAX) {\n    slot = get_placement(err, sizeof(value));\n  } else {\n    unref_slice(*(grpc_slice *)((*err)->arena + slot));\n  }\n  (*err)->strs[which] = slot;\n  memcpy((*err)->arena + slot, &value, sizeof(value));\n}",
  "abstract_func_before": "static void internal_set_str(grpc_error **VAR_0, grpc_error_strs VAR_1,\n                             grpc_slice VAR_2) {\n  /* COMMENT_0 */\n  uint8_t VAR_3 = (*VAR_0)->strs[VAR_1];\n  if (VAR_3 == VAR_4) {\n    VAR_3 = get_placement(VAR_0, sizeof(VAR_2));\n  } else {\n    unref_slice(*(grpc_slice *)((*VAR_0)->arena + VAR_3));\n  }\n  (*VAR_0)->strs[VAR_1] = VAR_3;\n  memcpy((*VAR_0)->arena + VAR_3, &VAR_2, sizeof(VAR_2));\n}",
  "func_graph_path_before": "grpc/c6ec1155d026c91b1badb07ef1605bb747cff064/error.c/vul/before/4.json",
  "func": "static void internal_set_str(grpc_error **err, grpc_error_strs which,\n                             grpc_slice value) {\n  uint8_t slot = (*err)->strs[which];\n  if (slot == UINT8_MAX) {\n    slot = get_placement(err, sizeof(value));\n    if (slot == UINT8_MAX) {\n      const char *str = grpc_slice_to_c_string(value);\n      gpr_log(GPR_ERROR, \"Error %p is full, dropping string {\\\"%s\\\":\\\"%s\\\"}\",\n              *err, error_str_name(which), str);\n      gpr_free((void *)str);\n      return;\n    }\n  } else {\n    unref_slice(*(grpc_slice *)((*err)->arena + slot));\n  }\n  (*err)->strs[which] = slot;\n  memcpy((*err)->arena + slot, &value, sizeof(value));\n}",
  "abstract_func": "static void internal_set_str(grpc_error **VAR_0, grpc_error_strs VAR_1,\n                             grpc_slice VAR_2) {\n  uint8_t VAR_3 = (*VAR_0)->strs[VAR_1];\n  if (VAR_3 == VAR_4) {\n    VAR_3 = get_placement(VAR_0, sizeof(VAR_2));\n    if (VAR_3 == VAR_4) {\n      const char *VAR_5 = grpc_slice_to_c_string(VAR_2);\n      gpr_log(VAR_6, \"Error %p is full, dropping string {\\\"%s\\\":\\\"%s\\\"}\",\n              *VAR_0, error_str_name(VAR_1), VAR_5);\n      gpr_free((void *)VAR_5);\n      return;\n    }\n  } else {\n    unref_slice(*(grpc_slice *)((*VAR_0)->arena + VAR_3));\n  }\n  (*VAR_0)->strs[VAR_1] = VAR_3;\n  memcpy((*VAR_0)->arena + VAR_3, &VAR_2, sizeof(VAR_2));\n}",
  "func_graph_path": "grpc/c6ec1155d026c91b1badb07ef1605bb747cff064/error.c/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,15 @@\n static void internal_set_str(grpc_error **err, grpc_error_strs which,\n                              grpc_slice value) {\n-  // GPR_ASSERT((*err)->strs[which] == UINT8_MAX); // TODO, enforce this\n   uint8_t slot = (*err)->strs[which];\n   if (slot == UINT8_MAX) {\n     slot = get_placement(err, sizeof(value));\n+    if (slot == UINT8_MAX) {\n+      const char *str = grpc_slice_to_c_string(value);\n+      gpr_log(GPR_ERROR, \"Error %p is full, dropping string {\\\"%s\\\":\\\"%s\\\"}\",\n+              *err, error_str_name(which), str);\n+      gpr_free((void *)str);\n+      return;\n+    }\n   } else {\n     unref_slice(*(grpc_slice *)((*err)->arena + slot));\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "  // GPR_ASSERT((*err)->strs[which] == UINT8_MAX); // TODO, enforce this"
    ],
    "added_lines": [
      "    if (slot == UINT8_MAX) {",
      "      const char *str = grpc_slice_to_c_string(value);",
      "      gpr_log(GPR_ERROR, \"Error %p is full, dropping string {\\\"%s\\\":\\\"%s\\\"}\",",
      "              *err, error_str_name(which), str);",
      "      gpr_free((void *)str);",
      "      return;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/grpc/grpc/pull/10492",
  "description": {
    "pr_info": {
      "title": "Fix Error Overflow Bug",
      "number": 10492
    },
    "comment": [
      "Errors now drop and log data when they are too full. Added the fuzzer that caught this. Also added a new test case to error_test to hit some of this new functionality.",
      "This fixes: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1018",
      "```\nNo significant performance differences\n```",
      "```\nNo significant performance differences\n```",
      "Failures: #9804, Docker python flake"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses an overflow bug by enhancing error handling and adding tests. It's a bug fix rather than a security vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}