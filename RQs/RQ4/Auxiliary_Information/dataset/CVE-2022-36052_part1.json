{
  "cve_id": "CVE-2022-36052",
  "cwe_ids": [
    "CWE-787",
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "Prevent a possible read out of bounds in the processing of IPv6 extension headers.",
  "commit_hash": "9cdec6e19865d7b0d8caf61f1a34001f64d565b0",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/9cdec6e19865d7b0d8caf61f1a34001f64d565b0",
  "file_path": "os/net/ipv6/uipbuf.c",
  "func_name": "uipbuf_get_next_header",
  "func_before": "uint8_t *\nuipbuf_get_next_header(uint8_t *buffer, uint16_t size, uint8_t *protocol, bool start)\n{\n  int curr_hdr_len = 0;\n  int next_hdr_len = 0;\n  uint8_t *next_header = NULL;\n  struct uip_ip_hdr *ipbuf = NULL;\n  struct uip_ext_hdr *curr_ext = NULL;\n  struct uip_ext_hdr *next_ext = NULL;\n\n  if(start) {\n    /* protocol in the IP buffer */\n    ipbuf = (struct uip_ip_hdr *)buffer;\n    *protocol = ipbuf->proto;\n    curr_hdr_len = UIP_IPH_LEN;\n  } else {\n    /* protocol in the Ext hdr */\n    curr_ext = (struct uip_ext_hdr *)buffer;\n    *protocol = curr_ext->next;\n    /* This is just an ext header */\n    curr_hdr_len = (curr_ext->len << 3) + 8;\n  }\n\n  /* Check first if enough space for current header */\n  if(curr_hdr_len > size) {\n    return NULL;\n  }\n  next_header = buffer + curr_hdr_len;\n\n  /* Check if the buffer is large enough for the next header */\n  if(uip_is_proto_ext_hdr(*protocol)) {\n    next_ext = (struct uip_ext_hdr *)next_header;\n    next_hdr_len = (next_ext->len << 3) + 8;\n  } else {\n    if(*protocol == UIP_PROTO_TCP) {\n      next_hdr_len = UIP_TCPH_LEN;\n    } else if(*protocol == UIP_PROTO_UDP) {\n      next_hdr_len = UIP_UDPH_LEN;\n    } else if(*protocol == UIP_PROTO_ICMP6) {\n      next_hdr_len = UIP_ICMPH_LEN;\n    }\n  }\n\n  /* Size must be enough to hold both the current and next header */\n  if(next_hdr_len == 0 || curr_hdr_len + next_hdr_len > size) {\n    return NULL;\n  }\n\n  return next_header;\n}",
  "abstract_func_before": "uint8_t *\nuipbuf_get_next_header(uint8_t *VAR_0, uint16_t VAR_1, uint8_t *VAR_2, bool VAR_3)\n{\n  int VAR_4 = 0;\n  int VAR_5 = 0;\n  uint8_t *VAR_6 = NULL;\n  struct uip_ip_hdr *VAR_7 = NULL;\n  struct uip_ext_hdr *VAR_8 = NULL;\n  struct uip_ext_hdr *VAR_9 = NULL;\n\n  if(VAR_3) {\n    /* COMMENT_0 */\n    VAR_7 = (struct uip_ip_hdr *)VAR_0;\n    *VAR_2 = VAR_7->proto;\n    VAR_4 = VAR_10;\n  } else {\n    /* COMMENT_1 */\n    VAR_8 = (struct uip_ext_hdr *)VAR_0;\n    *VAR_2 = VAR_8->next;\n    /* COMMENT_2 */\n    VAR_4 = (VAR_8->len << 3) + 8;\n  }\n\n  /* COMMENT_3 */\n  if(VAR_4 > VAR_1) {\n    return NULL;\n  }\n  VAR_6 = VAR_0 + VAR_4;\n\n  /* COMMENT_4 */\n  if(uip_is_proto_ext_hdr(*VAR_2)) {\n    VAR_9 = (struct uip_ext_hdr *)VAR_6;\n    VAR_5 = (VAR_9->len << 3) + 8;\n  } else {\n    if(*VAR_2 == VAR_11) {\n      VAR_5 = VAR_12;\n    } else if(*VAR_2 == VAR_13) {\n      VAR_5 = VAR_14;\n    } else if(*VAR_2 == VAR_15) {\n      VAR_5 = VAR_16;\n    }\n  }\n\n  /* COMMENT_5 */\n  if(VAR_5 == 0 || VAR_4 + VAR_5 > VAR_1) {\n    return NULL;\n  }\n\n  return VAR_6;\n}",
  "func_graph_path_before": "contiki-ng/9cdec6e19865d7b0d8caf61f1a34001f64d565b0/uipbuf.c/vul/before/0.json",
  "func": "uint8_t *\nuipbuf_get_next_header(uint8_t *buffer, uint16_t size, uint8_t *protocol, bool start)\n{\n  int curr_hdr_len = 0;\n  int next_hdr_len = 0;\n  uint8_t *next_header = NULL;\n  struct uip_ip_hdr *ipbuf = NULL;\n  struct uip_ext_hdr *curr_ext = NULL;\n  struct uip_ext_hdr *next_ext = NULL;\n\n  if(start) {\n    /* protocol in the IP buffer */\n    ipbuf = (struct uip_ip_hdr *)buffer;\n    *protocol = ipbuf->proto;\n    curr_hdr_len = UIP_IPH_LEN;\n  } else {\n    /* protocol in the Ext hdr */\n    curr_ext = (struct uip_ext_hdr *)buffer;\n    *protocol = curr_ext->next;\n    /* This is just an ext header */\n    curr_hdr_len = (curr_ext->len << 3) + 8;\n  }\n\n  /* Check first if enough space for current header */\n  if(curr_hdr_len > size) {\n    return NULL;\n  }\n  next_header = buffer + curr_hdr_len;\n\n  /* Check if the buffer is large enough for the next header */\n  if(uip_is_proto_ext_hdr(*protocol)) {\n    if(curr_hdr_len + sizeof(struct uip_ext_hdr) > size) {\n      return NULL;\n    }\n    next_ext = (struct uip_ext_hdr *)next_header;\n    next_hdr_len = (next_ext->len << 3) + 8;\n  } else {\n    if(*protocol == UIP_PROTO_TCP) {\n      next_hdr_len = UIP_TCPH_LEN;\n    } else if(*protocol == UIP_PROTO_UDP) {\n      next_hdr_len = UIP_UDPH_LEN;\n    } else if(*protocol == UIP_PROTO_ICMP6) {\n      next_hdr_len = UIP_ICMPH_LEN;\n    }\n  }\n\n  /* Size must be enough to hold both the current and next header */\n  if(next_hdr_len == 0 || curr_hdr_len + next_hdr_len > size) {\n    return NULL;\n  }\n\n  return next_header;\n}",
  "abstract_func": "uint8_t *\nuipbuf_get_next_header(uint8_t *VAR_0, uint16_t VAR_1, uint8_t *VAR_2, bool VAR_3)\n{\n  int VAR_4 = 0;\n  int VAR_5 = 0;\n  uint8_t *VAR_6 = NULL;\n  struct uip_ip_hdr *VAR_7 = NULL;\n  struct uip_ext_hdr *VAR_8 = NULL;\n  struct uip_ext_hdr *VAR_9 = NULL;\n\n  if(VAR_3) {\n    /* COMMENT_0 */\n    VAR_7 = (struct uip_ip_hdr *)VAR_0;\n    *VAR_2 = VAR_7->proto;\n    VAR_4 = VAR_10;\n  } else {\n    /* COMMENT_1 */\n    VAR_8 = (struct uip_ext_hdr *)VAR_0;\n    *VAR_2 = VAR_8->next;\n    /* COMMENT_2 */\n    VAR_4 = (VAR_8->len << 3) + 8;\n  }\n\n  /* COMMENT_3 */\n  if(VAR_4 > VAR_1) {\n    return NULL;\n  }\n  VAR_6 = VAR_0 + VAR_4;\n\n  /* COMMENT_4 */\n  if(uip_is_proto_ext_hdr(*VAR_2)) {\n    if(VAR_4 + sizeof(struct uip_ext_hdr) > VAR_1) {\n      return NULL;\n    }\n    VAR_9 = (struct uip_ext_hdr *)VAR_6;\n    VAR_5 = (VAR_9->len << 3) + 8;\n  } else {\n    if(*VAR_2 == VAR_11) {\n      VAR_5 = VAR_12;\n    } else if(*VAR_2 == VAR_13) {\n      VAR_5 = VAR_14;\n    } else if(*VAR_2 == VAR_15) {\n      VAR_5 = VAR_16;\n    }\n  }\n\n  /* COMMENT_5 */\n  if(VAR_5 == 0 || VAR_4 + VAR_5 > VAR_1) {\n    return NULL;\n  }\n\n  return VAR_6;\n}",
  "func_graph_path": "contiki-ng/9cdec6e19865d7b0d8caf61f1a34001f64d565b0/uipbuf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,9 @@\n \n   /* Check if the buffer is large enough for the next header */\n   if(uip_is_proto_ext_hdr(*protocol)) {\n+    if(curr_hdr_len + sizeof(struct uip_ext_hdr) > size) {\n+      return NULL;\n+    }\n     next_ext = (struct uip_ext_hdr *)next_header;\n     next_hdr_len = (next_ext->len << 3) + 8;\n   } else {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if(curr_hdr_len + sizeof(struct uip_ext_hdr) > size) {",
      "      return NULL;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1648",
  "description": {
    "pr_info": {
      "title": "uipbuf: Do not assume that there is enough space for a following extension header",
      "number": 1648
    },
    "comment": [
      "When processing IPv6 extension headers in uipbuf.c, we need to check the offset before casting to a <code>uip_ext_hdr</code> pointer."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}