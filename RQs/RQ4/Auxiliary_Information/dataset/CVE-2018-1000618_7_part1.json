{
  "cve_id": "CVE-2018-1000618",
  "cwe_ids": [
    "CWE-674"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "EOSIO/eos",
  "commit_msg": "Pass recursion_depth to binary_to_variant and variant_to_binary",
  "commit_hash": "cc5722858cc24808f7bd4fa699718eec0240b3a2",
  "git_url": "https://github.com/EOSIO/eos/commit/cc5722858cc24808f7bd4fa699718eec0240b3a2",
  "file_path": "libraries/chain/include/eosio/chain/abi_serializer.hpp",
  "func_name": "add",
  "func_before": "static void add(mutable_variant_object &out, const char* name, const action& act, Resolver resolver, size_t recursion_depth) {\n         FC_ASSERT( ++recursion_depth < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         mutable_variant_object mvo;\n         mvo(\"account\", act.account);\n         mvo(\"name\", act.name);\n         mvo(\"authorization\", act.authorization);\n\n         auto abi = resolver(act.account);\n         if (abi.valid()) {\n            auto type = abi->get_action_type(act.name);\n            if (!type.empty()) {\n               try {\n                  mvo( \"data\", abi->binary_to_variant( type, act.data ));\n                  mvo(\"hex_data\", act.data);\n               } catch(...) {\n                  // any failure to serialize data, then leave as not serailzed\n                  mvo(\"data\", act.data);\n               }\n            } else {\n               mvo(\"data\", act.data);\n            }\n         } else {\n            mvo(\"data\", act.data);\n         }\n         out(name, std::move(mvo));\n      }",
  "abstract_func_before": "static void add(mutable_variant_object &VAR_0, const char* VAR_1, const action& VAR_2, Resolver VAR_3, size_t VAR_4) {\n         FC_ASSERT( ++VAR_4 < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         mutable_variant_object VAR_5;\n         VAR_5(\"account\", VAR_2.account);\n         VAR_5(\"name\", VAR_2.name);\n         VAR_5(\"authorization\", VAR_2.authorization);\n\n         auto VAR_6 = VAR_3(VAR_2.account);\n         if (VAR_6.valid()) {\n            auto VAR_7 = VAR_6->get_action_type(VAR_2.name);\n            if (!VAR_7.empty()) {\n               try {\n                  VAR_5( \"data\", VAR_6->binary_to_variant( VAR_7, VAR_2.data ));\n                  VAR_5(\"hex_data\", VAR_2.data);\n               } catch(...) {\n                  /* COMMENT_0 */\n                  VAR_5(\"data\", VAR_2.data);\n               }\n            } else {\n               VAR_5(\"data\", VAR_2.data);\n            }\n         } else {\n            VAR_5(\"data\", VAR_2.data);\n         }\n         VAR_0(VAR_1, std::move(VAR_5));\n      }",
  "func_graph_path_before": null,
  "func": "static void add(mutable_variant_object &out, const char* name, const action& act, Resolver resolver, size_t recursion_depth) {\n         FC_ASSERT( ++recursion_depth < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         mutable_variant_object mvo;\n         mvo(\"account\", act.account);\n         mvo(\"name\", act.name);\n         mvo(\"authorization\", act.authorization);\n\n         auto abi = resolver(act.account);\n         if (abi.valid()) {\n            auto type = abi->get_action_type(act.name);\n            if (!type.empty()) {\n               try {\n                  mvo( \"data\", abi->_binary_to_variant( type, act.data, recursion_depth ));\n                  mvo(\"hex_data\", act.data);\n               } catch(...) {\n                  // any failure to serialize data, then leave as not serailzed\n                  mvo(\"data\", act.data);\n               }\n            } else {\n               mvo(\"data\", act.data);\n            }\n         } else {\n            mvo(\"data\", act.data);\n         }\n         out(name, std::move(mvo));\n      }",
  "abstract_func": "static void add(mutable_variant_object &VAR_0, const char* VAR_1, const action& VAR_2, Resolver VAR_3, size_t VAR_4) {\n         FC_ASSERT( ++VAR_4 < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         mutable_variant_object VAR_5;\n         VAR_5(\"account\", VAR_2.account);\n         VAR_5(\"name\", VAR_2.name);\n         VAR_5(\"authorization\", VAR_2.authorization);\n\n         auto VAR_6 = VAR_3(VAR_2.account);\n         if (VAR_6.valid()) {\n            auto VAR_7 = VAR_6->get_action_type(VAR_2.name);\n            if (!VAR_7.empty()) {\n               try {\n                  VAR_5( \"data\", VAR_6->_binary_to_variant( VAR_7, VAR_2.data, VAR_4 ));\n                  VAR_5(\"hex_data\", VAR_2.data);\n               } catch(...) {\n                  /* COMMENT_0 */\n                  VAR_5(\"data\", VAR_2.data);\n               }\n            } else {\n               VAR_5(\"data\", VAR_2.data);\n            }\n         } else {\n            VAR_5(\"data\", VAR_2.data);\n         }\n         VAR_0(VAR_1, std::move(VAR_5));\n      }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n             auto type = abi->get_action_type(act.name);\n             if (!type.empty()) {\n                try {\n-                  mvo( \"data\", abi->binary_to_variant( type, act.data ));\n+                  mvo( \"data\", abi->_binary_to_variant( type, act.data, recursion_depth ));\n                   mvo(\"hex_data\", act.data);\n                } catch(...) {\n                   // any failure to serialize data, then leave as not serailzed",
  "diff_line_info": {
    "deleted_lines": [
      "                  mvo( \"data\", abi->binary_to_variant( type, act.data ));"
    ],
    "added_lines": [
      "                  mvo( \"data\", abi->_binary_to_variant( type, act.data, recursion_depth ));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EOSIO/eos/pull/4112",
  "description": {
    "pr_info": {
      "title": "Pretty print transactions",
      "number": 4112
    },
    "comment": [
      "Enhanced the abi_serializer to be able to deserialize transactions even if they have invalid abi set on the contract. So even with invalid abi the transaction can still be pretty-printed. In the case of invalid abi the action data is left in hex since there is no way to deserialize it. This allows indexers like the mongodb plugin to serialize the parts of transaction that are serializable without the user provided abi.\r\n\r\nI suspect this will fix issue #4111 that was just submitted.",
      "@heifner My issue is still there. [issue#4111](https://github.com/EOSIO/eos/issues/4111)\r\nThis is the error I'm getting:\r\nInvalid packed transaction\r\npivot != std::string::npos: No delimiter in string, cannot determine type: EOSK59ovuuemzcGX1QKATF4pEVg2AmUT2rjQAH8MrC52SpmBZ59YPVYMFYTBg7XNgCDQcX18vMyDsjEp4SbyDnkcUvruZ94BX\r\nFailed to deserialize variant",
      "This is the command I'm using and getting error:\r\ncleos -H node1.eosphere.io --wallet-host localhost --wallet-port 8888 set contract eosuser build/contracts/eosio.token -p eosuser\r\n\r\nGetting same error for every contract\r\n\r\ncleos version client: 15953cc1\r\n\r\nPlease, help me to fix this.\r\nThanks",
      "@heifner The problem is coming from here /eos/libraries/fc/src/crypto/signature.cpp:\r\n const auto pivot = base58str.find('_');\r\n      FC_ASSERT(pivot != std::string::npos, \"No delimiter in string, cannot determine type: ${str}\", (\"str\", base58str));\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8"
}