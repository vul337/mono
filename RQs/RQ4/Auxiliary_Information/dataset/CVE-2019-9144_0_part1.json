{
  "cve_id": "CVE-2019-9144",
  "cwe_ids": [
    "CWE-674"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Add comment to explain choice of cut-off value.",
  "commit_hash": "a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b",
  "git_url": "https://github.com/Exiv2/exiv2/commit/a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b",
  "file_path": "src/bigtiffimage.cpp",
  "func_name": "printIFD",
  "func_before": "void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    // Fix for https://github.com/Exiv2/exiv2/issues/712\n                    // A malicious file can cause a very deep recursion, leading to\n                    // stack exhaustion.\n                    if (depth > 200) {\n                      out << Internal::indent(depth) << \"Maximum indentation depth exceeded.\" << std::endl;\n                      return;\n                    }\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << \"STRUCTURE OF BIGTIFF FILE \" << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \"entries = \" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \"\" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |\",\n                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)\n                                    <<(usePointer ? Internal::stringFormat(\"%10u | \",(size_t)offset)\n                                                  : Internal::stringFormat(\"%10s | \",\"\"))\n                                    ;\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \"/\" << b;\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));\n\n                                sp = kount == count ? \"\" : \" ...\";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    if (Safe::add(count, offset) > io.size()) {\n                                        throw Error(kerCorruptedMetadata);\n                                    }\n\n                                    const size_t restore = io.tell();\n                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory\n                                    // TODO: once we have C++11 use bytes.data()\n                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));\n                                    io.seek(restore, BasicIo::beg);\n                                    // TODO: once we have C++11 use bytes.data()\n                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\"Nikon\",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n                }",
  "abstract_func_before": "void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)\n                {\n                    BasicIo& VAR_4 = Image::io();\n\n                    /* COMMENT_0 */\n                    /* COMMENT_1 */\n                    /* COMMENT_2 */\n                    if (VAR_3 > 200) {\n                      VAR_0 << Internal::indent(VAR_3) << \"Maximum indentation depth exceeded.\" << std::endl;\n                      return;\n                    }\n\n                    VAR_3++;\n                    bool VAR_5  = true;\n\n                    /* COMMENT_3 */\n                    bool VAR_6 = true;\n\n                    do\n                    {\n                        /* COMMENT_4 */\n                        VAR_4.seek(VAR_7<int64>(VAR_2), BasicIo::beg);\n\n                        const uint64_t VAR_8 = readData(VAR_9.format() == Header::StandardTiff? 2: 8);\n                        const bool VAR_10 = VAR_8 > 500;\n\n                        if ( VAR_5 && VAR_6 )\n                        {\n                            VAR_0 << Internal::indent(VAR_3) << \"STRUCTURE OF BIGTIFF FILE \" << VAR_4.path() << std::endl;\n                            if (VAR_10)\n                                VAR_0 << Internal::indent(VAR_3) << \"entries = \" << VAR_8 << std::endl;\n                        }\n\n                        if (VAR_10)\n                            break;\n\n                        /* COMMENT_5 */\n                        for ( uint64_t VAR_11 = 0; VAR_11 < VAR_8; VAR_11 ++ )\n                        {\n                            if ( VAR_5 && VAR_6 )\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            VAR_5 = false;\n\n                            const uint16_t VAR_12   = (uint16_t) readData(2);\n                            const uint16_t VAR_13  = (uint16_t) readData(2);\n                            const uint64_t VAR_14 = readData(VAR_15);\n                            const DataBuf  VAR_16  = VAR_4.read(VAR_15);        /* COMMENT_6 */\n\n                            std::string VAR_17 = \"\" ; /* COMMENT_7 */\n\n                            /* COMMENT_8 */\n                            /* COMMENT_9 */\n                            const uint64_t VAR_18  = isStringType(VAR_13)? (VAR_14 > 32 ? 32 : VAR_14) /* COMMENT_10 */\n                                                            : VAR_14 > 5              ? 5\n                                                            : VAR_14\n                                                            ;\n                            const uint32_t VAR_19    = isStringType(VAR_13) ? 1 : 0;\n                            const uint32_t VAR_20   = isStringType(VAR_13) ? 1\n                                                  : is2ByteType(VAR_13)  ? 2\n                                                  : is4ByteType(VAR_13)  ? 4\n                                                  : is8ByteType(VAR_13)  ? 8\n                                                  : 1;\n\n                            /* COMMENT_11 */\n\n                            /* COMMENT_12 */\n                            /* COMMENT_13 */\n                            /* COMMENT_14 */\n                            /* COMMENT_15 */\n                            if (VAR_14 != 0) {\n                                if (VAR_20 > std::numeric_limits<uint64_t>::max() / VAR_14) {\n                                    throw Error(VAR_21);             /* COMMENT_16 */\n                                }\n                            }\n                                                             /* COMMENT_17 */\n\n                            if (VAR_20 * VAR_14 > std::numeric_limits<uint64_t>::max() - VAR_19)\n                                throw Error(VAR_21);             /* COMMENT_18 */\n\n                            const uint64_t VAR_22 = VAR_20*VAR_14 + VAR_19;\n                            if ( VAR_22 > VAR_4.size() ) {\n                                throw Error(VAR_21);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t VAR_23 = VAR_9.format() == Header::StandardTiff?\n                                    byteSwap4(VAR_16, 0, VAR_24):\n                                    byteSwap8(VAR_16, 0, VAR_24);\n\n                            /* COMMENT_19 */\n                            const bool VAR_25 = (size_t) VAR_14*VAR_20 > (size_t) VAR_15;\n\n                            if ( VAR_25 )                          /* COMMENT_20 */\n                            {\n                                size_t   VAR_26 = VAR_4.tell();          /* COMMENT_21 */\n                                VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);         /* COMMENT_22 */\n                                VAR_4.read(VAR_27.pData_, (long) VAR_14 * VAR_20);     /* COMMENT_23 */\n                                VAR_4.seek(VAR_26, BasicIo::beg);        /* COMMENT_24 */\n                            }\n                            else  /* COMMENT_25 */\n                                std::memcpy(VAR_27.pData_, VAR_16.pData_, (size_t) VAR_14 * VAR_20);     /* COMMENT_26 */\n\n                            if ( VAR_6 )\n                            {\n                                const uint64_t VAR_28 = VAR_9.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t VAR_29 = VAR_2 + 2 + VAR_11 * VAR_28;\n\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |\",\n                                        static_cast<size_t>(VAR_29), VAR_12, tagName(VAR_12).c_str(), typeName(VAR_13), VAR_14)\n                                    <<(VAR_25 ? Internal::stringFormat(\"%10u | \",(size_t)VAR_23)\n                                                  : Internal::stringFormat(\"%10s | \",\"\"))\n                                    ;\n                                if ( isShortType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_17 << byteSwap2(VAR_27, VAR_30*VAR_20, VAR_24);\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isLongType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_17 << byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_17 << byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24);\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        uint32_t VAR_31 = byteSwap4(VAR_27, VAR_30*VAR_20+0, VAR_24);\n                                        uint32_t VAR_32 = byteSwap4(VAR_27, VAR_30*VAR_20+4, VAR_24);\n                                        VAR_0 << VAR_17 << VAR_31 << \"/\" << VAR_32;\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isStringType(VAR_13) )\n                                    VAR_0 << VAR_17 << Internal::binaryToString(makeSlice(VAR_27, 0, static_cast<size_t>(VAR_18)));\n\n                                VAR_17 = VAR_18 == VAR_14 ? \"\" : \" ...\";\n                                VAR_0 << VAR_17 << std::endl;\n\n                                if ( VAR_1 == VAR_33 &&\n                                        (VAR_12 == 0x8769 /* COMMENT_27 */ || VAR_12 == 0x014a/* COMMENT_28 */ || VAR_13 == VAR_34 || VAR_13 == VAR_35) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_14 ; VAR_30++ )\n                                    {\n                                        const size_t VAR_26 = VAR_4.tell();\n                                        const uint64_t VAR_36 = VAR_13 == VAR_35?\n                                            byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24):\n                                            byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);\n\n                                        printIFD(VAR_0, VAR_1, VAR_36, VAR_3);\n                                        VAR_4.seek(VAR_26, BasicIo::beg);\n                                    }\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x83bb /* COMMENT_29 */ )\n                                {\n                                    if (Safe::add(VAR_14, VAR_23) > VAR_4.size()) {\n                                        throw Error(VAR_37);\n                                    }\n\n                                    const size_t VAR_26 = VAR_4.tell();\n                                    VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);  /* COMMENT_22 */\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  /* COMMENT_30 */\n                                    /* COMMENT_31 */\n                                    const size_t VAR_38 = VAR_4.read(&VAR_39[0], static_cast<long>(count));\n                                    VAR_4.seek(VAR_26, BasicIo::beg);\n                                    /* COMMENT_31 */\n                                    IptcData::printStructure(VAR_0, makeSliceUntil(&VAR_39[0], VAR_38), VAR_3);\n\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x927c /* COMMENT_32 */ && count > 10)\n                                {\n                                    size_t   VAR_26 = VAR_4.tell();  /* COMMENT_21 */\n\n                                    long VAR_40= 10           ;\n                                    byte     VAR_39[20]          ;\n                                    const char* VAR_41 = (const char*) &VAR_39[0] ;\n                                    VAR_4.seek(static_cast<int64>(VAR_2), BasicIo::beg);  /* COMMENT_22 */\n                                    VAR_4.read(VAR_39,VAR_40    )     ;  /* COMMENT_23 */\n                                    VAR_39[VAR_40]=0               ;\n                                    if ( ::strcmp(\"Nikon\",VAR_41) == 0 )\n                                    {\n                                      /* COMMENT_33 */\n                                      std::vector<byte> VAR_42(static_cast<size_t>(count - VAR_40));\n\n                                      VAR_4.read(&VAR_42.at(0), (long)VAR_42.size());\n                                      MemIo VAR_43(&VAR_42.at(0), (long)count - VAR_40); /* COMMENT_34 */\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      /* COMMENT_35 */\n                                      /* COMMENT_36 */\n                                    }\n                                    else\n                                    {\n                                        /* COMMENT_37 */\n                                        VAR_4.seek(0, BasicIo::beg);  /* COMMENT_22 */\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(VAR_0,VAR_1,VAR_23,VAR_3);\n                                    }\n\n                                    VAR_4.seek(VAR_26,BasicIo::beg); /* COMMENT_24 */\n                                }\n                            }\n                        }\n\n                        const uint64_t VAR_44 = readData(VAR_15);\n\n                        VAR_2 = VAR_10 ? 0 : VAR_44;\n                        VAR_0.flush();\n                    } while (VAR_2 != 0);\n\n                    if ( VAR_6 )\n                        VAR_0 << Internal::indent(VAR_3) << \"END \" << VAR_4.path() << std::endl;\n                }",
  "func_graph_path_before": "Exiv2/exiv2/a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b/bigtiffimage.cpp/vul/before/0.json",
  "func": "void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    // Fix for https://github.com/Exiv2/exiv2/issues/712\n                    // A malicious file can cause a very deep recursion, leading to\n                    // stack exhaustion.\n                    // Note: 200 is an arbitrarily chosen cut-off value. The value\n                    // of depth determines the amount of indentation inserted by the\n                    // pretty-printer. The output starts to become unreadable as\n                    // soon as the indentation exceeds 80 characters or so. That's\n                    // why 200 ought to be a reasonable cut-off.\n                    if (depth > 200) {\n                      out << Internal::indent(depth) << \"Maximum indentation depth exceeded.\" << std::endl;\n                      return;\n                    }\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << \"STRUCTURE OF BIGTIFF FILE \" << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \"entries = \" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \"\" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |\",\n                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)\n                                    <<(usePointer ? Internal::stringFormat(\"%10u | \",(size_t)offset)\n                                                  : Internal::stringFormat(\"%10s | \",\"\"))\n                                    ;\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \"/\" << b;\n                                        sp = \" \";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));\n\n                                sp = kount == count ? \"\" : \" ...\";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    if (Safe::add(count, offset) > io.size()) {\n                                        throw Error(kerCorruptedMetadata);\n                                    }\n\n                                    const size_t restore = io.tell();\n                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory\n                                    // TODO: once we have C++11 use bytes.data()\n                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));\n                                    io.seek(restore, BasicIo::beg);\n                                    // TODO: once we have C++11 use bytes.data()\n                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\"Nikon\",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n                }",
  "abstract_func": "void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)\n                {\n                    BasicIo& VAR_4 = Image::io();\n\n                    /* COMMENT_0 */\n                    /* COMMENT_1 */\n                    /* COMMENT_2 */\n                    /* COMMENT_3 */\n                    /* COMMENT_4 */\n                    /* COMMENT_5 */\n                    /* COMMENT_6 */\n                    /* COMMENT_7 */\n                    if (VAR_3 > 200) {\n                      VAR_0 << Internal::indent(VAR_3) << \"Maximum indentation depth exceeded.\" << std::endl;\n                      return;\n                    }\n\n                    VAR_3++;\n                    bool VAR_5  = true;\n\n                    /* COMMENT_8 */\n                    bool VAR_6 = true;\n\n                    do\n                    {\n                        /* COMMENT_9 */\n                        VAR_4.seek(VAR_7<int64>(VAR_2), BasicIo::beg);\n\n                        const uint64_t VAR_8 = readData(VAR_9.format() == Header::StandardTiff? 2: 8);\n                        const bool VAR_10 = VAR_8 > 500;\n\n                        if ( VAR_5 && VAR_6 )\n                        {\n                            VAR_0 << Internal::indent(VAR_3) << \"STRUCTURE OF BIGTIFF FILE \" << VAR_4.path() << std::endl;\n                            if (VAR_10)\n                                VAR_0 << Internal::indent(VAR_3) << \"entries = \" << VAR_8 << std::endl;\n                        }\n\n                        if (VAR_10)\n                            break;\n\n                        /* COMMENT_10 */\n                        for ( uint64_t VAR_11 = 0; VAR_11 < VAR_8; VAR_11 ++ )\n                        {\n                            if ( VAR_5 && VAR_6 )\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << \" address |    tag                           |     \"\n                                    << \" type |    count |    offset | value\\n\";\n\n                            VAR_5 = false;\n\n                            const uint16_t VAR_12   = (uint16_t) readData(2);\n                            const uint16_t VAR_13  = (uint16_t) readData(2);\n                            const uint64_t VAR_14 = readData(VAR_15);\n                            const DataBuf  VAR_16  = VAR_4.read(VAR_15);        /* COMMENT_11 */\n\n                            std::string VAR_17 = \"\" ; /* COMMENT_12 */\n\n                            /* COMMENT_13 */\n                            /* COMMENT_14 */\n                            const uint64_t VAR_18  = isStringType(VAR_13)? (VAR_14 > 32 ? 32 : VAR_14) /* COMMENT_15 */\n                                                            : VAR_14 > 5              ? 5\n                                                            : VAR_14\n                                                            ;\n                            const uint32_t VAR_19    = isStringType(VAR_13) ? 1 : 0;\n                            const uint32_t VAR_20   = isStringType(VAR_13) ? 1\n                                                  : is2ByteType(VAR_13)  ? 2\n                                                  : is4ByteType(VAR_13)  ? 4\n                                                  : is8ByteType(VAR_13)  ? 8\n                                                  : 1;\n\n                            /* COMMENT_16 */\n\n                            /* COMMENT_17 */\n                            /* COMMENT_18 */\n                            /* COMMENT_19 */\n                            /* COMMENT_20 */\n                            if (VAR_14 != 0) {\n                                if (VAR_20 > std::numeric_limits<uint64_t>::max() / VAR_14) {\n                                    throw Error(VAR_21);             /* COMMENT_21 */\n                                }\n                            }\n                                                             /* COMMENT_22 */\n\n                            if (VAR_20 * VAR_14 > std::numeric_limits<uint64_t>::max() - VAR_19)\n                                throw Error(VAR_21);             /* COMMENT_23 */\n\n                            const uint64_t VAR_22 = VAR_20*VAR_14 + VAR_19;\n                            if ( VAR_22 > VAR_4.size() ) {\n                                throw Error(VAR_21);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t VAR_23 = VAR_9.format() == Header::StandardTiff?\n                                    byteSwap4(VAR_16, 0, VAR_24):\n                                    byteSwap8(VAR_16, 0, VAR_24);\n\n                            /* COMMENT_24 */\n                            const bool VAR_25 = (size_t) VAR_14*VAR_20 > (size_t) VAR_15;\n\n                            if ( VAR_25 )                          /* COMMENT_25 */\n                            {\n                                size_t   VAR_26 = VAR_4.tell();          /* COMMENT_26 */\n                                VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);         /* COMMENT_27 */\n                                VAR_4.read(VAR_27.pData_, (long) VAR_14 * VAR_20);     /* COMMENT_28 */\n                                VAR_4.seek(VAR_26, BasicIo::beg);        /* COMMENT_29 */\n                            }\n                            else  /* COMMENT_30 */\n                                std::memcpy(VAR_27.pData_, VAR_16.pData_, (size_t) VAR_14 * VAR_20);     /* COMMENT_31 */\n\n                            if ( VAR_6 )\n                            {\n                                const uint64_t VAR_28 = VAR_9.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t VAR_29 = VAR_2 + 2 + VAR_11 * VAR_28;\n\n                                VAR_0 << Internal::indent(VAR_3)\n                                    << Internal::stringFormat(\"%8u | %#06x %-25s |%10s |%9u |\",\n                                        static_cast<size_t>(VAR_29), VAR_12, tagName(VAR_12).c_str(), typeName(VAR_13), VAR_14)\n                                    <<(VAR_25 ? Internal::stringFormat(\"%10u | \",(size_t)VAR_23)\n                                                  : Internal::stringFormat(\"%10s | \",\"\"))\n                                    ;\n                                if ( isShortType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_17 << byteSwap2(VAR_27, VAR_30*VAR_20, VAR_24);\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isLongType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_17 << byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isLongLongType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        VAR_0 << VAR_17 << byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24);\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isRationalType(VAR_13) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )\n                                    {\n                                        uint32_t VAR_31 = byteSwap4(VAR_27, VAR_30*VAR_20+0, VAR_24);\n                                        uint32_t VAR_32 = byteSwap4(VAR_27, VAR_30*VAR_20+4, VAR_24);\n                                        VAR_0 << VAR_17 << VAR_31 << \"/\" << VAR_32;\n                                        VAR_17 = \" \";\n                                    }\n                                }\n                                else if ( isStringType(VAR_13) )\n                                    VAR_0 << VAR_17 << Internal::binaryToString(makeSlice(VAR_27, 0, static_cast<size_t>(VAR_18)));\n\n                                VAR_17 = VAR_18 == VAR_14 ? \"\" : \" ...\";\n                                VAR_0 << VAR_17 << std::endl;\n\n                                if ( VAR_1 == VAR_33 &&\n                                        (VAR_12 == 0x8769 /* COMMENT_32 */ || VAR_12 == 0x014a/* COMMENT_33 */ || VAR_13 == VAR_34 || VAR_13 == VAR_35) )\n                                {\n                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_14 ; VAR_30++ )\n                                    {\n                                        const size_t VAR_26 = VAR_4.tell();\n                                        const uint64_t VAR_36 = VAR_13 == VAR_35?\n                                            byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24):\n                                            byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);\n\n                                        printIFD(VAR_0, VAR_1, VAR_36, VAR_3);\n                                        VAR_4.seek(VAR_26, BasicIo::beg);\n                                    }\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x83bb /* COMMENT_34 */ )\n                                {\n                                    if (Safe::add(VAR_14, VAR_23) > VAR_4.size()) {\n                                        throw Error(VAR_37);\n                                    }\n\n                                    const size_t VAR_26 = VAR_4.tell();\n                                    VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);  /* COMMENT_27 */\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  /* COMMENT_35 */\n                                    /* COMMENT_36 */\n                                    const size_t VAR_38 = VAR_4.read(&VAR_39[0], static_cast<long>(count));\n                                    VAR_4.seek(VAR_26, BasicIo::beg);\n                                    /* COMMENT_36 */\n                                    IptcData::printStructure(VAR_0, makeSliceUntil(&VAR_39[0], VAR_38), VAR_3);\n\n                                }\n                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x927c /* COMMENT_37 */ && count > 10)\n                                {\n                                    size_t   VAR_26 = VAR_4.tell();  /* COMMENT_26 */\n\n                                    long VAR_40= 10           ;\n                                    byte     VAR_39[20]          ;\n                                    const char* VAR_41 = (const char*) &VAR_39[0] ;\n                                    VAR_4.seek(static_cast<int64>(VAR_2), BasicIo::beg);  /* COMMENT_27 */\n                                    VAR_4.read(VAR_39,VAR_40    )     ;  /* COMMENT_28 */\n                                    VAR_39[VAR_40]=0               ;\n                                    if ( ::strcmp(\"Nikon\",VAR_41) == 0 )\n                                    {\n                                      /* COMMENT_38 */\n                                      std::vector<byte> VAR_42(static_cast<size_t>(count - VAR_40));\n\n                                      VAR_4.read(&VAR_42.at(0), (long)VAR_42.size());\n                                      MemIo VAR_43(&VAR_42.at(0), (long)count - VAR_40); /* COMMENT_39 */\n                                      std::cerr << \"Nikon makernote\" << std::endl;\n                                      /* COMMENT_40 */\n                                      /* COMMENT_41 */\n                                    }\n                                    else\n                                    {\n                                        /* COMMENT_42 */\n                                        VAR_4.seek(0, BasicIo::beg);  /* COMMENT_27 */\n                                        std::cerr << \"makernote\" << std::endl;\n                                        printIFD(VAR_0,VAR_1,VAR_23,VAR_3);\n                                    }\n\n                                    VAR_4.seek(VAR_26,BasicIo::beg); /* COMMENT_29 */\n                                }\n                            }\n                        }\n\n                        const uint64_t VAR_44 = readData(VAR_15);\n\n                        VAR_2 = VAR_10 ? 0 : VAR_44;\n                        VAR_0.flush();\n                    } while (VAR_2 != 0);\n\n                    if ( VAR_6 )\n                        VAR_0 << Internal::indent(VAR_3) << \"END \" << VAR_4.path() << std::endl;\n                }",
  "func_graph_path": "Exiv2/exiv2/a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b/bigtiffimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,11 @@\n                     // Fix for https://github.com/Exiv2/exiv2/issues/712\n                     // A malicious file can cause a very deep recursion, leading to\n                     // stack exhaustion.\n+                    // Note: 200 is an arbitrarily chosen cut-off value. The value\n+                    // of depth determines the amount of indentation inserted by the\n+                    // pretty-printer. The output starts to become unreadable as\n+                    // soon as the indentation exceeds 80 characters or so. That's\n+                    // why 200 ought to be a reasonable cut-off.\n                     if (depth > 200) {\n                       out << Internal::indent(depth) << \"Maximum indentation depth exceeded.\" << std::endl;\n                       return;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                    // Note: 200 is an arbitrarily chosen cut-off value. The value",
      "                    // of depth determines the amount of indentation inserted by the",
      "                    // pretty-printer. The output starts to become unreadable as",
      "                    // soon as the indentation exceeds 80 characters or so. That's",
      "                    // why 200 ought to be a reasonable cut-off."
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/1091",
  "description": {
    "pr_info": {
      "title": "Bound recursion depth to avoid stack exhaustion",
      "number": 1091
    },
    "comment": [
      "Fixes #712 .\r\n\r\nNote: I added a test, but I omitted the `-pR` flag from the command line because that feature is only supported in debug builds. As far as I know, it isn't possible to specify that the test should only run on debug builds.\r\n",
      "# [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/1091?src=pr&el=h1) Report\n> Merging [#1091](https://codecov.io/gh/Exiv2/exiv2/pull/1091?src=pr&el=desc) into [master](https://codecov.io/gh/Exiv2/exiv2/commit/99be597e00cc686a66299b9bd7dbfb1d3c343356?src=pr&el=desc) will **increase** coverage by `0.02%`.\n> The diff coverage is `33.33%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/Exiv2/exiv2/pull/1091/graphs/tree.svg?width=650&token=O9G7Iswx26&height=150&src=pr)](https://codecov.io/gh/Exiv2/exiv2/pull/1091?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master    #1091      +/-   ##\n==========================================\n+ Coverage   71.81%   71.83%   +0.02%     \n==========================================\n  Files         152      152              \n  Lines       17651    17654       +3     \n==========================================\n+ Hits        12676    12682       +6     \n+ Misses       4975     4972       -3\n```\n\n\n| [Impacted Files](https://codecov.io/gh/Exiv2/exiv2/pull/1091?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [src/bigtiffimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/1091/diff?src=pr&el=tree#diff-c3JjL2JpZ3RpZmZpbWFnZS5jcHA=) | `63.21% <33.33%> (+1.23%)` | :arrow_up: |\n| [src/pngimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/1091/diff?src=pr&el=tree#diff-c3JjL3BuZ2ltYWdlLmNwcA==) | `77.81% <0%> (ø)` | :arrow_up: |\n| [src/RemoteIo.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/1091/diff?src=pr&el=tree#diff-c3JjL1JlbW90ZUlvLmNwcA==) | `0% <0%> (ø)` | :arrow_up: |\n| [src/params.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/1091/diff?src=pr&el=tree#diff-c3JjL3BhcmFtcy5jcHA=) | `72.17% <0%> (+0.31%)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/1091?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/1091?src=pr&el=footer). Last update [99be597...a6765cf](https://codecov.io/gh/Exiv2/exiv2/pull/1091?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n",
      "Fix submitted into 0.27-maintenance #1140"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nThe patch addresses a security vulnerability by preventing stack exhaustion through a depth check. The commit and code changes are consistent and clearly indicate a security fix."
}