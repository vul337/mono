{
  "cve_id": "CVE-2023-44487",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Limit the number of HTTP requests processed from a connection in I/O cycle\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>\n\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "cf687ac66b60f14a71e2a7e552943f138922a71d",
  "git_url": "https://github.com/envoyproxy/envoy/commit/cf687ac66b60f14a71e2a7e552943f138922a71d",
  "file_path": "source/common/http/conn_manager_impl.cc",
  "func_name": "ConnectionManagerImpl::ConnectionManagerImpl",
  "func_before": "ConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& config,\n                                             const Network::DrainDecision& drain_close,\n                                             Random::RandomGenerator& random_generator,\n                                             Http::Context& http_context, Runtime::Loader& runtime,\n                                             const LocalInfo::LocalInfo& local_info,\n                                             Upstream::ClusterManager& cluster_manager,\n                                             Server::OverloadManager& overload_manager,\n                                             TimeSource& time_source)\n    : config_(config), stats_(config_.stats()),\n      conn_length_(new Stats::HistogramCompletableTimespanImpl(\n          stats_.named_.downstream_cx_length_ms_, time_source)),\n      drain_close_(drain_close), user_agent_(http_context.userAgentContext()),\n      random_generator_(random_generator), runtime_(runtime), local_info_(local_info),\n      cluster_manager_(cluster_manager), listener_stats_(config_.listenerStats()),\n      overload_manager_(overload_manager),\n      overload_state_(overload_manager.getThreadLocalOverloadState()),\n      accept_new_http_stream_(overload_manager.getLoadShedPoint(\n          \"envoy.load_shed_points.http_connection_manager_decode_headers\")),\n      overload_stop_accepting_requests_ref_(\n          overload_state_.getState(Server::OverloadActionNames::get().StopAcceptingRequests)),\n      overload_disable_keepalive_ref_(\n          overload_state_.getState(Server::OverloadActionNames::get().DisableHttpKeepAlive)),\n      time_source_(time_source), proxy_name_(StreamInfo::ProxyStatusUtils::makeProxyName(\n                                     /*node_id=*/local_info_.node().id(),\n                                     /*server_name=*/config_.serverName(),\n                                     /*proxy_status_config=*/config_.proxyStatusConfig())),\n      refresh_rtt_after_request_(\n          Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.refresh_rtt_after_request\")) {\n  ENVOY_LOG_ONCE_IF(\n      trace, accept_new_http_stream_ == nullptr,\n      \"LoadShedPoint envoy.load_shed_points.http_connection_manager_decode_headers is not \"\n      \"found. Is it configured?\");\n}",
  "abstract_func_before": "ConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& VAR_0,\n                                             const Network::DrainDecision& VAR_1,\n                                             Random::RandomGenerator& VAR_2,\n                                             Http::Context& VAR_3, Runtime::Loader& VAR_4,\n                                             const LocalInfo::LocalInfo& VAR_5,\n                                             Upstream::ClusterManager& VAR_6,\n                                             Server::OverloadManager& VAR_7,\n                                             TimeSource& VAR_8)\n    : config_(VAR_0), stats_(VAR_9.stats()),\n      conn_length_(new Stats::HistogramCompletableTimespanImpl(\n          VAR_10.named_.downstream_cx_length_ms_, VAR_8)),\n      drain_close_(VAR_1), user_agent_(VAR_3.userAgentContext()),\n      random_generator_(VAR_2), runtime_(VAR_4), local_info_(VAR_5),\n      cluster_manager_(VAR_6), listener_stats_(VAR_9.listenerStats()),\n      overload_manager_(VAR_7),\n      overload_state_(VAR_7.getThreadLocalOverloadState()),\n      accept_new_http_stream_(VAR_7.getLoadShedPoint(\n          \"envoy.load_shed_points.http_connection_manager_decode_headers\")),\n      overload_stop_accepting_requests_ref_(\n          VAR_11.getState(Server::OverloadActionNames::get().StopAcceptingRequests)),\n      overload_disable_keepalive_ref_(\n          VAR_11.getState(Server::OverloadActionNames::get().DisableHttpKeepAlive)),\n      time_source_(VAR_8), proxy_name_(StreamInfo::ProxyStatusUtils::makeProxyName(\n                                     /* COMMENT_0 */VAR_12.node().id(),\n                                     /* COMMENT_1 */VAR_9.serverName(),\n                                     /* COMMENT_2 */VAR_9.proxyStatusConfig())),\n      refresh_rtt_after_request_(\n          Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.refresh_rtt_after_request\")) {\n  ENVOY_LOG_ONCE_IF(\n      VAR_13, VAR_14 == nullptr,\n      \"LoadShedPoint envoy.load_shed_points.http_connection_manager_decode_headers is not \"\n      \"found. Is it configured?\");\n}",
  "func_graph_path_before": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/before/4.json",
  "func": "ConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& config,\n                                             const Network::DrainDecision& drain_close,\n                                             Random::RandomGenerator& random_generator,\n                                             Http::Context& http_context, Runtime::Loader& runtime,\n                                             const LocalInfo::LocalInfo& local_info,\n                                             Upstream::ClusterManager& cluster_manager,\n                                             Server::OverloadManager& overload_manager,\n                                             TimeSource& time_source)\n    : config_(config), stats_(config_.stats()),\n      conn_length_(new Stats::HistogramCompletableTimespanImpl(\n          stats_.named_.downstream_cx_length_ms_, time_source)),\n      drain_close_(drain_close), user_agent_(http_context.userAgentContext()),\n      random_generator_(random_generator), runtime_(runtime), local_info_(local_info),\n      cluster_manager_(cluster_manager), listener_stats_(config_.listenerStats()),\n      overload_manager_(overload_manager),\n      overload_state_(overload_manager.getThreadLocalOverloadState()),\n      accept_new_http_stream_(overload_manager.getLoadShedPoint(\n          \"envoy.load_shed_points.http_connection_manager_decode_headers\")),\n      overload_stop_accepting_requests_ref_(\n          overload_state_.getState(Server::OverloadActionNames::get().StopAcceptingRequests)),\n      overload_disable_keepalive_ref_(\n          overload_state_.getState(Server::OverloadActionNames::get().DisableHttpKeepAlive)),\n      time_source_(time_source), proxy_name_(StreamInfo::ProxyStatusUtils::makeProxyName(\n                                     /*node_id=*/local_info_.node().id(),\n                                     /*server_name=*/config_.serverName(),\n                                     /*proxy_status_config=*/config_.proxyStatusConfig())),\n      max_requests_during_dispatch_(\n          runtime_.snapshot().getInteger(ConnectionManagerImpl::MaxRequestsPerIoCycle, UINT32_MAX)),\n      refresh_rtt_after_request_(\n          Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.refresh_rtt_after_request\")) {\n  ENVOY_LOG_ONCE_IF(\n      trace, accept_new_http_stream_ == nullptr,\n      \"LoadShedPoint envoy.load_shed_points.http_connection_manager_decode_headers is not \"\n      \"found. Is it configured?\");\n}",
  "abstract_func": "ConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& VAR_0,\n                                             const Network::DrainDecision& VAR_1,\n                                             Random::RandomGenerator& VAR_2,\n                                             Http::Context& VAR_3, Runtime::Loader& VAR_4,\n                                             const LocalInfo::LocalInfo& VAR_5,\n                                             Upstream::ClusterManager& VAR_6,\n                                             Server::OverloadManager& VAR_7,\n                                             TimeSource& VAR_8)\n    : config_(VAR_0), stats_(VAR_9.stats()),\n      conn_length_(new Stats::HistogramCompletableTimespanImpl(\n          VAR_10.named_.downstream_cx_length_ms_, VAR_8)),\n      drain_close_(VAR_1), user_agent_(VAR_3.userAgentContext()),\n      random_generator_(VAR_2), runtime_(VAR_4), local_info_(VAR_5),\n      cluster_manager_(VAR_6), listener_stats_(VAR_9.listenerStats()),\n      overload_manager_(VAR_7),\n      overload_state_(VAR_7.getThreadLocalOverloadState()),\n      accept_new_http_stream_(VAR_7.getLoadShedPoint(\n          \"envoy.load_shed_points.http_connection_manager_decode_headers\")),\n      overload_stop_accepting_requests_ref_(\n          VAR_11.getState(Server::OverloadActionNames::get().StopAcceptingRequests)),\n      overload_disable_keepalive_ref_(\n          VAR_11.getState(Server::OverloadActionNames::get().DisableHttpKeepAlive)),\n      time_source_(VAR_8), proxy_name_(StreamInfo::ProxyStatusUtils::makeProxyName(\n                                     /* COMMENT_0 */VAR_12.node().id(),\n                                     /* COMMENT_1 */VAR_9.serverName(),\n                                     /* COMMENT_2 */VAR_9.proxyStatusConfig())),\n      max_requests_during_dispatch_(\n          VAR_13.snapshot().getInteger(ConnectionManagerImpl::MaxRequestsPerIoCycle, VAR_14)),\n      refresh_rtt_after_request_(\n          Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.refresh_rtt_after_request\")) {\n  ENVOY_LOG_ONCE_IF(\n      VAR_15, VAR_16 == nullptr,\n      \"LoadShedPoint envoy.load_shed_points.http_connection_manager_decode_headers is not \"\n      \"found. Is it configured?\");\n}",
  "func_graph_path": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,8 @@\n                                      /*node_id=*/local_info_.node().id(),\n                                      /*server_name=*/config_.serverName(),\n                                      /*proxy_status_config=*/config_.proxyStatusConfig())),\n+      max_requests_during_dispatch_(\n+          runtime_.snapshot().getInteger(ConnectionManagerImpl::MaxRequestsPerIoCycle, UINT32_MAX)),\n       refresh_rtt_after_request_(\n           Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.refresh_rtt_after_request\")) {\n   ENVOY_LOG_ONCE_IF(",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      max_requests_during_dispatch_(",
      "          runtime_.snapshot().getInteger(ConnectionManagerImpl::MaxRequestsPerIoCycle, UINT32_MAX)),"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/30055",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/envoyproxy/envoy/pull/30055: 403 Client Error: Forbidden for url: https://api.github.com/repos/envoyproxy/envoy/pulls/30055",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.6"
}