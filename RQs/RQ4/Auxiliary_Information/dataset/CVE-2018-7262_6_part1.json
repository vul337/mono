{
  "cve_id": "CVE-2018-7262",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "ceph",
  "commit_msg": "rgw:  make init env methods return an error\n\nSince web frontends may signal an error when requests are malformed or so, let\nus double check this and raise errors early. The current user of this is\ncivetweb frontend; which can potentially return null from `parse_http_headers`\nwhen a HTTP header without a \":\" is supplied at which point headers.value is\nnull which can lead to undefined behaviour later in RGW.\n\nFixes: http://tracker.ceph.com/issues/23039\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>",
  "commit_hash": "7872a831783e17dcc4d0aa70cffc256afb664f7a",
  "git_url": "https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a",
  "file_path": "src/rgw/rgw_asio_client.cc",
  "func_name": "ClientIO::init_env",
  "func_before": "void ClientIO::init_env(CephContext *cct)\n{\n  env.init(cct);\n\n  const auto& request = parser.get();\n  const auto& headers = request;\n  for (auto header = headers.begin(); header != headers.end(); ++header) {\n    const auto& field = header->name(); // enum type for known headers\n    const auto& name = header->name_string();\n    const auto& value = header->value();\n\n    if (field == beast::http::field::content_length) {\n      env.set(\"CONTENT_LENGTH\", value.to_string());\n      continue;\n    }\n    if (field == beast::http::field::content_type) {\n      env.set(\"CONTENT_TYPE\", value.to_string());\n      continue;\n    }\n\n    static const boost::string_ref HTTP_{\"HTTP_\"};\n\n    char buf[name.size() + HTTP_.size() + 1];\n    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);\n    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {\n      if (*src == '-') {\n        *dest = '_';\n      } else {\n        *dest = std::toupper(*src);\n      }\n    }\n    *dest = '\\0';\n\n    env.set(buf, value.to_string());\n  }\n\n  int major = request.version() / 10;\n  int minor = request.version() % 10;\n  env.set(\"HTTP_VERSION\", std::to_string(major) + '.' + std::to_string(minor));\n\n  env.set(\"REQUEST_METHOD\", request.method_string().to_string());\n\n  // split uri from query\n  auto url = request.target();\n  auto pos = url.find('?');\n  if (pos != url.npos) {\n    auto query = url.substr(pos + 1);\n    env.set(\"QUERY_STRING\", query.to_string());\n    url = url.substr(0, pos);\n  }\n  env.set(\"REQUEST_URI\", url.to_string());\n  env.set(\"SCRIPT_URI\", url.to_string()); /* FIXME */\n\n  char port_buf[16];\n  snprintf(port_buf, sizeof(port_buf), \"%d\", socket.local_endpoint().port());\n  env.set(\"SERVER_PORT\", port_buf);\n  env.set(\"REMOTE_ADDR\", socket.remote_endpoint().address().to_string());\n  // TODO: set SERVER_PORT_SECURE if using ssl\n  // TODO: set REMOTE_USER if authenticated\n}",
  "abstract_func_before": "void ClientIO::init_env(CephContext *VAR_0)\n{\n  VAR_1.init(VAR_0);\n\n  const auto& VAR_2 = VAR_3.get();\n  const auto& VAR_4 = VAR_2;\n  for (auto VAR_5 = VAR_4.begin(); VAR_5 != VAR_4.end(); ++VAR_5) {\n    const auto& VAR_6 = VAR_5->name(); /* COMMENT_0 */\n    const auto& VAR_7 = VAR_5->name_string();\n    const auto& VAR_8 = VAR_5->value();\n\n    if (VAR_6 == beast::http::field::content_length) {\n      VAR_1.set(\"CONTENT_LENGTH\", VAR_8.to_string());\n      continue;\n    }\n    if (VAR_6 == beast::http::field::content_type) {\n      VAR_1.set(\"CONTENT_TYPE\", VAR_8.to_string());\n      continue;\n    }\n\n    static const boost::string_ref VAR_9{\"HTTP_\"};\n\n    char VAR_10[VAR_7.size() + VAR_9.size() + 1];\n    auto VAR_11 = std::copy(std::begin(VAR_9), std::end(VAR_9), VAR_10);\n    for (auto VAR_12 = VAR_7.begin(); VAR_12 != VAR_7.end(); ++VAR_12, ++VAR_11) {\n      if (*VAR_12 == '-') {\n        *VAR_11 = '_';\n      } else {\n        *VAR_11 = std::toupper(*VAR_12);\n      }\n    }\n    *VAR_11 = '\\0';\n\n    VAR_1.set(VAR_10, VAR_8.to_string());\n  }\n\n  int VAR_13 = VAR_2.version() / 10;\n  int VAR_14 = VAR_2.version() % 10;\n  VAR_1.set(\"HTTP_VERSION\", std::to_string(VAR_13) + '.' + std::to_string(VAR_14));\n\n  VAR_1.set(\"REQUEST_METHOD\", VAR_2.method_string().to_string());\n\n  /* COMMENT_1 */\n  auto VAR_15 = VAR_2.target();\n  auto VAR_16 = VAR_15.find('?');\n  if (VAR_16 != VAR_15.npos) {\n    auto VAR_17 = VAR_15.substr(VAR_16 + 1);\n    VAR_1.set(\"QUERY_STRING\", VAR_17.to_string());\n    VAR_15 = VAR_15.substr(0, VAR_16);\n  }\n  VAR_1.set(\"REQUEST_URI\", VAR_15.to_string());\n  VAR_1.set(\"SCRIPT_URI\", VAR_15.to_string()); /* COMMENT_2 */\n\n  char VAR_18[16];\n  snprintf(VAR_18, sizeof(VAR_18), \"%d\", VAR_19.local_endpoint().port());\n  VAR_1.set(\"SERVER_PORT\", VAR_18);\n  VAR_1.set(\"REMOTE_ADDR\", VAR_19.remote_endpoint().address().to_string());\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n}",
  "func_graph_path_before": "ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_asio_client.cc/vul/before/0.json",
  "func": "int ClientIO::init_env(CephContext *cct)\n{\n  env.init(cct);\n\n  const auto& request = parser.get();\n  const auto& headers = request;\n  for (auto header = headers.begin(); header != headers.end(); ++header) {\n    const auto& field = header->name(); // enum type for known headers\n    const auto& name = header->name_string();\n    const auto& value = header->value();\n\n    if (field == beast::http::field::content_length) {\n      env.set(\"CONTENT_LENGTH\", value.to_string());\n      continue;\n    }\n    if (field == beast::http::field::content_type) {\n      env.set(\"CONTENT_TYPE\", value.to_string());\n      continue;\n    }\n\n    static const boost::string_ref HTTP_{\"HTTP_\"};\n\n    char buf[name.size() + HTTP_.size() + 1];\n    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);\n    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {\n      if (*src == '-') {\n        *dest = '_';\n      } else {\n        *dest = std::toupper(*src);\n      }\n    }\n    *dest = '\\0';\n\n    env.set(buf, value.to_string());\n  }\n\n  int major = request.version() / 10;\n  int minor = request.version() % 10;\n  env.set(\"HTTP_VERSION\", std::to_string(major) + '.' + std::to_string(minor));\n\n  env.set(\"REQUEST_METHOD\", request.method_string().to_string());\n\n  // split uri from query\n  auto url = request.target();\n  auto pos = url.find('?');\n  if (pos != url.npos) {\n    auto query = url.substr(pos + 1);\n    env.set(\"QUERY_STRING\", query.to_string());\n    url = url.substr(0, pos);\n  }\n  env.set(\"REQUEST_URI\", url.to_string());\n  env.set(\"SCRIPT_URI\", url.to_string()); /* FIXME */\n\n  char port_buf[16];\n  snprintf(port_buf, sizeof(port_buf), \"%d\", socket.local_endpoint().port());\n  env.set(\"SERVER_PORT\", port_buf);\n  env.set(\"REMOTE_ADDR\", socket.remote_endpoint().address().to_string());\n  // TODO: set SERVER_PORT_SECURE if using ssl\n  // TODO: set REMOTE_USER if authenticated\n  return 0;\n}",
  "abstract_func": "int ClientIO::init_env(CephContext *VAR_0)\n{\n  VAR_1.init(VAR_0);\n\n  const auto& VAR_2 = VAR_3.get();\n  const auto& VAR_4 = VAR_2;\n  for (auto VAR_5 = VAR_4.begin(); VAR_5 != VAR_4.end(); ++VAR_5) {\n    const auto& VAR_6 = VAR_5->name(); /* COMMENT_0 */\n    const auto& VAR_7 = VAR_5->name_string();\n    const auto& VAR_8 = VAR_5->value();\n\n    if (VAR_6 == beast::http::field::content_length) {\n      VAR_1.set(\"CONTENT_LENGTH\", VAR_8.to_string());\n      continue;\n    }\n    if (VAR_6 == beast::http::field::content_type) {\n      VAR_1.set(\"CONTENT_TYPE\", VAR_8.to_string());\n      continue;\n    }\n\n    static const boost::string_ref VAR_9{\"HTTP_\"};\n\n    char VAR_10[VAR_7.size() + VAR_9.size() + 1];\n    auto VAR_11 = std::copy(std::begin(VAR_9), std::end(VAR_9), VAR_10);\n    for (auto VAR_12 = VAR_7.begin(); VAR_12 != VAR_7.end(); ++VAR_12, ++VAR_11) {\n      if (*VAR_12 == '-') {\n        *VAR_11 = '_';\n      } else {\n        *VAR_11 = std::toupper(*VAR_12);\n      }\n    }\n    *VAR_11 = '\\0';\n\n    VAR_1.set(VAR_10, VAR_8.to_string());\n  }\n\n  int VAR_13 = VAR_2.version() / 10;\n  int VAR_14 = VAR_2.version() % 10;\n  VAR_1.set(\"HTTP_VERSION\", std::to_string(VAR_13) + '.' + std::to_string(VAR_14));\n\n  VAR_1.set(\"REQUEST_METHOD\", VAR_2.method_string().to_string());\n\n  /* COMMENT_1 */\n  auto VAR_15 = VAR_2.target();\n  auto VAR_16 = VAR_15.find('?');\n  if (VAR_16 != VAR_15.npos) {\n    auto VAR_17 = VAR_15.substr(VAR_16 + 1);\n    VAR_1.set(\"QUERY_STRING\", VAR_17.to_string());\n    VAR_15 = VAR_15.substr(0, VAR_16);\n  }\n  VAR_1.set(\"REQUEST_URI\", VAR_15.to_string());\n  VAR_1.set(\"SCRIPT_URI\", VAR_15.to_string()); /* COMMENT_2 */\n\n  char VAR_18[16];\n  snprintf(VAR_18, sizeof(VAR_18), \"%d\", VAR_19.local_endpoint().port());\n  VAR_1.set(\"SERVER_PORT\", VAR_18);\n  VAR_1.set(\"REMOTE_ADDR\", VAR_19.remote_endpoint().address().to_string());\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  return 0;\n}",
  "func_graph_path": "ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_asio_client.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-void ClientIO::init_env(CephContext *cct)\n+int ClientIO::init_env(CephContext *cct)\n {\n   env.init(cct);\n \n@@ -57,4 +57,5 @@\n   env.set(\"REMOTE_ADDR\", socket.remote_endpoint().address().to_string());\n   // TODO: set SERVER_PORT_SECURE if using ssl\n   // TODO: set REMOTE_USER if authenticated\n+  return 0;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "void ClientIO::init_env(CephContext *cct)"
    ],
    "added_lines": [
      "int ClientIO::init_env(CephContext *cct)",
      "  return 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ceph/ceph/pull/20488",
  "description": {
    "pr_info": {
      "title": "rgw:  make init env methods return an error",
      "number": 20488
    },
    "comment": [
      "Since web frontends may signal an error when requests are malformed or so, let\r\nus double check this and raise errors early. The current user of this is\r\ncivetweb frontend; which can potentially return null from `parse_http_headers`\r\nwhen a HTTP header without a \":\" is supplied at which point headers.value is\r\nnull which can lead to undefined behaviour later in RGW.\r\n\r\nFixes: http://tracker.ceph.com/issues/23039\r\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>",
      "changelog: \r\n- drop init_error variable in rgw_civetweb\r\n- raise -EINVAL if mg_request info isn't populated in rgw_civetweb.cc\r\n   this is a changed behaviour  from earlier where we return and fail at a much later stage in rgw process \r\n",
      "@yehudasa @cbodley do these changes look okay?",
      "was unable to reproduce the failures in manual testing :+1: "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}