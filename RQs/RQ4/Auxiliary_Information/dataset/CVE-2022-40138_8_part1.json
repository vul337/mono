{
  "cve_id": "CVE-2022-40138",
  "cwe_ids": [
    "CWE-681"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#822)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "6aa825e480d48127b480b08d13adf70033237097",
  "git_url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
  "file_path": "lib/CompilerDriver/CompilerDriver.cpp",
  "func_name": "generateBytecodeForSerialization",
  "func_before": "CompileResult generateBytecodeForSerialization(\n    raw_ostream &OS,\n    Module &M,\n    const BytecodeGenerationOptions &genOptions,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGenOrNull,\n    BaseBytecodeMap &baseBytecodeMap) {\n  // Serialize the bytecode to the file.\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    std::unique_ptr<hbc::BCProviderFromBuffer> baseBCProvider = nullptr;\n    auto itr = baseBytecodeMap.find(segment ? *segment : 0);\n    if (itr != baseBytecodeMap.end()) {\n      baseBCProvider = std::move(itr->second);\n      // We want to erase it from the map because unique_ptr can only\n      // have one owner.\n      baseBytecodeMap.erase(itr);\n    }\n    auto bytecodeModule = hbc::generateBytecode(\n        &M,\n        OS,\n        genOptions,\n        sourceHash,\n        segment,\n        sourceMapGenOrNull,\n        std::move(baseBCProvider));\n\n    if (cl::DumpTarget == DumpBytecode) {\n      disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n          std::move(bytecodeModule)));\n    }\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind\");\n  }\n  return Success;\n}",
  "abstract_func_before": "CompileResult generateBytecodeForSerialization(\n    raw_ostream &VAR_0,\n    Module &VAR_1,\n    const BytecodeGenerationOptions &VAR_2,\n    const SHA1 &VAR_3,\n    hermes::OptValue<uint32_t> VAR_4,\n    SourceMapGenerator *VAR_5,\n    BaseBytecodeMap &VAR_6) {\n  /* COMMENT_0 */\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    std::unique_ptr<hbc::BCProviderFromBuffer> VAR_7 = nullptr;\n    auto VAR_8 = VAR_6.find(VAR_4 ? *VAR_4 : 0);\n    if (VAR_8 != VAR_6.end()) {\n      VAR_7 = std::move(VAR_8->second);\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_6.erase(VAR_8);\n    }\n    auto VAR_9 = hbc::generateBytecode(\n        &VAR_1,\n        VAR_0,\n        VAR_2,\n        VAR_3,\n        VAR_4,\n        VAR_5,\n        std::move(VAR_7));\n\n    if (cl::DumpTarget == VAR_10) {\n      disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n          std::move(VAR_9)));\n    }\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind\");\n  }\n  return VAR_11;\n}",
  "func_graph_path_before": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/CompilerDriver.cpp/vul/before/0.json",
  "func": "CompileResult generateBytecodeForSerialization(\n    raw_ostream &OS,\n    Module &M,\n    const BytecodeGenerationOptions &genOptions,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGenOrNull,\n    BaseBytecodeMap &baseBytecodeMap) {\n  // Serialize the bytecode to the file.\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    std::unique_ptr<hbc::BCProviderFromBuffer> baseBCProvider = nullptr;\n    auto itr = baseBytecodeMap.find(segment ? *segment : 0);\n    if (itr != baseBytecodeMap.end()) {\n      baseBCProvider = std::move(itr->second);\n      // We want to erase it from the map because unique_ptr can only\n      // have one owner.\n      baseBytecodeMap.erase(itr);\n    }\n    auto bytecodeModule = hbc::generateBytecode(\n        &M,\n        OS,\n        genOptions,\n        sourceHash,\n        segment,\n        sourceMapGenOrNull,\n        std::move(baseBCProvider));\n\n    if (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {\n      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n      return BackendError;\n    }\n\n    if (cl::DumpTarget == DumpBytecode) {\n      disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n          std::move(bytecodeModule)));\n    }\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind\");\n  }\n  return Success;\n}",
  "abstract_func": "CompileResult generateBytecodeForSerialization(\n    raw_ostream &VAR_0,\n    Module &VAR_1,\n    const BytecodeGenerationOptions &VAR_2,\n    const SHA1 &VAR_3,\n    hermes::OptValue<uint32_t> VAR_4,\n    SourceMapGenerator *VAR_5,\n    BaseBytecodeMap &VAR_6) {\n  /* COMMENT_0 */\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    std::unique_ptr<hbc::BCProviderFromBuffer> VAR_7 = nullptr;\n    auto VAR_8 = VAR_6.find(VAR_4 ? *VAR_4 : 0);\n    if (VAR_8 != VAR_6.end()) {\n      VAR_7 = std::move(VAR_8->second);\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_6.erase(VAR_8);\n    }\n    auto VAR_9 = hbc::generateBytecode(\n        &VAR_1,\n        VAR_0,\n        VAR_2,\n        VAR_3,\n        VAR_4,\n        VAR_5,\n        std::move(VAR_7));\n\n    if (auto VAR_10 = VAR_1.getContext().getSourceErrorManager().getErrorCount()) {\n      llvh::errs() << \"Emitted \" << VAR_10 << \" errors in the backend. exiting.\\n\";\n      return VAR_11;\n    }\n\n    if (cl::DumpTarget == VAR_12) {\n      disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n          std::move(VAR_9)));\n    }\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind\");\n  }\n  return VAR_13;\n}",
  "func_graph_path": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/CompilerDriver.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,11 @@\n         sourceMapGenOrNull,\n         std::move(baseBCProvider));\n \n+    if (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {\n+      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n+      return BackendError;\n+    }\n+\n     if (cl::DumpTarget == DumpBytecode) {\n       disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n           std::move(bytecodeModule)));",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {",
      "      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";",
      "      return BackendError;",
      "    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/822",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/hermes/pull/822: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/hermes/pulls/822",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.7"
}