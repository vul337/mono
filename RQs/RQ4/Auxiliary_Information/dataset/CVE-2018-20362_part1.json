{
  "cve_id": "CVE-2018-20362",
  "cwe_ids": [
    "CWE-787",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "syntax.c: check for syntax element inconsistencies\n\nImplicit channel mapping reconfiguration is explicitely forbidden by\nISO/IEC 13818-7:2006 (8.5.3.3). Decoders should be able to detect such\nfiles and reject them. FAAD2 does not perform any kind of checks\nregarding this.\n\nThis leads to security vulnerabilities when processing crafted AAC\nfiles performing such reconfigurations.\n\nAdd checks to decode_sce_lfe and decode_cpe to make sure such\ninconsistencies are detected as early as possible.\n\nThese checks first read hDecoder->frame: if this is not the first\nframe then we make sure that the syntax element at the same position\nin the previous frame also had element_id id_syn_ele. If not, return\n21 as this is a fatal file structure issue.\n\nThis patch addresses CVE-2018-20362 (fixes #26) and possibly other\nrelated issues.",
  "commit_hash": "466b01d504d7e45f1e9169ac90b3e34ab94aed14",
  "git_url": "https://github.com/knik0/faad2/commit/466b01d504d7e45f1e9169ac90b3e34ab94aed14",
  "file_path": "libfaad/syntax.c",
  "func_name": "decode_sce_lfe",
  "func_before": "static void decode_sce_lfe(NeAACDecStruct *hDecoder,\n                           NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+1 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for SCE hDecoder->element_output_channels[] is not set here because this\n       can become 2 when some form of Parametric Stereo coding is used\n    */\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag);\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        if (hDecoder->pce_set)\n            hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels;\n        else\n            hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n}",
  "abstract_func_before": "static void decode_sce_lfe(NeAACDecStruct *VAR_0,\n                           NeAACDecFrameInfo *VAR_1, bitfile *VAR_2,\n                           uint8_t VAR_3)\n{\n    uint8_t VAR_4 = VAR_0->fr_channels;\n    uint8_t VAR_5 = 0;\n\n    if (VAR_4+1 > VAR_6)\n    {\n        VAR_1->error = 12;\n        return;\n    }\n    if (VAR_0->fr_ch_ele+1 > VAR_7)\n    {\n        VAR_1->error = 13;\n        return;\n    }\n\n    /* COMMENT_0 */\n                                                                      \n      \n\n    /* COMMENT_3 */\n    VAR_0->element_id[VAR_0->fr_ch_ele] = VAR_3;\n\n    /* COMMENT_4 */\n    VAR_1->error = single_lfe_channel_element(VAR_0, VAR_2, VAR_4, &VAR_5);\n\n    /* COMMENT_5 */\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2)\n    {\n        /* COMMENT_6 */\n        VAR_0->internal_channel[VAR_4] = VAR_4;\n        VAR_0->internal_channel[VAR_4+1] = VAR_4+1;\n    } else {\n        if (VAR_0->pce_set)\n            VAR_0->internal_channel[VAR_0->pce.sce_channel[VAR_5]] = VAR_4;\n        else\n            VAR_0->internal_channel[VAR_4] = VAR_4;\n    }\n\n    VAR_0->fr_channels += VAR_0->element_output_channels[VAR_0->fr_ch_ele];\n    VAR_0->fr_ch_ele++;\n}",
  "func_graph_path_before": "knik0/faad2/466b01d504d7e45f1e9169ac90b3e34ab94aed14/syntax.c/vul/before/0.json",
  "func": "static void decode_sce_lfe(NeAACDecStruct *hDecoder,\n                           NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+1 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for SCE hDecoder->element_output_channels[] is not set here because this\n       can become 2 when some form of Parametric Stereo coding is used\n    */\n\n    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag);\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        if (hDecoder->pce_set)\n            hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels;\n        else\n            hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n}",
  "abstract_func": "static void decode_sce_lfe(NeAACDecStruct *VAR_0,\n                           NeAACDecFrameInfo *VAR_1, bitfile *VAR_2,\n                           uint8_t VAR_3)\n{\n    uint8_t VAR_4 = VAR_0->fr_channels;\n    uint8_t VAR_5 = 0;\n\n    if (VAR_4+1 > VAR_6)\n    {\n        VAR_1->error = 12;\n        return;\n    }\n    if (VAR_0->fr_ch_ele+1 > VAR_7)\n    {\n        VAR_1->error = 13;\n        return;\n    }\n\n    /* COMMENT_0 */\n                                                                      \n      \n\n    if (VAR_0->frame && VAR_0->element_id[VAR_0->fr_ch_ele] != VAR_3) {\n        /* COMMENT_3 */\n        VAR_1->error = 21;\n        return;\n    }\n\n    /* COMMENT_4 */\n    VAR_0->element_id[VAR_0->fr_ch_ele] = VAR_3;\n\n    /* COMMENT_5 */\n    VAR_1->error = single_lfe_channel_element(VAR_0, VAR_2, VAR_4, &VAR_5);\n\n    /* COMMENT_6 */\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2)\n    {\n        /* COMMENT_7 */\n        VAR_0->internal_channel[VAR_4] = VAR_4;\n        VAR_0->internal_channel[VAR_4+1] = VAR_4+1;\n    } else {\n        if (VAR_0->pce_set)\n            VAR_0->internal_channel[VAR_0->pce.sce_channel[VAR_5]] = VAR_4;\n        else\n            VAR_0->internal_channel[VAR_4] = VAR_4;\n    }\n\n    VAR_0->fr_channels += VAR_0->element_output_channels[VAR_0->fr_ch_ele];\n    VAR_0->fr_ch_ele++;\n}",
  "func_graph_path": "knik0/faad2/466b01d504d7e45f1e9169ac90b3e34ab94aed14/syntax.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,12 @@\n     /* for SCE hDecoder->element_output_channels[] is not set here because this\n        can become 2 when some form of Parametric Stereo coding is used\n     */\n+\n+    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n+        /* element inconsistency */\n+        hInfo->error = 21;\n+        return;\n+    }\n \n     /* save the syntax element id */\n     hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {",
      "        /* element inconsistency */",
      "        hInfo->error = 21;",
      "        return;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/33",
  "description": {
    "pr_info": {
      "title": "CVE-2018-20194 / CVE-2018-20362 fixes",
      "number": 33
    },
    "comment": [
      "**Issue summary:**\r\n\r\nThe faad2 code base appears to assume that all frames of a same AAC file share the same syntax element structure. However, input files are not strictly verified again this assumption, or too late during file processing.\r\n\r\nThis leads to security vulnerabilities when processing crafted AAC files where these assumptions are false. For example, files declaring two frames, the first SCE+FIL and the second CPE.\r\n\r\n**Patch summary:**\r\n\r\nAdd checks to decode_sce_lfe and decode_cpe to make sure inter-frame inconsistencies are detected as early as possible.\r\n\r\nThese checks first read hDecoder->frame: if this is not the first frame then we make sure that the syntax element at the same position in the previous frame also had element_id id_syn_ele. If not, return 21 as this is a fatal file structure issue.\r\n\r\n**Issues addressed:**\r\n\r\nThis patch addresses CVE-2018-20362 (fixes #26) and possibly other related issues.",
      "This patch should fix #27 and #23 as well (same underlying issue everywhere).",
      "Thank you very much for the patch and sorry for the stupid question, but I may be he last remaining person with commit rights to this repository and my knowledge of the innards of the code is quite limited. So, is it really impossible in the AAC format that two consecutive frames have different types?",
      "Hi @fabiangreffrath, sorry for the late answer.\r\n\r\nI am not an AAC expert. I did not find any kind of official AAC file format specification which could precisely answer this question.\r\n\r\nMy guess is: it is not forbidden to define an AAC file containing frames of different formats. AFAIK, frames are independent units of data.\r\n\r\nWhether defining AAC files with frames of different formats makes sense or not is another question. Whether FAAD2 should support this is yet another question.\r\n\r\nFor the moment it is obvious that FAAD2 does not support it, because buffers are shared between frames. FAAD2 crashes if a complex frame requiring more buffers follows a simple frame. Supporting it would probably require more changes than what this patch suggests.\r\n\r\nIf my analysis is right, I suggest to officially declare this unsupported, make sure FAAD2 exits cleanly in these cases, and add this to the todo/roadmap. This is a refactoring, it should be done properly with tests, etc. not a security patch.\r\n\r\nbut then again, my knowledge of AAC is limited, and poorly documented.",
      "I have found [a copy](http://read.pudn.com/downloads69/ebook/247256/247256/13818-7_2006.pdf) of the ISO/IEC 13818-7:2006 spec. This should answer our questions.\r\n\r\nThere are three ways of specifying channel mapping: in the adts header, using PCE elements, or implicitly (8.5.3.3).\r\n\r\nIn the implicit case: _\"the  resulting configuration may not change within the bitstream without sending a program_config_element(), i.e. an implicit reconfiguration is not allowed\"_\r\n\r\nSo it looks like this patch goes the right way.\r\n\r\nI don't know whether FAAD2 handles reconfiguration via PCE elements properly.",
      "I have pushed another patch addressing CVE-2018-20194. I am quite confident in this patch, please tell me if the explanations I provided are clear enough to you.\r\n\r\nI have also updated the commit message of CVE-2018-20362 to use more precise terms and provide explanations based on the specification.",
      "@hlef May this patch from VLC be related? Just guessing from the patch description. \r\n\r\nhttps://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-cpe-reconstruction.patch",
      "> @hlef May this patch from VLC be related? Just guessing from the patch description.\r\n> \r\n> https://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-cpe-reconstruction.patch\r\n\r\nYes it is.\r\n\r\nWhat this patch does is one of the first things I tried when investigating this issue (see #26).\r\n\r\nAs far as I remember, this was not sufficient to prevent FAAD2 from crashing with the reproducer.\r\n\r\nFrom my point of view:\r\n* this situation (implicit reconfiguration) is not legal according to the specification (*as far as I understand the spec*, I am not an AAC expert)\r\n* if we don't exit at this point, FAAD2 will thus continue processing inconsistent data\r\n* this *might* trigger a variety of issues at other places in the source code\r\n* the result is likely to be garbage anyways\r\n\r\nGiven my limited knowledge of the codebase and of the AAC standard, the safest option seemed to abort at this point. This patch might work, or it might just as well replace one issue with another.",
      "So, your current stance is to better not apply that patch?",
      "> So, your current stance is to better not apply that patch?\r\n\r\nApplying both the VLC patch and my patch is probably a good idea.\r\n\r\nI'm skeptical about applying the VLC patch only, because I don't think we should continue to process the input at this point (unless my interpretation of the spec is wrong and this is a valid situtation).",
      "Since your patch is already applied for quite some time, I'll add the VLC one asap. If I got you right, it won't hurt. \r\n\r\nThanks for your input! ",
      "I consider applying this patch as well, we already have it in the Debian package:\r\n\r\nhttps://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-overflows.patch"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}