{
  "cve_id": "CVE-2020-36619",
  "cwe_ids": [
    "CWE-134"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "EliasOenal/multimon-ng",
  "commit_msg": "Remove uncontrolled format string vulnerability",
  "commit_hash": "e5a51c508ef952e81a6da25b43034dd1ed023c07",
  "git_url": "https://github.com/EliasOenal/multimon-ng/commit/e5a51c508ef952e81a6da25b43034dd1ed023c07",
  "file_path": "demod_flex.c",
  "func_name": "add_ch",
  "func_before": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    // avoid buffer overflow that has been happening\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    // TODO sanitize % or you will have uncontrolled format string vuln\n    // Originally, this only avoided storing ETX (end of text, 0x03).\n    // At minimum you'll also want to avoid storing NULL (str term, 0x00),\n    // otherwise verbprintf will truncate the message.\n    //   ex: if (ch != 0x03 && ch != 0x00) { buf[idx] = ch; return 1; }\n    // But while we are here, make it print friendly and get it onto a single line\n    //   * remove awkward ctrl chars (del, bs, bell, vertical tab, etc)\n    //   * encode valuable ctrl chars (new line/line feed, carriage ret, tab)\n    // NOTE: if you post process FLEX ALN output by sed/grep/awk etc on non-printables\n    //   then double check this doesn't mess with your pipeline\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  // '\\t'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  // '\\n'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  // '\\r'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    // only store ASCII printable\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    // if you want all non-printables, show as hex, but also make MAX_ALN 1024\n    /* if (idx < (MAX_ALN - 4)) {\n        sprintf(buf + idx, \"\\\\x%02x\", ch);\n        return 4;\n    }*/\n    return 0;\n}",
  "abstract_func_before": "unsigned int add_ch(unsigned char VAR_0, unsigned char* VAR_1, unsigned int VAR_2) {\n    /* COMMENT_0 */\n    if (VAR_2 >= VAR_3) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", VAR_2, VAR_3);\n        return 0;\n    }\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if (VAR_0 == 0x09 && VAR_2 < (VAR_3 - 2)) {  /* COMMENT_11 */\n        VAR_1[VAR_2] = '\\\\';\n        VAR_1[VAR_2 + 1] = 't';\n        return 2;\n    }\n    if (VAR_0 == 0x0a && VAR_2 < (VAR_3 - 2)) {  /* COMMENT_12 */\n        VAR_1[VAR_2] = '\\\\';\n        VAR_1[VAR_2 + 1] = 'n';\n        return 2;\n    }\n    if (VAR_0 == 0x0d && VAR_2 < (VAR_3 - 2)) {  /* COMMENT_13 */\n        VAR_1[VAR_2] = '\\\\';\n        VAR_1[VAR_2 + 1] = 'r';\n        return 2;\n    }\n    /* COMMENT_14 */\n    if (VAR_0 >= 32 && VAR_0 <= 126) {\n        VAR_1[VAR_2] = VAR_0;\n        return 1;\n    }\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n                                          \n                 \n       \n    return 0;\n}",
  "func_graph_path_before": "EliasOenal/multimon-ng/e5a51c508ef952e81a6da25b43034dd1ed023c07/demod_flex.c/vul/before/0.json",
  "func": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    // avoid buffer overflow that has been happening\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    // TODO sanitize % or you will have uncontrolled format string vuln\n    // Originally, this only avoided storing ETX (end of text, 0x03).\n    // At minimum you'll also want to avoid storing NULL (str term, 0x00),\n    // otherwise verbprintf will truncate the message.\n    //   ex: if (ch != 0x03 && ch != 0x00) { buf[idx] = ch; return 1; }\n    // But while we are here, make it print friendly and get it onto a single line\n    //   * remove awkward ctrl chars (del, bs, bell, vertical tab, etc)\n    //   * encode valuable ctrl chars (new line/line feed, carriage ret, tab)\n    // NOTE: if you post process FLEX ALN output by sed/grep/awk etc on non-printables\n    //   then double check this doesn't mess with your pipeline\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  // '\\t'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  // '\\n'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  // '\\r'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    // unixinput.c::_verbprintf uses this output as a format string\n    // which introduces an uncontrolled format string vulnerability\n    // and also, generally, risks stack corruption\n    if (ch == '%') {\n        if (idx < (MAX_ALN - 2)) {\n            buf[idx] = '%';\n            buf[idx + 1] = '%';\n            return 2;\n        }\n        return 0;\n    }\n    // only store ASCII printable\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    // if you want all non-printables, show as hex, but also make MAX_ALN 1024\n    /* if (idx < (MAX_ALN - 4)) {\n        sprintf(buf + idx, \"\\\\x%02x\", ch);\n        return 4;\n    }*/\n    return 0;\n}",
  "abstract_func": "unsigned int add_ch(unsigned char VAR_0, unsigned char* VAR_1, unsigned int VAR_2) {\n    /* COMMENT_0 */\n    if (VAR_2 >= VAR_3) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", VAR_2, VAR_3);\n        return 0;\n    }\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if (VAR_0 == 0x09 && VAR_2 < (VAR_3 - 2)) {  /* COMMENT_11 */\n        VAR_1[VAR_2] = '\\\\';\n        VAR_1[VAR_2 + 1] = 't';\n        return 2;\n    }\n    if (VAR_0 == 0x0a && VAR_2 < (VAR_3 - 2)) {  /* COMMENT_12 */\n        VAR_1[VAR_2] = '\\\\';\n        VAR_1[VAR_2 + 1] = 'n';\n        return 2;\n    }\n    if (VAR_0 == 0x0d && VAR_2 < (VAR_3 - 2)) {  /* COMMENT_13 */\n        VAR_1[VAR_2] = '\\\\';\n        VAR_1[VAR_2 + 1] = 'r';\n        return 2;\n    }\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    if (VAR_0 == '%') {\n        if (VAR_2 < (VAR_3 - 2)) {\n            VAR_1[VAR_2] = '%';\n            VAR_1[VAR_2 + 1] = '%';\n            return 2;\n        }\n        return 0;\n    }\n    /* COMMENT_17 */\n    if (VAR_0 >= 32 && VAR_0 <= 126) {\n        VAR_1[VAR_2] = VAR_0;\n        return 1;\n    }\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n                                          \n                 \n       \n    return 0;\n}",
  "func_graph_path": "EliasOenal/multimon-ng/e5a51c508ef952e81a6da25b43034dd1ed023c07/demod_flex.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,17 @@\n         buf[idx + 1] = 'r';\n         return 2;\n     }\n+    // unixinput.c::_verbprintf uses this output as a format string\n+    // which introduces an uncontrolled format string vulnerability\n+    // and also, generally, risks stack corruption\n+    if (ch == '%') {\n+        if (idx < (MAX_ALN - 2)) {\n+            buf[idx] = '%';\n+            buf[idx + 1] = '%';\n+            return 2;\n+        }\n+        return 0;\n+    }\n     // only store ASCII printable\n     if (ch >= 32 && ch <= 126) {\n         buf[idx] = ch;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    // unixinput.c::_verbprintf uses this output as a format string",
      "    // which introduces an uncontrolled format string vulnerability",
      "    // and also, generally, risks stack corruption",
      "    if (ch == '%') {",
      "        if (idx < (MAX_ALN - 2)) {",
      "            buf[idx] = '%';",
      "            buf[idx + 1] = '%';",
      "            return 2;",
      "        }",
      "        return 0;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EliasOenal/multimon-ng/pull/160",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/EliasOenal/multimon-ng/pull/160: 403 Client Error: Forbidden for url: https://api.github.com/repos/EliasOenal/multimon-ng/pulls/160",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}