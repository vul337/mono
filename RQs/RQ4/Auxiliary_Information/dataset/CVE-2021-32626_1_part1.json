{
  "cve_id": "CVE-2021-32626",
  "cwe_ids": [
    "CWE-787",
    "CWE-122"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n   to explode the LUA stack (notice that currently there is no such\n   command in Redis that returns such a nested reply, but modules might\n   do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n   explode the LUA stack (all the arguments will be pushed to the LUA\n   stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
  "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "git_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "file_path": "src/scripting.c",
  "func_name": "redisProtocolToLuaType",
  "func_before": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    char *p = reply;\n\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}",
  "abstract_func_before": "char *redisProtocolToLuaType(lua_State *VAR_0, char* VAR_1) {\n    char *VAR_2 = VAR_1;\n\n    switch(*VAR_2) {\n    case ':': VAR_2 = redisProtocolToLuaType_Int(VAR_0,VAR_1); break;\n    case '$': VAR_2 = redisProtocolToLuaType_Bulk(VAR_0,VAR_1); break;\n    case '+': VAR_2 = redisProtocolToLuaType_Status(VAR_0,VAR_1); break;\n    case '-': VAR_2 = redisProtocolToLuaType_Error(VAR_0,VAR_1); break;\n    case '*': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;\n    case '%': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;\n    case '~': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;\n    case '_': VAR_2 = redisProtocolToLuaType_Null(VAR_0,VAR_1); break;\n    case '#': VAR_2 = redisProtocolToLuaType_Bool(VAR_0,VAR_1,VAR_2[1]); break;\n    case ',': VAR_2 = redisProtocolToLuaType_Double(VAR_0,VAR_1); break;\n    }\n    return VAR_2;\n}",
  "func_graph_path_before": "redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/before/2.json",
  "func": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n\n    if (!lua_checkstack(lua, 5)) {\n        /*\n         * Increase the Lua stack if needed, to make sure there is enough room\n         * to push 5 elements to the stack. On failure, exit with panic.\n         * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate\n         * might push 5 elements to the Lua stack.*/\n        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n    }\n\n    char *p = reply;\n\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}",
  "abstract_func": "char *redisProtocolToLuaType(lua_State *VAR_0, char* VAR_1) {\n\n    if (!lua_checkstack(VAR_0, 5)) {\n        /* COMMENT_0 */\n                                                                              \n                                                                        \n                                                                                                      \n                                                    \n        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n    }\n\n    char *VAR_2 = VAR_1;\n\n    switch(*VAR_2) {\n    case ':': VAR_2 = redisProtocolToLuaType_Int(VAR_0,VAR_1); break;\n    case '$': VAR_2 = redisProtocolToLuaType_Bulk(VAR_0,VAR_1); break;\n    case '+': VAR_2 = redisProtocolToLuaType_Status(VAR_0,VAR_1); break;\n    case '-': VAR_2 = redisProtocolToLuaType_Error(VAR_0,VAR_1); break;\n    case '*': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;\n    case '%': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;\n    case '~': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;\n    case '_': VAR_2 = redisProtocolToLuaType_Null(VAR_0,VAR_1); break;\n    case '#': VAR_2 = redisProtocolToLuaType_Bool(VAR_0,VAR_1,VAR_2[1]); break;\n    case ',': VAR_2 = redisProtocolToLuaType_Double(VAR_0,VAR_1); break;\n    }\n    return VAR_2;\n}",
  "func_graph_path": "redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,14 @@\n char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n+\n+    if (!lua_checkstack(lua, 5)) {\n+        /*\n+         * Increase the Lua stack if needed, to make sure there is enough room\n+         * to push 5 elements to the stack. On failure, exit with panic.\n+         * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate\n+         * might push 5 elements to the Lua stack.*/\n+        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n+    }\n+\n     char *p = reply;\n \n     switch(*p) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if (!lua_checkstack(lua, 5)) {",
      "        /*",
      "         * Increase the Lua stack if needed, to make sure there is enough room",
      "         * to push 5 elements to the stack. On failure, exit with panic.",
      "         * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate",
      "         * might push 5 elements to the Lua stack.*/",
      "        serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
      "    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a security issue (CVE-2021-32626) by preventing Lua stack overflow, which could lead to memory corruption. The code changes include checks to ensure sufficient stack space, aligning with the commit and vulnerability descriptions.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}