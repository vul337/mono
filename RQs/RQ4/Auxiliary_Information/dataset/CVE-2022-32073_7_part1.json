{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvOpenDir",
  "func_before": "int wolfSSH_SFTP_RecvOpenDir(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WDIR  ctx;\n    word32 sz;\n    char*  dir;\n    word32 idx = 0;\n    int   ret = WS_SUCCESS;\n\n    word32 outSz = sizeof(word32)*2 + WOLFSSH_SFTP_HEADER + UINT32_SZ;\n    byte*  out = NULL;\n    word32 id[2];\n    byte idFlat[sizeof(word32) * 2];\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_OPENDIR\");\n\n    if (sizeof(WFD) > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Handle size is too large\");\n        return WS_FATAL_ERROR;\n    }\n\n    /* get directory name */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n\n    /* get directory handle */\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    if (WOPENDIR(ssh->fs, ssh->ctx->heap, &ctx, dir) != 0) {\n        WLOG(WS_LOG_SFTP, \"Error with opening directory\");\n        WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_NOFILE, reqId,\n                \"Unable To Open Directory\", \"English\", NULL, &outSz)\n                != WS_SIZE_ONLY) {\n                return WS_FATAL_ERROR;\n        }\n        ret = WS_BAD_FILE_E;\n    }\n\n    (void)reqId;\n\n    /* add to directory list @TODO locking for thread safety */\n    if (ret == WS_SUCCESS) {\n        DIR_HANDLE* cur = (DIR_HANDLE*)WMALLOC(sizeof(DIR_HANDLE),\n                ssh->ctx->heap, DYNTYPE_SFTP);\n        if (cur == NULL) {\n            WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n            WCLOSEDIR(&ctx);\n            return WS_MEMORY_E;\n        }\n#ifdef WOLFSSL_NUCLEUS\n        WMEMCPY(&cur->dir, &ctx, sizeof(WDIR));\n#else\n        cur->dir  = ctx;\n#endif\n        cur->id[0] = id[0] = idCount[0];\n        cur->id[1] = id[1] = idCount[1];\n        c32toa(id[0], idFlat);\n        c32toa(id[1], idFlat + UINT32_SZ);\n        AddAssign64(idCount, 1);\n        cur->isEof = 0;\n        cur->next  = dirList;\n        dirList    = cur;\n        dirList->dirName = dir; /* take over ownership of buffer */\n    }\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret == WS_SUCCESS) {\n        SFTP_CreatePacket(ssh, WOLFSSH_FTP_HANDLE, out, outSz,\n                idFlat, sizeof(idFlat));\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_NOFILE, reqId,\n                \"Unable To Open Directory\", \"English\", out, &outSz)\n                != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n\n    return ret;\n}",
  "abstract_func_before": "int wolfSSH_SFTP_RecvOpenDir(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WDIR  VAR_5;\n    word32 VAR_6;\n    char*  VAR_7;\n    word32 VAR_8 = 0;\n    int   VAR_9 = VAR_10;\n\n    word32 VAR_11 = sizeof(word32)*2 + VAR_12 + VAR_13;\n    byte*  VAR_14 = NULL;\n    word32 VAR_15[2];\n    byte VAR_16[sizeof(word32) * 2];\n\n    if (VAR_0 == NULL) {\n        return VAR_17;\n    }\n\n    WLOG(VAR_18, \"Receiving WOLFSSH_FTP_OPENDIR\");\n\n    if (sizeof(VAR_19) > VAR_20) {\n        WLOG(VAR_18, \"Handle size is too large\");\n        return VAR_21;\n    }\n\n    /* COMMENT_0 */\n    ato32(VAR_2 + VAR_8, &VAR_6); VAR_8 += VAR_13;\n    if (VAR_6 + VAR_8 > VAR_3) {\n        return VAR_22;\n    }\n\n    /* COMMENT_1 */\n    VAR_7 = (char*)WMALLOC(VAR_6 + 1, VAR_0->ctx->heap, VAR_23);\n    if (VAR_7 == NULL) {\n        return VAR_24;\n    }\n    WMEMCPY(VAR_7, VAR_2 + VAR_8, VAR_6);\n    VAR_7[VAR_6] = '\\0';\n\n    /* COMMENT_2 */\n    if (wolfSSH_CleanPath(VAR_0, VAR_7) < 0) {\n        WFREE(VAR_7, VAR_0->ctx->heap, VAR_23);\n        return VAR_21;\n    }\n\n    if (WOPENDIR(VAR_0->fs, VAR_0->ctx->heap, &VAR_5, VAR_7) != 0) {\n        WLOG(VAR_18, \"Error with opening directory\");\n        WFREE(VAR_7, VAR_0->ctx->heap, VAR_23);\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_25, VAR_1,\n                \"Unable To Open Directory\", \"English\", NULL, &VAR_11)\n                != VAR_26) {\n                return VAR_21;\n        }\n        VAR_9 = VAR_27;\n    }\n\n    (void)VAR_1;\n\n    /* COMMENT_3 */\n    if (VAR_9 == VAR_10) {\n        DIR_HANDLE* VAR_28 = (DIR_HANDLE*)WMALLOC(sizeof(DIR_HANDLE),\n                VAR_0->ctx->heap, VAR_29);\n        if (VAR_28 == NULL) {\n            WFREE(VAR_7, VAR_0->ctx->heap, VAR_23);\n            WCLOSEDIR(&VAR_5);\n            return VAR_24;\n        }\n#ifdef VAR_30\n        WMEMCPY(&VAR_28->dir, &VAR_5, sizeof(WDIR));\n#else\n        VAR_28->dir  = VAR_5;\n#endif\n        VAR_28->id[0] = VAR_15[0] = VAR_31[0];\n        VAR_28->id[1] = VAR_15[1] = VAR_31[1];\n        c32toa(VAR_15[0], VAR_16);\n        c32toa(VAR_15[1], VAR_16 + VAR_13);\n        AddAssign64(VAR_31, 1);\n        VAR_28->isEof = 0;\n        VAR_28->next  = VAR_32;\n        VAR_32    = VAR_28;\n        VAR_32->dirName = VAR_7; /* COMMENT_4 */\n    }\n\n    VAR_14 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_23);\n    if (VAR_14 == NULL) {\n        return VAR_24;\n    }\n\n    if (VAR_9 == VAR_10) {\n        SFTP_CreatePacket(VAR_0, VAR_33, VAR_14, VAR_11,\n                VAR_16, sizeof(VAR_16));\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_25, VAR_1,\n                \"Unable To Open Directory\", \"English\", VAR_14, &VAR_11)\n                != VAR_10) {\n            WFREE(VAR_14, VAR_0->ctx->heap, VAR_23);\n            return VAR_21;\n        }\n    }\n\n    /* COMMENT_5 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_14, VAR_11);\n\n    return VAR_9;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/8.json",
  "func": "int wolfSSH_SFTP_RecvOpenDir(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WDIR  ctx;\n    word32 sz;\n    char*  dir;\n    word32 idx = 0;\n    int   ret = WS_SUCCESS;\n\n    word32 outSz = sizeof(word32)*2 + WOLFSSH_SFTP_HEADER + UINT32_SZ;\n    byte*  out = NULL;\n    word32 id[2];\n    byte idFlat[sizeof(word32) * 2];\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_OPENDIR\");\n\n    if (sizeof(WFD) > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Handle size is too large\");\n        return WS_FATAL_ERROR;\n    }\n\n    /* get directory name */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n\n    /* get directory handle */\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    if (WOPENDIR(ssh->fs, ssh->ctx->heap, &ctx, dir) != 0) {\n        WLOG(WS_LOG_SFTP, \"Error with opening directory\");\n        WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_NOFILE, reqId,\n                \"Unable To Open Directory\", \"English\", NULL, &outSz)\n                != WS_SIZE_ONLY) {\n                return WS_FATAL_ERROR;\n        }\n        ret = WS_BAD_FILE_E;\n    }\n\n    (void)reqId;\n\n    /* add to directory list @TODO locking for thread safety */\n    if (ret == WS_SUCCESS) {\n        DIR_HANDLE* cur = (DIR_HANDLE*)WMALLOC(sizeof(DIR_HANDLE),\n                ssh->ctx->heap, DYNTYPE_SFTP);\n        if (cur == NULL) {\n            WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n            WCLOSEDIR(&ctx);\n            return WS_MEMORY_E;\n        }\n#ifdef WOLFSSL_NUCLEUS\n        WMEMCPY(&cur->dir, &ctx, sizeof(WDIR));\n#else\n        cur->dir  = ctx;\n#endif\n        cur->id[0] = id[0] = idCount[0];\n        cur->id[1] = id[1] = idCount[1];\n        c32toa(id[0], idFlat);\n        c32toa(id[1], idFlat + UINT32_SZ);\n        AddAssign64(idCount, 1);\n        cur->isEof = 0;\n        cur->next  = dirList;\n        dirList    = cur;\n        dirList->dirName = dir; /* take over ownership of buffer */\n    }\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret == WS_SUCCESS) {\n        SFTP_CreatePacket(ssh, WOLFSSH_FTP_HANDLE, out, outSz,\n                idFlat, sizeof(idFlat));\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_NOFILE, reqId,\n                \"Unable To Open Directory\", \"English\", out, &outSz)\n                != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n\n    return ret;\n}",
  "abstract_func": "int wolfSSH_SFTP_RecvOpenDir(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WDIR  VAR_5;\n    word32 VAR_6;\n    char*  VAR_7;\n    word32 VAR_8 = 0;\n    int   VAR_9 = VAR_10;\n\n    word32 VAR_11 = sizeof(word32)*2 + VAR_12 + VAR_13;\n    byte*  VAR_14 = NULL;\n    word32 VAR_15[2];\n    byte VAR_16[sizeof(word32) * 2];\n\n    if (VAR_0 == NULL) {\n        return VAR_17;\n    }\n\n    WLOG(VAR_18, \"Receiving WOLFSSH_FTP_OPENDIR\");\n\n    if (sizeof(VAR_19) > VAR_20) {\n        WLOG(VAR_18, \"Handle size is too large\");\n        return VAR_21;\n    }\n\n    /* COMMENT_0 */\n    ato32(VAR_2 + VAR_8, &VAR_6); VAR_8 += VAR_13;\n    if (VAR_6 > VAR_3 - VAR_8) {\n        return VAR_22;\n    }\n\n    /* COMMENT_1 */\n    VAR_7 = (char*)WMALLOC(VAR_6 + 1, VAR_0->ctx->heap, VAR_23);\n    if (VAR_7 == NULL) {\n        return VAR_24;\n    }\n    WMEMCPY(VAR_7, VAR_2 + VAR_8, VAR_6);\n    VAR_7[VAR_6] = '\\0';\n\n    /* COMMENT_2 */\n    if (wolfSSH_CleanPath(VAR_0, VAR_7) < 0) {\n        WFREE(VAR_7, VAR_0->ctx->heap, VAR_23);\n        return VAR_21;\n    }\n\n    if (WOPENDIR(VAR_0->fs, VAR_0->ctx->heap, &VAR_5, VAR_7) != 0) {\n        WLOG(VAR_18, \"Error with opening directory\");\n        WFREE(VAR_7, VAR_0->ctx->heap, VAR_23);\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_25, VAR_1,\n                \"Unable To Open Directory\", \"English\", NULL, &VAR_11)\n                != VAR_26) {\n                return VAR_21;\n        }\n        VAR_9 = VAR_27;\n    }\n\n    (void)VAR_1;\n\n    /* COMMENT_3 */\n    if (VAR_9 == VAR_10) {\n        DIR_HANDLE* VAR_28 = (DIR_HANDLE*)WMALLOC(sizeof(DIR_HANDLE),\n                VAR_0->ctx->heap, VAR_29);\n        if (VAR_28 == NULL) {\n            WFREE(VAR_7, VAR_0->ctx->heap, VAR_23);\n            WCLOSEDIR(&VAR_5);\n            return VAR_24;\n        }\n#ifdef VAR_30\n        WMEMCPY(&VAR_28->dir, &VAR_5, sizeof(WDIR));\n#else\n        VAR_28->dir  = VAR_5;\n#endif\n        VAR_28->id[0] = VAR_15[0] = VAR_31[0];\n        VAR_28->id[1] = VAR_15[1] = VAR_31[1];\n        c32toa(VAR_15[0], VAR_16);\n        c32toa(VAR_15[1], VAR_16 + VAR_13);\n        AddAssign64(VAR_31, 1);\n        VAR_28->isEof = 0;\n        VAR_28->next  = VAR_32;\n        VAR_32    = VAR_28;\n        VAR_32->dirName = VAR_7; /* COMMENT_4 */\n    }\n\n    VAR_14 = (byte*)WMALLOC(VAR_11, VAR_0->ctx->heap, VAR_23);\n    if (VAR_14 == NULL) {\n        return VAR_24;\n    }\n\n    if (VAR_9 == VAR_10) {\n        SFTP_CreatePacket(VAR_0, VAR_33, VAR_14, VAR_11,\n                VAR_16, sizeof(VAR_16));\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_25, VAR_1,\n                \"Unable To Open Directory\", \"English\", VAR_14, &VAR_11)\n                != VAR_10) {\n            WFREE(VAR_14, VAR_0->ctx->heap, VAR_23);\n            return VAR_21;\n        }\n    }\n\n    /* COMMENT_5 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_14, VAR_11);\n\n    return VAR_9;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/8.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \n     /* get directory name */\n     ato32(data + idx, &sz); idx += UINT32_SZ;\n-    if (sz + idx > maxSz) {\n+    if (sz > maxSz - idx) {\n         return WS_BUFFER_E;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    if (sz + idx > maxSz) {"
    ],
    "added_lines": [
      "    if (sz > maxSz - idx) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": {
    "pr_info": {
      "title": "ASAN SFTP Fixes",
      "number": 360
    },
    "comment": [
      "When decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.95"
}