{
  "cve_id": "CVE-2021-37616",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Check that findKey didn't return end().",
  "commit_hash": "3ac426b2c04004422c290425259082281e090116",
  "git_url": "https://github.com/Exiv2/exiv2/commit/3ac426b2c04004422c290425259082281e090116",
  "file_path": "src/crwimage_int.cpp",
  "func_name": "CrwMap::encode0x080a",
  "func_before": "void CrwMap::encode0x080a(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n\n        const ExifKey k1(\"Exif.Image.Make\");\n        const ExifKey k2(\"Exif.Image.Model\");\n        const ExifData::const_iterator ed1 = image.exifData().findKey(k1);\n        const ExifData::const_iterator ed2 = image.exifData().findKey(k2);\n        const ExifData::const_iterator edEnd = image.exifData().end();\n\n        long size = 0;\n        if (ed1 != edEnd) size += ed1->size();\n        if (ed2 != edEnd) size += ed2->size();\n        if (size != 0) {\n            DataBuf buf(size);\n            if (ed1 != edEnd) ed1->copy(buf.pData_, pHead->byteOrder());\n            if (ed2 != edEnd) ed2->copy(buf.pData_ + ed1->size(), pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    }",
  "abstract_func_before": "void CrwMap::encode0x080a(const Image&      VAR_0,\n                              const CrwMapping* VAR_1,\n                                    CiffHeader* VAR_2)\n    {\n        assert(VAR_1 != 0);\n        assert(VAR_2 != 0);\n\n        const ExifKey VAR_3(\"Exif.Image.Make\");\n        const ExifKey VAR_4(\"Exif.Image.Model\");\n        const ExifData::const_iterator VAR_5 = VAR_0.exifData().findKey(VAR_3);\n        const ExifData::const_iterator VAR_6 = VAR_0.exifData().findKey(VAR_4);\n        const ExifData::const_iterator VAR_7 = VAR_0.exifData().end();\n\n        long VAR_8 = 0;\n        if (VAR_5 != VAR_7) VAR_8 += VAR_5->size();\n        if (VAR_6 != VAR_7) VAR_8 += VAR_6->size();\n        if (VAR_8 != 0) {\n            DataBuf buf(size);\n            if (VAR_5 != VAR_7) VAR_5->copy(VAR_9.pData_, VAR_2->byteOrder());\n            if (VAR_6 != VAR_7) VAR_6->copy(VAR_9.pData_ + VAR_5->size(), VAR_2->byteOrder());\n            VAR_2->add(VAR_1->crwTagId_, VAR_1->crwDir_, VAR_9);\n        }\n        else {\n            VAR_2->remove(VAR_1->crwTagId_, VAR_1->crwDir_);\n        }\n    }",
  "func_graph_path_before": "Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/crwimage_int.cpp/vul/before/0.json",
  "func": "void CrwMap::encode0x080a(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n\n        const ExifKey k1(\"Exif.Image.Make\");\n        const ExifKey k2(\"Exif.Image.Model\");\n        const ExifData::const_iterator ed1 = image.exifData().findKey(k1);\n        const ExifData::const_iterator ed2 = image.exifData().findKey(k2);\n        const ExifData::const_iterator edEnd = image.exifData().end();\n\n        long size = 0;\n        if (ed1 != edEnd) size += ed1->size();\n        if (ed2 != edEnd) size += ed2->size();\n        if (size != 0) {\n            DataBuf buf(size);\n            long pos = 0;\n            if (ed1 != edEnd) {\n                ed1->copy(buf.pData_, pHead->byteOrder());\n                pos += ed1->size();\n            }\n            if (ed2 != edEnd) {\n                ed2->copy(buf.pData_ + pos, pHead->byteOrder());\n                pos += ed2->size();\n            }\n            assert(pos == size);\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    }",
  "abstract_func": "void CrwMap::encode0x080a(const Image&      VAR_0,\n                              const CrwMapping* VAR_1,\n                                    CiffHeader* VAR_2)\n    {\n        assert(VAR_1 != 0);\n        assert(VAR_2 != 0);\n\n        const ExifKey VAR_3(\"Exif.Image.Make\");\n        const ExifKey VAR_4(\"Exif.Image.Model\");\n        const ExifData::const_iterator VAR_5 = VAR_0.exifData().findKey(VAR_3);\n        const ExifData::const_iterator VAR_6 = VAR_0.exifData().findKey(VAR_4);\n        const ExifData::const_iterator VAR_7 = VAR_0.exifData().end();\n\n        long VAR_8 = 0;\n        if (VAR_5 != VAR_7) VAR_8 += VAR_5->size();\n        if (VAR_6 != VAR_7) VAR_8 += VAR_6->size();\n        if (VAR_8 != 0) {\n            DataBuf buf(size);\n            long VAR_9 = 0;\n            if (VAR_5 != VAR_7) {\n                VAR_5->copy(VAR_10.pData_, VAR_2->byteOrder());\n                VAR_9 += VAR_5->size();\n            }\n            if (VAR_6 != VAR_7) {\n                VAR_6->copy(VAR_10.pData_ + VAR_9, VAR_2->byteOrder());\n                VAR_9 += VAR_6->size();\n            }\n            assert(VAR_9 == size);\n            VAR_2->add(VAR_1->crwTagId_, VAR_1->crwDir_, VAR_10);\n        }\n        else {\n            VAR_2->remove(VAR_1->crwTagId_, VAR_1->crwDir_);\n        }\n    }",
  "func_graph_path": "Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/crwimage_int.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,8 +16,16 @@\n         if (ed2 != edEnd) size += ed2->size();\n         if (size != 0) {\n             DataBuf buf(size);\n-            if (ed1 != edEnd) ed1->copy(buf.pData_, pHead->byteOrder());\n-            if (ed2 != edEnd) ed2->copy(buf.pData_ + ed1->size(), pHead->byteOrder());\n+            long pos = 0;\n+            if (ed1 != edEnd) {\n+                ed1->copy(buf.pData_, pHead->byteOrder());\n+                pos += ed1->size();\n+            }\n+            if (ed2 != edEnd) {\n+                ed2->copy(buf.pData_ + pos, pHead->byteOrder());\n+                pos += ed2->size();\n+            }\n+            assert(pos == size);\n             pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n         }\n         else {",
  "diff_line_info": {
    "deleted_lines": [
      "            if (ed1 != edEnd) ed1->copy(buf.pData_, pHead->byteOrder());",
      "            if (ed2 != edEnd) ed2->copy(buf.pData_ + ed1->size(), pHead->byteOrder());"
    ],
    "added_lines": [
      "            long pos = 0;",
      "            if (ed1 != edEnd) {",
      "                ed1->copy(buf.pData_, pHead->byteOrder());",
      "                pos += ed1->size();",
      "            }",
      "            if (ed2 != edEnd) {",
      "                ed2->copy(buf.pData_ + pos, pHead->byteOrder());",
      "                pos += ed2->size();",
      "            }",
      "            assert(pos == size);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sridharb1/exiv2/pull/4: 403 Client Error: Forbidden for url: https://api.github.com/repos/sridharb1/exiv2/issues/4/comments",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}