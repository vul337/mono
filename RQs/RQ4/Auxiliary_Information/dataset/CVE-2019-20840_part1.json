{
  "cve_id": "CVE-2019-20840",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "fix crash because of unaligned accesses in hybiReadAndDecode()",
  "commit_hash": "0cf1400c61850065de590d403f6d49e32882fd76",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/0cf1400c61850065de590d403f6d49e32882fd76",
  "file_path": "libvncserver/ws_decode.c",
  "func_name": "hybiReadAndDecode",
  "func_before": "static int\nhybiReadAndDecode(ws_ctx_t *wsctx, char *dst, int len, int *sockRet, int nInBuf)\n{\n  int n;\n  int i;\n  int toReturn; /* number of data bytes to return */\n  int toDecode; /* number of bytes to decode starting at wsctx->writePos */\n  int bufsize;\n  int nextRead;\n  unsigned char *data;\n  uint32_t *data32;\n\n  /* if data was carried over, copy to start of buffer */\n  memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);\n  wsctx->writePos += wsctx->carrylen;\n\n  /* -1 accounts for potential '\\0' terminator for base64 decoding */\n  bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;\n  ws_dbg(\"bufsize=%d\\n\", bufsize);\n  if (hybiRemaining(wsctx) > bufsize) {\n    nextRead = bufsize;\n  } else {\n    nextRead = hybiRemaining(wsctx);\n  }\n\n  ws_dbg(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\\n\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);\n\n  if (nextRead > 0) {\n    /* decode more data */\n    if (-1 == (n = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, wsctx->writePos, nextRead))) {\n      int olderrno = errno;\n      rfbErr(\"%s: read; %s\", __func__, strerror(errno));\n      errno = olderrno;\n      *sockRet = -1;\n      return WS_HYBI_STATE_ERR;\n    } else if (n == 0) {\n      *sockRet = 0;\n      return WS_HYBI_STATE_ERR;\n    } else {\n      ws_dbg(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadPayload);\n    }\n  } else {\n    n = 0;\n  }\n\n  wsctx->nReadPayload += n;\n  wsctx->writePos += n;\n\n  if (hybiRemaining(wsctx) == 0) {\n    wsctx->hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE;\n  }\n\n  /* number of not yet unmasked payload bytes: what we read here + what was\n   * carried over + what was read with the header */\n  toDecode = n + wsctx->carrylen + nInBuf;\n  ws_dbg(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);\n  if (toDecode < 0) {\n    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);\n    errno=EIO;\n    *sockRet = -1;\n    return WS_HYBI_STATE_ERR;\n  }\n\n  /* for a possible base64 decoding, we decode multiples of 4 bytes until\n   * the whole frame is received and carry over any remaining bytes in the carry buf*/\n  data = (unsigned char *)(wsctx->writePos - toDecode);\n  data32= (uint32_t *)data;\n\n  for (i = 0; i < (toDecode >> 2); i++) {\n    data32[i] ^= wsctx->header.mask.u;\n  }\n  ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);\n\n  if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n    /* process the remaining bytes (if any) */\n    for (i*=4; i < toDecode; i++) {\n      data[i] ^= wsctx->header.mask.c[i % 4];\n    }\n\n    /* all data is here, no carrying */\n    wsctx->carrylen = 0;\n  } else {\n    /* carry over remaining, non-multiple-of-four bytes */\n    wsctx->carrylen = toDecode - (i * 4);\n    if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {\n      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);\n      *sockRet = -1;\n      errno = EIO;\n      return WS_HYBI_STATE_ERR;\n    }\n    ws_dbg(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);\n    memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);\n    wsctx->writePos -= wsctx->carrylen;\n  }\n\n  toReturn = toDecode - wsctx->carrylen;\n\n  switch (wsctx->header.opcode) {\n    case WS_OPCODE_CLOSE:\n      /* this data is not returned as payload data */\n      if (hybiWsFrameComplete(wsctx)) {\n        *(wsctx->writePos) = '\\0';\n        ws_dbg(\"got close cmd %d, reason %d: %s\\n\", (int)(wsctx->writePos - hybiPayloadStart(wsctx)), WS_NTOH16(((uint16_t *)hybiPayloadStart(wsctx))[0]), &hybiPayloadStart(wsctx)[2]);\n        errno = ECONNRESET;\n        *sockRet = -1;\n        return WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        ws_dbg(\"got close cmd; waiting for %d more bytes to arrive\\n\", hybiRemaining(wsctx));\n        *sockRet = -1;\n        errno = EAGAIN;\n        return WS_HYBI_STATE_CLOSE_REASON_PENDING;\n      }\n      break;\n    case WS_OPCODE_TEXT_FRAME:\n      data[toReturn] = '\\0';\n      ws_dbg(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);\n      if (-1 == (wsctx->readlen = rfbBase64PtoN((char *)data, data, bufsize))) {\n        rfbErr(\"%s: Base64 decode error; %s\\n\", __func__, strerror(errno));\n      }\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      break;\n    case WS_OPCODE_BINARY_FRAME:\n      wsctx->readlen = toReturn;\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      ws_dbg(\"set readlen=%d writePos=%p\\n\", wsctx->readlen, wsctx->writePos);\n      break;\n    default:\n      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);\n  }\n  wsctx->readPos = data;\n\n  return hybiReturnData(dst, len, wsctx, sockRet);\n}",
  "abstract_func_before": "static int\nhybiReadAndDecode(ws_ctx_t *VAR_0, char *VAR_1, int VAR_2, int *VAR_3, int VAR_4)\n{\n  int VAR_5;\n  int VAR_6;\n  int VAR_7; /* COMMENT_0 */\n  int VAR_8; /* COMMENT_1 */\n  int VAR_9;\n  int VAR_10;\n  unsigned char *VAR_11;\n  uint32_t *VAR_12;\n\n  /* COMMENT_2 */\n  memcpy(VAR_0->writePos, VAR_0->carryBuf, VAR_0->carrylen);\n  VAR_0->writePos += VAR_0->carrylen;\n\n  /* COMMENT_3 */\n  VAR_9 = VAR_0->codeBufDecode + ARRAYSIZE(VAR_0->codeBufDecode) - VAR_0->writePos - 1;\n  ws_dbg(\"bufsize=%d\\n\", VAR_9);\n  if (hybiRemaining(VAR_0) > VAR_9) {\n    VAR_10 = VAR_9;\n  } else {\n    VAR_10 = hybiRemaining(VAR_0);\n  }\n\n  ws_dbg(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\\n\", VAR_0->writePos, VAR_10, VAR_0->codeBufDecode, VAR_0->header.headerLen);\n\n  if (VAR_10 > 0) {\n    /* COMMENT_4 */\n    if (-1 == (VAR_5 = VAR_0->ctxInfo.readFunc(VAR_0->ctxInfo.ctxPtr, VAR_0->writePos, VAR_10))) {\n      int VAR_13 = VAR_14;\n      rfbErr(\"%s: read; %s\", VAR_15, strerror(VAR_14));\n      VAR_14 = VAR_13;\n      *VAR_3 = -1;\n      return VAR_16;\n    } else if (VAR_5 == 0) {\n      *VAR_3 = 0;\n      return VAR_16;\n    } else {\n      ws_dbg(\"read %d bytes from socket; nRead=%d\\n\", VAR_5, VAR_0->nReadPayload);\n    }\n  } else {\n    VAR_5 = 0;\n  }\n\n  VAR_0->nReadPayload += VAR_5;\n  VAR_0->writePos += VAR_5;\n\n  if (hybiRemaining(VAR_0) == 0) {\n    VAR_0->hybiDecodeState = VAR_17;\n  }\n\n  /* COMMENT_5 */\n                                                    \n  VAR_8 = VAR_5 + VAR_0->carrylen + VAR_4;\n  ws_dbg(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", VAR_8, VAR_5, VAR_0->carrylen, VAR_0->header.headerLen);\n  if (VAR_8 < 0) {\n    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", VAR_15, VAR_8);\n    VAR_14=VAR_18;\n    *VAR_3 = -1;\n    return VAR_16;\n  }\n\n  /* COMMENT_7 */\n                                                                                      \n  VAR_11 = (unsigned char *)(VAR_0->writePos - VAR_8);\n  VAR_12= (uint32_t *)VAR_11;\n\n  for (VAR_6 = 0; VAR_6 < (VAR_8 >> 2); VAR_6++) {\n    VAR_12[VAR_6] ^= VAR_0->header.mask.u;\n  }\n  ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", VAR_6, VAR_8);\n\n  if (VAR_0->hybiDecodeState == VAR_17) {\n    /* COMMENT_9 */\n    for (VAR_6*=4; VAR_6 < VAR_8; VAR_6++) {\n      VAR_11[VAR_6] ^= VAR_0->header.mask.c[VAR_6 % 4];\n    }\n\n    /* COMMENT_10 */\n    VAR_0->carrylen = 0;\n  } else {\n    /* COMMENT_11 */\n    VAR_0->carrylen = VAR_8 - (VAR_6 * 4);\n    if (VAR_0->carrylen < 0 || VAR_0->carrylen > ARRAYSIZE(VAR_0->carryBuf)) {\n      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", VAR_15, VAR_0->carrylen, VAR_8, VAR_6);\n      *VAR_3 = -1;\n      VAR_14 = VAR_18;\n      return VAR_16;\n    }\n    ws_dbg(\"carrying over %d bytes from %p to %p\\n\", VAR_0->carrylen, VAR_0->writePos + (VAR_6 * 4), VAR_0->carryBuf);\n    memcpy(VAR_0->carryBuf, VAR_11 + (VAR_6 * 4), VAR_0->carrylen);\n    VAR_0->writePos -= VAR_0->carrylen;\n  }\n\n  VAR_7 = VAR_8 - VAR_0->carrylen;\n\n  switch (VAR_0->header.opcode) {\n    case VAR_19:\n      /* COMMENT_12 */\n      if (hybiWsFrameComplete(VAR_0)) {\n        *(VAR_0->writePos) = '\\0';\n        ws_dbg(\"got close cmd %d, reason %d: %s\\n\", (int)(VAR_0->writePos - hybiPayloadStart(VAR_0)), WS_NTOH16(((uint16_t *)hybiPayloadStart(VAR_0))[0]), &hybiPayloadStart(VAR_0)[2]);\n        VAR_14 = VAR_20;\n        *VAR_3 = -1;\n        return VAR_17;\n      } else {\n        ws_dbg(\"got close cmd; waiting for %d more bytes to arrive\\n\", hybiRemaining(VAR_0));\n        *VAR_3 = -1;\n        VAR_14 = VAR_21;\n        return VAR_22;\n      }\n      break;\n    case VAR_23:\n      VAR_11[VAR_7] = '\\0';\n      ws_dbg(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", VAR_11, VAR_9, VAR_11 + VAR_7);\n      if (-1 == (VAR_0->readlen = rfbBase64PtoN((char *)VAR_11, VAR_11, VAR_9))) {\n        rfbErr(\"%s: Base64 decode error; %s\\n\", VAR_15, strerror(VAR_14));\n      }\n      VAR_0->writePos = hybiPayloadStart(VAR_0);\n      break;\n    case VAR_24:\n      VAR_0->readlen = VAR_7;\n      VAR_0->writePos = hybiPayloadStart(VAR_0);\n      ws_dbg(\"set readlen=%d writePos=%p\\n\", VAR_0->readlen, VAR_0->writePos);\n      break;\n    default:\n      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", VAR_15, (int)VAR_0->header.opcode, VAR_0->header.data->b0, VAR_0->header.data->b1);\n  }\n  VAR_0->readPos = VAR_11;\n\n  return hybiReturnData(VAR_1, VAR_2, VAR_0, VAR_3);\n}",
  "func_graph_path_before": "LibVNC/libvncserver/0cf1400c61850065de590d403f6d49e32882fd76/ws_decode.c/vul/before/0.json",
  "func": "static int\nhybiReadAndDecode(ws_ctx_t *wsctx, char *dst, int len, int *sockRet, int nInBuf)\n{\n  int n;\n  int i;\n  int toReturn; /* number of data bytes to return */\n  int toDecode; /* number of bytes to decode starting at wsctx->writePos */\n  int bufsize;\n  int nextRead;\n  unsigned char *data;\n\n  /* if data was carried over, copy to start of buffer */\n  memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);\n  wsctx->writePos += wsctx->carrylen;\n\n  /* -1 accounts for potential '\\0' terminator for base64 decoding */\n  bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;\n  ws_dbg(\"bufsize=%d\\n\", bufsize);\n  if (hybiRemaining(wsctx) > bufsize) {\n    nextRead = bufsize;\n  } else {\n    nextRead = hybiRemaining(wsctx);\n  }\n\n  ws_dbg(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\\n\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);\n\n  if (nextRead > 0) {\n    /* decode more data */\n    if (-1 == (n = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, wsctx->writePos, nextRead))) {\n      int olderrno = errno;\n      rfbErr(\"%s: read; %s\", __func__, strerror(errno));\n      errno = olderrno;\n      *sockRet = -1;\n      return WS_HYBI_STATE_ERR;\n    } else if (n == 0) {\n      *sockRet = 0;\n      return WS_HYBI_STATE_ERR;\n    } else {\n      ws_dbg(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadPayload);\n    }\n  } else {\n    n = 0;\n  }\n\n  wsctx->nReadPayload += n;\n  wsctx->writePos += n;\n\n  if (hybiRemaining(wsctx) == 0) {\n    wsctx->hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE;\n  }\n\n  /* number of not yet unmasked payload bytes: what we read here + what was\n   * carried over + what was read with the header */\n  toDecode = n + wsctx->carrylen + nInBuf;\n  ws_dbg(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);\n  if (toDecode < 0) {\n    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);\n    errno=EIO;\n    *sockRet = -1;\n    return WS_HYBI_STATE_ERR;\n  }\n\n  /* for a possible base64 decoding, we decode multiples of 4 bytes until\n   * the whole frame is received and carry over any remaining bytes in the carry buf*/\n  data = (unsigned char *)(wsctx->writePos - toDecode);\n\n  for (i = 0; i < (toDecode >> 2); i++) {\n    uint32_t tmp;\n    memcpy(&tmp, data + i * sizeof(tmp), sizeof(tmp));\n    tmp ^= wsctx->header.mask.u;\n    memcpy(data + i * sizeof(tmp), &tmp, sizeof(tmp));\n  }\n  ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);\n\n  if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {\n    /* process the remaining bytes (if any) */\n    for (i*=4; i < toDecode; i++) {\n      data[i] ^= wsctx->header.mask.c[i % 4];\n    }\n\n    /* all data is here, no carrying */\n    wsctx->carrylen = 0;\n  } else {\n    /* carry over remaining, non-multiple-of-four bytes */\n    wsctx->carrylen = toDecode - (i * 4);\n    if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {\n      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);\n      *sockRet = -1;\n      errno = EIO;\n      return WS_HYBI_STATE_ERR;\n    }\n    ws_dbg(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);\n    memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);\n    wsctx->writePos -= wsctx->carrylen;\n  }\n\n  toReturn = toDecode - wsctx->carrylen;\n\n  switch (wsctx->header.opcode) {\n    case WS_OPCODE_CLOSE:\n      /* this data is not returned as payload data */\n      if (hybiWsFrameComplete(wsctx)) {\n        *(wsctx->writePos) = '\\0';\n        ws_dbg(\"got close cmd %d, reason %d: %s\\n\", (int)(wsctx->writePos - hybiPayloadStart(wsctx)), WS_NTOH16(((uint16_t *)hybiPayloadStart(wsctx))[0]), &hybiPayloadStart(wsctx)[2]);\n        errno = ECONNRESET;\n        *sockRet = -1;\n        return WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        ws_dbg(\"got close cmd; waiting for %d more bytes to arrive\\n\", hybiRemaining(wsctx));\n        *sockRet = -1;\n        errno = EAGAIN;\n        return WS_HYBI_STATE_CLOSE_REASON_PENDING;\n      }\n      break;\n    case WS_OPCODE_TEXT_FRAME:\n      data[toReturn] = '\\0';\n      ws_dbg(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);\n      if (-1 == (wsctx->readlen = rfbBase64PtoN((char *)data, data, bufsize))) {\n        rfbErr(\"%s: Base64 decode error; %s\\n\", __func__, strerror(errno));\n      }\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      break;\n    case WS_OPCODE_BINARY_FRAME:\n      wsctx->readlen = toReturn;\n      wsctx->writePos = hybiPayloadStart(wsctx);\n      ws_dbg(\"set readlen=%d writePos=%p\\n\", wsctx->readlen, wsctx->writePos);\n      break;\n    default:\n      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);\n  }\n  wsctx->readPos = data;\n\n  return hybiReturnData(dst, len, wsctx, sockRet);\n}",
  "abstract_func": "static int\nhybiReadAndDecode(ws_ctx_t *VAR_0, char *VAR_1, int VAR_2, int *VAR_3, int VAR_4)\n{\n  int VAR_5;\n  int VAR_6;\n  int VAR_7; /* COMMENT_0 */\n  int VAR_8; /* COMMENT_1 */\n  int VAR_9;\n  int VAR_10;\n  unsigned char *VAR_11;\n\n  /* COMMENT_2 */\n  memcpy(VAR_0->writePos, VAR_0->carryBuf, VAR_0->carrylen);\n  VAR_0->writePos += VAR_0->carrylen;\n\n  /* COMMENT_3 */\n  VAR_9 = VAR_0->codeBufDecode + ARRAYSIZE(VAR_0->codeBufDecode) - VAR_0->writePos - 1;\n  ws_dbg(\"bufsize=%d\\n\", VAR_9);\n  if (hybiRemaining(VAR_0) > VAR_9) {\n    VAR_10 = VAR_9;\n  } else {\n    VAR_10 = hybiRemaining(VAR_0);\n  }\n\n  ws_dbg(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\\n\", VAR_0->writePos, VAR_10, VAR_0->codeBufDecode, VAR_0->header.headerLen);\n\n  if (VAR_10 > 0) {\n    /* COMMENT_4 */\n    if (-1 == (VAR_5 = VAR_0->ctxInfo.readFunc(VAR_0->ctxInfo.ctxPtr, VAR_0->writePos, VAR_10))) {\n      int VAR_12 = VAR_13;\n      rfbErr(\"%s: read; %s\", VAR_14, strerror(VAR_13));\n      VAR_13 = VAR_12;\n      *VAR_3 = -1;\n      return VAR_15;\n    } else if (VAR_5 == 0) {\n      *VAR_3 = 0;\n      return VAR_15;\n    } else {\n      ws_dbg(\"read %d bytes from socket; nRead=%d\\n\", VAR_5, VAR_0->nReadPayload);\n    }\n  } else {\n    VAR_5 = 0;\n  }\n\n  VAR_0->nReadPayload += VAR_5;\n  VAR_0->writePos += VAR_5;\n\n  if (hybiRemaining(VAR_0) == 0) {\n    VAR_0->hybiDecodeState = VAR_16;\n  }\n\n  /* COMMENT_5 */\n                                                    \n  VAR_8 = VAR_5 + VAR_0->carrylen + VAR_4;\n  ws_dbg(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", VAR_8, VAR_5, VAR_0->carrylen, VAR_0->header.headerLen);\n  if (VAR_8 < 0) {\n    rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", VAR_14, VAR_8);\n    VAR_13=VAR_17;\n    *VAR_3 = -1;\n    return VAR_15;\n  }\n\n  /* COMMENT_7 */\n                                                                                      \n  VAR_11 = (unsigned char *)(VAR_0->writePos - VAR_8);\n\n  for (VAR_6 = 0; VAR_6 < (VAR_8 >> 2); VAR_6++) {\n    uint32_t VAR_18;\n    memcpy(&VAR_18, VAR_11 + VAR_6 * sizeof(VAR_18), sizeof(VAR_18));\n    VAR_18 ^= VAR_0->header.mask.u;\n    memcpy(VAR_11 + VAR_6 * sizeof(VAR_18), &VAR_18, sizeof(VAR_18));\n  }\n  ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", VAR_6, VAR_8);\n\n  if (VAR_0->hybiDecodeState == VAR_16) {\n    /* COMMENT_9 */\n    for (VAR_6*=4; VAR_6 < VAR_8; VAR_6++) {\n      VAR_11[VAR_6] ^= VAR_0->header.mask.c[VAR_6 % 4];\n    }\n\n    /* COMMENT_10 */\n    VAR_0->carrylen = 0;\n  } else {\n    /* COMMENT_11 */\n    VAR_0->carrylen = VAR_8 - (VAR_6 * 4);\n    if (VAR_0->carrylen < 0 || VAR_0->carrylen > ARRAYSIZE(VAR_0->carryBuf)) {\n      rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", VAR_14, VAR_0->carrylen, VAR_8, VAR_6);\n      *VAR_3 = -1;\n      VAR_13 = VAR_17;\n      return VAR_15;\n    }\n    ws_dbg(\"carrying over %d bytes from %p to %p\\n\", VAR_0->carrylen, VAR_0->writePos + (VAR_6 * 4), VAR_0->carryBuf);\n    memcpy(VAR_0->carryBuf, VAR_11 + (VAR_6 * 4), VAR_0->carrylen);\n    VAR_0->writePos -= VAR_0->carrylen;\n  }\n\n  VAR_7 = VAR_8 - VAR_0->carrylen;\n\n  switch (VAR_0->header.opcode) {\n    case VAR_19:\n      /* COMMENT_12 */\n      if (hybiWsFrameComplete(VAR_0)) {\n        *(VAR_0->writePos) = '\\0';\n        ws_dbg(\"got close cmd %d, reason %d: %s\\n\", (int)(VAR_0->writePos - hybiPayloadStart(VAR_0)), WS_NTOH16(((uint16_t *)hybiPayloadStart(VAR_0))[0]), &hybiPayloadStart(VAR_0)[2]);\n        VAR_13 = VAR_20;\n        *VAR_3 = -1;\n        return VAR_16;\n      } else {\n        ws_dbg(\"got close cmd; waiting for %d more bytes to arrive\\n\", hybiRemaining(VAR_0));\n        *VAR_3 = -1;\n        VAR_13 = VAR_21;\n        return VAR_22;\n      }\n      break;\n    case VAR_23:\n      VAR_11[VAR_7] = '\\0';\n      ws_dbg(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", VAR_11, VAR_9, VAR_11 + VAR_7);\n      if (-1 == (VAR_0->readlen = rfbBase64PtoN((char *)VAR_11, VAR_11, VAR_9))) {\n        rfbErr(\"%s: Base64 decode error; %s\\n\", VAR_14, strerror(VAR_13));\n      }\n      VAR_0->writePos = hybiPayloadStart(VAR_0);\n      break;\n    case VAR_24:\n      VAR_0->readlen = VAR_7;\n      VAR_0->writePos = hybiPayloadStart(VAR_0);\n      ws_dbg(\"set readlen=%d writePos=%p\\n\", VAR_0->readlen, VAR_0->writePos);\n      break;\n    default:\n      rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", VAR_14, (int)VAR_0->header.opcode, VAR_0->header.data->b0, VAR_0->header.data->b1);\n  }\n  VAR_0->readPos = VAR_11;\n\n  return hybiReturnData(VAR_1, VAR_2, VAR_0, VAR_3);\n}",
  "func_graph_path": "LibVNC/libvncserver/0cf1400c61850065de590d403f6d49e32882fd76/ws_decode.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,6 @@\n   int bufsize;\n   int nextRead;\n   unsigned char *data;\n-  uint32_t *data32;\n \n   /* if data was carried over, copy to start of buffer */\n   memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);\n@@ -64,10 +63,12 @@\n   /* for a possible base64 decoding, we decode multiples of 4 bytes until\n    * the whole frame is received and carry over any remaining bytes in the carry buf*/\n   data = (unsigned char *)(wsctx->writePos - toDecode);\n-  data32= (uint32_t *)data;\n \n   for (i = 0; i < (toDecode >> 2); i++) {\n-    data32[i] ^= wsctx->header.mask.u;\n+    uint32_t tmp;\n+    memcpy(&tmp, data + i * sizeof(tmp), sizeof(tmp));\n+    tmp ^= wsctx->header.mask.u;\n+    memcpy(data + i * sizeof(tmp), &tmp, sizeof(tmp));\n   }\n   ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  uint32_t *data32;",
      "  data32= (uint32_t *)data;",
      "    data32[i] ^= wsctx->header.mask.u;"
    ],
    "added_lines": [
      "    uint32_t tmp;",
      "    memcpy(&tmp, data + i * sizeof(tmp), sizeof(tmp));",
      "    tmp ^= wsctx->header.mask.u;",
      "    memcpy(data + i * sizeof(tmp), &tmp, sizeof(tmp));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/308",
  "description": {
    "pr_info": {
      "title": "fix crash because of unaligned accesses in hybiReadAndDecode()",
      "number": 308
    },
    "comment": [
      "See https://bugs.gentoo.org/686914\r\n\r\nIt crashes in wstest otherwise.\r\n\r\nIt should not hurt on platforms that support unaligned accesses as the compiler usually is clever enough to optimize memcpy() away."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9  \n\nThe patch addresses a crash caused by unaligned memory accesses, fixing a bug without explicit security implications. The code changes target a known issue, making the classification clear."
}