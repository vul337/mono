{
  "cve_id": "CVE-2023-31438",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "systemd",
  "commit_msg": "journalctl: verify sealed log epochs are continuous\n\nCurrently empty epochs are not sealed. This allows an attacker to truncate\na sealed log and continue it without any problems showing when verifying the\nlog.\n\nThis partially addresses CVE-2023-31438. One way to extend this change to\naddress CVE-2023-31438 completely, would be to verify that there is exactly\none seal per epoch (and not sealing when the epoch has not ended yet).\n\nthe change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS\nthis flag indicates that a journal file is sealed continuously and decides whether\nany missing crypto epochs should trigger a warning or an error.",
  "commit_hash": "8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "file_path": "src/libsystemd/sd-journal/journal-file.c",
  "func_name": "warn_wrong_flags",
  "func_before": "static bool warn_wrong_flags(const JournalFile *f, bool compatible) {\n        const uint32_t any = compatible ? HEADER_COMPATIBLE_ANY : HEADER_INCOMPATIBLE_ANY,\n                supported = compatible ? HEADER_COMPATIBLE_SUPPORTED : HEADER_INCOMPATIBLE_SUPPORTED;\n        const char *type = compatible ? \"compatible\" : \"incompatible\";\n        uint32_t flags;\n\n        assert(f);\n        assert(f->header);\n\n        flags = le32toh(compatible ? f->header->compatible_flags : f->header->incompatible_flags);\n\n        if (flags & ~supported) {\n                if (flags & ~any)\n                        log_debug(\"Journal file %s has unknown %s flags 0x%\"PRIx32,\n                                  f->path, type, flags & ~any);\n                flags = (flags & any) & ~supported;\n                if (flags) {\n                        const char* strv[6];\n                        size_t n = 0;\n                        _cleanup_free_ char *t = NULL;\n\n                        if (compatible) {\n                                if (flags & HEADER_COMPATIBLE_SEALED)\n                                        strv[n++] = \"sealed\";\n                        } else {\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ)\n                                        strv[n++] = \"xz-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_LZ4)\n                                        strv[n++] = \"lz4-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_ZSTD)\n                                        strv[n++] = \"zstd-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_KEYED_HASH)\n                                        strv[n++] = \"keyed-hash\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPACT)\n                                        strv[n++] = \"compact\";\n                        }\n                        strv[n] = NULL;\n                        assert(n < ELEMENTSOF(strv));\n\n                        t = strv_join((char**) strv, \", \");\n                        log_debug(\"Journal file %s uses %s %s %s disabled at compilation time.\",\n                                  f->path, type, n > 1 ? \"flags\" : \"flag\", strnull(t));\n                }\n                return true;\n        }\n\n        return false;\n}",
  "abstract_func_before": "static bool warn_wrong_flags(const JournalFile *VAR_0, bool VAR_1) {\n        const uint32_t VAR_2 = VAR_1 ? VAR_3 : VAR_4,\n                VAR_5 = VAR_1 ? VAR_6 : VAR_7;\n        const char *VAR_8 = VAR_1 ? \"compatible\" : \"incompatible\";\n        uint32_t VAR_9;\n\n        assert(VAR_0);\n        assert(VAR_0->header);\n\n        VAR_9 = le32toh(VAR_1 ? VAR_0->header->compatible_flags : VAR_0->header->incompatible_flags);\n\n        if (VAR_9 & ~VAR_5) {\n                if (VAR_9 & ~VAR_2)\n                        log_debug(\"Journal file %s has unknown %s flags 0x%\"VAR_10,\n                                  VAR_0->path, VAR_8, VAR_9 & ~VAR_2);\n                VAR_9 = (VAR_9 & VAR_2) & ~VAR_5;\n                if (VAR_9) {\n                        const char* VAR_11[6];\n                        size_t VAR_12 = 0;\n                        _cleanup_free_ char *VAR_13 = NULL;\n\n                        if (VAR_1) {\n                                if (VAR_9 & VAR_14)\n                                        VAR_11[VAR_12++] = \"sealed\";\n                        } else {\n                                if (VAR_9 & VAR_15)\n                                        VAR_11[VAR_12++] = \"xz-compressed\";\n                                if (VAR_9 & VAR_16)\n                                        VAR_11[VAR_12++] = \"lz4-compressed\";\n                                if (VAR_9 & VAR_17)\n                                        VAR_11[VAR_12++] = \"zstd-compressed\";\n                                if (VAR_9 & VAR_18)\n                                        VAR_11[VAR_12++] = \"keyed-hash\";\n                                if (VAR_9 & VAR_19)\n                                        VAR_11[VAR_12++] = \"compact\";\n                        }\n                        VAR_11[VAR_12] = NULL;\n                        assert(VAR_12 < ELEMENTSOF(VAR_11));\n\n                        VAR_13 = strv_join((char**) VAR_11, \", \");\n                        log_debug(\"Journal file %s uses %s %s %s disabled at compilation time.\",\n                                  VAR_0->path, VAR_8, VAR_12 > 1 ? \"flags\" : \"flag\", strnull(VAR_13));\n                }\n                return true;\n        }\n\n        return false;\n}",
  "func_graph_path_before": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-file.c/vul/before/1.json",
  "func": "static bool warn_wrong_flags(const JournalFile *f, bool compatible) {\n        const uint32_t any = compatible ? HEADER_COMPATIBLE_ANY : HEADER_INCOMPATIBLE_ANY,\n                supported = compatible ? HEADER_COMPATIBLE_SUPPORTED : HEADER_INCOMPATIBLE_SUPPORTED;\n        const char *type = compatible ? \"compatible\" : \"incompatible\";\n        uint32_t flags;\n\n        assert(f);\n        assert(f->header);\n\n        flags = le32toh(compatible ? f->header->compatible_flags : f->header->incompatible_flags);\n\n        if (flags & ~supported) {\n                if (flags & ~any)\n                        log_debug(\"Journal file %s has unknown %s flags 0x%\"PRIx32,\n                                  f->path, type, flags & ~any);\n                flags = (flags & any) & ~supported;\n                if (flags) {\n                        const char* strv[6];\n                        size_t n = 0;\n                        _cleanup_free_ char *t = NULL;\n\n                        if (compatible) {\n                                if (flags & HEADER_COMPATIBLE_SEALED)\n                                        strv[n++] = \"sealed\";\n                                if (flags & HEADER_COMPATIBLE_SEALED_CONTINUOUS)\n                                        strv[n++] = \"sealed-continuous\";\n                        } else {\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ)\n                                        strv[n++] = \"xz-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_LZ4)\n                                        strv[n++] = \"lz4-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_ZSTD)\n                                        strv[n++] = \"zstd-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_KEYED_HASH)\n                                        strv[n++] = \"keyed-hash\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPACT)\n                                        strv[n++] = \"compact\";\n                        }\n                        strv[n] = NULL;\n                        assert(n < ELEMENTSOF(strv));\n\n                        t = strv_join((char**) strv, \", \");\n                        log_debug(\"Journal file %s uses %s %s %s disabled at compilation time.\",\n                                  f->path, type, n > 1 ? \"flags\" : \"flag\", strnull(t));\n                }\n                return true;\n        }\n\n        return false;\n}",
  "abstract_func": "static bool warn_wrong_flags(const JournalFile *VAR_0, bool VAR_1) {\n        const uint32_t VAR_2 = VAR_1 ? VAR_3 : VAR_4,\n                VAR_5 = VAR_1 ? VAR_6 : VAR_7;\n        const char *VAR_8 = VAR_1 ? \"compatible\" : \"incompatible\";\n        uint32_t VAR_9;\n\n        assert(VAR_0);\n        assert(VAR_0->header);\n\n        VAR_9 = le32toh(VAR_1 ? VAR_0->header->compatible_flags : VAR_0->header->incompatible_flags);\n\n        if (VAR_9 & ~VAR_5) {\n                if (VAR_9 & ~VAR_2)\n                        log_debug(\"Journal file %s has unknown %s flags 0x%\"VAR_10,\n                                  VAR_0->path, VAR_8, VAR_9 & ~VAR_2);\n                VAR_9 = (VAR_9 & VAR_2) & ~VAR_5;\n                if (VAR_9) {\n                        const char* VAR_11[6];\n                        size_t VAR_12 = 0;\n                        _cleanup_free_ char *VAR_13 = NULL;\n\n                        if (VAR_1) {\n                                if (VAR_9 & VAR_14)\n                                        VAR_11[VAR_12++] = \"sealed\";\n                                if (VAR_9 & VAR_15)\n                                        VAR_11[VAR_12++] = \"sealed-continuous\";\n                        } else {\n                                if (VAR_9 & VAR_16)\n                                        VAR_11[VAR_12++] = \"xz-compressed\";\n                                if (VAR_9 & VAR_17)\n                                        VAR_11[VAR_12++] = \"lz4-compressed\";\n                                if (VAR_9 & VAR_18)\n                                        VAR_11[VAR_12++] = \"zstd-compressed\";\n                                if (VAR_9 & VAR_19)\n                                        VAR_11[VAR_12++] = \"keyed-hash\";\n                                if (VAR_9 & VAR_20)\n                                        VAR_11[VAR_12++] = \"compact\";\n                        }\n                        VAR_11[VAR_12] = NULL;\n                        assert(VAR_12 < ELEMENTSOF(VAR_11));\n\n                        VAR_13 = strv_join((char**) VAR_11, \", \");\n                        log_debug(\"Journal file %s uses %s %s %s disabled at compilation time.\",\n                                  VAR_0->path, VAR_8, VAR_12 > 1 ? \"flags\" : \"flag\", strnull(VAR_13));\n                }\n                return true;\n        }\n\n        return false;\n}",
  "func_graph_path": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-file.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,8 @@\n                         if (compatible) {\n                                 if (flags & HEADER_COMPATIBLE_SEALED)\n                                         strv[n++] = \"sealed\";\n+                                if (flags & HEADER_COMPATIBLE_SEALED_CONTINUOUS)\n+                                        strv[n++] = \"sealed-continuous\";\n                         } else {\n                                 if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ)\n                                         strv[n++] = \"xz-compressed\";",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                                if (flags & HEADER_COMPATIBLE_SEALED_CONTINUOUS)",
      "                                        strv[n++] = \"sealed-continuous\";"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/28886",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/systemd/systemd/pull/28886: 403 Client Error: Forbidden for url: https://api.github.com/repos/systemd/systemd/pulls/28886",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}