{
  "cve_id": "CVE-2022-32234",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#772)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "06eaec767e376bfdb883d912cb15e987ddf2bda1",
  "git_url": "https://github.com/facebook/hermes/commit/06eaec767e376bfdb883d912cb15e987ddf2bda1",
  "file_path": "external/llvh/include/llvh/ADT/SmallVector.h",
  "func_name": "SmallVectorTemplateBase<T, isPodLike>::grow",
  "func_before": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n  if (MinSize > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  // Always grow, even from zero.\n  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));\n  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));\n  T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n\n  // Move the elements over.\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n\n  // Destroy the original elements.\n  destroy_range(this->begin(), this->end());\n\n  // If this wasn't grown from the inline copy, deallocate the old space.\n  if (!this->isSmall())\n    free(this->begin());\n\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}",
  "abstract_func_before": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t VAR_0) {\n  if (VAR_0 > VAR_1)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  /* COMMENT_0 */\n  size_t VAR_2 = size_t(NextPowerOf2(this->capacity() + 2));\n  VAR_2 = std::min(std::max(VAR_2, VAR_0), size_t(VAR_1));\n  T *VAR_3 = VAR_4<T*>(llvh::safe_malloc(VAR_2*sizeof(T)));\n\n  /* COMMENT_1 */\n  this->uninitialized_move(this->begin(), this->end(), VAR_3);\n\n  /* COMMENT_2 */\n  destroy_range(this->begin(), this->end());\n\n  /* COMMENT_3 */\n  if (!this->isSmall())\n    free(this->begin());\n\n  this->BeginX = VAR_3;\n  this->Capacity = VAR_2;\n}",
  "func_graph_path_before": "facebook/hermes/06eaec767e376bfdb883d912cb15e987ddf2bda1/SmallVector.h/vul/before/0.json",
  "func": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n  // Always grow, even from zero.\n  constexpr size_t MinGrowth = 2;\n  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + MinGrowth));\n  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinSize));\n  // Ensure that NewCapacity did not overflow an unsigned int,\n  // and that the capacity in bytes will not overflow a size_t.\n  if (NewCapacity <= this->capacity() ||\n      NewCapacity < MinSize ||\n      NewCapacity > size_t(-1) / sizeof(T))\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n\n  // Move the elements over.\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n\n  // Destroy the original elements.\n  destroy_range(this->begin(), this->end());\n\n  // If this wasn't grown from the inline copy, deallocate the old space.\n  if (!this->isSmall())\n    free(this->begin());\n\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}",
  "abstract_func": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t VAR_0) {\n  /* COMMENT_0 */\n  constexpr size_t VAR_1 = 2;\n  size_t VAR_2 = size_t(NextPowerOf2(this->capacity() + VAR_1));\n  VAR_2 = VAR_3<unsigned>(std::max(VAR_2, VAR_0));\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (VAR_2 <= this->capacity() ||\n      VAR_2 < VAR_0 ||\n      VAR_2 > size_t(-1) / sizeof(T))\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  T *VAR_4 = VAR_3<T*>(llvh::safe_malloc(VAR_2*sizeof(T)));\n\n  /* COMMENT_3 */\n  this->uninitialized_move(this->begin(), this->end(), VAR_4);\n\n  /* COMMENT_4 */\n  destroy_range(this->begin(), this->end());\n\n  /* COMMENT_5 */\n  if (!this->isSmall())\n    free(this->begin());\n\n  this->BeginX = VAR_4;\n  this->Capacity = VAR_2;\n}",
  "func_graph_path": "facebook/hermes/06eaec767e376bfdb883d912cb15e987ddf2bda1/SmallVector.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,14 @@\n void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n-  if (MinSize > UINT32_MAX)\n+  // Always grow, even from zero.\n+  constexpr size_t MinGrowth = 2;\n+  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + MinGrowth));\n+  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinSize));\n+  // Ensure that NewCapacity did not overflow an unsigned int,\n+  // and that the capacity in bytes will not overflow a size_t.\n+  if (NewCapacity <= this->capacity() ||\n+      NewCapacity < MinSize ||\n+      NewCapacity > size_t(-1) / sizeof(T))\n     report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n-\n-  // Always grow, even from zero.\n-  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));\n-  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));\n   T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n \n   // Move the elements over.",
  "diff_line_info": {
    "deleted_lines": [
      "  if (MinSize > UINT32_MAX)",
      "",
      "  // Always grow, even from zero.",
      "  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));",
      "  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));"
    ],
    "added_lines": [
      "  // Always grow, even from zero.",
      "  constexpr size_t MinGrowth = 2;",
      "  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + MinGrowth));",
      "  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinSize));",
      "  // Ensure that NewCapacity did not overflow an unsigned int,",
      "  // and that the capacity in bytes will not overflow a size_t.",
      "  if (NewCapacity <= this->capacity() ||",
      "      NewCapacity < MinSize ||",
      "      NewCapacity > size_t(-1) / sizeof(T))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/772",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/hermes/pull/772: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/hermes/pulls/772",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8"
}