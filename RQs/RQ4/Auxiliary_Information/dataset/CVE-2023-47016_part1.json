{
  "cve_id": "CVE-2023-47016",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix #22349 - oobread in xnu kernelcache ##crash\n\n* Reproducer rabin_hbo_194\n* Reported by @gandalf4a",
  "commit_hash": "40c9f50e127be80b9d816bce2ab2ee790831aefd",
  "git_url": "https://github.com/radareorg/radare2/commit/40c9f50e127be80b9d816bce2ab2ee790831aefd",
  "file_path": "libr/bin/p/bin_xnu_kernelcache.c",
  "func_name": "process_constructors",
  "func_before": "static void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}",
  "abstract_func_before": "static void process_constructors(RKernelCacheObj *VAR_0, struct MACH0_(obj_t) *VAR_1, RList *VAR_2, ut64 VAR_3, bool VAR_4, int VAR_5, const char *VAR_6) {\n\tconst RVector *VAR_7 = MACH0_(VAR_8) (VAR_1);\n\tif (!VAR_7) {\n\t\treturn;\n\t}\n\tint VAR_9;\n\tstruct section_t *VAR_10;\n\tr_vector_foreach (VAR_7, VAR_10) {\n\t\tif (VAR_10->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr (VAR_10->name, \"_mod_fini_func\") || strstr (VAR_10->name, \"_mod_term_func\")) {\n\t\t\tVAR_9  = VAR_11;\n\t\t} else if (strstr (VAR_10->name, \"_mod_init_func\")) {\n\t\t\tVAR_9  = VAR_4 ? 0 : VAR_12;\n\t\t\tVAR_4 = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut8 *VAR_13 = calloc (VAR_10->size, 1);\n\t\tif (!VAR_13) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (VAR_0->cache_buf, VAR_10->paddr + VAR_3, VAR_13, VAR_10->size) < VAR_10->size) {\n\t\t\tfree (VAR_13);\n\t\t\tbreak;\n\t\t}\n\t\tint VAR_14;\n\t\tint VAR_15 = 0;\n\t\tfor (VAR_14 = 0; VAR_14 < VAR_10->size; VAR_14 += 8) {\n\t\t\tut64 VAR_16 = K_RPTR (VAR_13 + VAR_14);\n\t\t\tut64 VAR_17 = VAR_10->paddr + VAR_3 + VAR_14;\n\t\t\tif (VAR_5 == VAR_18) {\n\t\t\t\tRBinAddr *VAR_19 = newEntry (VAR_17, VAR_16, VAR_9);\n\t\t\t\tr_list_append (VAR_2, VAR_19);\n\t\t\t} else if (VAR_5 == VAR_20) {\n\t\t\t\tRBinSymbol *VAR_21 = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!VAR_21) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tVAR_21->name = r_str_newf (\"%s.%s.%d\", VAR_6, (VAR_9 == VAR_12) ? \"init\" : \"fini\", VAR_15++);\n\t\t\t\tVAR_21->vaddr = VAR_16;\n\t\t\t\tVAR_21->paddr = VAR_17;\n\t\t\t\tVAR_21->size = 0;\n\t\t\t\tVAR_21->forwarder = \"NONE\";\n\t\t\t\tVAR_21->bind = \"GLOBAL\";\n\t\t\t\tVAR_21->type = \"FUNC\";\n\n\t\t\t\tr_list_append (VAR_2, VAR_21);\n\t\t\t}\n\t\t}\n\t\tfree (VAR_13);\n\t}\n}",
  "func_graph_path_before": null,
  "func": "static void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j + 7 < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}",
  "abstract_func": "static void process_constructors(RKernelCacheObj *VAR_0, struct MACH0_(obj_t) *VAR_1, RList *VAR_2, ut64 VAR_3, bool VAR_4, int VAR_5, const char *VAR_6) {\n\tconst RVector *VAR_7 = MACH0_(VAR_8) (VAR_1);\n\tif (!VAR_7) {\n\t\treturn;\n\t}\n\tint VAR_9;\n\tstruct section_t *VAR_10;\n\tr_vector_foreach (VAR_7, VAR_10) {\n\t\tif (VAR_10->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr (VAR_10->name, \"_mod_fini_func\") || strstr (VAR_10->name, \"_mod_term_func\")) {\n\t\t\tVAR_9  = VAR_11;\n\t\t} else if (strstr (VAR_10->name, \"_mod_init_func\")) {\n\t\t\tVAR_9  = VAR_4 ? 0 : VAR_12;\n\t\t\tVAR_4 = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut8 *VAR_13 = calloc (VAR_10->size, 1);\n\t\tif (!VAR_13) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (VAR_0->cache_buf, VAR_10->paddr + VAR_3, VAR_13, VAR_10->size) < VAR_10->size) {\n\t\t\tfree (VAR_13);\n\t\t\tbreak;\n\t\t}\n\t\tint VAR_14;\n\t\tint VAR_15 = 0;\n\t\tfor (VAR_14 = 0; VAR_14 + 7 < VAR_10->size; VAR_14 += 8) {\n\t\t\tut64 VAR_16 = K_RPTR (VAR_13 + VAR_14);\n\t\t\tut64 VAR_17 = VAR_10->paddr + VAR_3 + VAR_14;\n\t\t\tif (VAR_5 == VAR_18) {\n\t\t\t\tRBinAddr *VAR_19 = newEntry (VAR_17, VAR_16, VAR_9);\n\t\t\t\tr_list_append (VAR_2, VAR_19);\n\t\t\t} else if (VAR_5 == VAR_20) {\n\t\t\t\tRBinSymbol *VAR_21 = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!VAR_21) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tVAR_21->name = r_str_newf (\"%s.%s.%d\", VAR_6, (VAR_9 == VAR_12) ? \"init\" : \"fini\", VAR_15++);\n\t\t\t\tVAR_21->vaddr = VAR_16;\n\t\t\t\tVAR_21->paddr = VAR_17;\n\t\t\t\tVAR_21->size = 0;\n\t\t\t\tVAR_21->forwarder = \"NONE\";\n\t\t\t\tVAR_21->bind = \"GLOBAL\";\n\t\t\t\tVAR_21->type = \"FUNC\";\n\n\t\t\t\tr_list_append (VAR_2, VAR_21);\n\t\t\t}\n\t\t}\n\t\tfree (VAR_13);\n\t}\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \t\t}\n \t\tint j;\n \t\tint count = 0;\n-\t\tfor (j = 0; j < section->size; j += 8) {\n+\t\tfor (j = 0; j + 7 < section->size; j += 8) {\n \t\t\tut64 addr64 = K_RPTR (buf + j);\n \t\t\tut64 paddr64 = section->paddr + paddr + j;\n \t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tfor (j = 0; j < section->size; j += 8) {"
    ],
    "added_lines": [
      "\t\tfor (j = 0; j + 7 < section->size; j += 8) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/22355",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/22355: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/22355",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}