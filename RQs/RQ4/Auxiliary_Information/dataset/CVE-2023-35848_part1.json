{
  "cve_id": "CVE-2023-35848",
  "cwe_ids": [
    "CWE-682",
    "CWE-754"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "virtualsquare/picotcp",
  "commit_msg": "More checks for correct header sizes\n\nReported-by: \"P. Amsuo, Purdue University\"",
  "commit_hash": "4b9a16764f2b12b611de9c34a50b4713d10ca401",
  "git_url": "https://github.com/virtualsquare/picotcp/commit/4b9a16764f2b12b611de9c34a50b4713d10ca401",
  "file_path": "modules/pico_ipv4.c",
  "func_name": "pico_ipv4_process_in",
  "func_before": "static int pico_ipv4_process_in(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    uint8_t option_len = 0;\n    int ret = 0;\n    struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    uint16_t max_allowed = (uint16_t) ((int)f->buffer_len - (f->net_hdr - f->buffer) - (int)PICO_SIZE_IP4HDR);\n\n    if (!hdr)\n        return -1;\n\n    (void)self;\n\n    /* NAT needs transport header information */\n    if (((hdr->vhl) & 0x0F) > 5) {\n        option_len =  (uint8_t)(4 * (((hdr->vhl) & 0x0F) - 5));\n    }\n\n    f->transport_hdr = ((uint8_t *)f->net_hdr) + PICO_SIZE_IP4HDR + option_len;\n    f->transport_len = (uint16_t)(short_be(hdr->len) - PICO_SIZE_IP4HDR - option_len);\n    f->net_len = (uint16_t)(PICO_SIZE_IP4HDR + option_len);\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    f->frag = short_be(hdr->frag);\n#endif\n\n    if (f->transport_len > max_allowed) {\n        pico_frame_discard(f);\n        return 0; /* Packet is discarded due to unfeasible length */\n    }\n\n#ifdef PICO_SUPPORT_IPFILTER\n    if (ipfilter(f)) {\n        /*pico_frame is discarded as result of the filtering*/\n        return 0;\n    }\n\n#endif\n    /* ret == 1 indicates to continue the function */\n    ret = pico_ipv4_crc_check(f);\n    if (ret < 1)\n        return ret;\n\n    /* Validate source IP address. Discard quietly if invalid */\n    if (!pico_ipv4_is_valid_src(S, hdr->src.addr, f->dev)) {\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & PICO_IPV4_EVIL) {\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f); /* RFC 3514 */\n        return 0;\n    }\n#endif\n\n    if ((hdr->vhl & 0x0f) < 5) {\n        /* RFC 791: IHL minimum value is 5 */\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & (PICO_IPV4_MOREFRAG | PICO_IPV4_FRAG_MASK))\n    {\n#ifdef PICO_SUPPORT_IPV4FRAG\n        pico_ipv4_process_frag(hdr, f, hdr->proto);\n        /* Frame can be discarded, frag will handle its own copy */\n#endif\n        /* We do not support fragmentation, discard quietly */\n        pico_frame_discard(f);\n        return 0;\n    }\n#endif\n\n#ifdef PICO_SUPPORT_RAWSOCKETS\n    pico_socket_ipv4_process_in(f);\n#endif\n\n    if (pico_ipv4_process_bcast_in(S, f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_mcast_in(f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_local_unicast_in(S, f) > 0)\n        return 0;\n\n    pico_ipv4_process_finally_try_forward(S, f);\n\n    return 0;\n}",
  "abstract_func_before": "static int pico_ipv4_process_in(struct pico_stack *VAR_0, struct pico_protocol *VAR_1, struct pico_frame *VAR_2)\n{\n    uint8_t VAR_3 = 0;\n    int VAR_4 = 0;\n    struct pico_ipv4_hdr *VAR_5 = (struct pico_ipv4_hdr *) VAR_2->net_hdr;\n    uint16_t VAR_6 = (uint16_t) ((int)VAR_2->buffer_len - (VAR_2->net_hdr - VAR_2->buffer) - (int)VAR_7);\n\n    if (!VAR_5)\n        return -1;\n\n    (void)VAR_1;\n\n    /* COMMENT_0 */\n    if (((VAR_5->vhl) & 0x0F) > 5) {\n        VAR_3 =  (uint8_t)(4 * (((VAR_5->vhl) & 0x0F) - 5));\n    }\n\n    VAR_2->transport_hdr = ((uint8_t *)VAR_2->net_hdr) + VAR_7 + VAR_3;\n    VAR_2->transport_len = (uint16_t)(short_be(VAR_5->len) - VAR_7 - VAR_3);\n    VAR_2->net_len = (uint16_t)(VAR_7 + VAR_3);\n#if defined(VAR_8) || defined(VAR_9)\n    VAR_2->frag = short_be(VAR_5->frag);\n#endif\n\n    if (VAR_2->transport_len > VAR_6) {\n        pico_frame_discard(VAR_2);\n        return 0; /* COMMENT_1 */\n    }\n\n#ifdef VAR_10\n    if (ipfilter(VAR_2)) {\n        /* COMMENT_2 */\n        return 0;\n    }\n\n#endif\n    /* COMMENT_3 */\n    VAR_4 = pico_ipv4_crc_check(VAR_2);\n    if (VAR_4 < 1)\n        return VAR_4;\n\n    /* COMMENT_4 */\n    if (!pico_ipv4_is_valid_src(VAR_0, VAR_5->src.addr, VAR_2->dev)) {\n        pico_frame_discard(VAR_2);\n        return 0;\n    }\n\n#if defined(VAR_8) || defined(VAR_9)\n    if (VAR_2->frag & VAR_11) {\n        (void)pico_icmp4_param_problem(VAR_0, VAR_2, 0);\n        pico_frame_discard(VAR_2); /* COMMENT_5 */\n        return 0;\n    }\n#endif\n\n    if ((VAR_5->vhl & 0x0f) < 5) {\n        /* COMMENT_6 */\n        (void)pico_icmp4_param_problem(VAR_0, VAR_2, 0);\n        pico_frame_discard(VAR_2);\n        return 0;\n    }\n\n#if defined(VAR_8) || defined(VAR_9)\n    if (VAR_2->frag & (VAR_12 | VAR_13))\n    {\n#ifdef VAR_8\n        pico_ipv4_process_frag(VAR_5, VAR_2, VAR_5->proto);\n        /* COMMENT_7 */\n#endif\n        /* COMMENT_8 */\n        pico_frame_discard(VAR_2);\n        return 0;\n    }\n#endif\n\n#ifdef VAR_14\n    pico_socket_ipv4_process_in(VAR_2);\n#endif\n\n    if (pico_ipv4_process_bcast_in(VAR_0, VAR_2) > 0)\n        return 0;\n\n    if (pico_ipv4_process_mcast_in(VAR_2) > 0)\n        return 0;\n\n    if (pico_ipv4_process_local_unicast_in(VAR_0, VAR_2) > 0)\n        return 0;\n\n    pico_ipv4_process_finally_try_forward(VAR_0, VAR_2);\n\n    return 0;\n}",
  "func_graph_path_before": "virtualsquare/picotcp/4b9a16764f2b12b611de9c34a50b4713d10ca401/pico_ipv4.c/vul/before/0.json",
  "func": "static int pico_ipv4_process_in(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    uint8_t option_len = 0;\n    int ret = 0;\n    struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    uint16_t max_allowed = (uint16_t) ((int)f->buffer_len - (f->net_hdr - f->buffer) - (int)PICO_SIZE_IP4HDR);\n\n    if (!hdr)\n        return -1;\n\n    (void)self;\n\n    /* NAT needs transport header information */\n    if (((hdr->vhl) & 0x0F) > 5) {\n        option_len =  (uint8_t)(4 * (((hdr->vhl) & 0x0F) - 5));\n    }\n\n    f->transport_hdr = ((uint8_t *)f->net_hdr) + PICO_SIZE_IP4HDR + option_len;\n    f->transport_len = (uint16_t)(short_be(hdr->len) - PICO_SIZE_IP4HDR - option_len);\n    f->net_len = (uint16_t)(PICO_SIZE_IP4HDR + option_len);\n\n    if ((f->net_hdr + f->net_len) > (f->buffer + f->buffer_len)) {\n        pico_frame_discard(f);\n        return 0;\n    }\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    f->frag = short_be(hdr->frag);\n#endif\n\n    if (f->transport_len > max_allowed) {\n        pico_frame_discard(f);\n        return 0; /* Packet is discarded due to unfeasible length */\n    }\n\n#ifdef PICO_SUPPORT_IPFILTER\n    if (ipfilter(f)) {\n        /*pico_frame is discarded as result of the filtering*/\n        return 0;\n    }\n\n#endif\n    /* ret == 1 indicates to continue the function */\n    ret = pico_ipv4_crc_check(f);\n    if (ret < 1)\n        return ret;\n\n    /* Validate source IP address. Discard quietly if invalid */\n    if (!pico_ipv4_is_valid_src(S, hdr->src.addr, f->dev)) {\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & PICO_IPV4_EVIL) {\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f); /* RFC 3514 */\n        return 0;\n    }\n#endif\n\n    if ((hdr->vhl & 0x0f) < 5) {\n        /* RFC 791: IHL minimum value is 5 */\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & (PICO_IPV4_MOREFRAG | PICO_IPV4_FRAG_MASK))\n    {\n#ifdef PICO_SUPPORT_IPV4FRAG\n        pico_ipv4_process_frag(hdr, f, hdr->proto);\n        /* Frame can be discarded, frag will handle its own copy */\n#endif\n        /* We do not support fragmentation, discard quietly */\n        pico_frame_discard(f);\n        return 0;\n    }\n#endif\n\n#ifdef PICO_SUPPORT_RAWSOCKETS\n    pico_socket_ipv4_process_in(f);\n#endif\n\n    if (pico_ipv4_process_bcast_in(S, f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_mcast_in(f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_local_unicast_in(S, f) > 0)\n        return 0;\n\n    pico_ipv4_process_finally_try_forward(S, f);\n\n    return 0;\n}",
  "abstract_func": "static int pico_ipv4_process_in(struct pico_stack *VAR_0, struct pico_protocol *VAR_1, struct pico_frame *VAR_2)\n{\n    uint8_t VAR_3 = 0;\n    int VAR_4 = 0;\n    struct pico_ipv4_hdr *VAR_5 = (struct pico_ipv4_hdr *) VAR_2->net_hdr;\n    uint16_t VAR_6 = (uint16_t) ((int)VAR_2->buffer_len - (VAR_2->net_hdr - VAR_2->buffer) - (int)VAR_7);\n\n    if (!VAR_5)\n        return -1;\n\n    (void)VAR_1;\n\n    /* COMMENT_0 */\n    if (((VAR_5->vhl) & 0x0F) > 5) {\n        VAR_3 =  (uint8_t)(4 * (((VAR_5->vhl) & 0x0F) - 5));\n    }\n\n    VAR_2->transport_hdr = ((uint8_t *)VAR_2->net_hdr) + VAR_7 + VAR_3;\n    VAR_2->transport_len = (uint16_t)(short_be(VAR_5->len) - VAR_7 - VAR_3);\n    VAR_2->net_len = (uint16_t)(VAR_7 + VAR_3);\n\n    if ((VAR_2->net_hdr + VAR_2->net_len) > (VAR_2->buffer + VAR_2->buffer_len)) {\n        pico_frame_discard(VAR_2);\n        return 0;\n    }\n#if defined(VAR_8) || defined(VAR_9)\n    VAR_2->frag = short_be(VAR_5->frag);\n#endif\n\n    if (VAR_2->transport_len > VAR_6) {\n        pico_frame_discard(VAR_2);\n        return 0; /* COMMENT_1 */\n    }\n\n#ifdef VAR_10\n    if (ipfilter(VAR_2)) {\n        /* COMMENT_2 */\n        return 0;\n    }\n\n#endif\n    /* COMMENT_3 */\n    VAR_4 = pico_ipv4_crc_check(VAR_2);\n    if (VAR_4 < 1)\n        return VAR_4;\n\n    /* COMMENT_4 */\n    if (!pico_ipv4_is_valid_src(VAR_0, VAR_5->src.addr, VAR_2->dev)) {\n        pico_frame_discard(VAR_2);\n        return 0;\n    }\n\n#if defined(VAR_8) || defined(VAR_9)\n    if (VAR_2->frag & VAR_11) {\n        (void)pico_icmp4_param_problem(VAR_0, VAR_2, 0);\n        pico_frame_discard(VAR_2); /* COMMENT_5 */\n        return 0;\n    }\n#endif\n\n    if ((VAR_5->vhl & 0x0f) < 5) {\n        /* COMMENT_6 */\n        (void)pico_icmp4_param_problem(VAR_0, VAR_2, 0);\n        pico_frame_discard(VAR_2);\n        return 0;\n    }\n\n#if defined(VAR_8) || defined(VAR_9)\n    if (VAR_2->frag & (VAR_12 | VAR_13))\n    {\n#ifdef VAR_8\n        pico_ipv4_process_frag(VAR_5, VAR_2, VAR_5->proto);\n        /* COMMENT_7 */\n#endif\n        /* COMMENT_8 */\n        pico_frame_discard(VAR_2);\n        return 0;\n    }\n#endif\n\n#ifdef VAR_14\n    pico_socket_ipv4_process_in(VAR_2);\n#endif\n\n    if (pico_ipv4_process_bcast_in(VAR_0, VAR_2) > 0)\n        return 0;\n\n    if (pico_ipv4_process_mcast_in(VAR_2) > 0)\n        return 0;\n\n    if (pico_ipv4_process_local_unicast_in(VAR_0, VAR_2) > 0)\n        return 0;\n\n    pico_ipv4_process_finally_try_forward(VAR_0, VAR_2);\n\n    return 0;\n}",
  "func_graph_path": "virtualsquare/picotcp/4b9a16764f2b12b611de9c34a50b4713d10ca401/pico_ipv4.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,11 @@\n     f->transport_hdr = ((uint8_t *)f->net_hdr) + PICO_SIZE_IP4HDR + option_len;\n     f->transport_len = (uint16_t)(short_be(hdr->len) - PICO_SIZE_IP4HDR - option_len);\n     f->net_len = (uint16_t)(PICO_SIZE_IP4HDR + option_len);\n+\n+    if ((f->net_hdr + f->net_len) > (f->buffer + f->buffer_len)) {\n+        pico_frame_discard(f);\n+        return 0;\n+    }\n #if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n     f->frag = short_be(hdr->frag);\n #endif",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if ((f->net_hdr + f->net_len) > (f->buffer + f->buffer_len)) {",
      "        pico_frame_discard(f);",
      "        return 0;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/virtualsquare/picotcp/pull/15",
  "description": {
    "pr_info": {
      "title": "Various fixes on size calculation",
      "number": 15
    },
    "comment": [
      "- TCP: Fixed MSS size calculation, set lower MSS bound\r\n- TCP: Check options size before parsing MSS field\r\n- ipfilter: Check transport layer size before dereferencing port numbers\r\n- IPv4: Check transport layer size before calculating checksum",
      "There should be CVEs for these fixes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0  \n\nThe patch addresses buffer overflow risks by adding boundary checks, consistent with security fixes. High confidence due to clear alignment between commit message, code changes, and the described vulnerabilities."
}