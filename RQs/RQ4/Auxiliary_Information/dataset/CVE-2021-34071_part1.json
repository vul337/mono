{
  "cve_id": "CVE-2021-34071",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "justdan96/tsMuxer",
  "commit_msg": "[bug] heap buffer overflow when last byte of SEI = 0xFF (#425)\n\nFixes #423\r\nFixes #427\r\nFixes #430\r\nFixes #433",
  "commit_hash": "ea879f3b915baa4f9d145ce44229f7b3b1952c30",
  "git_url": "https://github.com/justdan96/tsMuxer/commit/ea879f3b915baa4f9d145ce44229f7b3b1952c30",
  "file_path": "tsMuxer/nalUnits.cpp",
  "func_name": "SEIUnit::removePicTimingSEI",
  "func_before": "int SEIUnit::removePicTimingSEI(SPSUnit& sps)\n{\n    uint8_t* nalEnd = m_nalBuffer + m_nalBufferLen;\n    uint8_t* curBuff = m_nalBuffer + 1;\n    uint8_t tmpBuffer[1024 * 4];\n    tmpBuffer[0] = m_nalBuffer[0];\n    int tmpBufferLen = 1;\n\n    while (curBuff < nalEnd)\n    {\n        int payloadType = 0;\n        for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++)\n        {\n            payloadType += 0xFF;\n            tmpBuffer[tmpBufferLen++] = 0xff;\n        }\n        if (curBuff >= nalEnd)\n            break;\n        payloadType += *curBuff++;\n        tmpBuffer[tmpBufferLen++] = payloadType;\n        if (curBuff >= nalEnd)\n            break;\n\n        int payloadSize = 0;\n        for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++)\n        {\n            payloadSize += 0xFF;\n            tmpBuffer[tmpBufferLen++] = 0xff;\n        }\n        if (curBuff >= nalEnd)\n            break;\n\n        payloadSize += *curBuff++;\n        tmpBuffer[tmpBufferLen++] = payloadSize;\n        if (curBuff >= nalEnd)\n            break;\n        if (payloadType == SEI_MSG_PIC_TIMING)\n        {\n            tmpBufferLen -= 2;  // skip this sei message\n        }\n        else if (payloadType == SEI_MSG_BUFFERING_PERIOD)\n        {\n            tmpBufferLen -= 2;  // skip this sei message\n        }\n        else\n        {\n            memcpy(tmpBuffer + tmpBufferLen, curBuff, payloadSize);\n            tmpBufferLen += payloadSize;\n        }\n        curBuff += payloadSize;\n    }\n    if (m_nalBufferLen < tmpBufferLen)\n    {\n        // assert(m_nalBufferLen < tmpBufferLen);\n        delete[] m_nalBuffer;\n        m_nalBuffer = new uint8_t[tmpBufferLen];\n    }\n    memcpy(m_nalBuffer, tmpBuffer, tmpBufferLen);\n    m_nalBufferLen = tmpBufferLen;\n    return tmpBufferLen;\n}",
  "abstract_func_before": "int SEIUnit::removePicTimingSEI(SPSUnit& VAR_0)\n{\n    uint8_t* VAR_1 = VAR_2 + VAR_3;\n    uint8_t* VAR_4 = VAR_2 + 1;\n    uint8_t VAR_5[1024 * 4];\n    VAR_5[0] = VAR_2[0];\n    int VAR_6 = 1;\n\n    while (VAR_4 < VAR_1)\n    {\n        int VAR_7 = 0;\n        for (; *VAR_4 == 0xFF && VAR_4 < VAR_1; VAR_4++)\n        {\n            VAR_7 += 0xFF;\n            VAR_5[VAR_6++] = 0xff;\n        }\n        if (VAR_4 >= VAR_1)\n            break;\n        VAR_7 += *VAR_4++;\n        VAR_5[VAR_6++] = VAR_7;\n        if (VAR_4 >= VAR_1)\n            break;\n\n        int VAR_8 = 0;\n        for (; *VAR_4 == 0xFF && VAR_4 < VAR_1; VAR_4++)\n        {\n            VAR_8 += 0xFF;\n            VAR_5[VAR_6++] = 0xff;\n        }\n        if (VAR_4 >= VAR_1)\n            break;\n\n        VAR_8 += *VAR_4++;\n        VAR_5[VAR_6++] = VAR_8;\n        if (VAR_4 >= VAR_1)\n            break;\n        if (VAR_7 == VAR_9)\n        {\n            VAR_6 -= 2;  /* COMMENT_0 */\n        }\n        else if (VAR_7 == VAR_10)\n        {\n            VAR_6 -= 2;  /* COMMENT_0 */\n        }\n        else\n        {\n            memcpy(VAR_5 + VAR_6, VAR_4, VAR_8);\n            VAR_6 += VAR_8;\n        }\n        VAR_4 += VAR_8;\n    }\n    if (VAR_3 < VAR_6)\n    {\n        /* COMMENT_1 */\n        delete[] VAR_2;\n        VAR_2 = new uint8_t[VAR_6];\n    }\n    memcpy(VAR_2, VAR_5, VAR_6);\n    VAR_3 = VAR_6;\n    return VAR_6;\n}",
  "func_graph_path_before": "justdan96/tsMuxer/ea879f3b915baa4f9d145ce44229f7b3b1952c30/nalUnits.cpp/vul/before/0.json",
  "func": "int SEIUnit::removePicTimingSEI(SPSUnit& sps)\n{\n    uint8_t* nalEnd = m_nalBuffer + m_nalBufferLen;\n    uint8_t* curBuff = m_nalBuffer + 1;\n    uint8_t tmpBuffer[1024 * 4];\n    tmpBuffer[0] = m_nalBuffer[0];\n    int tmpBufferLen = 1;\n\n    while (curBuff < nalEnd)\n    {\n        int payloadType = 0;\n        for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++)\n        {\n            payloadType += 0xFF;\n            tmpBuffer[tmpBufferLen++] = 0xff;\n        }\n        if (curBuff >= nalEnd)\n            break;\n        payloadType += *curBuff++;\n        tmpBuffer[tmpBufferLen++] = payloadType;\n        if (curBuff >= nalEnd)\n            break;\n\n        int payloadSize = 0;\n        for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++)\n        {\n            payloadSize += 0xFF;\n            tmpBuffer[tmpBufferLen++] = 0xff;\n        }\n        if (curBuff >= nalEnd)\n            break;\n\n        payloadSize += *curBuff++;\n        tmpBuffer[tmpBufferLen++] = payloadSize;\n        if (curBuff >= nalEnd)\n            break;\n        if (payloadType == SEI_MSG_PIC_TIMING)\n        {\n            tmpBufferLen -= 2;  // skip this sei message\n        }\n        else if (payloadType == SEI_MSG_BUFFERING_PERIOD)\n        {\n            tmpBufferLen -= 2;  // skip this sei message\n        }\n        else\n        {\n            memcpy(tmpBuffer + tmpBufferLen, curBuff, payloadSize);\n            tmpBufferLen += payloadSize;\n        }\n        curBuff += payloadSize;\n    }\n    if (m_nalBufferLen < tmpBufferLen)\n    {\n        // assert(m_nalBufferLen < tmpBufferLen);\n        delete[] m_nalBuffer;\n        m_nalBuffer = new uint8_t[tmpBufferLen];\n    }\n    memcpy(m_nalBuffer, tmpBuffer, tmpBufferLen);\n    m_nalBufferLen = tmpBufferLen;\n    return tmpBufferLen;\n}",
  "abstract_func": "int SEIUnit::removePicTimingSEI(SPSUnit& VAR_0)\n{\n    uint8_t* VAR_1 = VAR_2 + VAR_3;\n    uint8_t* VAR_4 = VAR_2 + 1;\n    uint8_t VAR_5[1024 * 4];\n    VAR_5[0] = VAR_2[0];\n    int VAR_6 = 1;\n\n    while (VAR_4 < VAR_1)\n    {\n        int VAR_7 = 0;\n        for (; VAR_4 < VAR_1 && *VAR_4 == 0xFF; VAR_4++)\n        {\n            VAR_7 += 0xFF;\n            VAR_5[VAR_6++] = 0xff;\n        }\n        if (VAR_4 >= VAR_1)\n            break;\n        VAR_7 += *VAR_4++;\n        VAR_5[VAR_6++] = VAR_7;\n        if (VAR_4 >= VAR_1)\n            break;\n\n        int VAR_8 = 0;\n        for (; VAR_4 < VAR_1 && *VAR_4 == 0xFF; VAR_4++)\n        {\n            VAR_8 += 0xFF;\n            VAR_5[VAR_6++] = 0xff;\n        }\n        if (VAR_4 >= VAR_1)\n            break;\n\n        VAR_8 += *VAR_4++;\n        VAR_5[VAR_6++] = VAR_8;\n        if (VAR_4 >= VAR_1)\n            break;\n        if (VAR_7 == VAR_9)\n        {\n            VAR_6 -= 2;  /* COMMENT_0 */\n        }\n        else if (VAR_7 == VAR_10)\n        {\n            VAR_6 -= 2;  /* COMMENT_0 */\n        }\n        else\n        {\n            memcpy(VAR_5 + VAR_6, VAR_4, VAR_8);\n            VAR_6 += VAR_8;\n        }\n        VAR_4 += VAR_8;\n    }\n    if (VAR_3 < VAR_6)\n    {\n        /* COMMENT_1 */\n        delete[] VAR_2;\n        VAR_2 = new uint8_t[VAR_6];\n    }\n    memcpy(VAR_2, VAR_5, VAR_6);\n    VAR_3 = VAR_6;\n    return VAR_6;\n}",
  "func_graph_path": "justdan96/tsMuxer/ea879f3b915baa4f9d145ce44229f7b3b1952c30/nalUnits.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n     while (curBuff < nalEnd)\n     {\n         int payloadType = 0;\n-        for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++)\n+        for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++)\n         {\n             payloadType += 0xFF;\n             tmpBuffer[tmpBufferLen++] = 0xff;\n@@ -22,7 +22,7 @@\n             break;\n \n         int payloadSize = 0;\n-        for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++)\n+        for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++)\n         {\n             payloadSize += 0xFF;\n             tmpBuffer[tmpBufferLen++] = 0xff;",
  "diff_line_info": {
    "deleted_lines": [
      "        for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++)",
      "        for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++)"
    ],
    "added_lines": [
      "        for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++)",
      "        for (; curBuff < nalEnd && *curBuff == 0xFF; curBuff++)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/justdan96/tsMuxer/pull/425",
  "description": {
    "pr_info": {
      "title": "[bug] heap buffer overflow when last byte of SEI = 0xFF",
      "number": 425
    },
    "comment": [
      "In the for loop, checking that `curBuff < nalEnd` must occur before checking that `*curBuff == 0xFF`\r\n\r\nFixes issues #423, #427, #430 and #433."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\nThe patch addresses a heap buffer overflow, a known security issue, by correcting the order of checks in loop conditions. The changes are consistent with the commit message and effectively mitigate the vulnerability, leading to a high confidence in the classification. \n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}