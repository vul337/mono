{
  "cve_id": "CVE-2022-21656",
  "cwe_ids": [
    "CWE-843"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Specify type for matching Subject Alternative Name. (#18628)\n\n\r\nSigned-off-by: Pradeep Rao <pcrao@google.com>",
  "commit_hash": "bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "file_path": "source/extensions/transport_sockets/tls/cert_validator/default_validator.cc",
  "func_name": "DefaultCertValidator::doVerifyCertChain",
  "func_before": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n\n  // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n  // sure the verification for other validation context configurations doesn't fail (i.e. either\n  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure other\n  // configurations are verified and the verification succeed.\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}",
  "abstract_func_before": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* VAR_0, Ssl::SslExtendedSocketInfo* VAR_1, X509& VAR_2,\n    const Network::TransportSocketOptions* VAR_3) {\n  if (VAR_4) {\n    int VAR_5 = X509_verify_cert(VAR_0);\n    if (VAR_1) {\n      VAR_1->setCertificateValidationStatus(\n          VAR_5 == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (VAR_5 <= 0) {\n      VAR_6.fail_verify_error_.inc();\n      ENVOY_LOG(VAR_7, \"{}\", Utility::getX509VerificationErrorInfo(VAR_0));\n      return VAR_8 ? 1 : VAR_5;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus VAR_9 =\n      verifyCertificate(&VAR_2,\n                        VAR_3 != nullptr\n                            ? VAR_3->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        VAR_10);\n\n  if (VAR_1) {\n    if (VAR_1->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      VAR_1->setCertificateValidationStatus(VAR_9);\n    } else if (VAR_9 != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      VAR_1->setCertificateValidationStatus(VAR_9);\n    }\n  }\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  int VAR_11 = VAR_4\n                              ? VAR_9 != Envoy::Ssl::ClientValidationStatus::Failed\n                              : VAR_9 == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return VAR_8 ? 1 : VAR_11;\n}",
  "func_graph_path_before": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/default_validator.cc/vul/before/3.json",
  "func": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n\n  // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n  // sure the verification for other validation context configurations doesn't fail (i.e. either\n  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure\n  // other configurations are verified and the verification succeed.\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}",
  "abstract_func": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* VAR_0, Ssl::SslExtendedSocketInfo* VAR_1, X509& VAR_2,\n    const Network::TransportSocketOptions* VAR_3) {\n  if (VAR_4) {\n    int VAR_5 = X509_verify_cert(VAR_0);\n    if (VAR_1) {\n      VAR_1->setCertificateValidationStatus(\n          VAR_5 == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (VAR_5 <= 0) {\n      VAR_6.fail_verify_error_.inc();\n      ENVOY_LOG(VAR_7, \"{}\", Utility::getX509VerificationErrorInfo(VAR_0));\n      return VAR_8 ? 1 : VAR_5;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus VAR_9 =\n      verifyCertificate(&VAR_2,\n                        VAR_3 != nullptr\n                            ? VAR_3->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        VAR_10);\n\n  if (VAR_1) {\n    if (VAR_1->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      VAR_1->setCertificateValidationStatus(VAR_9);\n    } else if (VAR_9 != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      VAR_1->setCertificateValidationStatus(VAR_9);\n    }\n  }\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  int VAR_11 = VAR_4\n                              ? VAR_9 != Envoy::Ssl::ClientValidationStatus::Failed\n                              : VAR_9 == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return VAR_8 ? 1 : VAR_11;\n}",
  "func_graph_path": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/default_validator.cc/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -34,8 +34,8 @@\n \n   // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n   // sure the verification for other validation context configurations doesn't fail (i.e. either\n-  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure other\n-  // configurations are verified and the verification succeed.\n+  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure\n+  // other configurations are verified and the verification succeed.\n   int validation_status = verify_trusted_ca_\n                               ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                               : validated == Envoy::Ssl::ClientValidationStatus::Validated;",
  "diff_line_info": {
    "deleted_lines": [
      "  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure other",
      "  // configurations are verified and the verification succeed."
    ],
    "added_lines": [
      "  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure",
      "  // other configurations are verified and the verification succeed."
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/18628",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/envoyproxy/envoy/pull/18628: 403 Client Error: Forbidden for url: https://api.github.com/repos/envoyproxy/envoy/pulls/18628",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "The patch addresses a change in certificate validation logic, which is a security-related task. However, the absence of explicit security terms in the commit message and description introduces some uncertainty.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.7\n\nThe confidence is moderately high because the code changes pertain to certificate validation, a security aspect, but the lack of explicit security mentions in the messages reduces the certainty."
}