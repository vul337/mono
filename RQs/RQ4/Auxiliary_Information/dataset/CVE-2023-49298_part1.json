{
  "cve_id": "CVE-2023-49298",
  "cwe_ids": [
    "CWE-639"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "openzfs/zfs",
  "commit_msg": "dnode_is_dirty: check dnode and its data for dirtiness\n\nOver its history this the dirty dnode test has been changed between\nchecking for a dnodes being on `os_dirty_dnodes` (`dn_dirty_link`) and\n`dn_dirty_record`.\n\n  de198f2d9 Fix lseek(SEEK_DATA/SEEK_HOLE) mmap consistency\n  2531ce372 Revert \"Report holes when there are only metadata changes\"\n  ec4f9b8f3 Report holes when there are only metadata changes\n  454365bba Fix dirty check in dmu_offset_next()\n  66aca2473 SEEK_HOLE should not block on txg_wait_synced()\n\nAlso illumos/illumos-gate@c543ec060d illumos/illumos-gate@2bcf0248e9\n\nIt turns out both are actually required.\n\nIn the case of appending data to a newly created file, the dnode proper\nis dirtied (at least to change the blocksize) and dirty records are\nadded.  Thus, a single logical operation is represented by separate\ndirty indicators, and must not be separated.\n\nThe incorrect dirty check becomes a problem when the first block of a\nfile is being appended to while another process is calling lseek to skip\nholes. There is a small window where the dnode part is undirtied while\nthere are still dirty records. In this case, `lseek(fd, 0, SEEK_DATA)`\nwould not know that the file is dirty, and would go to\n`dnode_next_offset()`. Since the object has no data blocks yet, it\nreturns `ESRCH`, indicating no data found, which results in `ENXIO`\nbeing returned to `lseek()`'s caller.\n\nSince coreutils 9.2, `cp` performs sparse copies by default, that is, it\nuses `SEEK_DATA` and `SEEK_HOLE` against the source file and attempts to\nreplicate the holes in the target. When it hits the bug, its initial\nsearch for data fails, and it goes on to call `fallocate()` to create a\nhole over the entire destination file.\n\nThis has come up more recently as users upgrade their systems, getting\nOpenZFS 2.2 as well as a newer coreutils. However, this problem has been\nreproduced against 2.1, as well as on FreeBSD 13 and 14.\n\nThis change simply updates the dirty check to check both types of dirty.\nIf there's anything dirty at all, we immediately go to the \"wait for\nsync\" stage, It doesn't really matter after that; both changes are on\ndisk, so the dirty fields should be correct.\n\nSigned-off-by: Rob Norris <rob.norris@klarasystems.com>\nSponsored-by: Klara, Inc.\nSponsored-by: Wasabi Technology, Inc.",
  "commit_hash": "c7fadf230f26be750feddaebda95e5cc66896107",
  "git_url": "https://github.com/openzfs/zfs/commit/c7fadf230f26be750feddaebda95e5cc66896107",
  "file_path": "module/zfs/dnode.c",
  "func_name": "dnode_is_dirty",
  "func_before": "boolean_t\ndnode_is_dirty(dnode_t *dn)\n{\n\tmutex_enter(&dn->dn_mtx);\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tif (multilist_link_active(&dn->dn_dirty_link[i])) {\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tmutex_exit(&dn->dn_mtx);\n\n\treturn (B_FALSE);\n}",
  "abstract_func_before": "boolean_t\ndnode_is_dirty(dnode_t *VAR_0)\n{\n\tmutex_enter(&VAR_0->dn_mtx);\n\n\tfor (int VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {\n\t\tif (multilist_link_active(&VAR_0->dn_dirty_link[VAR_1])) {\n\t\t\tmutex_exit(&VAR_0->dn_mtx);\n\t\t\treturn (VAR_3);\n\t\t}\n\t}\n\n\tmutex_exit(&VAR_0->dn_mtx);\n\n\treturn (VAR_4);\n}",
  "func_graph_path_before": "openzfs/zfs/c7fadf230f26be750feddaebda95e5cc66896107/dnode.c/vul/before/0.json",
  "func": "boolean_t\ndnode_is_dirty(dnode_t *dn)\n{\n\tmutex_enter(&dn->dn_mtx);\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tif (multilist_link_active(&dn->dn_dirty_link[i]) ||\n\t\t    !list_is_empty(&dn->dn_dirty_records[i])) {\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tmutex_exit(&dn->dn_mtx);\n\n\treturn (B_FALSE);\n}",
  "abstract_func": "boolean_t\ndnode_is_dirty(dnode_t *VAR_0)\n{\n\tmutex_enter(&VAR_0->dn_mtx);\n\n\tfor (int VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {\n\t\tif (multilist_link_active(&VAR_0->dn_dirty_link[VAR_1]) ||\n\t\t    !list_is_empty(&VAR_0->dn_dirty_records[VAR_1])) {\n\t\t\tmutex_exit(&VAR_0->dn_mtx);\n\t\t\treturn (VAR_3);\n\t\t}\n\t}\n\n\tmutex_exit(&VAR_0->dn_mtx);\n\n\treturn (VAR_4);\n}",
  "func_graph_path": "openzfs/zfs/c7fadf230f26be750feddaebda95e5cc66896107/dnode.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,8 @@\n \tmutex_enter(&dn->dn_mtx);\n \n \tfor (int i = 0; i < TXG_SIZE; i++) {\n-\t\tif (multilist_link_active(&dn->dn_dirty_link[i])) {\n+\t\tif (multilist_link_active(&dn->dn_dirty_link[i]) ||\n+\t\t    !list_is_empty(&dn->dn_dirty_records[i])) {\n \t\t\tmutex_exit(&dn->dn_mtx);\n \t\t\treturn (B_TRUE);\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tif (multilist_link_active(&dn->dn_dirty_link[i])) {"
    ],
    "added_lines": [
      "\t\tif (multilist_link_active(&dn->dn_dirty_link[i]) ||",
      "\t\t    !list_is_empty(&dn->dn_dirty_records[i])) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openzfs/zfs/pull/15571",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/openzfs/zfs/pull/15571: 403 Client Error: Forbidden for url: https://api.github.com/repos/openzfs/zfs/pulls/15571",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses a bug in the `dnode_is_dirty` function to correctly handle both types of dirtiness, preventing incorrect `lseek` behavior. This is a core bug fix, not a security issue. \n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.95"
}