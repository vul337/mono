{
  "cve_id": "CVE-2023-1523",
  "cwe_ids": [
    "CWE-74"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "snapcore/snapd",
  "commit_msg": "snap-seccomp-blacklist: also disallow the use of ioctl + TIOCLINUX\n\nFixes CVE-2023-1523\n\nSigned-off-by: Alex Murray <alex.murray@canonical.com>",
  "commit_hash": "997dbfd5327d6e429f63ae7adc2bf2b31f070931",
  "git_url": "https://github.com/snapcore/snapd/commit/997dbfd5327d6e429f63ae7adc2bf2b31f070931",
  "file_path": "cmd/snap-seccomp-blacklist/snap-seccomp-blacklist.c",
  "func_name": "populate_filter",
  "func_before": "static int populate_filter(scmp_filter_ctx ctx, const uint32_t *arch_tags, size_t num_arch_tags) {\n    int sc_err;\n\n    /* If the native architecture is not one of the supported 64bit\n     * architectures listed in main in le_arch_tags and be_arch_tags, then\n     * remove it.\n     *\n     * Libseccomp automatically adds the native architecture to each new filter.\n     * If the native architecture is a 32bit-one then we will hit a bug in libseccomp\n     * and the generated BPF program is incorrect as described below. */\n    uint32_t native_arch = seccomp_arch_native();\n    bool remove_native_arch = true;\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        if (arch_tags[i] == native_arch) {\n            remove_native_arch = false;\n            break;\n        }\n    }\n    if (remove_native_arch) {\n        sc_err = seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE);\n        if (sc_err < 0) {\n            showerr(\"cannot remove native architecture\");\n            return sc_err;\n        }\n    }\n\n    /* Add 64-bit architectures supported by snapd into the seccomp filter.\n     *\n     * The documentation of seccomp_arch_add() is confusing. It says that after\n     * this call any new rules will be added to this architecture. This is\n     * correct. It doesn't, however, explain that the rules will be multiplied\n     * and re-written as explained below. */\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        uint32_t arch_tag = arch_tags[i];\n        sc_err = seccomp_arch_add(ctx, arch_tag);\n        if (sc_err < 0 && sc_err != -EEXIST) {\n            showerr(\"cannot add architecture %x\", arch_tag);\n            return sc_err;\n        }\n    }\n\n    /* When the rule set doesn't match one of the architectures above then the\n     * resulting action should be a \"allow\" rather than \"kill\". We don't add\n     * any of the 32bit architectures since there is no need for any extra\n     * filtering there. */\n    sc_err = seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ALLOW);\n    if (sc_err < 0) {\n        showerr(\"cannot set action for unknown architectures\");\n        return sc_err;\n    }\n\n    /* Resolve the name of \"ioctl\" on this architecture. We are not using the\n     * system call number as available through the appropriate linux-specific\n     * header. This allows us to use a system call number that is not defined\n     * for the current architecture. This does not matter here, in this\n     * specific program, however it is more generic. In addition this is more\n     * in sync with the snap-seccomp program, which does the same for every\n     * system call. */\n    int sys_ioctl_nr;\n    sys_ioctl_nr = seccomp_syscall_resolve_name(\"ioctl\");\n    if (sys_ioctl_nr == __NR_SCMP_ERROR) {\n        showerr(\"cannot resolve ioctl system call number\");\n        return -ESRCH;\n    }\n\n    /* All of the rules must be added for the native architecture (using native\n     * system call numbers). When the final program is generated the set of\n     * architectures added earlier will be used to determine the correct system\n     * call number for each architecture.\n     *\n     * In other words, arguments to scmp_rule_add() must always use native\n     * system call numbers. Translation for the correct architecture will be\n     * performed internally. This is not documented in libseccomp, but correct\n     * operation was confirmed using the pseudo-code program and the bpf_dbg\n     * tool from the kernel tools/bpf directory.\n     *\n     * NOTE: not using scmp_rule_add_exact as that was not doing anything\n     * at all (presumably due to having all the architectures defined). */\n\n    const struct scmp_arg_cmp no_tty_inject = {\n        /* We learned that existing programs make legitimate requests with all\n         * bits set in the more significant 32bit word of the 64 bit double\n         * word. While this kernel behavior remains suspect and presumably\n         * undesired it is unlikely to change for backwards compatibility\n         * reasons. As such we cannot block all requests with high-bits set.\n         *\n         * When faced with ioctl(fd, request); refuse to proceed when\n         * request&0xffffffff == TIOCSTI. This specific way to encode the\n         * filter has the following important properties:\n         *\n         * - it blocks ioctl(fd, TIOCSTI, ptr).\n         * - it also blocks ioctl(fd, (1UL<<32) | TIOCSTI, ptr).\n         * - it doesn't block ioctl(fd, (1UL<<32) | (request not equal to TIOCSTI), ptr); */\n        .arg = 1,\n        .op = SCMP_CMP_MASKED_EQ,\n        .datum_a = 0xffffffffUL,\n        .datum_b = TIOCSTI,\n    };\n    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n\n    if (sc_err < 0) {\n        showerr(\"cannot add rule preventing the use high bits in ioctl\");\n        return sc_err;\n    }\n    return 0;\n}",
  "abstract_func_before": "static int populate_filter(scmp_filter_ctx VAR_0, const uint32_t *VAR_1, size_t VAR_2) {\n    int VAR_3;\n\n    /* COMMENT_0 */\n                                                                          \n                 \n      \n                                                                                \n                                                                                     \n                                                                        \n    uint32_t VAR_4 = seccomp_arch_native();\n    bool VAR_5 = true;\n    for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {\n        if (VAR_1[VAR_6] == VAR_4) {\n            VAR_5 = false;\n            break;\n        }\n    }\n    if (VAR_5) {\n        VAR_3 = seccomp_arch_remove(VAR_0, VAR_7);\n        if (VAR_3 < 0) {\n            showerr(\"cannot remove native architecture\");\n            return VAR_3;\n        }\n    }\n\n    /* COMMENT_7 */\n      \n                                                                               \n                                                                          \n                                                                              \n                                            \n    for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {\n        uint32_t VAR_8 = VAR_1[VAR_6];\n        VAR_3 = seccomp_arch_add(VAR_0, VAR_8);\n        if (VAR_3 < 0 && VAR_3 != -VAR_9) {\n            showerr(\"cannot add architecture %x\", VAR_8);\n            return VAR_3;\n        }\n    }\n\n    /* COMMENT_13 */\n                                                                            \n                                                                          \n                          \n    VAR_3 = seccomp_attr_set(VAR_0, VAR_10, VAR_11);\n    if (VAR_3 < 0) {\n        showerr(\"cannot set action for unknown architectures\");\n        return VAR_3;\n    }\n\n    /* COMMENT_17 */\n                                                                             \n                                                                             \n                                                                       \n                                                                             \n                                                                           \n                      \n    int VAR_12;\n    VAR_12 = seccomp_syscall_resolve_name(\"ioctl\");\n    if (VAR_12 == VAR_13) {\n        showerr(\"cannot resolve ioctl system call number\");\n        return -VAR_14;\n    }\n\n    /* COMMENT_24 */\n                                                                           \n                                                                               \n                                         \n      \n                                                                          \n                                                                            \n                                                                              \n                                                                            \n                                                \n      \n                                                                         \n                                                                          \n\n    const struct scmp_arg_cmp VAR_15 = {\n        /* COMMENT_36 */\n                                                                           \n                                                                          \n                                                                         \n                                                                            \n          \n                                                                     \n                                                                         \n                                                         \n          \n                                               \n                                                                \n                                                                                            \n        .arg = 1,\n        .op = VAR_16,\n        .datum_a = 0xffffffffUL,\n        .datum_b = VAR_17,\n    };\n    VAR_3 = seccomp_rule_add(VAR_0, SCMP_ACT_ERRNO(VAR_18), VAR_12, 1, VAR_15);\n\n    if (VAR_3 < 0) {\n        showerr(\"cannot add rule preventing the use high bits in ioctl\");\n        return VAR_3;\n    }\n    return 0;\n}",
  "func_graph_path_before": "snapcore/snapd/997dbfd5327d6e429f63ae7adc2bf2b31f070931/snap-seccomp-blacklist.c/vul/before/0.json",
  "func": "static int populate_filter(scmp_filter_ctx ctx, const uint32_t *arch_tags, size_t num_arch_tags) {\n    int sc_err;\n\n    /* If the native architecture is not one of the supported 64bit\n     * architectures listed in main in le_arch_tags and be_arch_tags, then\n     * remove it.\n     *\n     * Libseccomp automatically adds the native architecture to each new filter.\n     * If the native architecture is a 32bit-one then we will hit a bug in libseccomp\n     * and the generated BPF program is incorrect as described below. */\n    uint32_t native_arch = seccomp_arch_native();\n    bool remove_native_arch = true;\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        if (arch_tags[i] == native_arch) {\n            remove_native_arch = false;\n            break;\n        }\n    }\n    if (remove_native_arch) {\n        sc_err = seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE);\n        if (sc_err < 0) {\n            showerr(\"cannot remove native architecture\");\n            return sc_err;\n        }\n    }\n\n    /* Add 64-bit architectures supported by snapd into the seccomp filter.\n     *\n     * The documentation of seccomp_arch_add() is confusing. It says that after\n     * this call any new rules will be added to this architecture. This is\n     * correct. It doesn't, however, explain that the rules will be multiplied\n     * and re-written as explained below. */\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        uint32_t arch_tag = arch_tags[i];\n        sc_err = seccomp_arch_add(ctx, arch_tag);\n        if (sc_err < 0 && sc_err != -EEXIST) {\n            showerr(\"cannot add architecture %x\", arch_tag);\n            return sc_err;\n        }\n    }\n\n    /* When the rule set doesn't match one of the architectures above then the\n     * resulting action should be a \"allow\" rather than \"kill\". We don't add\n     * any of the 32bit architectures since there is no need for any extra\n     * filtering there. */\n    sc_err = seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ALLOW);\n    if (sc_err < 0) {\n        showerr(\"cannot set action for unknown architectures\");\n        return sc_err;\n    }\n\n    /* Resolve the name of \"ioctl\" on this architecture. We are not using the\n     * system call number as available through the appropriate linux-specific\n     * header. This allows us to use a system call number that is not defined\n     * for the current architecture. This does not matter here, in this\n     * specific program, however it is more generic. In addition this is more\n     * in sync with the snap-seccomp program, which does the same for every\n     * system call. */\n    int sys_ioctl_nr;\n    sys_ioctl_nr = seccomp_syscall_resolve_name(\"ioctl\");\n    if (sys_ioctl_nr == __NR_SCMP_ERROR) {\n        showerr(\"cannot resolve ioctl system call number\");\n        return -ESRCH;\n    }\n\n    /* All of the rules must be added for the native architecture (using native\n     * system call numbers). When the final program is generated the set of\n     * architectures added earlier will be used to determine the correct system\n     * call number for each architecture.\n     *\n     * In other words, arguments to scmp_rule_add() must always use native\n     * system call numbers. Translation for the correct architecture will be\n     * performed internally. This is not documented in libseccomp, but correct\n     * operation was confirmed using the pseudo-code program and the bpf_dbg\n     * tool from the kernel tools/bpf directory.\n     *\n     * NOTE: not using scmp_rule_add_exact as that was not doing anything\n     * at all (presumably due to having all the architectures defined). */\n\n    struct scmp_arg_cmp no_tty_inject = {\n        /* We learned that existing programs make legitimate requests with all\n         * bits set in the more significant 32bit word of the 64 bit double\n         * word. While this kernel behavior remains suspect and presumably\n         * undesired it is unlikely to change for backwards compatibility\n         * reasons. As such we cannot block all requests with high-bits set.\n         *\n         * When faced with ioctl(fd, request); refuse to proceed when\n         * request&0xffffffff == TIOCSTI. This specific way to encode the\n         * filter has the following important properties:\n         *\n         * - it blocks ioctl(fd, TIOCSTI, ptr).\n         * - it also blocks ioctl(fd, (1UL<<32) | TIOCSTI, ptr).\n         * - it doesn't block ioctl(fd, (1UL<<32) | (request not equal to TIOCSTI), ptr); */\n        .arg = 1,\n        .op = SCMP_CMP_MASKED_EQ,\n        .datum_a = 0xffffffffUL,\n        .datum_b = TIOCSTI,\n    };\n    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n\n    /* also block use of TIOCLINUX */\n    no_tty_inject.datum_b = TIOCLINUX;\n    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n\n    if (sc_err < 0) {\n        showerr(\"cannot add rule preventing the use high bits in ioctl\");\n        return sc_err;\n    }\n    return 0;\n}",
  "abstract_func": "static int populate_filter(scmp_filter_ctx VAR_0, const uint32_t *VAR_1, size_t VAR_2) {\n    int VAR_3;\n\n    /* COMMENT_0 */\n                                                                          \n                 \n      \n                                                                                \n                                                                                     \n                                                                        \n    uint32_t VAR_4 = seccomp_arch_native();\n    bool VAR_5 = true;\n    for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {\n        if (VAR_1[VAR_6] == VAR_4) {\n            VAR_5 = false;\n            break;\n        }\n    }\n    if (VAR_5) {\n        VAR_3 = seccomp_arch_remove(VAR_0, VAR_7);\n        if (VAR_3 < 0) {\n            showerr(\"cannot remove native architecture\");\n            return VAR_3;\n        }\n    }\n\n    /* COMMENT_7 */\n      \n                                                                               \n                                                                          \n                                                                              \n                                            \n    for (size_t VAR_6 = 0; VAR_6 < VAR_2; ++VAR_6) {\n        uint32_t VAR_8 = VAR_1[VAR_6];\n        VAR_3 = seccomp_arch_add(VAR_0, VAR_8);\n        if (VAR_3 < 0 && VAR_3 != -VAR_9) {\n            showerr(\"cannot add architecture %x\", VAR_8);\n            return VAR_3;\n        }\n    }\n\n    /* COMMENT_13 */\n                                                                            \n                                                                          \n                          \n    VAR_3 = seccomp_attr_set(VAR_0, VAR_10, VAR_11);\n    if (VAR_3 < 0) {\n        showerr(\"cannot set action for unknown architectures\");\n        return VAR_3;\n    }\n\n    /* COMMENT_17 */\n                                                                             \n                                                                             \n                                                                       \n                                                                             \n                                                                           \n                      \n    int VAR_12;\n    VAR_12 = seccomp_syscall_resolve_name(\"ioctl\");\n    if (VAR_12 == VAR_13) {\n        showerr(\"cannot resolve ioctl system call number\");\n        return -VAR_14;\n    }\n\n    /* COMMENT_24 */\n                                                                           \n                                                                               \n                                         \n      \n                                                                          \n                                                                            \n                                                                              \n                                                                            \n                                                \n      \n                                                                         \n                                                                          \n\n    struct scmp_arg_cmp VAR_15 = {\n        /* COMMENT_36 */\n                                                                           \n                                                                          \n                                                                         \n                                                                            \n          \n                                                                     \n                                                                         \n                                                         \n          \n                                               \n                                                                \n                                                                                            \n        .arg = 1,\n        .op = VAR_16,\n        .datum_a = 0xffffffffUL,\n        .datum_b = VAR_17,\n    };\n    VAR_3 = seccomp_rule_add(VAR_0, SCMP_ACT_ERRNO(VAR_18), VAR_12, 1, VAR_15);\n\n    /* COMMENT_48 */\n    VAR_15.datum_b = VAR_19;\n    VAR_3 = seccomp_rule_add(VAR_0, SCMP_ACT_ERRNO(VAR_18), VAR_12, 1, VAR_15);\n\n    if (VAR_3 < 0) {\n        showerr(\"cannot add rule preventing the use high bits in ioctl\");\n        return VAR_3;\n    }\n    return 0;\n}",
  "func_graph_path": "snapcore/snapd/997dbfd5327d6e429f63ae7adc2bf2b31f070931/snap-seccomp-blacklist.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -77,7 +77,7 @@\n      * NOTE: not using scmp_rule_add_exact as that was not doing anything\n      * at all (presumably due to having all the architectures defined). */\n \n-    const struct scmp_arg_cmp no_tty_inject = {\n+    struct scmp_arg_cmp no_tty_inject = {\n         /* We learned that existing programs make legitimate requests with all\n          * bits set in the more significant 32bit word of the 64 bit double\n          * word. While this kernel behavior remains suspect and presumably\n@@ -98,6 +98,10 @@\n     };\n     sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n \n+    /* also block use of TIOCLINUX */\n+    no_tty_inject.datum_b = TIOCLINUX;\n+    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n+\n     if (sc_err < 0) {\n         showerr(\"cannot add rule preventing the use high bits in ioctl\");\n         return sc_err;",
  "diff_line_info": {
    "deleted_lines": [
      "    const struct scmp_arg_cmp no_tty_inject = {"
    ],
    "added_lines": [
      "    struct scmp_arg_cmp no_tty_inject = {",
      "    /* also block use of TIOCLINUX */",
      "    no_tty_inject.datum_b = TIOCLINUX;",
      "    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/canonical/snapd/pull/12849",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/canonical/snapd/pull/12849: 403 Client Error: Forbidden for url: https://api.github.com/repos/canonical/snapd/pulls/12849",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\n**Rationale:**  \nThe commit addresses CVE-2023-1523 by modifying the seccomp filter to block the use of `ioctl` with `TIOCLINUX`, which is a security fix. The code changes align with the vulnerability description and the commit message, clearly indicating a security patch."
}