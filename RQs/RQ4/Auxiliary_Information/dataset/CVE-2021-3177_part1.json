{
  "cve_id": "CVE-2021-3177",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "python/cpython",
  "commit_msg": "closes bpo-42938: Replace snprintf with Python unicode formatting in ctypes param reprs.",
  "commit_hash": "298cc0231a271b5d5c6d55273297b9541353ecc3",
  "git_url": "https://github.com/python/cpython/commit/298cc0231a271b5d5c6d55273297b9541353ecc3",
  "file_path": "Modules/_ctypes/callproc.c",
  "func_name": "PyCArg_repr",
  "func_before": "static PyObject *\nPyCArg_repr(PyCArgObject *self)\n{\n    char buffer[256];\n    switch(self->tag) {\n    case 'b':\n    case 'B':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.b);\n        break;\n    case 'h':\n    case 'H':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.h);\n        break;\n    case 'i':\n    case 'I':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.i);\n        break;\n    case 'l':\n    case 'L':\n        sprintf(buffer, \"<cparam '%c' (%ld)>\",\n            self->tag, self->value.l);\n        break;\n\n    case 'q':\n    case 'Q':\n        sprintf(buffer,\n#ifdef MS_WIN32\n            \"<cparam '%c' (%I64d)>\",\n#else\n            \"<cparam '%c' (%lld)>\",\n#endif\n            self->tag, self->value.q);\n        break;\n    case 'd':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.d);\n        break;\n    case 'f':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.f);\n        break;\n\n    case 'c':\n        if (is_literal_char((unsigned char)self->value.c)) {\n            sprintf(buffer, \"<cparam '%c' ('%c')>\",\n                self->tag, self->value.c);\n        }\n        else {\n            sprintf(buffer, \"<cparam '%c' ('\\\\x%02x')>\",\n                self->tag, (unsigned char)self->value.c);\n        }\n        break;\n\n/* Hm, are these 'z' and 'Z' codes useful at all?\n   Shouldn't they be replaced by the functionality of c_string\n   and c_wstring ?\n*/\n    case 'z':\n    case 'Z':\n    case 'P':\n        sprintf(buffer, \"<cparam '%c' (%p)>\",\n            self->tag, self->value.p);\n        break;\n\n    default:\n        if (is_literal_char((unsigned char)self->tag)) {\n            sprintf(buffer, \"<cparam '%c' at %p>\",\n                (unsigned char)self->tag, (void *)self);\n        }\n        else {\n            sprintf(buffer, \"<cparam 0x%02x at %p>\",\n                (unsigned char)self->tag, (void *)self);\n        }\n        break;\n    }\n    return PyUnicode_FromString(buffer);\n}",
  "abstract_func_before": "static PyObject *\nPyCArg_repr(PyCArgObject *VAR_0)\n{\n    char VAR_1[256];\n    switch(VAR_0->tag) {\n    case 'b':\n    case 'B':\n        sprintf(VAR_1, \"<cparam '%c' (%d)>\",\n            VAR_0->tag, VAR_0->value.b);\n        break;\n    case 'h':\n    case 'H':\n        sprintf(VAR_1, \"<cparam '%c' (%d)>\",\n            VAR_0->tag, VAR_0->value.h);\n        break;\n    case 'i':\n    case 'I':\n        sprintf(VAR_1, \"<cparam '%c' (%d)>\",\n            VAR_0->tag, VAR_0->value.i);\n        break;\n    case 'l':\n    case 'L':\n        sprintf(VAR_1, \"<cparam '%c' (%ld)>\",\n            VAR_0->tag, VAR_0->value.l);\n        break;\n\n    case 'q':\n    case 'Q':\n        VAR_2(VAR_1,\n#ifdef VAR_3\n            \"<cparam '%c' (%I64d)>\",\n#else\n            \"<cparam '%c' (%lld)>\",\n#endif\n            VAR_0->tag, VAR_0->value.q);\n        break;\n    case 'd':\n        VAR_2(VAR_1, \"<cparam '%c' (%f)>\",\n            VAR_0->tag, VAR_0->value.d);\n        break;\n    case 'f':\n        VAR_2(VAR_1, \"<cparam '%c' (%f)>\",\n            VAR_0->tag, VAR_0->value.f);\n        break;\n\n    case 'c':\n        if (is_literal_char((unsigned char)VAR_0->value.c)) {\n            VAR_2(VAR_1, \"<cparam '%c' ('%c')>\",\n                VAR_0->tag, VAR_0->value.c);\n        }\n        else {\n            VAR_2(VAR_1, \"<cparam '%c' ('\\\\x%02x')>\",\n                VAR_0->tag, (unsigned char)VAR_0->value.c);\n        }\n        break;\n\n/* COMMENT_0 */\n                                                              \n                  \n  \n    case 'z':\n    case 'Z':\n    case 'P':\n        VAR_2(VAR_1, \"<cparam '%c' (%p)>\",\n            VAR_0->tag, VAR_0->value.p);\n        break;\n\n    default:\n        if (is_literal_char((unsigned char)VAR_0->tag)) {\n            VAR_2(VAR_1, \"<cparam '%c' at %p>\",\n                (unsigned char)VAR_0->tag, (void *)VAR_0);\n        }\n        else {\n            VAR_2(VAR_1, \"<cparam 0x%02x at %p>\",\n                (unsigned char)VAR_0->tag, (void *)VAR_0);\n        }\n        break;\n    }\n    return PyUnicode_FromString(VAR_1);\n}",
  "func_graph_path_before": "python/cpython/298cc0231a271b5d5c6d55273297b9541353ecc3/callproc.c/vul/before/0.json",
  "func": "static PyObject *\nPyCArg_repr(PyCArgObject *self)\n{\n    switch(self->tag) {\n    case 'b':\n    case 'B':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n            self->tag, self->value.b);\n    case 'h':\n    case 'H':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n            self->tag, self->value.h);\n    case 'i':\n    case 'I':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n            self->tag, self->value.i);\n    case 'l':\n    case 'L':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%ld)>\",\n            self->tag, self->value.l);\n\n    case 'q':\n    case 'Q':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%lld)>\",\n            self->tag, self->value.q);\n    case 'd':\n    case 'f': {\n        PyObject *f = PyFloat_FromDouble((self->tag == 'f') ? self->value.f : self->value.d);\n        if (f == NULL) {\n            return NULL;\n        }\n        PyObject *result = PyUnicode_FromFormat(\"<cparam '%c' (%R)>\", self->tag, f);\n        Py_DECREF(f);\n        return result;\n    }\n    case 'c':\n        if (is_literal_char((unsigned char)self->value.c)) {\n            return PyUnicode_FromFormat(\"<cparam '%c' ('%c')>\",\n                self->tag, self->value.c);\n        }\n        else {\n            return PyUnicode_FromFormat(\"<cparam '%c' ('\\\\x%02x')>\",\n                self->tag, (unsigned char)self->value.c);\n        }\n\n/* Hm, are these 'z' and 'Z' codes useful at all?\n   Shouldn't they be replaced by the functionality of c_string\n   and c_wstring ?\n*/\n    case 'z':\n    case 'Z':\n    case 'P':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%p)>\",\n            self->tag, self->value.p);\n        break;\n\n    default:\n        if (is_literal_char((unsigned char)self->tag)) {\n            return PyUnicode_FromFormat(\"<cparam '%c' at %p>\",\n                (unsigned char)self->tag, (void *)self);\n        }\n        else {\n            return PyUnicode_FromFormat(\"<cparam 0x%02x at %p>\",\n                (unsigned char)self->tag, (void *)self);\n        }\n    }\n}",
  "abstract_func": "static PyObject *\nPyCArg_repr(PyCArgObject *VAR_0)\n{\n    switch(VAR_0->tag) {\n    case 'b':\n    case 'B':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n            VAR_0->tag, VAR_0->value.b);\n    case 'h':\n    case 'H':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n            VAR_0->tag, VAR_0->value.h);\n    case 'i':\n    case 'I':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n            VAR_0->tag, VAR_0->value.i);\n    case 'l':\n    case 'L':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%ld)>\",\n            VAR_0->tag, VAR_0->value.l);\n\n    case 'q':\n    case 'Q':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%lld)>\",\n            VAR_0->tag, VAR_0->value.q);\n    case 'd':\n    case 'f': {\n        PyObject *VAR_1 = PyFloat_FromDouble((VAR_0->tag == 'f') ? VAR_0->value.f : VAR_0->value.d);\n        if (VAR_1 == NULL) {\n            return NULL;\n        }\n        PyObject *VAR_2 = PyUnicode_FromFormat(\"<cparam '%c' (%R)>\", VAR_0->tag, VAR_1);\n        Py_DECREF(VAR_1);\n        return VAR_2;\n    }\n    case 'c':\n        if (is_literal_char((unsigned char)VAR_0->value.c)) {\n            return PyUnicode_FromFormat(\"<cparam '%c' ('%c')>\",\n                VAR_0->tag, VAR_0->value.c);\n        }\n        else {\n            return PyUnicode_FromFormat(\"<cparam '%c' ('\\\\x%02x')>\",\n                VAR_0->tag, (unsigned char)VAR_0->value.c);\n        }\n\n/* COMMENT_0 */\n                                                              \n                  \n  \n    case 'z':\n    case 'Z':\n    case 'P':\n        return PyUnicode_FromFormat(\"<cparam '%c' (%p)>\",\n            VAR_0->tag, VAR_0->value.p);\n        break;\n\n    default:\n        if (is_literal_char((unsigned char)VAR_0->tag)) {\n            return PyUnicode_FromFormat(\"<cparam '%c' at %p>\",\n                (unsigned char)VAR_0->tag, (void *)VAR_0);\n        }\n        else {\n            return PyUnicode_FromFormat(\"<cparam 0x%02x at %p>\",\n                (unsigned char)VAR_0->tag, (void *)VAR_0);\n        }\n    }\n}",
  "func_graph_path": "python/cpython/298cc0231a271b5d5c6d55273297b9541353ecc3/callproc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,58 +1,47 @@\n static PyObject *\n PyCArg_repr(PyCArgObject *self)\n {\n-    char buffer[256];\n     switch(self->tag) {\n     case 'b':\n     case 'B':\n-        sprintf(buffer, \"<cparam '%c' (%d)>\",\n+        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n             self->tag, self->value.b);\n-        break;\n     case 'h':\n     case 'H':\n-        sprintf(buffer, \"<cparam '%c' (%d)>\",\n+        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n             self->tag, self->value.h);\n-        break;\n     case 'i':\n     case 'I':\n-        sprintf(buffer, \"<cparam '%c' (%d)>\",\n+        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",\n             self->tag, self->value.i);\n-        break;\n     case 'l':\n     case 'L':\n-        sprintf(buffer, \"<cparam '%c' (%ld)>\",\n+        return PyUnicode_FromFormat(\"<cparam '%c' (%ld)>\",\n             self->tag, self->value.l);\n-        break;\n \n     case 'q':\n     case 'Q':\n-        sprintf(buffer,\n-#ifdef MS_WIN32\n-            \"<cparam '%c' (%I64d)>\",\n-#else\n-            \"<cparam '%c' (%lld)>\",\n-#endif\n+        return PyUnicode_FromFormat(\"<cparam '%c' (%lld)>\",\n             self->tag, self->value.q);\n-        break;\n     case 'd':\n-        sprintf(buffer, \"<cparam '%c' (%f)>\",\n-            self->tag, self->value.d);\n-        break;\n-    case 'f':\n-        sprintf(buffer, \"<cparam '%c' (%f)>\",\n-            self->tag, self->value.f);\n-        break;\n-\n+    case 'f': {\n+        PyObject *f = PyFloat_FromDouble((self->tag == 'f') ? self->value.f : self->value.d);\n+        if (f == NULL) {\n+            return NULL;\n+        }\n+        PyObject *result = PyUnicode_FromFormat(\"<cparam '%c' (%R)>\", self->tag, f);\n+        Py_DECREF(f);\n+        return result;\n+    }\n     case 'c':\n         if (is_literal_char((unsigned char)self->value.c)) {\n-            sprintf(buffer, \"<cparam '%c' ('%c')>\",\n+            return PyUnicode_FromFormat(\"<cparam '%c' ('%c')>\",\n                 self->tag, self->value.c);\n         }\n         else {\n-            sprintf(buffer, \"<cparam '%c' ('\\\\x%02x')>\",\n+            return PyUnicode_FromFormat(\"<cparam '%c' ('\\\\x%02x')>\",\n                 self->tag, (unsigned char)self->value.c);\n         }\n-        break;\n \n /* Hm, are these 'z' and 'Z' codes useful at all?\n    Shouldn't they be replaced by the functionality of c_string\n@@ -61,20 +50,18 @@\n     case 'z':\n     case 'Z':\n     case 'P':\n-        sprintf(buffer, \"<cparam '%c' (%p)>\",\n+        return PyUnicode_FromFormat(\"<cparam '%c' (%p)>\",\n             self->tag, self->value.p);\n         break;\n \n     default:\n         if (is_literal_char((unsigned char)self->tag)) {\n-            sprintf(buffer, \"<cparam '%c' at %p>\",\n+            return PyUnicode_FromFormat(\"<cparam '%c' at %p>\",\n                 (unsigned char)self->tag, (void *)self);\n         }\n         else {\n-            sprintf(buffer, \"<cparam 0x%02x at %p>\",\n+            return PyUnicode_FromFormat(\"<cparam 0x%02x at %p>\",\n                 (unsigned char)self->tag, (void *)self);\n         }\n-        break;\n     }\n-    return PyUnicode_FromString(buffer);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    char buffer[256];",
      "        sprintf(buffer, \"<cparam '%c' (%d)>\",",
      "        break;",
      "        sprintf(buffer, \"<cparam '%c' (%d)>\",",
      "        break;",
      "        sprintf(buffer, \"<cparam '%c' (%d)>\",",
      "        break;",
      "        sprintf(buffer, \"<cparam '%c' (%ld)>\",",
      "        break;",
      "        sprintf(buffer,",
      "#ifdef MS_WIN32",
      "            \"<cparam '%c' (%I64d)>\",",
      "#else",
      "            \"<cparam '%c' (%lld)>\",",
      "#endif",
      "        break;",
      "        sprintf(buffer, \"<cparam '%c' (%f)>\",",
      "            self->tag, self->value.d);",
      "        break;",
      "    case 'f':",
      "        sprintf(buffer, \"<cparam '%c' (%f)>\",",
      "            self->tag, self->value.f);",
      "        break;",
      "",
      "            sprintf(buffer, \"<cparam '%c' ('%c')>\",",
      "            sprintf(buffer, \"<cparam '%c' ('\\\\x%02x')>\",",
      "        break;",
      "        sprintf(buffer, \"<cparam '%c' (%p)>\",",
      "            sprintf(buffer, \"<cparam '%c' at %p>\",",
      "            sprintf(buffer, \"<cparam 0x%02x at %p>\",",
      "        break;",
      "    return PyUnicode_FromString(buffer);"
    ],
    "added_lines": [
      "        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",",
      "        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",",
      "        return PyUnicode_FromFormat(\"<cparam '%c' (%d)>\",",
      "        return PyUnicode_FromFormat(\"<cparam '%c' (%ld)>\",",
      "        return PyUnicode_FromFormat(\"<cparam '%c' (%lld)>\",",
      "    case 'f': {",
      "        PyObject *f = PyFloat_FromDouble((self->tag == 'f') ? self->value.f : self->value.d);",
      "        if (f == NULL) {",
      "            return NULL;",
      "        }",
      "        PyObject *result = PyUnicode_FromFormat(\"<cparam '%c' (%R)>\", self->tag, f);",
      "        Py_DECREF(f);",
      "        return result;",
      "    }",
      "            return PyUnicode_FromFormat(\"<cparam '%c' ('%c')>\",",
      "            return PyUnicode_FromFormat(\"<cparam '%c' ('\\\\x%02x')>\",",
      "        return PyUnicode_FromFormat(\"<cparam '%c' (%p)>\",",
      "            return PyUnicode_FromFormat(\"<cparam '%c' at %p>\",",
      "            return PyUnicode_FromFormat(\"<cparam 0x%02x at %p>\","
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/cpython/pull/24239",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/python/cpython/pull/24239: 403 Client Error: Forbidden for url: https://api.github.com/repos/python/cpython/pulls/24239",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "The commit replaces `sprintf` with `PyUnicode_FromFormat` to improve string formatting in the `ctypes` module. This change enhances Unicode handling but doesn't address a security vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8\n\nThe change fixes a bug related to string representation, enhancing functionality without addressing a security flaw."
}