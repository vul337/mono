{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_server.cpp",
  "func_name": "zmq::curve_server_t::produce_ready",
  "func_before": "int zmq::curve_server_t::produce_ready (msg_t *msg_)\n{\n    uint8_t ready_nonce [crypto_box_NONCEBYTES];\n    uint8_t ready_plaintext [crypto_box_ZEROBYTES + 256];\n    uint8_t ready_box [crypto_box_BOXZEROBYTES + 16 + 256];\n\n    //  Create Box [metadata](S'->C')\n    memset (ready_plaintext, 0, crypto_box_ZEROBYTES);\n    uint8_t *ptr = ready_plaintext + crypto_box_ZEROBYTES;\n\n    //  Add socket type property\n    const char *socket_type = socket_type_string (options.type);\n    ptr += add_property (ptr, \"Socket-Type\", socket_type, strlen (socket_type));\n\n    //  Add identity property\n    if (options.type == ZMQ_REQ\n    ||  options.type == ZMQ_DEALER\n    ||  options.type == ZMQ_ROUTER)\n        ptr += add_property (ptr, \"Identity\", options.identity, options.identity_size);\n\n    const size_t mlen = ptr - ready_plaintext;\n\n    memcpy (ready_nonce, \"CurveZMQREADY---\", 16);\n    memcpy (ready_nonce + 16, &cn_nonce, 8);\n\n    int rc = crypto_box_afternm (ready_box, ready_plaintext,\n                                 mlen, ready_nonce, cn_precom);\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (14 + mlen - crypto_box_BOXZEROBYTES);\n    errno_assert (rc == 0);\n\n    uint8_t *ready = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (ready, \"\\x05READY\", 6);\n    //  Short nonce, prefixed by \"CurveZMQREADY---\"\n    memcpy (ready + 6, &cn_nonce, 8);\n    //  Box [metadata](S'->C')\n    memcpy (ready + 14, ready_box + crypto_box_BOXZEROBYTES,\n            mlen - crypto_box_BOXZEROBYTES);\n\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func_before": "int zmq::curve_server_t::produce_ready (msg_t *VAR_0)\n{\n    uint8_t VAR_1 [VAR_2];\n    uint8_t VAR_3 [VAR_4 + 256];\n    uint8_t VAR_5 [VAR_6 + 16 + 256];\n\n    /* COMMENT_0 */\n    memset (VAR_3, 0, VAR_4);\n    uint8_t *VAR_7 = VAR_3 + VAR_4;\n\n    /* COMMENT_1 */\n    const char *VAR_8 = socket_type_string (VAR_9.type);\n    VAR_7 += add_property (VAR_7, \"Socket-Type\", VAR_8, strlen (VAR_8));\n\n    /* COMMENT_2 */\n    if (VAR_9.type == VAR_10\n    ||  VAR_9.type == VAR_11\n    ||  VAR_9.type == VAR_12)\n        VAR_7 += add_property (VAR_7, \"Identity\", VAR_9.identity, VAR_9.identity_size);\n\n    const size_t VAR_13 = VAR_7 - VAR_3;\n\n    memcpy (VAR_1, \"CurveZMQREADY---\", 16);\n    memcpy (VAR_1 + 16, &VAR_14, 8);\n\n    int VAR_15 = crypto_box_afternm (VAR_5, VAR_3,\n                                 VAR_13, VAR_1, VAR_16);\n    zmq_assert (VAR_15 == 0);\n\n    VAR_15 = VAR_0->init_size (14 + VAR_13 - VAR_6);\n    errno_assert (VAR_15 == 0);\n\n    uint8_t *VAR_17 = VAR_18 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_17, \"\\x05READY\", 6);\n    /* COMMENT_3 */\n    memcpy (VAR_17 + 6, &VAR_14, 8);\n    /* COMMENT_4 */\n    memcpy (VAR_17 + 14, VAR_5 + VAR_6,\n            VAR_13 - VAR_6);\n\n    VAR_14++;\n\n    return 0;\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/before/5.json",
  "func": "int zmq::curve_server_t::produce_ready (msg_t *msg_)\n{\n    uint8_t ready_nonce [crypto_box_NONCEBYTES];\n    uint8_t ready_plaintext [crypto_box_ZEROBYTES + 256];\n    uint8_t ready_box [crypto_box_BOXZEROBYTES + 16 + 256];\n\n    //  Create Box [metadata](S'->C')\n    memset (ready_plaintext, 0, crypto_box_ZEROBYTES);\n    uint8_t *ptr = ready_plaintext + crypto_box_ZEROBYTES;\n\n    //  Add socket type property\n    const char *socket_type = socket_type_string (options.type);\n    ptr += add_property (ptr, \"Socket-Type\", socket_type, strlen (socket_type));\n\n    //  Add identity property\n    if (options.type == ZMQ_REQ\n    ||  options.type == ZMQ_DEALER\n    ||  options.type == ZMQ_ROUTER)\n        ptr += add_property (ptr, \"Identity\", options.identity, options.identity_size);\n\n    const size_t mlen = ptr - ready_plaintext;\n\n    memcpy (ready_nonce, \"CurveZMQREADY---\", 16);\n    put_uint64 (ready_nonce + 16, cn_nonce);\n\n    int rc = crypto_box_afternm (ready_box, ready_plaintext,\n                                 mlen, ready_nonce, cn_precom);\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (14 + mlen - crypto_box_BOXZEROBYTES);\n    errno_assert (rc == 0);\n\n    uint8_t *ready = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (ready, \"\\x05READY\", 6);\n    //  Short nonce, prefixed by \"CurveZMQREADY---\"\n    memcpy (ready + 6, ready_nonce + 16, 8);\n    //  Box [metadata](S'->C')\n    memcpy (ready + 14, ready_box + crypto_box_BOXZEROBYTES,\n            mlen - crypto_box_BOXZEROBYTES);\n\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func": "int zmq::curve_server_t::produce_ready (msg_t *VAR_0)\n{\n    uint8_t VAR_1 [VAR_2];\n    uint8_t VAR_3 [VAR_4 + 256];\n    uint8_t VAR_5 [VAR_6 + 16 + 256];\n\n    /* COMMENT_0 */\n    memset (VAR_3, 0, VAR_4);\n    uint8_t *VAR_7 = VAR_3 + VAR_4;\n\n    /* COMMENT_1 */\n    const char *VAR_8 = socket_type_string (VAR_9.type);\n    VAR_7 += add_property (VAR_7, \"Socket-Type\", VAR_8, strlen (VAR_8));\n\n    /* COMMENT_2 */\n    if (VAR_9.type == VAR_10\n    ||  VAR_9.type == VAR_11\n    ||  VAR_9.type == VAR_12)\n        VAR_7 += add_property (VAR_7, \"Identity\", VAR_9.identity, VAR_9.identity_size);\n\n    const size_t VAR_13 = VAR_7 - VAR_3;\n\n    memcpy (VAR_1, \"CurveZMQREADY---\", 16);\n    put_uint64 (VAR_1 + 16, VAR_14);\n\n    int VAR_15 = crypto_box_afternm (VAR_5, VAR_3,\n                                 VAR_13, VAR_1, VAR_16);\n    zmq_assert (VAR_15 == 0);\n\n    VAR_15 = VAR_0->init_size (14 + VAR_13 - VAR_6);\n    errno_assert (VAR_15 == 0);\n\n    uint8_t *VAR_17 = VAR_18 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_17, \"\\x05READY\", 6);\n    /* COMMENT_3 */\n    memcpy (VAR_17 + 6, VAR_1 + 16, 8);\n    /* COMMENT_4 */\n    memcpy (VAR_17 + 14, VAR_5 + VAR_6,\n            VAR_13 - VAR_6);\n\n    VAR_14++;\n\n    return 0;\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n     const size_t mlen = ptr - ready_plaintext;\n \n     memcpy (ready_nonce, \"CurveZMQREADY---\", 16);\n-    memcpy (ready_nonce + 16, &cn_nonce, 8);\n+    put_uint64 (ready_nonce + 16, cn_nonce);\n \n     int rc = crypto_box_afternm (ready_box, ready_plaintext,\n                                  mlen, ready_nonce, cn_precom);\n@@ -34,7 +34,7 @@\n \n     memcpy (ready, \"\\x05READY\", 6);\n     //  Short nonce, prefixed by \"CurveZMQREADY---\"\n-    memcpy (ready + 6, &cn_nonce, 8);\n+    memcpy (ready + 6, ready_nonce + 16, 8);\n     //  Box [metadata](S'->C')\n     memcpy (ready + 14, ready_box + crypto_box_BOXZEROBYTES,\n             mlen - crypto_box_BOXZEROBYTES);",
  "diff_line_info": {
    "deleted_lines": [
      "    memcpy (ready_nonce + 16, &cn_nonce, 8);",
      "    memcpy (ready + 6, &cn_nonce, 8);"
    ],
    "added_lines": [
      "    put_uint64 (ready_nonce + 16, cn_nonce);",
      "    memcpy (ready + 6, ready_nonce + 16, 8);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zeromq/libzmq/pull/1189: 403 Client Error: Forbidden for url: https://api.github.com/repos/zeromq/libzmq/pulls/1189",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}