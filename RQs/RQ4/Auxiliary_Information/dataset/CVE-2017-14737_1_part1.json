{
  "cve_id": "CVE-2017-14737",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "randombit/botan",
  "commit_msg": "Use a side channel silent table look up in the Montgomery exponentiation",
  "commit_hash": "a3c4ec54ba8f611e7ef41867a4ed0fd669ef8057",
  "git_url": "https://github.com/randombit/botan/commit/a3c4ec54ba8f611e7ef41867a4ed0fd669ef8057",
  "file_path": "src/lib/math/numbertheory/powm_mnt.cpp",
  "func_name": "Montgomery_Exponentiator::execute",
  "func_before": "BigInt Montgomery_Exponentiator::execute() const\n   {\n   const size_t exp_nibbles = (m_exp_bits + m_window_bits - 1) / m_window_bits;\n\n   BigInt x = m_R_mod;\n\n   const size_t z_size = 2*(m_mod_words + 1);\n\n   BigInt z(BigInt::Positive, z_size);\n   secure_vector<word> workspace(z.size());\n\n   for(size_t i = exp_nibbles; i > 0; --i)\n      {\n      for(size_t k = 0; k != m_window_bits; ++k)\n         {\n         bigint_monty_sqr(z, x, m_modulus.data(), m_mod_words, m_mod_prime,\n                          workspace.data());\n\n         x = z;\n         }\n\n      const uint32_t nibble = m_exp.get_substring(m_window_bits*(i-1), m_window_bits);\n\n      bigint_monty_mul(z, x, m_g[nibble],\n                       m_modulus.data(), m_mod_words, m_mod_prime,\n                       workspace.data());\n\n      x = z;\n      }\n\n   x.grow_to(2*m_mod_words + 1);\n\n   bigint_monty_redc(x.mutable_data(),\n                     m_modulus.data(), m_mod_words, m_mod_prime,\n                     workspace.data());\n\n   return x;\n   }",
  "abstract_func_before": "BigInt Montgomery_Exponentiator::execute() const\n   {\n   const size_t VAR_0 = (VAR_1 + VAR_2 - 1) / VAR_2;\n\n   BigInt VAR_3 = VAR_4;\n\n   const size_t VAR_5 = 2*(VAR_6 + 1);\n\n   BigInt z(BigInt::Positive, z_size);\n   secure_vector<word> VAR_7(VAR_8.size());\n\n   for(size_t VAR_9 = VAR_0; VAR_9 > 0; --VAR_9)\n      {\n      for(size_t VAR_10 = 0; VAR_10 != VAR_2; ++VAR_10)\n         {\n         bigint_monty_sqr(VAR_8, VAR_3, VAR_11.data(), VAR_6, VAR_12,\n                          VAR_7.data());\n\n         VAR_3 = VAR_8;\n         }\n\n      const uint32_t VAR_13 = VAR_14.get_substring(VAR_2*(VAR_9-1), VAR_2);\n\n      bigint_monty_mul(VAR_8, VAR_3, VAR_15[VAR_13],\n                       VAR_11.data(), VAR_6, VAR_12,\n                       VAR_7.data());\n\n      VAR_3 = VAR_8;\n      }\n\n   VAR_3.grow_to(2*VAR_6 + 1);\n\n   bigint_monty_redc(VAR_3.mutable_data(),\n                     VAR_11.data(), VAR_6, VAR_12,\n                     VAR_7.data());\n\n   return VAR_3;\n   }",
  "func_graph_path_before": "randombit/botan/a3c4ec54ba8f611e7ef41867a4ed0fd669ef8057/powm_mnt.cpp/vul/before/0.json",
  "func": "BigInt Montgomery_Exponentiator::execute() const\n   {\n   const size_t exp_nibbles = (m_exp_bits + m_window_bits - 1) / m_window_bits;\n\n   BigInt x = m_R_mod;\n\n   const size_t z_size = 2*(m_mod_words + 1);\n\n   BigInt z(BigInt::Positive, z_size);\n   secure_vector<word> workspace(z.size());\n   secure_vector<word> e(m_mod_words);\n\n   for(size_t i = exp_nibbles; i > 0; --i)\n      {\n      for(size_t k = 0; k != m_window_bits; ++k)\n         {\n         bigint_monty_sqr(z, x, m_modulus.data(), m_mod_words, m_mod_prime,\n                          workspace.data());\n\n         x = z;\n         }\n\n      const uint32_t nibble = m_exp.get_substring(m_window_bits*(i-1), m_window_bits);\n\n      BigInt::const_time_lookup(e, m_g, nibble);\n\n      bigint_mul(z.mutable_data(), z.size(),\n                 x.data(), x.size(), x.sig_words(),\n                 e.data(), m_mod_words, m_mod_words,\n                 workspace.data());\n\n      bigint_monty_redc(z.mutable_data(),\n                        m_modulus.data(), m_mod_words, m_mod_prime,\n                        workspace.data());\n\n      x = z;\n      }\n\n   x.grow_to(2*m_mod_words + 1);\n\n   bigint_monty_redc(x.mutable_data(),\n                     m_modulus.data(), m_mod_words, m_mod_prime,\n                     workspace.data());\n\n   return x;\n   }",
  "abstract_func": "BigInt Montgomery_Exponentiator::execute() const\n   {\n   const size_t VAR_0 = (VAR_1 + VAR_2 - 1) / VAR_2;\n\n   BigInt VAR_3 = VAR_4;\n\n   const size_t VAR_5 = 2*(VAR_6 + 1);\n\n   BigInt z(BigInt::Positive, z_size);\n   secure_vector<word> VAR_7(VAR_8.size());\n   secure_vector<word> e(m_mod_words);\n\n   for(size_t VAR_9 = VAR_0; VAR_9 > 0; --VAR_9)\n      {\n      for(size_t VAR_10 = 0; VAR_10 != VAR_2; ++VAR_10)\n         {\n         bigint_monty_sqr(VAR_8, VAR_3, VAR_11.data(), m_mod_words, VAR_12,\n                          VAR_7.data());\n\n         VAR_3 = VAR_8;\n         }\n\n      const uint32_t VAR_13 = VAR_14.get_substring(VAR_2*(VAR_9-1), VAR_2);\n\n      BigInt::const_time_lookup(VAR_15, VAR_16, VAR_13);\n\n      bigint_mul(VAR_8.mutable_data(), VAR_8.size(),\n                 VAR_3.data(), VAR_3.size(), VAR_3.sig_words(),\n                 VAR_15.data(), m_mod_words, m_mod_words,\n                 VAR_7.data());\n\n      bigint_monty_redc(VAR_8.mutable_data(),\n                        VAR_11.data(), m_mod_words, VAR_12,\n                        VAR_7.data());\n\n      VAR_3 = VAR_8;\n      }\n\n   VAR_3.grow_to(2*m_mod_words + 1);\n\n   bigint_monty_redc(VAR_3.mutable_data(),\n                     VAR_11.data(), m_mod_words, VAR_12,\n                     VAR_7.data());\n\n   return VAR_3;\n   }",
  "func_graph_path": "randombit/botan/a3c4ec54ba8f611e7ef41867a4ed0fd669ef8057/powm_mnt.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n \n    BigInt z(BigInt::Positive, z_size);\n    secure_vector<word> workspace(z.size());\n+   secure_vector<word> e(m_mod_words);\n \n    for(size_t i = exp_nibbles; i > 0; --i)\n       {\n@@ -21,9 +22,16 @@\n \n       const uint32_t nibble = m_exp.get_substring(m_window_bits*(i-1), m_window_bits);\n \n-      bigint_monty_mul(z, x, m_g[nibble],\n-                       m_modulus.data(), m_mod_words, m_mod_prime,\n-                       workspace.data());\n+      BigInt::const_time_lookup(e, m_g, nibble);\n+\n+      bigint_mul(z.mutable_data(), z.size(),\n+                 x.data(), x.size(), x.sig_words(),\n+                 e.data(), m_mod_words, m_mod_words,\n+                 workspace.data());\n+\n+      bigint_monty_redc(z.mutable_data(),\n+                        m_modulus.data(), m_mod_words, m_mod_prime,\n+                        workspace.data());\n \n       x = z;\n       }",
  "diff_line_info": {
    "deleted_lines": [
      "      bigint_monty_mul(z, x, m_g[nibble],",
      "                       m_modulus.data(), m_mod_words, m_mod_prime,",
      "                       workspace.data());"
    ],
    "added_lines": [
      "   secure_vector<word> e(m_mod_words);",
      "      BigInt::const_time_lookup(e, m_g, nibble);",
      "",
      "      bigint_mul(z.mutable_data(), z.size(),",
      "                 x.data(), x.size(), x.sig_words(),",
      "                 e.data(), m_mod_words, m_mod_words,",
      "                 workspace.data());",
      "",
      "      bigint_monty_redc(z.mutable_data(),",
      "                        m_modulus.data(), m_mod_words, m_mod_prime,",
      "                        workspace.data());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/randombit/botan/pull/1224",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/randombit/botan/pull/1224: 403 Client Error: Forbidden for url: https://api.github.com/repos/randombit/botan/pulls/1224",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 0.9  \n\nThe changes address a side-channel vulnerability in the Montgomery exponentiation, as indicated by the commit message, vulnerability description, and code modifications focused on cryptographic operations. All evidence points clearly to a security fix."
}