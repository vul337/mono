{
  "cve_id": "CVE-2017-14199",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "zephyrproject-rtos/zephyr",
  "commit_msg": "net: sockets: getaddrinfo() buffer overflow, etc. fixes\n\nThe existing implementation assumed DNS resolv callback will be\ncalled just once, but that's not always the case (apparently,\nfor multi-homes hosts or something). So, apply array bounds\nchecking (and do pointer arithmetic only after it, as the C\nstandard otherwise warns of \"undefined behavior\"). In such a case,\nthe port number wasn't set in each entry too, so rework how it's\ndone.\n\nThe issues discovered while resolving archive.ubuntu.com.\n\nSigned-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>",
  "commit_hash": "3953714a9b8508aca72ab93991e8468ba508aa4b",
  "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/3953714a9b8508aca72ab93991e8468ba508aa4b",
  "file_path": "subsys/net/lib/sockets/getaddrinfo.c",
  "func_name": "dns_resolve_cb",
  "func_before": "static void dns_resolve_cb(enum dns_resolve_status status,\n\t\t\t   struct dns_addrinfo *info, void *user_data)\n{\n\tstruct getaddrinfo_state *state = user_data;\n\tstruct zsock_addrinfo *ai = ai_arr + state->idx;\n\tint socktype = SOCK_STREAM;\n\tint proto;\n\n\tNET_DBG(\"dns status: %d\", status);\n\n\tif (info == NULL) {\n\t\tif (status == DNS_EAI_ALLDONE) {\n\t\t\tstatus = 0;\n\t\t}\n\t\tstate->status = status;\n\t\tk_sem_give(&state->sem);\n\t\treturn;\n\t}\n\n\tmemcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n\tai->ai_addr = &ai->_ai_addr;\n\tai->ai_addrlen = info->ai_addrlen;\n\tmemcpy(&ai->_ai_canonname, &info->ai_canonname,\n\t       sizeof(ai->_ai_canonname));\n\tai->ai_canonname = ai->_ai_canonname;\n\tai->ai_family = info->ai_family;\n\n\tif (state->hints) {\n\t\tif (state->hints->ai_socktype) {\n\t\t\tsocktype = state->hints->ai_socktype;\n\t\t}\n\t}\n\n\tproto = IPPROTO_TCP;\n\tif (socktype == SOCK_DGRAM) {\n\t\tproto = IPPROTO_UDP;\n\t}\n\n\tai->ai_socktype = socktype;\n\tai->ai_protocol = proto;\n\n\tstate->idx++;\n}",
  "abstract_func_before": "static void dns_resolve_cb(enum dns_resolve_status VAR_0,\n\t\t\t   struct dns_addrinfo *VAR_1, void *VAR_2)\n{\n\tstruct getaddrinfo_state *VAR_3 = VAR_2;\n\tstruct zsock_addrinfo *VAR_4 = VAR_5 + VAR_3->idx;\n\tint VAR_6 = VAR_7;\n\tint VAR_8;\n\n\tNET_DBG(\"dns status: %d\", VAR_0);\n\n\tif (VAR_1 == NULL) {\n\t\tif (VAR_0 == VAR_9) {\n\t\t\tVAR_0 = 0;\n\t\t}\n\t\tVAR_3->status = VAR_0;\n\t\tk_sem_give(&VAR_3->sem);\n\t\treturn;\n\t}\n\n\tmemcpy(&VAR_4->_ai_addr, &VAR_1->ai_addr, VAR_1->ai_addrlen);\n\tVAR_4->ai_addr = &VAR_4->_ai_addr;\n\tVAR_4->ai_addrlen = VAR_1->ai_addrlen;\n\tmemcpy(&VAR_4->_ai_canonname, &VAR_1->ai_canonname,\n\t       sizeof(VAR_4->_ai_canonname));\n\tVAR_4->ai_canonname = VAR_4->_ai_canonname;\n\tVAR_4->ai_family = VAR_1->ai_family;\n\n\tif (VAR_3->hints) {\n\t\tif (VAR_3->hints->ai_socktype) {\n\t\t\tVAR_6 = VAR_3->hints->ai_socktype;\n\t\t}\n\t}\n\n\tVAR_8 = VAR_10;\n\tif (VAR_6 == VAR_11) {\n\t\tVAR_8 = VAR_12;\n\t}\n\n\tVAR_4->ai_socktype = VAR_6;\n\tVAR_4->ai_protocol = VAR_8;\n\n\tVAR_3->idx++;\n}",
  "func_graph_path_before": "zephyrproject-rtos/zephyr/3953714a9b8508aca72ab93991e8468ba508aa4b/getaddrinfo.c/vul/before/0.json",
  "func": "static void dns_resolve_cb(enum dns_resolve_status status,\n\t\t\t   struct dns_addrinfo *info, void *user_data)\n{\n\tstruct getaddrinfo_state *state = user_data;\n\tstruct zsock_addrinfo *ai;\n\tint socktype = SOCK_STREAM;\n\tint proto;\n\n\tNET_DBG(\"dns status: %d\", status);\n\n\tif (info == NULL) {\n\t\tif (status == DNS_EAI_ALLDONE) {\n\t\t\tstatus = 0;\n\t\t}\n\t\tstate->status = status;\n\t\tk_sem_give(&state->sem);\n\t\treturn;\n\t}\n\n\tif (state->idx >= ARRAY_SIZE(ai_arr)) {\n\t\tNET_DBG(\"getaddrinfo entries overflow\");\n\t\treturn;\n\t}\n\n\tai = ai_arr + state->idx;\n\tmemcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n\tnet_sin(&ai->_ai_addr)->sin_port = state->port;\n\tai->ai_addr = &ai->_ai_addr;\n\tai->ai_addrlen = info->ai_addrlen;\n\tmemcpy(&ai->_ai_canonname, &info->ai_canonname,\n\t       sizeof(ai->_ai_canonname));\n\tai->ai_canonname = ai->_ai_canonname;\n\tai->ai_family = info->ai_family;\n\n\tif (state->hints) {\n\t\tif (state->hints->ai_socktype) {\n\t\t\tsocktype = state->hints->ai_socktype;\n\t\t}\n\t}\n\n\tproto = IPPROTO_TCP;\n\tif (socktype == SOCK_DGRAM) {\n\t\tproto = IPPROTO_UDP;\n\t}\n\n\tai->ai_socktype = socktype;\n\tai->ai_protocol = proto;\n\n\tstate->idx++;\n}",
  "abstract_func": "static void dns_resolve_cb(enum dns_resolve_status VAR_0,\n\t\t\t   struct dns_addrinfo *VAR_1, void *VAR_2)\n{\n\tstruct getaddrinfo_state *VAR_3 = VAR_2;\n\tstruct zsock_addrinfo *VAR_4;\n\tint VAR_5 = VAR_6;\n\tint VAR_7;\n\n\tNET_DBG(\"dns status: %d\", VAR_0);\n\n\tif (VAR_1 == NULL) {\n\t\tif (VAR_0 == VAR_8) {\n\t\t\tVAR_0 = 0;\n\t\t}\n\t\tVAR_3->status = VAR_0;\n\t\tk_sem_give(&VAR_3->sem);\n\t\treturn;\n\t}\n\n\tif (VAR_3->idx >= ARRAY_SIZE(VAR_9)) {\n\t\tNET_DBG(\"getaddrinfo entries overflow\");\n\t\treturn;\n\t}\n\n\tVAR_4 = VAR_9 + VAR_3->idx;\n\tmemcpy(&VAR_4->_ai_addr, &VAR_1->ai_addr, VAR_1->ai_addrlen);\n\tnet_sin(&VAR_4->_ai_addr)->sin_port = VAR_3->port;\n\tVAR_4->ai_addr = &VAR_4->_ai_addr;\n\tVAR_4->ai_addrlen = VAR_1->ai_addrlen;\n\tmemcpy(&VAR_4->_ai_canonname, &VAR_1->ai_canonname,\n\t       sizeof(VAR_4->_ai_canonname));\n\tVAR_4->ai_canonname = VAR_4->_ai_canonname;\n\tVAR_4->ai_family = VAR_1->ai_family;\n\n\tif (VAR_3->hints) {\n\t\tif (VAR_3->hints->ai_socktype) {\n\t\t\tVAR_5 = VAR_3->hints->ai_socktype;\n\t\t}\n\t}\n\n\tVAR_7 = VAR_10;\n\tif (VAR_5 == VAR_11) {\n\t\tVAR_7 = VAR_12;\n\t}\n\n\tVAR_4->ai_socktype = VAR_5;\n\tVAR_4->ai_protocol = VAR_7;\n\n\tVAR_3->idx++;\n}",
  "func_graph_path": "zephyrproject-rtos/zephyr/3953714a9b8508aca72ab93991e8468ba508aa4b/getaddrinfo.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n \t\t\t   struct dns_addrinfo *info, void *user_data)\n {\n \tstruct getaddrinfo_state *state = user_data;\n-\tstruct zsock_addrinfo *ai = ai_arr + state->idx;\n+\tstruct zsock_addrinfo *ai;\n \tint socktype = SOCK_STREAM;\n \tint proto;\n \n@@ -17,7 +17,14 @@\n \t\treturn;\n \t}\n \n+\tif (state->idx >= ARRAY_SIZE(ai_arr)) {\n+\t\tNET_DBG(\"getaddrinfo entries overflow\");\n+\t\treturn;\n+\t}\n+\n+\tai = ai_arr + state->idx;\n \tmemcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);\n+\tnet_sin(&ai->_ai_addr)->sin_port = state->port;\n \tai->ai_addr = &ai->_ai_addr;\n \tai->ai_addrlen = info->ai_addrlen;\n \tmemcpy(&ai->_ai_canonname, &info->ai_canonname,",
  "diff_line_info": {
    "deleted_lines": [
      "\tstruct zsock_addrinfo *ai = ai_arr + state->idx;"
    ],
    "added_lines": [
      "\tstruct zsock_addrinfo *ai;",
      "\tif (state->idx >= ARRAY_SIZE(ai_arr)) {",
      "\t\tNET_DBG(\"getaddrinfo entries overflow\");",
      "\t\treturn;",
      "\t}",
      "",
      "\tai = ai_arr + state->idx;",
      "\tnet_sin(&ai->_ai_addr)->sin_port = state->port;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zephyrproject-rtos/zephyr/pull/6158",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zephyrproject-rtos/zephyr/pull/6158: 403 Client Error: Forbidden for url: https://api.github.com/repos/zephyrproject-rtos/zephyr/pulls/6158",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95  \nThe patch addresses a buffer overflow in the DNS resolver, a classic security issue, and includes bounds checking to prevent overflow. This directly mitigates a security risk, making it a clear security fix."
}