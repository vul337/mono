{
  "cve_id": "CVE-2022-48257",
  "cwe_ids": [
    "CWE-Other",
    "CWE-732"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "MisterTea/EternalTerminal",
  "commit_msg": "Logfile location configurability.\n\nFixes #555",
  "commit_hash": "04e64d442adb780a126996aa910da84e6939185a",
  "git_url": "https://github.com/MisterTea/EternalTerminal/commit/04e64d442adb780a126996aa910da84e6939185a",
  "file_path": "src/terminal/TerminalServerMain.cpp",
  "func_name": "main",
  "func_before": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"logtostdout\", \"log to stdout\")                    //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",\n                              result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"),\n                              true /* appendPid */, maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
  "abstract_func_before": "int main(int VAR_0, char **VAR_1) {\n  /* COMMENT_0 */\n  el::Configurations VAR_2 = LogHandler::setupLogHandler(&VAR_0, &VAR_1);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  /* COMMENT_1 */\n  ::signal(VAR_3, et::InterruptSignalHandler);\n\n  cxxopts::Options VAR_4(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    /* COMMENT_2 */\n    VAR_4.allow_unrecognised_options();\n\n    VAR_4.add_options()             /* COMMENT_3 */\n        (\"h,help\", \"Print help\")      /* COMMENT_3 */\n        (\"version\", \"Print version\")  /* COMMENT_3 */\n        (\"port\", \"Port to listen on\",\n         cxxopts::VAR_5<int>()->default_value(\"0\"))  /* COMMENT_3 */\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::VAR_5<string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"daemon\", \"Daemonize the server\")             /* COMMENT_3 */\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::VAR_5<std::string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"logtostdout\", \"log to stdout\")                    /* COMMENT_3 */\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::VAR_5<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  /* COMMENT_3 */\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::VAR_5<int>()->default_value(\"0\"), \"LEVEL\")  /* COMMENT_3 */\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       /* COMMENT_3 */\n         cxxopts::VAR_5<std::string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::VAR_5<bool>())  /* COMMENT_3 */\n        ;\n\n    auto VAR_6 = VAR_4.parse(VAR_0, VAR_1);\n\n    if (VAR_6.count(\"help\")) {\n      CLOG(VAR_7, \"stdout\") << VAR_4.help({}) << VAR_8;\n      exit(0);\n    }\n    if (VAR_6.count(\"version\")) {\n      CLOG(VAR_7, \"stdout\") << \"et version \" << VAR_9 << VAR_8;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(VAR_6[\"verbose\"].as<int>());\n\n    if (VAR_6.count(\"daemon\")) {\n      if (DaemonCreator::create(true, VAR_6[\"pidfile\"].as<string>()) == -1) {\n        VAR_10 << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath VAR_11;\n\n    /* COMMENT_4 */\n    string VAR_12 = \"20971520\";\n\n    int VAR_13 = 0;\n    string VAR_14 = \"\";\n    bool VAR_15 = false;\n    if (VAR_6.count(\"cfgfile\")) {\n      /* COMMENT_5 */\n      CSimpleIniA VAR_16(true, false, false);\n      string VAR_17 = VAR_6[\"cfgfile\"].as<string>();\n      SI_Error VAR_18 = VAR_16.LoadFile(VAR_17.c_str());\n      if (VAR_18 == 0) {\n        if (!VAR_6.count(\"port\")) {\n          const char *VAR_19 = VAR_16.GetValue(\"Networking\", \"port\", NULL);\n          if (VAR_19) {\n            VAR_13 = stoi(VAR_19);\n          }\n        }\n\n        if (!VAR_6.count(\"bindip\")) {\n          const char *VAR_20 = VAR_16.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (VAR_20) {\n            VAR_14 = string(VAR_20);\n          }\n        }\n\n        VAR_15 = VAR_16.GetBoolValue(\"Debug\", \"telemetry\", false);\n        /* COMMENT_6 */\n        const char *VAR_21 = VAR_16.GetValue(\"Debug\", \"verbose\", NULL);\n        if (VAR_6.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(VAR_6[\"verbose\"].as<int>());\n        } else if (VAR_21) {\n          el::Loggers::setVerboseLevel(atoi(VAR_21));\n        }\n\n        const char *VAR_22 = VAR_16.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (VAR_22) {\n          const string fifoNameStr(fifoName);\n          if (!VAR_23.empty()) {\n            VAR_11.setPathOverride(VAR_23);\n          }\n        }\n\n        /* COMMENT_7 */\n        const char *VAR_24 = VAR_16.GetValue(\"Debug\", \"silent\", NULL);\n        if (VAR_24 && atoi(VAR_24) != 0) {\n          VAR_2.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n        /* COMMENT_8 */\n        const char *VAR_25 = VAR_16.GetValue(\"Debug\", \"logsize\", NULL);\n        if (VAR_25 && atoi(VAR_25) != 0) {\n          /* COMMENT_9 */\n          VAR_12 = string(VAR_25);\n        }\n\n      } else {\n        VAR_10 << \"Invalid config file: \" << VAR_17;\n      }\n    }\n\n    if (VAR_6.count(\"serverfifo\") &&\n        !VAR_6[\"serverfifo\"].as<string>().empty()) {\n      VAR_11.setPathOverride(VAR_6[\"serverfifo\"].as<string>());\n    }\n\n    if (VAR_6.count(\"port\")) {\n      VAR_13 = VAR_6[\"port\"].as<int>();\n    }\n\n    if (VAR_6.count(\"bindip\")) {\n      VAR_14 = VAR_6[\"bindip\"].as<string>();\n    }\n\n    if (VAR_6.count(\"telemetry\")) {\n      VAR_15 = VAR_6[\"telemetry\"].as<bool>();\n    }\n\n    VAR_26;\n    srand(1);\n\n    if (VAR_13 == 0) {\n      VAR_13 = 2022;\n    }\n\n    /* COMMENT_10 */\n    LogHandler::setupLogFiles(&VAR_2, GetTempDirectory(), \"etserver\",\n                              VAR_6.count(\"logtostdout\"),\n                              !VAR_6.count(\"logtostdout\"),\n                              true /* COMMENT_11 */, VAR_12);\n    /* COMMENT_12 */\n    el::Loggers::reconfigureLogger(\"default\", VAR_2);\n    /* COMMENT_13 */\n    el::Helpers::setThreadName(\"etserver-main\");\n    /* COMMENT_14 */\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        VAR_15, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    VAR_11.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> VAR_27(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> VAR_28(\n        new PipeSocketHandler());\n\n    LOG(VAR_7) << \"In child, about to start server.\";\n\n    SocketEndpoint VAR_29;\n    VAR_29.set_port(VAR_13);\n    if (VAR_14.length()) {\n      VAR_29.set_name(VAR_14);\n    }\n    SocketEndpoint VAR_30;\n    VAR_30.set_name(VAR_11.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    VAR_31.run();\n\n  } catch (cxxopts::OptionException &VAR_32) {\n    CLOG(VAR_7, \"stdout\") << \"Exception: \" << VAR_32.what() << \"\\n\" << VAR_8;\n    CLOG(VAR_7, \"stdout\") << VAR_4.help({}) << VAR_8;\n    exit(1);\n  }\n\n  /* COMMENT_15 */\n  el::Helpers::uninstallPreRollOutCallback();\n}",
  "func_graph_path_before": "MisterTea/EternalTerminal/04e64d442adb780a126996aa910da84e6939185a/TerminalServerMain.cpp/vul/before/0.json",
  "func": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>())   //\n        (\"logtostdout\", \"log to stdout\")  //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    string logDirectory = GetTempDirectory();\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n        // log file directory (TODO path validation and trailing slash cleanup)\n        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);\n        if (logdir) {\n          logDirectory = string(logdir);\n        }\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    if (result.count(\"logdir\")) {\n      logDirectory = result[\"logdir\"].as<string>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFiles(\n        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),\n        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
  "abstract_func": "int main(int VAR_0, char **VAR_1) {\n  /* COMMENT_0 */\n  el::Configurations VAR_2 = LogHandler::setupLogHandler(&VAR_0, &VAR_1);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  /* COMMENT_1 */\n  ::signal(VAR_3, et::InterruptSignalHandler);\n\n  cxxopts::Options VAR_4(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    /* COMMENT_2 */\n    VAR_4.allow_unrecognised_options();\n\n    VAR_4.add_options()             /* COMMENT_3 */\n        (\"h,help\", \"Print help\")      /* COMMENT_3 */\n        (\"version\", \"Print version\")  /* COMMENT_3 */\n        (\"port\", \"Port to listen on\",\n         cxxopts::VAR_5<int>()->default_value(\"0\"))  /* COMMENT_3 */\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::VAR_5<string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"daemon\", \"Daemonize the server\")             /* COMMENT_3 */\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::VAR_5<std::string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::VAR_5<std::string>())   /* COMMENT_3 */\n        (\"logtostdout\", \"log to stdout\")  /* COMMENT_3 */\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::VAR_5<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  /* COMMENT_3 */\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::VAR_5<int>()->default_value(\"0\"), \"LEVEL\")  /* COMMENT_3 */\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       /* COMMENT_3 */\n         cxxopts::VAR_5<std::string>()->default_value(\"\"))  /* COMMENT_3 */\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::VAR_5<bool>())  /* COMMENT_3 */\n        ;\n\n    auto VAR_6 = VAR_4.parse(VAR_0, VAR_1);\n\n    if (VAR_6.count(\"help\")) {\n      CLOG(VAR_7, \"stdout\") << VAR_4.help({}) << VAR_8;\n      exit(0);\n    }\n    if (VAR_6.count(\"version\")) {\n      CLOG(VAR_7, \"stdout\") << \"et version \" << VAR_9 << VAR_8;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(VAR_6[\"verbose\"].as<int>());\n\n    if (VAR_6.count(\"daemon\")) {\n      if (DaemonCreator::create(true, VAR_6[\"pidfile\"].as<string>()) == -1) {\n        VAR_10 << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath VAR_11;\n\n    /* COMMENT_4 */\n    string VAR_12 = \"20971520\";\n\n    int VAR_13 = 0;\n    string VAR_14 = \"\";\n    bool VAR_15 = false;\n    string VAR_16 = GetTempDirectory();\n    if (VAR_6.count(\"cfgfile\")) {\n      /* COMMENT_5 */\n      CSimpleIniA VAR_17(true, false, false);\n      string VAR_18 = VAR_6[\"cfgfile\"].as<string>();\n      SI_Error VAR_19 = VAR_17.LoadFile(VAR_18.c_str());\n      if (VAR_19 == 0) {\n        if (!VAR_6.count(\"port\")) {\n          const char *VAR_20 = VAR_17.GetValue(\"Networking\", \"port\", NULL);\n          if (VAR_20) {\n            VAR_13 = stoi(VAR_20);\n          }\n        }\n\n        if (!VAR_6.count(\"bindip\")) {\n          const char *VAR_21 = VAR_17.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (VAR_21) {\n            VAR_14 = string(VAR_21);\n          }\n        }\n\n        VAR_15 = VAR_17.GetBoolValue(\"Debug\", \"telemetry\", false);\n        /* COMMENT_6 */\n        const char *VAR_22 = VAR_17.GetValue(\"Debug\", \"verbose\", NULL);\n        if (VAR_6.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(VAR_6[\"verbose\"].as<int>());\n        } else if (VAR_22) {\n          el::Loggers::setVerboseLevel(atoi(VAR_22));\n        }\n\n        const char *VAR_23 = VAR_17.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (VAR_23) {\n          const string fifoNameStr(fifoName);\n          if (!VAR_24.empty()) {\n            VAR_11.setPathOverride(VAR_24);\n          }\n        }\n\n        /* COMMENT_7 */\n        const char *VAR_25 = VAR_17.GetValue(\"Debug\", \"silent\", NULL);\n        if (VAR_25 && atoi(VAR_25) != 0) {\n          VAR_2.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n\n        /* COMMENT_8 */\n        const char *VAR_26 = VAR_17.GetValue(\"Debug\", \"logsize\", NULL);\n        if (VAR_26 && atoi(VAR_26) != 0) {\n          /* COMMENT_9 */\n          VAR_12 = string(VAR_26);\n        }\n\n        /* COMMENT_10 */\n        const char *VAR_27 = VAR_17.GetValue(\"Debug\", \"logdirectory\", NULL);\n        if (VAR_27) {\n          VAR_16 = string(VAR_27);\n        }\n      } else {\n        VAR_10 << \"Invalid config file: \" << VAR_18;\n      }\n    }\n\n    if (VAR_6.count(\"serverfifo\") &&\n        !VAR_6[\"serverfifo\"].as<string>().empty()) {\n      VAR_11.setPathOverride(VAR_6[\"serverfifo\"].as<string>());\n    }\n\n    if (VAR_6.count(\"port\")) {\n      VAR_13 = VAR_6[\"port\"].as<int>();\n    }\n\n    if (VAR_6.count(\"bindip\")) {\n      VAR_14 = VAR_6[\"bindip\"].as<string>();\n    }\n\n    if (VAR_6.count(\"telemetry\")) {\n      VAR_15 = VAR_6[\"telemetry\"].as<bool>();\n    }\n\n    if (VAR_6.count(\"logdir\")) {\n      VAR_16 = VAR_6[\"logdir\"].as<string>();\n    }\n\n    VAR_28;\n    srand(1);\n\n    if (VAR_13 == 0) {\n      VAR_13 = 2022;\n    }\n\n    /* COMMENT_11 */\n    LogHandler::setupLogFiles(\n        &VAR_2, VAR_16, \"etserver\", VAR_6.count(\"logtostdout\"),\n        !VAR_6.count(\"logtostdout\"), true /* COMMENT_12 */, VAR_12);\n    /* COMMENT_13 */\n    el::Loggers::reconfigureLogger(\"default\", VAR_2);\n    /* COMMENT_14 */\n    el::Helpers::setThreadName(\"etserver-main\");\n    /* COMMENT_15 */\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        VAR_15, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    VAR_11.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> VAR_29(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> VAR_30(\n        new PipeSocketHandler());\n\n    LOG(VAR_7) << \"In child, about to start server.\";\n\n    SocketEndpoint VAR_31;\n    VAR_31.set_port(VAR_13);\n    if (VAR_14.length()) {\n      VAR_31.set_name(VAR_14);\n    }\n    SocketEndpoint VAR_32;\n    VAR_32.set_name(VAR_11.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    VAR_33.run();\n\n  } catch (cxxopts::OptionException &VAR_34) {\n    CLOG(VAR_7, \"stdout\") << \"Exception: \" << VAR_34.what() << \"\\n\" << VAR_8;\n    CLOG(VAR_7, \"stdout\") << VAR_4.help({}) << VAR_8;\n    exit(1);\n  }\n\n  /* COMMENT_16 */\n  el::Helpers::uninstallPreRollOutCallback();\n}",
  "func_graph_path": "MisterTea/EternalTerminal/04e64d442adb780a126996aa910da84e6939185a/TerminalServerMain.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,9 @@\n         (\"daemon\", \"Daemonize the server\")             //\n         (\"cfgfile\", \"Location of the config file\",\n          cxxopts::value<std::string>()->default_value(\"\"))  //\n-        (\"logtostdout\", \"log to stdout\")                    //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>())   //\n+        (\"logtostdout\", \"log to stdout\")  //\n         (\"pidfile\", \"Location of the pid file\",\n          cxxopts::value<std::string>()->default_value(\n              \"/var/run/etserver.pid\"))  //\n@@ -65,6 +67,7 @@\n     int port = 0;\n     string bindIp = \"\";\n     bool telemetry = false;\n+    string logDirectory = GetTempDirectory();\n     if (result.count(\"cfgfile\")) {\n       // Load the config file\n       CSimpleIniA ini(true, false, false);\n@@ -107,6 +110,7 @@\n         if (silent && atoi(silent) != 0) {\n           defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n         }\n+\n         // read log file size limit\n         const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n         if (logsize && atoi(logsize) != 0) {\n@@ -114,6 +118,11 @@\n           maxlogsize = string(logsize);\n         }\n \n+        // log file directory (TODO path validation and trailing slash cleanup)\n+        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);\n+        if (logdir) {\n+          logDirectory = string(logdir);\n+        }\n       } else {\n         STFATAL << \"Invalid config file: \" << cfgfilename;\n       }\n@@ -136,6 +145,10 @@\n       telemetry = result[\"telemetry\"].as<bool>();\n     }\n \n+    if (result.count(\"logdir\")) {\n+      logDirectory = result[\"logdir\"].as<string>();\n+    }\n+\n     GOOGLE_PROTOBUF_VERIFY_VERSION;\n     srand(1);\n \n@@ -144,10 +157,9 @@\n     }\n \n     // Set log file for etserver process here.\n-    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",\n-                              result.count(\"logtostdout\"),\n-                              !result.count(\"logtostdout\"),\n-                              true /* appendPid */, maxlogsize);\n+    LogHandler::setupLogFiles(\n+        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),\n+        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);\n     // Reconfigure default logger to apply settings above\n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
  "diff_line_info": {
    "deleted_lines": [
      "        (\"logtostdout\", \"log to stdout\")                    //",
      "    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",",
      "                              result.count(\"logtostdout\"),",
      "                              !result.count(\"logtostdout\"),",
      "                              true /* appendPid */, maxlogsize);"
    ],
    "added_lines": [
      "        (\"l,logdir\", \"Base directory for log files.\",",
      "         cxxopts::value<std::string>())   //",
      "        (\"logtostdout\", \"log to stdout\")  //",
      "    string logDirectory = GetTempDirectory();",
      "",
      "        // log file directory (TODO path validation and trailing slash cleanup)",
      "        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);",
      "        if (logdir) {",
      "          logDirectory = string(logdir);",
      "        }",
      "    if (result.count(\"logdir\")) {",
      "      logDirectory = result[\"logdir\"].as<string>();",
      "    }",
      "",
      "    LogHandler::setupLogFiles(",
      "        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),",
      "        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/MisterTea/EternalTerminal/pull/556",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/MisterTea/EternalTerminal/pull/556: 403 Client Error: Forbidden for url: https://api.github.com/repos/MisterTea/EternalTerminal/pulls/556",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis**: The commit message indicates the addition of logfile location configuration. The code diff shows the introduction of a new command-line option (`--logdir`) and corresponding configuration handling, allowing users to specify the log directory location.\n\n2. **Consistency Check**: The commit message accurately reflects the code changes. There's no ambiguity in the modifications.\n\n3. **Purpose Evaluation**: The changes are part of core functionality, enhancing the ability to configure log locations without addressing any security issues.\n\n4. **Security Vulnerability Assessment**: There's no evidence of a security risk being fixed. The patch focuses on feature enhancement rather than security.\n\n5. **Non-Security Classification**: The patch directly improves core business logic by allowing configurable log directories, fitting under \"Defect Remediation & Feature Upgrades.\"\n\n6. **Confidence Scoring**: High confidence (0.9) as the intent and changes are clear, with no security implications addressed."
}