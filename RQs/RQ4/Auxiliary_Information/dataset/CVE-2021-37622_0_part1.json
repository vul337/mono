{
  "cve_id": "CVE-2021-37622",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Make sure that read is complete to prevent infinite loop.",
  "commit_hash": "ffe5eb517dad93845e62144d8e53f52b17420ecd",
  "git_url": "https://github.com/Exiv2/exiv2/commit/ffe5eb517dad93845e62144d8e53f52b17420ecd",
  "file_path": "src/jpgimage.cpp",
  "func_name": "JpegBase::printStructure",
  "func_before": "void JpegBase::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        // Ensure that this is the correct image type\n        if (!isThisType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        Exiv2::Uint32Vector iptcDataSegs;\n\n        if (bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase) {\n            // nmonic for markers\n            std::string nm[256];\n            nm[0xd8] = \"SOI\";\n            nm[0xd9] = \"EOI\";\n            nm[0xda] = \"SOS\";\n            nm[0xdb] = \"DQT\";\n            nm[0xdd] = \"DRI\";\n            nm[0xfe] = \"COM\";\n\n            // 0xe0 .. 0xef are APPn\n            // 0xc0 .. 0xcf are SOFn (except 4)\n            nm[0xc4] = \"DHT\";\n            for (int i = 0; i <= 15; i++) {\n                char MN[16];\n                /// \\todo to be replaced by std::snprintf on master (only available in c++11)\n                sprintf(MN, \"APP%d\", i);\n                nm[0xe0 + i] = MN;\n                if (i != 4) {\n                    sprintf(MN, \"SOF%d\", i);\n                    nm[0xc0 + i] = MN;\n                }\n            }\n\n            // which markers have a length field?\n            bool mHasLength[256];\n            for (int i = 0; i < 256; i++)\n                mHasLength[i] = (i >= sof0_ && i <= sof15_) || (i >= app0_ && i <= (app0_ | 0x0F)) ||\n                                (i == dht_ || i == dqt_ || i == dri_ || i == com_ || i == sos_);\n\n            // Container for the signature\n            bool bExtXMP = false;\n            long bufRead = 0;\n            const long bufMinSize = 36;\n            DataBuf buf(bufMinSize);\n\n            // Read section marker\n            int marker = advanceToMarker();\n            if (marker < 0)\n                throw Error(kerNotAJpeg);\n\n            bool done = false;\n            bool first = true;\n            while (!done) {\n                // print marker bytes\n                if (first && bPrint) {\n                    out << \"STRUCTURE OF JPEG FILE: \" << io_->path() << std::endl;\n                    out << \" address | marker       |  length | data\" << std::endl;\n                    REPORT_MARKER;\n                }\n                first = false;\n                bool bLF = bPrint;\n\n                // Read size and signature\n                std::memset(buf.pData_, 0x0, buf.size_);\n                bufRead = io_->read(buf.pData_, bufMinSize);\n                if (io_->error())\n                    throw Error(kerFailedToReadImageData);\n                if (bufRead < 2)\n                    throw Error(kerNotAJpeg);\n                const uint16_t size = mHasLength[marker] ? getUShort(buf.pData_, bigEndian) : 0;\n                if (bPrint && mHasLength[marker])\n                    out << Internal::stringFormat(\" | %7d \", size);\n\n                // print signature for APPn\n                if (marker >= app0_ && marker <= (app0_ | 0x0F)) {\n                    // http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf p75\n                    const std::string signature =\n                        string_from_unterminated(reinterpret_cast<const char*>(buf.pData_ + 2), buf.size_ - 2);\n\n                    // 728 rmills@rmillsmbp:~/gnu/exiv2/ttt $ exiv2 -pS test/data/exiv2-bug922.jpg\n                    // STRUCTURE OF JPEG FILE: test/data/exiv2-bug922.jpg\n                    // address | marker     | length  | data\n                    //       0 | 0xd8 SOI   |       0\n                    //       2 | 0xe1 APP1  |     911 | Exif..MM.*.......%.........#....\n                    //     915 | 0xe1 APP1  |     870 | http://ns.adobe.com/xap/1.0/.<x:\n                    //    1787 | 0xe1 APP1  |   65460 | http://ns.adobe.com/xmp/extensio\n                    if (option == kpsXMP && signature.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        // extract XMP\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            std::vector<byte> xmp(size + 1);\n                            io_->read(&xmp[0], size);\n                            int start = 0;\n\n                            // http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf\n                            // if we find HasExtendedXMP, set the flag and ignore this block\n                            // the first extended block is a copy of the Standard block.\n                            // a robust implementation allows extended blocks to be out of sequence\n                            // we could implement out of sequence with a dictionary of sequence/offset\n                            // and dumping the XMP in a post read operation similar to kpsIptcErase\n                            // for the moment, dumping 'on the fly' is working fine\n                            if (!bExtXMP) {\n                                while (xmp.at(start)) {\n                                    start++;\n                                }\n                                start++;\n                                const std::string xmp_from_start = string_from_unterminated(\n                                    reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                                if (xmp_from_start.find(\"HasExtendedXMP\", start) != xmp_from_start.npos) {\n                                    start = size;  // ignore this packet, we'll get on the next time around\n                                    bExtXMP = true;\n                                }\n                            } else {\n                                start = 2 + 35 + 32 + 4 + 4;  // Adobe Spec, p19\n                            }\n\n                            out.write(reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                            bufRead = size;\n                            done = !bExtXMP;\n                        }\n                    } else if (option == kpsIccProfile && signature.compare(iccId_) == 0) {\n                        // extract ICCProfile\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);  // back to buffer (after marker)\n                            io_->seek(14 + 2, BasicIo::cur);    // step over header\n                            DataBuf icc(size - (14 + 2));\n                            io_->read(icc.pData_, icc.size_);\n                            out.write(reinterpret_cast<const char*>(icc.pData_), icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"iccProfile size = \" << icc.size_ << std::endl;\n#endif\n                            bufRead = size;\n                        }\n                    } else if (option == kpsIptcErase && signature.compare(\"Photoshop 3.0\") == 0) {\n                        // delete IPTC data segment from JPEG\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            iptcDataSegs.push_back(io_->tell());\n                            iptcDataSegs.push_back(size);\n                        }\n                    } else if (bPrint) {\n                        const size_t start = size > 0 ? 2 : 0;\n                        const size_t end = start + (size > 32 ? 32 : size);\n                        out << \"| \" << Internal::binaryToString(makeSlice(buf, start, end));\n                        if (signature.compare(iccId_) == 0) {\n                            // extract the chunk information from the buffer\n                            //\n                            // the buffer looks like this in this branch\n                            // ICC_PROFILE\\0AB\n                            // where A & B are bytes (the variables chunk & chunks)\n                            //\n                            // We cannot extract the variables A and B from the signature string, as they are beyond the\n                            // null termination (and signature ends there).\n                            // => Read the chunk info from the DataBuf directly\n                            enforce<std::out_of_range>(buf.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int chunk = buf.pData_[2 + 12];\n                            const int chunks = buf.pData_[2 + 13];\n                            out << Internal::stringFormat(\" chunk %d/%d\", chunk, chunks);\n                        }\n                    }\n\n                    // for MPF: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html\n                    // for FLIR: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html\n                    bool bFlir = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"FLIR\") == 0;\n                    bool bExif = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"Exif\") == 0;\n                    bool bMPF = option == kpsRecursive && marker == (app0_ + 2) && signature.compare(\"MPF\") == 0;\n                    bool bPS = option == kpsRecursive && signature.compare(\"Photoshop 3.0\") == 0;\n                    if (bFlir || bExif || bMPF || bPS) {\n                        // extract Exif data block which is tiff formatted\n                        if (size > 0) {\n                            out << std::endl;\n\n                            // allocate storage and current file position\n                            byte* exif = new byte[size];\n                            uint32_t restore = io_->tell();\n\n                            // copy the data to memory\n                            io_->seek(-bufRead, BasicIo::cur);\n                            io_->read(exif, size);\n                            uint32_t start = signature.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t max = (uint32_t)size - 1;\n\n                            // is this an fff block?\n                            if (bFlir) {\n                                start = 0;\n                                bFlir = false;\n                                while (start < max) {\n                                    if (std::strcmp((const char*)(exif + start), \"FFF\") == 0) {\n                                        bFlir = true;\n                                        break;\n                                    }\n                                    start++;\n                                }\n                            }\n\n                            // there is a header in FLIR, followed by a tiff block\n                            // Hunt down the tiff using brute force\n                            if (bFlir) {\n                                // FLIRFILEHEAD* pFFF = (FLIRFILEHEAD*) (exif+start) ;\n                                while (start < max) {\n                                    if (exif[start] == 'I' && exif[start + 1] == 'I')\n                                        break;\n                                    if (exif[start] == 'M' && exif[start + 1] == 'M')\n                                        break;\n                                    start++;\n                                }\n                                if (start < max)\n                                    std::cout << \"  FFF start = \" << start << std::endl;\n                                // << \" index = \" << pFFF->dwIndexOff << std::endl;\n                            }\n\n                            if (bPS) {\n                                IptcData::printStructure(out, makeSlice(exif, 0, size), depth);\n                            } else {\n                                // create a copy on write memio object with the data, then print the structure\n                                BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(exif + start, size - start));\n                                if (start < max)\n                                    printTiffStructure(*p, out, option, depth);\n                            }\n\n                            // restore and clean up\n                            io_->seek(restore, Exiv2::BasicIo::beg);\n                            delete[] exif;\n                            bLF = false;\n                        }\n                    }\n                }\n\n                // print COM marker\n                if (bPrint && marker == com_) {\n                    // size includes 2 for the two bytes for size!\n                    const int n = (size - 2) > 32 ? 32 : size - 2;\n                    // start after the two bytes\n                    out << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(buf, 2, n + 2 /* cannot overflow as n is at most size - 2 */));\n                }\n\n                // Skip the segment if the size is known\n                if (io_->seek(size - bufRead, BasicIo::cur))\n                    throw Error(kerFailedToReadImageData);\n\n                if (bLF)\n                    out << std::endl;\n\n                if (marker != sos_) {\n                    // Read the beginning of the next segment\n                    marker = advanceToMarker();\n                    enforce(marker>=0, kerNoImageInInputData);\n                    REPORT_MARKER;\n                }\n                done |= marker == eoi_ || marker == sos_;\n                if (done && bPrint)\n                    out << std::endl;\n            }\n        }\n        if (option == kpsIptcErase && iptcDataSegs.size()) {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"iptc data blocks: \" << iptcDataSegs.size() << std::endl;\n            uint32_t toggle = 0;\n            for (Uint32Vector_i i = iptcDataSegs.begin(); i != iptcDataSegs.end(); i++) {\n                std::cout << *i;\n                if (toggle++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t count = (uint32_t)iptcDataSegs.size();\n\n            // figure out which blocks to copy\n            uint64_t* pos = new uint64_t[count + 2];\n            pos[0] = 0;\n            // copy the data that is not iptc\n            Uint32Vector_i it = iptcDataSegs.begin();\n            for (uint64_t i = 0; i < count; i++) {\n                bool bOdd = (i % 2) != 0;\n                bool bEven = !bOdd;\n                pos[i + 1] = bEven ? *it : pos[i] + *it;\n                ++it;\n            }\n            pos[count + 1] = io_->size() - pos[count];\n#ifdef EXIV2_DEBUG_MESSAGES\n            for (uint64_t i = 0; i < count + 2; i++)\n                std::cout << pos[i] << \" \";\n            std::cout << std::endl;\n#endif\n            // $ dd bs=1 skip=$((0)) count=$((13164)) if=ETH0138028.jpg of=E1.jpg\n            // $ dd bs=1 skip=$((49304)) count=2000000  if=ETH0138028.jpg of=E2.jpg\n            // cat E1.jpg E2.jpg > E.jpg\n            // exiv2 -pS E.jpg\n\n            // binary copy io_ to a temporary file\n            BasicIo::AutoPtr tempIo(new MemIo);\n\n            assert(tempIo.get() != 0);\n            for (uint64_t i = 0; i < (count / 2) + 1; i++) {\n                uint64_t start = pos[2 * i] + 2;  // step JPG 2 byte marker\n                if (start == 2)\n                    start = 0;  // read the file 2 byte SOI\n                long length = (long)(pos[2 * i + 1] - start);\n                if (length) {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << start << \":\" << length << std::endl;\n#endif\n                    io_->seek(start, BasicIo::beg);\n                    DataBuf buf(length);\n                    io_->read(buf.pData_, buf.size_);\n                    tempIo->write(buf.pData_, buf.size_);\n                }\n            }\n            delete[] pos;\n\n            io_->seek(0, BasicIo::beg);\n            io_->transfer(*tempIo);  // may throw\n            io_->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
  "abstract_func_before": "void JpegBase::printStructure(std::ostream& VAR_0, PrintStructureOption VAR_1, int VAR_2)\n    {\n        if (VAR_3->open() != 0)\n            throw Error(VAR_4, VAR_3->path(), strError());\n        /* COMMENT_0 */\n        if (!isThisType(*VAR_3, false)) {\n            if (VAR_3->error() || VAR_3->eof())\n                throw Error(VAR_5);\n            throw Error(VAR_6);\n        }\n\n        bool VAR_7 = VAR_1 == VAR_8 || VAR_1 == VAR_9;\n        Exiv2::Uint32Vector VAR_10;\n\n        if (VAR_7 || VAR_1 == VAR_11 || VAR_1 == VAR_12 || VAR_1 == VAR_13) {\n            /* COMMENT_1 */\n            std::string VAR_14[256];\n            VAR_14[0xd8] = \"SOI\";\n            VAR_14[0xd9] = \"EOI\";\n            VAR_14[0xda] = \"SOS\";\n            VAR_14[0xdb] = \"DQT\";\n            VAR_14[0xdd] = \"DRI\";\n            VAR_14[0xfe] = \"COM\";\n\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            VAR_14[0xc4] = \"DHT\";\n            for (int VAR_15 = 0; VAR_15 <= 15; VAR_15++) {\n                char VAR_16[16];\n                /* COMMENT_4 */\n                sprintf(VAR_16, \"APP%d\", VAR_15);\n                VAR_14[0xe0 + VAR_15] = VAR_16;\n                if (VAR_15 != 4) {\n                    sprintf(VAR_16, \"SOF%d\", VAR_15);\n                    VAR_14[0xc0 + VAR_15] = VAR_16;\n                }\n            }\n\n            /* COMMENT_5 */\n            bool VAR_17[256];\n            for (int VAR_15 = 0; VAR_15 < 256; VAR_15++)\n                VAR_17[VAR_15] = (VAR_15 >= VAR_18 && VAR_15 <= VAR_19) || (VAR_15 >= VAR_20 && VAR_15 <= (VAR_20 | 0x0F)) ||\n                                (VAR_15 == VAR_21 || VAR_15 == VAR_22 || VAR_15 == VAR_23 || VAR_15 == VAR_24 || VAR_15 == VAR_25);\n\n            /* COMMENT_6 */\n            bool VAR_26 = false;\n            long VAR_27 = 0;\n            const long VAR_28 = 36;\n            DataBuf buf(bufMinSize);\n\n            /* COMMENT_7 */\n            int VAR_29 = advanceToMarker();\n            if (VAR_29 < 0)\n                throw Error(VAR_6);\n\n            bool VAR_30 = false;\n            bool VAR_31 = true;\n            while (!VAR_30) {\n                /* COMMENT_8 */\n                if (VAR_31 && VAR_7) {\n                    VAR_0 << \"STRUCTURE OF JPEG FILE: \" << VAR_3->path() << std::endl;\n                    VAR_0 << \" address | marker       |  length | data\" << std::endl;\n                    VAR_32;\n                }\n                VAR_31 = false;\n                bool VAR_33 = VAR_7;\n\n                /* COMMENT_9 */\n                std::memset(VAR_34.pData_, 0x0, VAR_34.size_);\n                VAR_27 = VAR_3->read(VAR_34.pData_, bufMinSize);\n                if (VAR_3->error())\n                    throw Error(VAR_5);\n                if (VAR_27 < 2)\n                    throw Error(VAR_6);\n                const uint16_t VAR_35 = VAR_17[VAR_29] ? getUShort(VAR_34.pData_, VAR_36) : 0;\n                if (VAR_7 && VAR_17[VAR_29])\n                    VAR_0 << Internal::stringFormat(\" | %7d \", VAR_35);\n\n                /* COMMENT_10 */\n                if (VAR_29 >= VAR_20 && VAR_29 <= (VAR_20 | 0x0F)) {\n                    /* COMMENT_11 */\n                    const std::string VAR_37 =\n                        string_from_unterminated(VAR_38<const char*>(VAR_34.pData_ + 2), VAR_34.size_ - 2);\n\n                    /* COMMENT_12 */\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    /* COMMENT_17 */\n                    /* COMMENT_18 */\n                    if (VAR_1 == VAR_11 && VAR_37.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        /* COMMENT_19 */\n                        if (VAR_35 > 0) {\n                            VAR_3->seek(-VAR_27, BasicIo::cur);\n                            std::vector<byte> VAR_39(VAR_35 + 1);\n                            VAR_3->read(&VAR_39[0], VAR_35);\n                            int VAR_40 = 0;\n\n                            /* COMMENT_20 */\n                            /* COMMENT_21 */\n                            /* COMMENT_22 */\n                            /* COMMENT_23 */\n                            /* COMMENT_24 */\n                            /* COMMENT_25 */\n                            /* COMMENT_26 */\n                            if (!VAR_26) {\n                                while (VAR_39.at(VAR_40)) {\n                                    VAR_40++;\n                                }\n                                VAR_40++;\n                                const std::string VAR_41 = string_from_unterminated(\n                                    VAR_38<const char*>(&VAR_39.at(VAR_40)), VAR_35 - VAR_40);\n                                if (VAR_41.find(\"HasExtendedXMP\", VAR_40) != VAR_41.npos) {\n                                    VAR_40 = VAR_35;  /* COMMENT_27 */\n                                    VAR_26 = true;\n                                }\n                            } else {\n                                VAR_40 = 2 + 35 + 32 + 4 + 4;  /* COMMENT_28 */\n                            }\n\n                            VAR_0.write(VAR_38<const char*>(&VAR_39.at(VAR_40)), VAR_35 - VAR_40);\n                            VAR_27 = VAR_35;\n                            VAR_30 = !VAR_26;\n                        }\n                    } else if (VAR_1 == VAR_12 && VAR_37.compare(VAR_42) == 0) {\n                        /* COMMENT_29 */\n                        if (VAR_35 > 0) {\n                            VAR_3->seek(-VAR_27, BasicIo::cur);  /* COMMENT_30 */\n                            VAR_3->seek(14 + 2, BasicIo::cur);    /* COMMENT_31 */\n                            DataBuf VAR_43(VAR_35 - (14 + 2));\n                            VAR_3->read(VAR_43.pData_, VAR_43.size_);\n                            VAR_0.write(VAR_38<const char*>(VAR_43.pData_), VAR_43.size_);\n#ifdef VAR_44\n                            std::cout << \"iccProfile size = \" << VAR_43.size_ << std::endl;\n#endif\n                            VAR_27 = VAR_35;\n                        }\n                    } else if (VAR_1 == VAR_13 && VAR_37.compare(\"Photoshop 3.0\") == 0) {\n                        /* COMMENT_32 */\n                        if (VAR_35 > 0) {\n                            VAR_3->seek(-VAR_27, BasicIo::cur);\n                            VAR_10.push_back(VAR_3->tell());\n                            VAR_10.push_back(VAR_35);\n                        }\n                    } else if (VAR_7) {\n                        const size_t VAR_40 = VAR_35 > 0 ? 2 : 0;\n                        const size_t VAR_45 = VAR_40 + (VAR_35 > 32 ? 32 : VAR_35);\n                        VAR_0 << \"| \" << Internal::binaryToString(makeSlice(VAR_34, VAR_40, VAR_45));\n                        if (VAR_37.compare(VAR_42) == 0) {\n                            /* COMMENT_33 */\n                            /* COMMENT_34 */\n                            /* COMMENT_35 */\n                            /* COMMENT_36 */\n                            /* COMMENT_37 */\n                            /* COMMENT_34 */\n                            /* COMMENT_38 */\n                            /* COMMENT_39 */\n                            /* COMMENT_40 */\n                            VAR_46<std::out_of_range>(VAR_34.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int VAR_47 = VAR_34.pData_[2 + 12];\n                            const int VAR_48 = VAR_34.pData_[2 + 13];\n                            VAR_0 << Internal::stringFormat(\" chunk %d/%d\", VAR_47, VAR_48);\n                        }\n                    }\n\n                    /* COMMENT_41 */\n                    /* COMMENT_42 */\n                    bool VAR_49 = VAR_1 == VAR_9 && VAR_29 == (VAR_20 + 1) && VAR_37.compare(\"FLIR\") == 0;\n                    bool VAR_50 = VAR_1 == VAR_9 && VAR_29 == (VAR_20 + 1) && VAR_37.compare(\"Exif\") == 0;\n                    bool VAR_51 = VAR_1 == VAR_9 && VAR_29 == (VAR_20 + 2) && VAR_37.compare(\"MPF\") == 0;\n                    bool VAR_52 = VAR_1 == VAR_9 && VAR_37.compare(\"Photoshop 3.0\") == 0;\n                    if (VAR_49 || VAR_50 || VAR_51 || VAR_52) {\n                        /* COMMENT_43 */\n                        if (VAR_35 > 0) {\n                            VAR_0 << std::endl;\n\n                            /* COMMENT_44 */\n                            byte* VAR_53 = new byte[VAR_35];\n                            uint32_t VAR_54 = VAR_3->tell();\n\n                            /* COMMENT_45 */\n                            VAR_3->seek(-VAR_27, BasicIo::cur);\n                            VAR_3->read(VAR_53, VAR_35);\n                            uint32_t VAR_40 = VAR_37.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t VAR_55 = (uint32_t)VAR_35 - 1;\n\n                            /* COMMENT_46 */\n                            if (VAR_49) {\n                                VAR_40 = 0;\n                                VAR_49 = false;\n                                while (VAR_40 < VAR_55) {\n                                    if (std::strcmp((const char*)(VAR_53 + VAR_40), \"FFF\") == 0) {\n                                        VAR_49 = true;\n                                        break;\n                                    }\n                                    VAR_40++;\n                                }\n                            }\n\n                            /* COMMENT_47 */\n                            /* COMMENT_48 */\n                            if (VAR_49) {\n                                /* COMMENT_49 */\n                                while (VAR_40 < VAR_55) {\n                                    if (VAR_53[VAR_40] == 'I' && VAR_53[VAR_40 + 1] == 'I')\n                                        break;\n                                    if (VAR_53[VAR_40] == 'M' && VAR_53[VAR_40 + 1] == 'M')\n                                        break;\n                                    VAR_40++;\n                                }\n                                if (VAR_40 < VAR_55)\n                                    std::cout << \"  FFF start = \" << VAR_40 << std::endl;\n                                /* COMMENT_50 */\n                            }\n\n                            if (VAR_52) {\n                                IptcData::printStructure(VAR_0, makeSlice(VAR_53, 0, VAR_35), VAR_2);\n                            } else {\n                                /* COMMENT_51 */\n                                BasicIo::AutoPtr VAR_56 = BasicIo::AutoPtr(new MemIo(VAR_53 + VAR_40, VAR_35 - VAR_40));\n                                if (VAR_40 < VAR_55)\n                                    printTiffStructure(*VAR_56, VAR_0, VAR_1, VAR_2);\n                            }\n\n                            /* COMMENT_52 */\n                            VAR_3->seek(VAR_54, Exiv2::BasicIo::beg);\n                            delete[] VAR_53;\n                            VAR_33 = false;\n                        }\n                    }\n                }\n\n                /* COMMENT_53 */\n                if (VAR_7 && VAR_29 == VAR_24) {\n                    /* COMMENT_54 */\n                    const int VAR_57 = (VAR_35 - 2) > 32 ? 32 : VAR_35 - 2;\n                    /* COMMENT_55 */\n                    VAR_0 << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(VAR_34, 2, VAR_57 + 2 /* COMMENT_56 */));\n                }\n\n                /* COMMENT_57 */\n                if (VAR_3->seek(VAR_35 - VAR_27, BasicIo::cur))\n                    throw Error(VAR_5);\n\n                if (VAR_33)\n                    VAR_0 << std::endl;\n\n                if (VAR_29 != VAR_25) {\n                    /* COMMENT_58 */\n                    VAR_29 = advanceToMarker();\n                    VAR_46(VAR_29>=0, VAR_58);\n                    VAR_32;\n                }\n                VAR_30 |= VAR_29 == VAR_59 || VAR_29 == VAR_25;\n                if (VAR_30 && VAR_7)\n                    VAR_0 << std::endl;\n            }\n        }\n        if (VAR_1 == VAR_13 && VAR_10.size()) {\n#ifdef VAR_44\n            std::cout << \"iptc data blocks: \" << VAR_10.size() << std::endl;\n            uint32_t VAR_60 = 0;\n            for (Uint32Vector_i VAR_15 = VAR_10.begin(); VAR_15 != VAR_10.end(); VAR_15++) {\n                std::cout << *VAR_15;\n                if (VAR_60++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t VAR_61 = (uint32_t)VAR_10.size();\n\n            /* COMMENT_59 */\n            uint64_t* VAR_62 = new uint64_t[VAR_61 + 2];\n            VAR_62[0] = 0;\n            /* COMMENT_60 */\n            Uint32Vector_i VAR_63 = VAR_10.begin();\n            for (uint64_t VAR_15 = 0; VAR_15 < VAR_61; VAR_15++) {\n                bool VAR_64 = (VAR_15 % 2) != 0;\n                bool VAR_65 = !VAR_64;\n                VAR_62[VAR_15 + 1] = VAR_65 ? *VAR_63 : VAR_62[VAR_15] + *VAR_63;\n                ++VAR_63;\n            }\n            VAR_62[VAR_61 + 1] = VAR_3->size() - VAR_62[VAR_61];\n#ifdef VAR_44\n            for (uint64_t VAR_15 = 0; VAR_15 < VAR_61 + 2; VAR_15++)\n                std::cout << VAR_62[VAR_15] << \" \";\n            std::cout << std::endl;\n#endif\n            /* COMMENT_61 */\n            /* COMMENT_62 */\n            /* COMMENT_63 */\n            /* COMMENT_64 */\n\n            /* COMMENT_65 */\n            BasicIo::AutoPtr VAR_66(new MemIo);\n\n            assert(VAR_66.get() != 0);\n            for (uint64_t VAR_15 = 0; VAR_15 < (VAR_61 / 2) + 1; VAR_15++) {\n                uint64_t VAR_40 = VAR_62[2 * VAR_15] + 2;  /* COMMENT_66 */\n                if (VAR_40 == 2)\n                    VAR_40 = 0;  /* COMMENT_67 */\n                long VAR_67 = (long)(VAR_62[2 * VAR_15 + 1] - VAR_40);\n                if (VAR_67) {\n#ifdef VAR_44\n                    std::cout << VAR_40 << \":\" << VAR_67 << std::endl;\n#endif\n                    VAR_3->seek(VAR_40, BasicIo::beg);\n                    DataBuf buf(length);\n                    VAR_3->read(VAR_34.pData_, VAR_34.size_);\n                    VAR_66->write(VAR_34.pData_, VAR_34.size_);\n                }\n            }\n            delete[] VAR_62;\n\n            VAR_3->seek(0, BasicIo::beg);\n            VAR_3->transfer(*VAR_66);  /* COMMENT_68 */\n            VAR_3->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
  "func_graph_path_before": "Exiv2/exiv2/ffe5eb517dad93845e62144d8e53f52b17420ecd/jpgimage.cpp/vul/before/0.json",
  "func": "void JpegBase::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        // Ensure that this is the correct image type\n        if (!isThisType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        Exiv2::Uint32Vector iptcDataSegs;\n\n        if (bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase) {\n            // nmonic for markers\n            std::string nm[256];\n            nm[0xd8] = \"SOI\";\n            nm[0xd9] = \"EOI\";\n            nm[0xda] = \"SOS\";\n            nm[0xdb] = \"DQT\";\n            nm[0xdd] = \"DRI\";\n            nm[0xfe] = \"COM\";\n\n            // 0xe0 .. 0xef are APPn\n            // 0xc0 .. 0xcf are SOFn (except 4)\n            nm[0xc4] = \"DHT\";\n            for (int i = 0; i <= 15; i++) {\n                char MN[16];\n                /// \\todo to be replaced by std::snprintf on master (only available in c++11)\n                sprintf(MN, \"APP%d\", i);\n                nm[0xe0 + i] = MN;\n                if (i != 4) {\n                    sprintf(MN, \"SOF%d\", i);\n                    nm[0xc0 + i] = MN;\n                }\n            }\n\n            // which markers have a length field?\n            bool mHasLength[256];\n            for (int i = 0; i < 256; i++)\n                mHasLength[i] = (i >= sof0_ && i <= sof15_) || (i >= app0_ && i <= (app0_ | 0x0F)) ||\n                                (i == dht_ || i == dqt_ || i == dri_ || i == com_ || i == sos_);\n\n            // Container for the signature\n            bool bExtXMP = false;\n            long bufRead = 0;\n            const long bufMinSize = 36;\n            DataBuf buf(bufMinSize);\n\n            // Read section marker\n            int marker = advanceToMarker();\n            if (marker < 0)\n                throw Error(kerNotAJpeg);\n\n            bool done = false;\n            bool first = true;\n            while (!done) {\n                // print marker bytes\n                if (first && bPrint) {\n                    out << \"STRUCTURE OF JPEG FILE: \" << io_->path() << std::endl;\n                    out << \" address | marker       |  length | data\" << std::endl;\n                    REPORT_MARKER;\n                }\n                first = false;\n                bool bLF = bPrint;\n\n                // Read size and signature\n                std::memset(buf.pData_, 0x0, buf.size_);\n                bufRead = io_->read(buf.pData_, bufMinSize);\n                if (io_->error() || bufRead != bufMinSize)\n                    throw Error(kerFailedToReadImageData);\n                if (bufRead < 2)\n                    throw Error(kerNotAJpeg);\n                const uint16_t size = mHasLength[marker] ? getUShort(buf.pData_, bigEndian) : 0;\n                if (bPrint && mHasLength[marker])\n                    out << Internal::stringFormat(\" | %7d \", size);\n\n                // print signature for APPn\n                if (marker >= app0_ && marker <= (app0_ | 0x0F)) {\n                    // http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf p75\n                    const std::string signature =\n                        string_from_unterminated(reinterpret_cast<const char*>(buf.pData_ + 2), buf.size_ - 2);\n\n                    // 728 rmills@rmillsmbp:~/gnu/exiv2/ttt $ exiv2 -pS test/data/exiv2-bug922.jpg\n                    // STRUCTURE OF JPEG FILE: test/data/exiv2-bug922.jpg\n                    // address | marker     | length  | data\n                    //       0 | 0xd8 SOI   |       0\n                    //       2 | 0xe1 APP1  |     911 | Exif..MM.*.......%.........#....\n                    //     915 | 0xe1 APP1  |     870 | http://ns.adobe.com/xap/1.0/.<x:\n                    //    1787 | 0xe1 APP1  |   65460 | http://ns.adobe.com/xmp/extensio\n                    if (option == kpsXMP && signature.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        // extract XMP\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            std::vector<byte> xmp(size + 1);\n                            io_->read(&xmp[0], size);\n                            int start = 0;\n\n                            // http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf\n                            // if we find HasExtendedXMP, set the flag and ignore this block\n                            // the first extended block is a copy of the Standard block.\n                            // a robust implementation allows extended blocks to be out of sequence\n                            // we could implement out of sequence with a dictionary of sequence/offset\n                            // and dumping the XMP in a post read operation similar to kpsIptcErase\n                            // for the moment, dumping 'on the fly' is working fine\n                            if (!bExtXMP) {\n                                while (xmp.at(start)) {\n                                    start++;\n                                }\n                                start++;\n                                const std::string xmp_from_start = string_from_unterminated(\n                                    reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                                if (xmp_from_start.find(\"HasExtendedXMP\", start) != xmp_from_start.npos) {\n                                    start = size;  // ignore this packet, we'll get on the next time around\n                                    bExtXMP = true;\n                                }\n                            } else {\n                                start = 2 + 35 + 32 + 4 + 4;  // Adobe Spec, p19\n                            }\n\n                            out.write(reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                            bufRead = size;\n                            done = !bExtXMP;\n                        }\n                    } else if (option == kpsIccProfile && signature.compare(iccId_) == 0) {\n                        // extract ICCProfile\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);  // back to buffer (after marker)\n                            io_->seek(14 + 2, BasicIo::cur);    // step over header\n                            DataBuf icc(size - (14 + 2));\n                            io_->read(icc.pData_, icc.size_);\n                            out.write(reinterpret_cast<const char*>(icc.pData_), icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"iccProfile size = \" << icc.size_ << std::endl;\n#endif\n                            bufRead = size;\n                        }\n                    } else if (option == kpsIptcErase && signature.compare(\"Photoshop 3.0\") == 0) {\n                        // delete IPTC data segment from JPEG\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            iptcDataSegs.push_back(io_->tell());\n                            iptcDataSegs.push_back(size);\n                        }\n                    } else if (bPrint) {\n                        const size_t start = size > 0 ? 2 : 0;\n                        const size_t end = start + (size > 32 ? 32 : size);\n                        out << \"| \" << Internal::binaryToString(makeSlice(buf, start, end));\n                        if (signature.compare(iccId_) == 0) {\n                            // extract the chunk information from the buffer\n                            //\n                            // the buffer looks like this in this branch\n                            // ICC_PROFILE\\0AB\n                            // where A & B are bytes (the variables chunk & chunks)\n                            //\n                            // We cannot extract the variables A and B from the signature string, as they are beyond the\n                            // null termination (and signature ends there).\n                            // => Read the chunk info from the DataBuf directly\n                            enforce<std::out_of_range>(buf.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int chunk = buf.pData_[2 + 12];\n                            const int chunks = buf.pData_[2 + 13];\n                            out << Internal::stringFormat(\" chunk %d/%d\", chunk, chunks);\n                        }\n                    }\n\n                    // for MPF: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html\n                    // for FLIR: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html\n                    bool bFlir = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"FLIR\") == 0;\n                    bool bExif = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"Exif\") == 0;\n                    bool bMPF = option == kpsRecursive && marker == (app0_ + 2) && signature.compare(\"MPF\") == 0;\n                    bool bPS = option == kpsRecursive && signature.compare(\"Photoshop 3.0\") == 0;\n                    if (bFlir || bExif || bMPF || bPS) {\n                        // extract Exif data block which is tiff formatted\n                        if (size > 0) {\n                            out << std::endl;\n\n                            // allocate storage and current file position\n                            byte* exif = new byte[size];\n                            uint32_t restore = io_->tell();\n\n                            // copy the data to memory\n                            io_->seek(-bufRead, BasicIo::cur);\n                            io_->read(exif, size);\n                            uint32_t start = signature.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t max = (uint32_t)size - 1;\n\n                            // is this an fff block?\n                            if (bFlir) {\n                                start = 0;\n                                bFlir = false;\n                                while (start < max) {\n                                    if (std::strcmp((const char*)(exif + start), \"FFF\") == 0) {\n                                        bFlir = true;\n                                        break;\n                                    }\n                                    start++;\n                                }\n                            }\n\n                            // there is a header in FLIR, followed by a tiff block\n                            // Hunt down the tiff using brute force\n                            if (bFlir) {\n                                // FLIRFILEHEAD* pFFF = (FLIRFILEHEAD*) (exif+start) ;\n                                while (start < max) {\n                                    if (exif[start] == 'I' && exif[start + 1] == 'I')\n                                        break;\n                                    if (exif[start] == 'M' && exif[start + 1] == 'M')\n                                        break;\n                                    start++;\n                                }\n                                if (start < max)\n                                    std::cout << \"  FFF start = \" << start << std::endl;\n                                // << \" index = \" << pFFF->dwIndexOff << std::endl;\n                            }\n\n                            if (bPS) {\n                                IptcData::printStructure(out, makeSlice(exif, 0, size), depth);\n                            } else {\n                                // create a copy on write memio object with the data, then print the structure\n                                BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(exif + start, size - start));\n                                if (start < max)\n                                    printTiffStructure(*p, out, option, depth);\n                            }\n\n                            // restore and clean up\n                            io_->seek(restore, Exiv2::BasicIo::beg);\n                            delete[] exif;\n                            bLF = false;\n                        }\n                    }\n                }\n\n                // print COM marker\n                if (bPrint && marker == com_) {\n                    // size includes 2 for the two bytes for size!\n                    const int n = (size - 2) > 32 ? 32 : size - 2;\n                    // start after the two bytes\n                    out << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(buf, 2, n + 2 /* cannot overflow as n is at most size - 2 */));\n                }\n\n                // Skip the segment if the size is known\n                if (io_->seek(size - bufRead, BasicIo::cur))\n                    throw Error(kerFailedToReadImageData);\n\n                if (bLF)\n                    out << std::endl;\n\n                if (marker != sos_) {\n                    // Read the beginning of the next segment\n                    marker = advanceToMarker();\n                    enforce(marker>=0, kerNoImageInInputData);\n                    REPORT_MARKER;\n                }\n                done |= marker == eoi_ || marker == sos_;\n                if (done && bPrint)\n                    out << std::endl;\n            }\n        }\n        if (option == kpsIptcErase && iptcDataSegs.size()) {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"iptc data blocks: \" << iptcDataSegs.size() << std::endl;\n            uint32_t toggle = 0;\n            for (Uint32Vector_i i = iptcDataSegs.begin(); i != iptcDataSegs.end(); i++) {\n                std::cout << *i;\n                if (toggle++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t count = (uint32_t)iptcDataSegs.size();\n\n            // figure out which blocks to copy\n            uint64_t* pos = new uint64_t[count + 2];\n            pos[0] = 0;\n            // copy the data that is not iptc\n            Uint32Vector_i it = iptcDataSegs.begin();\n            for (uint64_t i = 0; i < count; i++) {\n                bool bOdd = (i % 2) != 0;\n                bool bEven = !bOdd;\n                pos[i + 1] = bEven ? *it : pos[i] + *it;\n                ++it;\n            }\n            pos[count + 1] = io_->size() - pos[count];\n#ifdef EXIV2_DEBUG_MESSAGES\n            for (uint64_t i = 0; i < count + 2; i++)\n                std::cout << pos[i] << \" \";\n            std::cout << std::endl;\n#endif\n            // $ dd bs=1 skip=$((0)) count=$((13164)) if=ETH0138028.jpg of=E1.jpg\n            // $ dd bs=1 skip=$((49304)) count=2000000  if=ETH0138028.jpg of=E2.jpg\n            // cat E1.jpg E2.jpg > E.jpg\n            // exiv2 -pS E.jpg\n\n            // binary copy io_ to a temporary file\n            BasicIo::AutoPtr tempIo(new MemIo);\n\n            assert(tempIo.get() != 0);\n            for (uint64_t i = 0; i < (count / 2) + 1; i++) {\n                uint64_t start = pos[2 * i] + 2;  // step JPG 2 byte marker\n                if (start == 2)\n                    start = 0;  // read the file 2 byte SOI\n                long length = (long)(pos[2 * i + 1] - start);\n                if (length) {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << start << \":\" << length << std::endl;\n#endif\n                    io_->seek(start, BasicIo::beg);\n                    DataBuf buf(length);\n                    io_->read(buf.pData_, buf.size_);\n                    tempIo->write(buf.pData_, buf.size_);\n                }\n            }\n            delete[] pos;\n\n            io_->seek(0, BasicIo::beg);\n            io_->transfer(*tempIo);  // may throw\n            io_->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
  "abstract_func": "void JpegBase::printStructure(std::ostream& VAR_0, PrintStructureOption VAR_1, int VAR_2)\n    {\n        if (VAR_3->open() != 0)\n            throw Error(VAR_4, VAR_3->path(), strError());\n        /* COMMENT_0 */\n        if (!isThisType(*VAR_3, false)) {\n            if (VAR_3->error() || VAR_3->eof())\n                throw Error(VAR_5);\n            throw Error(VAR_6);\n        }\n\n        bool VAR_7 = VAR_1 == VAR_8 || VAR_1 == VAR_9;\n        Exiv2::Uint32Vector VAR_10;\n\n        if (VAR_7 || VAR_1 == VAR_11 || VAR_1 == VAR_12 || VAR_1 == VAR_13) {\n            /* COMMENT_1 */\n            std::string VAR_14[256];\n            VAR_14[0xd8] = \"SOI\";\n            VAR_14[0xd9] = \"EOI\";\n            VAR_14[0xda] = \"SOS\";\n            VAR_14[0xdb] = \"DQT\";\n            VAR_14[0xdd] = \"DRI\";\n            VAR_14[0xfe] = \"COM\";\n\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            VAR_14[0xc4] = \"DHT\";\n            for (int VAR_15 = 0; VAR_15 <= 15; VAR_15++) {\n                char VAR_16[16];\n                /* COMMENT_4 */\n                sprintf(VAR_16, \"APP%d\", VAR_15);\n                VAR_14[0xe0 + VAR_15] = VAR_16;\n                if (VAR_15 != 4) {\n                    sprintf(VAR_16, \"SOF%d\", VAR_15);\n                    VAR_14[0xc0 + VAR_15] = VAR_16;\n                }\n            }\n\n            /* COMMENT_5 */\n            bool VAR_17[256];\n            for (int VAR_15 = 0; VAR_15 < 256; VAR_15++)\n                VAR_17[VAR_15] = (VAR_15 >= VAR_18 && VAR_15 <= VAR_19) || (VAR_15 >= VAR_20 && VAR_15 <= (VAR_20 | 0x0F)) ||\n                                (VAR_15 == VAR_21 || VAR_15 == VAR_22 || VAR_15 == VAR_23 || VAR_15 == VAR_24 || VAR_15 == VAR_25);\n\n            /* COMMENT_6 */\n            bool VAR_26 = false;\n            long VAR_27 = 0;\n            const long VAR_28 = 36;\n            DataBuf buf(bufMinSize);\n\n            /* COMMENT_7 */\n            int VAR_29 = advanceToMarker();\n            if (VAR_29 < 0)\n                throw Error(VAR_6);\n\n            bool VAR_30 = false;\n            bool VAR_31 = true;\n            while (!VAR_30) {\n                /* COMMENT_8 */\n                if (VAR_31 && VAR_7) {\n                    VAR_0 << \"STRUCTURE OF JPEG FILE: \" << VAR_3->path() << std::endl;\n                    VAR_0 << \" address | marker       |  length | data\" << std::endl;\n                    VAR_32;\n                }\n                VAR_31 = false;\n                bool VAR_33 = VAR_7;\n\n                /* COMMENT_9 */\n                std::memset(VAR_34.pData_, 0x0, VAR_34.size_);\n                VAR_27 = VAR_3->read(VAR_34.pData_, bufMinSize);\n                if (VAR_3->error() || VAR_27 != bufMinSize)\n                    throw Error(VAR_5);\n                if (VAR_27 < 2)\n                    throw Error(VAR_6);\n                const uint16_t VAR_35 = VAR_17[VAR_29] ? getUShort(VAR_34.pData_, VAR_36) : 0;\n                if (VAR_7 && VAR_17[VAR_29])\n                    VAR_0 << Internal::stringFormat(\" | %7d \", VAR_35);\n\n                /* COMMENT_10 */\n                if (VAR_29 >= VAR_20 && VAR_29 <= (VAR_20 | 0x0F)) {\n                    /* COMMENT_11 */\n                    const std::string VAR_37 =\n                        string_from_unterminated(VAR_38<const char*>(VAR_34.pData_ + 2), VAR_34.size_ - 2);\n\n                    /* COMMENT_12 */\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    /* COMMENT_17 */\n                    /* COMMENT_18 */\n                    if (VAR_1 == VAR_11 && VAR_37.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        /* COMMENT_19 */\n                        if (VAR_35 > 0) {\n                            VAR_3->seek(-VAR_27, BasicIo::cur);\n                            std::vector<byte> VAR_39(VAR_35 + 1);\n                            VAR_3->read(&VAR_39[0], VAR_35);\n                            int VAR_40 = 0;\n\n                            /* COMMENT_20 */\n                            /* COMMENT_21 */\n                            /* COMMENT_22 */\n                            /* COMMENT_23 */\n                            /* COMMENT_24 */\n                            /* COMMENT_25 */\n                            /* COMMENT_26 */\n                            if (!VAR_26) {\n                                while (VAR_39.at(VAR_40)) {\n                                    VAR_40++;\n                                }\n                                VAR_40++;\n                                const std::string VAR_41 = string_from_unterminated(\n                                    VAR_38<const char*>(&VAR_39.at(VAR_40)), VAR_35 - VAR_40);\n                                if (VAR_41.find(\"HasExtendedXMP\", VAR_40) != VAR_41.npos) {\n                                    VAR_40 = VAR_35;  /* COMMENT_27 */\n                                    VAR_26 = true;\n                                }\n                            } else {\n                                VAR_40 = 2 + 35 + 32 + 4 + 4;  /* COMMENT_28 */\n                            }\n\n                            VAR_0.write(VAR_38<const char*>(&VAR_39.at(VAR_40)), VAR_35 - VAR_40);\n                            VAR_27 = VAR_35;\n                            VAR_30 = !VAR_26;\n                        }\n                    } else if (VAR_1 == VAR_12 && VAR_37.compare(VAR_42) == 0) {\n                        /* COMMENT_29 */\n                        if (VAR_35 > 0) {\n                            VAR_3->seek(-VAR_27, BasicIo::cur);  /* COMMENT_30 */\n                            VAR_3->seek(14 + 2, BasicIo::cur);    /* COMMENT_31 */\n                            DataBuf VAR_43(VAR_35 - (14 + 2));\n                            VAR_3->read(VAR_43.pData_, VAR_43.size_);\n                            VAR_0.write(VAR_38<const char*>(VAR_43.pData_), VAR_43.size_);\n#ifdef VAR_44\n                            std::cout << \"iccProfile size = \" << VAR_43.size_ << std::endl;\n#endif\n                            VAR_27 = VAR_35;\n                        }\n                    } else if (VAR_1 == VAR_13 && VAR_37.compare(\"Photoshop 3.0\") == 0) {\n                        /* COMMENT_32 */\n                        if (VAR_35 > 0) {\n                            VAR_3->seek(-VAR_27, BasicIo::cur);\n                            VAR_10.push_back(VAR_3->tell());\n                            VAR_10.push_back(VAR_35);\n                        }\n                    } else if (VAR_7) {\n                        const size_t VAR_40 = VAR_35 > 0 ? 2 : 0;\n                        const size_t VAR_45 = VAR_40 + (VAR_35 > 32 ? 32 : VAR_35);\n                        VAR_0 << \"| \" << Internal::binaryToString(makeSlice(VAR_34, VAR_40, VAR_45));\n                        if (VAR_37.compare(VAR_42) == 0) {\n                            /* COMMENT_33 */\n                            /* COMMENT_34 */\n                            /* COMMENT_35 */\n                            /* COMMENT_36 */\n                            /* COMMENT_37 */\n                            /* COMMENT_34 */\n                            /* COMMENT_38 */\n                            /* COMMENT_39 */\n                            /* COMMENT_40 */\n                            VAR_46<std::out_of_range>(VAR_34.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int VAR_47 = VAR_34.pData_[2 + 12];\n                            const int VAR_48 = VAR_34.pData_[2 + 13];\n                            VAR_0 << Internal::stringFormat(\" chunk %d/%d\", VAR_47, VAR_48);\n                        }\n                    }\n\n                    /* COMMENT_41 */\n                    /* COMMENT_42 */\n                    bool VAR_49 = VAR_1 == VAR_9 && VAR_29 == (VAR_20 + 1) && VAR_37.compare(\"FLIR\") == 0;\n                    bool VAR_50 = VAR_1 == VAR_9 && VAR_29 == (VAR_20 + 1) && VAR_37.compare(\"Exif\") == 0;\n                    bool VAR_51 = VAR_1 == VAR_9 && VAR_29 == (VAR_20 + 2) && VAR_37.compare(\"MPF\") == 0;\n                    bool VAR_52 = VAR_1 == VAR_9 && VAR_37.compare(\"Photoshop 3.0\") == 0;\n                    if (VAR_49 || VAR_50 || VAR_51 || VAR_52) {\n                        /* COMMENT_43 */\n                        if (VAR_35 > 0) {\n                            VAR_0 << std::endl;\n\n                            /* COMMENT_44 */\n                            byte* VAR_53 = new byte[VAR_35];\n                            uint32_t VAR_54 = VAR_3->tell();\n\n                            /* COMMENT_45 */\n                            VAR_3->seek(-VAR_27, BasicIo::cur);\n                            VAR_3->read(VAR_53, VAR_35);\n                            uint32_t VAR_40 = VAR_37.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t VAR_55 = (uint32_t)VAR_35 - 1;\n\n                            /* COMMENT_46 */\n                            if (VAR_49) {\n                                VAR_40 = 0;\n                                VAR_49 = false;\n                                while (VAR_40 < VAR_55) {\n                                    if (std::strcmp((const char*)(VAR_53 + VAR_40), \"FFF\") == 0) {\n                                        VAR_49 = true;\n                                        break;\n                                    }\n                                    VAR_40++;\n                                }\n                            }\n\n                            /* COMMENT_47 */\n                            /* COMMENT_48 */\n                            if (VAR_49) {\n                                /* COMMENT_49 */\n                                while (VAR_40 < VAR_55) {\n                                    if (VAR_53[VAR_40] == 'I' && VAR_53[VAR_40 + 1] == 'I')\n                                        break;\n                                    if (VAR_53[VAR_40] == 'M' && VAR_53[VAR_40 + 1] == 'M')\n                                        break;\n                                    VAR_40++;\n                                }\n                                if (VAR_40 < VAR_55)\n                                    std::cout << \"  FFF start = \" << VAR_40 << std::endl;\n                                /* COMMENT_50 */\n                            }\n\n                            if (VAR_52) {\n                                IptcData::printStructure(VAR_0, makeSlice(VAR_53, 0, VAR_35), VAR_2);\n                            } else {\n                                /* COMMENT_51 */\n                                BasicIo::AutoPtr VAR_56 = BasicIo::AutoPtr(new MemIo(VAR_53 + VAR_40, VAR_35 - VAR_40));\n                                if (VAR_40 < VAR_55)\n                                    printTiffStructure(*VAR_56, VAR_0, VAR_1, VAR_2);\n                            }\n\n                            /* COMMENT_52 */\n                            VAR_3->seek(VAR_54, Exiv2::BasicIo::beg);\n                            delete[] VAR_53;\n                            VAR_33 = false;\n                        }\n                    }\n                }\n\n                /* COMMENT_53 */\n                if (VAR_7 && VAR_29 == VAR_24) {\n                    /* COMMENT_54 */\n                    const int VAR_57 = (VAR_35 - 2) > 32 ? 32 : VAR_35 - 2;\n                    /* COMMENT_55 */\n                    VAR_0 << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(VAR_34, 2, VAR_57 + 2 /* COMMENT_56 */));\n                }\n\n                /* COMMENT_57 */\n                if (VAR_3->seek(VAR_35 - VAR_27, BasicIo::cur))\n                    throw Error(VAR_5);\n\n                if (VAR_33)\n                    VAR_0 << std::endl;\n\n                if (VAR_29 != VAR_25) {\n                    /* COMMENT_58 */\n                    VAR_29 = advanceToMarker();\n                    VAR_46(VAR_29>=0, VAR_58);\n                    VAR_32;\n                }\n                VAR_30 |= VAR_29 == VAR_59 || VAR_29 == VAR_25;\n                if (VAR_30 && VAR_7)\n                    VAR_0 << std::endl;\n            }\n        }\n        if (VAR_1 == VAR_13 && VAR_10.size()) {\n#ifdef VAR_44\n            std::cout << \"iptc data blocks: \" << VAR_10.size() << std::endl;\n            uint32_t VAR_60 = 0;\n            for (Uint32Vector_i VAR_15 = VAR_10.begin(); VAR_15 != VAR_10.end(); VAR_15++) {\n                std::cout << *VAR_15;\n                if (VAR_60++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t VAR_61 = (uint32_t)VAR_10.size();\n\n            /* COMMENT_59 */\n            uint64_t* VAR_62 = new uint64_t[VAR_61 + 2];\n            VAR_62[0] = 0;\n            /* COMMENT_60 */\n            Uint32Vector_i VAR_63 = VAR_10.begin();\n            for (uint64_t VAR_15 = 0; VAR_15 < VAR_61; VAR_15++) {\n                bool VAR_64 = (VAR_15 % 2) != 0;\n                bool VAR_65 = !VAR_64;\n                VAR_62[VAR_15 + 1] = VAR_65 ? *VAR_63 : VAR_62[VAR_15] + *VAR_63;\n                ++VAR_63;\n            }\n            VAR_62[VAR_61 + 1] = VAR_3->size() - VAR_62[VAR_61];\n#ifdef VAR_44\n            for (uint64_t VAR_15 = 0; VAR_15 < VAR_61 + 2; VAR_15++)\n                std::cout << VAR_62[VAR_15] << \" \";\n            std::cout << std::endl;\n#endif\n            /* COMMENT_61 */\n            /* COMMENT_62 */\n            /* COMMENT_63 */\n            /* COMMENT_64 */\n\n            /* COMMENT_65 */\n            BasicIo::AutoPtr VAR_66(new MemIo);\n\n            assert(VAR_66.get() != 0);\n            for (uint64_t VAR_15 = 0; VAR_15 < (VAR_61 / 2) + 1; VAR_15++) {\n                uint64_t VAR_40 = VAR_62[2 * VAR_15] + 2;  /* COMMENT_66 */\n                if (VAR_40 == 2)\n                    VAR_40 = 0;  /* COMMENT_67 */\n                long VAR_67 = (long)(VAR_62[2 * VAR_15 + 1] - VAR_40);\n                if (VAR_67) {\n#ifdef VAR_44\n                    std::cout << VAR_40 << \":\" << VAR_67 << std::endl;\n#endif\n                    VAR_3->seek(VAR_40, BasicIo::beg);\n                    DataBuf buf(length);\n                    VAR_3->read(VAR_34.pData_, VAR_34.size_);\n                    VAR_66->write(VAR_34.pData_, VAR_34.size_);\n                }\n            }\n            delete[] VAR_62;\n\n            VAR_3->seek(0, BasicIo::beg);\n            VAR_3->transfer(*VAR_66);  /* COMMENT_68 */\n            VAR_3->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
  "func_graph_path": "Exiv2/exiv2/ffe5eb517dad93845e62144d8e53f52b17420ecd/jpgimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,7 @@\n                 // Read size and signature\n                 std::memset(buf.pData_, 0x0, buf.size_);\n                 bufRead = io_->read(buf.pData_, bufMinSize);\n-                if (io_->error())\n+                if (io_->error() || bufRead != bufMinSize)\n                     throw Error(kerFailedToReadImageData);\n                 if (bufRead < 2)\n                     throw Error(kerNotAJpeg);",
  "diff_line_info": {
    "deleted_lines": [
      "                if (io_->error())"
    ],
    "added_lines": [
      "                if (io_->error() || bufRead != bufMinSize)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sridharb1/exiv2/pull/4: 403 Client Error: Forbidden for url: https://api.github.com/repos/sridharb1/exiv2/pulls/4",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8"
}