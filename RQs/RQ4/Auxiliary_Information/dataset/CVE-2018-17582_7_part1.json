{
  "cve_id": "CVE-2018-17582",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files\n\n* Check for packets that are larger than 262144 bytes\n* Check for capture lengths that are greater than packet length\n\nExample of a corrupt PCAP file ...\n\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144",
  "commit_hash": "68f67b1a3a4d319543692afb5bd5b191ec984287",
  "git_url": "https://github.com/appneta/tcpreplay/commit/68f67b1a3a4d319543692afb5bd5b191ec984287",
  "file_path": "src/tcpliveplay.c",
  "func_name": "rewrite",
  "func_before": "int\nrewrite(input_addr* new_remoteip, struct mac_addr* new_remotemac, input_addr* myip, struct mac_addr* mymac, char* file, unsigned int new_src_port)\n{\n\n    ether_hdr* etherhdr; \n    ipv4_hdr *iphdr;\n    tcp_hdr *tcphdr;\n    input_addr local_ip; \n    input_addr remote_ip; \n    unsigned int size_ip;\n    unsigned int size_tcp; \n    char* newfile = \"newfile.pcap\";\n    char ErrBuff [1024];\n    int pkt_counter;\n    const u_char *packet;\n    struct pcap_pkthdr *header;\n    pcap_dumper_t *dumpfile;\n    input_addr sip;  /* Source IP */ \n    unsigned int flags;\n    int local_packets = 0;\n    bool initstep1 = false;  /* keep track of successful handshake step */\n    bool warned = false;\n\n    local_ip.byte1=0;\n    local_ip.byte2=0;\n    local_ip.byte3=0;\n    local_ip.byte4=0;\n\n    remote_ip.byte1=0;\n    remote_ip.byte2=0;\n    remote_ip.byte3=0;\n    remote_ip.byte4=0;\n\n    pcap_t *pcap = set_offline_filter(file); \n    if (!pcap){\n        fprintf (stderr, \"Cannot open PCAP file '%s' for reading\\n\", file);\n        fprintf(stderr, \"%s\\n\",ErrBuff);\n        return PCAP_OPEN_ERROR;\n    }\n\n    dumpfile = pcap_dump_open(pcap, newfile);\n    if (!dumpfile) {\n        fprintf (stderr, \"Cannot open PCAP file '%s' for writing\\n\", newfile);\n        return PCAP_OPEN_ERROR;\n    }\n\n    /*Modify each packet's IP & MAC based on the passed args then do a checksum of each packet*/\n    for (pkt_counter = 0; pcap_next_ex(pcap, &header, &packet) > 0; pkt_counter++){\n\n        if (!warned && header->len > header->caplen) {\n            fprintf(stderr, \"warning: packet capture truncated to %d byte packets\\n\",\n                    header->caplen);\n            warned = true;\n        }\n        etherhdr = (ether_hdr*)(packet);\n        iphdr = (ipv4_hdr *)(packet + SIZE_ETHERNET);\n        size_ip = iphdr->ip_hl << 2; \n        if (size_ip < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", size_ip);\n            return ERROR;\n        }\n        tcphdr = (tcp_hdr *)(packet + SIZE_ETHERNET + size_ip);\n        size_tcp = tcphdr->th_off*4;\n        if (size_tcp < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", size_tcp);\n            return ERROR;\n        }\n        /* payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp); */\n\n        sip = iphdr->ip_src;\n        flags = tcphdr->th_flags;\n\n        /* set IPs who's local and who's remote based on the SYN flag */\n        if(flags == TH_SYN){\n            local_ip = iphdr->ip_src; \n            remote_ip = iphdr->ip_dst; \n            initstep1 = true; /* This flag is set to signify the first encounter of the SYN within the pacp*/\n        }\n\n        if(compip(&local_ip, &remote_ip, &sip)==LOCAL_IP_MATCH){\n            /* Set the source MAC */\n            etherhdr->ether_shost[0] = mymac->byte1;\n            etherhdr->ether_shost[1] = mymac->byte2;\n            etherhdr->ether_shost[2] = mymac->byte3;\n            etherhdr->ether_shost[3] = mymac->byte4;\n            etherhdr->ether_shost[4] = mymac->byte5;\n            etherhdr->ether_shost[5] = mymac->byte6;\n\n            /* Set the source IP */\n            iphdr->ip_src = *myip;\n            /* Set the destination IP */\n            iphdr->ip_dst = *new_remoteip;\n\n            /* Set the destination MAC */\n            etherhdr->ether_dhost[0] = new_remotemac->byte1;\n            etherhdr->ether_dhost[1] = new_remotemac->byte2;\n            etherhdr->ether_dhost[2] = new_remotemac->byte3;\n            etherhdr->ether_dhost[3] = new_remotemac->byte4;\n            etherhdr->ether_dhost[4] = new_remotemac->byte5;\n            etherhdr->ether_dhost[5] = new_remotemac->byte6;\n\n            /* This is to change the source port, whether it is specified as random or as a port # by the user */\n            tcphdr->th_sport = htons(new_src_port);\n        }\n        else if(compip(&local_ip, &remote_ip, &sip)==REMOTE_IP_MATCH){\n\n            /* Set the destination MAC */\n            etherhdr->ether_dhost[0] = mymac->byte1;\n            etherhdr->ether_dhost[1] = mymac->byte2;\n            etherhdr->ether_dhost[2] = mymac->byte3;\n            etherhdr->ether_dhost[3] = mymac->byte4;\n            etherhdr->ether_dhost[4] = mymac->byte5;\n            etherhdr->ether_dhost[5] = mymac->byte6;\n            /* Set the destination IP */\n            iphdr->ip_dst = *myip;\n            /* Set the source IP */\n            iphdr->ip_src = *new_remoteip;\n            /* Set the source MAC */\n            etherhdr->ether_shost[0] = new_remotemac->byte1;\n            etherhdr->ether_shost[1] = new_remotemac->byte2;\n            etherhdr->ether_shost[2] = new_remotemac->byte3;\n            etherhdr->ether_shost[3] = new_remotemac->byte4;\n            etherhdr->ether_shost[4] = new_remotemac->byte5;\n            etherhdr->ether_shost[5] = new_remotemac->byte6;\n\n            /* This is to change the source port, whether it is specified as random or as a port # by the user */\n            tcphdr->th_dport = htons(new_src_port);\n        }\n\n        /*Calculate & fix checksum for newly edited-packet*/\n        fix_all_checksum_liveplay(iphdr);\n\n        if(initstep1){ /*only start rewriting new pcap with SYN packets on wards*/\n            local_packets ++;\n            pcap_dump((u_char *)dumpfile, header, packet);\n        }\n    } /* end of while loop */\n\n    pcap_close (pcap);\n    pcap_dump_close(dumpfile);\n    return local_packets;\n}",
  "abstract_func_before": "int\nrewrite(input_addr* VAR_0, struct mac_addr* VAR_1, input_addr* VAR_2, struct mac_addr* VAR_3, char* VAR_4, unsigned int VAR_5)\n{\n\n    ether_hdr* VAR_6; \n    ipv4_hdr *VAR_7;\n    tcp_hdr *VAR_8;\n    input_addr VAR_9; \n    input_addr VAR_10; \n    unsigned int VAR_11;\n    unsigned int VAR_12; \n    char* VAR_13 = \"newfile.pcap\";\n    char VAR_14 [1024];\n    int VAR_15;\n    const u_char *VAR_16;\n    struct pcap_pkthdr *VAR_17;\n    pcap_dumper_t *VAR_18;\n    input_addr VAR_19;  /* COMMENT_0 */ \n    unsigned int VAR_20;\n    int VAR_21 = 0;\n    bool VAR_22 = false;  /* COMMENT_1 */\n    bool VAR_23 = false;\n\n    VAR_9.byte1=0;\n    VAR_9.byte2=0;\n    VAR_9.byte3=0;\n    VAR_9.byte4=0;\n\n    VAR_10.byte1=0;\n    VAR_10.byte2=0;\n    VAR_10.byte3=0;\n    VAR_10.byte4=0;\n\n    pcap_t *VAR_24 = set_offline_filter(VAR_4); \n    if (!VAR_24){\n        fprintf (VAR_25, \"Cannot open PCAP file '%s' for reading\\n\", VAR_4);\n        fprintf(VAR_25, \"%s\\n\",VAR_14);\n        return VAR_26;\n    }\n\n    VAR_18 = pcap_dump_open(VAR_24, VAR_13);\n    if (!VAR_18) {\n        fprintf (VAR_25, \"Cannot open PCAP file '%s' for writing\\n\", VAR_13);\n        return VAR_26;\n    }\n\n    /* COMMENT_2 */\n    for (VAR_15 = 0; pcap_next_ex(VAR_24, &VAR_17, &VAR_16) > 0; VAR_15++){\n\n        if (!VAR_23 && VAR_17->len > VAR_17->caplen) {\n            fprintf(VAR_25, \"warning: packet capture truncated to %d byte packets\\n\",\n                    VAR_17->caplen);\n            VAR_23 = true;\n        }\n        VAR_6 = (ether_hdr*)(VAR_16);\n        VAR_7 = (ipv4_hdr *)(VAR_16 + VAR_27);\n        VAR_11 = VAR_7->ip_hl << 2; \n        if (VAR_11 < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", VAR_11);\n            return VAR_28;\n        }\n        VAR_8 = (tcp_hdr *)(VAR_16 + VAR_27 + VAR_11);\n        VAR_12 = VAR_8->th_off*4;\n        if (VAR_12 < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", VAR_12);\n            return VAR_28;\n        }\n        /* COMMENT_3 */\n\n        VAR_19 = VAR_7->ip_src;\n        VAR_20 = VAR_8->th_flags;\n\n        /* COMMENT_4 */\n        if(VAR_20 == VAR_29){\n            VAR_9 = VAR_7->ip_src; \n            VAR_10 = VAR_7->ip_dst; \n            VAR_22 = true; /* COMMENT_5 */\n        }\n\n        if(compip(&VAR_9, &VAR_10, &VAR_19)==VAR_30){\n            /* COMMENT_6 */\n            VAR_6->ether_shost[0] = VAR_3->byte1;\n            VAR_6->ether_shost[1] = VAR_3->byte2;\n            VAR_6->ether_shost[2] = VAR_3->byte3;\n            VAR_6->ether_shost[3] = VAR_3->byte4;\n            VAR_6->ether_shost[4] = VAR_3->byte5;\n            VAR_6->ether_shost[5] = VAR_3->byte6;\n\n            /* COMMENT_7 */\n            VAR_7->ip_src = *VAR_2;\n            /* COMMENT_8 */\n            VAR_7->ip_dst = *VAR_0;\n\n            /* COMMENT_9 */\n            VAR_6->ether_dhost[0] = VAR_1->byte1;\n            VAR_6->ether_dhost[1] = VAR_1->byte2;\n            VAR_6->ether_dhost[2] = VAR_1->byte3;\n            VAR_6->ether_dhost[3] = VAR_1->byte4;\n            VAR_6->ether_dhost[4] = VAR_1->byte5;\n            VAR_6->ether_dhost[5] = VAR_1->byte6;\n\n            /* COMMENT_10 */\n            VAR_8->th_sport = htons(VAR_5);\n        }\n        else if(compip(&VAR_9, &VAR_10, &VAR_19)==VAR_31){\n\n            /* COMMENT_9 */\n            VAR_6->ether_dhost[0] = VAR_3->byte1;\n            VAR_6->ether_dhost[1] = VAR_3->byte2;\n            VAR_6->ether_dhost[2] = VAR_3->byte3;\n            VAR_6->ether_dhost[3] = VAR_3->byte4;\n            VAR_6->ether_dhost[4] = VAR_3->byte5;\n            VAR_6->ether_dhost[5] = VAR_3->byte6;\n            /* COMMENT_8 */\n            VAR_7->ip_dst = *VAR_2;\n            /* COMMENT_7 */\n            VAR_7->ip_src = *VAR_0;\n            /* COMMENT_6 */\n            VAR_6->ether_shost[0] = VAR_1->byte1;\n            VAR_6->ether_shost[1] = VAR_1->byte2;\n            VAR_6->ether_shost[2] = VAR_1->byte3;\n            VAR_6->ether_shost[3] = VAR_1->byte4;\n            VAR_6->ether_shost[4] = VAR_1->byte5;\n            VAR_6->ether_shost[5] = VAR_1->byte6;\n\n            /* COMMENT_10 */\n            VAR_8->th_dport = htons(VAR_5);\n        }\n\n        /* COMMENT_11 */\n        fix_all_checksum_liveplay(VAR_7);\n\n        if(VAR_22){ /* COMMENT_12 */\n            VAR_21 ++;\n            pcap_dump((u_char *)VAR_18, VAR_17, VAR_16);\n        }\n    } /* COMMENT_13 */\n\n    pcap_close (VAR_24);\n    pcap_dump_close(VAR_18);\n    return VAR_21;\n}",
  "func_graph_path_before": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcpliveplay.c/vul/before/0.json",
  "func": "int\nrewrite(input_addr* new_remoteip, struct mac_addr* new_remotemac, input_addr* myip, struct mac_addr* mymac, char* file, unsigned int new_src_port)\n{\n\n    ether_hdr* etherhdr; \n    ipv4_hdr *iphdr;\n    tcp_hdr *tcphdr;\n    input_addr local_ip; \n    input_addr remote_ip; \n    unsigned int size_ip;\n    unsigned int size_tcp; \n    char* newfile = \"newfile.pcap\";\n    char ErrBuff [1024];\n    int pkt_counter;\n    const u_char *packet;\n    struct pcap_pkthdr *header;\n    pcap_dumper_t *dumpfile;\n    input_addr sip;  /* Source IP */ \n    unsigned int flags;\n    int local_packets = 0;\n    bool initstep1 = false;  /* keep track of successful handshake step */\n    bool warned = false;\n\n    local_ip.byte1=0;\n    local_ip.byte2=0;\n    local_ip.byte3=0;\n    local_ip.byte4=0;\n\n    remote_ip.byte1=0;\n    remote_ip.byte2=0;\n    remote_ip.byte3=0;\n    remote_ip.byte4=0;\n\n    pcap_t *pcap = set_offline_filter(file); \n    if (!pcap){\n        fprintf (stderr, \"Cannot open PCAP file '%s' for reading\\n\", file);\n        fprintf(stderr, \"%s\\n\",ErrBuff);\n        return PCAP_OPEN_ERROR;\n    }\n\n    dumpfile = pcap_dump_open(pcap, newfile);\n    if (!dumpfile) {\n        fprintf (stderr, \"Cannot open PCAP file '%s' for writing\\n\", newfile);\n        return PCAP_OPEN_ERROR;\n    }\n\n    /*Modify each packet's IP & MAC based on the passed args then do a checksum of each packet*/\n    for (pkt_counter = 0; safe_pcap_next_ex(pcap, &header, &packet) > 0; pkt_counter++){\n\n        if (!warned && header->len > header->caplen) {\n            fprintf(stderr, \"warning: packet capture truncated to %d byte packets\\n\",\n                    header->caplen);\n            warned = true;\n        }\n        etherhdr = (ether_hdr*)(packet);\n        iphdr = (ipv4_hdr *)(packet + SIZE_ETHERNET);\n        size_ip = iphdr->ip_hl << 2; \n        if (size_ip < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", size_ip);\n            return ERROR;\n        }\n        tcphdr = (tcp_hdr *)(packet + SIZE_ETHERNET + size_ip);\n        size_tcp = tcphdr->th_off*4;\n        if (size_tcp < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", size_tcp);\n            return ERROR;\n        }\n        /* payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp); */\n\n        sip = iphdr->ip_src;\n        flags = tcphdr->th_flags;\n\n        /* set IPs who's local and who's remote based on the SYN flag */\n        if(flags == TH_SYN){\n            local_ip = iphdr->ip_src; \n            remote_ip = iphdr->ip_dst; \n            initstep1 = true; /* This flag is set to signify the first encounter of the SYN within the pacp*/\n        }\n\n        if(compip(&local_ip, &remote_ip, &sip)==LOCAL_IP_MATCH){\n            /* Set the source MAC */\n            etherhdr->ether_shost[0] = mymac->byte1;\n            etherhdr->ether_shost[1] = mymac->byte2;\n            etherhdr->ether_shost[2] = mymac->byte3;\n            etherhdr->ether_shost[3] = mymac->byte4;\n            etherhdr->ether_shost[4] = mymac->byte5;\n            etherhdr->ether_shost[5] = mymac->byte6;\n\n            /* Set the source IP */\n            iphdr->ip_src = *myip;\n            /* Set the destination IP */\n            iphdr->ip_dst = *new_remoteip;\n\n            /* Set the destination MAC */\n            etherhdr->ether_dhost[0] = new_remotemac->byte1;\n            etherhdr->ether_dhost[1] = new_remotemac->byte2;\n            etherhdr->ether_dhost[2] = new_remotemac->byte3;\n            etherhdr->ether_dhost[3] = new_remotemac->byte4;\n            etherhdr->ether_dhost[4] = new_remotemac->byte5;\n            etherhdr->ether_dhost[5] = new_remotemac->byte6;\n\n            /* This is to change the source port, whether it is specified as random or as a port # by the user */\n            tcphdr->th_sport = htons(new_src_port);\n        }\n        else if(compip(&local_ip, &remote_ip, &sip)==REMOTE_IP_MATCH){\n\n            /* Set the destination MAC */\n            etherhdr->ether_dhost[0] = mymac->byte1;\n            etherhdr->ether_dhost[1] = mymac->byte2;\n            etherhdr->ether_dhost[2] = mymac->byte3;\n            etherhdr->ether_dhost[3] = mymac->byte4;\n            etherhdr->ether_dhost[4] = mymac->byte5;\n            etherhdr->ether_dhost[5] = mymac->byte6;\n            /* Set the destination IP */\n            iphdr->ip_dst = *myip;\n            /* Set the source IP */\n            iphdr->ip_src = *new_remoteip;\n            /* Set the source MAC */\n            etherhdr->ether_shost[0] = new_remotemac->byte1;\n            etherhdr->ether_shost[1] = new_remotemac->byte2;\n            etherhdr->ether_shost[2] = new_remotemac->byte3;\n            etherhdr->ether_shost[3] = new_remotemac->byte4;\n            etherhdr->ether_shost[4] = new_remotemac->byte5;\n            etherhdr->ether_shost[5] = new_remotemac->byte6;\n\n            /* This is to change the source port, whether it is specified as random or as a port # by the user */\n            tcphdr->th_dport = htons(new_src_port);\n        }\n\n        /*Calculate & fix checksum for newly edited-packet*/\n        fix_all_checksum_liveplay(iphdr);\n\n        if(initstep1){ /*only start rewriting new pcap with SYN packets on wards*/\n            local_packets ++;\n            pcap_dump((u_char *)dumpfile, header, packet);\n        }\n    } /* end of while loop */\n\n    pcap_close (pcap);\n    pcap_dump_close(dumpfile);\n    return local_packets;\n}",
  "abstract_func": "int\nrewrite(input_addr* VAR_0, struct mac_addr* VAR_1, input_addr* VAR_2, struct mac_addr* VAR_3, char* VAR_4, unsigned int VAR_5)\n{\n\n    ether_hdr* VAR_6; \n    ipv4_hdr *VAR_7;\n    tcp_hdr *VAR_8;\n    input_addr VAR_9; \n    input_addr VAR_10; \n    unsigned int VAR_11;\n    unsigned int VAR_12; \n    char* VAR_13 = \"newfile.pcap\";\n    char VAR_14 [1024];\n    int VAR_15;\n    const u_char *VAR_16;\n    struct pcap_pkthdr *VAR_17;\n    pcap_dumper_t *VAR_18;\n    input_addr VAR_19;  /* COMMENT_0 */ \n    unsigned int VAR_20;\n    int VAR_21 = 0;\n    bool VAR_22 = false;  /* COMMENT_1 */\n    bool VAR_23 = false;\n\n    VAR_9.byte1=0;\n    VAR_9.byte2=0;\n    VAR_9.byte3=0;\n    VAR_9.byte4=0;\n\n    VAR_10.byte1=0;\n    VAR_10.byte2=0;\n    VAR_10.byte3=0;\n    VAR_10.byte4=0;\n\n    pcap_t *VAR_24 = set_offline_filter(VAR_4); \n    if (!VAR_24){\n        fprintf (VAR_25, \"Cannot open PCAP file '%s' for reading\\n\", VAR_4);\n        fprintf(VAR_25, \"%s\\n\",VAR_14);\n        return VAR_26;\n    }\n\n    VAR_18 = pcap_dump_open(VAR_24, VAR_13);\n    if (!VAR_18) {\n        fprintf (VAR_25, \"Cannot open PCAP file '%s' for writing\\n\", VAR_13);\n        return VAR_26;\n    }\n\n    /* COMMENT_2 */\n    for (VAR_15 = 0; safe_pcap_next_ex(VAR_24, &VAR_17, &VAR_16) > 0; VAR_15++){\n\n        if (!VAR_23 && VAR_17->len > VAR_17->caplen) {\n            fprintf(VAR_25, \"warning: packet capture truncated to %d byte packets\\n\",\n                    VAR_17->caplen);\n            VAR_23 = true;\n        }\n        VAR_6 = (ether_hdr*)(VAR_16);\n        VAR_7 = (ipv4_hdr *)(VAR_16 + VAR_27);\n        VAR_11 = VAR_7->ip_hl << 2; \n        if (VAR_11 < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", VAR_11);\n            return VAR_28;\n        }\n        VAR_8 = (tcp_hdr *)(VAR_16 + VAR_27 + VAR_11);\n        VAR_12 = VAR_8->th_off*4;\n        if (VAR_12 < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", VAR_12);\n            return VAR_28;\n        }\n        /* COMMENT_3 */\n\n        VAR_19 = VAR_7->ip_src;\n        VAR_20 = VAR_8->th_flags;\n\n        /* COMMENT_4 */\n        if(VAR_20 == VAR_29){\n            VAR_9 = VAR_7->ip_src; \n            VAR_10 = VAR_7->ip_dst; \n            VAR_22 = true; /* COMMENT_5 */\n        }\n\n        if(compip(&VAR_9, &VAR_10, &VAR_19)==VAR_30){\n            /* COMMENT_6 */\n            VAR_6->ether_shost[0] = VAR_3->byte1;\n            VAR_6->ether_shost[1] = VAR_3->byte2;\n            VAR_6->ether_shost[2] = VAR_3->byte3;\n            VAR_6->ether_shost[3] = VAR_3->byte4;\n            VAR_6->ether_shost[4] = VAR_3->byte5;\n            VAR_6->ether_shost[5] = VAR_3->byte6;\n\n            /* COMMENT_7 */\n            VAR_7->ip_src = *VAR_2;\n            /* COMMENT_8 */\n            VAR_7->ip_dst = *VAR_0;\n\n            /* COMMENT_9 */\n            VAR_6->ether_dhost[0] = VAR_1->byte1;\n            VAR_6->ether_dhost[1] = VAR_1->byte2;\n            VAR_6->ether_dhost[2] = VAR_1->byte3;\n            VAR_6->ether_dhost[3] = VAR_1->byte4;\n            VAR_6->ether_dhost[4] = VAR_1->byte5;\n            VAR_6->ether_dhost[5] = VAR_1->byte6;\n\n            /* COMMENT_10 */\n            VAR_8->th_sport = htons(VAR_5);\n        }\n        else if(compip(&VAR_9, &VAR_10, &VAR_19)==VAR_31){\n\n            /* COMMENT_9 */\n            VAR_6->ether_dhost[0] = VAR_3->byte1;\n            VAR_6->ether_dhost[1] = VAR_3->byte2;\n            VAR_6->ether_dhost[2] = VAR_3->byte3;\n            VAR_6->ether_dhost[3] = VAR_3->byte4;\n            VAR_6->ether_dhost[4] = VAR_3->byte5;\n            VAR_6->ether_dhost[5] = VAR_3->byte6;\n            /* COMMENT_8 */\n            VAR_7->ip_dst = *VAR_2;\n            /* COMMENT_7 */\n            VAR_7->ip_src = *VAR_0;\n            /* COMMENT_6 */\n            VAR_6->ether_shost[0] = VAR_1->byte1;\n            VAR_6->ether_shost[1] = VAR_1->byte2;\n            VAR_6->ether_shost[2] = VAR_1->byte3;\n            VAR_6->ether_shost[3] = VAR_1->byte4;\n            VAR_6->ether_shost[4] = VAR_1->byte5;\n            VAR_6->ether_shost[5] = VAR_1->byte6;\n\n            /* COMMENT_10 */\n            VAR_8->th_dport = htons(VAR_5);\n        }\n\n        /* COMMENT_11 */\n        fix_all_checksum_liveplay(VAR_7);\n\n        if(VAR_22){ /* COMMENT_12 */\n            VAR_21 ++;\n            pcap_dump((u_char *)VAR_18, VAR_17, VAR_16);\n        }\n    } /* COMMENT_13 */\n\n    pcap_close (VAR_24);\n    pcap_dump_close(VAR_18);\n    return VAR_21;\n}",
  "func_graph_path": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcpliveplay.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n     }\n \n     /*Modify each packet's IP & MAC based on the passed args then do a checksum of each packet*/\n-    for (pkt_counter = 0; pcap_next_ex(pcap, &header, &packet) > 0; pkt_counter++){\n+    for (pkt_counter = 0; safe_pcap_next_ex(pcap, &header, &packet) > 0; pkt_counter++){\n \n         if (!warned && header->len > header->caplen) {\n             fprintf(stderr, \"warning: packet capture truncated to %d byte packets\\n\",",
  "diff_line_info": {
    "deleted_lines": [
      "    for (pkt_counter = 0; pcap_next_ex(pcap, &header, &packet) > 0; pkt_counter++){"
    ],
    "added_lines": [
      "    for (pkt_counter = 0; safe_pcap_next_ex(pcap, &header, &packet) > 0; pkt_counter++){"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/491",
  "description": {
    "pr_info": {
      "title": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files",
      "number": 491
    },
    "comment": [
      "* Check for packets that are larger than 262144 bytes\r\n* Check for capture lengths that are greater than packet length\r\n\r\nExample of a corrupt PCAP file ...\r\n\r\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\r\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit addresses a known security vulnerability (CVE-2018-17582) by adding checks for corrupt PCAP files, which is a direct security fix. The code changes implement safe handling of packet lengths, aligning with security practices to prevent buffer overflows or crashes."
}