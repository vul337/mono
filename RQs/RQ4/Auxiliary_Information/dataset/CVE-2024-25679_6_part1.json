{
  "cve_id": "CVE-2024-25679",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "p-quic/pquic",
  "commit_msg": "discard the keys after handshake is done; use the correct original_destination_connection_id; discard the re-transmission packets correctly; limit the active_connection_id",
  "commit_hash": "2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "git_url": "https://github.com/p-quic/pquic/commit/2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "file_path": "picoquic/sender.c",
  "func_name": "schedule_frames_on_path",
  "func_before": "protoop_arg_t schedule_frames_on_path(picoquic_cnx_t *cnx)\n{\n    picoquic_packet_t* packet = (picoquic_packet_t*) cnx->protoop_inputv[0];\n    size_t send_buffer_max = (size_t) cnx->protoop_inputv[1];\n    uint64_t current_time = (uint64_t) cnx->protoop_inputv[2];\n    /* picoquic_packet_t* retransmit_p = (picoquic_packet_t*) cnx->protoop_inputv[3]; */ // Unused\n    /* picoquic_path_t* from_path = (picoquic_path_t*) cnx->protoop_inputv[4]; */ // Unused\n    char* reason = (char*) cnx->protoop_inputv[5];\n\n    int ret = 0;\n    uint32_t length = 0;\n    int is_cleartext_mode = 0;\n    uint32_t checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n\n    /* FIXME cope with different path MTUs */\n    picoquic_path_t *path_x = cnx->path[0];\n    PUSH_LOG_CTX(cnx, \"\\\"path\\\": \\\"%p\\\"\", path_x);\n\n    uint32_t send_buffer_min_max = (send_buffer_max > path_x->send_mtu) ? path_x->send_mtu : (uint32_t)send_buffer_max;\n    int retransmit_possible = 1;\n    picoquic_packet_context_enum pc = picoquic_packet_context_application;\n    size_t data_bytes = 0;\n    uint32_t header_length = 0;\n    uint8_t* bytes = packet->bytes;\n    picoquic_packet_type_enum packet_type = picoquic_packet_1rtt_protected_phi0;\n\n    /* TODO: manage multiple streams. */\n    picoquic_stream_head* stream = NULL;\n    int tls_ready = picoquic_is_tls_stream_ready(cnx);\n    stream = picoquic_find_ready_stream(cnx);\n    picoquic_stream_head* plugin_stream = NULL;\n    plugin_stream = picoquic_find_ready_plugin_stream(cnx);\n\n\n    /* First enqueue frames that can be fairly sent, if any */\n    /* Only schedule new frames if there is no planned frames */\n    if (queue_peek(cnx->reserved_frames) == NULL) {\n        stream = picoquic_schedule_next_stream(cnx, send_buffer_min_max - checksum_overhead - length, path_x);\n        picoquic_frame_fair_reserve(cnx, path_x, stream, send_buffer_min_max - checksum_overhead - length);\n    }\n\n    char * retrans_reason = NULL;\n    if (ret == 0 && retransmit_possible &&\n        (length = picoquic_retransmit_needed(cnx, pc, path_x, current_time, packet, send_buffer_min_max, &is_cleartext_mode, &header_length, &retrans_reason)) > 0) {\n        if (reason != NULL) {\n            protoop_id_t pid = { .id = retrans_reason };\n            pid.hash = hash_value_str(pid.id);\n            protoop_prepare_and_run_noparam(cnx, &pid, NULL, packet);\n        }\n        /* Set the new checksum length */\n        checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n        /* Check whether it makes sense to add an ACK at the end of the retransmission */\n        /* Don't do that if it risks mixing clear text and encrypted ack */\n        if (is_cleartext_mode == 0 && packet->ptype != picoquic_packet_0rtt_protected) {\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_min_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                packet->length = length;\n            }\n        }\n        /* document the send time & overhead */\n        packet->is_pure_ack = 0;\n        packet->send_time = current_time;\n        packet->checksum_overhead = checksum_overhead;\n    }\n    else if (ret == 0) {\n        length = picoquic_predict_packet_header_length(\n                cnx, packet_type, path_x);\n        packet->ptype = packet_type;\n        packet->offset = length;\n        header_length = length;\n        packet->sequence_number = path_x->pkt_ctx[pc].send_sequence;\n        packet->send_time = current_time;\n        packet->send_path = path_x;\n\n        if (((stream == NULL && tls_ready == 0) ||\n                path_x->cwin <= path_x->bytes_in_transit)\n            && picoquic_is_ack_needed(cnx, current_time, pc, path_x) == 0\n            && picoquic_should_send_max_data(cnx) == 0\n            && path_x->challenge_response_to_send == 0\n            && (cnx->client_mode || !cnx->handshake_done || cnx->handshake_done_sent)\n            && (path_x->challenge_verified == 1 || current_time < path_x->challenge_time + path_x->retransmit_timer)\n            && queue_peek(cnx->reserved_frames) == NULL\n            && queue_peek(cnx->retry_frames) == NULL\n            && queue_peek(cnx->rtx_frames[pc]) == NULL) {\n            if (ret == 0 && send_buffer_max > path_x->send_mtu && picoquic_is_mtu_probe_needed(cnx, path_x)) {\n                length = picoquic_prepare_mtu_probe(cnx, path_x, header_length, checksum_overhead, bytes);\n                packet->is_mtu_probe = 1;\n                packet->length = length;\n                packet->is_congestion_controlled = 0;  // See DPLPMTUD\n                path_x->mtu_probe_sent = 1;\n                packet->is_pure_ack = 0;\n            } else {\n                length = 0;\n                packet->offset = 0;\n            }\n        } else {\n            if (path_x->challenge_verified == 0 &&\n                current_time >= (path_x->challenge_time + path_x->retransmit_timer)) {\n                if (picoquic_prepare_path_challenge_frame(cnx, &bytes[length],\n                                                            send_buffer_min_max - checksum_overhead - length,\n                                                            &data_bytes, path_x) == 0) {\n                    length += (uint32_t) data_bytes;\n                    path_x->challenge_time = current_time;\n                    path_x->challenge_repeat_count++;\n                    packet->is_congestion_controlled = 1;\n\n\n                    if (path_x->challenge_repeat_count > PICOQUIC_CHALLENGE_REPEAT_MAX) {\n                        DBG_PRINTF(\"%s\\n\", \"Too many challenge retransmits, disconnect\");\n                        picoquic_set_cnx_state(cnx, picoquic_state_disconnected);\n                        if (cnx->callback_fn) {\n                            (void)(cnx->callback_fn)(cnx, 0, NULL, 0, picoquic_callback_close, cnx->callback_ctx, NULL);\n                        }\n                        length = 0;\n                        packet->offset = 0;\n                    }\n                }\n            }\n\n            if (cnx->cnx_state != picoquic_state_disconnected) {\n                size_t consumed = 0;\n                unsigned int is_pure_ack = packet->is_pure_ack;\n                ret = picoquic_scheduler_write_new_frames(cnx, &bytes[length],\n                                                          send_buffer_min_max - checksum_overhead - length,\n                                                          length - packet->offset, packet,\n                                                          &consumed, &is_pure_ack);\n                packet->is_pure_ack = is_pure_ack;\n                if (!ret && consumed > send_buffer_min_max - checksum_overhead - length) {\n                    ret = PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL;\n                } else if (!ret) {\n                    length += consumed;\n                    /* FIXME: Sorry, I'm lazy, this could be easily fixed by making this a PO.\n                        * This is needed by the way the cwin is now handled. */\n                    if (path_x == cnx->path[0] && (header_length != length || picoquic_is_ack_needed(cnx, current_time, pc, path_x))) {\n                        if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length], send_buffer_min_max - checksum_overhead - length, &data_bytes) == 0) {\n                            length += (uint32_t)data_bytes;\n                        }\n                    }\n\n                    if (path_x->cwin > path_x->bytes_in_transit) {\n                        /* if present, send tls data */\n                        if (tls_ready) {\n                            ret = picoquic_prepare_crypto_hs_frame(cnx, 3, &bytes[length],\n                                                                    send_buffer_min_max - checksum_overhead - length, &data_bytes);\n\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->contains_crypto = 1;\n                                    packet->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n\n                        if (!cnx->client_mode && cnx->handshake_done && !cnx->handshake_done_sent) {\n                            ret = picoquic_prepare_handshake_done_frame(cnx, bytes + length, send_buffer_min_max - checksum_overhead - length, &data_bytes);\n                            if (ret == 0 && data_bytes > 0) {\n                                length += (uint32_t) data_bytes;\n                                packet->has_handshake_done = 1;\n                                packet->is_pure_ack = 0;\n                            }\n                        }\n\n                        /* if present, send path response. This ensures we send it on the right path */\n                        if (path_x->challenge_response_to_send && send_buffer_min_max - checksum_overhead - length >= PICOQUIC_CHALLENGE_LENGTH + 1) {\n                            /* This is not really clean, but it will work */\n                            bytes[length] = picoquic_frame_type_path_response;\n                            memcpy(&bytes[length+1], path_x->challenge_response, PICOQUIC_CHALLENGE_LENGTH);\n                            path_x->challenge_response_to_send = 0;\n                            length += PICOQUIC_CHALLENGE_LENGTH + 1;\n                            packet->is_congestion_controlled = 1;\n                        }\n                        /* If necessary, encode the max data frame */\n                        if (ret == 0 && 2 * cnx->data_received > cnx->maxdata_local) {\n                            ret = picoquic_prepare_max_data_frame(cnx, 2 * cnx->data_received, &bytes[length],\n                                                                    send_buffer_min_max - checksum_overhead - length, &data_bytes);\n\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n                            }\n                            else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                ret = 0;\n                            }\n                        }\n                        /* If necessary, encode the max stream data frames */\n                        if (ret == 0) {\n                            ret = picoquic_prepare_required_max_stream_data_frames(cnx, &bytes[length],\n                                                                                    send_buffer_min_max - checksum_overhead - length, &data_bytes);\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n                        /* If required, request for plugins */\n                        if (ret == 0 && !cnx->plugin_requested) {\n                            int is_retransmittable = 1;\n                            for (int i = 0; ret == 0 && i < cnx->pids_to_request.size; i++) {\n                                ret = picoquic_write_plugin_validate_frame(cnx, &bytes[length], &bytes[send_buffer_min_max - checksum_overhead],\n                                    cnx->pids_to_request.elems[i].pid_id, cnx->pids_to_request.elems[i].plugin_name, &data_bytes, &is_retransmittable);\n                                if (ret == 0) {\n                                    length += (uint32_t)data_bytes;\n                                    if (data_bytes > 0)\n                                    {\n                                        packet->is_pure_ack = 0;\n                                        packet->is_congestion_controlled = 1;\n                                        cnx->pids_to_request.elems[i].requested = 1;\n                                    }\n                                }\n                                else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                    ret = 0;\n                                }\n                            }\n                            cnx->plugin_requested = 1;\n                        }\n\n                        /* Encode the plugin frame, or frames */\n                        while (plugin_stream != NULL) {\n                            size_t stream_bytes_max = picoquic_stream_bytes_max(cnx, send_buffer_min_max - checksum_overhead - length, header_length, bytes);\n                            ret = picoquic_prepare_plugin_frame(cnx, plugin_stream, &bytes[length],\n                                                                stream_bytes_max, &data_bytes);\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n\n                                if (stream_bytes_max > checksum_overhead + length + 8) {\n                                    plugin_stream = picoquic_find_ready_plugin_stream(cnx);\n                                }\n                                else {\n                                    break;\n                                }\n                            }\n                            else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                ret = 0;\n                                break;\n                            }\n                        }\n\n                        size_t stream_bytes_max = picoquic_stream_bytes_max(cnx, send_buffer_min_max - checksum_overhead - length, header_length, bytes);\n                        stream = picoquic_schedule_next_stream(cnx, stream_bytes_max, path_x);\n\n                        /* Encode the stream frame, or frames */\n                        while (stream != NULL) {\n                            ret = picoquic_prepare_stream_frame(cnx, stream, &bytes[length],\n                                                                stream_bytes_max, &data_bytes);\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n\n                                if (stream_bytes_max > checksum_overhead + length + 8) {\n                                    stream_bytes_max = picoquic_stream_bytes_max(cnx, send_buffer_min_max - checksum_overhead - length, header_length, bytes);\n                                    stream = picoquic_schedule_next_stream(cnx, stream_bytes_max, path_x);\n                                } else {\n                                    break;\n                                }\n                            } else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                ret = 0;\n                                break;\n                            }\n                        }\n\n                         if (length <= header_length) {\n                             /* Mark the bandwidth estimation as application limited */\n                             path_x->delivered_limited_index = path_x->delivered;\n                         }\n                    }\n                    if (length == 0 || length == header_length) {\n                        /* Don't flood the network with packets! */\n                        length = 0;\n                        packet->offset = 0;\n                    } else if (length > 0 && length != header_length && length + checksum_overhead <= PICOQUIC_RESET_PACKET_MIN_SIZE) {\n                        uint32_t pad_size = PICOQUIC_RESET_PACKET_MIN_SIZE - checksum_overhead - length + 1;\n                        for (uint32_t i = 0; i < pad_size; i++) {\n                            bytes[length++] = 0;\n                        }\n                    }\n                }\n\n                if (path_x->cwin <= path_x->bytes_in_transit + length) {\n                    picoquic_congestion_algorithm_notify_func(cnx, path_x, picoquic_congestion_notification_cwin_blocked, 0, 0, 0, current_time);\n                }\n            }\n\n        }\n    }\n\n    POP_LOG_CTX(cnx);\n    protoop_save_outputs(cnx, path_x, length, header_length);\n    return (protoop_arg_t) ret;\n}",
  "abstract_func_before": "protoop_arg_t schedule_frames_on_path(picoquic_cnx_t *VAR_0)\n{\n    picoquic_packet_t* VAR_1 = (picoquic_packet_t*) VAR_0->protoop_inputv[0];\n    size_t VAR_2 = (size_t) VAR_0->protoop_inputv[1];\n    uint64_t VAR_3 = (uint64_t) VAR_0->protoop_inputv[2];\n    /* COMMENT_0 */ /* COMMENT_1 */\n    /* COMMENT_2 */ /* COMMENT_1 */\n    char* VAR_4 = (char*) VAR_0->protoop_inputv[5];\n\n    int VAR_5 = 0;\n    uint32_t VAR_6 = 0;\n    int VAR_7 = 0;\n    uint32_t VAR_8 = picoquic_get_checksum_length(VAR_0, VAR_7);\n\n    /* COMMENT_3 */\n    picoquic_path_t *VAR_9 = VAR_0->path[0];\n    PUSH_LOG_CTX(VAR_0, \"\\\"path\\\": \\\"%p\\\"\", VAR_9);\n\n    uint32_t VAR_10 = (VAR_2 > VAR_9->send_mtu) ? VAR_9->send_mtu : (uint32_t)VAR_2;\n    int VAR_11 = 1;\n    picoquic_packet_context_enum VAR_12 = VAR_13;\n    size_t VAR_14 = 0;\n    uint32_t VAR_15 = 0;\n    uint8_t* VAR_16 = VAR_1->bytes;\n    picoquic_packet_type_enum VAR_17 = VAR_18;\n\n    /* COMMENT_4 */\n    picoquic_stream_head* VAR_19 = NULL;\n    int VAR_20 = picoquic_is_tls_stream_ready(VAR_0);\n    VAR_19 = picoquic_find_ready_stream(VAR_0);\n    picoquic_stream_head* VAR_21 = NULL;\n    VAR_21 = picoquic_find_ready_plugin_stream(VAR_0);\n\n\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if (queue_peek(VAR_0->reserved_frames) == NULL) {\n        VAR_19 = picoquic_schedule_next_stream(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_9);\n        picoquic_frame_fair_reserve(VAR_0, VAR_9, VAR_19, VAR_10 - VAR_8 - VAR_6);\n    }\n\n    char * VAR_22 = NULL;\n    if (VAR_5 == 0 && VAR_11 &&\n        (VAR_6 = picoquic_retransmit_needed(VAR_0, VAR_12, VAR_9, VAR_3, VAR_1, VAR_10, &VAR_7, &VAR_15, &VAR_22)) > 0) {\n        if (VAR_4 != NULL) {\n            protoop_id_t VAR_23 = { .id = VAR_22 };\n            VAR_23.hash = hash_value_str(VAR_23.id);\n            protoop_prepare_and_run_noparam(VAR_0, &VAR_23, NULL, VAR_1);\n        }\n        /* COMMENT_7 */\n        VAR_8 = picoquic_get_checksum_length(VAR_0, VAR_7);\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        if (VAR_7 == 0 && VAR_1->ptype != VAR_24) {\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_16[VAR_6],\n                VAR_10 - VAR_8 - VAR_6, &VAR_14)\n                == 0) {\n                VAR_6 += (uint32_t)VAR_14;\n                VAR_1->length = VAR_6;\n            }\n        }\n        /* COMMENT_10 */\n        VAR_1->is_pure_ack = 0;\n        VAR_1->send_time = VAR_3;\n        VAR_1->checksum_overhead = VAR_8;\n    }\n    else if (VAR_5 == 0) {\n        VAR_6 = picoquic_predict_packet_header_length(\n                VAR_0, VAR_17, VAR_9);\n        VAR_1->ptype = VAR_17;\n        VAR_1->offset = VAR_6;\n        VAR_15 = VAR_6;\n        VAR_1->sequence_number = VAR_9->pkt_ctx[VAR_12].send_sequence;\n        VAR_1->send_time = VAR_3;\n        VAR_1->send_path = VAR_9;\n\n        if (((VAR_19 == NULL && VAR_20 == 0) ||\n                VAR_9->cwin <= VAR_9->bytes_in_transit)\n            && picoquic_is_ack_needed(VAR_0, VAR_3, VAR_12, VAR_9) == 0\n            && picoquic_should_send_max_data(VAR_0) == 0\n            && VAR_9->challenge_response_to_send == 0\n            && (VAR_0->client_mode || !VAR_0->handshake_done || VAR_0->handshake_done_sent)\n            && (VAR_9->challenge_verified == 1 || VAR_3 < VAR_9->challenge_time + VAR_9->retransmit_timer)\n            && queue_peek(VAR_0->reserved_frames) == NULL\n            && queue_peek(VAR_0->retry_frames) == NULL\n            && queue_peek(VAR_0->rtx_frames[VAR_12]) == NULL) {\n            if (VAR_5 == 0 && VAR_2 > VAR_9->send_mtu && picoquic_is_mtu_probe_needed(VAR_0, VAR_9)) {\n                VAR_6 = picoquic_prepare_mtu_probe(VAR_0, VAR_9, VAR_15, VAR_8, VAR_16);\n                VAR_1->is_mtu_probe = 1;\n                VAR_1->length = VAR_6;\n                VAR_1->is_congestion_controlled = 0;  /* COMMENT_11 */\n                VAR_9->mtu_probe_sent = 1;\n                VAR_1->is_pure_ack = 0;\n            } else {\n                VAR_6 = 0;\n                VAR_1->offset = 0;\n            }\n        } else {\n            if (VAR_9->challenge_verified == 0 &&\n                VAR_3 >= (VAR_9->challenge_time + VAR_9->retransmit_timer)) {\n                if (picoquic_prepare_path_challenge_frame(VAR_0, &VAR_16[VAR_6],\n                                                            VAR_10 - VAR_8 - VAR_6,\n                                                            &VAR_14, VAR_9) == 0) {\n                    VAR_6 += (uint32_t) VAR_14;\n                    VAR_9->challenge_time = VAR_3;\n                    VAR_9->challenge_repeat_count++;\n                    VAR_1->is_congestion_controlled = 1;\n\n\n                    if (VAR_9->challenge_repeat_count > VAR_25) {\n                        DBG_PRINTF(\"%s\\n\", \"Too many challenge retransmits, disconnect\");\n                        picoquic_set_cnx_state(VAR_0, VAR_26);\n                        if (VAR_0->callback_fn) {\n                            (void)(VAR_0->callback_fn)(VAR_0, 0, NULL, 0, VAR_27, VAR_0->callback_ctx, NULL);\n                        }\n                        VAR_6 = 0;\n                        VAR_1->offset = 0;\n                    }\n                }\n            }\n\n            if (VAR_0->cnx_state != VAR_26) {\n                size_t VAR_28 = 0;\n                unsigned int VAR_29 = VAR_1->is_pure_ack;\n                VAR_5 = picoquic_scheduler_write_new_frames(VAR_0, &VAR_16[VAR_6],\n                                                          VAR_10 - VAR_8 - VAR_6,\n                                                          VAR_6 - VAR_1->offset, VAR_1,\n                                                          &VAR_28, &VAR_29);\n                VAR_1->is_pure_ack = VAR_29;\n                if (!VAR_5 && VAR_28 > VAR_10 - VAR_8 - VAR_6) {\n                    VAR_5 = VAR_30;\n                } else if (!VAR_5) {\n                    VAR_6 += VAR_28;\n                    /* COMMENT_12 */\n                                                                               \n                    if (VAR_9 == VAR_0->path[0] && (VAR_15 != VAR_6 || picoquic_is_ack_needed(VAR_0, VAR_3, VAR_12, VAR_9))) {\n                        if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_16[VAR_6], VAR_10 - VAR_8 - VAR_6, &VAR_14) == 0) {\n                            VAR_6 += (uint32_t)VAR_14;\n                        }\n                    }\n\n                    if (VAR_9->cwin > VAR_9->bytes_in_transit) {\n                        /* COMMENT_14 */\n                        if (VAR_20) {\n                            VAR_5 = picoquic_prepare_crypto_hs_frame(VAR_0, 3, &VAR_16[VAR_6],\n                                                                    VAR_10 - VAR_8 - VAR_6, &VAR_14);\n\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->contains_crypto = 1;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n\n                        if (!VAR_0->client_mode && VAR_0->handshake_done && !VAR_0->handshake_done_sent) {\n                            VAR_5 = picoquic_prepare_handshake_done_frame(VAR_0, VAR_16 + VAR_6, VAR_10 - VAR_8 - VAR_6, &VAR_14);\n                            if (VAR_5 == 0 && VAR_14 > 0) {\n                                VAR_6 += (uint32_t) VAR_14;\n                                VAR_1->has_handshake_done = 1;\n                                VAR_1->is_pure_ack = 0;\n                            }\n                        }\n\n                        /* COMMENT_15 */\n                        if (VAR_9->challenge_response_to_send && VAR_10 - VAR_8 - VAR_6 >= VAR_31 + 1) {\n                            /* COMMENT_16 */\n                            VAR_16[VAR_6] = VAR_32;\n                            memcpy(&VAR_16[VAR_6+1], VAR_9->challenge_response, VAR_31);\n                            VAR_9->challenge_response_to_send = 0;\n                            VAR_6 += VAR_31 + 1;\n                            VAR_1->is_congestion_controlled = 1;\n                        }\n                        /* COMMENT_17 */\n                        if (VAR_5 == 0 && 2 * VAR_0->data_received > VAR_0->maxdata_local) {\n                            VAR_5 = picoquic_prepare_max_data_frame(VAR_0, 2 * VAR_0->data_received, &VAR_16[VAR_6],\n                                                                    VAR_10 - VAR_8 - VAR_6, &VAR_14);\n\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n                            }\n                            else if (VAR_5 == VAR_30) {\n                                VAR_5 = 0;\n                            }\n                        }\n                        /* COMMENT_18 */\n                        if (VAR_5 == 0) {\n                            VAR_5 = picoquic_prepare_required_max_stream_data_frames(VAR_0, &VAR_16[VAR_6],\n                                                                                    VAR_10 - VAR_8 - VAR_6, &VAR_14);\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n                        /* COMMENT_19 */\n                        if (VAR_5 == 0 && !VAR_0->plugin_requested) {\n                            int VAR_33 = 1;\n                            for (int VAR_34 = 0; VAR_5 == 0 && VAR_34 < VAR_0->pids_to_request.size; VAR_34++) {\n                                VAR_5 = picoquic_write_plugin_validate_frame(VAR_0, &VAR_16[VAR_6], &VAR_16[VAR_10 - VAR_8],\n                                    VAR_0->pids_to_request.elems[VAR_34].pid_id, VAR_0->pids_to_request.elems[VAR_34].plugin_name, &VAR_14, &VAR_33);\n                                if (VAR_5 == 0) {\n                                    VAR_6 += (uint32_t)VAR_14;\n                                    if (VAR_14 > 0)\n                                    {\n                                        VAR_1->is_pure_ack = 0;\n                                        VAR_1->is_congestion_controlled = 1;\n                                        VAR_0->pids_to_request.elems[VAR_34].requested = 1;\n                                    }\n                                }\n                                else if (VAR_5 == VAR_30) {\n                                    VAR_5 = 0;\n                                }\n                            }\n                            VAR_0->plugin_requested = 1;\n                        }\n\n                        /* COMMENT_20 */\n                        while (VAR_21 != NULL) {\n                            size_t VAR_35 = picoquic_stream_bytes_max(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_15, VAR_16);\n                            VAR_5 = picoquic_prepare_plugin_frame(VAR_0, VAR_21, &VAR_16[VAR_6],\n                                                                VAR_35, &VAR_14);\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n\n                                if (VAR_35 > VAR_8 + VAR_6 + 8) {\n                                    VAR_21 = picoquic_find_ready_plugin_stream(VAR_0);\n                                }\n                                else {\n                                    break;\n                                }\n                            }\n                            else if (VAR_5 == VAR_30) {\n                                VAR_5 = 0;\n                                break;\n                            }\n                        }\n\n                        size_t VAR_35 = picoquic_stream_bytes_max(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_15, VAR_16);\n                        VAR_19 = picoquic_schedule_next_stream(VAR_0, VAR_35, VAR_9);\n\n                        /* COMMENT_21 */\n                        while (VAR_19 != NULL) {\n                            VAR_5 = picoquic_prepare_stream_frame(VAR_0, VAR_19, &VAR_16[VAR_6],\n                                                                VAR_35, &VAR_14);\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n\n                                if (VAR_35 > VAR_8 + VAR_6 + 8) {\n                                    VAR_35 = picoquic_stream_bytes_max(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_15, VAR_16);\n                                    VAR_19 = picoquic_schedule_next_stream(VAR_0, VAR_35, VAR_9);\n                                } else {\n                                    break;\n                                }\n                            } else if (VAR_5 == VAR_30) {\n                                VAR_5 = 0;\n                                break;\n                            }\n                        }\n\n                         if (VAR_6 <= VAR_15) {\n                             /* COMMENT_22 */\n                             VAR_9->delivered_limited_index = VAR_9->delivered;\n                         }\n                    }\n                    if (VAR_6 == 0 || VAR_6 == VAR_15) {\n                        /* COMMENT_23 */\n                        VAR_6 = 0;\n                        VAR_1->offset = 0;\n                    } else if (VAR_6 > 0 && VAR_6 != VAR_15 && VAR_6 + VAR_8 <= VAR_36) {\n                        uint32_t VAR_37 = VAR_36 - VAR_8 - VAR_6 + 1;\n                        for (uint32_t VAR_34 = 0; VAR_34 < VAR_37; VAR_34++) {\n                            VAR_16[VAR_6++] = 0;\n                        }\n                    }\n                }\n\n                if (VAR_9->cwin <= VAR_9->bytes_in_transit + VAR_6) {\n                    picoquic_congestion_algorithm_notify_func(VAR_0, VAR_9, VAR_38, 0, 0, 0, VAR_3);\n                }\n            }\n\n        }\n    }\n\n    POP_LOG_CTX(VAR_0);\n    protoop_save_outputs(VAR_0, VAR_9, VAR_6, VAR_15);\n    return (protoop_arg_t) VAR_5;\n}",
  "func_graph_path_before": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/sender.c/vul/before/3.json",
  "func": "protoop_arg_t schedule_frames_on_path(picoquic_cnx_t *cnx)\n{\n    picoquic_packet_t* packet = (picoquic_packet_t*) cnx->protoop_inputv[0];\n    size_t send_buffer_max = (size_t) cnx->protoop_inputv[1];\n    uint64_t current_time = (uint64_t) cnx->protoop_inputv[2];\n    /* picoquic_packet_t* retransmit_p = (picoquic_packet_t*) cnx->protoop_inputv[3]; */ // Unused\n    /* picoquic_path_t* from_path = (picoquic_path_t*) cnx->protoop_inputv[4]; */ // Unused\n    char* reason = (char*) cnx->protoop_inputv[5];\n\n    int ret = 0;\n    uint32_t length = 0;\n    int is_cleartext_mode = 0;\n    uint32_t checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n\n    /* FIXME cope with different path MTUs */\n    picoquic_path_t *path_x = cnx->path[0];\n    PUSH_LOG_CTX(cnx, \"\\\"path\\\": \\\"%p\\\"\", path_x);\n\n    uint32_t send_buffer_min_max = (send_buffer_max > path_x->send_mtu) ? path_x->send_mtu : (uint32_t)send_buffer_max;\n    int retransmit_possible = 1;\n    picoquic_packet_context_enum pc = picoquic_packet_context_application;\n    size_t data_bytes = 0;\n    uint32_t header_length = 0;\n    uint8_t* bytes = packet->bytes;\n    picoquic_packet_type_enum packet_type = picoquic_packet_1rtt_protected_phi0;\n\n    /* TODO: manage multiple streams. */\n    picoquic_stream_head* stream = NULL;\n    int tls_ready = picoquic_is_tls_stream_ready(cnx);\n    stream = picoquic_find_ready_stream(cnx);\n    picoquic_stream_head* plugin_stream = NULL;\n    plugin_stream = picoquic_find_ready_plugin_stream(cnx);\n\n\n    /* First enqueue frames that can be fairly sent, if any */\n    /* Only schedule new frames if there is no planned frames */\n    if (queue_peek(cnx->reserved_frames) == NULL) {\n        stream = picoquic_schedule_next_stream(cnx, send_buffer_min_max - checksum_overhead - length, path_x);\n        picoquic_frame_fair_reserve(cnx, path_x, stream, send_buffer_min_max - checksum_overhead - length);\n    }\n\n    char * retrans_reason = NULL;\n    if (ret == 0 && retransmit_possible &&\n        (length = picoquic_retransmit_needed(cnx, pc, path_x, current_time, packet, send_buffer_min_max, &is_cleartext_mode, &header_length, &retrans_reason)) > 0) {\n        if (reason != NULL) {\n            protoop_id_t pid = { .id = retrans_reason };\n            pid.hash = hash_value_str(pid.id);\n            protoop_prepare_and_run_noparam(cnx, &pid, NULL, packet);\n        }\n        /* Set the new checksum length */\n        checksum_overhead = picoquic_get_checksum_length(cnx, is_cleartext_mode);\n        /* Check whether it makes sense to add an ACK at the end of the retransmission */\n        /* Don't do that if it risks mixing clear text and encrypted ack */\n        if (is_cleartext_mode == 0 && packet->ptype != picoquic_packet_0rtt_protected) {\n            if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length],\n                send_buffer_min_max - checksum_overhead - length, &data_bytes)\n                == 0) {\n                length += (uint32_t)data_bytes;\n                packet->length = length;\n            }\n        }\n        /* document the send time & overhead */\n        packet->is_pure_ack = 0;\n        packet->send_time = current_time;\n        packet->checksum_overhead = checksum_overhead;\n    }\n    else if (ret == 0) {\n        length = picoquic_predict_packet_header_length(\n                cnx, packet_type, path_x);\n        packet->ptype = packet_type;\n        packet->offset = length;\n        header_length = length;\n        packet->sequence_number = path_x->pkt_ctx[pc].send_sequence;\n        packet->send_time = current_time;\n        packet->send_path = path_x;\n\n        if (((stream == NULL && tls_ready == 0) ||\n                path_x->cwin <= path_x->bytes_in_transit)\n            && picoquic_is_ack_needed(cnx, current_time, pc, path_x) == 0\n            && picoquic_should_send_max_data(cnx) == 0\n            && path_x->challenge_response_to_send == 0\n            && (cnx->client_mode || !cnx->handshake_done || cnx->handshake_done_sent)\n            && (path_x->challenge_verified == 1 || current_time < path_x->challenge_time + path_x->retransmit_timer)\n            && queue_peek(cnx->reserved_frames) == NULL\n            && queue_peek(cnx->retry_frames) == NULL\n            && queue_peek(cnx->rtx_frames[pc]) == NULL) {\n            if (ret == 0 && send_buffer_max > path_x->send_mtu && picoquic_is_mtu_probe_needed(cnx, path_x)) {\n                length = picoquic_prepare_mtu_probe(cnx, path_x, header_length, checksum_overhead, bytes);\n                packet->is_mtu_probe = 1;\n                packet->length = length;\n                packet->is_congestion_controlled = 0;  // See DPLPMTUD\n                path_x->mtu_probe_sent = 1;\n                packet->is_pure_ack = 0;\n            } else {\n                length = 0;\n                packet->offset = 0;\n            }\n        } else {\n            if (path_x->challenge_verified == 0 &&\n                current_time >= (path_x->challenge_time + path_x->retransmit_timer)) {\n                if (picoquic_prepare_path_challenge_frame(cnx, &bytes[length],\n                                                            send_buffer_min_max - checksum_overhead - length,\n                                                            &data_bytes, path_x) == 0) {\n                    length += (uint32_t) data_bytes;\n                    path_x->challenge_time = current_time;\n                    path_x->challenge_repeat_count++;\n                    packet->is_congestion_controlled = 1;\n\n\n                    if (path_x->challenge_repeat_count > PICOQUIC_CHALLENGE_REPEAT_MAX) {\n                        DBG_PRINTF(\"%s\\n\", \"Too many challenge retransmits, disconnect\");\n                        picoquic_set_cnx_state(cnx, picoquic_state_disconnected);\n                        if (cnx->callback_fn) {\n                            (void)(cnx->callback_fn)(cnx, 0, NULL, 0, picoquic_callback_close, cnx->callback_ctx, NULL);\n                        }\n                        length = 0;\n                        packet->offset = 0;\n                    }\n                }\n            }\n\n            if (cnx->cnx_state != picoquic_state_disconnected) {\n                size_t consumed = 0;\n                unsigned int is_pure_ack = packet->is_pure_ack;\n                ret = picoquic_scheduler_write_new_frames(cnx, &bytes[length],\n                                                          send_buffer_min_max - checksum_overhead - length,\n                                                          length - packet->offset, packet,\n                                                          &consumed, &is_pure_ack);\n                packet->is_pure_ack = is_pure_ack;\n                if (!ret && consumed > send_buffer_min_max - checksum_overhead - length) {\n                    ret = PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL;\n                } else if (!ret) {\n                    length += consumed;\n                    /* FIXME: Sorry, I'm lazy, this could be easily fixed by making this a PO.\n                        * This is needed by the way the cwin is now handled. */\n                    if (path_x == cnx->path[0] && (header_length != length || picoquic_is_ack_needed(cnx, current_time, pc, path_x))) {\n                        if (picoquic_prepare_ack_frame(cnx, current_time, pc, &bytes[length], send_buffer_min_max - checksum_overhead - length, &data_bytes) == 0) {\n                            length += (uint32_t)data_bytes;\n                        }\n                    }\n\n                    if (path_x->cwin > path_x->bytes_in_transit) {\n                        /* if present, send tls data */\n                        if (tls_ready) {\n                            ret = picoquic_prepare_crypto_hs_frame(cnx, 3, &bytes[length],\n                                                                    send_buffer_min_max - checksum_overhead - length, &data_bytes);\n\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->contains_crypto = 1;\n                                    packet->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n\n                        if (!cnx->client_mode && cnx->handshake_done && !cnx->handshake_done_sent) {\n                            ret = picoquic_prepare_handshake_done_frame(cnx, bytes + length, send_buffer_min_max - checksum_overhead - length, &data_bytes);\n                            if (ret == 0 && data_bytes > 0) {\n                                length += (uint32_t) data_bytes;\n                                packet->has_handshake_done = 1;\n                                packet->is_pure_ack = 0;\n                                picoquic_crypto_context_free(&cnx->crypto_context[2]);\n                            }\n                        }\n\n                        /* if present, send path response. This ensures we send it on the right path */\n                        if (path_x->challenge_response_to_send && send_buffer_min_max - checksum_overhead - length >= PICOQUIC_CHALLENGE_LENGTH + 1) {\n                            /* This is not really clean, but it will work */\n                            bytes[length] = picoquic_frame_type_path_response;\n                            memcpy(&bytes[length+1], path_x->challenge_response, PICOQUIC_CHALLENGE_LENGTH);\n                            path_x->challenge_response_to_send = 0;\n                            length += PICOQUIC_CHALLENGE_LENGTH + 1;\n                            packet->is_congestion_controlled = 1;\n                        }\n                        /* If necessary, encode the max data frame */\n                        if (ret == 0 && 2 * cnx->data_received > cnx->maxdata_local) {\n                            ret = picoquic_prepare_max_data_frame(cnx, 2 * cnx->data_received, &bytes[length],\n                                                                    send_buffer_min_max - checksum_overhead - length, &data_bytes);\n\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n                            }\n                            else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                ret = 0;\n                            }\n                        }\n                        /* If necessary, encode the max stream data frames */\n                        if (ret == 0) {\n                            ret = picoquic_prepare_required_max_stream_data_frames(cnx, &bytes[length],\n                                                                                    send_buffer_min_max - checksum_overhead - length, &data_bytes);\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n                        /* If required, request for plugins */\n                        if (ret == 0 && !cnx->plugin_requested) {\n                            int is_retransmittable = 1;\n                            for (int i = 0; ret == 0 && i < cnx->pids_to_request.size; i++) {\n                                ret = picoquic_write_plugin_validate_frame(cnx, &bytes[length], &bytes[send_buffer_min_max - checksum_overhead],\n                                    cnx->pids_to_request.elems[i].pid_id, cnx->pids_to_request.elems[i].plugin_name, &data_bytes, &is_retransmittable);\n                                if (ret == 0) {\n                                    length += (uint32_t)data_bytes;\n                                    if (data_bytes > 0)\n                                    {\n                                        packet->is_pure_ack = 0;\n                                        packet->is_congestion_controlled = 1;\n                                        cnx->pids_to_request.elems[i].requested = 1;\n                                    }\n                                }\n                                else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                    ret = 0;\n                                }\n                            }\n                            cnx->plugin_requested = 1;\n                        }\n\n                        /* Encode the plugin frame, or frames */\n                        while (plugin_stream != NULL) {\n                            size_t stream_bytes_max = picoquic_stream_bytes_max(cnx, send_buffer_min_max - checksum_overhead - length, header_length, bytes);\n                            ret = picoquic_prepare_plugin_frame(cnx, plugin_stream, &bytes[length],\n                                                                stream_bytes_max, &data_bytes);\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n\n                                if (stream_bytes_max > checksum_overhead + length + 8) {\n                                    plugin_stream = picoquic_find_ready_plugin_stream(cnx);\n                                }\n                                else {\n                                    break;\n                                }\n                            }\n                            else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                ret = 0;\n                                break;\n                            }\n                        }\n\n                        size_t stream_bytes_max = picoquic_stream_bytes_max(cnx, send_buffer_min_max - checksum_overhead - length, header_length, bytes);\n                        stream = picoquic_schedule_next_stream(cnx, stream_bytes_max, path_x);\n\n                        /* Encode the stream frame, or frames */\n                        while (stream != NULL) {\n                            ret = picoquic_prepare_stream_frame(cnx, stream, &bytes[length],\n                                                                stream_bytes_max, &data_bytes);\n                            if (ret == 0) {\n                                length += (uint32_t)data_bytes;\n                                if (data_bytes > 0)\n                                {\n                                    packet->is_pure_ack = 0;\n                                    packet->is_congestion_controlled = 1;\n                                }\n\n                                if (stream_bytes_max > checksum_overhead + length + 8) {\n                                    stream_bytes_max = picoquic_stream_bytes_max(cnx, send_buffer_min_max - checksum_overhead - length, header_length, bytes);\n                                    stream = picoquic_schedule_next_stream(cnx, stream_bytes_max, path_x);\n                                } else {\n                                    break;\n                                }\n                            } else if (ret == PICOQUIC_ERROR_FRAME_BUFFER_TOO_SMALL) {\n                                ret = 0;\n                                break;\n                            }\n                        }\n\n                         if (length <= header_length) {\n                             /* Mark the bandwidth estimation as application limited */\n                             path_x->delivered_limited_index = path_x->delivered;\n                         }\n                    }\n                    if (length == 0 || length == header_length) {\n                        /* Don't flood the network with packets! */\n                        length = 0;\n                        packet->offset = 0;\n                    } else if (length > 0 && length != header_length && length + checksum_overhead <= PICOQUIC_RESET_PACKET_MIN_SIZE) {\n                        uint32_t pad_size = PICOQUIC_RESET_PACKET_MIN_SIZE - checksum_overhead - length + 1;\n                        for (uint32_t i = 0; i < pad_size; i++) {\n                            bytes[length++] = 0;\n                        }\n                    }\n                }\n\n                if (path_x->cwin <= path_x->bytes_in_transit + length) {\n                    picoquic_congestion_algorithm_notify_func(cnx, path_x, picoquic_congestion_notification_cwin_blocked, 0, 0, 0, current_time);\n                }\n            }\n\n        }\n    }\n\n    POP_LOG_CTX(cnx);\n    protoop_save_outputs(cnx, path_x, length, header_length);\n    return (protoop_arg_t) ret;\n}",
  "abstract_func": "protoop_arg_t schedule_frames_on_path(picoquic_cnx_t *VAR_0)\n{\n    picoquic_packet_t* VAR_1 = (picoquic_packet_t*) VAR_0->protoop_inputv[0];\n    size_t VAR_2 = (size_t) VAR_0->protoop_inputv[1];\n    uint64_t VAR_3 = (uint64_t) VAR_0->protoop_inputv[2];\n    /* COMMENT_0 */ /* COMMENT_1 */\n    /* COMMENT_2 */ /* COMMENT_1 */\n    char* VAR_4 = (char*) VAR_0->protoop_inputv[5];\n\n    int VAR_5 = 0;\n    uint32_t VAR_6 = 0;\n    int VAR_7 = 0;\n    uint32_t VAR_8 = picoquic_get_checksum_length(VAR_0, VAR_7);\n\n    /* COMMENT_3 */\n    picoquic_path_t *VAR_9 = VAR_0->path[0];\n    PUSH_LOG_CTX(VAR_0, \"\\\"path\\\": \\\"%p\\\"\", VAR_9);\n\n    uint32_t VAR_10 = (VAR_2 > VAR_9->send_mtu) ? VAR_9->send_mtu : (uint32_t)VAR_2;\n    int VAR_11 = 1;\n    picoquic_packet_context_enum VAR_12 = VAR_13;\n    size_t VAR_14 = 0;\n    uint32_t VAR_15 = 0;\n    uint8_t* VAR_16 = VAR_1->bytes;\n    picoquic_packet_type_enum VAR_17 = VAR_18;\n\n    /* COMMENT_4 */\n    picoquic_stream_head* VAR_19 = NULL;\n    int VAR_20 = picoquic_is_tls_stream_ready(VAR_0);\n    VAR_19 = picoquic_find_ready_stream(VAR_0);\n    picoquic_stream_head* VAR_21 = NULL;\n    VAR_21 = picoquic_find_ready_plugin_stream(VAR_0);\n\n\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if (queue_peek(VAR_0->reserved_frames) == NULL) {\n        VAR_19 = picoquic_schedule_next_stream(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_9);\n        picoquic_frame_fair_reserve(VAR_0, VAR_9, VAR_19, VAR_10 - VAR_8 - VAR_6);\n    }\n\n    char * VAR_22 = NULL;\n    if (VAR_5 == 0 && VAR_11 &&\n        (VAR_6 = picoquic_retransmit_needed(VAR_0, VAR_12, VAR_9, VAR_3, VAR_1, VAR_10, &VAR_7, &VAR_15, &VAR_22)) > 0) {\n        if (VAR_4 != NULL) {\n            protoop_id_t VAR_23 = { .id = VAR_22 };\n            VAR_23.hash = hash_value_str(VAR_23.id);\n            protoop_prepare_and_run_noparam(VAR_0, &VAR_23, NULL, VAR_1);\n        }\n        /* COMMENT_7 */\n        VAR_8 = picoquic_get_checksum_length(VAR_0, VAR_7);\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        if (VAR_7 == 0 && VAR_1->ptype != VAR_24) {\n            if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_16[VAR_6],\n                VAR_10 - VAR_8 - VAR_6, &VAR_14)\n                == 0) {\n                VAR_6 += (uint32_t)VAR_14;\n                VAR_1->length = VAR_6;\n            }\n        }\n        /* COMMENT_10 */\n        VAR_1->is_pure_ack = 0;\n        VAR_1->send_time = VAR_3;\n        VAR_1->checksum_overhead = VAR_8;\n    }\n    else if (VAR_5 == 0) {\n        VAR_6 = picoquic_predict_packet_header_length(\n                VAR_0, VAR_17, VAR_9);\n        VAR_1->ptype = VAR_17;\n        VAR_1->offset = VAR_6;\n        VAR_15 = VAR_6;\n        VAR_1->sequence_number = VAR_9->pkt_ctx[VAR_12].send_sequence;\n        VAR_1->send_time = VAR_3;\n        VAR_1->send_path = VAR_9;\n\n        if (((VAR_19 == NULL && VAR_20 == 0) ||\n                VAR_9->cwin <= VAR_9->bytes_in_transit)\n            && picoquic_is_ack_needed(VAR_0, VAR_3, VAR_12, VAR_9) == 0\n            && picoquic_should_send_max_data(VAR_0) == 0\n            && VAR_9->challenge_response_to_send == 0\n            && (VAR_0->client_mode || !VAR_0->handshake_done || VAR_0->handshake_done_sent)\n            && (VAR_9->challenge_verified == 1 || VAR_3 < VAR_9->challenge_time + VAR_9->retransmit_timer)\n            && queue_peek(VAR_0->reserved_frames) == NULL\n            && queue_peek(VAR_0->retry_frames) == NULL\n            && queue_peek(VAR_0->rtx_frames[VAR_12]) == NULL) {\n            if (VAR_5 == 0 && VAR_2 > VAR_9->send_mtu && picoquic_is_mtu_probe_needed(VAR_0, VAR_9)) {\n                VAR_6 = picoquic_prepare_mtu_probe(VAR_0, VAR_9, VAR_15, VAR_8, VAR_16);\n                VAR_1->is_mtu_probe = 1;\n                VAR_1->length = VAR_6;\n                VAR_1->is_congestion_controlled = 0;  /* COMMENT_11 */\n                VAR_9->mtu_probe_sent = 1;\n                VAR_1->is_pure_ack = 0;\n            } else {\n                VAR_6 = 0;\n                VAR_1->offset = 0;\n            }\n        } else {\n            if (VAR_9->challenge_verified == 0 &&\n                VAR_3 >= (VAR_9->challenge_time + VAR_9->retransmit_timer)) {\n                if (picoquic_prepare_path_challenge_frame(VAR_0, &VAR_16[VAR_6],\n                                                            VAR_10 - VAR_8 - VAR_6,\n                                                            &VAR_14, VAR_9) == 0) {\n                    VAR_6 += (uint32_t) VAR_14;\n                    VAR_9->challenge_time = VAR_3;\n                    VAR_9->challenge_repeat_count++;\n                    VAR_1->is_congestion_controlled = 1;\n\n\n                    if (VAR_9->challenge_repeat_count > VAR_25) {\n                        DBG_PRINTF(\"%s\\n\", \"Too many challenge retransmits, disconnect\");\n                        picoquic_set_cnx_state(VAR_0, VAR_26);\n                        if (VAR_0->callback_fn) {\n                            (void)(VAR_0->callback_fn)(VAR_0, 0, NULL, 0, VAR_27, VAR_0->callback_ctx, NULL);\n                        }\n                        VAR_6 = 0;\n                        VAR_1->offset = 0;\n                    }\n                }\n            }\n\n            if (VAR_0->cnx_state != VAR_26) {\n                size_t VAR_28 = 0;\n                unsigned int VAR_29 = VAR_1->is_pure_ack;\n                VAR_5 = picoquic_scheduler_write_new_frames(VAR_0, &VAR_16[VAR_6],\n                                                          VAR_10 - VAR_8 - VAR_6,\n                                                          VAR_6 - VAR_1->offset, VAR_1,\n                                                          &VAR_28, &VAR_29);\n                VAR_1->is_pure_ack = VAR_29;\n                if (!VAR_5 && VAR_28 > VAR_10 - VAR_8 - VAR_6) {\n                    VAR_5 = VAR_30;\n                } else if (!VAR_5) {\n                    VAR_6 += VAR_28;\n                    /* COMMENT_12 */\n                                                                               \n                    if (VAR_9 == VAR_0->path[0] && (VAR_15 != VAR_6 || picoquic_is_ack_needed(VAR_0, VAR_3, VAR_12, VAR_9))) {\n                        if (picoquic_prepare_ack_frame(VAR_0, VAR_3, VAR_12, &VAR_16[VAR_6], VAR_10 - VAR_8 - VAR_6, &VAR_14) == 0) {\n                            VAR_6 += (uint32_t)VAR_14;\n                        }\n                    }\n\n                    if (VAR_9->cwin > VAR_9->bytes_in_transit) {\n                        /* COMMENT_14 */\n                        if (VAR_20) {\n                            VAR_5 = picoquic_prepare_crypto_hs_frame(VAR_0, 3, &VAR_16[VAR_6],\n                                                                    VAR_10 - VAR_8 - VAR_6, &VAR_14);\n\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->contains_crypto = 1;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n\n                        if (!VAR_0->client_mode && VAR_0->handshake_done && !VAR_0->handshake_done_sent) {\n                            VAR_5 = picoquic_prepare_handshake_done_frame(VAR_0, VAR_16 + VAR_6, VAR_10 - VAR_8 - VAR_6, &VAR_14);\n                            if (VAR_5 == 0 && VAR_14 > 0) {\n                                VAR_6 += (uint32_t) VAR_14;\n                                VAR_1->has_handshake_done = 1;\n                                VAR_1->is_pure_ack = 0;\n                                picoquic_crypto_context_free(&VAR_0->crypto_context[2]);\n                            }\n                        }\n\n                        /* COMMENT_15 */\n                        if (VAR_9->challenge_response_to_send && VAR_10 - VAR_8 - VAR_6 >= VAR_31 + 1) {\n                            /* COMMENT_16 */\n                            VAR_16[VAR_6] = VAR_32;\n                            memcpy(&VAR_16[VAR_6+1], VAR_9->challenge_response, VAR_31);\n                            VAR_9->challenge_response_to_send = 0;\n                            VAR_6 += VAR_31 + 1;\n                            VAR_1->is_congestion_controlled = 1;\n                        }\n                        /* COMMENT_17 */\n                        if (VAR_5 == 0 && 2 * VAR_0->data_received > VAR_0->maxdata_local) {\n                            VAR_5 = picoquic_prepare_max_data_frame(VAR_0, 2 * VAR_0->data_received, &VAR_16[VAR_6],\n                                                                    VAR_10 - VAR_8 - VAR_6, &VAR_14);\n\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n                            }\n                            else if (VAR_5 == VAR_30) {\n                                VAR_5 = 0;\n                            }\n                        }\n                        /* COMMENT_18 */\n                        if (VAR_5 == 0) {\n                            VAR_5 = picoquic_prepare_required_max_stream_data_frames(VAR_0, &VAR_16[VAR_6],\n                                                                                    VAR_10 - VAR_8 - VAR_6, &VAR_14);\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n                            }\n                        }\n                        /* COMMENT_19 */\n                        if (VAR_5 == 0 && !VAR_0->plugin_requested) {\n                            int VAR_33 = 1;\n                            for (int VAR_34 = 0; VAR_5 == 0 && VAR_34 < VAR_0->pids_to_request.size; VAR_34++) {\n                                VAR_5 = picoquic_write_plugin_validate_frame(VAR_0, &VAR_16[VAR_6], &VAR_16[VAR_10 - VAR_8],\n                                    VAR_0->pids_to_request.elems[VAR_34].pid_id, VAR_0->pids_to_request.elems[VAR_34].plugin_name, &VAR_14, &VAR_33);\n                                if (VAR_5 == 0) {\n                                    VAR_6 += (uint32_t)VAR_14;\n                                    if (VAR_14 > 0)\n                                    {\n                                        VAR_1->is_pure_ack = 0;\n                                        VAR_1->is_congestion_controlled = 1;\n                                        VAR_0->pids_to_request.elems[VAR_34].requested = 1;\n                                    }\n                                }\n                                else if (VAR_5 == VAR_30) {\n                                    VAR_5 = 0;\n                                }\n                            }\n                            VAR_0->plugin_requested = 1;\n                        }\n\n                        /* COMMENT_20 */\n                        while (VAR_21 != NULL) {\n                            size_t VAR_35 = picoquic_stream_bytes_max(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_15, VAR_16);\n                            VAR_5 = picoquic_prepare_plugin_frame(VAR_0, VAR_21, &VAR_16[VAR_6],\n                                                                VAR_35, &VAR_14);\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n\n                                if (VAR_35 > VAR_8 + VAR_6 + 8) {\n                                    VAR_21 = picoquic_find_ready_plugin_stream(VAR_0);\n                                }\n                                else {\n                                    break;\n                                }\n                            }\n                            else if (VAR_5 == VAR_30) {\n                                VAR_5 = 0;\n                                break;\n                            }\n                        }\n\n                        size_t VAR_35 = picoquic_stream_bytes_max(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_15, VAR_16);\n                        VAR_19 = picoquic_schedule_next_stream(VAR_0, VAR_35, VAR_9);\n\n                        /* COMMENT_21 */\n                        while (VAR_19 != NULL) {\n                            VAR_5 = picoquic_prepare_stream_frame(VAR_0, VAR_19, &VAR_16[VAR_6],\n                                                                VAR_35, &VAR_14);\n                            if (VAR_5 == 0) {\n                                VAR_6 += (uint32_t)VAR_14;\n                                if (VAR_14 > 0)\n                                {\n                                    VAR_1->is_pure_ack = 0;\n                                    VAR_1->is_congestion_controlled = 1;\n                                }\n\n                                if (VAR_35 > VAR_8 + VAR_6 + 8) {\n                                    VAR_35 = picoquic_stream_bytes_max(VAR_0, VAR_10 - VAR_8 - VAR_6, VAR_15, VAR_16);\n                                    VAR_19 = picoquic_schedule_next_stream(VAR_0, VAR_35, VAR_9);\n                                } else {\n                                    break;\n                                }\n                            } else if (VAR_5 == VAR_30) {\n                                VAR_5 = 0;\n                                break;\n                            }\n                        }\n\n                         if (VAR_6 <= VAR_15) {\n                             /* COMMENT_22 */\n                             VAR_9->delivered_limited_index = VAR_9->delivered;\n                         }\n                    }\n                    if (VAR_6 == 0 || VAR_6 == VAR_15) {\n                        /* COMMENT_23 */\n                        VAR_6 = 0;\n                        VAR_1->offset = 0;\n                    } else if (VAR_6 > 0 && VAR_6 != VAR_15 && VAR_6 + VAR_8 <= VAR_36) {\n                        uint32_t VAR_37 = VAR_36 - VAR_8 - VAR_6 + 1;\n                        for (uint32_t VAR_34 = 0; VAR_34 < VAR_37; VAR_34++) {\n                            VAR_16[VAR_6++] = 0;\n                        }\n                    }\n                }\n\n                if (VAR_9->cwin <= VAR_9->bytes_in_transit + VAR_6) {\n                    picoquic_congestion_algorithm_notify_func(VAR_0, VAR_9, VAR_38, 0, 0, 0, VAR_3);\n                }\n            }\n\n        }\n    }\n\n    POP_LOG_CTX(VAR_0);\n    protoop_save_outputs(VAR_0, VAR_9, VAR_6, VAR_15);\n    return (protoop_arg_t) VAR_5;\n}",
  "func_graph_path": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/sender.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -162,6 +162,7 @@\n                                 length += (uint32_t) data_bytes;\n                                 packet->has_handshake_done = 1;\n                                 packet->is_pure_ack = 0;\n+                                picoquic_crypto_context_free(&cnx->crypto_context[2]);\n                             }\n                         }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                                picoquic_crypto_context_free(&cnx->crypto_context[2]);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/p-quic/pquic/pull/39",
  "description": {
    "pr_info": {
      "title": "Minor Fix",
      "number": 39
    },
    "comment": [
      "Hi, I try to fix the bugs in #34 #35 #36 and #38.\r\n\r\nCan you validate these fixes please.\r\n",
      "The code looks good. Have you done any test to ensure it fixes these issues ?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}