{
  "cve_id": "CVE-2016-4425",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "akheron/jansson",
  "commit_msg": "Fix for issue #282\n\nThe fix limits recursion depths when parsing arrays and objects.\nThe limit is configurable via the `JSON_PARSER_MAX_DEPTH` setting\nwithin `jansson_config.h` and is set by default to 2048.\n\nUpdate the RFC conformance document to note the limit; the RFC\nallows limits to be set by the implementation so nothing has\nactually changed w.r.t. conformance state.\n\nReported by Gustavo Grieco.",
  "commit_hash": "64ce0ad3731ebd77e02897b07920eadd0e2cc318",
  "git_url": "https://github.com/akheron/jansson/commit/64ce0ad3731ebd77e02897b07920eadd0e2cc318",
  "file_path": "src/load.c",
  "func_name": "parse_json",
  "func_before": "static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *result;\n\n    lex_scan(lex, error);\n    if(!(flags & JSON_DECODE_ANY)) {\n        if(lex->token != '[' && lex->token != '{') {\n            error_set(error, lex, \"'[' or '{' expected\");\n            return NULL;\n        }\n    }\n\n    result = parse_value(lex, flags, error);\n    if(!result)\n        return NULL;\n\n    if(!(flags & JSON_DISABLE_EOF_CHECK)) {\n        lex_scan(lex, error);\n        if(lex->token != TOKEN_EOF) {\n            error_set(error, lex, \"end of file expected\");\n            json_decref(result);\n            return NULL;\n        }\n    }\n\n    if(error) {\n        /* Save the position even though there was no error */\n        error->position = (int)lex->stream.position;\n    }\n\n    return result;\n}",
  "abstract_func_before": "static json_t *parse_json(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)\n{\n    json_t *VAR_3;\n\n    lex_scan(VAR_0, VAR_2);\n    if(!(VAR_1 & VAR_4)) {\n        if(VAR_0->token != '[' && VAR_0->token != '{') {\n            error_set(VAR_2, VAR_0, \"'[' or '{' expected\");\n            return NULL;\n        }\n    }\n\n    VAR_3 = parse_value(VAR_0, VAR_1, VAR_2);\n    if(!VAR_3)\n        return NULL;\n\n    if(!(VAR_1 & VAR_5)) {\n        lex_scan(VAR_0, VAR_2);\n        if(VAR_0->token != VAR_6) {\n            error_set(VAR_2, VAR_0, \"end of file expected\");\n            json_decref(VAR_3);\n            return NULL;\n        }\n    }\n\n    if(VAR_2) {\n        /* COMMENT_0 */\n        VAR_2->position = (int)VAR_0->stream.position;\n    }\n\n    return VAR_3;\n}",
  "func_graph_path_before": "akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/before/0.json",
  "func": "static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *result;\n\n    lex->depth = 0;\n\n    lex_scan(lex, error);\n    if(!(flags & JSON_DECODE_ANY)) {\n        if(lex->token != '[' && lex->token != '{') {\n            error_set(error, lex, \"'[' or '{' expected\");\n            return NULL;\n        }\n    }\n\n    result = parse_value(lex, flags, error);\n    if(!result)\n        return NULL;\n\n    if(!(flags & JSON_DISABLE_EOF_CHECK)) {\n        lex_scan(lex, error);\n        if(lex->token != TOKEN_EOF) {\n            error_set(error, lex, \"end of file expected\");\n            json_decref(result);\n            return NULL;\n        }\n    }\n\n    if(error) {\n        /* Save the position even though there was no error */\n        error->position = (int)lex->stream.position;\n    }\n\n    return result;\n}",
  "abstract_func": "static json_t *parse_json(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)\n{\n    json_t *VAR_3;\n\n    VAR_0->depth = 0;\n\n    lex_scan(VAR_0, VAR_2);\n    if(!(VAR_1 & VAR_4)) {\n        if(VAR_0->token != '[' && VAR_0->token != '{') {\n            error_set(VAR_2, VAR_0, \"'[' or '{' expected\");\n            return NULL;\n        }\n    }\n\n    VAR_3 = parse_value(VAR_0, VAR_1, VAR_2);\n    if(!VAR_3)\n        return NULL;\n\n    if(!(VAR_1 & VAR_5)) {\n        lex_scan(VAR_0, VAR_2);\n        if(VAR_0->token != VAR_6) {\n            error_set(VAR_2, VAR_0, \"end of file expected\");\n            json_decref(VAR_3);\n            return NULL;\n        }\n    }\n\n    if(VAR_2) {\n        /* COMMENT_0 */\n        VAR_2->position = (int)VAR_0->stream.position;\n    }\n\n    return VAR_3;\n}",
  "func_graph_path": "akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)\n {\n     json_t *result;\n+\n+    lex->depth = 0;\n \n     lex_scan(lex, error);\n     if(!(flags & JSON_DECODE_ANY)) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    lex->depth = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/akheron/jansson/pull/284",
  "description": {
    "pr_info": {
      "title": "Fix for issue #282",
      "number": 284
    },
    "comment": [
      "This is a squashed version of the original fixes in pull request #283. No other changes were made.\n",
      "[![Coverage Status](https://coveralls.io/builds/6025269/badge)](https://coveralls.io/builds/6025269)\n\nCoverage remained the same at 90.254% when pulling **64ce0ad3731ebd77e02897b07920eadd0e2cc318 on dev-zzo:issue-282** into **087ed94c452ecade26447c14605cd419e970cfd2 on akheron:master**.\n",
      "Merged, thanks a lot!\n",
      "Was happy to help.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}