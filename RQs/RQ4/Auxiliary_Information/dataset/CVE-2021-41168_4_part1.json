{
  "cve_id": "CVE-2021-41168",
  "cwe_ids": [
    "CWE-407"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "reddit/snudown",
  "commit_msg": "Hash-collision denial-of-service vulnerabilities (#87)\n\n* Add case insensitive SipHash implementation\n* Replace ref hash function with SipHash\n* Add label to link_ref struct.\n* Update find_link_ref to compare link labels as well as hashes\n* Update add_link_ref to disallow duplicate entries.\n* cast to char from uint8_t for strncasecmp\n* update README markdown, remove TODO\n* add py2 wheel generation\n* fix: add logic for older glibc not having getrandom, impacting staging\n\nCo-authored-by: Nicolaas <nweidema@usc.edu>",
  "commit_hash": "1ac2c130b210539ee1e5d67a7bac93f9d8007c0e",
  "git_url": "https://github.com/reddit/snudown/commit/1ac2c130b210539ee1e5d67a7bac93f9d8007c0e",
  "file_path": "src/markdown.c",
  "func_name": "add_link_ref",
  "func_before": "static struct link_ref *\nadd_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}",
  "abstract_func_before": "static struct link_ref *\nadd_link_ref(\n\tstruct link_ref **VAR_0,\n\tconst uint8_t *VAR_1, size_t VAR_2)\n{\n\tstruct link_ref *VAR_3 = calloc(1, sizeof(struct link_ref));\n\n\tif (!VAR_3)\n\t\treturn NULL;\n\n\tVAR_3->id = hash_link_ref(VAR_1, VAR_2);\n\tVAR_3->next = VAR_0[VAR_3->id % VAR_4];\n\n\tVAR_0[VAR_3->id % VAR_4] = VAR_3;\n\treturn VAR_3;\n}",
  "func_graph_path_before": "reddit/snudown/1ac2c130b210539ee1e5d67a7bac93f9d8007c0e/markdown.c/vul/before/5.json",
  "func": "static struct link_ref *\nadd_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tunsigned int hash;\n\tstruct link_ref *ref;\n\thash = hash_link_ref(name, name_size);\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\t/* If a reference with the same label exists already, replace it with the new reference */\n\t\tif (ref->id == hash && ref->label->size == name_size) {\n\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, name_size) == 0) {\n\t\t\t\tbufrelease(ref->label);\n\t\t\t\tbufrelease(ref->link);\n\t\t\t\tbufrelease(ref->title);\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t}\n\n\t\tref = ref->next;\n\t}\n\tref = calloc(1, sizeof(struct link_ref));\n\tif (!ref)\n\t\treturn NULL;\n\tref->id = hash;\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}",
  "abstract_func": "static struct link_ref *\nadd_link_ref(\n\tstruct link_ref **VAR_0,\n\tconst uint8_t *VAR_1, size_t VAR_2)\n{\n\tunsigned int VAR_3;\n\tstruct link_ref *VAR_4;\n\tVAR_3 = hash_link_ref(VAR_1, VAR_2);\n\tVAR_4 = VAR_0[VAR_3 % VAR_5];\n\twhile (VAR_4 != NULL) {\n\t\t/* COMMENT_0 */\n\t\tif (VAR_4->id == VAR_3 && VAR_4->label->size == VAR_2) {\n\t\t\tif (strncasecmp((char *)VAR_4->label->data, (char *) VAR_1, VAR_2) == 0) {\n\t\t\t\tbufrelease(VAR_4->label);\n\t\t\t\tbufrelease(VAR_4->link);\n\t\t\t\tbufrelease(VAR_4->title);\n\t\t\t\treturn VAR_4;\n\t\t\t}\n\t\t}\n\n\t\tVAR_4 = VAR_4->next;\n\t}\n\tVAR_4 = calloc(1, sizeof(struct link_ref));\n\tif (!VAR_4)\n\t\treturn NULL;\n\tVAR_4->id = VAR_3;\n\tVAR_4->next = VAR_0[VAR_4->id % VAR_5];\n\n\tVAR_0[VAR_4->id % VAR_5] = VAR_4;\n\treturn VAR_4;\n}",
  "func_graph_path": "reddit/snudown/1ac2c130b210539ee1e5d67a7bac93f9d8007c0e/markdown.c/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,12 +3,27 @@\n \tstruct link_ref **references,\n \tconst uint8_t *name, size_t name_size)\n {\n-\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n+\tunsigned int hash;\n+\tstruct link_ref *ref;\n+\thash = hash_link_ref(name, name_size);\n+\tref = references[hash % REF_TABLE_SIZE];\n+\twhile (ref != NULL) {\n+\t\t/* If a reference with the same label exists already, replace it with the new reference */\n+\t\tif (ref->id == hash && ref->label->size == name_size) {\n+\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, name_size) == 0) {\n+\t\t\t\tbufrelease(ref->label);\n+\t\t\t\tbufrelease(ref->link);\n+\t\t\t\tbufrelease(ref->title);\n+\t\t\t\treturn ref;\n+\t\t\t}\n+\t\t}\n \n+\t\tref = ref->next;\n+\t}\n+\tref = calloc(1, sizeof(struct link_ref));\n \tif (!ref)\n \t\treturn NULL;\n-\n-\tref->id = hash_link_ref(name, name_size);\n+\tref->id = hash;\n \tref->next = references[ref->id % REF_TABLE_SIZE];\n \n \treferences[ref->id % REF_TABLE_SIZE] = ref;",
  "diff_line_info": {
    "deleted_lines": [
      "\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));",
      "",
      "\tref->id = hash_link_ref(name, name_size);"
    ],
    "added_lines": [
      "\tunsigned int hash;",
      "\tstruct link_ref *ref;",
      "\thash = hash_link_ref(name, name_size);",
      "\tref = references[hash % REF_TABLE_SIZE];",
      "\twhile (ref != NULL) {",
      "\t\t/* If a reference with the same label exists already, replace it with the new reference */",
      "\t\tif (ref->id == hash && ref->label->size == name_size) {",
      "\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, name_size) == 0) {",
      "\t\t\t\tbufrelease(ref->label);",
      "\t\t\t\tbufrelease(ref->link);",
      "\t\t\t\tbufrelease(ref->title);",
      "\t\t\t\treturn ref;",
      "\t\t\t}",
      "\t\t}",
      "\t\tref = ref->next;",
      "\t}",
      "\tref = calloc(1, sizeof(struct link_ref));",
      "\tref->id = hash;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/reddit/snudown/pull/88",
  "description": {
    "pr_info": {
      "title": "Merge 1.7.0 into downstream github.com repo",
      "number": 88
    },
    "comment": [
      "Publishing internal repo of snudown (which had a 1.6.0 that is merged here as well). \r\n\r\nIn addition, this 1.7.0 branch includes fixes for a to-be-published security advisory (thanks to @NicolaasWeideman)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}