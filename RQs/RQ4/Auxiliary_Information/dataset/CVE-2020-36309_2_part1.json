{
  "cve_id": "CVE-2020-36309",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "openresty/lua-nginx-module",
  "commit_msg": "bugfix: ensured arguments of APIs mutating uri or request/response headers do not contain unsafe characters.\n\nSigned-off-by: Thibault Charbonnier <thibaultcha@me.com>",
  "commit_hash": "041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "git_url": "https://github.com/openresty/lua-nginx-module/commit/041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "file_path": "src/ngx_http_lua_control.c",
  "func_name": "ngx_http_lua_ngx_redirect",
  "func_before": "static int\nngx_http_lua_ngx_redirect(lua_State *L)\n{\n    ngx_http_lua_ctx_t          *ctx;\n    ngx_int_t                    rc;\n    int                          n;\n    u_char                      *p;\n    u_char                      *uri;\n    size_t                       len;\n    ngx_table_elt_t             *h;\n    ngx_http_request_t          *r;\n\n    n = lua_gettop(L);\n\n    if (n != 1 && n != 2) {\n        return luaL_error(L, \"expecting one or two arguments\");\n    }\n\n    p = (u_char *) luaL_checklstring(L, 1, &len);\n\n    if (n == 2) {\n        rc = (ngx_int_t) luaL_checknumber(L, 2);\n\n        if (rc != NGX_HTTP_MOVED_TEMPORARILY\n            && rc != NGX_HTTP_MOVED_PERMANENTLY\n            && rc != NGX_HTTP_SEE_OTHER\n            && rc != NGX_HTTP_PERMANENT_REDIRECT\n            && rc != NGX_HTTP_TEMPORARY_REDIRECT)\n        {\n            return luaL_error(L, \"only ngx.HTTP_MOVED_TEMPORARILY, \"\n                              \"ngx.HTTP_MOVED_PERMANENTLY, \"\n                              \"ngx.HTTP_PERMANENT_REDIRECT, \"\n                              \"ngx.HTTP_SEE_OTHER, and \"\n                              \"ngx.HTTP_TEMPORARY_REDIRECT are allowed\");\n        }\n\n    } else {\n        rc = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n\n    r = ngx_http_lua_get_req(L);\n    if (r == NULL) {\n        return luaL_error(L, \"no request object found\");\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n    if (ctx == NULL) {\n        return luaL_error(L, \"no request ctx found\");\n    }\n\n    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE\n                               | NGX_HTTP_LUA_CONTEXT_ACCESS\n                               | NGX_HTTP_LUA_CONTEXT_CONTENT);\n\n    ngx_http_lua_check_if_abortable(L, ctx);\n\n    if (r->header_sent || ctx->header_sent) {\n        return luaL_error(L, \"attempt to call ngx.redirect after sending out \"\n                          \"the headers\");\n    }\n\n    len = ngx_http_lua_safe_header_value_len(p, len);\n\n    uri = ngx_palloc(r->pool, len);\n    if (uri == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    ngx_memcpy(uri, p, len);\n\n    h = ngx_list_push(&r->headers_out.headers);\n    if (h == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    h->hash = ngx_http_lua_location_hash;\n\n#if 0\n    dd(\"location hash: %lu == %lu\",\n       (unsigned long) h->hash,\n       (unsigned long) ngx_hash_key_lc((u_char *) \"Location\",\n                                       sizeof(\"Location\") - 1));\n#endif\n\n    h->value.len = len;\n    h->value.data = uri;\n    ngx_str_set(&h->key, \"Location\");\n\n    r->headers_out.status = rc;\n\n    ctx->exit_code = rc;\n    ctx->exited = 1;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua redirect to \\\"%V\\\" with code %i\",\n                   &h->value, ctx->exit_code);\n\n    if (len && uri[0] != '/') {\n        r->headers_out.location = h;\n    }\n\n    /*\n     * we do not set r->headers_out.location here to avoid the handling\n     * the local redirects without a host name by ngx_http_header_filter()\n     */\n\n    return lua_yield(L, 0);\n}",
  "abstract_func_before": "static int\nngx_http_lua_ngx_redirect(lua_State *VAR_0)\n{\n    ngx_http_lua_ctx_t          *VAR_1;\n    ngx_int_t                    VAR_2;\n    int                          VAR_3;\n    u_char                      *VAR_4;\n    u_char                      *VAR_5;\n    size_t                       VAR_6;\n    ngx_table_elt_t             *VAR_7;\n    ngx_http_request_t          *VAR_8;\n\n    VAR_3 = lua_gettop(VAR_0);\n\n    if (VAR_3 != 1 && VAR_3 != 2) {\n        return luaL_error(VAR_0, \"expecting one or two arguments\");\n    }\n\n    VAR_4 = (u_char *) luaL_checklstring(VAR_0, 1, &VAR_6);\n\n    if (VAR_3 == 2) {\n        VAR_2 = (ngx_int_t) luaL_checknumber(VAR_0, 2);\n\n        if (VAR_2 != VAR_9\n            && VAR_2 != VAR_10\n            && VAR_2 != VAR_11\n            && VAR_2 != VAR_12\n            && VAR_2 != VAR_13)\n        {\n            return luaL_error(VAR_0, \"only ngx.HTTP_MOVED_TEMPORARILY, \"\n                              \"ngx.HTTP_MOVED_PERMANENTLY, \"\n                              \"ngx.HTTP_PERMANENT_REDIRECT, \"\n                              \"ngx.HTTP_SEE_OTHER, and \"\n                              \"ngx.HTTP_TEMPORARY_REDIRECT are allowed\");\n        }\n\n    } else {\n        VAR_2 = VAR_9;\n    }\n\n    VAR_8 = ngx_http_lua_get_req(VAR_0);\n    if (VAR_8 == NULL) {\n        return luaL_error(VAR_0, \"no request object found\");\n    }\n\n    VAR_1 = ngx_http_get_module_ctx(VAR_8, VAR_14);\n    if (VAR_1 == NULL) {\n        return luaL_error(VAR_0, \"no request ctx found\");\n    }\n\n    ngx_http_lua_check_context(VAR_0, VAR_1, VAR_15\n                               | VAR_16\n                               | VAR_17);\n\n    ngx_http_lua_check_if_abortable(VAR_0, VAR_1);\n\n    if (VAR_8->header_sent || VAR_1->header_sent) {\n        return luaL_error(VAR_0, \"attempt to call ngx.redirect after sending out \"\n                          \"the headers\");\n    }\n\n    VAR_6 = ngx_http_lua_safe_header_value_len(VAR_4, VAR_6);\n\n    VAR_5 = ngx_palloc(VAR_8->pool, VAR_6);\n    if (VAR_5 == NULL) {\n        return luaL_error(VAR_0, \"no memory\");\n    }\n\n    ngx_memcpy(VAR_5, VAR_4, VAR_6);\n\n    VAR_7 = ngx_list_push(&VAR_8->headers_out.headers);\n    if (VAR_7 == NULL) {\n        return luaL_error(VAR_0, \"no memory\");\n    }\n\n    VAR_7->hash = VAR_18;\n\n#if 0\n    dd(\"location hash: %lu == %lu\",\n       (unsigned long) VAR_7->hash,\n       (unsigned long) ngx_hash_key_lc((u_char *) \"Location\",\n                                       sizeof(\"Location\") - 1));\n#endif\n\n    VAR_7->value.len = VAR_6;\n    VAR_7->value.data = VAR_5;\n    ngx_str_set(&VAR_7->key, \"Location\");\n\n    VAR_8->headers_out.status = VAR_2;\n\n    VAR_1->exit_code = VAR_2;\n    VAR_1->exited = 1;\n\n    ngx_log_debug2(VAR_19, VAR_8->connection->log, 0,\n                   \"lua redirect to \\\"%V\\\" with code %i\",\n                   &VAR_7->value, VAR_1->exit_code);\n\n    if (VAR_6 && VAR_5[0] != '/') {\n        VAR_8->headers_out.location = VAR_7;\n    }\n\n    /* COMMENT_0 */\n                                                                       \n                                                                          \n       \n\n    return lua_yield(VAR_0, 0);\n}",
  "func_graph_path_before": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_control.c/vul/before/0.json",
  "func": "static int\nngx_http_lua_ngx_redirect(lua_State *L)\n{\n    ngx_http_lua_ctx_t          *ctx;\n    ngx_int_t                    rc;\n    int                          n;\n    u_char                      *p;\n    u_char                      *uri;\n    size_t                       len;\n    ngx_table_elt_t             *h;\n    ngx_http_request_t          *r;\n\n    n = lua_gettop(L);\n\n    if (n != 1 && n != 2) {\n        return luaL_error(L, \"expecting one or two arguments\");\n    }\n\n    p = (u_char *) luaL_checklstring(L, 1, &len);\n\n    if (n == 2) {\n        rc = (ngx_int_t) luaL_checknumber(L, 2);\n\n        if (rc != NGX_HTTP_MOVED_TEMPORARILY\n            && rc != NGX_HTTP_MOVED_PERMANENTLY\n            && rc != NGX_HTTP_SEE_OTHER\n            && rc != NGX_HTTP_PERMANENT_REDIRECT\n            && rc != NGX_HTTP_TEMPORARY_REDIRECT)\n        {\n            return luaL_error(L, \"only ngx.HTTP_MOVED_TEMPORARILY, \"\n                              \"ngx.HTTP_MOVED_PERMANENTLY, \"\n                              \"ngx.HTTP_PERMANENT_REDIRECT, \"\n                              \"ngx.HTTP_SEE_OTHER, and \"\n                              \"ngx.HTTP_TEMPORARY_REDIRECT are allowed\");\n        }\n\n    } else {\n        rc = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n\n    r = ngx_http_lua_get_req(L);\n    if (r == NULL) {\n        return luaL_error(L, \"no request object found\");\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\n    if (ctx == NULL) {\n        return luaL_error(L, \"no request ctx found\");\n    }\n\n    ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE\n                               | NGX_HTTP_LUA_CONTEXT_ACCESS\n                               | NGX_HTTP_LUA_CONTEXT_CONTENT);\n\n    ngx_http_lua_check_if_abortable(L, ctx);\n\n    if (r->header_sent || ctx->header_sent) {\n        return luaL_error(L, \"attempt to call ngx.redirect after sending out \"\n                          \"the headers\");\n    }\n\n    if (ngx_http_lua_check_header_safe(r, p, len) != NGX_OK) {\n        return luaL_error(L, \"attempt to use unsafe uri\");\n    }\n\n    uri = ngx_palloc(r->pool, len);\n    if (uri == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    ngx_memcpy(uri, p, len);\n\n    h = ngx_list_push(&r->headers_out.headers);\n    if (h == NULL) {\n        return luaL_error(L, \"no memory\");\n    }\n\n    h->hash = ngx_http_lua_location_hash;\n\n#if 0\n    dd(\"location hash: %lu == %lu\",\n       (unsigned long) h->hash,\n       (unsigned long) ngx_hash_key_lc((u_char *) \"Location\",\n                                       sizeof(\"Location\") - 1));\n#endif\n\n    h->value.len = len;\n    h->value.data = uri;\n    ngx_str_set(&h->key, \"Location\");\n\n    r->headers_out.status = rc;\n\n    ctx->exit_code = rc;\n    ctx->exited = 1;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"lua redirect to \\\"%V\\\" with code %i\",\n                   &h->value, ctx->exit_code);\n\n    if (len && uri[0] != '/') {\n        r->headers_out.location = h;\n    }\n\n    /*\n     * we do not set r->headers_out.location here to avoid the handling\n     * the local redirects without a host name by ngx_http_header_filter()\n     */\n\n    return lua_yield(L, 0);\n}",
  "abstract_func": "static int\nngx_http_lua_ngx_redirect(lua_State *VAR_0)\n{\n    ngx_http_lua_ctx_t          *VAR_1;\n    ngx_int_t                    VAR_2;\n    int                          VAR_3;\n    u_char                      *VAR_4;\n    u_char                      *VAR_5;\n    size_t                       VAR_6;\n    ngx_table_elt_t             *VAR_7;\n    ngx_http_request_t          *VAR_8;\n\n    VAR_3 = lua_gettop(VAR_0);\n\n    if (VAR_3 != 1 && VAR_3 != 2) {\n        return luaL_error(VAR_0, \"expecting one or two arguments\");\n    }\n\n    VAR_4 = (u_char *) luaL_checklstring(VAR_0, 1, &VAR_6);\n\n    if (VAR_3 == 2) {\n        VAR_2 = (ngx_int_t) luaL_checknumber(VAR_0, 2);\n\n        if (VAR_2 != VAR_9\n            && VAR_2 != VAR_10\n            && VAR_2 != VAR_11\n            && VAR_2 != VAR_12\n            && VAR_2 != VAR_13)\n        {\n            return luaL_error(VAR_0, \"only ngx.HTTP_MOVED_TEMPORARILY, \"\n                              \"ngx.HTTP_MOVED_PERMANENTLY, \"\n                              \"ngx.HTTP_PERMANENT_REDIRECT, \"\n                              \"ngx.HTTP_SEE_OTHER, and \"\n                              \"ngx.HTTP_TEMPORARY_REDIRECT are allowed\");\n        }\n\n    } else {\n        VAR_2 = VAR_9;\n    }\n\n    VAR_8 = ngx_http_lua_get_req(VAR_0);\n    if (VAR_8 == NULL) {\n        return luaL_error(VAR_0, \"no request object found\");\n    }\n\n    VAR_1 = ngx_http_get_module_ctx(VAR_8, VAR_14);\n    if (VAR_1 == NULL) {\n        return luaL_error(VAR_0, \"no request ctx found\");\n    }\n\n    ngx_http_lua_check_context(VAR_0, VAR_1, VAR_15\n                               | VAR_16\n                               | VAR_17);\n\n    ngx_http_lua_check_if_abortable(VAR_0, VAR_1);\n\n    if (VAR_8->header_sent || VAR_1->header_sent) {\n        return luaL_error(VAR_0, \"attempt to call ngx.redirect after sending out \"\n                          \"the headers\");\n    }\n\n    if (ngx_http_lua_check_header_safe(VAR_8, VAR_4, VAR_6) != VAR_18) {\n        return luaL_error(VAR_0, \"attempt to use unsafe uri\");\n    }\n\n    VAR_5 = ngx_palloc(VAR_8->pool, VAR_6);\n    if (VAR_5 == NULL) {\n        return luaL_error(VAR_0, \"no memory\");\n    }\n\n    ngx_memcpy(VAR_5, VAR_4, VAR_6);\n\n    VAR_7 = ngx_list_push(&VAR_8->headers_out.headers);\n    if (VAR_7 == NULL) {\n        return luaL_error(VAR_0, \"no memory\");\n    }\n\n    VAR_7->hash = VAR_19;\n\n#if 0\n    dd(\"location hash: %lu == %lu\",\n       (unsigned long) VAR_7->hash,\n       (unsigned long) ngx_hash_key_lc((u_char *) \"Location\",\n                                       sizeof(\"Location\") - 1));\n#endif\n\n    VAR_7->value.len = VAR_6;\n    VAR_7->value.data = VAR_5;\n    ngx_str_set(&VAR_7->key, \"Location\");\n\n    VAR_8->headers_out.status = VAR_2;\n\n    VAR_1->exit_code = VAR_2;\n    VAR_1->exited = 1;\n\n    ngx_log_debug2(VAR_20, VAR_8->connection->log, 0,\n                   \"lua redirect to \\\"%V\\\" with code %i\",\n                   &VAR_7->value, VAR_1->exit_code);\n\n    if (VAR_6 && VAR_5[0] != '/') {\n        VAR_8->headers_out.location = VAR_7;\n    }\n\n    /* COMMENT_0 */\n                                                                       \n                                                                          \n       \n\n    return lua_yield(VAR_0, 0);\n}",
  "func_graph_path": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_control.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -59,7 +59,9 @@\n                           \"the headers\");\n     }\n \n-    len = ngx_http_lua_safe_header_value_len(p, len);\n+    if (ngx_http_lua_check_header_safe(r, p, len) != NGX_OK) {\n+        return luaL_error(L, \"attempt to use unsafe uri\");\n+    }\n \n     uri = ngx_palloc(r->pool, len);\n     if (uri == NULL) {",
  "diff_line_info": {
    "deleted_lines": [
      "    len = ngx_http_lua_safe_header_value_len(p, len);"
    ],
    "added_lines": [
      "    if (ngx_http_lua_check_header_safe(r, p, len) != NGX_OK) {",
      "        return luaL_error(L, \"attempt to use unsafe uri\");",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openresty/lua-nginx-module/pull/1654",
  "description": {
    "pr_info": {
      "title": "bugfix: ensured arguments of APIs mutating uri or request/response headers do not contain unsafe characters.",
      "number": 1654
    },
    "comment": [
      "I hereby granted the copyright of the changes in this pull request\nto the authors of this lua-nginx-module project.",
      "(Rebased on top of master due to a newly failing tests caused by changes in openresty.org's accepted ciphers)",
      "Just pushed an additional commit with more fixes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}