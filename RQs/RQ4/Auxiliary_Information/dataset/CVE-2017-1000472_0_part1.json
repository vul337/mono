{
  "cve_id": "CVE-2017-1000472",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "pocoproject/poco",
  "commit_msg": "- fix Zip Decompress Parent Path Injection #1968 bug\n- add valid patch check test\n- add vulnearbility triggering zip archive and test\n- remove temporary test output files\n- if possible, redirect temporary file generation to temp directory or\n- delete temporary files after tests",
  "commit_hash": "f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d",
  "git_url": "https://github.com/pocoproject/poco/commit/f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d",
  "file_path": "Zip/src/Decompress.cpp",
  "func_name": "Decompress::handleZipEntry",
  "func_before": "bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)\n{\n\tif (hdr.isDirectory())\n\t{\n\t\t// directory have 0 size, nth to read\n\t\tif (!_flattenDirs)\n\t\t{\n\t\t\tstd::string dirName = hdr.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(dirName))\n\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tdir.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\taFile.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string fileName = hdr.getFileName();\n\t\tif (_flattenDirs)\n\t\t{\n\t\t\t// remove path info\n\t\t\tPoco::Path p(fileName);\n\t\t\tp.makeFile();\n\t\t\tfileName = p.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");\n\n\t\tPoco::Path file(fileName);\n\t\tfile.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tdest.makeFile();\n\t\tif (dest.depth() > 0)\n\t\t{\n\t\t\tPoco::File aFile(dest.parent());\n\t\t\taFile.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream out(dest.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(inp, out);\n\t\tout.close();\n\t\tPoco::File aFile(dest.toString());\n\t\tif (!aFile.exists() || !aFile.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Failed to create output stream \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!inp.crcValid())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\t// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo\n\t\t// crc is typically enough to detect errors\n\t\tif (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);\n\t\tEOk.notify(this, tmp);\n\t}\n\tcatch (Poco::Exception& e)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Exception: \" + e.displayText()));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
  "abstract_func_before": "bool Decompress::handleZipEntry(std::istream& VAR_0, const ZipLocalFileHeader& VAR_1)\n{\n\tif (VAR_1.isDirectory())\n\t{\n\t\t/* COMMENT_0 */\n\t\tif (!VAR_2)\n\t\t{\n\t\t\tstd::string VAR_3 = VAR_1.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(VAR_3))\n\t\t\t\tthrow ZipException(\"Illegal entry name \" + VAR_3 + \" containing parent directory reference\");\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tVAR_4.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\tVAR_5.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string VAR_6 = VAR_1.getFileName();\n\t\tif (VAR_2)\n\t\t{\n\t\t\t/* COMMENT_1 */\n\t\t\tPoco::Path p(fileName);\n\t\t\tVAR_7.makeFile();\n\t\t\tfileName = VAR_7.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");\n\n\t\tPoco::Path file(fileName);\n\t\tVAR_8.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tVAR_9.makeFile();\n\t\tif (VAR_9.depth() > 0)\n\t\t{\n\t\t\tPoco::File VAR_5(VAR_9.parent());\n\t\t\tVAR_5.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream VAR_10(VAR_9.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(VAR_11, VAR_10);\n\t\tVAR_10.close();\n\t\tPoco::File VAR_5(VAR_9.toString());\n\t\tif (!VAR_5.exists() || !VAR_5.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, \"Failed to create output stream \" + VAR_9.toString());\n\t\t\tVAR_13.notify(this, VAR_12);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!VAR_11.crcValid())\n\t\t{\n\t\t\tif (!VAR_14)\n\t\t\t\tVAR_5.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + VAR_9.toString());\n\t\t\tVAR_13.notify(this, VAR_12);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tif (VAR_5.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!VAR_14)\n\t\t\t\tVAR_5.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + VAR_9.toString());\n\t\t\tVAR_13.notify(this, VAR_12);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> VAR_12 = std::make_pair(hdr, file);\n\t\tVAR_15.notify(this, VAR_12);\n\t}\n\tcatch (Poco::Exception& VAR_16)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(\"Exception: \" + VAR_16.displayText()));\n\t\tVAR_13.notify(this, VAR_12);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tVAR_13.notify(this, VAR_12);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
  "func_graph_path_before": null,
  "func": "bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)\n{\n\tif (hdr.isDirectory())\n\t{\n\t\t// directory have 0 size, nth to read\n\t\tif (!_flattenDirs)\n\t\t{\n\t\t\tstd::string dirName = hdr.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(dirName))\n\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName);\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tdir.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\taFile.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string fileName = hdr.getFileName();\n\t\tif (_flattenDirs)\n\t\t{\n\t\t\t// remove path info\n\t\t\tPoco::Path p(fileName);\n\t\t\tp.makeFile();\n\t\t\tfileName = p.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name \" + fileName);\n\n\t\tPoco::Path file(fileName);\n\t\tfile.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tdest.makeFile();\n\t\tif (dest.depth() > 0)\n\t\t{\n\t\t\tPoco::File aFile(dest.parent());\n\t\t\taFile.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream out(dest.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(inp, out);\n\t\tout.close();\n\t\tPoco::File aFile(dest.toString());\n\t\tif (!aFile.exists() || !aFile.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Failed to create output stream \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!inp.crcValid())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\t// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo\n\t\t// crc is typically enough to detect errors\n\t\tif (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);\n\t\tEOk.notify(this, tmp);\n\t}\n\tcatch (Poco::Exception& e)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Exception: \" + e.displayText()));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
  "abstract_func": "bool Decompress::handleZipEntry(std::istream& VAR_0, const ZipLocalFileHeader& VAR_1)\n{\n\tif (VAR_1.isDirectory())\n\t{\n\t\t/* COMMENT_0 */\n\t\tif (!VAR_2)\n\t\t{\n\t\t\tstd::string VAR_3 = VAR_1.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(VAR_3))\n\t\t\t\tthrow ZipException(\"Illegal entry name \" + VAR_3);\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tVAR_4.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\tVAR_5.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string VAR_6 = VAR_1.getFileName();\n\t\tif (VAR_2)\n\t\t{\n\t\t\t/* COMMENT_1 */\n\t\t\tPoco::Path p(fileName);\n\t\t\tVAR_7.makeFile();\n\t\t\tfileName = VAR_7.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name \" + fileName);\n\n\t\tPoco::Path file(fileName);\n\t\tVAR_8.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tVAR_9.makeFile();\n\t\tif (VAR_9.depth() > 0)\n\t\t{\n\t\t\tPoco::File VAR_5(VAR_9.parent());\n\t\t\tVAR_5.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream VAR_10(VAR_9.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(VAR_11, VAR_10);\n\t\tVAR_10.close();\n\t\tPoco::File VAR_5(VAR_9.toString());\n\t\tif (!VAR_5.exists() || !VAR_5.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, \"Failed to create output stream \" + VAR_9.toString());\n\t\t\tVAR_13.notify(this, VAR_12);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!VAR_11.crcValid())\n\t\t{\n\t\t\tif (!VAR_14)\n\t\t\t\tVAR_5.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + VAR_9.toString());\n\t\t\tVAR_13.notify(this, VAR_12);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tif (VAR_5.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!VAR_14)\n\t\t\t\tVAR_5.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + VAR_9.toString());\n\t\t\tVAR_13.notify(this, VAR_12);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> VAR_12 = std::make_pair(hdr, file);\n\t\tVAR_15.notify(this, VAR_12);\n\t}\n\tcatch (Poco::Exception& VAR_16)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(\"Exception: \" + VAR_16.displayText()));\n\t\tVAR_13.notify(this, VAR_12);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> VAR_12 = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tVAR_13.notify(this, VAR_12);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \t\t{\n \t\t\tstd::string dirName = hdr.getFileName();\n \t\t\tif (!ZipCommon::isValidPath(dirName))\n-\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");\n+\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName);\n \t\t\tPoco::Path dir(_outDir, dirName);\n \t\t\tdir.makeDirectory();\n \t\t\tPoco::File aFile(dir);\n@@ -27,7 +27,7 @@\n \t\t}\n \n \t\tif (!ZipCommon::isValidPath(fileName))\n-\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");\n+\t\t\tthrow ZipException(\"Illegal entry name \" + fileName);\n \n \t\tPoco::Path file(fileName);\n \t\tfile.makeFile();",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");",
      "\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");"
    ],
    "added_lines": [
      "\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName);",
      "\t\t\tthrow ZipException(\"Illegal entry name \" + fileName);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/pocoproject/poco/pull/2031",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/pocoproject/poco/pull/2031: 403 Client Error: Forbidden for url: https://api.github.com/repos/pocoproject/poco/pulls/2031",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95\n\nThe patch addresses a Zip Slip vulnerability by validating file paths to prevent directory traversal attacks during zip file extraction. The modifications in the code, combined with the addition of tests, clearly indicate a security fix."
}