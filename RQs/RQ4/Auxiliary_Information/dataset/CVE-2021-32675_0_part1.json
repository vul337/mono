{
  "cve_id": "CVE-2021-32675",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
  "commit_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
  "git_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
  "file_path": "src/server.c",
  "func_name": "processCommand",
  "func_before": "int processCommand(client *c) {\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    if (auth_required) {\n        /* AUTH and HELLO and no auth modules are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n        else\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;\n        /* freeMemoryIfNeeded may flush slave output buffers. This may result\n         * into a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return C_OK;\n}",
  "abstract_func_before": "int processCommand(client *VAR_0) {\n    moduleCallCommandFilters(VAR_0);\n\n    /* COMMENT_0 */\n                                                                      \n                                                                    \n                                 \n    if (!strcasecmp(VAR_0->argv[0]->ptr,\"quit\")) {\n        addReply(VAR_0,VAR_1.ok);\n        VAR_0->flags |= VAR_2;\n        return VAR_3;\n    }\n\n    /* COMMENT_4 */\n                                                             \n    VAR_0->cmd = VAR_0->lastcmd = lookupCommand(VAR_0->argv[0]->ptr);\n    if (!VAR_0->cmd) {\n        sds VAR_4 = sdsempty();\n        int VAR_5;\n        for (VAR_5=1; VAR_5 < VAR_0->argc && sdslen(VAR_4) < 128; VAR_5++)\n            VAR_4 = sdscatprintf(VAR_4, \"`%.*s`, \", 128-(int)sdslen(VAR_4), (char*)VAR_0->argv[VAR_5]->ptr);\n        rejectCommandFormat(VAR_0,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)VAR_0->argv[0]->ptr, VAR_4);\n        sdsfree(VAR_4);\n        return VAR_6;\n    } else if ((VAR_0->cmd->arity > 0 && VAR_0->cmd->arity != VAR_0->argc) ||\n               (VAR_0->argc < -VAR_0->cmd->arity)) {\n        rejectCommandFormat(VAR_0,\"wrong number of arguments for '%s' command\",\n            VAR_0->cmd->name);\n        return VAR_6;\n    }\n\n    int VAR_7 = (VAR_0->cmd->flags & VAR_8) ||\n                           (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_flags & VAR_8));\n    int VAR_10 = (VAR_0->cmd->flags & VAR_11) ||\n                             (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_flags & VAR_11));\n    int VAR_12 = !(VAR_0->cmd->flags & VAR_13) ||\n                               (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_inv_flags & VAR_13));\n    int VAR_14 = !(VAR_0->cmd->flags & VAR_15) ||\n                                 (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_inv_flags & VAR_15));\n\n    /* COMMENT_6 */\n                                                                \n    int VAR_16 = (!(VAR_17->flags & VAR_18) ||\n                          (VAR_17->flags & VAR_19)) &&\n                        !VAR_0->authenticated;\n    if (VAR_16) {\n        /* COMMENT_8 */\n                                      \n        if (!(VAR_0->cmd->flags & VAR_20)) {\n            rejectCommand(VAR_0,VAR_1.noautherr);\n            return VAR_6;\n        }\n    }\n\n    /* COMMENT_10 */\n               \n    int VAR_21;\n    int VAR_22 = ACLCheckCommandPerm(VAR_0,&VAR_21);\n    if (VAR_22 != VAR_23) {\n        addACLLogEntry(VAR_0,VAR_22,VAR_21,NULL);\n        if (VAR_22 == VAR_24)\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", VAR_0->cmd->name);\n        else\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return VAR_6;\n    }\n\n    /* COMMENT_12 */\n                                                   \n                                                   \n                                              \n    if (VAR_25.cluster_enabled &&\n        !(VAR_0->flags & VAR_26) &&\n        !(VAR_0->flags & VAR_27 &&\n          VAR_25.lua_caller->flags & VAR_26) &&\n        !(VAR_0->cmd->getkeys_proc == NULL && VAR_0->cmd->firstkey == 0 &&\n          VAR_0->cmd->proc != VAR_9))\n    {\n        int VAR_28;\n        int VAR_29;\n        clusterNode *VAR_30 = getNodeByQuery(VAR_0,VAR_0->cmd,VAR_0->argv,VAR_0->argc,\n                                        &VAR_28,&VAR_29);\n        if (VAR_30 == NULL || VAR_30 != VAR_25.cluster->myself) {\n            if (VAR_0->cmd->proc == VAR_9) {\n                discardTransaction(VAR_0);\n            } else {\n                flagTransaction(VAR_0);\n            }\n            clusterRedirectClient(VAR_0,VAR_30,VAR_28,VAR_29);\n            return VAR_6;\n        }\n    }\n\n    /* COMMENT_16 */\n      \n                                                                            \n                                                                         \n                                                                     \n                                              \n    if (VAR_25.maxmemory && !VAR_25.lua_timedout) {\n        int VAR_31 = freeMemoryIfNeededAndSafe() == VAR_3;\n        /* COMMENT_22 */\n                                                                       \n        if (VAR_25.current_client == NULL) return VAR_3;\n\n        int VAR_32 = VAR_10;\n        /* COMMENT_24 */\n                                                     \n                                                                            \n                                                                                \n                  \n        if (VAR_0->flags & VAR_33 &&\n            VAR_0->cmd->proc != VAR_9 &&\n            VAR_0->cmd->proc != VAR_34) {\n            VAR_32 = 1;\n        }\n\n        if (VAR_31 && VAR_32) {\n            rejectCommand(VAR_0, VAR_1.oomerr);\n            return VAR_6;\n        }\n\n        /* COMMENT_29 */\n                                                                        \n                                        \n        if (VAR_0->cmd->proc == VAR_35 || VAR_0->cmd->proc == VAR_36) {\n            VAR_25.lua_oom = VAR_31;\n        }\n    }\n\n    /* COMMENT_32 */\n                           \n    if (VAR_25.tracking_clients) trackingLimitUsedSlots();\n\n    /* COMMENT_34 */\n                                           \n    int VAR_37 = writeCommandsDeniedByDiskError();\n    if (VAR_37 != VAR_38 &&\n        VAR_25.masterhost == NULL &&\n        (VAR_7 ||VAR_0->cmd->proc == VAR_39))\n    {\n        if (VAR_37 == VAR_40)\n            rejectCommand(VAR_0, VAR_1.bgsaveerr);\n        else\n            rejectCommandFormat(VAR_0,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(VAR_25.aof_last_write_errno));\n        return VAR_6;\n    }\n\n    /* COMMENT_36 */\n                                                         \n    if (VAR_25.masterhost == NULL &&\n        VAR_25.repl_min_slaves_to_write &&\n        VAR_25.repl_min_slaves_max_lag &&\n        VAR_7 &&\n        VAR_25.repl_good_slaves_count < VAR_25.repl_min_slaves_to_write)\n    {\n        rejectCommand(VAR_0, VAR_1.noreplicaserr);\n        return VAR_6;\n    }\n\n    /* COMMENT_38 */\n                                                      \n    if (VAR_25.masterhost && VAR_25.repl_slave_ro &&\n        !(VAR_0->flags & VAR_26) &&\n        VAR_7)\n    {\n        rejectCommand(VAR_0, VAR_1.roslaveerr);\n        return VAR_6;\n    }\n\n    /* COMMENT_40 */\n                                                                      \n    if ((VAR_0->flags & VAR_41 && VAR_0->resp == 2) &&\n        VAR_0->cmd->proc != VAR_39 &&\n        VAR_0->cmd->proc != VAR_42 &&\n        VAR_0->cmd->proc != VAR_43 &&\n        VAR_0->cmd->proc != VAR_44 &&\n        VAR_0->cmd->proc != VAR_45) {\n        rejectCommandFormat(VAR_0,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            VAR_0->cmd->name);\n        return VAR_6;\n    }\n\n    /* COMMENT_42 */\n                                                                         \n                           \n    if (VAR_25.masterhost && VAR_25.repl_state != VAR_46 &&\n        VAR_25.repl_serve_stale_data == 0 &&\n        VAR_12)\n    {\n        rejectCommand(VAR_0, VAR_1.masterdownerr);\n        return VAR_6;\n    }\n\n    /* COMMENT_45 */\n                           \n    if (VAR_25.loading && VAR_14) {\n        rejectCommand(VAR_0, VAR_1.loadingerr);\n        return VAR_6;\n    }\n\n    /* COMMENT_47 */\n                                                                              \n                                                                             \n                                                                      \n                                                                      \n                                        \n    if (VAR_25.lua_timedout &&\n          VAR_0->cmd->proc != VAR_47 &&\n          VAR_0->cmd->proc != VAR_48 &&\n          VAR_0->cmd->proc != VAR_49 &&\n          VAR_0->cmd->proc != VAR_50 &&\n          VAR_0->cmd->proc != VAR_34 &&\n          VAR_0->cmd->proc != VAR_51 &&\n          VAR_0->cmd->proc != VAR_52 &&\n        !(VAR_0->cmd->proc == VAR_53 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'n') &&\n        !(VAR_0->cmd->proc == VAR_54 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(VAR_0, VAR_1.slowscripterr);\n        return VAR_6;\n    }\n\n    /* COMMENT_53 */\n    if (VAR_0->flags & VAR_33 &&\n        VAR_0->cmd->proc != VAR_9 && VAR_0->cmd->proc != VAR_34 &&\n        VAR_0->cmd->proc != VAR_50 && VAR_0->cmd->proc != VAR_51)\n    {\n        queueMultiCommand(VAR_0);\n        addReply(VAR_0,VAR_1.queued);\n    } else {\n        call(VAR_0,VAR_55);\n        VAR_0->woff = VAR_25.master_repl_offset;\n        if (listLength(VAR_25.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return VAR_6;\n}",
  "func_graph_path_before": "redis/5674b0057ff2903d43eaff802017eddf37c360f8/server.c/vul/before/0.json",
  "func": "int processCommand(client *c) {\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n\n    if (authRequired(c)) {\n        /* AUTH and HELLO and no auth commands are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n        else\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;\n        /* freeMemoryIfNeeded may flush slave output buffers. This may result\n         * into a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return C_OK;\n}",
  "abstract_func": "int processCommand(client *VAR_0) {\n    moduleCallCommandFilters(VAR_0);\n\n    /* COMMENT_0 */\n                                                                      \n                                                                    \n                                 \n    if (!strcasecmp(VAR_0->argv[0]->ptr,\"quit\")) {\n        addReply(VAR_0,VAR_1.ok);\n        VAR_0->flags |= VAR_2;\n        return VAR_3;\n    }\n\n    /* COMMENT_4 */\n                                                             \n    VAR_0->cmd = VAR_0->lastcmd = lookupCommand(VAR_0->argv[0]->ptr);\n    if (!VAR_0->cmd) {\n        sds VAR_4 = sdsempty();\n        int VAR_5;\n        for (VAR_5=1; VAR_5 < VAR_0->argc && sdslen(VAR_4) < 128; VAR_5++)\n            VAR_4 = sdscatprintf(VAR_4, \"`%.*s`, \", 128-(int)sdslen(VAR_4), (char*)VAR_0->argv[VAR_5]->ptr);\n        rejectCommandFormat(VAR_0,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)VAR_0->argv[0]->ptr, VAR_4);\n        sdsfree(VAR_4);\n        return VAR_6;\n    } else if ((VAR_0->cmd->arity > 0 && VAR_0->cmd->arity != VAR_0->argc) ||\n               (VAR_0->argc < -VAR_0->cmd->arity)) {\n        rejectCommandFormat(VAR_0,\"wrong number of arguments for '%s' command\",\n            VAR_0->cmd->name);\n        return VAR_6;\n    }\n\n    int VAR_7 = (VAR_0->cmd->flags & VAR_8) ||\n                           (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_flags & VAR_8));\n    int VAR_10 = (VAR_0->cmd->flags & VAR_11) ||\n                             (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_flags & VAR_11));\n    int VAR_12 = !(VAR_0->cmd->flags & VAR_13) ||\n                               (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_inv_flags & VAR_13));\n    int VAR_14 = !(VAR_0->cmd->flags & VAR_15) ||\n                                 (VAR_0->cmd->proc == VAR_9 && (VAR_0->mstate.cmd_inv_flags & VAR_15));\n\n    if (authRequired(VAR_0)) {\n        /* COMMENT_6 */\n                                      \n        if (!(VAR_0->cmd->flags & VAR_16)) {\n            rejectCommand(VAR_0,VAR_1.noautherr);\n            return VAR_6;\n        }\n    }\n\n    /* COMMENT_8 */\n               \n    int VAR_17;\n    int VAR_18 = ACLCheckCommandPerm(VAR_0,&VAR_17);\n    if (VAR_18 != VAR_19) {\n        addACLLogEntry(VAR_0,VAR_18,VAR_17,NULL);\n        if (VAR_18 == VAR_20)\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", VAR_0->cmd->name);\n        else\n            rejectCommandFormat(VAR_0,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return VAR_6;\n    }\n\n    /* COMMENT_10 */\n                                                   \n                                                   \n                                              \n    if (VAR_21.cluster_enabled &&\n        !(VAR_0->flags & VAR_22) &&\n        !(VAR_0->flags & VAR_23 &&\n          VAR_21.lua_caller->flags & VAR_22) &&\n        !(VAR_0->cmd->getkeys_proc == NULL && VAR_0->cmd->firstkey == 0 &&\n          VAR_0->cmd->proc != VAR_9))\n    {\n        int VAR_24;\n        int VAR_25;\n        clusterNode *VAR_26 = getNodeByQuery(VAR_0,VAR_0->cmd,VAR_0->argv,VAR_0->argc,\n                                        &VAR_24,&VAR_25);\n        if (VAR_26 == NULL || VAR_26 != VAR_21.cluster->myself) {\n            if (VAR_0->cmd->proc == VAR_9) {\n                discardTransaction(VAR_0);\n            } else {\n                flagTransaction(VAR_0);\n            }\n            clusterRedirectClient(VAR_0,VAR_26,VAR_24,VAR_25);\n            return VAR_6;\n        }\n    }\n\n    /* COMMENT_14 */\n      \n                                                                            \n                                                                         \n                                                                     \n                                              \n    if (VAR_21.maxmemory && !VAR_21.lua_timedout) {\n        int VAR_27 = freeMemoryIfNeededAndSafe() == VAR_3;\n        /* COMMENT_20 */\n                                                                       \n        if (VAR_21.current_client == NULL) return VAR_3;\n\n        int VAR_28 = VAR_10;\n        /* COMMENT_22 */\n                                                     \n                                                                            \n                                                                                \n                  \n        if (VAR_0->flags & VAR_29 &&\n            VAR_0->cmd->proc != VAR_9 &&\n            VAR_0->cmd->proc != VAR_30) {\n            VAR_28 = 1;\n        }\n\n        if (VAR_27 && VAR_28) {\n            rejectCommand(VAR_0, VAR_1.oomerr);\n            return VAR_6;\n        }\n\n        /* COMMENT_27 */\n                                                                        \n                                        \n        if (VAR_0->cmd->proc == VAR_31 || VAR_0->cmd->proc == VAR_32) {\n            VAR_21.lua_oom = VAR_27;\n        }\n    }\n\n    /* COMMENT_30 */\n                           \n    if (VAR_21.tracking_clients) trackingLimitUsedSlots();\n\n    /* COMMENT_32 */\n                                           \n    int VAR_33 = writeCommandsDeniedByDiskError();\n    if (VAR_33 != VAR_34 &&\n        VAR_21.masterhost == NULL &&\n        (VAR_7 ||VAR_0->cmd->proc == VAR_35))\n    {\n        if (VAR_33 == VAR_36)\n            rejectCommand(VAR_0, VAR_1.bgsaveerr);\n        else\n            rejectCommandFormat(VAR_0,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(VAR_21.aof_last_write_errno));\n        return VAR_6;\n    }\n\n    /* COMMENT_34 */\n                                                         \n    if (VAR_21.masterhost == NULL &&\n        VAR_21.repl_min_slaves_to_write &&\n        VAR_21.repl_min_slaves_max_lag &&\n        VAR_7 &&\n        VAR_21.repl_good_slaves_count < VAR_21.repl_min_slaves_to_write)\n    {\n        rejectCommand(VAR_0, VAR_1.noreplicaserr);\n        return VAR_6;\n    }\n\n    /* COMMENT_36 */\n                                                      \n    if (VAR_21.masterhost && VAR_21.repl_slave_ro &&\n        !(VAR_0->flags & VAR_22) &&\n        VAR_7)\n    {\n        rejectCommand(VAR_0, VAR_1.roslaveerr);\n        return VAR_6;\n    }\n\n    /* COMMENT_38 */\n                                                                      \n    if ((VAR_0->flags & VAR_37 && VAR_0->resp == 2) &&\n        VAR_0->cmd->proc != VAR_35 &&\n        VAR_0->cmd->proc != VAR_38 &&\n        VAR_0->cmd->proc != VAR_39 &&\n        VAR_0->cmd->proc != VAR_40 &&\n        VAR_0->cmd->proc != VAR_41) {\n        rejectCommandFormat(VAR_0,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            VAR_0->cmd->name);\n        return VAR_6;\n    }\n\n    /* COMMENT_40 */\n                                                                         \n                           \n    if (VAR_21.masterhost && VAR_21.repl_state != VAR_42 &&\n        VAR_21.repl_serve_stale_data == 0 &&\n        VAR_12)\n    {\n        rejectCommand(VAR_0, VAR_1.masterdownerr);\n        return VAR_6;\n    }\n\n    /* COMMENT_43 */\n                           \n    if (VAR_21.loading && VAR_14) {\n        rejectCommand(VAR_0, VAR_1.loadingerr);\n        return VAR_6;\n    }\n\n    /* COMMENT_45 */\n                                                                              \n                                                                             \n                                                                      \n                                                                      \n                                        \n    if (VAR_21.lua_timedout &&\n          VAR_0->cmd->proc != VAR_43 &&\n          VAR_0->cmd->proc != VAR_44 &&\n          VAR_0->cmd->proc != VAR_45 &&\n          VAR_0->cmd->proc != VAR_46 &&\n          VAR_0->cmd->proc != VAR_30 &&\n          VAR_0->cmd->proc != VAR_47 &&\n          VAR_0->cmd->proc != VAR_48 &&\n        !(VAR_0->cmd->proc == VAR_49 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'n') &&\n        !(VAR_0->cmd->proc == VAR_50 &&\n          VAR_0->argc == 2 &&\n          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(VAR_0, VAR_1.slowscripterr);\n        return VAR_6;\n    }\n\n    /* COMMENT_51 */\n    if (VAR_0->flags & VAR_29 &&\n        VAR_0->cmd->proc != VAR_9 && VAR_0->cmd->proc != VAR_30 &&\n        VAR_0->cmd->proc != VAR_46 && VAR_0->cmd->proc != VAR_47)\n    {\n        queueMultiCommand(VAR_0);\n        addReply(VAR_0,VAR_1.queued);\n    } else {\n        call(VAR_0,VAR_51);\n        VAR_0->woff = VAR_21.master_repl_offset;\n        if (listLength(VAR_21.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return VAR_6;\n}",
  "func_graph_path": "redis/5674b0057ff2903d43eaff802017eddf37c360f8/server.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -39,13 +39,8 @@\n     int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                  (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n \n-    /* Check if the user is authenticated. This check is skipped in case\n-     * the default user is flagged as \"nopass\" and is active. */\n-    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n-                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n-                        !c->authenticated;\n-    if (auth_required) {\n-        /* AUTH and HELLO and no auth modules are valid even in\n+    if (authRequired(c)) {\n+        /* AUTH and HELLO and no auth commands are valid even in\n          * non-authenticated state. */\n         if (!(c->cmd->flags & CMD_NO_AUTH)) {\n             rejectCommand(c,shared.noautherr);",
  "diff_line_info": {
    "deleted_lines": [
      "    /* Check if the user is authenticated. This check is skipped in case",
      "     * the default user is flagged as \"nopass\" and is active. */",
      "    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
      "                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
      "                        !c->authenticated;",
      "    if (auth_required) {",
      "        /* AUTH and HELLO and no auth modules are valid even in"
    ],
    "added_lines": [
      "    if (authRequired(c)) {",
      "        /* AUTH and HELLO and no auth commands are valid even in"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}