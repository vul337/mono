{
  "cve_id": "CVE-2022-40138",
  "cwe_ids": [
    "CWE-681"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#822)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "6aa825e480d48127b480b08d13adf70033237097",
  "git_url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
  "file_path": "lib/VM/Interpreter.cpp",
  "func_name": "Runtime::interpretFunctionImpl",
  "func_before": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(*this);\n\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  // We always call getCurrentIP() in a debug build as this has the effect\n  // of asserting the IP is correctly set (not invalidated) at this point.\n  // This allows us to leverage our whole test-suite to find missing cases\n  // of CAPTURE_IP* macros in the interpreter loop.\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    // All functions end in a Ret so we must match this with a pushCallStack()\n    // before executing.\n    if (codeBlock) {\n      // Push a call entry at the last location we were executing bytecode.\n      // This will correctly attribute things like eval().\n      pushCallStack(codeBlock, ip);\n    } else {\n      // Push a call entry at the entry at the top of interpreted code.\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    // Push a call entry at the entry at the top of interpreted code.\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}",
  "abstract_func_before": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *VAR_0) {\n  VAR_0->lazyCompile(*this);\n\n#if defined(VAR_1) || !defined(VAR_2)\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  const inst::Inst *VAR_3 = getCurrentIP();\n  (void)VAR_3;\n#endif\n#ifdef VAR_1\n  if (VAR_3) {\n    const CodeBlock *VAR_4;\n    std::tie(VAR_4, VAR_3) = getCurrentInterpreterLocation(VAR_3);\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    if (VAR_4) {\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      pushCallStack(VAR_4, VAR_3);\n    } else {\n      /* COMMENT_8 */\n      pushCallStack(VAR_0, (const Inst *)VAR_0->begin());\n    }\n  } else {\n    /* COMMENT_8 */\n    pushCallStack(VAR_0, (const Inst *)VAR_0->begin());\n  }\n#endif\n\n  InterpreterState VAR_5{VAR_0, 0};\n  if (VAR_6 &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::VAR_7<false, true>(*this, VAR_5);\n  } else {\n    return Interpreter::VAR_7<false, false>(*this, VAR_5);\n  }\n}",
  "func_graph_path_before": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Interpreter.cpp/vul/before/0.json",
  "func": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  if (LLVM_UNLIKELY(\n          newCodeBlock->lazyCompile(*this) == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  // We always call getCurrentIP() in a debug build as this has the effect\n  // of asserting the IP is correctly set (not invalidated) at this point.\n  // This allows us to leverage our whole test-suite to find missing cases\n  // of CAPTURE_IP* macros in the interpreter loop.\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    // All functions end in a Ret so we must match this with a pushCallStack()\n    // before executing.\n    if (codeBlock) {\n      // Push a call entry at the last location we were executing bytecode.\n      // This will correctly attribute things like eval().\n      pushCallStack(codeBlock, ip);\n    } else {\n      // Push a call entry at the entry at the top of interpreted code.\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    // Push a call entry at the entry at the top of interpreted code.\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}",
  "abstract_func": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *VAR_0) {\n  if (LLVM_UNLIKELY(\n          VAR_0->lazyCompile(*this) == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n#if defined(VAR_1) || !defined(VAR_2)\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  const inst::Inst *VAR_3 = getCurrentIP();\n  (void)VAR_3;\n#endif\n#ifdef VAR_1\n  if (VAR_3) {\n    const CodeBlock *VAR_4;\n    std::tie(VAR_4, VAR_3) = getCurrentInterpreterLocation(VAR_3);\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    if (VAR_4) {\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      pushCallStack(VAR_4, VAR_3);\n    } else {\n      /* COMMENT_8 */\n      pushCallStack(VAR_0, (const Inst *)VAR_0->begin());\n    }\n  } else {\n    /* COMMENT_8 */\n    pushCallStack(VAR_0, (const Inst *)VAR_0->begin());\n  }\n#endif\n\n  InterpreterState VAR_5{VAR_0, 0};\n  if (VAR_6 &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::VAR_7<false, true>(*this, VAR_5);\n  } else {\n    return Interpreter::VAR_7<false, false>(*this, VAR_5);\n  }\n}",
  "func_graph_path": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Interpreter.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n CallResult<HermesValue> Runtime::interpretFunctionImpl(\n     CodeBlock *newCodeBlock) {\n-  newCodeBlock->lazyCompile(*this);\n+  if (LLVM_UNLIKELY(\n+          newCodeBlock->lazyCompile(*this) == ExecutionStatus::EXCEPTION)) {\n+    return ExecutionStatus::EXCEPTION;\n+  }\n \n #if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n   // We always call getCurrentIP() in a debug build as this has the effect",
  "diff_line_info": {
    "deleted_lines": [
      "  newCodeBlock->lazyCompile(*this);"
    ],
    "added_lines": [
      "  if (LLVM_UNLIKELY(",
      "          newCodeBlock->lazyCompile(*this) == ExecutionStatus::EXCEPTION)) {",
      "    return ExecutionStatus::EXCEPTION;",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/822",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 822
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}