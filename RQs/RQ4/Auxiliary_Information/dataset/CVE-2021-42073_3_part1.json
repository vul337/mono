{
  "cve_id": "CVE-2021-42073",
  "cwe_ids": [
    "CWE-384"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "debauchee/barrier",
  "commit_msg": "Implement client identity verification\n\nThis commit fixes two security vulnerabilities: CVE-2021-42072 and\nCVE-2021-42073.\n\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
  "commit_hash": "229abab99f39f11624e5651f819e7f1f8eddedcc",
  "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
  "file_path": "src/lib/net/SecureSocket.cpp",
  "func_name": "SecureSocket::initContext",
  "func_before": "void\nSecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n\n    const SSL_METHOD* method;\n\n    // load & register all cryptos, etc.\n    OpenSSL_add_all_algorithms();\n\n    // load all error messages\n    SSL_load_error_strings();\n\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n\n    // SSLv23_method uses TLSv1, with the ability to fall back to SSLv3\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n\n    // create new context from method\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n\n    // drop SSLv3 support\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n}",
  "abstract_func_before": "void\nSecureSocket::initContext(bool VAR_0)\n{\n    SSL_library_init();\n\n    const SSL_METHOD* VAR_1;\n\n    /* COMMENT_0 */\n    OpenSSL_add_all_algorithms();\n\n    /* COMMENT_1 */\n    SSL_load_error_strings();\n\n    if (VAR_2->getFilter() >= VAR_3) {\n        showSecureLibInfo();\n    }\n\n    /* COMMENT_2 */\n    if (VAR_0) {\n        VAR_1 = SSLv23_server_method();\n    }\n    else {\n        VAR_1 = SSLv23_client_method();\n    }\n\n    /* COMMENT_3 */\n    SSL_METHOD* VAR_4 = VAR_5<SSL_METHOD*>(VAR_1);\n    VAR_6->m_context = SSL_CTX_new(VAR_4);\n\n    /* COMMENT_4 */\n    SSL_CTX_set_options(VAR_6->m_context, VAR_7);\n\n    if (VAR_6->m_context == NULL) {\n        showError(\"\");\n    }\n}",
  "func_graph_path_before": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/before/1.json",
  "func": "void\nSecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n\n    const SSL_METHOD* method;\n\n    // load & register all cryptos, etc.\n    OpenSSL_add_all_algorithms();\n\n    // load all error messages\n    SSL_load_error_strings();\n\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n\n    // SSLv23_method uses TLSv1, with the ability to fall back to SSLv3\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n\n    // create new context from method\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n\n    // drop SSLv3 support\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n\n    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n        // We want to ask for peer certificate, but not verify it. If we don't ask for peer\n        // certificate, e.g. client won't send it.\n        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                           nullptr);\n        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n    }\n}",
  "abstract_func": "void\nSecureSocket::initContext(bool VAR_0)\n{\n    SSL_library_init();\n\n    const SSL_METHOD* VAR_1;\n\n    /* COMMENT_0 */\n    OpenSSL_add_all_algorithms();\n\n    /* COMMENT_1 */\n    SSL_load_error_strings();\n\n    if (VAR_2->getFilter() >= VAR_3) {\n        showSecureLibInfo();\n    }\n\n    /* COMMENT_2 */\n    if (VAR_0) {\n        VAR_1 = SSLv23_server_method();\n    }\n    else {\n        VAR_1 = SSLv23_client_method();\n    }\n\n    /* COMMENT_3 */\n    SSL_METHOD* VAR_4 = VAR_5<SSL_METHOD*>(VAR_1);\n    VAR_6->m_context = SSL_CTX_new(VAR_4);\n\n    /* COMMENT_4 */\n    SSL_CTX_set_options(VAR_6->m_context, VAR_7);\n\n    if (VAR_6->m_context == NULL) {\n        showError(\"\");\n    }\n\n    if (VAR_8 == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        SSL_CTX_set_verify(VAR_6->m_context, VAR_9 | VAR_10,\n                           nullptr);\n        SSL_CTX_set_cert_verify_callback(VAR_6->m_context, VAR_11, nullptr);\n    }\n}",
  "func_graph_path": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -33,4 +33,12 @@\n     if (m_ssl->m_context == NULL) {\n         showError(\"\");\n     }\n+\n+    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n+        // We want to ask for peer certificate, but not verify it. If we don't ask for peer\n+        // certificate, e.g. client won't send it.\n+        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n+                           nullptr);\n+        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n+    }\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {",
      "        // We want to ask for peer certificate, but not verify it. If we don't ask for peer",
      "        // certificate, e.g. client won't send it.",
      "        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,",
      "                           nullptr);",
      "        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/debauchee/barrier/pull/1346",
  "description": {
    "pr_info": {
      "title": "Implement client identity verification [SECURITY VULNERABILITIES CVE-2021-42072, CVE-2021-42073]",
      "number": 1346
    },
    "comment": [
      "This PR implements client identity verification. Essentially server gets the same process of accepting and rejecting clients like the clients can accept or reject the server. This is important because even though the client can't move the mouse on the server, it can still receive input and potentially set the clipboard.\r\n\r\nThis PR fixes the following security vulnerabilities:\r\n\r\n - CVE-2021-42072 server does not verify client identity (certificate fingerprint)\r\n - CVE-2021-42073 By guessing/listening in on valid client names server clipboard content can be manipulated.\r\n\r\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de> @mgerstner. Matthias also provided insights into how best to fix the issues, precise reproduction steps and any used tools and made the maintainer's life as pleasant as possible. Thank you!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit explicitly addresses two CVEs and the code changes implement client identity verification, directly fixing a security issue."
}