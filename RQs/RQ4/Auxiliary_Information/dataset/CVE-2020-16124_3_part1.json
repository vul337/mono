{
  "cve_id": "CVE-2020-16124",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ros/ros_comm",
  "commit_msg": "Trap for overly large input to XmlRPCPP which could cause problems with int <-> size_t conversions.\n\n - In XmlRpcClient, XmlRpcServerConnection and XmlRpcSocket, recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header, and generate an error if the length is invalid or too large.\n - In XmlRpcUtil, prevent attempts to parse overly large XML input.\n - Add tests where they can reasonably be inserted into existing test routines.\n\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\n\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\n\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
  "commit_hash": "3dd308911d7294bc6cff12f626b8467fe1555423",
  "git_url": "https://github.com/ros/ros_comm/commit/3dd308911d7294bc6cff12f626b8467fe1555423",
  "file_path": "utilities/xmlrpcpp/src/XmlRpcClient.cpp",
  "func_name": "XmlRpcClient::generateRequest",
  "func_before": "bool\nXmlRpcClient::generateRequest(const char* methodName, XmlRpcValue const& params)\n{\n  std::string body = REQUEST_BEGIN;\n  body += methodName;\n  body += REQUEST_END_METHODNAME;\n\n  // If params is an array, each element is a separate parameter\n  if (params.valid()) {\n    body += PARAMS_TAG;\n    if (params.getType() == XmlRpcValue::TypeArray)\n    {\n      for (int i=0; i<params.size(); ++i) {\n        body += PARAM_TAG;\n        body += params[i].toXml();\n        body += PARAM_ETAG;\n      }\n    }\n    else\n    {\n      body += PARAM_TAG;\n      body += params.toXml();\n      body += PARAM_ETAG;\n    }\n      \n    body += PARAMS_ETAG;\n  }\n  body += REQUEST_END;\n\n  std::string header = generateHeader(body.length());\n  XmlRpcUtil::log(4, \"XmlRpcClient::generateRequest: header is %d bytes, content-length is %d.\", \n                  header.length(), body.length());\n\n  _request = header + body;\n  return true;\n}",
  "abstract_func_before": "bool\nXmlRpcClient::generateRequest(const char* VAR_0, XmlRpcValue const& VAR_1)\n{\n  std::string VAR_2 = VAR_3;\n  VAR_2 += VAR_0;\n  VAR_2 += VAR_4;\n\n  /* COMMENT_0 */\n  if (VAR_1.valid()) {\n    VAR_2 += VAR_5;\n    if (VAR_1.getType() == XmlRpcValue::TypeArray)\n    {\n      for (int VAR_6=0; VAR_6<VAR_1.size(); ++VAR_6) {\n        VAR_2 += VAR_7;\n        VAR_2 += VAR_1[VAR_6].toXml();\n        VAR_2 += VAR_8;\n      }\n    }\n    else\n    {\n      VAR_2 += VAR_7;\n      VAR_2 += VAR_1.toXml();\n      VAR_2 += VAR_8;\n    }\n      \n    VAR_2 += VAR_9;\n  }\n  VAR_2 += VAR_10;\n\n  std::string VAR_11 = generateHeader(VAR_2.length());\n  XmlRpcUtil::log(4, \"XmlRpcClient::generateRequest: header is %d bytes, content-length is %d.\", \n                  VAR_11.length(), VAR_2.length());\n\n  VAR_12 = VAR_11 + VAR_2;\n  return true;\n}",
  "func_graph_path_before": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcClient.cpp/vul/before/0.json",
  "func": "bool\nXmlRpcClient::generateRequest(const char* methodName, XmlRpcValue const& params)\n{\n  std::string body = REQUEST_BEGIN;\n  body += methodName;\n  body += REQUEST_END_METHODNAME;\n\n  // If params is an array, each element is a separate parameter\n  if (params.valid()) {\n    body += PARAMS_TAG;\n    if (params.getType() == XmlRpcValue::TypeArray)\n    {\n      for (int i=0; i<params.size(); ++i) {\n        body += PARAM_TAG;\n        body += params[i].toXml();\n        body += PARAM_ETAG;\n      }\n    }\n    else\n    {\n      body += PARAM_TAG;\n      body += params.toXml();\n      body += PARAM_ETAG;\n    }\n      \n    body += PARAMS_ETAG;\n  }\n  body += REQUEST_END;\n\n  std::string header = generateHeader(body.length());\n  XmlRpcUtil::log(4, \"XmlRpcClient::generateRequest: header is %d bytes, content-length is %d.\", \n                  header.length(), body.length());\n\n  _request = header + body;\n  // Limit the size of the request to avoid integer overruns\n  if (_request.length() > size_t(__INT_MAX__)) {\n    XmlRpcUtil::error(\"XmlRpcClient::generateRequest: request length (%u) exceeds maximum allowed size (%u).\",\n                      _request.length(), __INT_MAX__);\n    _request.clear();\n    return false;\n  }\n  return true;\n}",
  "abstract_func": "bool\nXmlRpcClient::generateRequest(const char* VAR_0, XmlRpcValue const& VAR_1)\n{\n  std::string VAR_2 = VAR_3;\n  VAR_2 += VAR_0;\n  VAR_2 += VAR_4;\n\n  /* COMMENT_0 */\n  if (VAR_1.valid()) {\n    VAR_2 += VAR_5;\n    if (VAR_1.getType() == XmlRpcValue::TypeArray)\n    {\n      for (int VAR_6=0; VAR_6<VAR_1.size(); ++VAR_6) {\n        VAR_2 += VAR_7;\n        VAR_2 += VAR_1[VAR_6].toXml();\n        VAR_2 += VAR_8;\n      }\n    }\n    else\n    {\n      VAR_2 += VAR_7;\n      VAR_2 += VAR_1.toXml();\n      VAR_2 += VAR_8;\n    }\n      \n    VAR_2 += VAR_9;\n  }\n  VAR_2 += VAR_10;\n\n  std::string VAR_11 = generateHeader(VAR_2.length());\n  XmlRpcUtil::log(4, \"XmlRpcClient::generateRequest: header is %d bytes, content-length is %d.\", \n                  VAR_11.length(), VAR_2.length());\n\n  VAR_12 = VAR_11 + VAR_2;\n  /* COMMENT_1 */\n  if (VAR_12.length() > size_t(VAR_13)) {\n    XmlRpcUtil::error(\"XmlRpcClient::generateRequest: request length (%u) exceeds maximum allowed size (%u).\",\n                      VAR_12.length(), VAR_13);\n    VAR_12.clear();\n    return false;\n  }\n  return true;\n}",
  "func_graph_path": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcClient.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -32,5 +32,12 @@\n                   header.length(), body.length());\n \n   _request = header + body;\n+  // Limit the size of the request to avoid integer overruns\n+  if (_request.length() > size_t(__INT_MAX__)) {\n+    XmlRpcUtil::error(\"XmlRpcClient::generateRequest: request length (%u) exceeds maximum allowed size (%u).\",\n+                      _request.length(), __INT_MAX__);\n+    _request.clear();\n+    return false;\n+  }\n   return true;\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  // Limit the size of the request to avoid integer overruns",
      "  if (_request.length() > size_t(__INT_MAX__)) {",
      "    XmlRpcUtil::error(\"XmlRpcClient::generateRequest: request length (%u) exceeds maximum allowed size (%u).\",",
      "                      _request.length(), __INT_MAX__);",
      "    _request.clear();",
      "    return false;",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ros/ros_comm/pull/2065",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/ros/ros_comm/pull/2065: 403 Client Error: Forbidden for url: https://api.github.com/repos/ros/ros_comm/pulls/2065",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch addresses a known security issue, CVE-2020-16124, by implementing checks for excessively large inputs and replacing unsafe functions, ensuring the fix is clear and consistent."
}