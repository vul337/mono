{
  "cve_id": "CVE-2022-1296",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix oobread in NE parser ##crash\n\n* Reported by @hmsec via huntr.dev\n* Reproducer: necrash\n* BountyID: 52b57274-0e1a-4d61-ab29-1373b555fea0/",
  "commit_hash": "153bcdc29f11cd8c90e7d639a7405450f644ddb6",
  "git_url": "https://github.com/radareorg/radare2/commit/153bcdc29f11cd8c90e7d639a7405450f644ddb6",
  "file_path": "libr/bin/format/ne/ne.c",
  "func_name": "r_bin_ne_get_relocs",
  "func_before": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n#if NE_BUG\n\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t} else {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t}\n#else\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n#endif\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}",
  "abstract_func_before": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *VAR_0) {\n\tRList *VAR_1 = VAR_0->segments;\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_2 = VAR_0->entries;\n\tif (!VAR_2) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_3 = VAR_0->symbols;\n\tif (!VAR_3) {\n\t\treturn NULL;\n\t}\n\n\tut16 *VAR_4 = calloc (VAR_0->ne_header->ModRefs, sizeof (ut16));\n\tif (!VAR_4) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (VAR_0->buf, (ut64)VAR_0->ne_header->ModRefTable + VAR_0->header_offset, (ut8 *)VAR_4, VAR_0->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *VAR_5 = r_list_newf (VAR_6);\n\tif (!VAR_5) {\n\t\tVAR_6 (VAR_4);\n\t\treturn NULL;\n\t}\n\n\tRListIter *VAR_7;\n\tRBinSection *VAR_8;\n\tint VAR_9 = -1;\n\tr_list_foreach (VAR_1, VAR_7, VAR_8) {\n\t\tVAR_9++;\n\t\tif (!(VAR_0->segment_entries[VAR_9].flags & VAR_10)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 VAR_11 = VAR_8->paddr + VAR_8->size;\n\t\tut32 VAR_12 = VAR_11;\n\t\tut16 VAR_13 = r_buf_read_le16_at (VAR_0->buf, VAR_11);\n\t\tif (!VAR_13) {\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_11 += 2;\n\t\t/* COMMENT_0 */\n\t\twhile (VAR_11 < VAR_12 + VAR_13 * sizeof (VAR_14)) {\n\t\t\t/* COMMENT_1 */\n\t\t\tNE_image_reloc_item VAR_15 = {0};\n\t\t\tif (r_buf_read_at (VAR_0->buf, VAR_11, (ut8 *)&VAR_15, sizeof (VAR_15)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *VAR_16 = R_NEW0 (RBinReloc);\n\t\t\tif (!VAR_16) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_16->paddr = VAR_8->paddr + VAR_15.offset;\n\t\t\tswitch (VAR_15.type) {\n\t\t\tcase VAR_17:\n\t\t\t\tVAR_16->type = VAR_18;\n\t\t\t\tbreak;\n\t\t\tcase VAR_19:\n\t\t\tcase VAR_20:\n\t\t\t\tVAR_16->type = VAR_21;\n\t\t\t\tbreak;\n\t\t\tcase VAR_22:\n\t\t\tcase VAR_23:\n\t\t\t\tVAR_16->type = VAR_24;\n\t\t\t\tbreak;\n\t\t\tcase VAR_25:\n\t\t\t\tVAR_16->type = VAR_26;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 VAR_27;\n\t\t\tif (VAR_15.flags & (VAR_28 | VAR_29)) {\n\t\t\t\tRBinImport *VAR_30 = R_NEW0 (RBinImport);\n\t\t\t\tif (!VAR_30) {\n\t\t\t\t\tVAR_6 (VAR_16);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *VAR_31;\n#if VAR_32\n\t\t\t\tif (VAR_15.index > 0 && VAR_15.index < VAR_0->ne_header->ModRefs) {\n\t\t\t\t\tVAR_27 = VAR_4[VAR_15.index - 1] + VAR_0->header_offset + VAR_0->ne_header->ImportNameTable;\n\t\t\t\t\tVAR_31 = __read_nonnull_str_at (VAR_0->buf, VAR_27);\n\t\t\t\t} else {\n\t\t\t\t\tVAR_31 = r_str_newf (\"UnknownModule%d_%x\", VAR_15.index, VAR_11); /* COMMENT_2 */\n\t\t\t\t}\n#else\n\t\t\t\tif (VAR_15.index > VAR_0->ne_header->ModRefs) {\n\t\t\t\t\tVAR_31 = r_str_newf (\"UnknownModule%d_%x\", VAR_15.index, VAR_11); /* COMMENT_2 */\n\t\t\t\t} else {\n\t\t\t\t\tVAR_27 = VAR_4[VAR_15.index - 1] + VAR_0->header_offset + VAR_0->ne_header->ImportNameTable;\n\t\t\t\t\tVAR_31 = __read_nonnull_str_at (VAR_0->buf, VAR_27);\n\t\t\t\t}\n#endif\n\t\t\t\tif (VAR_15.flags & VAR_28) {\n\t\t\t\t\tVAR_30->ordinal = VAR_15.func_ord;\n\t\t\t\t\tVAR_30->name = r_str_newf (\"%s.%s\", VAR_31, __func_name_from_ord(VAR_31, VAR_15.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\tVAR_27 = VAR_0->header_offset + VAR_0->ne_header->ImportNameTable + VAR_15.name_off;\n\t\t\t\t\tchar *VAR_33 = __read_nonnull_str_at (VAR_0->buf, VAR_27);\n\t\t\t\t\tVAR_30->name = r_str_newf (\"%s.%s\", VAR_31, VAR_33);\n\t\t\t\t\tVAR_6 (VAR_33);\n\t\t\t\t}\n\t\t\t\tVAR_6 (VAR_31);\n\t\t\t\tVAR_16->import = VAR_30;\n\t\t\t} else if (VAR_15.flags & VAR_34) {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t} else {\n\t\t\t\tif (strstr (VAR_8->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *VAR_35 = r_list_get_n (VAR_1, VAR_15.segnum - 1);\n\t\t\t\t\tif (VAR_35) {\n\t\t\t\t\t\tVAR_27 = VAR_35->paddr + VAR_15.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_27 = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *VAR_36 = r_list_get_n (VAR_2, VAR_15.entry_ordinal - 1);\n\t\t\t\t\tif (VAR_36) {\n\t\t\t\t\t\tVAR_27 = VAR_36->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_27 = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_16->addend = VAR_27;\n\t\t\t\tRBinSymbol *VAR_37 = NULL;\n\t\t\t\tRListIter *VAR_38;\n\t\t\t\tr_list_foreach (VAR_3, VAR_38, VAR_37) {\n\t\t\t\t\tif (VAR_37->paddr == VAR_16->addend) {\n\t\t\t\t\t\tVAR_16->symbol = VAR_37;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_15.flags & VAR_39) {\n\t\t\t\tVAR_16->additive = 1;\n\t\t\t\tr_list_append (VAR_5, VAR_16);\n\t\t\t} else {\n\t\t\t\tdo {\n#if VAR_32\n\t\t\t\t\tif (VAR_16->paddr + 4 < r_buf_size (VAR_0->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (VAR_5, VAR_16);\n\t\t\t\t\tVAR_27 = r_buf_read_le16_at (VAR_0->buf, VAR_16->paddr);\n\t\t\t\t\tRBinReloc *VAR_40 = VAR_16;\n\t\t\t\t\tVAR_16 = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!VAR_16) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*VAR_16 = *VAR_40;\n\t\t\t\t\tVAR_16->paddr = VAR_8->paddr + VAR_27;\n\t\t\t\t} while (VAR_27 != 0xFFFF);\n\t\t\t\tVAR_6 (VAR_16);\n\t\t\t}\n\n\t\t\tVAR_11 += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tVAR_6 (VAR_4);\n\treturn VAR_5;\n}",
  "func_graph_path_before": "radareorg/radare2/153bcdc29f11cd8c90e7d639a7405450f644ddb6/ne.c/vul/before/0.json",
  "func": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name = NULL;\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else if (rel.index > 0) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\tchar *fname = __func_name_from_ord (name, rel.func_ord);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, fname);\n\t\t\t\t\tfree (fname);\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#define NE_BUG 0\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}",
  "abstract_func": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *VAR_0) {\n\tRList *VAR_1 = VAR_0->segments;\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_2 = VAR_0->entries;\n\tif (!VAR_2) {\n\t\treturn NULL;\n\t}\n\tRList *VAR_3 = VAR_0->symbols;\n\tif (!VAR_3) {\n\t\treturn NULL;\n\t}\n\n\tut16 *VAR_4 = calloc (VAR_0->ne_header->ModRefs, sizeof (ut16));\n\tif (!VAR_4) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (VAR_0->buf, (ut64)VAR_0->ne_header->ModRefTable + VAR_0->header_offset, (ut8 *)VAR_4, VAR_0->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *VAR_5 = r_list_newf (VAR_6);\n\tif (!VAR_5) {\n\t\tVAR_6 (VAR_4);\n\t\treturn NULL;\n\t}\n\n\tRListIter *VAR_7;\n\tRBinSection *VAR_8;\n\tint VAR_9 = -1;\n\tr_list_foreach (VAR_1, VAR_7, VAR_8) {\n\t\tVAR_9++;\n\t\tif (!(VAR_0->segment_entries[VAR_9].flags & VAR_10)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 VAR_11 = VAR_8->paddr + VAR_8->size;\n\t\tut32 VAR_12 = VAR_11;\n\t\tut16 VAR_13 = r_buf_read_le16_at (VAR_0->buf, VAR_11);\n\t\tif (!VAR_13) {\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_11 += 2;\n\t\t/* COMMENT_0 */\n\t\twhile (VAR_11 < VAR_12 + VAR_13 * sizeof (VAR_14)) {\n\t\t\t/* COMMENT_1 */\n\t\t\tNE_image_reloc_item VAR_15 = {0};\n\t\t\tif (r_buf_read_at (VAR_0->buf, VAR_11, (ut8 *)&VAR_15, sizeof (VAR_15)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *VAR_16 = R_NEW0 (RBinReloc);\n\t\t\tif (!VAR_16) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_16->paddr = VAR_8->paddr + VAR_15.offset;\n\t\t\tswitch (VAR_15.type) {\n\t\t\tcase VAR_17:\n\t\t\t\tVAR_16->type = VAR_18;\n\t\t\t\tbreak;\n\t\t\tcase VAR_19:\n\t\t\tcase VAR_20:\n\t\t\t\tVAR_16->type = VAR_21;\n\t\t\t\tbreak;\n\t\t\tcase VAR_22:\n\t\t\tcase VAR_23:\n\t\t\t\tVAR_16->type = VAR_24;\n\t\t\t\tbreak;\n\t\t\tcase VAR_25:\n\t\t\t\tVAR_16->type = VAR_26;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 VAR_27;\n\t\t\tif (VAR_15.flags & (VAR_28 | VAR_29)) {\n\t\t\t\tRBinImport *VAR_30 = R_NEW0 (RBinImport);\n\t\t\t\tif (!VAR_30) {\n\t\t\t\t\tVAR_6 (VAR_16);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *VAR_31 = NULL;\n\t\t\t\tif (VAR_15.index > VAR_0->ne_header->ModRefs) {\n\t\t\t\t\tVAR_31 = r_str_newf (\"UnknownModule%d_%x\", VAR_15.index, VAR_11); /* COMMENT_2 */\n\t\t\t\t} else if (VAR_15.index > 0) {\n\t\t\t\t\tVAR_27 = VAR_4[VAR_15.index - 1] + VAR_0->header_offset + VAR_0->ne_header->ImportNameTable;\n\t\t\t\t\tVAR_31 = __read_nonnull_str_at (VAR_0->buf, VAR_27);\n\t\t\t\t}\n\t\t\t\tif (VAR_15.flags & VAR_28) {\n\t\t\t\t\tVAR_30->ordinal = VAR_15.func_ord;\n\t\t\t\t\tchar *VAR_32 = __func_name_from_ord (VAR_31, VAR_15.func_ord);\n\t\t\t\t\tVAR_30->name = r_str_newf (\"%s.%s\", VAR_31, VAR_32);\n\t\t\t\t\tVAR_6 (VAR_32);\n\t\t\t\t} else {\n\t\t\t\t\tVAR_27 = VAR_0->header_offset + VAR_0->ne_header->ImportNameTable + VAR_15.name_off;\n\t\t\t\t\tchar *VAR_33 = __read_nonnull_str_at (VAR_0->buf, VAR_27);\n\t\t\t\t\tVAR_30->name = r_str_newf (\"%s.%s\", VAR_31, VAR_33);\n\t\t\t\t\tVAR_6 (VAR_33);\n\t\t\t\t}\n\t\t\t\tVAR_6 (VAR_31);\n\t\t\t\tVAR_16->import = VAR_30;\n\t\t\t} else if (VAR_15.flags & VAR_34) {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t} else {\n\t\t\t\tif (strstr (VAR_8->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *VAR_35 = r_list_get_n (VAR_1, VAR_15.segnum - 1);\n\t\t\t\t\tif (VAR_35) {\n\t\t\t\t\t\tVAR_27 = VAR_35->paddr + VAR_15.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_27 = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *VAR_36 = r_list_get_n (VAR_2, VAR_15.entry_ordinal - 1);\n\t\t\t\t\tif (VAR_36) {\n\t\t\t\t\t\tVAR_27 = VAR_36->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_27 = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_16->addend = VAR_27;\n\t\t\t\tRBinSymbol *VAR_37 = NULL;\n\t\t\t\tRListIter *VAR_38;\n\t\t\t\tr_list_foreach (VAR_3, VAR_38, VAR_37) {\n\t\t\t\t\tif (VAR_37->paddr == VAR_16->addend) {\n\t\t\t\t\t\tVAR_16->symbol = VAR_37;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_15.flags & VAR_39) {\n\t\t\t\tVAR_16->additive = 1;\n\t\t\t\tr_list_append (VAR_5, VAR_16);\n\t\t\t} else {\n\t\t\t\tdo {\n#define VAR_40 0\n#if VAR_40\n\t\t\t\t\tif (VAR_16->paddr + 4 < r_buf_size (VAR_0->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (VAR_5, VAR_16);\n\t\t\t\t\tVAR_27 = r_buf_read_le16_at (VAR_0->buf, VAR_16->paddr);\n\t\t\t\t\tRBinReloc *VAR_41 = VAR_16;\n\t\t\t\t\tVAR_16 = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!VAR_16) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*VAR_16 = *VAR_41;\n\t\t\t\t\tVAR_16->paddr = VAR_8->paddr + VAR_27;\n\t\t\t\t} while (VAR_27 != 0xFFFF);\n\t\t\t\tVAR_6 (VAR_16);\n\t\t\t}\n\n\t\t\tVAR_11 += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tVAR_6 (VAR_4);\n\treturn VAR_5;\n}",
  "func_graph_path": "radareorg/radare2/153bcdc29f11cd8c90e7d639a7405450f644ddb6/ne.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -75,25 +75,18 @@\n \t\t\t\t\tfree (reloc);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\tchar *name;\n-#if NE_BUG\n-\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {\n-\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n-\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n-\t\t\t\t} else {\n-\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n-\t\t\t\t}\n-#else\n+\t\t\t\tchar *name = NULL;\n \t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n \t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n-\t\t\t\t} else {\n+\t\t\t\t} else if (rel.index > 0) {\n \t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n \t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n \t\t\t\t}\n-#endif\n \t\t\t\tif (rel.flags & IMPORTED_ORD) {\n \t\t\t\t\timp->ordinal = rel.func_ord;\n-\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n+\t\t\t\t\tchar *fname = __func_name_from_ord (name, rel.func_ord);\n+\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, fname);\n+\t\t\t\t\tfree (fname);\n \t\t\t\t} else {\n \t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n \t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n@@ -136,6 +129,7 @@\n \t\t\t\tr_list_append (relocs, reloc);\n \t\t\t} else {\n \t\t\t\tdo {\n+#define NE_BUG 0\n #if NE_BUG\n \t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n \t\t\t\t\t\tbreak;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tchar *name;",
      "#if NE_BUG",
      "\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {",
      "\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;",
      "\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);",
      "\t\t\t\t} else {",
      "\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????",
      "\t\t\t\t}",
      "#else",
      "\t\t\t\t} else {",
      "#endif",
      "\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));"
    ],
    "added_lines": [
      "\t\t\t\tchar *name = NULL;",
      "\t\t\t\t} else if (rel.index > 0) {",
      "\t\t\t\t\tchar *fname = __func_name_from_ord (name, rel.func_ord);",
      "\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, fname);",
      "\t\t\t\t\tfree (fname);",
      "#define NE_BUG 0"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19923",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19923: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19923",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}