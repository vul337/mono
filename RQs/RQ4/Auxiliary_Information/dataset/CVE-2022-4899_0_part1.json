{
  "cve_id": "CVE-2022-4899",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/zstd",
  "commit_msg": "Disallow empty output directory",
  "commit_hash": "f9f27de91c89d826c6a39c3ef44fb1b02f9a43aa",
  "git_url": "https://github.com/facebook/zstd/commit/f9f27de91c89d826c6a39c3ef44fb1b02f9a43aa",
  "file_path": "programs/zstdcli.c",
  "func_name": "main",
  "func_before": "int main(int argCount, const char* argv[])\n{\n    int argNb,\n        followLinks = 0,\n        allowBlockDevices = 0,\n        forceStdin = 0,\n        forceStdout = 0,\n        hasStdout = 0,\n        ldmFlag = 0,\n        main_pause = 0,\n        nbWorkers = 0,\n        adapt = 0,\n        useRowMatchFinder = 0,\n        adaptMin = MINCLEVEL,\n        adaptMax = MAXCLEVEL,\n        rsyncable = 0,\n        nextArgumentsAreFiles = 0,\n        operationResult = 0,\n        separateFiles = 0,\n        setRealTimePrio = 0,\n        singleThread = 0,\n        defaultLogicalCores = 0,\n        showDefaultCParams = 0,\n        ultra=0,\n        contentSize=1;\n    double compressibility = 0.5;\n    unsigned bench_nbSeconds = 3;   /* would be better if this value was synchronized from bench */\n    size_t blockSize = 0;\n\n    FIO_prefs_t* const prefs = FIO_createPreferences();\n    FIO_ctx_t* const fCtx = FIO_createContext();\n    zstd_operation_mode operation = zom_compress;\n    ZSTD_compressionParameters compressionParams;\n    int cLevel = init_cLevel();\n    int cLevelLast = MINCLEVEL - 1;  /* lower than minimum */\n    unsigned recursive = 0;\n    unsigned memLimit = 0;\n    FileNamesTable* filenames = UTIL_allocateFileNamesTable((size_t)argCount);  /* argCount >= 1 */\n    FileNamesTable* file_of_names = UTIL_allocateFileNamesTable((size_t)argCount);  /* argCount >= 1 */\n    const char* programName = argv[0];\n    const char* outFileName = NULL;\n    const char* outDirName = NULL;\n    const char* outMirroredDirName = NULL;\n    const char* dictFileName = NULL;\n    const char* patchFromDictFileName = NULL;\n    const char* suffix = ZSTD_EXTENSION;\n    unsigned maxDictSize = g_defaultMaxDictSize;\n    unsigned dictID = 0;\n    size_t streamSrcSize = 0;\n    size_t targetCBlockSize = 0;\n    size_t srcSizeHint = 0;\n    size_t nbInputFileNames = 0;\n    int dictCLevel = g_defaultDictCLevel;\n    unsigned dictSelect = g_defaultSelectivityLevel;\n#ifndef ZSTD_NODICT\n    ZDICT_cover_params_t coverParams = defaultCoverParams();\n    ZDICT_fastCover_params_t fastCoverParams = defaultFastCoverParams();\n    dictType dict = fastCover;\n#endif\n#ifndef ZSTD_NOBENCH\n    BMK_advancedParams_t benchParams = BMK_initAdvancedParams();\n#endif\n    ZSTD_paramSwitch_e literalCompressionMode = ZSTD_ps_auto;\n\n\n    /* init */\n    checkLibVersion();\n    (void)recursive; (void)cLevelLast;    /* not used when ZSTD_NOBENCH set */\n    (void)memLimit;\n    assert(argCount >= 1);\n    if ((filenames==NULL) || (file_of_names==NULL)) { DISPLAY(\"zstd: allocation error \\n\"); exit(1); }\n    programName = lastNameFromPath(programName);\n#ifdef ZSTD_MULTITHREAD\n    nbWorkers = init_nbThreads();\n#endif\n\n    /* preset behaviors */\n    if (exeNameMatch(programName, ZSTD_ZSTDMT)) nbWorkers=0, singleThread=0;\n    if (exeNameMatch(programName, ZSTD_UNZSTD)) operation=zom_decompress;\n    if (exeNameMatch(programName, ZSTD_CAT)) { operation=zom_decompress; FIO_overwriteMode(prefs); forceStdout=1; followLinks=1; outFileName=stdoutmark; g_displayLevel=1; }     /* supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_ZCAT)) { operation=zom_decompress; FIO_overwriteMode(prefs); forceStdout=1; followLinks=1; outFileName=stdoutmark; g_displayLevel=1; }    /* behave like zcat, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_GZ)) {   /* behave like gzip */\n        suffix = GZ_EXTENSION; FIO_setCompressionType(prefs, FIO_gzipCompression); FIO_setRemoveSrcFile(prefs, 1);\n        dictCLevel = cLevel = 6;  /* gzip default is -6 */\n    }\n    if (exeNameMatch(programName, ZSTD_GUNZIP)) { operation=zom_decompress; FIO_setRemoveSrcFile(prefs, 1); }                                                     /* behave like gunzip, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_GZCAT)) { operation=zom_decompress; FIO_overwriteMode(prefs); forceStdout=1; followLinks=1; outFileName=stdoutmark; g_displayLevel=1; }   /* behave like gzcat, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_LZMA)) { suffix = LZMA_EXTENSION; FIO_setCompressionType(prefs, FIO_lzmaCompression); FIO_setRemoveSrcFile(prefs, 1); }    /* behave like lzma */\n    if (exeNameMatch(programName, ZSTD_UNLZMA)) { operation=zom_decompress; FIO_setCompressionType(prefs, FIO_lzmaCompression); FIO_setRemoveSrcFile(prefs, 1); } /* behave like unlzma, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_XZ)) { suffix = XZ_EXTENSION; FIO_setCompressionType(prefs, FIO_xzCompression); FIO_setRemoveSrcFile(prefs, 1); }          /* behave like xz */\n    if (exeNameMatch(programName, ZSTD_UNXZ)) { operation=zom_decompress; FIO_setCompressionType(prefs, FIO_xzCompression); FIO_setRemoveSrcFile(prefs, 1); }     /* behave like unxz, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_LZ4)) { suffix = LZ4_EXTENSION; FIO_setCompressionType(prefs, FIO_lz4Compression); }                                       /* behave like lz4 */\n    if (exeNameMatch(programName, ZSTD_UNLZ4)) { operation=zom_decompress; FIO_setCompressionType(prefs, FIO_lz4Compression); }                                   /* behave like unlz4, also supports multiple formats */\n    memset(&compressionParams, 0, sizeof(compressionParams));\n\n    /* init crash handler */\n    FIO_addAbortHandler();\n\n    /* command switches */\n    for (argNb=1; argNb<argCount; argNb++) {\n        const char* argument = argv[argNb];\n        if (!argument) continue;   /* Protection if argument empty */\n\n        if (nextArgumentsAreFiles) {\n            UTIL_refFilename(filenames, argument);\n            continue;\n        }\n\n        /* \"-\" means stdin/stdout */\n        if (!strcmp(argument, \"-\")){\n            UTIL_refFilename(filenames, stdinmark);\n            continue;\n        }\n\n        /* Decode commands (note : aggregated commands are allowed) */\n        if (argument[0]=='-') {\n\n            if (argument[1]=='-') {\n                /* long commands (--long-word) */\n                if (!strcmp(argument, \"--\")) { nextArgumentsAreFiles=1; continue; }   /* only file names allowed from now on */\n                if (!strcmp(argument, \"--list\")) { operation=zom_list; continue; }\n                if (!strcmp(argument, \"--compress\")) { operation=zom_compress; continue; }\n                if (!strcmp(argument, \"--decompress\")) { operation=zom_decompress; continue; }\n                if (!strcmp(argument, \"--uncompress\")) { operation=zom_decompress; continue; }\n                if (!strcmp(argument, \"--force\")) { FIO_overwriteMode(prefs); forceStdin=1; forceStdout=1; followLinks=1; allowBlockDevices=1; continue; }\n                if (!strcmp(argument, \"--version\")) { printVersion(); CLEAN_RETURN(0); }\n                if (!strcmp(argument, \"--help\")) { usage_advanced(programName); CLEAN_RETURN(0); }\n                if (!strcmp(argument, \"--verbose\")) { g_displayLevel++; continue; }\n                if (!strcmp(argument, \"--quiet\")) { g_displayLevel--; continue; }\n                if (!strcmp(argument, \"--stdout\")) { forceStdout=1; outFileName=stdoutmark; FIO_setRemoveSrcFile(prefs, 0); g_displayLevel-=(g_displayLevel==2); continue; }\n                if (!strcmp(argument, \"--ultra\")) { ultra=1; continue; }\n                if (!strcmp(argument, \"--check\")) { FIO_setChecksumFlag(prefs, 2); continue; }\n                if (!strcmp(argument, \"--no-check\")) { FIO_setChecksumFlag(prefs, 0); continue; }\n                if (!strcmp(argument, \"--sparse\")) { FIO_setSparseWrite(prefs, 2); continue; }\n                if (!strcmp(argument, \"--no-sparse\")) { FIO_setSparseWrite(prefs, 0); continue; }\n                if (!strcmp(argument, \"--test\")) { operation=zom_test; continue; }\n                if (!strcmp(argument, \"--asyncio\")) { FIO_setAsyncIOFlag(prefs, 1); continue;}\n                if (!strcmp(argument, \"--no-asyncio\")) { FIO_setAsyncIOFlag(prefs, 0); continue;}\n                if (!strcmp(argument, \"--train\")) { operation=zom_train; if (outFileName==NULL) outFileName=g_defaultDictName; continue; }\n                if (!strcmp(argument, \"--no-dictID\")) { FIO_setDictIDFlag(prefs, 0); continue; }\n                if (!strcmp(argument, \"--keep\")) { FIO_setRemoveSrcFile(prefs, 0); continue; }\n                if (!strcmp(argument, \"--rm\")) { FIO_setRemoveSrcFile(prefs, 1); continue; }\n                if (!strcmp(argument, \"--priority=rt\")) { setRealTimePrio = 1; continue; }\n                if (!strcmp(argument, \"--show-default-cparams\")) { showDefaultCParams = 1; continue; }\n                if (!strcmp(argument, \"--content-size\")) { contentSize = 1; continue; }\n                if (!strcmp(argument, \"--no-content-size\")) { contentSize = 0; continue; }\n                if (!strcmp(argument, \"--adapt\")) { adapt = 1; continue; }\n                if (!strcmp(argument, \"--no-row-match-finder\")) { useRowMatchFinder = 1; continue; }\n                if (!strcmp(argument, \"--row-match-finder\")) { useRowMatchFinder = 2; continue; }\n                if (longCommandWArg(&argument, \"--adapt=\")) { adapt = 1; if (!parseAdaptParameters(argument, &adaptMin, &adaptMax)) { badusage(programName); CLEAN_RETURN(1); } continue; }\n                if (!strcmp(argument, \"--single-thread\")) { nbWorkers = 0; singleThread = 1; continue; }\n                if (!strcmp(argument, \"--format=zstd\")) { suffix = ZSTD_EXTENSION; FIO_setCompressionType(prefs, FIO_zstdCompression); continue; }\n#ifdef ZSTD_GZCOMPRESS\n                if (!strcmp(argument, \"--format=gzip\")) { suffix = GZ_EXTENSION; FIO_setCompressionType(prefs, FIO_gzipCompression); continue; }\n                if (exeNameMatch(programName, ZSTD_GZ)) {     /* behave like gzip */\n                    if (!strcmp(argument, \"--best\")) { dictCLevel = cLevel = 9; continue; }\n                    if (!strcmp(argument, \"--no-name\")) { /* ignore for now */; continue; }\n                }\n#endif\n#ifdef ZSTD_LZMACOMPRESS\n                if (!strcmp(argument, \"--format=lzma\")) { suffix = LZMA_EXTENSION; FIO_setCompressionType(prefs, FIO_lzmaCompression);  continue; }\n                if (!strcmp(argument, \"--format=xz\")) { suffix = XZ_EXTENSION; FIO_setCompressionType(prefs, FIO_xzCompression);  continue; }\n#endif\n#ifdef ZSTD_LZ4COMPRESS\n                if (!strcmp(argument, \"--format=lz4\")) { suffix = LZ4_EXTENSION; FIO_setCompressionType(prefs, FIO_lz4Compression);  continue; }\n#endif\n                if (!strcmp(argument, \"--rsyncable\")) { rsyncable = 1; continue; }\n                if (!strcmp(argument, \"--compress-literals\")) { literalCompressionMode = ZSTD_ps_enable; continue; }\n                if (!strcmp(argument, \"--no-compress-literals\")) { literalCompressionMode = ZSTD_ps_disable; continue; }\n                if (!strcmp(argument, \"--no-progress\")) { FIO_setProgressSetting(FIO_ps_never); continue; }\n                if (!strcmp(argument, \"--progress\")) { FIO_setProgressSetting(FIO_ps_always); continue; }\n                if (!strcmp(argument, \"--exclude-compressed\")) { FIO_setExcludeCompressedFile(prefs, 1); continue; }\n\n                /* long commands with arguments */\n#ifndef ZSTD_NODICT\n                if (longCommandWArg(&argument, \"--train-cover\")) {\n                  operation = zom_train;\n                  if (outFileName == NULL)\n                      outFileName = g_defaultDictName;\n                  dict = cover;\n                  /* Allow optional arguments following an = */\n                  if (*argument == 0) { memset(&coverParams, 0, sizeof(coverParams)); }\n                  else if (*argument++ != '=') { badusage(programName); CLEAN_RETURN(1); }\n                  else if (!parseCoverParameters(argument, &coverParams)) { badusage(programName); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&argument, \"--train-fastcover\")) {\n                  operation = zom_train;\n                  if (outFileName == NULL)\n                      outFileName = g_defaultDictName;\n                  dict = fastCover;\n                  /* Allow optional arguments following an = */\n                  if (*argument == 0) { memset(&fastCoverParams, 0, sizeof(fastCoverParams)); }\n                  else if (*argument++ != '=') { badusage(programName); CLEAN_RETURN(1); }\n                  else if (!parseFastCoverParameters(argument, &fastCoverParams)) { badusage(programName); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&argument, \"--train-legacy\")) {\n                  operation = zom_train;\n                  if (outFileName == NULL)\n                      outFileName = g_defaultDictName;\n                  dict = legacy;\n                  /* Allow optional arguments following an = */\n                  if (*argument == 0) { continue; }\n                  else if (*argument++ != '=') { badusage(programName); CLEAN_RETURN(1); }\n                  else if (!parseLegacyParameters(argument, &dictSelect)) { badusage(programName); CLEAN_RETURN(1); }\n                  continue;\n                }\n#endif\n                if (longCommandWArg(&argument, \"--threads\")) { NEXT_UINT32(nbWorkers); continue; }\n                if (longCommandWArg(&argument, \"--memlimit\")) { NEXT_UINT32(memLimit); continue; }\n                if (longCommandWArg(&argument, \"--memory\")) { NEXT_UINT32(memLimit); continue; }\n                if (longCommandWArg(&argument, \"--memlimit-decompress\")) { NEXT_UINT32(memLimit); continue; }\n                if (longCommandWArg(&argument, \"--block-size=\")) { blockSize = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--maxdict\")) { NEXT_UINT32(maxDictSize); continue; }\n                if (longCommandWArg(&argument, \"--dictID\")) { NEXT_UINT32(dictID); continue; }\n                if (longCommandWArg(&argument, \"--zstd=\")) { if (!parseCompressionParameters(argument, &compressionParams)) { badusage(programName); CLEAN_RETURN(1); } continue; }\n                if (longCommandWArg(&argument, \"--stream-size=\")) { streamSrcSize = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--target-compressed-block-size=\")) { targetCBlockSize = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--size-hint=\")) { srcSizeHint = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--output-dir-flat\")) { NEXT_FIELD(outDirName); continue; }\n                if (longCommandWArg(&argument, \"--auto-threads\")) {\n                    const char* threadDefault = NULL;\n                    NEXT_FIELD(threadDefault);\n                    if (strcmp(threadDefault, \"logical\") == 0)\n                        defaultLogicalCores = 1;\n                    continue;\n                }\n#ifdef UTIL_HAS_MIRRORFILELIST\n                if (longCommandWArg(&argument, \"--output-dir-mirror\")) { NEXT_FIELD(outMirroredDirName); continue; }\n#endif\n#ifndef ZSTD_NOTRACE\n                if (longCommandWArg(&argument, \"--trace\")) { char const* traceFile; NEXT_FIELD(traceFile); TRACE_enable(traceFile); continue; }\n#endif\n                if (longCommandWArg(&argument, \"--patch-from\")) { NEXT_FIELD(patchFromDictFileName); continue; }\n                if (longCommandWArg(&argument, \"--long\")) {\n                    unsigned ldmWindowLog = 0;\n                    ldmFlag = 1;\n                    /* Parse optional window log */\n                    if (*argument == '=') {\n                        ++argument;\n                        ldmWindowLog = readU32FromChar(&argument);\n                    } else if (*argument != 0) {\n                        /* Invalid character following --long */\n                        badusage(programName);\n                        CLEAN_RETURN(1);\n                    }\n                    /* Only set windowLog if not already set by --zstd */\n                    if (compressionParams.windowLog == 0)\n                        compressionParams.windowLog = ldmWindowLog;\n                    continue;\n                }\n#ifndef ZSTD_NOCOMPRESS   /* linking ZSTD_minCLevel() requires compression support */\n                if (longCommandWArg(&argument, \"--fast\")) {\n                    /* Parse optional acceleration factor */\n                    if (*argument == '=') {\n                        U32 const maxFast = (U32)-ZSTD_minCLevel();\n                        U32 fastLevel;\n                        ++argument;\n                        fastLevel = readU32FromChar(&argument);\n                        if (fastLevel > maxFast) fastLevel = maxFast;\n                        if (fastLevel) {\n                            dictCLevel = cLevel = -(int)fastLevel;\n                        } else {\n                            badusage(programName);\n                            CLEAN_RETURN(1);\n                        }\n                    } else if (*argument != 0) {\n                        /* Invalid character following --fast */\n                        badusage(programName);\n                        CLEAN_RETURN(1);\n                    } else {\n                        cLevel = -1;  /* default for --fast */\n                    }\n                    continue;\n                }\n#endif\n\n                if (longCommandWArg(&argument, \"--filelist\")) {\n                    const char* listName;\n                    NEXT_FIELD(listName);\n                    UTIL_refFilename(file_of_names, listName);\n                    continue;\n                }\n\n                /* fall-through, will trigger bad_usage() later on */\n            }\n\n            argument++;\n            while (argument[0]!=0) {\n\n#ifndef ZSTD_NOCOMPRESS\n                /* compression Level */\n                if ((*argument>='0') && (*argument<='9')) {\n                    dictCLevel = cLevel = (int)readU32FromChar(&argument);\n                    continue;\n                }\n#endif\n\n                switch(argument[0])\n                {\n                    /* Display help */\n                case 'V': printVersion(); CLEAN_RETURN(0);   /* Version Only */\n                case 'H': usage_advanced(programName); CLEAN_RETURN(0);\n                case 'h': usage(stdout, programName); CLEAN_RETURN(0);\n\n                     /* Compress */\n                case 'z': operation=zom_compress; argument++; break;\n\n                     /* Decoding */\n                case 'd':\n#ifndef ZSTD_NOBENCH\n                        benchParams.mode = BMK_decodeOnly;\n                        if (operation==zom_bench) { argument++; break; }  /* benchmark decode (hidden option) */\n#endif\n                        operation=zom_decompress; argument++; break;\n\n                    /* Force stdout, even if stdout==console */\n                case 'c': forceStdout=1; outFileName=stdoutmark; FIO_setRemoveSrcFile(prefs, 0); argument++; break;\n\n                    /* do not store filename - gzip compatibility - nothing to do */\n                case 'n': argument++; break;\n\n                    /* Use file content as dictionary */\n                case 'D': argument++; NEXT_FIELD(dictFileName); break;\n\n                    /* Overwrite */\n                case 'f': FIO_overwriteMode(prefs); forceStdin=1; forceStdout=1; followLinks=1; allowBlockDevices=1; argument++; break;\n\n                    /* Verbose mode */\n                case 'v': g_displayLevel++; argument++; break;\n\n                    /* Quiet mode */\n                case 'q': g_displayLevel--; argument++; break;\n\n                    /* keep source file (default) */\n                case 'k': FIO_setRemoveSrcFile(prefs, 0); argument++; break;\n\n                    /* Checksum */\n                case 'C': FIO_setChecksumFlag(prefs, 2); argument++; break;\n\n                    /* test compressed file */\n                case 't': operation=zom_test; argument++; break;\n\n                    /* destination file name */\n                case 'o': argument++; NEXT_FIELD(outFileName); break;\n\n                    /* limit memory */\n                case 'M':\n                    argument++;\n                    memLimit = readU32FromChar(&argument);\n                    break;\n                case 'l': operation=zom_list; argument++; break;\n#ifdef UTIL_HAS_CREATEFILELIST\n                    /* recursive */\n                case 'r': recursive=1; argument++; break;\n#endif\n\n#ifndef ZSTD_NOBENCH\n                    /* Benchmark */\n                case 'b':\n                    operation=zom_bench;\n                    argument++;\n                    break;\n\n                    /* range bench (benchmark only) */\n                case 'e':\n                    /* compression Level */\n                    argument++;\n                    cLevelLast = (int)readU32FromChar(&argument);\n                    break;\n\n                    /* Modify Nb Iterations (benchmark only) */\n                case 'i':\n                    argument++;\n                    bench_nbSeconds = readU32FromChar(&argument);\n                    break;\n\n                    /* cut input into blocks (benchmark only) */\n                case 'B':\n                    argument++;\n                    blockSize = readU32FromChar(&argument);\n                    break;\n\n                    /* benchmark files separately (hidden option) */\n                case 'S':\n                    argument++;\n                    separateFiles = 1;\n                    break;\n\n#endif   /* ZSTD_NOBENCH */\n\n                    /* nb of threads (hidden option) */\n                case 'T':\n                    argument++;\n                    nbWorkers = (int)readU32FromChar(&argument);\n                    break;\n\n                    /* Dictionary Selection level */\n                case 's':\n                    argument++;\n                    dictSelect = readU32FromChar(&argument);\n                    break;\n\n                    /* Pause at the end (-p) or set an additional param (-p#) (hidden option) */\n                case 'p': argument++;\n#ifndef ZSTD_NOBENCH\n                    if ((*argument>='0') && (*argument<='9')) {\n                        benchParams.additionalParam = (int)readU32FromChar(&argument);\n                    } else\n#endif\n                        main_pause=1;\n                    break;\n\n                    /* Select compressibility of synthetic sample */\n                case 'P':\n                    argument++;\n                    compressibility = (double)readU32FromChar(&argument) / 100;\n                    break;\n\n                    /* unknown command */\n                default : badusage(programName); CLEAN_RETURN(1);\n                }\n            }\n            continue;\n        }   /* if (argument[0]=='-') */\n\n        /* none of the above : add filename to list */\n        UTIL_refFilename(filenames, argument);\n    }\n\n    /* Welcome message (if verbose) */\n    DISPLAYLEVEL(3, WELCOME_MESSAGE);\n\n#ifdef ZSTD_MULTITHREAD\n    if ((nbWorkers==0) && (!singleThread)) {\n        /* automatically set # workers based on # of reported cpus */\n        if (defaultLogicalCores) {\n            nbWorkers = UTIL_countLogicalCores();\n            DISPLAYLEVEL(3, \"Note: %d logical core(s) detected \\n\", nbWorkers);\n        } else {\n            nbWorkers = UTIL_countPhysicalCores();\n            DISPLAYLEVEL(3, \"Note: %d physical core(s) detected \\n\", nbWorkers);\n        }\n    }\n#else\n    (void)singleThread; (void)nbWorkers; (void)defaultLogicalCores;\n#endif\n\n    g_utilDisplayLevel = g_displayLevel;\n\n#ifdef UTIL_HAS_CREATEFILELIST\n    if (!followLinks) {\n        unsigned u, fileNamesNb;\n        unsigned const nbFilenames = (unsigned)filenames->tableSize;\n        for (u=0, fileNamesNb=0; u<nbFilenames; u++) {\n            if ( UTIL_isLink(filenames->fileNames[u])\n             && !UTIL_isFIFO(filenames->fileNames[u])\n            ) {\n                DISPLAYLEVEL(2, \"Warning : %s is a symbolic link, ignoring \\n\", filenames->fileNames[u]);\n            } else {\n                filenames->fileNames[fileNamesNb++] = filenames->fileNames[u];\n        }   }\n        if (fileNamesNb == 0 && nbFilenames > 0)  /* all names are eliminated */\n            CLEAN_RETURN(1);\n        filenames->tableSize = fileNamesNb;\n    }   /* if (!followLinks) */\n\n    /* read names from a file */\n    if (file_of_names->tableSize) {\n        size_t const nbFileLists = file_of_names->tableSize;\n        size_t flNb;\n        for (flNb=0; flNb < nbFileLists; flNb++) {\n            FileNamesTable* const fnt = UTIL_createFileNamesTable_fromFileName(file_of_names->fileNames[flNb]);\n            if (fnt==NULL) {\n                DISPLAYLEVEL(1, \"zstd: error reading %s \\n\", file_of_names->fileNames[flNb]);\n                CLEAN_RETURN(1);\n            }\n            filenames = UTIL_mergeFileNamesTable(filenames, fnt);\n        }\n    }\n\n    nbInputFileNames = filenames->tableSize; /* saving number of input files */\n\n    if (recursive) {  /* at this stage, filenameTable is a list of paths, which can contain both files and directories */\n        UTIL_expandFNT(&filenames, followLinks);\n    }\n#else\n    (void)followLinks;\n#endif\n\n    if (operation == zom_list) {\n#ifndef ZSTD_NODECOMPRESS\n        int const ret = FIO_listMultipleFiles((unsigned)filenames->tableSize, filenames->fileNames, g_displayLevel);\n        CLEAN_RETURN(ret);\n#else\n        DISPLAY(\"file information is not supported \\n\");\n        CLEAN_RETURN(1);\n#endif\n    }\n\n    /* Check if benchmark is selected */\n    if (operation==zom_bench) {\n#ifndef ZSTD_NOBENCH\n        benchParams.blockSize = blockSize;\n        benchParams.nbWorkers = nbWorkers;\n        benchParams.realTime = (unsigned)setRealTimePrio;\n        benchParams.nbSeconds = bench_nbSeconds;\n        benchParams.ldmFlag = ldmFlag;\n        benchParams.ldmMinMatch = (int)g_ldmMinMatch;\n        benchParams.ldmHashLog = (int)g_ldmHashLog;\n        benchParams.useRowMatchFinder = useRowMatchFinder;\n        if (g_ldmBucketSizeLog != LDM_PARAM_DEFAULT) {\n            benchParams.ldmBucketSizeLog = (int)g_ldmBucketSizeLog;\n        }\n        if (g_ldmHashRateLog != LDM_PARAM_DEFAULT) {\n            benchParams.ldmHashRateLog = (int)g_ldmHashRateLog;\n        }\n        benchParams.literalCompressionMode = literalCompressionMode;\n\n        if (cLevel > ZSTD_maxCLevel()) cLevel = ZSTD_maxCLevel();\n        if (cLevelLast > ZSTD_maxCLevel()) cLevelLast = ZSTD_maxCLevel();\n        if (cLevelLast < cLevel) cLevelLast = cLevel;\n        if (cLevelLast > cLevel)\n            DISPLAYLEVEL(3, \"Benchmarking levels from %d to %d\\n\", cLevel, cLevelLast);\n        if (filenames->tableSize > 0) {\n            if(separateFiles) {\n                unsigned i;\n                for(i = 0; i < filenames->tableSize; i++) {\n                    int c;\n                    DISPLAYLEVEL(3, \"Benchmarking %s \\n\", filenames->fileNames[i]);\n                    for(c = cLevel; c <= cLevelLast; c++) {\n                        BMK_benchFilesAdvanced(&filenames->fileNames[i], 1, dictFileName, c, &compressionParams, g_displayLevel, &benchParams);\n                }   }\n            } else {\n                for(; cLevel <= cLevelLast; cLevel++) {\n                    BMK_benchFilesAdvanced(filenames->fileNames, (unsigned)filenames->tableSize, dictFileName, cLevel, &compressionParams, g_displayLevel, &benchParams);\n            }   }\n        } else {\n            for(; cLevel <= cLevelLast; cLevel++) {\n                BMK_syntheticTest(cLevel, compressibility, &compressionParams, g_displayLevel, &benchParams);\n        }   }\n\n#else\n        (void)bench_nbSeconds; (void)blockSize; (void)setRealTimePrio; (void)separateFiles; (void)compressibility;\n#endif\n        goto _end;\n    }\n\n    /* Check if dictionary builder is selected */\n    if (operation==zom_train) {\n#ifndef ZSTD_NODICT\n        ZDICT_params_t zParams;\n        zParams.compressionLevel = dictCLevel;\n        zParams.notificationLevel = (unsigned)g_displayLevel;\n        zParams.dictID = dictID;\n        if (dict == cover) {\n            int const optimize = !coverParams.k || !coverParams.d;\n            coverParams.nbThreads = (unsigned)nbWorkers;\n            coverParams.zParams = zParams;\n            operationResult = DiB_trainFromFiles(outFileName, maxDictSize, filenames->fileNames, (int)filenames->tableSize, blockSize, NULL, &coverParams, NULL, optimize, memLimit);\n        } else if (dict == fastCover) {\n            int const optimize = !fastCoverParams.k || !fastCoverParams.d;\n            fastCoverParams.nbThreads = (unsigned)nbWorkers;\n            fastCoverParams.zParams = zParams;\n            operationResult = DiB_trainFromFiles(outFileName, maxDictSize, filenames->fileNames, (int)filenames->tableSize, blockSize, NULL, NULL, &fastCoverParams, optimize, memLimit);\n        } else {\n            ZDICT_legacy_params_t dictParams;\n            memset(&dictParams, 0, sizeof(dictParams));\n            dictParams.selectivityLevel = dictSelect;\n            dictParams.zParams = zParams;\n            operationResult = DiB_trainFromFiles(outFileName, maxDictSize, filenames->fileNames, (int)filenames->tableSize, blockSize, &dictParams, NULL, NULL, 0, memLimit);\n        }\n#else\n        (void)dictCLevel; (void)dictSelect; (void)dictID;  (void)maxDictSize; /* not used when ZSTD_NODICT set */\n        DISPLAYLEVEL(1, \"training mode not available \\n\");\n        operationResult = 1;\n#endif\n        goto _end;\n    }\n\n#ifndef ZSTD_NODECOMPRESS\n    if (operation==zom_test) { FIO_setTestMode(prefs, 1); outFileName=nulmark; FIO_setRemoveSrcFile(prefs, 0); }  /* test mode */\n#endif\n\n    /* No input filename ==> use stdin and stdout */\n    if (filenames->tableSize == 0) {\n      /* It is possible that the input\n       was a number of empty directories. In this case\n       stdin and stdout should not be used */\n       if (nbInputFileNames > 0 ){\n        DISPLAYLEVEL(1, \"please provide correct input file(s) or non-empty directories -- ignored \\n\");\n        CLEAN_RETURN(0);\n       }\n       UTIL_refFilename(filenames, stdinmark);\n    }\n\n    if (!strcmp(filenames->fileNames[0], stdinmark) && !outFileName)\n        outFileName = stdoutmark;  /* when input is stdin, default output is stdout */\n\n    /* Check if input/output defined as console; trigger an error in this case */\n    if (!forceStdin\n     && !strcmp(filenames->fileNames[0], stdinmark)\n     && IS_CONSOLE(stdin) ) {\n        DISPLAYLEVEL(1, \"stdin is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n    if ( outFileName && !strcmp(outFileName, stdoutmark)\n      && IS_CONSOLE(stdout)\n      && !strcmp(filenames->fileNames[0], stdinmark)\n      && !forceStdout\n      && operation!=zom_decompress ) {\n        DISPLAYLEVEL(1, \"stdout is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n\n#ifndef ZSTD_NOCOMPRESS\n    /* check compression level limits */\n    {   int const maxCLevel = ultra ? ZSTD_maxCLevel() : ZSTDCLI_CLEVEL_MAX;\n        if (cLevel > maxCLevel) {\n            DISPLAYLEVEL(2, \"Warning : compression level higher than max, reduced to %i \\n\", maxCLevel);\n            cLevel = maxCLevel;\n    }   }\n#endif\n\n    if (showDefaultCParams) {\n        if (operation == zom_decompress) {\n            DISPLAY(\"error : can't use --show-default-cparams in decompression mode \\n\");\n            CLEAN_RETURN(1);\n        }\n    }\n\n    if (dictFileName != NULL && patchFromDictFileName != NULL) {\n        DISPLAY(\"error : can't use -D and --patch-from=# at the same time \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    if (patchFromDictFileName != NULL && filenames->tableSize > 1) {\n        DISPLAY(\"error : can't use --patch-from=# on multiple files \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    /* No status message in pipe mode (stdin - stdout) */\n    hasStdout = outFileName && !strcmp(outFileName,stdoutmark);\n\n    if ((hasStdout || !IS_CONSOLE(stderr)) && (g_displayLevel==2)) g_displayLevel=1;\n\n    /* IO Stream/File */\n    FIO_setHasStdoutOutput(fCtx, hasStdout);\n    FIO_setNbFilesTotal(fCtx, (int)filenames->tableSize);\n    FIO_determineHasStdinInput(fCtx, filenames);\n    FIO_setNotificationLevel(g_displayLevel);\n    FIO_setAllowBlockDevices(prefs, allowBlockDevices);\n    FIO_setPatchFromMode(prefs, patchFromDictFileName != NULL);\n    if (memLimit == 0) {\n        if (compressionParams.windowLog == 0) {\n            memLimit = (U32)1 << g_defaultMaxWindowLog;\n        } else {\n            memLimit = (U32)1 << (compressionParams.windowLog & 31);\n    }   }\n    if (patchFromDictFileName != NULL)\n        dictFileName = patchFromDictFileName;\n    FIO_setMemLimit(prefs, memLimit);\n    if (operation==zom_compress) {\n#ifndef ZSTD_NOCOMPRESS\n        FIO_setContentSize(prefs, contentSize);\n        FIO_setNbWorkers(prefs, nbWorkers);\n        FIO_setBlockSize(prefs, (int)blockSize);\n        if (g_overlapLog!=OVERLAP_LOG_DEFAULT) FIO_setOverlapLog(prefs, (int)g_overlapLog);\n        FIO_setLdmFlag(prefs, (unsigned)ldmFlag);\n        FIO_setLdmHashLog(prefs, (int)g_ldmHashLog);\n        FIO_setLdmMinMatch(prefs, (int)g_ldmMinMatch);\n        if (g_ldmBucketSizeLog != LDM_PARAM_DEFAULT) FIO_setLdmBucketSizeLog(prefs, (int)g_ldmBucketSizeLog);\n        if (g_ldmHashRateLog != LDM_PARAM_DEFAULT) FIO_setLdmHashRateLog(prefs, (int)g_ldmHashRateLog);\n        FIO_setAdaptiveMode(prefs, (unsigned)adapt);\n        FIO_setUseRowMatchFinder(prefs, useRowMatchFinder);\n        FIO_setAdaptMin(prefs, adaptMin);\n        FIO_setAdaptMax(prefs, adaptMax);\n        FIO_setRsyncable(prefs, rsyncable);\n        FIO_setStreamSrcSize(prefs, streamSrcSize);\n        FIO_setTargetCBlockSize(prefs, targetCBlockSize);\n        FIO_setSrcSizeHint(prefs, srcSizeHint);\n        FIO_setLiteralCompressionMode(prefs, literalCompressionMode);\n        FIO_setSparseWrite(prefs, 0);\n        if (adaptMin > cLevel) cLevel = adaptMin;\n        if (adaptMax < cLevel) cLevel = adaptMax;\n\n        /* Compare strategies constant with the ground truth */\n        { ZSTD_bounds strategyBounds = ZSTD_cParam_getBounds(ZSTD_c_strategy);\n          assert(ZSTD_NB_STRATEGIES == strategyBounds.upperBound);\n          (void)strategyBounds; }\n\n        if (showDefaultCParams || g_displayLevel >= 4) {\n            size_t fileNb;\n            for (fileNb = 0; fileNb < (size_t)filenames->tableSize; fileNb++) {\n                if (showDefaultCParams)\n                    printDefaultCParams(filenames->fileNames[fileNb], dictFileName, cLevel);\n                if (g_displayLevel >= 4)\n                    printActualCParams(filenames->fileNames[fileNb], dictFileName, cLevel, &compressionParams);\n            }\n        }\n\n        if (g_displayLevel >= 4)\n            FIO_displayCompressionParameters(prefs);\n        if ((filenames->tableSize==1) && outFileName)\n            operationResult = FIO_compressFilename(fCtx, prefs, outFileName, filenames->fileNames[0], dictFileName, cLevel, compressionParams);\n        else\n            operationResult = FIO_compressMultipleFilenames(fCtx, prefs, filenames->fileNames, outMirroredDirName, outDirName, outFileName, suffix, dictFileName, cLevel, compressionParams);\n#else\n        (void)contentSize; (void)suffix; (void)adapt; (void)rsyncable; (void)ultra; (void)cLevel; (void)ldmFlag; (void)literalCompressionMode; (void)targetCBlockSize; (void)streamSrcSize; (void)srcSizeHint; (void)ZSTD_strategyMap; (void)useRowMatchFinder; /* not used when ZSTD_NOCOMPRESS set */\n        DISPLAY(\"Compression not supported \\n\");\n#endif\n    } else {  /* decompression or test */\n#ifndef ZSTD_NODECOMPRESS\n        if (filenames->tableSize == 1 && outFileName) {\n            operationResult = FIO_decompressFilename(fCtx, prefs, outFileName, filenames->fileNames[0], dictFileName);\n        } else {\n            operationResult = FIO_decompressMultipleFilenames(fCtx, prefs, filenames->fileNames, outMirroredDirName, outDirName, outFileName, dictFileName);\n        }\n#else\n        DISPLAY(\"Decompression not supported \\n\");\n#endif\n    }\n\n_end:\n    FIO_freePreferences(prefs);\n    FIO_freeContext(fCtx);\n    if (main_pause) waitEnter();\n    UTIL_freeFileNamesTable(filenames);\n    UTIL_freeFileNamesTable(file_of_names);\n#ifndef ZSTD_NOTRACE\n    TRACE_finish();\n#endif\n\n    return operationResult;\n}",
  "abstract_func_before": "int main(int VAR_0, const char* VAR_1[])\n{\n    int VAR_2,\n        VAR_3 = 0,\n        VAR_4 = 0,\n        VAR_5 = 0,\n        VAR_6 = 0,\n        VAR_7 = 0,\n        VAR_8 = 0,\n        VAR_9 = 0,\n        VAR_10 = 0,\n        VAR_11 = 0,\n        VAR_12 = 0,\n        VAR_13 = VAR_14,\n        VAR_15 = VAR_16,\n        VAR_17 = 0,\n        VAR_18 = 0,\n        VAR_19 = 0,\n        VAR_20 = 0,\n        VAR_21 = 0,\n        VAR_22 = 0,\n        VAR_23 = 0,\n        VAR_24 = 0,\n        VAR_25=0,\n        VAR_26=1;\n    double VAR_27 = 0.5;\n    unsigned VAR_28 = 3;   /* COMMENT_0 */\n    size_t VAR_29 = 0;\n\n    FIO_prefs_t* const VAR_30 = FIO_createPreferences();\n    FIO_ctx_t* const VAR_31 = FIO_createContext();\n    zstd_operation_mode VAR_32 = VAR_33;\n    ZSTD_compressionParameters VAR_34;\n    int VAR_35 = init_cLevel();\n    int VAR_36 = VAR_14 - 1;  /* COMMENT_1 */\n    unsigned VAR_37 = 0;\n    unsigned VAR_38 = 0;\n    FileNamesTable* VAR_39 = UTIL_allocateFileNamesTable((size_t)VAR_0);  /* COMMENT_2 */\n    FileNamesTable* VAR_40 = UTIL_allocateFileNamesTable((size_t)VAR_0);  /* COMMENT_2 */\n    const char* VAR_41 = VAR_1[0];\n    const char* VAR_42 = NULL;\n    const char* VAR_43 = NULL;\n    const char* VAR_44 = NULL;\n    const char* VAR_45 = NULL;\n    const char* VAR_46 = NULL;\n    const char* VAR_47 = VAR_48;\n    unsigned VAR_49 = VAR_50;\n    unsigned VAR_51 = 0;\n    size_t VAR_52 = 0;\n    size_t VAR_53 = 0;\n    size_t VAR_54 = 0;\n    size_t VAR_55 = 0;\n    int VAR_56 = VAR_57;\n    unsigned VAR_58 = VAR_59;\n#ifndef VAR_60\n    ZDICT_cover_params_t VAR_61 = defaultCoverParams();\n    ZDICT_fastCover_params_t VAR_62 = defaultFastCoverParams();\n    dictType VAR_63 = VAR_64;\n#endif\n#ifndef VAR_65\n    BMK_advancedParams_t VAR_66 = BMK_initAdvancedParams();\n#endif\n    ZSTD_paramSwitch_e VAR_67 = VAR_68;\n\n\n    /* COMMENT_3 */\n    checkLibVersion();\n    (void)VAR_37; (void)VAR_36;    /* COMMENT_4 */\n    (void)VAR_38;\n    assert(VAR_0 >= 1);\n    if ((VAR_39==NULL) || (VAR_40==NULL)) { DISPLAY(\"zstd: allocation error \\n\"); exit(1); }\n    VAR_41 = lastNameFromPath(VAR_41);\n#ifdef VAR_69\n    VAR_10 = init_nbThreads();\n#endif\n\n    /* COMMENT_5 */\n    if (exeNameMatch(VAR_41, VAR_70)) VAR_10=0, VAR_22=0;\n    if (exeNameMatch(VAR_41, VAR_71)) VAR_32=VAR_72;\n    if (exeNameMatch(VAR_41, VAR_73)) { VAR_32=VAR_72; FIO_overwriteMode(VAR_30); VAR_6=1; VAR_3=1; VAR_42=VAR_74; VAR_75=1; }     /* COMMENT_6 */\n    if (exeNameMatch(VAR_41, VAR_76)) { VAR_32=VAR_72; FIO_overwriteMode(VAR_30); VAR_6=1; VAR_3=1; VAR_42=VAR_74; VAR_75=1; }    /* COMMENT_7 */\n    if (exeNameMatch(VAR_41, VAR_77)) {   /* COMMENT_8 */\n        VAR_47 = VAR_78; FIO_setCompressionType(VAR_30, VAR_79); FIO_setRemoveSrcFile(VAR_30, 1);\n        VAR_56 = VAR_35 = 6;  /* COMMENT_9 */\n    }\n    if (exeNameMatch(VAR_41, VAR_80)) { VAR_32=VAR_72; FIO_setRemoveSrcFile(VAR_30, 1); }                                                     /* COMMENT_10 */\n    if (exeNameMatch(VAR_41, VAR_81)) { VAR_32=VAR_72; FIO_overwriteMode(VAR_30); VAR_6=1; VAR_3=1; VAR_42=VAR_74; VAR_75=1; }   /* COMMENT_11 */\n    if (exeNameMatch(VAR_41, VAR_82)) { VAR_47 = VAR_83; FIO_setCompressionType(VAR_30, VAR_84); FIO_setRemoveSrcFile(VAR_30, 1); }    /* COMMENT_12 */\n    if (exeNameMatch(VAR_41, VAR_85)) { VAR_32=VAR_72; FIO_setCompressionType(VAR_30, VAR_84); FIO_setRemoveSrcFile(VAR_30, 1); } /* COMMENT_13 */\n    if (exeNameMatch(VAR_41, VAR_86)) { VAR_47 = VAR_87; FIO_setCompressionType(VAR_30, VAR_88); FIO_setRemoveSrcFile(VAR_30, 1); }          /* COMMENT_14 */\n    if (exeNameMatch(VAR_41, VAR_89)) { VAR_32=VAR_72; FIO_setCompressionType(VAR_30, VAR_88); FIO_setRemoveSrcFile(VAR_30, 1); }     /* COMMENT_15 */\n    if (exeNameMatch(VAR_41, VAR_90)) { VAR_47 = VAR_91; FIO_setCompressionType(VAR_30, VAR_92); }                                       /* COMMENT_16 */\n    if (exeNameMatch(VAR_41, VAR_93)) { VAR_32=VAR_72; FIO_setCompressionType(VAR_30, VAR_92); }                                   /* COMMENT_17 */\n    memset(&VAR_34, 0, sizeof(VAR_34));\n\n    /* COMMENT_18 */\n    FIO_addAbortHandler();\n\n    /* COMMENT_19 */\n    for (VAR_2=1; VAR_2<VAR_0; VAR_2++) {\n        const char* VAR_94 = VAR_1[VAR_2];\n        if (!VAR_94) continue;   /* COMMENT_20 */\n\n        if (VAR_18) {\n            UTIL_refFilename(VAR_39, VAR_94);\n            continue;\n        }\n\n        /* COMMENT_21 */\n        if (!strcmp(VAR_94, \"-\")){\n            UTIL_refFilename(VAR_39, VAR_95);\n            continue;\n        }\n\n        /* COMMENT_22 */\n        if (VAR_94[0]=='-') {\n\n            if (VAR_94[1]=='-') {\n                /* COMMENT_23 */\n                if (!strcmp(VAR_94, \"--\")) { VAR_18=1; continue; }   /* COMMENT_24 */\n                if (!strcmp(VAR_94, \"--list\")) { VAR_32=VAR_96; continue; }\n                if (!strcmp(VAR_94, \"--compress\")) { VAR_32=VAR_33; continue; }\n                if (!strcmp(VAR_94, \"--decompress\")) { VAR_32=VAR_72; continue; }\n                if (!strcmp(VAR_94, \"--uncompress\")) { VAR_32=VAR_72; continue; }\n                if (!strcmp(VAR_94, \"--force\")) { FIO_overwriteMode(VAR_30); VAR_5=1; VAR_6=1; VAR_3=1; VAR_4=1; continue; }\n                if (!strcmp(VAR_94, \"--version\")) { printVersion(); CLEAN_RETURN(0); }\n                if (!strcmp(VAR_94, \"--help\")) { usage_advanced(VAR_41); CLEAN_RETURN(0); }\n                if (!strcmp(VAR_94, \"--verbose\")) { VAR_75++; continue; }\n                if (!strcmp(VAR_94, \"--quiet\")) { VAR_75--; continue; }\n                if (!strcmp(VAR_94, \"--stdout\")) { VAR_6=1; VAR_42=VAR_74; FIO_setRemoveSrcFile(VAR_30, 0); VAR_75-=(VAR_75==2); continue; }\n                if (!strcmp(VAR_94, \"--ultra\")) { VAR_25=1; continue; }\n                if (!strcmp(VAR_94, \"--check\")) { FIO_setChecksumFlag(VAR_30, 2); continue; }\n                if (!strcmp(VAR_94, \"--no-check\")) { FIO_setChecksumFlag(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--sparse\")) { FIO_setSparseWrite(VAR_30, 2); continue; }\n                if (!strcmp(VAR_94, \"--no-sparse\")) { FIO_setSparseWrite(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--test\")) { VAR_32=VAR_97; continue; }\n                if (!strcmp(VAR_94, \"--asyncio\")) { FIO_setAsyncIOFlag(VAR_30, 1); continue;}\n                if (!strcmp(VAR_94, \"--no-asyncio\")) { FIO_setAsyncIOFlag(VAR_30, 0); continue;}\n                if (!strcmp(VAR_94, \"--train\")) { VAR_32=VAR_98; if (VAR_42==NULL) VAR_42=VAR_99; continue; }\n                if (!strcmp(VAR_94, \"--no-dictID\")) { FIO_setDictIDFlag(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--keep\")) { FIO_setRemoveSrcFile(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--rm\")) { FIO_setRemoveSrcFile(VAR_30, 1); continue; }\n                if (!strcmp(VAR_94, \"--priority=rt\")) { VAR_21 = 1; continue; }\n                if (!strcmp(VAR_94, \"--show-default-cparams\")) { VAR_24 = 1; continue; }\n                if (!strcmp(VAR_94, \"--content-size\")) { VAR_26 = 1; continue; }\n                if (!strcmp(VAR_94, \"--no-content-size\")) { VAR_26 = 0; continue; }\n                if (!strcmp(VAR_94, \"--adapt\")) { VAR_11 = 1; continue; }\n                if (!strcmp(VAR_94, \"--no-row-match-finder\")) { VAR_12 = 1; continue; }\n                if (!strcmp(VAR_94, \"--row-match-finder\")) { VAR_12 = 2; continue; }\n                if (longCommandWArg(&VAR_94, \"--adapt=\")) { VAR_11 = 1; if (!parseAdaptParameters(VAR_94, &VAR_13, &VAR_15)) { badusage(VAR_41); CLEAN_RETURN(1); } continue; }\n                if (!strcmp(VAR_94, \"--single-thread\")) { VAR_10 = 0; VAR_22 = 1; continue; }\n                if (!strcmp(VAR_94, \"--format=zstd\")) { VAR_47 = VAR_48; FIO_setCompressionType(VAR_30, VAR_100); continue; }\n#ifdef VAR_101\n                if (!strcmp(VAR_94, \"--format=gzip\")) { VAR_47 = VAR_78; FIO_setCompressionType(VAR_30, VAR_79); continue; }\n                if (exeNameMatch(VAR_41, VAR_77)) {     /* COMMENT_8 */\n                    if (!strcmp(VAR_94, \"--best\")) { VAR_56 = VAR_35 = 9; continue; }\n                    if (!strcmp(VAR_94, \"--no-name\")) { /* COMMENT_25 */; continue; }\n                }\n#endif\n#ifdef VAR_102\n                if (!strcmp(VAR_94, \"--format=lzma\")) { VAR_47 = VAR_83; FIO_setCompressionType(VAR_30, VAR_84);  continue; }\n                if (!strcmp(VAR_94, \"--format=xz\")) { VAR_47 = VAR_87; FIO_setCompressionType(VAR_30, VAR_88);  continue; }\n#endif\n#ifdef VAR_103\n                if (!strcmp(VAR_94, \"--format=lz4\")) { VAR_47 = VAR_91; FIO_setCompressionType(VAR_30, VAR_92);  continue; }\n#endif\n                if (!strcmp(VAR_94, \"--rsyncable\")) { VAR_17 = 1; continue; }\n                if (!strcmp(VAR_94, \"--compress-literals\")) { VAR_67 = VAR_104; continue; }\n                if (!strcmp(VAR_94, \"--no-compress-literals\")) { VAR_67 = VAR_105; continue; }\n                if (!strcmp(VAR_94, \"--no-progress\")) { FIO_setProgressSetting(VAR_106); continue; }\n                if (!strcmp(VAR_94, \"--progress\")) { FIO_setProgressSetting(VAR_107); continue; }\n                if (!strcmp(VAR_94, \"--exclude-compressed\")) { FIO_setExcludeCompressedFile(VAR_30, 1); continue; }\n\n                /* COMMENT_26 */\n#ifndef VAR_60\n                if (longCommandWArg(&VAR_94, \"--train-cover\")) {\n                  VAR_32 = VAR_98;\n                  if (VAR_42 == NULL)\n                      VAR_42 = VAR_99;\n                  VAR_63 = VAR_108;\n                  /* COMMENT_27 */\n                  if (*VAR_94 == 0) { memset(&VAR_61, 0, sizeof(VAR_61)); }\n                  else if (*VAR_94++ != '=') { badusage(VAR_41); CLEAN_RETURN(1); }\n                  else if (!parseCoverParameters(VAR_94, &VAR_61)) { badusage(VAR_41); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&VAR_94, \"--train-fastcover\")) {\n                  VAR_32 = VAR_98;\n                  if (VAR_42 == NULL)\n                      VAR_42 = VAR_99;\n                  VAR_63 = VAR_64;\n                  /* COMMENT_27 */\n                  if (*VAR_94 == 0) { memset(&VAR_62, 0, sizeof(VAR_62)); }\n                  else if (*VAR_94++ != '=') { badusage(VAR_41); CLEAN_RETURN(1); }\n                  else if (!parseFastCoverParameters(VAR_94, &VAR_62)) { badusage(VAR_41); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&VAR_94, \"--train-legacy\")) {\n                  VAR_32 = VAR_98;\n                  if (VAR_42 == NULL)\n                      VAR_42 = VAR_99;\n                  VAR_63 = VAR_109;\n                  /* COMMENT_27 */\n                  if (*VAR_94 == 0) { continue; }\n                  else if (*VAR_94++ != '=') { badusage(VAR_41); CLEAN_RETURN(1); }\n                  else if (!parseLegacyParameters(VAR_94, &VAR_58)) { badusage(VAR_41); CLEAN_RETURN(1); }\n                  continue;\n                }\n#endif\n                if (longCommandWArg(&VAR_94, \"--threads\")) { NEXT_UINT32(VAR_10); continue; }\n                if (longCommandWArg(&VAR_94, \"--memlimit\")) { NEXT_UINT32(VAR_38); continue; }\n                if (longCommandWArg(&VAR_94, \"--memory\")) { NEXT_UINT32(VAR_38); continue; }\n                if (longCommandWArg(&VAR_94, \"--memlimit-decompress\")) { NEXT_UINT32(VAR_38); continue; }\n                if (longCommandWArg(&VAR_94, \"--block-size=\")) { VAR_29 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--maxdict\")) { NEXT_UINT32(VAR_49); continue; }\n                if (longCommandWArg(&VAR_94, \"--dictID\")) { NEXT_UINT32(VAR_51); continue; }\n                if (longCommandWArg(&VAR_94, \"--zstd=\")) { if (!parseCompressionParameters(VAR_94, &VAR_34)) { badusage(VAR_41); CLEAN_RETURN(1); } continue; }\n                if (longCommandWArg(&VAR_94, \"--stream-size=\")) { VAR_52 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--target-compressed-block-size=\")) { VAR_53 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--size-hint=\")) { VAR_54 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--output-dir-flat\")) { NEXT_FIELD(VAR_43); continue; }\n                if (longCommandWArg(&VAR_94, \"--auto-threads\")) {\n                    const char* VAR_110 = NULL;\n                    NEXT_FIELD(VAR_110);\n                    if (strcmp(VAR_110, \"logical\") == 0)\n                        VAR_23 = 1;\n                    continue;\n                }\n#ifdef VAR_111\n                if (longCommandWArg(&VAR_94, \"--output-dir-mirror\")) { NEXT_FIELD(VAR_44); continue; }\n#endif\n#ifndef VAR_112\n                if (longCommandWArg(&VAR_94, \"--trace\")) { char const* VAR_113; NEXT_FIELD(VAR_113); TRACE_enable(VAR_113); continue; }\n#endif\n                if (longCommandWArg(&VAR_94, \"--patch-from\")) { NEXT_FIELD(VAR_46); continue; }\n                if (longCommandWArg(&VAR_94, \"--long\")) {\n                    unsigned VAR_114 = 0;\n                    VAR_8 = 1;\n                    /* COMMENT_28 */\n                    if (*VAR_94 == '=') {\n                        ++VAR_94;\n                        VAR_114 = readU32FromChar(&VAR_94);\n                    } else if (*VAR_94 != 0) {\n                        /* COMMENT_29 */\n                        badusage(VAR_41);\n                        CLEAN_RETURN(1);\n                    }\n                    /* COMMENT_30 */\n                    if (VAR_34.windowLog == 0)\n                        VAR_34.windowLog = VAR_114;\n                    continue;\n                }\n#ifndef VAR_115   /* COMMENT_31 */\n                if (longCommandWArg(&VAR_94, \"--fast\")) {\n                    /* COMMENT_32 */\n                    if (*VAR_94 == '=') {\n                        U32 const VAR_116 = (U32)-ZSTD_minCLevel();\n                        U32 VAR_117;\n                        ++VAR_94;\n                        VAR_117 = readU32FromChar(&VAR_94);\n                        if (VAR_117 > VAR_116) VAR_117 = VAR_116;\n                        if (VAR_117) {\n                            VAR_56 = VAR_35 = -(int)VAR_117;\n                        } else {\n                            badusage(VAR_41);\n                            CLEAN_RETURN(1);\n                        }\n                    } else if (*VAR_94 != 0) {\n                        /* COMMENT_33 */\n                        badusage(VAR_41);\n                        CLEAN_RETURN(1);\n                    } else {\n                        VAR_35 = -1;  /* COMMENT_34 */\n                    }\n                    continue;\n                }\n#endif\n\n                if (longCommandWArg(&VAR_94, \"--filelist\")) {\n                    const char* VAR_118;\n                    NEXT_FIELD(VAR_118);\n                    UTIL_refFilename(VAR_40, VAR_118);\n                    continue;\n                }\n\n                /* COMMENT_35 */\n            }\n\n            VAR_94++;\n            while (VAR_94[0]!=0) {\n\n#ifndef VAR_115\n                /* COMMENT_36 */\n                if ((*VAR_94>='0') && (*VAR_94<='9')) {\n                    VAR_56 = VAR_35 = (int)readU32FromChar(&VAR_94);\n                    continue;\n                }\n#endif\n\n                switch(VAR_94[0])\n                {\n                    /* COMMENT_37 */\n                case 'V': printVersion(); CLEAN_RETURN(0);   /* COMMENT_38 */\n                case 'H': usage_advanced(VAR_41); CLEAN_RETURN(0);\n                case 'h': usage(VAR_119, VAR_41); CLEAN_RETURN(0);\n\n                     /* COMMENT_39 */\n                case 'z': VAR_32=VAR_33; VAR_94++; break;\n\n                     /* COMMENT_40 */\n                case 'd':\n#ifndef VAR_65\n                        VAR_66.mode = VAR_120;\n                        if (VAR_32==VAR_121) { VAR_94++; break; }  /* COMMENT_41 */\n#endif\n                        VAR_32=VAR_72; VAR_94++; break;\n\n                    /* COMMENT_42 */\n                case 'c': VAR_6=1; VAR_42=VAR_74; FIO_setRemoveSrcFile(VAR_30, 0); VAR_94++; break;\n\n                    /* COMMENT_43 */\n                case 'n': VAR_94++; break;\n\n                    /* COMMENT_44 */\n                case 'D': VAR_94++; NEXT_FIELD(VAR_45); break;\n\n                    /* COMMENT_45 */\n                case 'f': FIO_overwriteMode(VAR_30); VAR_5=1; VAR_6=1; VAR_3=1; VAR_4=1; VAR_94++; break;\n\n                    /* COMMENT_46 */\n                case 'v': VAR_75++; VAR_94++; break;\n\n                    /* COMMENT_47 */\n                case 'q': VAR_75--; VAR_94++; break;\n\n                    /* COMMENT_48 */\n                case 'k': FIO_setRemoveSrcFile(VAR_30, 0); VAR_94++; break;\n\n                    /* COMMENT_49 */\n                case 'C': FIO_setChecksumFlag(VAR_30, 2); VAR_94++; break;\n\n                    /* COMMENT_50 */\n                case 't': VAR_32=VAR_97; VAR_94++; break;\n\n                    /* COMMENT_51 */\n                case 'o': VAR_94++; NEXT_FIELD(VAR_42); break;\n\n                    /* COMMENT_52 */\n                case 'M':\n                    VAR_94++;\n                    VAR_38 = readU32FromChar(&VAR_94);\n                    break;\n                case 'l': VAR_32=VAR_96; VAR_94++; break;\n#ifdef VAR_122\n                    /* COMMENT_53 */\n                case 'r': VAR_37=1; VAR_94++; break;\n#endif\n\n#ifndef VAR_65\n                    /* COMMENT_54 */\n                case 'b':\n                    VAR_32=VAR_121;\n                    VAR_94++;\n                    break;\n\n                    /* COMMENT_55 */\n                case 'e':\n                    /* COMMENT_36 */\n                    VAR_94++;\n                    VAR_36 = (int)readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_56 */\n                case 'i':\n                    VAR_94++;\n                    VAR_28 = readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_57 */\n                case 'B':\n                    VAR_94++;\n                    VAR_29 = readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_58 */\n                case 'S':\n                    VAR_94++;\n                    VAR_20 = 1;\n                    break;\n\n#endif   /* COMMENT_59 */\n\n                    /* COMMENT_60 */\n                case 'T':\n                    VAR_94++;\n                    VAR_10 = (int)readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_61 */\n                case 's':\n                    VAR_94++;\n                    VAR_58 = readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_62 */\n                case 'p': VAR_94++;\n#ifndef VAR_65\n                    if ((*VAR_94>='0') && (*VAR_94<='9')) {\n                        VAR_66.additionalParam = (int)readU32FromChar(&VAR_94);\n                    } else\n#endif\n                        VAR_9=1;\n                    break;\n\n                    /* COMMENT_63 */\n                case 'P':\n                    VAR_94++;\n                    VAR_27 = (double)readU32FromChar(&VAR_94) / 100;\n                    break;\n\n                    /* COMMENT_64 */\n                default : badusage(VAR_41); CLEAN_RETURN(1);\n                }\n            }\n            continue;\n        }   /* COMMENT_65 */\n\n        /* COMMENT_66 */\n        UTIL_refFilename(VAR_39, VAR_94);\n    }\n\n    /* COMMENT_67 */\n    DISPLAYLEVEL(3, VAR_123);\n\n#ifdef VAR_69\n    if ((VAR_10==0) && (!VAR_22)) {\n        /* COMMENT_68 */\n        if (VAR_23) {\n            VAR_10 = UTIL_countLogicalCores();\n            DISPLAYLEVEL(3, \"Note: %d logical core(s) detected \\n\", VAR_10);\n        } else {\n            VAR_10 = UTIL_countPhysicalCores();\n            DISPLAYLEVEL(3, \"Note: %d physical core(s) detected \\n\", VAR_10);\n        }\n    }\n#else\n    (void)VAR_22; (void)VAR_10; (void)VAR_23;\n#endif\n\n    VAR_124 = VAR_75;\n\n#ifdef VAR_122\n    if (!VAR_3) {\n        unsigned VAR_125, VAR_126;\n        unsigned const VAR_127 = (unsigned)VAR_39->tableSize;\n        for (VAR_125=0, VAR_126=0; VAR_125<VAR_127; VAR_125++) {\n            if ( UTIL_isLink(VAR_39->fileNames[VAR_125])\n             && !UTIL_isFIFO(VAR_39->fileNames[VAR_125])\n            ) {\n                DISPLAYLEVEL(2, \"Warning : %s is a symbolic link, ignoring \\n\", VAR_39->fileNames[VAR_125]);\n            } else {\n                VAR_39->fileNames[VAR_126++] = VAR_39->fileNames[VAR_125];\n        }   }\n        if (VAR_126 == 0 && VAR_127 > 0)  /* COMMENT_69 */\n            CLEAN_RETURN(1);\n        VAR_39->tableSize = VAR_126;\n    }   /* COMMENT_70 */\n\n    /* COMMENT_71 */\n    if (VAR_40->tableSize) {\n        size_t const VAR_128 = VAR_40->tableSize;\n        size_t VAR_129;\n        for (VAR_129=0; VAR_129 < VAR_128; VAR_129++) {\n            FileNamesTable* const VAR_130 = UTIL_createFileNamesTable_fromFileName(VAR_40->fileNames[VAR_129]);\n            if (VAR_130==NULL) {\n                DISPLAYLEVEL(1, \"zstd: error reading %s \\n\", VAR_40->fileNames[VAR_129]);\n                CLEAN_RETURN(1);\n            }\n            VAR_39 = UTIL_mergeFileNamesTable(VAR_39, VAR_130);\n        }\n    }\n\n    VAR_55 = VAR_39->tableSize; /* COMMENT_72 */\n\n    if (VAR_37) {  /* COMMENT_73 */\n        UTIL_expandFNT(&VAR_39, VAR_3);\n    }\n#else\n    (void)VAR_3;\n#endif\n\n    if (VAR_32 == VAR_96) {\n#ifndef VAR_131\n        int const VAR_132 = FIO_listMultipleFiles((unsigned)VAR_39->tableSize, VAR_39->fileNames, VAR_75);\n        CLEAN_RETURN(VAR_132);\n#else\n        DISPLAY(\"file information is not supported \\n\");\n        CLEAN_RETURN(1);\n#endif\n    }\n\n    /* COMMENT_74 */\n    if (VAR_32==VAR_121) {\n#ifndef VAR_65\n        VAR_66.blockSize = VAR_29;\n        VAR_66.nbWorkers = VAR_10;\n        VAR_66.realTime = (unsigned)VAR_21;\n        VAR_66.nbSeconds = VAR_28;\n        VAR_66.ldmFlag = VAR_8;\n        VAR_66.ldmMinMatch = (int)VAR_133;\n        VAR_66.ldmHashLog = (int)VAR_134;\n        VAR_66.useRowMatchFinder = VAR_12;\n        if (VAR_135 != VAR_136) {\n            VAR_66.ldmBucketSizeLog = (int)VAR_135;\n        }\n        if (VAR_137 != VAR_136) {\n            VAR_66.ldmHashRateLog = (int)VAR_137;\n        }\n        VAR_66.literalCompressionMode = VAR_67;\n\n        if (VAR_35 > ZSTD_maxCLevel()) VAR_35 = ZSTD_maxCLevel();\n        if (VAR_36 > ZSTD_maxCLevel()) VAR_36 = ZSTD_maxCLevel();\n        if (VAR_36 < VAR_35) VAR_36 = VAR_35;\n        if (VAR_36 > VAR_35)\n            DISPLAYLEVEL(3, \"Benchmarking levels from %d to %d\\n\", VAR_35, VAR_36);\n        if (VAR_39->tableSize > 0) {\n            if(VAR_20) {\n                unsigned VAR_138;\n                for(VAR_138 = 0; VAR_138 < VAR_39->tableSize; VAR_138++) {\n                    int VAR_139;\n                    DISPLAYLEVEL(3, \"Benchmarking %s \\n\", VAR_39->fileNames[VAR_138]);\n                    for(VAR_139 = VAR_35; VAR_139 <= VAR_36; VAR_139++) {\n                        BMK_benchFilesAdvanced(&VAR_39->fileNames[VAR_138], 1, VAR_45, VAR_139, &VAR_34, VAR_75, &VAR_66);\n                }   }\n            } else {\n                for(; VAR_35 <= VAR_36; VAR_35++) {\n                    BMK_benchFilesAdvanced(VAR_39->fileNames, (unsigned)VAR_39->tableSize, VAR_45, VAR_35, &VAR_34, VAR_75, &VAR_66);\n            }   }\n        } else {\n            for(; VAR_35 <= VAR_36; VAR_35++) {\n                BMK_syntheticTest(VAR_35, VAR_27, &VAR_34, VAR_75, &VAR_66);\n        }   }\n\n#else\n        (void)VAR_28; (void)VAR_29; (void)VAR_21; (void)VAR_20; (void)VAR_27;\n#endif\n        goto _end;\n    }\n\n    /* COMMENT_75 */\n    if (VAR_32==VAR_98) {\n#ifndef VAR_60\n        ZDICT_params_t VAR_140;\n        VAR_140.compressionLevel = VAR_56;\n        VAR_140.notificationLevel = (unsigned)VAR_75;\n        VAR_140.dictID = VAR_51;\n        if (VAR_63 == VAR_108) {\n            int const VAR_141 = !VAR_61.k || !VAR_61.d;\n            VAR_61.nbThreads = (unsigned)VAR_10;\n            VAR_61.zParams = VAR_140;\n            VAR_19 = DiB_trainFromFiles(VAR_42, VAR_49, VAR_39->fileNames, (int)VAR_39->tableSize, VAR_29, NULL, &VAR_61, NULL, VAR_141, VAR_38);\n        } else if (VAR_63 == VAR_64) {\n            int const VAR_141 = !VAR_62.k || !VAR_62.d;\n            VAR_62.nbThreads = (unsigned)VAR_10;\n            VAR_62.zParams = VAR_140;\n            VAR_19 = DiB_trainFromFiles(VAR_42, VAR_49, VAR_39->fileNames, (int)VAR_39->tableSize, VAR_29, NULL, NULL, &VAR_62, VAR_141, VAR_38);\n        } else {\n            ZDICT_legacy_params_t VAR_142;\n            memset(&VAR_142, 0, sizeof(VAR_142));\n            VAR_142.selectivityLevel = VAR_58;\n            VAR_142.zParams = VAR_140;\n            VAR_19 = DiB_trainFromFiles(VAR_42, VAR_49, VAR_39->fileNames, (int)VAR_39->tableSize, VAR_29, &VAR_142, NULL, NULL, 0, VAR_38);\n        }\n#else\n        (void)VAR_56; (void)VAR_58; (void)VAR_51;  (void)VAR_49; /* COMMENT_76 */\n        DISPLAYLEVEL(1, \"training mode not available \\n\");\n        VAR_19 = 1;\n#endif\n        goto _end;\n    }\n\n#ifndef VAR_131\n    if (VAR_32==VAR_97) { FIO_setTestMode(VAR_30, 1); VAR_42=VAR_143; FIO_setRemoveSrcFile(VAR_30, 0); }  /* COMMENT_77 */\n#endif\n\n    /* COMMENT_78 */\n    if (VAR_39->tableSize == 0) {\n      /* COMMENT_79 */\n                                                      \n                                             \n       if (VAR_55 > 0 ){\n        DISPLAYLEVEL(1, \"please provide correct input file(s) or non-empty directories -- ignored \\n\");\n        CLEAN_RETURN(0);\n       }\n       UTIL_refFilename(VAR_39, VAR_95);\n    }\n\n    if (!strcmp(VAR_39->fileNames[0], VAR_95) && !VAR_42)\n        VAR_42 = VAR_74;  /* COMMENT_82 */\n\n    /* COMMENT_83 */\n    if (!VAR_5\n     && !strcmp(VAR_39->fileNames[0], VAR_95)\n     && IS_CONSOLE(VAR_144) ) {\n        DISPLAYLEVEL(1, \"stdin is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n    if ( VAR_42 && !strcmp(VAR_42, VAR_74)\n      && IS_CONSOLE(VAR_119)\n      && !strcmp(VAR_39->fileNames[0], VAR_95)\n      && !VAR_6\n      && VAR_32!=VAR_72 ) {\n        DISPLAYLEVEL(1, \"stdout is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n\n#ifndef VAR_115\n    /* COMMENT_84 */\n    {   int const VAR_145 = VAR_25 ? ZSTD_maxCLevel() : VAR_146;\n        if (VAR_35 > VAR_145) {\n            DISPLAYLEVEL(2, \"Warning : compression level higher than max, reduced to %i \\n\", VAR_145);\n            VAR_35 = VAR_145;\n    }   }\n#endif\n\n    if (VAR_24) {\n        if (VAR_32 == VAR_72) {\n            DISPLAY(\"error : can't use --show-default-cparams in decompression mode \\n\");\n            CLEAN_RETURN(1);\n        }\n    }\n\n    if (VAR_45 != NULL && VAR_46 != NULL) {\n        DISPLAY(\"error : can't use -D and --patch-from=# at the same time \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    if (VAR_46 != NULL && VAR_39->tableSize > 1) {\n        DISPLAY(\"error : can't use --patch-from=# on multiple files \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    /* COMMENT_85 */\n    VAR_7 = VAR_42 && !strcmp(VAR_42,VAR_74);\n\n    if ((VAR_7 || !IS_CONSOLE(VAR_147)) && (VAR_75==2)) VAR_75=1;\n\n    /* COMMENT_86 */\n    FIO_setHasStdoutOutput(VAR_31, VAR_7);\n    FIO_setNbFilesTotal(VAR_31, (int)VAR_39->tableSize);\n    FIO_determineHasStdinInput(VAR_31, VAR_39);\n    FIO_setNotificationLevel(VAR_75);\n    FIO_setAllowBlockDevices(VAR_30, VAR_4);\n    FIO_setPatchFromMode(VAR_30, VAR_46 != NULL);\n    if (VAR_38 == 0) {\n        if (VAR_34.windowLog == 0) {\n            VAR_38 = (U32)1 << VAR_148;\n        } else {\n            VAR_38 = (U32)1 << (VAR_34.windowLog & 31);\n    }   }\n    if (VAR_46 != NULL)\n        VAR_45 = VAR_46;\n    FIO_setMemLimit(VAR_30, VAR_38);\n    if (VAR_32==VAR_33) {\n#ifndef VAR_115\n        FIO_setContentSize(VAR_30, VAR_26);\n        FIO_setNbWorkers(VAR_30, VAR_10);\n        FIO_setBlockSize(VAR_30, (int)VAR_29);\n        if (VAR_149!=VAR_150) FIO_setOverlapLog(VAR_30, (int)VAR_149);\n        FIO_setLdmFlag(VAR_30, (unsigned)VAR_8);\n        FIO_setLdmHashLog(VAR_30, (int)VAR_134);\n        FIO_setLdmMinMatch(VAR_30, (int)VAR_133);\n        if (VAR_135 != VAR_136) FIO_setLdmBucketSizeLog(VAR_30, (int)VAR_135);\n        if (VAR_137 != VAR_136) FIO_setLdmHashRateLog(VAR_30, (int)VAR_137);\n        FIO_setAdaptiveMode(VAR_30, (unsigned)VAR_11);\n        FIO_setUseRowMatchFinder(VAR_30, VAR_12);\n        FIO_setAdaptMin(VAR_30, VAR_13);\n        FIO_setAdaptMax(VAR_30, VAR_15);\n        FIO_setRsyncable(VAR_30, VAR_17);\n        FIO_setStreamSrcSize(VAR_30, VAR_52);\n        FIO_setTargetCBlockSize(VAR_30, VAR_53);\n        FIO_setSrcSizeHint(VAR_30, VAR_54);\n        FIO_setLiteralCompressionMode(VAR_30, VAR_67);\n        FIO_setSparseWrite(VAR_30, 0);\n        if (VAR_13 > VAR_35) VAR_35 = VAR_13;\n        if (VAR_15 < VAR_35) VAR_35 = VAR_15;\n\n        /* COMMENT_87 */\n        { ZSTD_bounds VAR_151 = ZSTD_cParam_getBounds(VAR_152);\n          assert(VAR_153 == VAR_151.upperBound);\n          (void)VAR_151; }\n\n        if (VAR_24 || VAR_75 >= 4) {\n            size_t VAR_154;\n            for (VAR_154 = 0; VAR_154 < (size_t)VAR_39->tableSize; VAR_154++) {\n                if (VAR_24)\n                    printDefaultCParams(VAR_39->fileNames[VAR_154], VAR_45, VAR_35);\n                if (VAR_75 >= 4)\n                    printActualCParams(VAR_39->fileNames[VAR_154], VAR_45, VAR_35, &VAR_34);\n            }\n        }\n\n        if (VAR_75 >= 4)\n            FIO_displayCompressionParameters(VAR_30);\n        if ((VAR_39->tableSize==1) && VAR_42)\n            VAR_19 = FIO_compressFilename(VAR_31, VAR_30, VAR_42, VAR_39->fileNames[0], VAR_45, VAR_35, VAR_34);\n        else\n            VAR_19 = FIO_compressMultipleFilenames(VAR_31, VAR_30, VAR_39->fileNames, VAR_44, VAR_43, VAR_42, VAR_47, VAR_45, VAR_35, VAR_34);\n#else\n        (void)VAR_26; (void)VAR_47; (void)VAR_11; (void)VAR_17; (void)VAR_25; (void)VAR_35; (void)VAR_8; (void)VAR_67; (void)VAR_53; (void)VAR_52; (void)VAR_54; (void)VAR_155; (void)VAR_12; /* COMMENT_88 */\n        DISPLAY(\"Compression not supported \\n\");\n#endif\n    } else {  /* COMMENT_89 */\n#ifndef VAR_131\n        if (VAR_39->tableSize == 1 && VAR_42) {\n            VAR_19 = FIO_decompressFilename(VAR_31, VAR_30, VAR_42, VAR_39->fileNames[0], VAR_45);\n        } else {\n            VAR_19 = FIO_decompressMultipleFilenames(VAR_31, VAR_30, VAR_39->fileNames, VAR_44, VAR_43, VAR_42, VAR_45);\n        }\n#else\n        DISPLAY(\"Decompression not supported \\n\");\n#endif\n    }\n\n_end:\n    FIO_freePreferences(VAR_30);\n    FIO_freeContext(VAR_31);\n    if (VAR_9) waitEnter();\n    UTIL_freeFileNamesTable(VAR_39);\n    UTIL_freeFileNamesTable(VAR_40);\n#ifndef VAR_112\n    TRACE_finish();\n#endif\n\n    return VAR_19;\n}",
  "func_graph_path_before": "facebook/zstd/f9f27de91c89d826c6a39c3ef44fb1b02f9a43aa/zstdcli.c/vul/before/0.json",
  "func": "int main(int argCount, const char* argv[])\n{\n    int argNb,\n        followLinks = 0,\n        allowBlockDevices = 0,\n        forceStdin = 0,\n        forceStdout = 0,\n        hasStdout = 0,\n        ldmFlag = 0,\n        main_pause = 0,\n        nbWorkers = 0,\n        adapt = 0,\n        useRowMatchFinder = 0,\n        adaptMin = MINCLEVEL,\n        adaptMax = MAXCLEVEL,\n        rsyncable = 0,\n        nextArgumentsAreFiles = 0,\n        operationResult = 0,\n        separateFiles = 0,\n        setRealTimePrio = 0,\n        singleThread = 0,\n        defaultLogicalCores = 0,\n        showDefaultCParams = 0,\n        ultra=0,\n        contentSize=1;\n    double compressibility = 0.5;\n    unsigned bench_nbSeconds = 3;   /* would be better if this value was synchronized from bench */\n    size_t blockSize = 0;\n\n    FIO_prefs_t* const prefs = FIO_createPreferences();\n    FIO_ctx_t* const fCtx = FIO_createContext();\n    zstd_operation_mode operation = zom_compress;\n    ZSTD_compressionParameters compressionParams;\n    int cLevel = init_cLevel();\n    int cLevelLast = MINCLEVEL - 1;  /* lower than minimum */\n    unsigned recursive = 0;\n    unsigned memLimit = 0;\n    FileNamesTable* filenames = UTIL_allocateFileNamesTable((size_t)argCount);  /* argCount >= 1 */\n    FileNamesTable* file_of_names = UTIL_allocateFileNamesTable((size_t)argCount);  /* argCount >= 1 */\n    const char* programName = argv[0];\n    const char* outFileName = NULL;\n    const char* outDirName = NULL;\n    const char* outMirroredDirName = NULL;\n    const char* dictFileName = NULL;\n    const char* patchFromDictFileName = NULL;\n    const char* suffix = ZSTD_EXTENSION;\n    unsigned maxDictSize = g_defaultMaxDictSize;\n    unsigned dictID = 0;\n    size_t streamSrcSize = 0;\n    size_t targetCBlockSize = 0;\n    size_t srcSizeHint = 0;\n    size_t nbInputFileNames = 0;\n    int dictCLevel = g_defaultDictCLevel;\n    unsigned dictSelect = g_defaultSelectivityLevel;\n#ifndef ZSTD_NODICT\n    ZDICT_cover_params_t coverParams = defaultCoverParams();\n    ZDICT_fastCover_params_t fastCoverParams = defaultFastCoverParams();\n    dictType dict = fastCover;\n#endif\n#ifndef ZSTD_NOBENCH\n    BMK_advancedParams_t benchParams = BMK_initAdvancedParams();\n#endif\n    ZSTD_paramSwitch_e literalCompressionMode = ZSTD_ps_auto;\n\n\n    /* init */\n    checkLibVersion();\n    (void)recursive; (void)cLevelLast;    /* not used when ZSTD_NOBENCH set */\n    (void)memLimit;\n    assert(argCount >= 1);\n    if ((filenames==NULL) || (file_of_names==NULL)) { DISPLAY(\"zstd: allocation error \\n\"); exit(1); }\n    programName = lastNameFromPath(programName);\n#ifdef ZSTD_MULTITHREAD\n    nbWorkers = init_nbThreads();\n#endif\n\n    /* preset behaviors */\n    if (exeNameMatch(programName, ZSTD_ZSTDMT)) nbWorkers=0, singleThread=0;\n    if (exeNameMatch(programName, ZSTD_UNZSTD)) operation=zom_decompress;\n    if (exeNameMatch(programName, ZSTD_CAT)) { operation=zom_decompress; FIO_overwriteMode(prefs); forceStdout=1; followLinks=1; outFileName=stdoutmark; g_displayLevel=1; }     /* supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_ZCAT)) { operation=zom_decompress; FIO_overwriteMode(prefs); forceStdout=1; followLinks=1; outFileName=stdoutmark; g_displayLevel=1; }    /* behave like zcat, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_GZ)) {   /* behave like gzip */\n        suffix = GZ_EXTENSION; FIO_setCompressionType(prefs, FIO_gzipCompression); FIO_setRemoveSrcFile(prefs, 1);\n        dictCLevel = cLevel = 6;  /* gzip default is -6 */\n    }\n    if (exeNameMatch(programName, ZSTD_GUNZIP)) { operation=zom_decompress; FIO_setRemoveSrcFile(prefs, 1); }                                                     /* behave like gunzip, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_GZCAT)) { operation=zom_decompress; FIO_overwriteMode(prefs); forceStdout=1; followLinks=1; outFileName=stdoutmark; g_displayLevel=1; }   /* behave like gzcat, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_LZMA)) { suffix = LZMA_EXTENSION; FIO_setCompressionType(prefs, FIO_lzmaCompression); FIO_setRemoveSrcFile(prefs, 1); }    /* behave like lzma */\n    if (exeNameMatch(programName, ZSTD_UNLZMA)) { operation=zom_decompress; FIO_setCompressionType(prefs, FIO_lzmaCompression); FIO_setRemoveSrcFile(prefs, 1); } /* behave like unlzma, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_XZ)) { suffix = XZ_EXTENSION; FIO_setCompressionType(prefs, FIO_xzCompression); FIO_setRemoveSrcFile(prefs, 1); }          /* behave like xz */\n    if (exeNameMatch(programName, ZSTD_UNXZ)) { operation=zom_decompress; FIO_setCompressionType(prefs, FIO_xzCompression); FIO_setRemoveSrcFile(prefs, 1); }     /* behave like unxz, also supports multiple formats */\n    if (exeNameMatch(programName, ZSTD_LZ4)) { suffix = LZ4_EXTENSION; FIO_setCompressionType(prefs, FIO_lz4Compression); }                                       /* behave like lz4 */\n    if (exeNameMatch(programName, ZSTD_UNLZ4)) { operation=zom_decompress; FIO_setCompressionType(prefs, FIO_lz4Compression); }                                   /* behave like unlz4, also supports multiple formats */\n    memset(&compressionParams, 0, sizeof(compressionParams));\n\n    /* init crash handler */\n    FIO_addAbortHandler();\n\n    /* command switches */\n    for (argNb=1; argNb<argCount; argNb++) {\n        const char* argument = argv[argNb];\n        if (!argument) continue;   /* Protection if argument empty */\n\n        if (nextArgumentsAreFiles) {\n            UTIL_refFilename(filenames, argument);\n            continue;\n        }\n\n        /* \"-\" means stdin/stdout */\n        if (!strcmp(argument, \"-\")){\n            UTIL_refFilename(filenames, stdinmark);\n            continue;\n        }\n\n        /* Decode commands (note : aggregated commands are allowed) */\n        if (argument[0]=='-') {\n\n            if (argument[1]=='-') {\n                /* long commands (--long-word) */\n                if (!strcmp(argument, \"--\")) { nextArgumentsAreFiles=1; continue; }   /* only file names allowed from now on */\n                if (!strcmp(argument, \"--list\")) { operation=zom_list; continue; }\n                if (!strcmp(argument, \"--compress\")) { operation=zom_compress; continue; }\n                if (!strcmp(argument, \"--decompress\")) { operation=zom_decompress; continue; }\n                if (!strcmp(argument, \"--uncompress\")) { operation=zom_decompress; continue; }\n                if (!strcmp(argument, \"--force\")) { FIO_overwriteMode(prefs); forceStdin=1; forceStdout=1; followLinks=1; allowBlockDevices=1; continue; }\n                if (!strcmp(argument, \"--version\")) { printVersion(); CLEAN_RETURN(0); }\n                if (!strcmp(argument, \"--help\")) { usage_advanced(programName); CLEAN_RETURN(0); }\n                if (!strcmp(argument, \"--verbose\")) { g_displayLevel++; continue; }\n                if (!strcmp(argument, \"--quiet\")) { g_displayLevel--; continue; }\n                if (!strcmp(argument, \"--stdout\")) { forceStdout=1; outFileName=stdoutmark; FIO_setRemoveSrcFile(prefs, 0); g_displayLevel-=(g_displayLevel==2); continue; }\n                if (!strcmp(argument, \"--ultra\")) { ultra=1; continue; }\n                if (!strcmp(argument, \"--check\")) { FIO_setChecksumFlag(prefs, 2); continue; }\n                if (!strcmp(argument, \"--no-check\")) { FIO_setChecksumFlag(prefs, 0); continue; }\n                if (!strcmp(argument, \"--sparse\")) { FIO_setSparseWrite(prefs, 2); continue; }\n                if (!strcmp(argument, \"--no-sparse\")) { FIO_setSparseWrite(prefs, 0); continue; }\n                if (!strcmp(argument, \"--test\")) { operation=zom_test; continue; }\n                if (!strcmp(argument, \"--asyncio\")) { FIO_setAsyncIOFlag(prefs, 1); continue;}\n                if (!strcmp(argument, \"--no-asyncio\")) { FIO_setAsyncIOFlag(prefs, 0); continue;}\n                if (!strcmp(argument, \"--train\")) { operation=zom_train; if (outFileName==NULL) outFileName=g_defaultDictName; continue; }\n                if (!strcmp(argument, \"--no-dictID\")) { FIO_setDictIDFlag(prefs, 0); continue; }\n                if (!strcmp(argument, \"--keep\")) { FIO_setRemoveSrcFile(prefs, 0); continue; }\n                if (!strcmp(argument, \"--rm\")) { FIO_setRemoveSrcFile(prefs, 1); continue; }\n                if (!strcmp(argument, \"--priority=rt\")) { setRealTimePrio = 1; continue; }\n                if (!strcmp(argument, \"--show-default-cparams\")) { showDefaultCParams = 1; continue; }\n                if (!strcmp(argument, \"--content-size\")) { contentSize = 1; continue; }\n                if (!strcmp(argument, \"--no-content-size\")) { contentSize = 0; continue; }\n                if (!strcmp(argument, \"--adapt\")) { adapt = 1; continue; }\n                if (!strcmp(argument, \"--no-row-match-finder\")) { useRowMatchFinder = 1; continue; }\n                if (!strcmp(argument, \"--row-match-finder\")) { useRowMatchFinder = 2; continue; }\n                if (longCommandWArg(&argument, \"--adapt=\")) { adapt = 1; if (!parseAdaptParameters(argument, &adaptMin, &adaptMax)) { badusage(programName); CLEAN_RETURN(1); } continue; }\n                if (!strcmp(argument, \"--single-thread\")) { nbWorkers = 0; singleThread = 1; continue; }\n                if (!strcmp(argument, \"--format=zstd\")) { suffix = ZSTD_EXTENSION; FIO_setCompressionType(prefs, FIO_zstdCompression); continue; }\n#ifdef ZSTD_GZCOMPRESS\n                if (!strcmp(argument, \"--format=gzip\")) { suffix = GZ_EXTENSION; FIO_setCompressionType(prefs, FIO_gzipCompression); continue; }\n                if (exeNameMatch(programName, ZSTD_GZ)) {     /* behave like gzip */\n                    if (!strcmp(argument, \"--best\")) { dictCLevel = cLevel = 9; continue; }\n                    if (!strcmp(argument, \"--no-name\")) { /* ignore for now */; continue; }\n                }\n#endif\n#ifdef ZSTD_LZMACOMPRESS\n                if (!strcmp(argument, \"--format=lzma\")) { suffix = LZMA_EXTENSION; FIO_setCompressionType(prefs, FIO_lzmaCompression);  continue; }\n                if (!strcmp(argument, \"--format=xz\")) { suffix = XZ_EXTENSION; FIO_setCompressionType(prefs, FIO_xzCompression);  continue; }\n#endif\n#ifdef ZSTD_LZ4COMPRESS\n                if (!strcmp(argument, \"--format=lz4\")) { suffix = LZ4_EXTENSION; FIO_setCompressionType(prefs, FIO_lz4Compression);  continue; }\n#endif\n                if (!strcmp(argument, \"--rsyncable\")) { rsyncable = 1; continue; }\n                if (!strcmp(argument, \"--compress-literals\")) { literalCompressionMode = ZSTD_ps_enable; continue; }\n                if (!strcmp(argument, \"--no-compress-literals\")) { literalCompressionMode = ZSTD_ps_disable; continue; }\n                if (!strcmp(argument, \"--no-progress\")) { FIO_setProgressSetting(FIO_ps_never); continue; }\n                if (!strcmp(argument, \"--progress\")) { FIO_setProgressSetting(FIO_ps_always); continue; }\n                if (!strcmp(argument, \"--exclude-compressed\")) { FIO_setExcludeCompressedFile(prefs, 1); continue; }\n\n                /* long commands with arguments */\n#ifndef ZSTD_NODICT\n                if (longCommandWArg(&argument, \"--train-cover\")) {\n                  operation = zom_train;\n                  if (outFileName == NULL)\n                      outFileName = g_defaultDictName;\n                  dict = cover;\n                  /* Allow optional arguments following an = */\n                  if (*argument == 0) { memset(&coverParams, 0, sizeof(coverParams)); }\n                  else if (*argument++ != '=') { badusage(programName); CLEAN_RETURN(1); }\n                  else if (!parseCoverParameters(argument, &coverParams)) { badusage(programName); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&argument, \"--train-fastcover\")) {\n                  operation = zom_train;\n                  if (outFileName == NULL)\n                      outFileName = g_defaultDictName;\n                  dict = fastCover;\n                  /* Allow optional arguments following an = */\n                  if (*argument == 0) { memset(&fastCoverParams, 0, sizeof(fastCoverParams)); }\n                  else if (*argument++ != '=') { badusage(programName); CLEAN_RETURN(1); }\n                  else if (!parseFastCoverParameters(argument, &fastCoverParams)) { badusage(programName); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&argument, \"--train-legacy\")) {\n                  operation = zom_train;\n                  if (outFileName == NULL)\n                      outFileName = g_defaultDictName;\n                  dict = legacy;\n                  /* Allow optional arguments following an = */\n                  if (*argument == 0) { continue; }\n                  else if (*argument++ != '=') { badusage(programName); CLEAN_RETURN(1); }\n                  else if (!parseLegacyParameters(argument, &dictSelect)) { badusage(programName); CLEAN_RETURN(1); }\n                  continue;\n                }\n#endif\n                if (longCommandWArg(&argument, \"--threads\")) { NEXT_UINT32(nbWorkers); continue; }\n                if (longCommandWArg(&argument, \"--memlimit\")) { NEXT_UINT32(memLimit); continue; }\n                if (longCommandWArg(&argument, \"--memory\")) { NEXT_UINT32(memLimit); continue; }\n                if (longCommandWArg(&argument, \"--memlimit-decompress\")) { NEXT_UINT32(memLimit); continue; }\n                if (longCommandWArg(&argument, \"--block-size=\")) { blockSize = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--maxdict\")) { NEXT_UINT32(maxDictSize); continue; }\n                if (longCommandWArg(&argument, \"--dictID\")) { NEXT_UINT32(dictID); continue; }\n                if (longCommandWArg(&argument, \"--zstd=\")) { if (!parseCompressionParameters(argument, &compressionParams)) { badusage(programName); CLEAN_RETURN(1); } continue; }\n                if (longCommandWArg(&argument, \"--stream-size=\")) { streamSrcSize = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--target-compressed-block-size=\")) { targetCBlockSize = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--size-hint=\")) { srcSizeHint = readSizeTFromChar(&argument); continue; }\n                if (longCommandWArg(&argument, \"--output-dir-flat\")) {\n                    NEXT_FIELD(outDirName);\n                    if (strlen(outDirName) == 0) {\n                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");\n                        CLEAN_RETURN(1);\n                    }\n                    continue;\n                }\n                if (longCommandWArg(&argument, \"--auto-threads\")) {\n                    const char* threadDefault = NULL;\n                    NEXT_FIELD(threadDefault);\n                    if (strcmp(threadDefault, \"logical\") == 0)\n                        defaultLogicalCores = 1;\n                    continue;\n                }\n#ifdef UTIL_HAS_MIRRORFILELIST\n                if (longCommandWArg(&argument, \"--output-dir-mirror\")) {\n                    NEXT_FIELD(outMirroredDirName);\n                    if (strlen(outMirroredDirName) == 0) {\n                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");\n                        CLEAN_RETURN(1);\n                    }\n                    continue;\n                }\n#endif\n#ifndef ZSTD_NOTRACE\n                if (longCommandWArg(&argument, \"--trace\")) { char const* traceFile; NEXT_FIELD(traceFile); TRACE_enable(traceFile); continue; }\n#endif\n                if (longCommandWArg(&argument, \"--patch-from\")) { NEXT_FIELD(patchFromDictFileName); continue; }\n                if (longCommandWArg(&argument, \"--long\")) {\n                    unsigned ldmWindowLog = 0;\n                    ldmFlag = 1;\n                    /* Parse optional window log */\n                    if (*argument == '=') {\n                        ++argument;\n                        ldmWindowLog = readU32FromChar(&argument);\n                    } else if (*argument != 0) {\n                        /* Invalid character following --long */\n                        badusage(programName);\n                        CLEAN_RETURN(1);\n                    }\n                    /* Only set windowLog if not already set by --zstd */\n                    if (compressionParams.windowLog == 0)\n                        compressionParams.windowLog = ldmWindowLog;\n                    continue;\n                }\n#ifndef ZSTD_NOCOMPRESS   /* linking ZSTD_minCLevel() requires compression support */\n                if (longCommandWArg(&argument, \"--fast\")) {\n                    /* Parse optional acceleration factor */\n                    if (*argument == '=') {\n                        U32 const maxFast = (U32)-ZSTD_minCLevel();\n                        U32 fastLevel;\n                        ++argument;\n                        fastLevel = readU32FromChar(&argument);\n                        if (fastLevel > maxFast) fastLevel = maxFast;\n                        if (fastLevel) {\n                            dictCLevel = cLevel = -(int)fastLevel;\n                        } else {\n                            badusage(programName);\n                            CLEAN_RETURN(1);\n                        }\n                    } else if (*argument != 0) {\n                        /* Invalid character following --fast */\n                        badusage(programName);\n                        CLEAN_RETURN(1);\n                    } else {\n                        cLevel = -1;  /* default for --fast */\n                    }\n                    continue;\n                }\n#endif\n\n                if (longCommandWArg(&argument, \"--filelist\")) {\n                    const char* listName;\n                    NEXT_FIELD(listName);\n                    UTIL_refFilename(file_of_names, listName);\n                    continue;\n                }\n\n                /* fall-through, will trigger bad_usage() later on */\n            }\n\n            argument++;\n            while (argument[0]!=0) {\n\n#ifndef ZSTD_NOCOMPRESS\n                /* compression Level */\n                if ((*argument>='0') && (*argument<='9')) {\n                    dictCLevel = cLevel = (int)readU32FromChar(&argument);\n                    continue;\n                }\n#endif\n\n                switch(argument[0])\n                {\n                    /* Display help */\n                case 'V': printVersion(); CLEAN_RETURN(0);   /* Version Only */\n                case 'H': usage_advanced(programName); CLEAN_RETURN(0);\n                case 'h': usage(stdout, programName); CLEAN_RETURN(0);\n\n                     /* Compress */\n                case 'z': operation=zom_compress; argument++; break;\n\n                     /* Decoding */\n                case 'd':\n#ifndef ZSTD_NOBENCH\n                        benchParams.mode = BMK_decodeOnly;\n                        if (operation==zom_bench) { argument++; break; }  /* benchmark decode (hidden option) */\n#endif\n                        operation=zom_decompress; argument++; break;\n\n                    /* Force stdout, even if stdout==console */\n                case 'c': forceStdout=1; outFileName=stdoutmark; FIO_setRemoveSrcFile(prefs, 0); argument++; break;\n\n                    /* do not store filename - gzip compatibility - nothing to do */\n                case 'n': argument++; break;\n\n                    /* Use file content as dictionary */\n                case 'D': argument++; NEXT_FIELD(dictFileName); break;\n\n                    /* Overwrite */\n                case 'f': FIO_overwriteMode(prefs); forceStdin=1; forceStdout=1; followLinks=1; allowBlockDevices=1; argument++; break;\n\n                    /* Verbose mode */\n                case 'v': g_displayLevel++; argument++; break;\n\n                    /* Quiet mode */\n                case 'q': g_displayLevel--; argument++; break;\n\n                    /* keep source file (default) */\n                case 'k': FIO_setRemoveSrcFile(prefs, 0); argument++; break;\n\n                    /* Checksum */\n                case 'C': FIO_setChecksumFlag(prefs, 2); argument++; break;\n\n                    /* test compressed file */\n                case 't': operation=zom_test; argument++; break;\n\n                    /* destination file name */\n                case 'o': argument++; NEXT_FIELD(outFileName); break;\n\n                    /* limit memory */\n                case 'M':\n                    argument++;\n                    memLimit = readU32FromChar(&argument);\n                    break;\n                case 'l': operation=zom_list; argument++; break;\n#ifdef UTIL_HAS_CREATEFILELIST\n                    /* recursive */\n                case 'r': recursive=1; argument++; break;\n#endif\n\n#ifndef ZSTD_NOBENCH\n                    /* Benchmark */\n                case 'b':\n                    operation=zom_bench;\n                    argument++;\n                    break;\n\n                    /* range bench (benchmark only) */\n                case 'e':\n                    /* compression Level */\n                    argument++;\n                    cLevelLast = (int)readU32FromChar(&argument);\n                    break;\n\n                    /* Modify Nb Iterations (benchmark only) */\n                case 'i':\n                    argument++;\n                    bench_nbSeconds = readU32FromChar(&argument);\n                    break;\n\n                    /* cut input into blocks (benchmark only) */\n                case 'B':\n                    argument++;\n                    blockSize = readU32FromChar(&argument);\n                    break;\n\n                    /* benchmark files separately (hidden option) */\n                case 'S':\n                    argument++;\n                    separateFiles = 1;\n                    break;\n\n#endif   /* ZSTD_NOBENCH */\n\n                    /* nb of threads (hidden option) */\n                case 'T':\n                    argument++;\n                    nbWorkers = (int)readU32FromChar(&argument);\n                    break;\n\n                    /* Dictionary Selection level */\n                case 's':\n                    argument++;\n                    dictSelect = readU32FromChar(&argument);\n                    break;\n\n                    /* Pause at the end (-p) or set an additional param (-p#) (hidden option) */\n                case 'p': argument++;\n#ifndef ZSTD_NOBENCH\n                    if ((*argument>='0') && (*argument<='9')) {\n                        benchParams.additionalParam = (int)readU32FromChar(&argument);\n                    } else\n#endif\n                        main_pause=1;\n                    break;\n\n                    /* Select compressibility of synthetic sample */\n                case 'P':\n                    argument++;\n                    compressibility = (double)readU32FromChar(&argument) / 100;\n                    break;\n\n                    /* unknown command */\n                default : badusage(programName); CLEAN_RETURN(1);\n                }\n            }\n            continue;\n        }   /* if (argument[0]=='-') */\n\n        /* none of the above : add filename to list */\n        UTIL_refFilename(filenames, argument);\n    }\n\n    /* Welcome message (if verbose) */\n    DISPLAYLEVEL(3, WELCOME_MESSAGE);\n\n#ifdef ZSTD_MULTITHREAD\n    if ((nbWorkers==0) && (!singleThread)) {\n        /* automatically set # workers based on # of reported cpus */\n        if (defaultLogicalCores) {\n            nbWorkers = UTIL_countLogicalCores();\n            DISPLAYLEVEL(3, \"Note: %d logical core(s) detected \\n\", nbWorkers);\n        } else {\n            nbWorkers = UTIL_countPhysicalCores();\n            DISPLAYLEVEL(3, \"Note: %d physical core(s) detected \\n\", nbWorkers);\n        }\n    }\n#else\n    (void)singleThread; (void)nbWorkers; (void)defaultLogicalCores;\n#endif\n\n    g_utilDisplayLevel = g_displayLevel;\n\n#ifdef UTIL_HAS_CREATEFILELIST\n    if (!followLinks) {\n        unsigned u, fileNamesNb;\n        unsigned const nbFilenames = (unsigned)filenames->tableSize;\n        for (u=0, fileNamesNb=0; u<nbFilenames; u++) {\n            if ( UTIL_isLink(filenames->fileNames[u])\n             && !UTIL_isFIFO(filenames->fileNames[u])\n            ) {\n                DISPLAYLEVEL(2, \"Warning : %s is a symbolic link, ignoring \\n\", filenames->fileNames[u]);\n            } else {\n                filenames->fileNames[fileNamesNb++] = filenames->fileNames[u];\n        }   }\n        if (fileNamesNb == 0 && nbFilenames > 0)  /* all names are eliminated */\n            CLEAN_RETURN(1);\n        filenames->tableSize = fileNamesNb;\n    }   /* if (!followLinks) */\n\n    /* read names from a file */\n    if (file_of_names->tableSize) {\n        size_t const nbFileLists = file_of_names->tableSize;\n        size_t flNb;\n        for (flNb=0; flNb < nbFileLists; flNb++) {\n            FileNamesTable* const fnt = UTIL_createFileNamesTable_fromFileName(file_of_names->fileNames[flNb]);\n            if (fnt==NULL) {\n                DISPLAYLEVEL(1, \"zstd: error reading %s \\n\", file_of_names->fileNames[flNb]);\n                CLEAN_RETURN(1);\n            }\n            filenames = UTIL_mergeFileNamesTable(filenames, fnt);\n        }\n    }\n\n    nbInputFileNames = filenames->tableSize; /* saving number of input files */\n\n    if (recursive) {  /* at this stage, filenameTable is a list of paths, which can contain both files and directories */\n        UTIL_expandFNT(&filenames, followLinks);\n    }\n#else\n    (void)followLinks;\n#endif\n\n    if (operation == zom_list) {\n#ifndef ZSTD_NODECOMPRESS\n        int const ret = FIO_listMultipleFiles((unsigned)filenames->tableSize, filenames->fileNames, g_displayLevel);\n        CLEAN_RETURN(ret);\n#else\n        DISPLAY(\"file information is not supported \\n\");\n        CLEAN_RETURN(1);\n#endif\n    }\n\n    /* Check if benchmark is selected */\n    if (operation==zom_bench) {\n#ifndef ZSTD_NOBENCH\n        benchParams.blockSize = blockSize;\n        benchParams.nbWorkers = nbWorkers;\n        benchParams.realTime = (unsigned)setRealTimePrio;\n        benchParams.nbSeconds = bench_nbSeconds;\n        benchParams.ldmFlag = ldmFlag;\n        benchParams.ldmMinMatch = (int)g_ldmMinMatch;\n        benchParams.ldmHashLog = (int)g_ldmHashLog;\n        benchParams.useRowMatchFinder = useRowMatchFinder;\n        if (g_ldmBucketSizeLog != LDM_PARAM_DEFAULT) {\n            benchParams.ldmBucketSizeLog = (int)g_ldmBucketSizeLog;\n        }\n        if (g_ldmHashRateLog != LDM_PARAM_DEFAULT) {\n            benchParams.ldmHashRateLog = (int)g_ldmHashRateLog;\n        }\n        benchParams.literalCompressionMode = literalCompressionMode;\n\n        if (cLevel > ZSTD_maxCLevel()) cLevel = ZSTD_maxCLevel();\n        if (cLevelLast > ZSTD_maxCLevel()) cLevelLast = ZSTD_maxCLevel();\n        if (cLevelLast < cLevel) cLevelLast = cLevel;\n        if (cLevelLast > cLevel)\n            DISPLAYLEVEL(3, \"Benchmarking levels from %d to %d\\n\", cLevel, cLevelLast);\n        if (filenames->tableSize > 0) {\n            if(separateFiles) {\n                unsigned i;\n                for(i = 0; i < filenames->tableSize; i++) {\n                    int c;\n                    DISPLAYLEVEL(3, \"Benchmarking %s \\n\", filenames->fileNames[i]);\n                    for(c = cLevel; c <= cLevelLast; c++) {\n                        BMK_benchFilesAdvanced(&filenames->fileNames[i], 1, dictFileName, c, &compressionParams, g_displayLevel, &benchParams);\n                }   }\n            } else {\n                for(; cLevel <= cLevelLast; cLevel++) {\n                    BMK_benchFilesAdvanced(filenames->fileNames, (unsigned)filenames->tableSize, dictFileName, cLevel, &compressionParams, g_displayLevel, &benchParams);\n            }   }\n        } else {\n            for(; cLevel <= cLevelLast; cLevel++) {\n                BMK_syntheticTest(cLevel, compressibility, &compressionParams, g_displayLevel, &benchParams);\n        }   }\n\n#else\n        (void)bench_nbSeconds; (void)blockSize; (void)setRealTimePrio; (void)separateFiles; (void)compressibility;\n#endif\n        goto _end;\n    }\n\n    /* Check if dictionary builder is selected */\n    if (operation==zom_train) {\n#ifndef ZSTD_NODICT\n        ZDICT_params_t zParams;\n        zParams.compressionLevel = dictCLevel;\n        zParams.notificationLevel = (unsigned)g_displayLevel;\n        zParams.dictID = dictID;\n        if (dict == cover) {\n            int const optimize = !coverParams.k || !coverParams.d;\n            coverParams.nbThreads = (unsigned)nbWorkers;\n            coverParams.zParams = zParams;\n            operationResult = DiB_trainFromFiles(outFileName, maxDictSize, filenames->fileNames, (int)filenames->tableSize, blockSize, NULL, &coverParams, NULL, optimize, memLimit);\n        } else if (dict == fastCover) {\n            int const optimize = !fastCoverParams.k || !fastCoverParams.d;\n            fastCoverParams.nbThreads = (unsigned)nbWorkers;\n            fastCoverParams.zParams = zParams;\n            operationResult = DiB_trainFromFiles(outFileName, maxDictSize, filenames->fileNames, (int)filenames->tableSize, blockSize, NULL, NULL, &fastCoverParams, optimize, memLimit);\n        } else {\n            ZDICT_legacy_params_t dictParams;\n            memset(&dictParams, 0, sizeof(dictParams));\n            dictParams.selectivityLevel = dictSelect;\n            dictParams.zParams = zParams;\n            operationResult = DiB_trainFromFiles(outFileName, maxDictSize, filenames->fileNames, (int)filenames->tableSize, blockSize, &dictParams, NULL, NULL, 0, memLimit);\n        }\n#else\n        (void)dictCLevel; (void)dictSelect; (void)dictID;  (void)maxDictSize; /* not used when ZSTD_NODICT set */\n        DISPLAYLEVEL(1, \"training mode not available \\n\");\n        operationResult = 1;\n#endif\n        goto _end;\n    }\n\n#ifndef ZSTD_NODECOMPRESS\n    if (operation==zom_test) { FIO_setTestMode(prefs, 1); outFileName=nulmark; FIO_setRemoveSrcFile(prefs, 0); }  /* test mode */\n#endif\n\n    /* No input filename ==> use stdin and stdout */\n    if (filenames->tableSize == 0) {\n      /* It is possible that the input\n       was a number of empty directories. In this case\n       stdin and stdout should not be used */\n       if (nbInputFileNames > 0 ){\n        DISPLAYLEVEL(1, \"please provide correct input file(s) or non-empty directories -- ignored \\n\");\n        CLEAN_RETURN(0);\n       }\n       UTIL_refFilename(filenames, stdinmark);\n    }\n\n    if (!strcmp(filenames->fileNames[0], stdinmark) && !outFileName)\n        outFileName = stdoutmark;  /* when input is stdin, default output is stdout */\n\n    /* Check if input/output defined as console; trigger an error in this case */\n    if (!forceStdin\n     && !strcmp(filenames->fileNames[0], stdinmark)\n     && IS_CONSOLE(stdin) ) {\n        DISPLAYLEVEL(1, \"stdin is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n    if ( outFileName && !strcmp(outFileName, stdoutmark)\n      && IS_CONSOLE(stdout)\n      && !strcmp(filenames->fileNames[0], stdinmark)\n      && !forceStdout\n      && operation!=zom_decompress ) {\n        DISPLAYLEVEL(1, \"stdout is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n\n#ifndef ZSTD_NOCOMPRESS\n    /* check compression level limits */\n    {   int const maxCLevel = ultra ? ZSTD_maxCLevel() : ZSTDCLI_CLEVEL_MAX;\n        if (cLevel > maxCLevel) {\n            DISPLAYLEVEL(2, \"Warning : compression level higher than max, reduced to %i \\n\", maxCLevel);\n            cLevel = maxCLevel;\n    }   }\n#endif\n\n    if (showDefaultCParams) {\n        if (operation == zom_decompress) {\n            DISPLAY(\"error : can't use --show-default-cparams in decompression mode \\n\");\n            CLEAN_RETURN(1);\n        }\n    }\n\n    if (dictFileName != NULL && patchFromDictFileName != NULL) {\n        DISPLAY(\"error : can't use -D and --patch-from=# at the same time \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    if (patchFromDictFileName != NULL && filenames->tableSize > 1) {\n        DISPLAY(\"error : can't use --patch-from=# on multiple files \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    /* No status message in pipe mode (stdin - stdout) */\n    hasStdout = outFileName && !strcmp(outFileName,stdoutmark);\n\n    if ((hasStdout || !IS_CONSOLE(stderr)) && (g_displayLevel==2)) g_displayLevel=1;\n\n    /* IO Stream/File */\n    FIO_setHasStdoutOutput(fCtx, hasStdout);\n    FIO_setNbFilesTotal(fCtx, (int)filenames->tableSize);\n    FIO_determineHasStdinInput(fCtx, filenames);\n    FIO_setNotificationLevel(g_displayLevel);\n    FIO_setAllowBlockDevices(prefs, allowBlockDevices);\n    FIO_setPatchFromMode(prefs, patchFromDictFileName != NULL);\n    if (memLimit == 0) {\n        if (compressionParams.windowLog == 0) {\n            memLimit = (U32)1 << g_defaultMaxWindowLog;\n        } else {\n            memLimit = (U32)1 << (compressionParams.windowLog & 31);\n    }   }\n    if (patchFromDictFileName != NULL)\n        dictFileName = patchFromDictFileName;\n    FIO_setMemLimit(prefs, memLimit);\n    if (operation==zom_compress) {\n#ifndef ZSTD_NOCOMPRESS\n        FIO_setContentSize(prefs, contentSize);\n        FIO_setNbWorkers(prefs, nbWorkers);\n        FIO_setBlockSize(prefs, (int)blockSize);\n        if (g_overlapLog!=OVERLAP_LOG_DEFAULT) FIO_setOverlapLog(prefs, (int)g_overlapLog);\n        FIO_setLdmFlag(prefs, (unsigned)ldmFlag);\n        FIO_setLdmHashLog(prefs, (int)g_ldmHashLog);\n        FIO_setLdmMinMatch(prefs, (int)g_ldmMinMatch);\n        if (g_ldmBucketSizeLog != LDM_PARAM_DEFAULT) FIO_setLdmBucketSizeLog(prefs, (int)g_ldmBucketSizeLog);\n        if (g_ldmHashRateLog != LDM_PARAM_DEFAULT) FIO_setLdmHashRateLog(prefs, (int)g_ldmHashRateLog);\n        FIO_setAdaptiveMode(prefs, (unsigned)adapt);\n        FIO_setUseRowMatchFinder(prefs, useRowMatchFinder);\n        FIO_setAdaptMin(prefs, adaptMin);\n        FIO_setAdaptMax(prefs, adaptMax);\n        FIO_setRsyncable(prefs, rsyncable);\n        FIO_setStreamSrcSize(prefs, streamSrcSize);\n        FIO_setTargetCBlockSize(prefs, targetCBlockSize);\n        FIO_setSrcSizeHint(prefs, srcSizeHint);\n        FIO_setLiteralCompressionMode(prefs, literalCompressionMode);\n        FIO_setSparseWrite(prefs, 0);\n        if (adaptMin > cLevel) cLevel = adaptMin;\n        if (adaptMax < cLevel) cLevel = adaptMax;\n\n        /* Compare strategies constant with the ground truth */\n        { ZSTD_bounds strategyBounds = ZSTD_cParam_getBounds(ZSTD_c_strategy);\n          assert(ZSTD_NB_STRATEGIES == strategyBounds.upperBound);\n          (void)strategyBounds; }\n\n        if (showDefaultCParams || g_displayLevel >= 4) {\n            size_t fileNb;\n            for (fileNb = 0; fileNb < (size_t)filenames->tableSize; fileNb++) {\n                if (showDefaultCParams)\n                    printDefaultCParams(filenames->fileNames[fileNb], dictFileName, cLevel);\n                if (g_displayLevel >= 4)\n                    printActualCParams(filenames->fileNames[fileNb], dictFileName, cLevel, &compressionParams);\n            }\n        }\n\n        if (g_displayLevel >= 4)\n            FIO_displayCompressionParameters(prefs);\n        if ((filenames->tableSize==1) && outFileName)\n            operationResult = FIO_compressFilename(fCtx, prefs, outFileName, filenames->fileNames[0], dictFileName, cLevel, compressionParams);\n        else\n            operationResult = FIO_compressMultipleFilenames(fCtx, prefs, filenames->fileNames, outMirroredDirName, outDirName, outFileName, suffix, dictFileName, cLevel, compressionParams);\n#else\n        (void)contentSize; (void)suffix; (void)adapt; (void)rsyncable; (void)ultra; (void)cLevel; (void)ldmFlag; (void)literalCompressionMode; (void)targetCBlockSize; (void)streamSrcSize; (void)srcSizeHint; (void)ZSTD_strategyMap; (void)useRowMatchFinder; /* not used when ZSTD_NOCOMPRESS set */\n        DISPLAY(\"Compression not supported \\n\");\n#endif\n    } else {  /* decompression or test */\n#ifndef ZSTD_NODECOMPRESS\n        if (filenames->tableSize == 1 && outFileName) {\n            operationResult = FIO_decompressFilename(fCtx, prefs, outFileName, filenames->fileNames[0], dictFileName);\n        } else {\n            operationResult = FIO_decompressMultipleFilenames(fCtx, prefs, filenames->fileNames, outMirroredDirName, outDirName, outFileName, dictFileName);\n        }\n#else\n        DISPLAY(\"Decompression not supported \\n\");\n#endif\n    }\n\n_end:\n    FIO_freePreferences(prefs);\n    FIO_freeContext(fCtx);\n    if (main_pause) waitEnter();\n    UTIL_freeFileNamesTable(filenames);\n    UTIL_freeFileNamesTable(file_of_names);\n#ifndef ZSTD_NOTRACE\n    TRACE_finish();\n#endif\n\n    return operationResult;\n}",
  "abstract_func": "int main(int VAR_0, const char* VAR_1[])\n{\n    int VAR_2,\n        VAR_3 = 0,\n        VAR_4 = 0,\n        VAR_5 = 0,\n        VAR_6 = 0,\n        VAR_7 = 0,\n        VAR_8 = 0,\n        VAR_9 = 0,\n        VAR_10 = 0,\n        VAR_11 = 0,\n        VAR_12 = 0,\n        VAR_13 = VAR_14,\n        VAR_15 = VAR_16,\n        VAR_17 = 0,\n        VAR_18 = 0,\n        VAR_19 = 0,\n        VAR_20 = 0,\n        VAR_21 = 0,\n        VAR_22 = 0,\n        VAR_23 = 0,\n        VAR_24 = 0,\n        VAR_25=0,\n        VAR_26=1;\n    double VAR_27 = 0.5;\n    unsigned VAR_28 = 3;   /* COMMENT_0 */\n    size_t VAR_29 = 0;\n\n    FIO_prefs_t* const VAR_30 = FIO_createPreferences();\n    FIO_ctx_t* const VAR_31 = FIO_createContext();\n    zstd_operation_mode VAR_32 = VAR_33;\n    ZSTD_compressionParameters VAR_34;\n    int VAR_35 = init_cLevel();\n    int VAR_36 = VAR_14 - 1;  /* COMMENT_1 */\n    unsigned VAR_37 = 0;\n    unsigned VAR_38 = 0;\n    FileNamesTable* VAR_39 = UTIL_allocateFileNamesTable((size_t)VAR_0);  /* COMMENT_2 */\n    FileNamesTable* VAR_40 = UTIL_allocateFileNamesTable((size_t)VAR_0);  /* COMMENT_2 */\n    const char* VAR_41 = VAR_1[0];\n    const char* VAR_42 = NULL;\n    const char* VAR_43 = NULL;\n    const char* VAR_44 = NULL;\n    const char* VAR_45 = NULL;\n    const char* VAR_46 = NULL;\n    const char* VAR_47 = VAR_48;\n    unsigned VAR_49 = VAR_50;\n    unsigned VAR_51 = 0;\n    size_t VAR_52 = 0;\n    size_t VAR_53 = 0;\n    size_t VAR_54 = 0;\n    size_t VAR_55 = 0;\n    int VAR_56 = VAR_57;\n    unsigned VAR_58 = VAR_59;\n#ifndef VAR_60\n    ZDICT_cover_params_t VAR_61 = defaultCoverParams();\n    ZDICT_fastCover_params_t VAR_62 = defaultFastCoverParams();\n    dictType VAR_63 = VAR_64;\n#endif\n#ifndef VAR_65\n    BMK_advancedParams_t VAR_66 = BMK_initAdvancedParams();\n#endif\n    ZSTD_paramSwitch_e VAR_67 = VAR_68;\n\n\n    /* COMMENT_3 */\n    checkLibVersion();\n    (void)VAR_37; (void)VAR_36;    /* COMMENT_4 */\n    (void)VAR_38;\n    assert(VAR_0 >= 1);\n    if ((VAR_39==NULL) || (VAR_40==NULL)) { DISPLAY(\"zstd: allocation error \\n\"); exit(1); }\n    VAR_41 = lastNameFromPath(VAR_41);\n#ifdef VAR_69\n    VAR_10 = init_nbThreads();\n#endif\n\n    /* COMMENT_5 */\n    if (exeNameMatch(VAR_41, VAR_70)) VAR_10=0, VAR_22=0;\n    if (exeNameMatch(VAR_41, VAR_71)) VAR_32=VAR_72;\n    if (exeNameMatch(VAR_41, VAR_73)) { VAR_32=VAR_72; FIO_overwriteMode(VAR_30); VAR_6=1; VAR_3=1; VAR_42=VAR_74; VAR_75=1; }     /* COMMENT_6 */\n    if (exeNameMatch(VAR_41, VAR_76)) { VAR_32=VAR_72; FIO_overwriteMode(VAR_30); VAR_6=1; VAR_3=1; VAR_42=VAR_74; VAR_75=1; }    /* COMMENT_7 */\n    if (exeNameMatch(VAR_41, VAR_77)) {   /* COMMENT_8 */\n        VAR_47 = VAR_78; FIO_setCompressionType(VAR_30, VAR_79); FIO_setRemoveSrcFile(VAR_30, 1);\n        VAR_56 = VAR_35 = 6;  /* COMMENT_9 */\n    }\n    if (exeNameMatch(VAR_41, VAR_80)) { VAR_32=VAR_72; FIO_setRemoveSrcFile(VAR_30, 1); }                                                     /* COMMENT_10 */\n    if (exeNameMatch(VAR_41, VAR_81)) { VAR_32=VAR_72; FIO_overwriteMode(VAR_30); VAR_6=1; VAR_3=1; VAR_42=VAR_74; VAR_75=1; }   /* COMMENT_11 */\n    if (exeNameMatch(VAR_41, VAR_82)) { VAR_47 = VAR_83; FIO_setCompressionType(VAR_30, VAR_84); FIO_setRemoveSrcFile(VAR_30, 1); }    /* COMMENT_12 */\n    if (exeNameMatch(VAR_41, VAR_85)) { VAR_32=VAR_72; FIO_setCompressionType(VAR_30, VAR_84); FIO_setRemoveSrcFile(VAR_30, 1); } /* COMMENT_13 */\n    if (exeNameMatch(VAR_41, VAR_86)) { VAR_47 = VAR_87; FIO_setCompressionType(VAR_30, VAR_88); FIO_setRemoveSrcFile(VAR_30, 1); }          /* COMMENT_14 */\n    if (exeNameMatch(VAR_41, VAR_89)) { VAR_32=VAR_72; FIO_setCompressionType(VAR_30, VAR_88); FIO_setRemoveSrcFile(VAR_30, 1); }     /* COMMENT_15 */\n    if (exeNameMatch(VAR_41, VAR_90)) { VAR_47 = VAR_91; FIO_setCompressionType(VAR_30, VAR_92); }                                       /* COMMENT_16 */\n    if (exeNameMatch(VAR_41, VAR_93)) { VAR_32=VAR_72; FIO_setCompressionType(VAR_30, VAR_92); }                                   /* COMMENT_17 */\n    memset(&VAR_34, 0, sizeof(VAR_34));\n\n    /* COMMENT_18 */\n    FIO_addAbortHandler();\n\n    /* COMMENT_19 */\n    for (VAR_2=1; VAR_2<VAR_0; VAR_2++) {\n        const char* VAR_94 = VAR_1[VAR_2];\n        if (!VAR_94) continue;   /* COMMENT_20 */\n\n        if (VAR_18) {\n            UTIL_refFilename(VAR_39, VAR_94);\n            continue;\n        }\n\n        /* COMMENT_21 */\n        if (!strcmp(VAR_94, \"-\")){\n            UTIL_refFilename(VAR_39, VAR_95);\n            continue;\n        }\n\n        /* COMMENT_22 */\n        if (VAR_94[0]=='-') {\n\n            if (VAR_94[1]=='-') {\n                /* COMMENT_23 */\n                if (!strcmp(VAR_94, \"--\")) { VAR_18=1; continue; }   /* COMMENT_24 */\n                if (!strcmp(VAR_94, \"--list\")) { VAR_32=VAR_96; continue; }\n                if (!strcmp(VAR_94, \"--compress\")) { VAR_32=VAR_33; continue; }\n                if (!strcmp(VAR_94, \"--decompress\")) { VAR_32=VAR_72; continue; }\n                if (!strcmp(VAR_94, \"--uncompress\")) { VAR_32=VAR_72; continue; }\n                if (!strcmp(VAR_94, \"--force\")) { FIO_overwriteMode(VAR_30); VAR_5=1; VAR_6=1; VAR_3=1; VAR_4=1; continue; }\n                if (!strcmp(VAR_94, \"--version\")) { printVersion(); CLEAN_RETURN(0); }\n                if (!strcmp(VAR_94, \"--help\")) { usage_advanced(VAR_41); CLEAN_RETURN(0); }\n                if (!strcmp(VAR_94, \"--verbose\")) { VAR_75++; continue; }\n                if (!strcmp(VAR_94, \"--quiet\")) { VAR_75--; continue; }\n                if (!strcmp(VAR_94, \"--stdout\")) { VAR_6=1; VAR_42=VAR_74; FIO_setRemoveSrcFile(VAR_30, 0); VAR_75-=(VAR_75==2); continue; }\n                if (!strcmp(VAR_94, \"--ultra\")) { VAR_25=1; continue; }\n                if (!strcmp(VAR_94, \"--check\")) { FIO_setChecksumFlag(VAR_30, 2); continue; }\n                if (!strcmp(VAR_94, \"--no-check\")) { FIO_setChecksumFlag(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--sparse\")) { FIO_setSparseWrite(VAR_30, 2); continue; }\n                if (!strcmp(VAR_94, \"--no-sparse\")) { FIO_setSparseWrite(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--test\")) { VAR_32=VAR_97; continue; }\n                if (!strcmp(VAR_94, \"--asyncio\")) { FIO_setAsyncIOFlag(VAR_30, 1); continue;}\n                if (!strcmp(VAR_94, \"--no-asyncio\")) { FIO_setAsyncIOFlag(VAR_30, 0); continue;}\n                if (!strcmp(VAR_94, \"--train\")) { VAR_32=VAR_98; if (VAR_42==NULL) VAR_42=VAR_99; continue; }\n                if (!strcmp(VAR_94, \"--no-dictID\")) { FIO_setDictIDFlag(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--keep\")) { FIO_setRemoveSrcFile(VAR_30, 0); continue; }\n                if (!strcmp(VAR_94, \"--rm\")) { FIO_setRemoveSrcFile(VAR_30, 1); continue; }\n                if (!strcmp(VAR_94, \"--priority=rt\")) { VAR_21 = 1; continue; }\n                if (!strcmp(VAR_94, \"--show-default-cparams\")) { VAR_24 = 1; continue; }\n                if (!strcmp(VAR_94, \"--content-size\")) { VAR_26 = 1; continue; }\n                if (!strcmp(VAR_94, \"--no-content-size\")) { VAR_26 = 0; continue; }\n                if (!strcmp(VAR_94, \"--adapt\")) { VAR_11 = 1; continue; }\n                if (!strcmp(VAR_94, \"--no-row-match-finder\")) { VAR_12 = 1; continue; }\n                if (!strcmp(VAR_94, \"--row-match-finder\")) { VAR_12 = 2; continue; }\n                if (longCommandWArg(&VAR_94, \"--adapt=\")) { VAR_11 = 1; if (!parseAdaptParameters(VAR_94, &VAR_13, &VAR_15)) { badusage(VAR_41); CLEAN_RETURN(1); } continue; }\n                if (!strcmp(VAR_94, \"--single-thread\")) { VAR_10 = 0; VAR_22 = 1; continue; }\n                if (!strcmp(VAR_94, \"--format=zstd\")) { VAR_47 = VAR_48; FIO_setCompressionType(VAR_30, VAR_100); continue; }\n#ifdef VAR_101\n                if (!strcmp(VAR_94, \"--format=gzip\")) { VAR_47 = VAR_78; FIO_setCompressionType(VAR_30, VAR_79); continue; }\n                if (exeNameMatch(VAR_41, VAR_77)) {     /* COMMENT_8 */\n                    if (!strcmp(VAR_94, \"--best\")) { VAR_56 = VAR_35 = 9; continue; }\n                    if (!strcmp(VAR_94, \"--no-name\")) { /* COMMENT_25 */; continue; }\n                }\n#endif\n#ifdef VAR_102\n                if (!strcmp(VAR_94, \"--format=lzma\")) { VAR_47 = VAR_83; FIO_setCompressionType(VAR_30, VAR_84);  continue; }\n                if (!strcmp(VAR_94, \"--format=xz\")) { VAR_47 = VAR_87; FIO_setCompressionType(VAR_30, VAR_88);  continue; }\n#endif\n#ifdef VAR_103\n                if (!strcmp(VAR_94, \"--format=lz4\")) { VAR_47 = VAR_91; FIO_setCompressionType(VAR_30, VAR_92);  continue; }\n#endif\n                if (!strcmp(VAR_94, \"--rsyncable\")) { VAR_17 = 1; continue; }\n                if (!strcmp(VAR_94, \"--compress-literals\")) { VAR_67 = VAR_104; continue; }\n                if (!strcmp(VAR_94, \"--no-compress-literals\")) { VAR_67 = VAR_105; continue; }\n                if (!strcmp(VAR_94, \"--no-progress\")) { FIO_setProgressSetting(VAR_106); continue; }\n                if (!strcmp(VAR_94, \"--progress\")) { FIO_setProgressSetting(VAR_107); continue; }\n                if (!strcmp(VAR_94, \"--exclude-compressed\")) { FIO_setExcludeCompressedFile(VAR_30, 1); continue; }\n\n                /* COMMENT_26 */\n#ifndef VAR_60\n                if (longCommandWArg(&VAR_94, \"--train-cover\")) {\n                  VAR_32 = VAR_98;\n                  if (VAR_42 == NULL)\n                      VAR_42 = VAR_99;\n                  VAR_63 = VAR_108;\n                  /* COMMENT_27 */\n                  if (*VAR_94 == 0) { memset(&VAR_61, 0, sizeof(VAR_61)); }\n                  else if (*VAR_94++ != '=') { badusage(VAR_41); CLEAN_RETURN(1); }\n                  else if (!parseCoverParameters(VAR_94, &VAR_61)) { badusage(VAR_41); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&VAR_94, \"--train-fastcover\")) {\n                  VAR_32 = VAR_98;\n                  if (VAR_42 == NULL)\n                      VAR_42 = VAR_99;\n                  VAR_63 = VAR_64;\n                  /* COMMENT_27 */\n                  if (*VAR_94 == 0) { memset(&VAR_62, 0, sizeof(VAR_62)); }\n                  else if (*VAR_94++ != '=') { badusage(VAR_41); CLEAN_RETURN(1); }\n                  else if (!parseFastCoverParameters(VAR_94, &VAR_62)) { badusage(VAR_41); CLEAN_RETURN(1); }\n                  continue;\n                }\n                if (longCommandWArg(&VAR_94, \"--train-legacy\")) {\n                  VAR_32 = VAR_98;\n                  if (VAR_42 == NULL)\n                      VAR_42 = VAR_99;\n                  VAR_63 = VAR_109;\n                  /* COMMENT_27 */\n                  if (*VAR_94 == 0) { continue; }\n                  else if (*VAR_94++ != '=') { badusage(VAR_41); CLEAN_RETURN(1); }\n                  else if (!parseLegacyParameters(VAR_94, &VAR_58)) { badusage(VAR_41); CLEAN_RETURN(1); }\n                  continue;\n                }\n#endif\n                if (longCommandWArg(&VAR_94, \"--threads\")) { NEXT_UINT32(VAR_10); continue; }\n                if (longCommandWArg(&VAR_94, \"--memlimit\")) { NEXT_UINT32(VAR_38); continue; }\n                if (longCommandWArg(&VAR_94, \"--memory\")) { NEXT_UINT32(VAR_38); continue; }\n                if (longCommandWArg(&VAR_94, \"--memlimit-decompress\")) { NEXT_UINT32(VAR_38); continue; }\n                if (longCommandWArg(&VAR_94, \"--block-size=\")) { VAR_29 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--maxdict\")) { NEXT_UINT32(VAR_49); continue; }\n                if (longCommandWArg(&VAR_94, \"--dictID\")) { NEXT_UINT32(VAR_51); continue; }\n                if (longCommandWArg(&VAR_94, \"--zstd=\")) { if (!parseCompressionParameters(VAR_94, &VAR_34)) { badusage(VAR_41); CLEAN_RETURN(1); } continue; }\n                if (longCommandWArg(&VAR_94, \"--stream-size=\")) { VAR_52 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--target-compressed-block-size=\")) { VAR_53 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--size-hint=\")) { VAR_54 = readSizeTFromChar(&VAR_94); continue; }\n                if (longCommandWArg(&VAR_94, \"--output-dir-flat\")) {\n                    NEXT_FIELD(VAR_43);\n                    if (strlen(VAR_43) == 0) {\n                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");\n                        CLEAN_RETURN(1);\n                    }\n                    continue;\n                }\n                if (longCommandWArg(&VAR_94, \"--auto-threads\")) {\n                    const char* VAR_110 = NULL;\n                    NEXT_FIELD(VAR_110);\n                    if (strcmp(VAR_110, \"logical\") == 0)\n                        VAR_23 = 1;\n                    continue;\n                }\n#ifdef VAR_111\n                if (longCommandWArg(&VAR_94, \"--output-dir-mirror\")) {\n                    NEXT_FIELD(VAR_44);\n                    if (strlen(VAR_44) == 0) {\n                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");\n                        CLEAN_RETURN(1);\n                    }\n                    continue;\n                }\n#endif\n#ifndef VAR_112\n                if (longCommandWArg(&VAR_94, \"--trace\")) { char const* VAR_113; NEXT_FIELD(VAR_113); TRACE_enable(VAR_113); continue; }\n#endif\n                if (longCommandWArg(&VAR_94, \"--patch-from\")) { NEXT_FIELD(VAR_46); continue; }\n                if (longCommandWArg(&VAR_94, \"--long\")) {\n                    unsigned VAR_114 = 0;\n                    VAR_8 = 1;\n                    /* COMMENT_28 */\n                    if (*VAR_94 == '=') {\n                        ++VAR_94;\n                        VAR_114 = readU32FromChar(&VAR_94);\n                    } else if (*VAR_94 != 0) {\n                        /* COMMENT_29 */\n                        badusage(VAR_41);\n                        CLEAN_RETURN(1);\n                    }\n                    /* COMMENT_30 */\n                    if (VAR_34.windowLog == 0)\n                        VAR_34.windowLog = VAR_114;\n                    continue;\n                }\n#ifndef VAR_115   /* COMMENT_31 */\n                if (longCommandWArg(&VAR_94, \"--fast\")) {\n                    /* COMMENT_32 */\n                    if (*VAR_94 == '=') {\n                        U32 const VAR_116 = (U32)-ZSTD_minCLevel();\n                        U32 VAR_117;\n                        ++VAR_94;\n                        VAR_117 = readU32FromChar(&VAR_94);\n                        if (VAR_117 > VAR_116) VAR_117 = VAR_116;\n                        if (VAR_117) {\n                            VAR_56 = VAR_35 = -(int)VAR_117;\n                        } else {\n                            badusage(VAR_41);\n                            CLEAN_RETURN(1);\n                        }\n                    } else if (*VAR_94 != 0) {\n                        /* COMMENT_33 */\n                        badusage(VAR_41);\n                        CLEAN_RETURN(1);\n                    } else {\n                        VAR_35 = -1;  /* COMMENT_34 */\n                    }\n                    continue;\n                }\n#endif\n\n                if (longCommandWArg(&VAR_94, \"--filelist\")) {\n                    const char* VAR_118;\n                    NEXT_FIELD(VAR_118);\n                    UTIL_refFilename(VAR_40, VAR_118);\n                    continue;\n                }\n\n                /* COMMENT_35 */\n            }\n\n            VAR_94++;\n            while (VAR_94[0]!=0) {\n\n#ifndef VAR_115\n                /* COMMENT_36 */\n                if ((*VAR_94>='0') && (*VAR_94<='9')) {\n                    VAR_56 = VAR_35 = (int)readU32FromChar(&VAR_94);\n                    continue;\n                }\n#endif\n\n                switch(VAR_94[0])\n                {\n                    /* COMMENT_37 */\n                case 'V': printVersion(); CLEAN_RETURN(0);   /* COMMENT_38 */\n                case 'H': usage_advanced(VAR_41); CLEAN_RETURN(0);\n                case 'h': usage(VAR_119, VAR_41); CLEAN_RETURN(0);\n\n                     /* COMMENT_39 */\n                case 'z': VAR_32=VAR_33; VAR_94++; break;\n\n                     /* COMMENT_40 */\n                case 'd':\n#ifndef VAR_65\n                        VAR_66.mode = VAR_120;\n                        if (VAR_32==VAR_121) { VAR_94++; break; }  /* COMMENT_41 */\n#endif\n                        VAR_32=VAR_72; VAR_94++; break;\n\n                    /* COMMENT_42 */\n                case 'c': VAR_6=1; VAR_42=VAR_74; FIO_setRemoveSrcFile(VAR_30, 0); VAR_94++; break;\n\n                    /* COMMENT_43 */\n                case 'n': VAR_94++; break;\n\n                    /* COMMENT_44 */\n                case 'D': VAR_94++; NEXT_FIELD(VAR_45); break;\n\n                    /* COMMENT_45 */\n                case 'f': FIO_overwriteMode(VAR_30); VAR_5=1; VAR_6=1; VAR_3=1; VAR_4=1; VAR_94++; break;\n\n                    /* COMMENT_46 */\n                case 'v': VAR_75++; VAR_94++; break;\n\n                    /* COMMENT_47 */\n                case 'q': VAR_75--; VAR_94++; break;\n\n                    /* COMMENT_48 */\n                case 'k': FIO_setRemoveSrcFile(VAR_30, 0); VAR_94++; break;\n\n                    /* COMMENT_49 */\n                case 'C': FIO_setChecksumFlag(VAR_30, 2); VAR_94++; break;\n\n                    /* COMMENT_50 */\n                case 't': VAR_32=VAR_97; VAR_94++; break;\n\n                    /* COMMENT_51 */\n                case 'o': VAR_94++; NEXT_FIELD(VAR_42); break;\n\n                    /* COMMENT_52 */\n                case 'M':\n                    VAR_94++;\n                    VAR_38 = readU32FromChar(&VAR_94);\n                    break;\n                case 'l': VAR_32=VAR_96; VAR_94++; break;\n#ifdef VAR_122\n                    /* COMMENT_53 */\n                case 'r': VAR_37=1; VAR_94++; break;\n#endif\n\n#ifndef VAR_65\n                    /* COMMENT_54 */\n                case 'b':\n                    VAR_32=VAR_121;\n                    VAR_94++;\n                    break;\n\n                    /* COMMENT_55 */\n                case 'e':\n                    /* COMMENT_36 */\n                    VAR_94++;\n                    VAR_36 = (int)readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_56 */\n                case 'i':\n                    VAR_94++;\n                    VAR_28 = readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_57 */\n                case 'B':\n                    VAR_94++;\n                    VAR_29 = readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_58 */\n                case 'S':\n                    VAR_94++;\n                    VAR_20 = 1;\n                    break;\n\n#endif   /* COMMENT_59 */\n\n                    /* COMMENT_60 */\n                case 'T':\n                    VAR_94++;\n                    VAR_10 = (int)readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_61 */\n                case 's':\n                    VAR_94++;\n                    VAR_58 = readU32FromChar(&VAR_94);\n                    break;\n\n                    /* COMMENT_62 */\n                case 'p': VAR_94++;\n#ifndef VAR_65\n                    if ((*VAR_94>='0') && (*VAR_94<='9')) {\n                        VAR_66.additionalParam = (int)readU32FromChar(&VAR_94);\n                    } else\n#endif\n                        VAR_9=1;\n                    break;\n\n                    /* COMMENT_63 */\n                case 'P':\n                    VAR_94++;\n                    VAR_27 = (double)readU32FromChar(&VAR_94) / 100;\n                    break;\n\n                    /* COMMENT_64 */\n                default : badusage(VAR_41); CLEAN_RETURN(1);\n                }\n            }\n            continue;\n        }   /* COMMENT_65 */\n\n        /* COMMENT_66 */\n        UTIL_refFilename(VAR_39, VAR_94);\n    }\n\n    /* COMMENT_67 */\n    DISPLAYLEVEL(3, VAR_123);\n\n#ifdef VAR_69\n    if ((VAR_10==0) && (!VAR_22)) {\n        /* COMMENT_68 */\n        if (VAR_23) {\n            VAR_10 = UTIL_countLogicalCores();\n            DISPLAYLEVEL(3, \"Note: %d logical core(s) detected \\n\", VAR_10);\n        } else {\n            VAR_10 = UTIL_countPhysicalCores();\n            DISPLAYLEVEL(3, \"Note: %d physical core(s) detected \\n\", VAR_10);\n        }\n    }\n#else\n    (void)VAR_22; (void)VAR_10; (void)VAR_23;\n#endif\n\n    VAR_124 = VAR_75;\n\n#ifdef VAR_122\n    if (!VAR_3) {\n        unsigned VAR_125, VAR_126;\n        unsigned const VAR_127 = (unsigned)VAR_39->tableSize;\n        for (VAR_125=0, VAR_126=0; VAR_125<VAR_127; VAR_125++) {\n            if ( UTIL_isLink(VAR_39->fileNames[VAR_125])\n             && !UTIL_isFIFO(VAR_39->fileNames[VAR_125])\n            ) {\n                DISPLAYLEVEL(2, \"Warning : %s is a symbolic link, ignoring \\n\", VAR_39->fileNames[VAR_125]);\n            } else {\n                VAR_39->fileNames[VAR_126++] = VAR_39->fileNames[VAR_125];\n        }   }\n        if (VAR_126 == 0 && VAR_127 > 0)  /* COMMENT_69 */\n            CLEAN_RETURN(1);\n        VAR_39->tableSize = VAR_126;\n    }   /* COMMENT_70 */\n\n    /* COMMENT_71 */\n    if (VAR_40->tableSize) {\n        size_t const VAR_128 = VAR_40->tableSize;\n        size_t VAR_129;\n        for (VAR_129=0; VAR_129 < VAR_128; VAR_129++) {\n            FileNamesTable* const VAR_130 = UTIL_createFileNamesTable_fromFileName(VAR_40->fileNames[VAR_129]);\n            if (VAR_130==NULL) {\n                DISPLAYLEVEL(1, \"zstd: error reading %s \\n\", VAR_40->fileNames[VAR_129]);\n                CLEAN_RETURN(1);\n            }\n            VAR_39 = UTIL_mergeFileNamesTable(VAR_39, VAR_130);\n        }\n    }\n\n    VAR_55 = VAR_39->tableSize; /* COMMENT_72 */\n\n    if (VAR_37) {  /* COMMENT_73 */\n        UTIL_expandFNT(&VAR_39, VAR_3);\n    }\n#else\n    (void)VAR_3;\n#endif\n\n    if (VAR_32 == VAR_96) {\n#ifndef VAR_131\n        int const VAR_132 = FIO_listMultipleFiles((unsigned)VAR_39->tableSize, VAR_39->fileNames, VAR_75);\n        CLEAN_RETURN(VAR_132);\n#else\n        DISPLAY(\"file information is not supported \\n\");\n        CLEAN_RETURN(1);\n#endif\n    }\n\n    /* COMMENT_74 */\n    if (VAR_32==VAR_121) {\n#ifndef VAR_65\n        VAR_66.blockSize = VAR_29;\n        VAR_66.nbWorkers = VAR_10;\n        VAR_66.realTime = (unsigned)VAR_21;\n        VAR_66.nbSeconds = VAR_28;\n        VAR_66.ldmFlag = VAR_8;\n        VAR_66.ldmMinMatch = (int)VAR_133;\n        VAR_66.ldmHashLog = (int)VAR_134;\n        VAR_66.useRowMatchFinder = VAR_12;\n        if (VAR_135 != VAR_136) {\n            VAR_66.ldmBucketSizeLog = (int)VAR_135;\n        }\n        if (VAR_137 != VAR_136) {\n            VAR_66.ldmHashRateLog = (int)VAR_137;\n        }\n        VAR_66.literalCompressionMode = VAR_67;\n\n        if (VAR_35 > ZSTD_maxCLevel()) VAR_35 = ZSTD_maxCLevel();\n        if (VAR_36 > ZSTD_maxCLevel()) VAR_36 = ZSTD_maxCLevel();\n        if (VAR_36 < VAR_35) VAR_36 = VAR_35;\n        if (VAR_36 > VAR_35)\n            DISPLAYLEVEL(3, \"Benchmarking levels from %d to %d\\n\", VAR_35, VAR_36);\n        if (VAR_39->tableSize > 0) {\n            if(VAR_20) {\n                unsigned VAR_138;\n                for(VAR_138 = 0; VAR_138 < VAR_39->tableSize; VAR_138++) {\n                    int VAR_139;\n                    DISPLAYLEVEL(3, \"Benchmarking %s \\n\", VAR_39->fileNames[VAR_138]);\n                    for(VAR_139 = VAR_35; VAR_139 <= VAR_36; VAR_139++) {\n                        BMK_benchFilesAdvanced(&VAR_39->fileNames[VAR_138], 1, VAR_45, VAR_139, &VAR_34, VAR_75, &VAR_66);\n                }   }\n            } else {\n                for(; VAR_35 <= VAR_36; VAR_35++) {\n                    BMK_benchFilesAdvanced(VAR_39->fileNames, (unsigned)VAR_39->tableSize, VAR_45, VAR_35, &VAR_34, VAR_75, &VAR_66);\n            }   }\n        } else {\n            for(; VAR_35 <= VAR_36; VAR_35++) {\n                BMK_syntheticTest(VAR_35, VAR_27, &VAR_34, VAR_75, &VAR_66);\n        }   }\n\n#else\n        (void)VAR_28; (void)VAR_29; (void)VAR_21; (void)VAR_20; (void)VAR_27;\n#endif\n        goto _end;\n    }\n\n    /* COMMENT_75 */\n    if (VAR_32==VAR_98) {\n#ifndef VAR_60\n        ZDICT_params_t VAR_140;\n        VAR_140.compressionLevel = VAR_56;\n        VAR_140.notificationLevel = (unsigned)VAR_75;\n        VAR_140.dictID = VAR_51;\n        if (VAR_63 == VAR_108) {\n            int const VAR_141 = !VAR_61.k || !VAR_61.d;\n            VAR_61.nbThreads = (unsigned)VAR_10;\n            VAR_61.zParams = VAR_140;\n            VAR_19 = DiB_trainFromFiles(VAR_42, VAR_49, VAR_39->fileNames, (int)VAR_39->tableSize, VAR_29, NULL, &VAR_61, NULL, VAR_141, VAR_38);\n        } else if (VAR_63 == VAR_64) {\n            int const VAR_141 = !VAR_62.k || !VAR_62.d;\n            VAR_62.nbThreads = (unsigned)VAR_10;\n            VAR_62.zParams = VAR_140;\n            VAR_19 = DiB_trainFromFiles(VAR_42, VAR_49, VAR_39->fileNames, (int)VAR_39->tableSize, VAR_29, NULL, NULL, &VAR_62, VAR_141, VAR_38);\n        } else {\n            ZDICT_legacy_params_t VAR_142;\n            memset(&VAR_142, 0, sizeof(VAR_142));\n            VAR_142.selectivityLevel = VAR_58;\n            VAR_142.zParams = VAR_140;\n            VAR_19 = DiB_trainFromFiles(VAR_42, VAR_49, VAR_39->fileNames, (int)VAR_39->tableSize, VAR_29, &VAR_142, NULL, NULL, 0, VAR_38);\n        }\n#else\n        (void)VAR_56; (void)VAR_58; (void)VAR_51;  (void)VAR_49; /* COMMENT_76 */\n        DISPLAYLEVEL(1, \"training mode not available \\n\");\n        VAR_19 = 1;\n#endif\n        goto _end;\n    }\n\n#ifndef VAR_131\n    if (VAR_32==VAR_97) { FIO_setTestMode(VAR_30, 1); VAR_42=VAR_143; FIO_setRemoveSrcFile(VAR_30, 0); }  /* COMMENT_77 */\n#endif\n\n    /* COMMENT_78 */\n    if (VAR_39->tableSize == 0) {\n      /* COMMENT_79 */\n                                                      \n                                             \n       if (VAR_55 > 0 ){\n        DISPLAYLEVEL(1, \"please provide correct input file(s) or non-empty directories -- ignored \\n\");\n        CLEAN_RETURN(0);\n       }\n       UTIL_refFilename(VAR_39, VAR_95);\n    }\n\n    if (!strcmp(VAR_39->fileNames[0], VAR_95) && !VAR_42)\n        VAR_42 = VAR_74;  /* COMMENT_82 */\n\n    /* COMMENT_83 */\n    if (!VAR_5\n     && !strcmp(VAR_39->fileNames[0], VAR_95)\n     && IS_CONSOLE(VAR_144) ) {\n        DISPLAYLEVEL(1, \"stdin is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n    if ( VAR_42 && !strcmp(VAR_42, VAR_74)\n      && IS_CONSOLE(VAR_119)\n      && !strcmp(VAR_39->fileNames[0], VAR_95)\n      && !VAR_6\n      && VAR_32!=VAR_72 ) {\n        DISPLAYLEVEL(1, \"stdout is a console, aborting\\n\");\n        CLEAN_RETURN(1);\n    }\n\n#ifndef VAR_115\n    /* COMMENT_84 */\n    {   int const VAR_145 = VAR_25 ? ZSTD_maxCLevel() : VAR_146;\n        if (VAR_35 > VAR_145) {\n            DISPLAYLEVEL(2, \"Warning : compression level higher than max, reduced to %i \\n\", VAR_145);\n            VAR_35 = VAR_145;\n    }   }\n#endif\n\n    if (VAR_24) {\n        if (VAR_32 == VAR_72) {\n            DISPLAY(\"error : can't use --show-default-cparams in decompression mode \\n\");\n            CLEAN_RETURN(1);\n        }\n    }\n\n    if (VAR_45 != NULL && VAR_46 != NULL) {\n        DISPLAY(\"error : can't use -D and --patch-from=# at the same time \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    if (VAR_46 != NULL && VAR_39->tableSize > 1) {\n        DISPLAY(\"error : can't use --patch-from=# on multiple files \\n\");\n        CLEAN_RETURN(1);\n    }\n\n    /* COMMENT_85 */\n    VAR_7 = VAR_42 && !strcmp(VAR_42,VAR_74);\n\n    if ((VAR_7 || !IS_CONSOLE(VAR_147)) && (VAR_75==2)) VAR_75=1;\n\n    /* COMMENT_86 */\n    FIO_setHasStdoutOutput(VAR_31, VAR_7);\n    FIO_setNbFilesTotal(VAR_31, (int)VAR_39->tableSize);\n    FIO_determineHasStdinInput(VAR_31, VAR_39);\n    FIO_setNotificationLevel(VAR_75);\n    FIO_setAllowBlockDevices(VAR_30, VAR_4);\n    FIO_setPatchFromMode(VAR_30, VAR_46 != NULL);\n    if (VAR_38 == 0) {\n        if (VAR_34.windowLog == 0) {\n            VAR_38 = (U32)1 << VAR_148;\n        } else {\n            VAR_38 = (U32)1 << (VAR_34.windowLog & 31);\n    }   }\n    if (VAR_46 != NULL)\n        VAR_45 = VAR_46;\n    FIO_setMemLimit(VAR_30, VAR_38);\n    if (VAR_32==VAR_33) {\n#ifndef VAR_115\n        FIO_setContentSize(VAR_30, VAR_26);\n        FIO_setNbWorkers(VAR_30, VAR_10);\n        FIO_setBlockSize(VAR_30, (int)VAR_29);\n        if (VAR_149!=VAR_150) FIO_setOverlapLog(VAR_30, (int)VAR_149);\n        FIO_setLdmFlag(VAR_30, (unsigned)VAR_8);\n        FIO_setLdmHashLog(VAR_30, (int)VAR_134);\n        FIO_setLdmMinMatch(VAR_30, (int)VAR_133);\n        if (VAR_135 != VAR_136) FIO_setLdmBucketSizeLog(VAR_30, (int)VAR_135);\n        if (VAR_137 != VAR_136) FIO_setLdmHashRateLog(VAR_30, (int)VAR_137);\n        FIO_setAdaptiveMode(VAR_30, (unsigned)VAR_11);\n        FIO_setUseRowMatchFinder(VAR_30, VAR_12);\n        FIO_setAdaptMin(VAR_30, VAR_13);\n        FIO_setAdaptMax(VAR_30, VAR_15);\n        FIO_setRsyncable(VAR_30, VAR_17);\n        FIO_setStreamSrcSize(VAR_30, VAR_52);\n        FIO_setTargetCBlockSize(VAR_30, VAR_53);\n        FIO_setSrcSizeHint(VAR_30, VAR_54);\n        FIO_setLiteralCompressionMode(VAR_30, VAR_67);\n        FIO_setSparseWrite(VAR_30, 0);\n        if (VAR_13 > VAR_35) VAR_35 = VAR_13;\n        if (VAR_15 < VAR_35) VAR_35 = VAR_15;\n\n        /* COMMENT_87 */\n        { ZSTD_bounds VAR_151 = ZSTD_cParam_getBounds(VAR_152);\n          assert(VAR_153 == VAR_151.upperBound);\n          (void)VAR_151; }\n\n        if (VAR_24 || VAR_75 >= 4) {\n            size_t VAR_154;\n            for (VAR_154 = 0; VAR_154 < (size_t)VAR_39->tableSize; VAR_154++) {\n                if (VAR_24)\n                    printDefaultCParams(VAR_39->fileNames[VAR_154], VAR_45, VAR_35);\n                if (VAR_75 >= 4)\n                    printActualCParams(VAR_39->fileNames[VAR_154], VAR_45, VAR_35, &VAR_34);\n            }\n        }\n\n        if (VAR_75 >= 4)\n            FIO_displayCompressionParameters(VAR_30);\n        if ((VAR_39->tableSize==1) && VAR_42)\n            VAR_19 = FIO_compressFilename(VAR_31, VAR_30, VAR_42, VAR_39->fileNames[0], VAR_45, VAR_35, VAR_34);\n        else\n            VAR_19 = FIO_compressMultipleFilenames(VAR_31, VAR_30, VAR_39->fileNames, VAR_44, VAR_43, VAR_42, VAR_47, VAR_45, VAR_35, VAR_34);\n#else\n        (void)VAR_26; (void)VAR_47; (void)VAR_11; (void)VAR_17; (void)VAR_25; (void)VAR_35; (void)VAR_8; (void)VAR_67; (void)VAR_53; (void)VAR_52; (void)VAR_54; (void)VAR_155; (void)VAR_12; /* COMMENT_88 */\n        DISPLAY(\"Compression not supported \\n\");\n#endif\n    } else {  /* COMMENT_89 */\n#ifndef VAR_131\n        if (VAR_39->tableSize == 1 && VAR_42) {\n            VAR_19 = FIO_decompressFilename(VAR_31, VAR_30, VAR_42, VAR_39->fileNames[0], VAR_45);\n        } else {\n            VAR_19 = FIO_decompressMultipleFilenames(VAR_31, VAR_30, VAR_39->fileNames, VAR_44, VAR_43, VAR_42, VAR_45);\n        }\n#else\n        DISPLAY(\"Decompression not supported \\n\");\n#endif\n    }\n\n_end:\n    FIO_freePreferences(VAR_30);\n    FIO_freeContext(VAR_31);\n    if (VAR_9) waitEnter();\n    UTIL_freeFileNamesTable(VAR_39);\n    UTIL_freeFileNamesTable(VAR_40);\n#ifndef VAR_112\n    TRACE_finish();\n#endif\n\n    return VAR_19;\n}",
  "func_graph_path": "facebook/zstd/f9f27de91c89d826c6a39c3ef44fb1b02f9a43aa/zstdcli.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -218,7 +218,14 @@\n                 if (longCommandWArg(&argument, \"--stream-size=\")) { streamSrcSize = readSizeTFromChar(&argument); continue; }\n                 if (longCommandWArg(&argument, \"--target-compressed-block-size=\")) { targetCBlockSize = readSizeTFromChar(&argument); continue; }\n                 if (longCommandWArg(&argument, \"--size-hint=\")) { srcSizeHint = readSizeTFromChar(&argument); continue; }\n-                if (longCommandWArg(&argument, \"--output-dir-flat\")) { NEXT_FIELD(outDirName); continue; }\n+                if (longCommandWArg(&argument, \"--output-dir-flat\")) {\n+                    NEXT_FIELD(outDirName);\n+                    if (strlen(outDirName) == 0) {\n+                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");\n+                        CLEAN_RETURN(1);\n+                    }\n+                    continue;\n+                }\n                 if (longCommandWArg(&argument, \"--auto-threads\")) {\n                     const char* threadDefault = NULL;\n                     NEXT_FIELD(threadDefault);\n@@ -227,7 +234,14 @@\n                     continue;\n                 }\n #ifdef UTIL_HAS_MIRRORFILELIST\n-                if (longCommandWArg(&argument, \"--output-dir-mirror\")) { NEXT_FIELD(outMirroredDirName); continue; }\n+                if (longCommandWArg(&argument, \"--output-dir-mirror\")) {\n+                    NEXT_FIELD(outMirroredDirName);\n+                    if (strlen(outMirroredDirName) == 0) {\n+                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");\n+                        CLEAN_RETURN(1);\n+                    }\n+                    continue;\n+                }\n #endif\n #ifndef ZSTD_NOTRACE\n                 if (longCommandWArg(&argument, \"--trace\")) { char const* traceFile; NEXT_FIELD(traceFile); TRACE_enable(traceFile); continue; }",
  "diff_line_info": {
    "deleted_lines": [
      "                if (longCommandWArg(&argument, \"--output-dir-flat\")) { NEXT_FIELD(outDirName); continue; }",
      "                if (longCommandWArg(&argument, \"--output-dir-mirror\")) { NEXT_FIELD(outMirroredDirName); continue; }"
    ],
    "added_lines": [
      "                if (longCommandWArg(&argument, \"--output-dir-flat\")) {",
      "                    NEXT_FIELD(outDirName);",
      "                    if (strlen(outDirName) == 0) {",
      "                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");",
      "                        CLEAN_RETURN(1);",
      "                    }",
      "                    continue;",
      "                }",
      "                if (longCommandWArg(&argument, \"--output-dir-mirror\")) {",
      "                    NEXT_FIELD(outMirroredDirName);",
      "                    if (strlen(outMirroredDirName) == 0) {",
      "                        DISPLAY(\"error: output dir cannot be empty string (did you mean to pass '.' instead?)\\n\");",
      "                        CLEAN_RETURN(1);",
      "                    }",
      "                    continue;",
      "                }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/zstd/pull/3220",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/zstd/pull/3220: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/zstd/pulls/3220",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit addresses a security issue by preventing buffer underflows caused by empty output directories. It adds checks for empty strings in the relevant functions, directly fixing the reported vulnerability.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}