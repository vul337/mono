{
  "cve_id": "CVE-2012-6119",
  "cwe_ids": [
    "CWE-264"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "candlepin",
  "commit_msg": "835977: Re-enable manifest signature checking.\n\nThe production/stage public candlepin certificate is now packaged in the\nRPM. This is flagged as a config file but *without* noreplace, so any\ndeployment using their own upstream cert (we don't think there are any)\nwill have to restore it from the rpmsave file that results after a\ncandlepin rpm upgrade. This was done because we expect this to be the\ndesired behavior, there is no known usecase for using your own\nupstream cert at this time.",
  "commit_hash": "f4d93230e58b969c506b4c9778e04482a059b08c",
  "git_url": "https://github.com/candlepin/candlepin/commit/f4d93230e58b969c506b4c9778e04482a059b08c",
  "file_path": "src/main/java/org/candlepin/sync/Importer.java",
  "func_name": "loadExport",
  "func_before": "public Map<String, Object> loadExport(Owner owner, File exportFile,\n        ConflictOverrides overrides)\n        throws ImporterException {\n        File tmpDir = null;\n        InputStream exportStream = null;\n        Map<String, Object> result = new HashMap<String, Object>();\n        try {\n            tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n            extractArchive(tmpDir, exportFile);\n\n//           only need this call when sig file is verified\n//            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n\n            /*\n             * Disabling this once again for a little bit longer. Dependent projects\n             * are not yet ready for it, and we're having some difficulty with the actual\n             * upstream cert to use.\n             *\n             * When we bring this back, we should probably report this conflict\n             * immediately, rather than continuing to extract and trying to find any\n             * other conflicts to pass back.\n             */\n//            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n//                exportStream,\n//                loadSignature(new File(tmpDir, \"signature\")));\n//            if (!verifiedSignature) {\n//                log.warn(\"Manifest signature check failed.\");\n//                if (!forcedConflicts\n//                    .isForced(ImportConflicts.Conflict.SIGNATURE_CONFLICT)) {\n//                    conflicts.addConflict(\n//                        i18n.tr(\"Failed import file hash check.\"),\n//                        ImportConflicts.Conflict.SIGNATURE_CONFLICT);\n//                }\n//                else {\n//                    log.warn(\"Ignoring signature check failure.\");\n//                }\n//            }\n\n            File signature = new File(tmpDir, \"signature\");\n            if (signature.length() == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                          \"contain the required signature file\"));\n            }\n\n            File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n            File exportDir = extractArchive(tmpDir, consumerExport);\n\n            Map<String, File> importFiles = new HashMap<String, File>();\n            File[] listFiles = exportDir.listFiles();\n            if (listFiles == null || listFiles.length == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The consumer_export \" +\n                    \"archive has no contents\"));\n            }\n            for (File file : listFiles) {\n                importFiles.put(file.getName(), file);\n            }\n\n            ConsumerDto consumer = importObjects(owner, importFiles, overrides);\n            Meta m = mapper.readValue(importFiles.get(ImportFile.META.fileName()),\n                Meta.class);\n            result.put(\"consumer\", consumer);\n            result.put(\"meta\", m);\n            return result;\n        }\n//        catch (CertificateException e) {\n//            log.error(\"Exception caught importing archive\", e);\n//            throw new ImportExtractionException(\"unable to extract export archive\", e);\n//        }\n        catch (FileNotFoundException fnfe) {\n            log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n            throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n                                           \"the required consumer_export.zip file\"));\n        }\n        catch (ConstraintViolationException cve) {\n            log.error(\"Failed to import archive\", cve);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                cve);\n        }\n        catch (PersistenceException pe) {\n            log.error(\"Failed to import archive\", pe);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                pe);\n        }\n        catch (IOException e) {\n            log.error(\"Exception caught importing archive\", e);\n            throw new ImportExtractionException(\"unable to extract export archive\", e);\n        }\n        finally {\n            if (tmpDir != null) {\n                try {\n                    FileUtils.deleteDirectory(tmpDir);\n                }\n                catch (IOException e) {\n                    log.error(\"Failed to delete extracted export\", e);\n                }\n            }\n            if (exportStream != null) {\n                try {\n                    exportStream.close();\n                }\n                catch (Exception e) {\n                    // nothing we can do.\n                }\n            }\n        }\n    }",
  "abstract_func_before": "public Map<String, Object> loadExport(Owner VAR_0, File VAR_1,\n        ConflictOverrides VAR_2)\n        throws ImporterException {\n        File VAR_3 = null;\n        InputStream VAR_4 = null;\n        Map<String, Object> VAR_5 = new HashMap<String, Object>();\n        try {\n            VAR_3 = new SyncUtils(VAR_6).makeTempDir(\"import\");\n            extractArchive(VAR_3, VAR_1);\n\n/* COMMENT_0 */\n/* COMMENT_1 */\n\n            /* COMMENT_2 */\n                                                                                    \n                                                                                         \n                                    \n              \n                                                                               \n                                                                                    \n                                            \n               \n/* COMMENT_11 */\n/* COMMENT_12 */\n/* COMMENT_13 */\n/* COMMENT_14 */\n/* COMMENT_15 */\n/* COMMENT_16 */\n/* COMMENT_17 */\n/* COMMENT_18 */\n/* COMMENT_19 */\n/* COMMENT_20 */\n/* COMMENT_21 */\n/* COMMENT_22 */\n/* COMMENT_23 */\n/* COMMENT_21 */\n/* COMMENT_24 */\n\n            File VAR_7 = new File(VAR_3, \"signature\");\n            if (VAR_7.length() == 0) {\n                throw new ImportExtractionException(VAR_8.tr(\"The archive does not \" +\n                                          \"contain the required signature file\"));\n            }\n\n            File VAR_9 = new File(VAR_3, \"consumer_export.zip\");\n            File VAR_10 = extractArchive(VAR_3, VAR_9);\n\n            Map<String, File> VAR_11 = new HashMap<String, File>();\n            File[] VAR_12 = VAR_10.listFiles();\n            if (VAR_12 == null || VAR_12.length == 0) {\n                throw new ImportExtractionException(VAR_8.tr(\"The consumer_export \" +\n                    \"archive has no contents\"));\n            }\n            for (File VAR_13 : VAR_12) {\n                VAR_11.put(VAR_13.getName(), VAR_13);\n            }\n\n            ConsumerDto VAR_14 = importObjects(VAR_0, VAR_11, VAR_2);\n            Meta VAR_15 = VAR_16.readValue(VAR_11.get(VAR_17.META.fileName()),\n                Meta.class);\n            VAR_5.put(\"consumer\", VAR_14);\n            VAR_5.put(\"meta\", VAR_15);\n            return VAR_5;\n        }\n/* COMMENT_25 */\n/* COMMENT_26 */\n/* COMMENT_27 */\n/* COMMENT_28 */\n        catch (FileNotFoundException VAR_18) {\n            VAR_19.error(\"Archive file does not contain consumer_export.zip\", VAR_18);\n            throw new ImportExtractionException(VAR_8.tr(\"The archive does not contain \" +\n                                           \"the required consumer_export.zip file\"));\n        }\n        catch (ConstraintViolationException VAR_20) {\n            VAR_19.error(\"Failed to import archive\", VAR_20);\n            throw new ImporterException(VAR_8.tr(\"Failed to import archive\"),\n                VAR_20);\n        }\n        catch (PersistenceException VAR_21) {\n            VAR_19.error(\"Failed to import archive\", VAR_21);\n            throw new ImporterException(VAR_8.tr(\"Failed to import archive\"),\n                VAR_21);\n        }\n        catch (IOException VAR_22) {\n            VAR_19.error(\"Exception caught importing archive\", VAR_22);\n            throw new ImportExtractionException(\"unable to extract export archive\", VAR_22);\n        }\n        finally {\n            if (VAR_3 != null) {\n                try {\n                    VAR_23.deleteDirectory(VAR_3);\n                }\n                catch (IOException VAR_22) {\n                    VAR_19.error(\"Failed to delete extracted export\", VAR_22);\n                }\n            }\n            if (VAR_4 != null) {\n                try {\n                    VAR_4.close();\n                }\n                catch (Exception VAR_22) {\n                    /* COMMENT_29 */\n                }\n            }\n        }\n    }",
  "func_graph_path_before": "candlepin/f4d93230e58b969c506b4c9778e04482a059b08c/Importer.java/vul/before/0.json",
  "func": "public Map<String, Object> loadExport(Owner owner, File exportFile,\n        ConflictOverrides overrides)\n        throws ImporterException {\n        File tmpDir = null;\n        InputStream exportStream = null;\n        Map<String, Object> result = new HashMap<String, Object>();\n        try {\n            tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n            extractArchive(tmpDir, exportFile);\n\n            File signature = new File(tmpDir, \"signature\");\n            if (signature.length() == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                          \"contain the required signature file\"));\n            }\n\n            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n                exportStream,\n                loadSignature(new File(tmpDir, \"signature\")));\n            if (!verifiedSignature) {\n                log.warn(\"Archive signature check failed.\");\n                if (!overrides\n                    .isForced(Conflict.SIGNATURE_CONFLICT)) {\n\n                    /*\n                     * Normally for import conflicts that can be overridden, we try to\n                     * report them all the first time so if the user intends to override,\n                     * they can do so with just one more request. However in the case of\n                     * a bad signature, we're going to report immediately due to the nature\n                     * of what this might mean.\n                     */\n                    throw new ImportConflictException(\n                        i18n.tr(\"Archive failed signature check\"),\n                        Conflict.SIGNATURE_CONFLICT);\n                }\n                else {\n                    log.warn(\"Ignoring signature check failure.\");\n                }\n            }\n\n            File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n            File exportDir = extractArchive(tmpDir, consumerExport);\n\n            Map<String, File> importFiles = new HashMap<String, File>();\n            File[] listFiles = exportDir.listFiles();\n            if (listFiles == null || listFiles.length == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The consumer_export \" +\n                    \"archive has no contents\"));\n            }\n            for (File file : listFiles) {\n                importFiles.put(file.getName(), file);\n            }\n\n            ConsumerDto consumer = importObjects(owner, importFiles, overrides);\n            Meta m = mapper.readValue(importFiles.get(ImportFile.META.fileName()),\n                Meta.class);\n            result.put(\"consumer\", consumer);\n            result.put(\"meta\", m);\n            return result;\n        }\n        catch (FileNotFoundException fnfe) {\n            log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n            throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n                                           \"the required consumer_export.zip file\"));\n        }\n        catch (ConstraintViolationException cve) {\n            log.error(\"Failed to import archive\", cve);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                cve);\n        }\n        catch (PersistenceException pe) {\n            log.error(\"Failed to import archive\", pe);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                pe);\n        }\n        catch (IOException e) {\n            log.error(\"Exception caught importing archive\", e);\n            throw new ImportExtractionException(\"unable to extract export archive\", e);\n        }\n        catch (CertificateException e) {\n            log.error(\"Certificate exception checking archive signature\", e);\n            throw new ImportExtractionException(\n                \"Certificate exception checking archive signature\", e);\n        }\n        finally {\n            if (tmpDir != null) {\n                try {\n                    FileUtils.deleteDirectory(tmpDir);\n                }\n                catch (IOException e) {\n                    log.error(\"Failed to delete extracted export\", e);\n                }\n            }\n            if (exportStream != null) {\n                try {\n                    exportStream.close();\n                }\n                catch (Exception e) {\n                    // nothing we can do.\n                }\n            }\n        }\n    }",
  "abstract_func": "public Map<String, Object> loadExport(Owner VAR_0, File VAR_1,\n        ConflictOverrides VAR_2)\n        throws ImporterException {\n        File VAR_3 = null;\n        InputStream VAR_4 = null;\n        Map<String, Object> VAR_5 = new HashMap<String, Object>();\n        try {\n            VAR_3 = new SyncUtils(VAR_6).makeTempDir(\"import\");\n            extractArchive(VAR_3, VAR_1);\n\n            File VAR_7 = new File(VAR_3, \"signature\");\n            if (VAR_7.length() == 0) {\n                throw new ImportExtractionException(VAR_8.tr(\"The archive does not \" +\n                                          \"contain the required signature file\"));\n            }\n\n            VAR_4 = new FileInputStream(new File(VAR_3, \"consumer_export.zip\"));\n            boolean VAR_9 = VAR_10.verifySHA256WithRSAHashWithUpstreamCACert(\n                VAR_4,\n                loadSignature(new File(VAR_3, \"signature\")));\n            if (!VAR_9) {\n                VAR_11.warn(\"Archive signature check failed.\");\n                if (!VAR_2\n                    .isForced(VAR_12.SIGNATURE_CONFLICT)) {\n\n                    /* COMMENT_0 */\n                                                                                      \n                                                                                         \n                                                                                        \n                                                                                           \n                                               \n                       \n                    throw new ImportConflictException(\n                        VAR_8.tr(\"Archive failed signature check\"),\n                        VAR_12.SIGNATURE_CONFLICT);\n                }\n                else {\n                    VAR_11.warn(\"Ignoring signature check failure.\");\n                }\n            }\n\n            File VAR_13 = new File(VAR_3, \"consumer_export.zip\");\n            File VAR_14 = extractArchive(VAR_3, VAR_13);\n\n            Map<String, File> VAR_15 = new HashMap<String, File>();\n            File[] VAR_16 = VAR_14.listFiles();\n            if (VAR_16 == null || VAR_16.length == 0) {\n                throw new ImportExtractionException(VAR_8.tr(\"The consumer_export \" +\n                    \"archive has no contents\"));\n            }\n            for (File VAR_17 : VAR_16) {\n                VAR_15.put(VAR_17.getName(), VAR_17);\n            }\n\n            ConsumerDto VAR_18 = importObjects(VAR_0, VAR_15, VAR_2);\n            Meta VAR_19 = VAR_20.readValue(VAR_15.get(VAR_21.META.fileName()),\n                Meta.class);\n            VAR_5.put(\"consumer\", VAR_18);\n            VAR_5.put(\"meta\", VAR_19);\n            return VAR_5;\n        }\n        catch (FileNotFoundException VAR_22) {\n            VAR_11.error(\"Archive file does not contain consumer_export.zip\", VAR_22);\n            throw new ImportExtractionException(VAR_8.tr(\"The archive does not contain \" +\n                                           \"the required consumer_export.zip file\"));\n        }\n        catch (ConstraintViolationException VAR_23) {\n            VAR_11.error(\"Failed to import archive\", VAR_23);\n            throw new ImporterException(VAR_8.tr(\"Failed to import archive\"),\n                VAR_23);\n        }\n        catch (PersistenceException VAR_24) {\n            VAR_11.error(\"Failed to import archive\", VAR_24);\n            throw new ImporterException(VAR_8.tr(\"Failed to import archive\"),\n                VAR_24);\n        }\n        catch (IOException VAR_25) {\n            VAR_11.error(\"Exception caught importing archive\", VAR_25);\n            throw new ImportExtractionException(\"unable to extract export archive\", VAR_25);\n        }\n        catch (CertificateException VAR_25) {\n            VAR_11.error(\"Certificate exception checking archive signature\", VAR_25);\n            throw new ImportExtractionException(\n                \"Certificate exception checking archive signature\", VAR_25);\n        }\n        finally {\n            if (VAR_3 != null) {\n                try {\n                    VAR_26.deleteDirectory(VAR_3);\n                }\n                catch (IOException VAR_25) {\n                    VAR_11.error(\"Failed to delete extracted export\", VAR_25);\n                }\n            }\n            if (VAR_4 != null) {\n                try {\n                    VAR_4.close();\n                }\n                catch (Exception VAR_25) {\n                    /* COMMENT_7 */\n                }\n            }\n        }\n    }",
  "func_graph_path": "candlepin/f4d93230e58b969c506b4c9778e04482a059b08c/Importer.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,38 +8,35 @@\n             tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n             extractArchive(tmpDir, exportFile);\n \n-//           only need this call when sig file is verified\n-//            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n-\n-            /*\n-             * Disabling this once again for a little bit longer. Dependent projects\n-             * are not yet ready for it, and we're having some difficulty with the actual\n-             * upstream cert to use.\n-             *\n-             * When we bring this back, we should probably report this conflict\n-             * immediately, rather than continuing to extract and trying to find any\n-             * other conflicts to pass back.\n-             */\n-//            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n-//                exportStream,\n-//                loadSignature(new File(tmpDir, \"signature\")));\n-//            if (!verifiedSignature) {\n-//                log.warn(\"Manifest signature check failed.\");\n-//                if (!forcedConflicts\n-//                    .isForced(ImportConflicts.Conflict.SIGNATURE_CONFLICT)) {\n-//                    conflicts.addConflict(\n-//                        i18n.tr(\"Failed import file hash check.\"),\n-//                        ImportConflicts.Conflict.SIGNATURE_CONFLICT);\n-//                }\n-//                else {\n-//                    log.warn(\"Ignoring signature check failure.\");\n-//                }\n-//            }\n-\n             File signature = new File(tmpDir, \"signature\");\n             if (signature.length() == 0) {\n                 throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                           \"contain the required signature file\"));\n+            }\n+\n+            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n+            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n+                exportStream,\n+                loadSignature(new File(tmpDir, \"signature\")));\n+            if (!verifiedSignature) {\n+                log.warn(\"Archive signature check failed.\");\n+                if (!overrides\n+                    .isForced(Conflict.SIGNATURE_CONFLICT)) {\n+\n+                    /*\n+                     * Normally for import conflicts that can be overridden, we try to\n+                     * report them all the first time so if the user intends to override,\n+                     * they can do so with just one more request. However in the case of\n+                     * a bad signature, we're going to report immediately due to the nature\n+                     * of what this might mean.\n+                     */\n+                    throw new ImportConflictException(\n+                        i18n.tr(\"Archive failed signature check\"),\n+                        Conflict.SIGNATURE_CONFLICT);\n+                }\n+                else {\n+                    log.warn(\"Ignoring signature check failure.\");\n+                }\n             }\n \n             File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n@@ -62,10 +59,6 @@\n             result.put(\"meta\", m);\n             return result;\n         }\n-//        catch (CertificateException e) {\n-//            log.error(\"Exception caught importing archive\", e);\n-//            throw new ImportExtractionException(\"unable to extract export archive\", e);\n-//        }\n         catch (FileNotFoundException fnfe) {\n             log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n             throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n@@ -84,6 +77,11 @@\n         catch (IOException e) {\n             log.error(\"Exception caught importing archive\", e);\n             throw new ImportExtractionException(\"unable to extract export archive\", e);\n+        }\n+        catch (CertificateException e) {\n+            log.error(\"Certificate exception checking archive signature\", e);\n+            throw new ImportExtractionException(\n+                \"Certificate exception checking archive signature\", e);\n         }\n         finally {\n             if (tmpDir != null) {",
  "diff_line_info": {
    "deleted_lines": [
      "//           only need this call when sig file is verified",
      "//            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));",
      "",
      "            /*",
      "             * Disabling this once again for a little bit longer. Dependent projects",
      "             * are not yet ready for it, and we're having some difficulty with the actual",
      "             * upstream cert to use.",
      "             *",
      "             * When we bring this back, we should probably report this conflict",
      "             * immediately, rather than continuing to extract and trying to find any",
      "             * other conflicts to pass back.",
      "             */",
      "//            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(",
      "//                exportStream,",
      "//                loadSignature(new File(tmpDir, \"signature\")));",
      "//            if (!verifiedSignature) {",
      "//                log.warn(\"Manifest signature check failed.\");",
      "//                if (!forcedConflicts",
      "//                    .isForced(ImportConflicts.Conflict.SIGNATURE_CONFLICT)) {",
      "//                    conflicts.addConflict(",
      "//                        i18n.tr(\"Failed import file hash check.\"),",
      "//                        ImportConflicts.Conflict.SIGNATURE_CONFLICT);",
      "//                }",
      "//                else {",
      "//                    log.warn(\"Ignoring signature check failure.\");",
      "//                }",
      "//            }",
      "",
      "//        catch (CertificateException e) {",
      "//            log.error(\"Exception caught importing archive\", e);",
      "//            throw new ImportExtractionException(\"unable to extract export archive\", e);",
      "//        }"
    ],
    "added_lines": [
      "            }",
      "",
      "            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));",
      "            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(",
      "                exportStream,",
      "                loadSignature(new File(tmpDir, \"signature\")));",
      "            if (!verifiedSignature) {",
      "                log.warn(\"Archive signature check failed.\");",
      "                if (!overrides",
      "                    .isForced(Conflict.SIGNATURE_CONFLICT)) {",
      "",
      "                    /*",
      "                     * Normally for import conflicts that can be overridden, we try to",
      "                     * report them all the first time so if the user intends to override,",
      "                     * they can do so with just one more request. However in the case of",
      "                     * a bad signature, we're going to report immediately due to the nature",
      "                     * of what this might mean.",
      "                     */",
      "                    throw new ImportConflictException(",
      "                        i18n.tr(\"Archive failed signature check\"),",
      "                        Conflict.SIGNATURE_CONFLICT);",
      "                }",
      "                else {",
      "                    log.warn(\"Ignoring signature check failure.\");",
      "                }",
      "        }",
      "        catch (CertificateException e) {",
      "            log.error(\"Certificate exception checking archive signature\", e);",
      "            throw new ImportExtractionException(",
      "                \"Certificate exception checking archive signature\", e);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/candlepin/candlepin/pull/153",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/candlepin/candlepin/pull/153: 403 Client Error: Forbidden for url: https://api.github.com/repos/candlepin/candlepin/pulls/153",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}