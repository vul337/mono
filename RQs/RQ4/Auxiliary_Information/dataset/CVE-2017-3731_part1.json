{
  "cve_id": "CVE-2017-3731",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "crypto/evp: harden AEAD ciphers.\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory. Since hash\noperation is read-only it is not considered to be exploitable\nbeyond a DoS condition. Other ciphers were hardened.\n\nThanks to Robert Święcki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
  "commit_hash": "00d965474b22b54e4275232bc71ee0c699c5cd21",
  "git_url": "https://github.com/openssl/openssl/commit/00d965474b22b54e4275232bc71ee0c699c5cd21",
  "file_path": "crypto/evp/e_aes.c",
  "func_name": "aes_gcm_ctrl",
  "func_before": "static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n{\n    EVP_AES_GCM_CTX *gctx = EVP_C_DATA(EVP_AES_GCM_CTX,c);\n    switch (type) {\n    case EVP_CTRL_INIT:\n        gctx->key_set = 0;\n        gctx->iv_set = 0;\n        gctx->ivlen = EVP_CIPHER_CTX_iv_length(c);\n        gctx->iv = EVP_CIPHER_CTX_iv_noconst(c);\n        gctx->taglen = -1;\n        gctx->iv_gen = 0;\n        gctx->tls_aad_len = -1;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0)\n            return 0;\n        /* Allocate memory for IV if needed */\n        if ((arg > EVP_MAX_IV_LENGTH) && (arg > gctx->ivlen)) {\n            if (gctx->iv != EVP_CIPHER_CTX_iv_noconst(c))\n                OPENSSL_free(gctx->iv);\n            gctx->iv = OPENSSL_malloc(arg);\n            if (gctx->iv == NULL)\n                return 0;\n        }\n        gctx->ivlen = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting(c))\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        gctx->taglen = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > 16 || !EVP_CIPHER_CTX_encrypting(c)\n            || gctx->taglen < 0)\n            return 0;\n        memcpy(ptr, EVP_CIPHER_CTX_buf_noconst(c), arg);\n        return 1;\n\n    case EVP_CTRL_GCM_SET_IV_FIXED:\n        /* Special case: -1 length restores whole IV */\n        if (arg == -1) {\n            memcpy(gctx->iv, ptr, gctx->ivlen);\n            gctx->iv_gen = 1;\n            return 1;\n        }\n        /*\n         * Fixed field must be at least 4 bytes and invocation field at least\n         * 8.\n         */\n        if ((arg < 4) || (gctx->ivlen - arg) < 8)\n            return 0;\n        if (arg)\n            memcpy(gctx->iv, ptr, arg);\n        if (EVP_CIPHER_CTX_encrypting(c)\n            && RAND_bytes(gctx->iv + arg, gctx->ivlen - arg) <= 0)\n            return 0;\n        gctx->iv_gen = 1;\n        return 1;\n\n    case EVP_CTRL_GCM_IV_GEN:\n        if (gctx->iv_gen == 0 || gctx->key_set == 0)\n            return 0;\n        CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);\n        if (arg <= 0 || arg > gctx->ivlen)\n            arg = gctx->ivlen;\n        memcpy(ptr, gctx->iv + gctx->ivlen - arg, arg);\n        /*\n         * Invocation field will be at least 8 bytes in size and so no need\n         * to check wrap around or increment more than last 8 bytes.\n         */\n        ctr64_inc(gctx->iv + gctx->ivlen - 8);\n        gctx->iv_set = 1;\n        return 1;\n\n    case EVP_CTRL_GCM_SET_IV_INV:\n        if (gctx->iv_gen == 0 || gctx->key_set == 0\n            || EVP_CIPHER_CTX_encrypting(c))\n            return 0;\n        memcpy(gctx->iv + gctx->ivlen - arg, ptr, arg);\n        CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);\n        gctx->iv_set = 1;\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        /* Save the AAD for later use */\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        gctx->tls_aad_len = arg;\n        {\n            unsigned int len =\n                EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n            /* Correct length for explicit IV */\n            len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n            /* If decrypting correct for tag too */\n            if (!EVP_CIPHER_CTX_encrypting(c))\n                len -= EVP_GCM_TLS_TAG_LEN;\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n        }\n        /* Extra padding: tag appended to record */\n        return EVP_GCM_TLS_TAG_LEN;\n\n    case EVP_CTRL_COPY:\n        {\n            EVP_CIPHER_CTX *out = ptr;\n            EVP_AES_GCM_CTX *gctx_out = EVP_C_DATA(EVP_AES_GCM_CTX,out);\n            if (gctx->gcm.key) {\n                if (gctx->gcm.key != &gctx->ks)\n                    return 0;\n                gctx_out->gcm.key = &gctx_out->ks;\n            }\n            if (gctx->iv == EVP_CIPHER_CTX_iv_noconst(c))\n                gctx_out->iv = EVP_CIPHER_CTX_iv_noconst(out);\n            else {\n                gctx_out->iv = OPENSSL_malloc(gctx->ivlen);\n                if (gctx_out->iv == NULL)\n                    return 0;\n                memcpy(gctx_out->iv, gctx->iv, gctx->ivlen);\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "abstract_func_before": "static int aes_gcm_ctrl(EVP_CIPHER_CTX *VAR_0, int VAR_1, int VAR_2, void *VAR_3)\n{\n    EVP_AES_GCM_CTX *VAR_4 = EVP_C_DATA(EVP_AES_GCM_CTX,VAR_0);\n    switch (VAR_1) {\n    case VAR_5:\n        VAR_4->key_set = 0;\n        VAR_4->iv_set = 0;\n        VAR_4->ivlen = EVP_CIPHER_CTX_iv_length(VAR_0);\n        VAR_4->iv = EVP_CIPHER_CTX_iv_noconst(VAR_0);\n        VAR_4->taglen = -1;\n        VAR_4->iv_gen = 0;\n        VAR_4->tls_aad_len = -1;\n        return 1;\n\n    case VAR_6:\n        if (VAR_2 <= 0)\n            return 0;\n        /* COMMENT_0 */\n        if ((VAR_2 > VAR_7) && (VAR_2 > VAR_4->ivlen)) {\n            if (VAR_4->iv != EVP_CIPHER_CTX_iv_noconst(VAR_0))\n                OPENSSL_free(VAR_4->iv);\n            VAR_4->iv = OPENSSL_malloc(VAR_2);\n            if (VAR_4->iv == NULL)\n                return 0;\n        }\n        VAR_4->ivlen = VAR_2;\n        return 1;\n\n    case VAR_8:\n        if (VAR_2 <= 0 || VAR_2 > 16 || EVP_CIPHER_CTX_encrypting(VAR_0))\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        VAR_4->taglen = VAR_2;\n        return 1;\n\n    case VAR_9:\n        if (VAR_2 <= 0 || VAR_2 > 16 || !EVP_CIPHER_CTX_encrypting(VAR_0)\n            || VAR_4->taglen < 0)\n            return 0;\n        memcpy(VAR_3, EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_2);\n        return 1;\n\n    case VAR_10:\n        /* COMMENT_1 */\n        if (VAR_2 == -1) {\n            memcpy(VAR_4->iv, VAR_3, VAR_4->ivlen);\n            VAR_4->iv_gen = 1;\n            return 1;\n        }\n        /* COMMENT_2 */\n                                                                             \n             \n           \n        if ((VAR_2 < 4) || (VAR_4->ivlen - VAR_2) < 8)\n            return 0;\n        if (VAR_2)\n            memcpy(VAR_4->iv, VAR_3, VAR_2);\n        if (EVP_CIPHER_CTX_encrypting(VAR_0)\n            && RAND_bytes(VAR_4->iv + VAR_2, VAR_4->ivlen - VAR_2) <= 0)\n            return 0;\n        VAR_4->iv_gen = 1;\n        return 1;\n\n    case VAR_11:\n        if (VAR_4->iv_gen == 0 || VAR_4->key_set == 0)\n            return 0;\n        CRYPTO_gcm128_setiv(&VAR_4->gcm, VAR_4->iv, VAR_4->ivlen);\n        if (VAR_2 <= 0 || VAR_2 > VAR_4->ivlen)\n            VAR_2 = VAR_4->ivlen;\n        memcpy(VAR_3, VAR_4->iv + VAR_4->ivlen - VAR_2, VAR_2);\n        /* COMMENT_6 */\n                                                                           \n                                                                    \n           \n        ctr64_inc(VAR_4->iv + VAR_4->ivlen - 8);\n        VAR_4->iv_set = 1;\n        return 1;\n\n    case VAR_12:\n        if (VAR_4->iv_gen == 0 || VAR_4->key_set == 0\n            || EVP_CIPHER_CTX_encrypting(VAR_0))\n            return 0;\n        memcpy(VAR_4->iv + VAR_4->ivlen - VAR_2, VAR_3, VAR_2);\n        CRYPTO_gcm128_setiv(&VAR_4->gcm, VAR_4->iv, VAR_4->ivlen);\n        VAR_4->iv_set = 1;\n        return 1;\n\n    case VAR_13:\n        /* COMMENT_10 */\n        if (VAR_2 != VAR_14)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        VAR_4->tls_aad_len = VAR_2;\n        {\n            unsigned int VAR_15 =\n                EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1];\n            /* COMMENT_11 */\n            VAR_15 -= VAR_16;\n            /* COMMENT_12 */\n            if (!EVP_CIPHER_CTX_encrypting(VAR_0))\n                VAR_15 -= VAR_17;\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] = VAR_15 >> 8;\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1] = VAR_15 & 0xff;\n        }\n        /* COMMENT_13 */\n        return VAR_17;\n\n    case VAR_18:\n        {\n            EVP_CIPHER_CTX *VAR_19 = VAR_3;\n            EVP_AES_GCM_CTX *VAR_20 = EVP_C_DATA(EVP_AES_GCM_CTX,VAR_19);\n            if (VAR_4->gcm.key) {\n                if (VAR_4->gcm.key != &VAR_4->ks)\n                    return 0;\n                VAR_20->gcm.key = &VAR_20->ks;\n            }\n            if (VAR_4->iv == EVP_CIPHER_CTX_iv_noconst(VAR_0))\n                VAR_20->iv = EVP_CIPHER_CTX_iv_noconst(VAR_19);\n            else {\n                VAR_20->iv = OPENSSL_malloc(VAR_4->ivlen);\n                if (VAR_20->iv == NULL)\n                    return 0;\n                memcpy(VAR_20->iv, VAR_4->iv, VAR_4->ivlen);\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "func_graph_path_before": "openssl/00d965474b22b54e4275232bc71ee0c699c5cd21/e_aes.c/vul/before/0.json",
  "func": "static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n{\n    EVP_AES_GCM_CTX *gctx = EVP_C_DATA(EVP_AES_GCM_CTX,c);\n    switch (type) {\n    case EVP_CTRL_INIT:\n        gctx->key_set = 0;\n        gctx->iv_set = 0;\n        gctx->ivlen = EVP_CIPHER_CTX_iv_length(c);\n        gctx->iv = EVP_CIPHER_CTX_iv_noconst(c);\n        gctx->taglen = -1;\n        gctx->iv_gen = 0;\n        gctx->tls_aad_len = -1;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0)\n            return 0;\n        /* Allocate memory for IV if needed */\n        if ((arg > EVP_MAX_IV_LENGTH) && (arg > gctx->ivlen)) {\n            if (gctx->iv != EVP_CIPHER_CTX_iv_noconst(c))\n                OPENSSL_free(gctx->iv);\n            gctx->iv = OPENSSL_malloc(arg);\n            if (gctx->iv == NULL)\n                return 0;\n        }\n        gctx->ivlen = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting(c))\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        gctx->taglen = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > 16 || !EVP_CIPHER_CTX_encrypting(c)\n            || gctx->taglen < 0)\n            return 0;\n        memcpy(ptr, EVP_CIPHER_CTX_buf_noconst(c), arg);\n        return 1;\n\n    case EVP_CTRL_GCM_SET_IV_FIXED:\n        /* Special case: -1 length restores whole IV */\n        if (arg == -1) {\n            memcpy(gctx->iv, ptr, gctx->ivlen);\n            gctx->iv_gen = 1;\n            return 1;\n        }\n        /*\n         * Fixed field must be at least 4 bytes and invocation field at least\n         * 8.\n         */\n        if ((arg < 4) || (gctx->ivlen - arg) < 8)\n            return 0;\n        if (arg)\n            memcpy(gctx->iv, ptr, arg);\n        if (EVP_CIPHER_CTX_encrypting(c)\n            && RAND_bytes(gctx->iv + arg, gctx->ivlen - arg) <= 0)\n            return 0;\n        gctx->iv_gen = 1;\n        return 1;\n\n    case EVP_CTRL_GCM_IV_GEN:\n        if (gctx->iv_gen == 0 || gctx->key_set == 0)\n            return 0;\n        CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);\n        if (arg <= 0 || arg > gctx->ivlen)\n            arg = gctx->ivlen;\n        memcpy(ptr, gctx->iv + gctx->ivlen - arg, arg);\n        /*\n         * Invocation field will be at least 8 bytes in size and so no need\n         * to check wrap around or increment more than last 8 bytes.\n         */\n        ctr64_inc(gctx->iv + gctx->ivlen - 8);\n        gctx->iv_set = 1;\n        return 1;\n\n    case EVP_CTRL_GCM_SET_IV_INV:\n        if (gctx->iv_gen == 0 || gctx->key_set == 0\n            || EVP_CIPHER_CTX_encrypting(c))\n            return 0;\n        memcpy(gctx->iv + gctx->ivlen - arg, ptr, arg);\n        CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);\n        gctx->iv_set = 1;\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        /* Save the AAD for later use */\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        gctx->tls_aad_len = arg;\n        {\n            unsigned int len =\n                EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n            /* Correct length for explicit IV */\n            if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)\n                return 0;\n            len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n            /* If decrypting correct for tag too */\n            if (!EVP_CIPHER_CTX_encrypting(c)) {\n                if (len < EVP_GCM_TLS_TAG_LEN)\n                    return 0;\n                len -= EVP_GCM_TLS_TAG_LEN;\n            }\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n        }\n        /* Extra padding: tag appended to record */\n        return EVP_GCM_TLS_TAG_LEN;\n\n    case EVP_CTRL_COPY:\n        {\n            EVP_CIPHER_CTX *out = ptr;\n            EVP_AES_GCM_CTX *gctx_out = EVP_C_DATA(EVP_AES_GCM_CTX,out);\n            if (gctx->gcm.key) {\n                if (gctx->gcm.key != &gctx->ks)\n                    return 0;\n                gctx_out->gcm.key = &gctx_out->ks;\n            }\n            if (gctx->iv == EVP_CIPHER_CTX_iv_noconst(c))\n                gctx_out->iv = EVP_CIPHER_CTX_iv_noconst(out);\n            else {\n                gctx_out->iv = OPENSSL_malloc(gctx->ivlen);\n                if (gctx_out->iv == NULL)\n                    return 0;\n                memcpy(gctx_out->iv, gctx->iv, gctx->ivlen);\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "abstract_func": "static int aes_gcm_ctrl(EVP_CIPHER_CTX *VAR_0, int VAR_1, int VAR_2, void *VAR_3)\n{\n    EVP_AES_GCM_CTX *VAR_4 = EVP_C_DATA(EVP_AES_GCM_CTX,VAR_0);\n    switch (VAR_1) {\n    case VAR_5:\n        VAR_4->key_set = 0;\n        VAR_4->iv_set = 0;\n        VAR_4->ivlen = EVP_CIPHER_CTX_iv_length(VAR_0);\n        VAR_4->iv = EVP_CIPHER_CTX_iv_noconst(VAR_0);\n        VAR_4->taglen = -1;\n        VAR_4->iv_gen = 0;\n        VAR_4->tls_aad_len = -1;\n        return 1;\n\n    case VAR_6:\n        if (VAR_2 <= 0)\n            return 0;\n        /* COMMENT_0 */\n        if ((VAR_2 > VAR_7) && (VAR_2 > VAR_4->ivlen)) {\n            if (VAR_4->iv != EVP_CIPHER_CTX_iv_noconst(VAR_0))\n                OPENSSL_free(VAR_4->iv);\n            VAR_4->iv = OPENSSL_malloc(VAR_2);\n            if (VAR_4->iv == NULL)\n                return 0;\n        }\n        VAR_4->ivlen = VAR_2;\n        return 1;\n\n    case VAR_8:\n        if (VAR_2 <= 0 || VAR_2 > 16 || EVP_CIPHER_CTX_encrypting(VAR_0))\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        VAR_4->taglen = VAR_2;\n        return 1;\n\n    case VAR_9:\n        if (VAR_2 <= 0 || VAR_2 > 16 || !EVP_CIPHER_CTX_encrypting(VAR_0)\n            || VAR_4->taglen < 0)\n            return 0;\n        memcpy(VAR_3, EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_2);\n        return 1;\n\n    case VAR_10:\n        /* COMMENT_1 */\n        if (VAR_2 == -1) {\n            memcpy(VAR_4->iv, VAR_3, VAR_4->ivlen);\n            VAR_4->iv_gen = 1;\n            return 1;\n        }\n        /* COMMENT_2 */\n                                                                             \n             \n           \n        if ((VAR_2 < 4) || (VAR_4->ivlen - VAR_2) < 8)\n            return 0;\n        if (VAR_2)\n            memcpy(VAR_4->iv, VAR_3, VAR_2);\n        if (EVP_CIPHER_CTX_encrypting(VAR_0)\n            && RAND_bytes(VAR_4->iv + VAR_2, VAR_4->ivlen - VAR_2) <= 0)\n            return 0;\n        VAR_4->iv_gen = 1;\n        return 1;\n\n    case VAR_11:\n        if (VAR_4->iv_gen == 0 || VAR_4->key_set == 0)\n            return 0;\n        CRYPTO_gcm128_setiv(&VAR_4->gcm, VAR_4->iv, VAR_4->ivlen);\n        if (VAR_2 <= 0 || VAR_2 > VAR_4->ivlen)\n            VAR_2 = VAR_4->ivlen;\n        memcpy(VAR_3, VAR_4->iv + VAR_4->ivlen - VAR_2, VAR_2);\n        /* COMMENT_6 */\n                                                                           \n                                                                    \n           \n        ctr64_inc(VAR_4->iv + VAR_4->ivlen - 8);\n        VAR_4->iv_set = 1;\n        return 1;\n\n    case VAR_12:\n        if (VAR_4->iv_gen == 0 || VAR_4->key_set == 0\n            || EVP_CIPHER_CTX_encrypting(VAR_0))\n            return 0;\n        memcpy(VAR_4->iv + VAR_4->ivlen - VAR_2, VAR_3, VAR_2);\n        CRYPTO_gcm128_setiv(&VAR_4->gcm, VAR_4->iv, VAR_4->ivlen);\n        VAR_4->iv_set = 1;\n        return 1;\n\n    case VAR_13:\n        /* COMMENT_10 */\n        if (VAR_2 != VAR_14)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(VAR_0), VAR_3, VAR_2);\n        VAR_4->tls_aad_len = VAR_2;\n        {\n            unsigned int VAR_15 =\n                EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1];\n            /* COMMENT_11 */\n            if (VAR_15 < VAR_16)\n                return 0;\n            VAR_15 -= VAR_16;\n            /* COMMENT_12 */\n            if (!EVP_CIPHER_CTX_encrypting(VAR_0)) {\n                if (VAR_15 < VAR_17)\n                    return 0;\n                VAR_15 -= VAR_17;\n            }\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 2] = VAR_15 >> 8;\n            EVP_CIPHER_CTX_buf_noconst(VAR_0)[VAR_2 - 1] = VAR_15 & 0xff;\n        }\n        /* COMMENT_13 */\n        return VAR_17;\n\n    case VAR_18:\n        {\n            EVP_CIPHER_CTX *VAR_19 = VAR_3;\n            EVP_AES_GCM_CTX *VAR_20 = EVP_C_DATA(EVP_AES_GCM_CTX,VAR_19);\n            if (VAR_4->gcm.key) {\n                if (VAR_4->gcm.key != &VAR_4->ks)\n                    return 0;\n                VAR_20->gcm.key = &VAR_20->ks;\n            }\n            if (VAR_4->iv == EVP_CIPHER_CTX_iv_noconst(VAR_0))\n                VAR_20->iv = EVP_CIPHER_CTX_iv_noconst(VAR_19);\n            else {\n                VAR_20->iv = OPENSSL_malloc(VAR_4->ivlen);\n                if (VAR_20->iv == NULL)\n                    return 0;\n                memcpy(VAR_20->iv, VAR_4->iv, VAR_4->ivlen);\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}",
  "func_graph_path": "openssl/00d965474b22b54e4275232bc71ee0c699c5cd21/e_aes.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -96,10 +96,15 @@\n                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n             /* Correct length for explicit IV */\n+            if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)\n+                return 0;\n             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n             /* If decrypting correct for tag too */\n-            if (!EVP_CIPHER_CTX_encrypting(c))\n+            if (!EVP_CIPHER_CTX_encrypting(c)) {\n+                if (len < EVP_GCM_TLS_TAG_LEN)\n+                    return 0;\n                 len -= EVP_GCM_TLS_TAG_LEN;\n+            }\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "            if (!EVP_CIPHER_CTX_encrypting(c))"
    ],
    "added_lines": [
      "            if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)",
      "                return 0;",
      "            if (!EVP_CIPHER_CTX_encrypting(c)) {",
      "                if (len < EVP_GCM_TLS_TAG_LEN)",
      "                    return 0;",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/EktapopaT/openssl/pull/1: 403 Client Error: Forbidden for url: https://api.github.com/repos/EktapopaT/openssl/pulls/1",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch clearly addresses a security issue by hardening AEAD ciphers to prevent crashes that could lead to a DoS. It includes changes to length checks and references a CVE, making it a security fix with high confidence."
}