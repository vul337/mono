{
  "cve_id": "CVE-2019-1010065",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "sleuthkit",
  "commit_msg": "hfs: fix keylen check in hfs_cat_traverse()\n\nIf key->key_len is 65535, calculating \"uint16_t keylen' would\ncause an overflow:\n\n   uint16_t keylen;\n   ...\n   keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len)\n\nso the code bypasses the sanity check \"if (keylen > nodesize)\"\nwhich results in crash later:\n\n    ./toolfs/fstools/fls -b 512 -f hfs <image>\n    =================================================================\n    ==16==ERROR: AddressSanitizer: SEGV on unknown address 0x6210000256a4 (pc 0x00000054812b bp 0x7ffca548a8f0 sp 0x7ffca548a480 T0)\n    ==16==The signal is caused by a READ memory access.\n        #0 0x54812a in hfs_dir_open_meta_cb /fuzzing/sleuthkit/tsk/fs/hfs_dent.c:237:20\n        #1 0x51a96c in hfs_cat_traverse /fuzzing/sleuthkit/tsk/fs/hfs.c:1082:21\n        #2 0x547785 in hfs_dir_open_meta /fuzzing/sleuthkit/tsk/fs/hfs_dent.c:480:9\n        #3 0x50f57d in tsk_fs_dir_open_meta /fuzzing/sleuthkit/tsk/fs/fs_dir.c:290:14\n        #4 0x54af17 in tsk_fs_path2inum /fuzzing/sleuthkit/tsk/fs/ifind_lib.c:237:23\n        #5 0x522266 in hfs_open /fuzzing/sleuthkit/tsk/fs/hfs.c:6579:9\n        #6 0x508e89 in main /fuzzing/sleuthkit/tools/fstools/fls.cpp:267:19\n        #7 0x7f9daf67c2b0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202b0)\n        #8 0x41d679 in _start (/fuzzing/sleuthkit/tools/fstools/fls+0x41d679)\n\nMake 'keylen' int type to prevent the overflow and fix that.\nNow, I get proper error message instead of crash:\n    ./toolfs/fstools/fls -b 512 -f hfs <image>\n    General file system error (hfs_cat_traverse: length of key 3 in leaf node 1 too large (65537 vs 4096))",
  "commit_hash": "114cd3d0aac8bd1aeaf4b33840feb0163d342d5b",
  "git_url": "https://github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b",
  "file_path": "tsk/fs/hfs.c",
  "func_name": "hfs_cat_traverse",
  "func_before": "uint8_t\nhfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"hfs_cat_traverse: starting at \"\n            \"root node %\" PRIu32 \"; nodesize = %\"\n            PRIu16 \"\\n\", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: node %\" PRIu32\n                \" @ %\" PRIu64 \" has %\" PRIu16 \" records\\n\",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \" ; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            PRIu16 \")\", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \"; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" PRIu32\n                \" (%\" PRIu64 \") is neither index nor leaf (%\" PRIu8 \")\",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}",
  "abstract_func_before": "uint8_t\nhfs_cat_traverse(HFS_INFO * VAR_0,\n    TSK_HFS_BTREE_CB VAR_1, void *VAR_2)\n{\n    TSK_FS_INFO *VAR_3 = &(VAR_0->fs_info);\n    uint32_t VAR_4;          /* COMMENT_0 */\n    char *VAR_5;\n\n    uint16_t VAR_6;\n    uint8_t VAR_7 = 0;\n\n    tsk_error_reset();\n\n    VAR_6 = tsk_getu16(VAR_3->endian, VAR_0->catalog_header.nodesize);\n    if ((VAR_5 = (char *) tsk_malloc(VAR_6)) == NULL)\n        return 1;\n\n    /* COMMENT_1 */\n    VAR_4 = tsk_getu32(VAR_3->endian, VAR_0->catalog_header.rootNode);\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n                                                             \n                         \n    if (VAR_4 == 0) {\n        if (VAR_8)\n            tsk_fprintf(VAR_9, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(VAR_5);\n        return 1;\n    }\n\n    if (VAR_8)\n        tsk_fprintf(VAR_9, \"hfs_cat_traverse: starting at \"\n            \"root node %\" VAR_10 \"; nodesize = %\"\n            VAR_11 \"\\n\", VAR_4, VAR_6);\n\n    /* COMMENT_6 */\n    VAR_7 = 0;\n    while (VAR_7 == 0) {\n        TSK_OFF_T VAR_12;      /* COMMENT_7 */\n        uint16_t VAR_13;       /* COMMENT_8 */\n        ssize_t VAR_14;\n        hfs_btree_node *VAR_15;\n\n        /* COMMENT_9 */\n        if (VAR_4 > tsk_getu32(VAR_3->endian,\n                VAR_0->catalog_header.totalNodes)) {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", VAR_4);\n            free(VAR_5);\n            return 1;\n        }\n\n        /* COMMENT_10 */\n        VAR_12 = VAR_4 * VAR_6;\n        VAR_14 = tsk_fs_attr_read(VAR_0->catalog_attr, VAR_12,\n            VAR_5, VAR_6, 0);\n        if (VAR_14 != VAR_6) {\n            if (VAR_14 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_17);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                VAR_18, VAR_4, VAR_12);\n            free(VAR_5);\n            return 1;\n        }\n\n        /* COMMENT_11 */\n        if (VAR_6 < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", VAR_6);\n            free(VAR_5);\n            return 1;\n        }\n        VAR_15 = (hfs_btree_node *) VAR_5;\n        VAR_13 = tsk_getu16(VAR_3->endian, VAR_15->num_rec);\n\n        if (VAR_8)\n            tsk_fprintf(VAR_9, \"hfs_cat_traverse: node %\" VAR_10\n                \" @ %\" VAR_19 \" has %\" VAR_11 \" records\\n\",\n                VAR_4, VAR_12, VAR_13);\n\n        if (VAR_13 == 0) {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                VAR_10, VAR_4);\n            free(VAR_5);\n            return 1;\n        }\n\n        /* COMMENT_12 */\n                                 \n        if (VAR_15->type == VAR_20) {\n            uint32_t VAR_21 = 0;\n            int VAR_22;\n\n            for (VAR_22 = 0; VAR_22 < VAR_13; ++VAR_22) {\n                size_t VAR_23;\n                hfs_btree_key_cat *VAR_24;\n                uint8_t VAR_25;\n                uint16_t VAR_26;\n\n                /* COMMENT_14 */\n                VAR_23 =\n                    tsk_getu16(VAR_3->endian,\n                    &VAR_5[VAR_6 - (VAR_22 + 1) * 2]);\n                if (VAR_23 > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, (int) VAR_23,\n                        VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n\n                VAR_24 = (hfs_btree_key_cat *) & VAR_5[VAR_23];\n\n                VAR_26 = 2 + tsk_getu16(VAR_0->fs_info.endian, VAR_24->key_len);\n                if ((VAR_26) > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, VAR_26, VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n\n\n                /* COMMENT_15 */\n                                   \n                                      \n                                                      \n                                                                \n                                                        \n                                                             \n                   \n\n\n                /* COMMENT_23 */\n                VAR_25 =\n                    VAR_1(VAR_0, VAR_20, VAR_24,\n                    VAR_12 + VAR_23, VAR_2);\n                if (VAR_25 == VAR_27) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(VAR_5);\n                    return 1;\n                }\n                /* COMMENT_24 */\n                else if ((VAR_25 == VAR_28)\n                    || (VAR_21 == 0)) {\n                    hfs_btree_index_record *VAR_29;\n                    int VAR_26 =\n                        2 + hfs_get_idxkeylen(VAR_0, tsk_getu16(VAR_3->endian,\n                            VAR_24->key_len), &(VAR_0->catalog_header));\n                    if (VAR_23 + VAR_26 > VAR_6) {\n                        tsk_error_set_errno(VAR_16);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            VAR_11 \")\", VAR_22, VAR_4,\n                            (int) VAR_23 + VAR_26, VAR_6);\n                        free(VAR_5);\n                        return 1;\n                    }\n                    VAR_29 =\n                        (hfs_btree_index_record *) & VAR_5[VAR_23 +\n                        VAR_26];\n                    VAR_21 = tsk_getu32(VAR_3->endian, VAR_29->childNode);\n                }\n                if (VAR_25 == VAR_30) {\n                    /* COMMENT_25 */\n                    break;\n                }\n            }\n            /* COMMENT_26 */\n            if (VAR_21 == 0) {\n                tsk_error_set_errno(VAR_16);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    VAR_4);\n                VAR_7 = 1;\n                break;\n            }\n            /* COMMENT_27 */\n            if (VAR_21 == VAR_4) {\n                tsk_error_set_errno(VAR_16);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    VAR_4);\n                VAR_7 = 1;\n                break;\n            }\n            VAR_4 = VAR_21;\n        }\n\n        /* COMMENT_28 */\n        else if (VAR_15->type == VAR_31) {\n            int VAR_22;\n\n            for (VAR_22 = 0; VAR_22 < VAR_13; ++VAR_22) {\n                size_t VAR_23;\n                hfs_btree_key_cat *VAR_24;\n                uint8_t VAR_25;\n                uint16_t VAR_26;\n\n                /* COMMENT_14 */\n                VAR_23 =\n                    tsk_getu16(VAR_3->endian,\n                    &VAR_5[VAR_6 - (VAR_22 + 1) * 2]);\n                if (VAR_23 > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, (int) VAR_23,\n                        VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n                VAR_24 = (hfs_btree_key_cat *) & VAR_5[VAR_23];\n\n                VAR_26 = 2 + tsk_getu16(VAR_0->fs_info.endian, VAR_24->key_len);\n                if ((VAR_26) > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, VAR_26, VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n\n                /* COMMENT_29 */\n                                   \n                                      \n                                                      \n                                                               \n                                                        \n                                                             \n                   \n                /* COMMENT_37 */\n\n                VAR_25 =\n                    VAR_1(VAR_0, VAR_31, VAR_24,\n                    VAR_12 + VAR_23, VAR_2);\n                if (VAR_25 == VAR_32) {\n                    VAR_7 = 1;\n                    break;\n                }\n                else if (VAR_25 == VAR_27) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(VAR_5);\n                    return 1;\n                }\n            }\n\n            /* COMMENT_38 */\n            if (VAR_7 == 0) {\n                VAR_4 = tsk_getu32(VAR_3->endian, VAR_15->flink);\n                if (VAR_4 == 0) {\n                    VAR_7 = 1;\n                }\n                if (VAR_8)\n                    tsk_fprintf(VAR_9,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" VAR_10\n                \" (%\" VAR_19 \") is neither index nor leaf (%\" VAR_33 \")\",\n                VAR_4, VAR_12, VAR_15->type);\n            free(VAR_5);\n            return 1;\n        }\n    }\n    free(VAR_5);\n    return 0;\n}",
  "func_graph_path_before": "sleuthkit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b/hfs.c/vul/before/0.json",
  "func": "uint8_t\nhfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"hfs_cat_traverse: starting at \"\n            \"root node %\" PRIu32 \"; nodesize = %\"\n            PRIu16 \"\\n\", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"hfs_cat_traverse: node %\" PRIu32\n                \" @ %\" PRIu64 \" has %\" PRIu16 \" records\\n\",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \" ; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            PRIu16 \")\", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \"hfs_cat_traverse: record %\" PRIu16\n                   \"; keylen %\" PRIu16 \" (%\" PRIu32 \")\\n\", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" PRIu32\n                \" (%\" PRIu64 \") is neither index nor leaf (%\" PRIu8 \")\",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}",
  "abstract_func": "uint8_t\nhfs_cat_traverse(HFS_INFO * VAR_0,\n    TSK_HFS_BTREE_CB VAR_1, void *VAR_2)\n{\n    TSK_FS_INFO *VAR_3 = &(VAR_0->fs_info);\n    uint32_t VAR_4;          /* COMMENT_0 */\n    char *VAR_5;\n\n    uint16_t VAR_6;\n    uint8_t VAR_7 = 0;\n\n    tsk_error_reset();\n\n    VAR_6 = tsk_getu16(VAR_3->endian, VAR_0->catalog_header.nodesize);\n    if ((VAR_5 = (char *) tsk_malloc(VAR_6)) == NULL)\n        return 1;\n\n    /* COMMENT_1 */\n    VAR_4 = tsk_getu32(VAR_3->endian, VAR_0->catalog_header.rootNode);\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n                                                             \n                         \n    if (VAR_4 == 0) {\n        if (VAR_8)\n            tsk_fprintf(VAR_9, \"hfs_cat_traverse: \"\n                \"empty extents btree\\n\");\n        free(VAR_5);\n        return 1;\n    }\n\n    if (VAR_8)\n        tsk_fprintf(VAR_9, \"hfs_cat_traverse: starting at \"\n            \"root node %\" VAR_10 \"; nodesize = %\"\n            VAR_11 \"\\n\", VAR_4, VAR_6);\n\n    /* COMMENT_6 */\n    VAR_7 = 0;\n    while (VAR_7 == 0) {\n        TSK_OFF_T VAR_12;      /* COMMENT_7 */\n        uint16_t VAR_13;       /* COMMENT_8 */\n        ssize_t VAR_14;\n        hfs_btree_node *VAR_15;\n\n        /* COMMENT_9 */\n        if (VAR_4 > tsk_getu32(VAR_3->endian,\n                VAR_0->catalog_header.totalNodes)) {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr\n                (\"hfs_cat_traverse: Node %d too large for file\", VAR_4);\n            free(VAR_5);\n            return 1;\n        }\n\n        /* COMMENT_10 */\n        VAR_12 = VAR_4 * VAR_6;\n        VAR_14 = tsk_fs_attr_read(VAR_0->catalog_attr, VAR_12,\n            VAR_5, VAR_6, 0);\n        if (VAR_14 != VAR_6) {\n            if (VAR_14 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_17);\n            }\n            tsk_error_set_errstr2\n                (\"hfs_cat_traverse: Error reading node %d at offset %\"\n                VAR_18, VAR_4, VAR_12);\n            free(VAR_5);\n            return 1;\n        }\n\n        /* COMMENT_11 */\n        if (VAR_6 < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr\n            (\"hfs_cat_traverse: Node size %d is too small to be valid\", VAR_6);\n            free(VAR_5);\n            return 1;\n        }\n        VAR_15 = (hfs_btree_node *) VAR_5;\n        VAR_13 = tsk_getu16(VAR_3->endian, VAR_15->num_rec);\n\n        if (VAR_8)\n            tsk_fprintf(VAR_9, \"hfs_cat_traverse: node %\" VAR_10\n                \" @ %\" VAR_19 \" has %\" VAR_11 \" records\\n\",\n                VAR_4, VAR_12, VAR_13);\n\n        if (VAR_13 == 0) {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr(\"hfs_cat_traverse: zero records in node %\"\n                VAR_10, VAR_4);\n            free(VAR_5);\n            return 1;\n        }\n\n        /* COMMENT_12 */\n                                 \n        if (VAR_15->type == VAR_20) {\n            uint32_t VAR_21 = 0;\n            int VAR_22;\n\n            for (VAR_22 = 0; VAR_22 < VAR_13; ++VAR_22) {\n                size_t VAR_23;\n                hfs_btree_key_cat *VAR_24;\n                uint8_t VAR_25;\n                int VAR_26;\n\n                /* COMMENT_14 */\n                VAR_23 =\n                    tsk_getu16(VAR_3->endian,\n                    &VAR_5[VAR_6 - (VAR_22 + 1) * 2]);\n                if (VAR_23 > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, (int) VAR_23,\n                        VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n\n                VAR_24 = (hfs_btree_key_cat *) & VAR_5[VAR_23];\n\n                VAR_26 = 2 + tsk_getu16(VAR_0->fs_info.endian, VAR_24->key_len);\n                if ((VAR_26) > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, VAR_26, VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n\n\n                /* COMMENT_15 */\n                                   \n                                      \n                                                      \n                                                                \n                                                        \n                                                             \n                   \n\n\n                /* COMMENT_23 */\n                VAR_25 =\n                    VAR_1(VAR_0, VAR_20, VAR_24,\n                    VAR_12 + VAR_23, VAR_2);\n                if (VAR_25 == VAR_27) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(VAR_5);\n                    return 1;\n                }\n                /* COMMENT_24 */\n                else if ((VAR_25 == VAR_28)\n                    || (VAR_21 == 0)) {\n                    hfs_btree_index_record *VAR_29;\n                    int VAR_26 =\n                        2 + hfs_get_idxkeylen(VAR_0, tsk_getu16(VAR_3->endian,\n                            VAR_24->key_len), &(VAR_0->catalog_header));\n                    if (VAR_23 + VAR_26 > VAR_6) {\n                        tsk_error_set_errno(VAR_16);\n                        tsk_error_set_errstr\n                            (\"hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\"\n                            VAR_11 \")\", VAR_22, VAR_4,\n                            (int) VAR_23 + VAR_26, VAR_6);\n                        free(VAR_5);\n                        return 1;\n                    }\n                    VAR_29 =\n                        (hfs_btree_index_record *) & VAR_5[VAR_23 +\n                        VAR_26];\n                    VAR_21 = tsk_getu32(VAR_3->endian, VAR_29->childNode);\n                }\n                if (VAR_25 == VAR_30) {\n                    /* COMMENT_25 */\n                    break;\n                }\n            }\n            /* COMMENT_26 */\n            if (VAR_21 == 0) {\n                tsk_error_set_errno(VAR_16);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: did not find any keys in index node %d\",\n                    VAR_4);\n                VAR_7 = 1;\n                break;\n            }\n            /* COMMENT_27 */\n            if (VAR_21 == VAR_4) {\n                tsk_error_set_errno(VAR_16);\n                tsk_error_set_errstr\n                    (\"hfs_cat_traverse: node %d references itself as next node\",\n                    VAR_4);\n                VAR_7 = 1;\n                break;\n            }\n            VAR_4 = VAR_21;\n        }\n\n        /* COMMENT_28 */\n        else if (VAR_15->type == VAR_31) {\n            int VAR_22;\n\n            for (VAR_22 = 0; VAR_22 < VAR_13; ++VAR_22) {\n                size_t VAR_23;\n                hfs_btree_key_cat *VAR_24;\n                uint8_t VAR_25;\n                int VAR_26;\n\n                /* COMMENT_14 */\n                VAR_23 =\n                    tsk_getu16(VAR_3->endian,\n                    &VAR_5[VAR_6 - (VAR_22 + 1) * 2]);\n                if (VAR_23 > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, (int) VAR_23,\n                        VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n                VAR_24 = (hfs_btree_key_cat *) & VAR_5[VAR_23];\n\n                VAR_26 = 2 + tsk_getu16(VAR_0->fs_info.endian, VAR_24->key_len);\n                if ((VAR_26) > VAR_6) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr\n                        (\"hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\"\n                        VAR_11 \")\", VAR_22, VAR_4, VAR_26, VAR_6);\n                    free(VAR_5);\n                    return 1;\n                }\n\n                /* COMMENT_29 */\n                                   \n                                      \n                                                      \n                                                               \n                                                        \n                                                             \n                   \n                /* COMMENT_37 */\n\n                VAR_25 =\n                    VAR_1(VAR_0, VAR_31, VAR_24,\n                    VAR_12 + VAR_23, VAR_2);\n                if (VAR_25 == VAR_32) {\n                    VAR_7 = 1;\n                    break;\n                }\n                else if (VAR_25 == VAR_27) {\n                    tsk_error_set_errno(VAR_16);\n                    tsk_error_set_errstr2\n                        (\"hfs_cat_traverse: Callback returned error\");\n                    free(VAR_5);\n                    return 1;\n                }\n            }\n\n            /* COMMENT_38 */\n            if (VAR_7 == 0) {\n                VAR_4 = tsk_getu32(VAR_3->endian, VAR_15->flink);\n                if (VAR_4 == 0) {\n                    VAR_7 = 1;\n                }\n                if (VAR_8)\n                    tsk_fprintf(VAR_9,\n                        \"hfs_cat_traverse: moving forward to next leaf\");\n            }\n        }\n        else {\n            tsk_error_set_errno(VAR_16);\n            tsk_error_set_errstr(\"hfs_cat_traverse: btree node %\" VAR_10\n                \" (%\" VAR_19 \") is neither index nor leaf (%\" VAR_33 \")\",\n                VAR_4, VAR_12, VAR_15->type);\n            free(VAR_5);\n            return 1;\n        }\n    }\n    free(VAR_5);\n    return 0;\n}",
  "func_graph_path": "sleuthkit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b/hfs.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -103,7 +103,7 @@\n                 size_t rec_off;\n                 hfs_btree_key_cat *key;\n                 uint8_t retval;\n-                uint16_t keylen;\n+                int keylen;\n \n                 // get the record offset in the node\n                 rec_off =\n@@ -208,7 +208,7 @@\n                 size_t rec_off;\n                 hfs_btree_key_cat *key;\n                 uint8_t retval;\n-                uint16_t keylen;\n+                int keylen;\n \n                 // get the record offset in the node\n                 rec_off =",
  "diff_line_info": {
    "deleted_lines": [
      "                uint16_t keylen;",
      "                uint16_t keylen;"
    ],
    "added_lines": [
      "                int keylen;",
      "                int keylen;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sleuthkit/sleuthkit/pull/1199",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sleuthkit/sleuthkit/pull/1199: 403 Client Error: Forbidden for url: https://api.github.com/repos/sleuthkit/sleuthkit/pulls/1199",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95\n\nThe patch addresses an integer overflow in the HFS filesystem code, which could lead to a crash, making it a security fix. The code change is consistent with the commit message and vulnerability description, and the confidence is high due to clear alignment between the fix and the reported issue."
}