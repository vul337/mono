{
  "cve_id": "CVE-2021-32277",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "Restrict SBR frame length to 960 and 1024 samples.\n\nFixes #59 and #60.",
  "commit_hash": "c78251b2b5d41ea840fd61ab9502b3d3036bd747",
  "git_url": "https://github.com/knik0/faad2/commit/c78251b2b5d41ea840fd61ab9502b3d3036bd747",
  "file_path": "libfaad/specrec.c",
  "func_name": "reconstruct_single_channel",
  "func_before": "uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \"suddenly\" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency */\n\n        /* this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        /* reset the allocation */\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n\n        //return 21;\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n    /* sanity check, CVE-2018-20199, CVE-2018-20360 */\n    if(!hDecoder->time_out[sce->channel])\n        return 15;\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func_before": "uint8_t reconstruct_single_channel(NeAACDecStruct *VAR_0, ic_stream *VAR_1,\n                                   element *VAR_2, int16_t *VAR_3)\n{\n    uint8_t VAR_4;\n    int VAR_5;\n    ALIGN VAR_6 VAR_7[1024];\n\n#ifdef VAR_8\n    int64_t VAR_9 = faad_get_ts();\n#endif\n\n\n    /* COMMENT_0 */\n#if ( (defined(VAR_10) && defined(VAR_11)) )\n    VAR_5 = 2;\n#elif defined(VAR_12)\n    if (VAR_0->ps_used[VAR_0->fr_ch_ele])\n        VAR_5 = 2;\n    else\n        VAR_5 = 1;\n#else\n    VAR_5 = 1;\n#endif\n\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n    {\n        /* COMMENT_1 */\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n    } else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != VAR_5) {\n        /* COMMENT_2 */\n\n        /* COMMENT_3 */\n                                                             \n           \n\n        /* COMMENT_6 */\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 0;\n\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n\n        /* COMMENT_7 */\n    }\n\n    if (VAR_0->element_alloced[VAR_0->fr_ch_ele] == 0)\n    {\n        VAR_4 = allocate_single_channel(VAR_0, VAR_2->channel, VAR_5);\n        if (VAR_4 > 0)\n            return VAR_4;\n\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 1;\n    }\n\n    /* COMMENT_8 */\n    if(!VAR_0->time_out[VAR_2->channel])\n        return 15;\n\n    /* COMMENT_9 */\n    VAR_4 = quant_to_spec(VAR_0, VAR_1, VAR_3, VAR_7, VAR_0->frameLength);\n    if (VAR_4 > 0)\n        return VAR_4;\n\n#ifdef VAR_8\n    VAR_9 = faad_get_ts() - VAR_9;\n    VAR_0->requant_cycles += VAR_9;\n#endif\n\n\n    /* COMMENT_10 */\n    pns_decode(VAR_1, NULL, VAR_7, NULL, VAR_0->frameLength, 0, VAR_0->object_type,\n        &(VAR_0->__r1), &(VAR_0->__r2));\n\n#ifdef VAR_13\n    /* COMMENT_11 */\n    if (VAR_0->object_type == VAR_14)\n    {\n\t\tif (!VAR_0->pred_stat[VAR_2->channel])\n\t\t\treturn 33;\n\n        /* COMMENT_12 */\n        ic_prediction(VAR_1, VAR_7, VAR_0->pred_stat[VAR_2->channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n\n        /* COMMENT_13 */\n                                                             \n                                                         \n          \n        pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_2->channel]);\n    }\n#endif\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n#ifdef VAR_16\n        if (VAR_0->object_type == VAR_17)\n        {\n            if (VAR_1->ltp.data_present)\n            {\n                if (VAR_1->ltp.lag_update)\n                    VAR_0->ltp_lag[VAR_2->channel] = VAR_1->ltp.lag;\n            }\n            VAR_1->ltp.lag = VAR_0->ltp_lag[VAR_2->channel];\n        }\n#endif\n\n        /* COMMENT_17 */\n        lt_prediction(VAR_1, &(VAR_1->ltp), VAR_7, VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->fb,\n            VAR_1->window_shape, VAR_0->window_shape_prev[VAR_2->channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_18 */\n    tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_7, VAR_0->frameLength);\n\n    /* COMMENT_19 */\n    if (VAR_0->drc->present)\n    {\n        if (!VAR_0->drc->exclude_mask[VAR_2->channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_7);\n    }\n\n    /* COMMENT_20 */\n#ifdef VAR_18\n    if (VAR_0->object_type != VAR_19)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7,\n            VAR_0->time_out[VAR_2->channel], VAR_0->fb_intermed[VAR_2->channel],\n            VAR_0->object_type, VAR_0->frameLength);\n#ifdef VAR_18\n    } else {\n        ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7, VAR_0->time_out[VAR_2->channel],\n            VAR_0->ssr_overlap[VAR_2->channel], VAR_0->ipqf_buffer[VAR_2->channel], VAR_0->prev_fmd[VAR_2->channel],\n            VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_21 */\n    VAR_0->window_shape_prev[VAR_2->channel] = VAR_1->window_shape;\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        lt_update_state(VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->time_out[VAR_2->channel],\n            VAR_0->fb_intermed[VAR_2->channel], VAR_0->frameLength, VAR_0->object_type);\n    }\n#endif\n\n#ifdef VAR_20\n    if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n\n        /* COMMENT_22 */\n        if (VAR_0->sbr[VAR_21] == NULL)\n        {\n            VAR_0->sbr[VAR_21] = sbrDecodeInit(VAR_0->frameLength,\n                VAR_0->element_id[VAR_21], 2*get_sample_rate(VAR_0->sf_index),\n                VAR_0->downSampledSBR\n#ifdef VAR_10\n                , 0\n#endif\n                );\n        }\n\n        if (VAR_2->ics1.window_sequence == VAR_23)\n            VAR_0->sbr[VAR_21]->maxAACLine = 8*min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n        else\n            VAR_0->sbr[VAR_21]->maxAACLine = min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n\n        /* COMMENT_23 */\n#if (defined(VAR_12) || defined(VAR_11))\n        if (VAR_0->ps_used[VAR_21] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);\n#if (defined(VAR_12) || defined(VAR_11))\n        } else {\n            VAR_4 = sbrDecodeSingleFramePS(VAR_0->sbr[VAR_21], VAR_0->time_out[VAR_22],\n                VAR_0->time_out[VAR_22+1], VAR_0->postSeekResetFlag,\n                VAR_0->downSampledSBR);\n        }\n#endif\n        if (VAR_4 > 0)\n            return VAR_4;\n    } else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* COMMENT_24 */\n#if (defined(VAR_12) || defined(VAR_11))\n    if ((VAR_0->ps_used[VAR_0->fr_ch_ele] == 0) &&\n        (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2))\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n        int VAR_24 = (VAR_0->sbr_alloced[VAR_21]) ? 2 : 1;\n        VAR_24 *= VAR_0->frameLength*sizeof(VAR_6);\n\n        memcpy(VAR_0->time_out[VAR_22+1], VAR_0->time_out[VAR_22], VAR_24);\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path_before": "knik0/faad2/c78251b2b5d41ea840fd61ab9502b3d3036bd747/specrec.c/vul/before/1.json",
  "func": "uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \"suddenly\" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency */\n\n        /* this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        /* reset the allocation */\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n\n        //return 21;\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n    /* sanity check, CVE-2018-20199, CVE-2018-20360 */\n    if(!hDecoder->time_out[sce->channel])\n        return 15;\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n        if (!hDecoder->sbr[ele])\n            return 19;\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func": "uint8_t reconstruct_single_channel(NeAACDecStruct *VAR_0, ic_stream *VAR_1,\n                                   element *VAR_2, int16_t *VAR_3)\n{\n    uint8_t VAR_4;\n    int VAR_5;\n    ALIGN VAR_6 VAR_7[1024];\n\n#ifdef VAR_8\n    int64_t VAR_9 = faad_get_ts();\n#endif\n\n\n    /* COMMENT_0 */\n#if ( (defined(VAR_10) && defined(VAR_11)) )\n    VAR_5 = 2;\n#elif defined(VAR_12)\n    if (VAR_0->ps_used[VAR_0->fr_ch_ele])\n        VAR_5 = 2;\n    else\n        VAR_5 = 1;\n#else\n    VAR_5 = 1;\n#endif\n\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n    {\n        /* COMMENT_1 */\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n    } else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != VAR_5) {\n        /* COMMENT_2 */\n\n        /* COMMENT_3 */\n                                                             \n           \n\n        /* COMMENT_6 */\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 0;\n\n        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;\n\n        /* COMMENT_7 */\n    }\n\n    if (VAR_0->element_alloced[VAR_0->fr_ch_ele] == 0)\n    {\n        VAR_4 = allocate_single_channel(VAR_0, VAR_2->channel, VAR_5);\n        if (VAR_4 > 0)\n            return VAR_4;\n\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 1;\n    }\n\n    /* COMMENT_8 */\n    if(!VAR_0->time_out[VAR_2->channel])\n        return 15;\n\n    /* COMMENT_9 */\n    VAR_4 = quant_to_spec(VAR_0, VAR_1, VAR_3, VAR_7, VAR_0->frameLength);\n    if (VAR_4 > 0)\n        return VAR_4;\n\n#ifdef VAR_8\n    VAR_9 = faad_get_ts() - VAR_9;\n    VAR_0->requant_cycles += VAR_9;\n#endif\n\n\n    /* COMMENT_10 */\n    pns_decode(VAR_1, NULL, VAR_7, NULL, VAR_0->frameLength, 0, VAR_0->object_type,\n        &(VAR_0->__r1), &(VAR_0->__r2));\n\n#ifdef VAR_13\n    /* COMMENT_11 */\n    if (VAR_0->object_type == VAR_14)\n    {\n\t\tif (!VAR_0->pred_stat[VAR_2->channel])\n\t\t\treturn 33;\n\n        /* COMMENT_12 */\n        ic_prediction(VAR_1, VAR_7, VAR_0->pred_stat[VAR_2->channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n\n        /* COMMENT_13 */\n                                                             \n                                                         \n          \n        pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_2->channel]);\n    }\n#endif\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n#ifdef VAR_16\n        if (VAR_0->object_type == VAR_17)\n        {\n            if (VAR_1->ltp.data_present)\n            {\n                if (VAR_1->ltp.lag_update)\n                    VAR_0->ltp_lag[VAR_2->channel] = VAR_1->ltp.lag;\n            }\n            VAR_1->ltp.lag = VAR_0->ltp_lag[VAR_2->channel];\n        }\n#endif\n\n        /* COMMENT_17 */\n        lt_prediction(VAR_1, &(VAR_1->ltp), VAR_7, VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->fb,\n            VAR_1->window_shape, VAR_0->window_shape_prev[VAR_2->channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_18 */\n    tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_7, VAR_0->frameLength);\n\n    /* COMMENT_19 */\n    if (VAR_0->drc->present)\n    {\n        if (!VAR_0->drc->exclude_mask[VAR_2->channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_7);\n    }\n\n    /* COMMENT_20 */\n#ifdef VAR_18\n    if (VAR_0->object_type != VAR_19)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7,\n            VAR_0->time_out[VAR_2->channel], VAR_0->fb_intermed[VAR_2->channel],\n            VAR_0->object_type, VAR_0->frameLength);\n#ifdef VAR_18\n    } else {\n        ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,\n            VAR_0->window_shape_prev[VAR_2->channel], VAR_7, VAR_0->time_out[VAR_2->channel],\n            VAR_0->ssr_overlap[VAR_2->channel], VAR_0->ipqf_buffer[VAR_2->channel], VAR_0->prev_fmd[VAR_2->channel],\n            VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_21 */\n    VAR_0->window_shape_prev[VAR_2->channel] = VAR_1->window_shape;\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        lt_update_state(VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->time_out[VAR_2->channel],\n            VAR_0->fb_intermed[VAR_2->channel], VAR_0->frameLength, VAR_0->object_type);\n    }\n#endif\n\n#ifdef VAR_20\n    if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n\n        /* COMMENT_22 */\n        if (VAR_0->sbr[VAR_21] == NULL)\n        {\n            VAR_0->sbr[VAR_21] = sbrDecodeInit(VAR_0->frameLength,\n                VAR_0->element_id[VAR_21], 2*get_sample_rate(VAR_0->sf_index),\n                VAR_0->downSampledSBR\n#ifdef VAR_10\n                , 0\n#endif\n                );\n        }\n        if (!VAR_0->sbr[VAR_21])\n            return 19;\n\n        if (VAR_2->ics1.window_sequence == VAR_23)\n            VAR_0->sbr[VAR_21]->maxAACLine = 8*min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n        else\n            VAR_0->sbr[VAR_21]->maxAACLine = min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);\n\n        /* COMMENT_23 */\n#if (defined(VAR_12) || defined(VAR_11))\n        if (VAR_0->ps_used[VAR_21] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);\n#if (defined(VAR_12) || defined(VAR_11))\n        } else {\n            VAR_4 = sbrDecodeSingleFramePS(VAR_0->sbr[VAR_21], VAR_0->time_out[VAR_22],\n                VAR_0->time_out[VAR_22+1], VAR_0->postSeekResetFlag,\n                VAR_0->downSampledSBR);\n        }\n#endif\n        if (VAR_4 > 0)\n            return VAR_4;\n    } else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* COMMENT_24 */\n#if (defined(VAR_12) || defined(VAR_11))\n    if ((VAR_0->ps_used[VAR_0->fr_ch_ele] == 0) &&\n        (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2))\n    {\n        int VAR_21 = VAR_0->fr_ch_ele;\n        int VAR_22 = VAR_2->channel;\n        int VAR_24 = (VAR_0->sbr_alloced[VAR_21]) ? 2 : 1;\n        VAR_24 *= VAR_0->frameLength*sizeof(VAR_6);\n\n        memcpy(VAR_0->time_out[VAR_22+1], VAR_0->time_out[VAR_22], VAR_24);\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path": "knik0/faad2/c78251b2b5d41ea840fd61ab9502b3d3036bd747/specrec.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -168,6 +168,8 @@\n #endif\n                 );\n         }\n+        if (!hDecoder->sbr[ele])\n+            return 19;\n \n         if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n             hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (!hDecoder->sbr[ele])",
      "            return 19;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/63",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/knik0/faad2/pull/63: 403 Client Error: Forbidden for url: https://api.github.com/repos/knik0/faad2/pulls/63",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "The patch modifies the frame length restrictions and adds checks for SBR objects, which could prevent errors or crashes, but the commit message and description don't specifically mention security. It's more likely a bug fix related to core functionality, not a security issue.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.6"
}