{
  "cve_id": "CVE-2019-13351",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "jackaudio/jack2",
  "commit_msg": "Set fSocket to -1 after close on an error to prevent a double close.\n\nSigned-off-by: Joe Yasi <joe.yasi@gmail.com>",
  "commit_hash": "994e225bbb07a89f56147f7ce7d59beb49f8cfba",
  "git_url": "https://github.com/jackaudio/jack2/commit/994e225bbb07a89f56147f7ce7d59beb49f8cfba",
  "file_path": "posix/JackSocket.cpp",
  "func_name": "JackServerSocket::Bind",
  "func_before": "int JackServerSocket::Bind(const char* dir, const char* name, int which) // A revoir : utilisation de \"which\"\n{\n    struct sockaddr_un addr;\n\n    if ((fSocket = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        jack_error(\"Cannot create server socket err = %s\", strerror(errno));\n        return -1;\n    }\n\n    addr.sun_family = AF_UNIX;\n    // Socket name has to be kept in fName to be \"unlinked\".\n    BuildName(name, fName, dir, which, sizeof(addr.sun_path), fPromiscuous);\n    strncpy(addr.sun_path, fName, sizeof(addr.sun_path) - 1);\n   \n    jack_log(\"JackServerSocket::Bind : addr.sun_path %s\", addr.sun_path);\n    unlink(fName); // Security...\n\n    if (bind(fSocket, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n        jack_error(\"Cannot bind server to socket err = %s\", strerror(errno));\n        goto error;\n    }\n\n    if (listen(fSocket, 100) < 0) {\n        jack_error(\"Cannot enable listen on server socket err = %s\", strerror(errno));\n        goto error;\n    }\n\n    if (fPromiscuous && (jack_promiscuous_perms(-1, fName, fPromiscuousGid) < 0))\n        goto error;\n\n    return 0;\n\nerror:\n    unlink(fName);\n    close(fSocket);\n    return -1;\n}",
  "abstract_func_before": "int JackServerSocket::Bind(const char* VAR_0, const char* VAR_1, int VAR_2) /* COMMENT_0 */\n{\n    struct sockaddr_un VAR_3;\n\n    if ((VAR_4 = socket(VAR_5, VAR_6, 0)) < 0) {\n        jack_error(\"Cannot create server socket err = %s\", strerror(VAR_7));\n        return -1;\n    }\n\n    VAR_3.sun_family = VAR_5;\n    /* COMMENT_1 */\n    BuildName(VAR_1, VAR_8, VAR_0, VAR_2, sizeof(VAR_3.sun_path), VAR_9);\n    strncpy(VAR_3.sun_path, VAR_8, sizeof(VAR_3.sun_path) - 1);\n   \n    jack_log(\"JackServerSocket::Bind : addr.sun_path %s\", VAR_3.sun_path);\n    unlink(VAR_8); /* COMMENT_2 */\n\n    if (bind(VAR_4, (struct sockaddr*)&VAR_3, sizeof(VAR_3)) < 0) {\n        jack_error(\"Cannot bind server to socket err = %s\", strerror(VAR_7));\n        goto error;\n    }\n\n    if (listen(VAR_4, 100) < 0) {\n        jack_error(\"Cannot enable listen on server socket err = %s\", strerror(VAR_7));\n        goto error;\n    }\n\n    if (VAR_9 && (jack_promiscuous_perms(-1, VAR_8, VAR_10) < 0))\n        goto error;\n\n    return 0;\n\nerror:\n    unlink(VAR_8);\n    close(VAR_4);\n    return -1;\n}",
  "func_graph_path_before": "jackaudio/jack2/994e225bbb07a89f56147f7ce7d59beb49f8cfba/JackSocket.cpp/vul/before/0.json",
  "func": "int JackServerSocket::Bind(const char* dir, const char* name, int which) // A revoir : utilisation de \"which\"\n{\n    struct sockaddr_un addr;\n\n    if ((fSocket = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n        jack_error(\"Cannot create server socket err = %s\", strerror(errno));\n        return -1;\n    }\n\n    addr.sun_family = AF_UNIX;\n    // Socket name has to be kept in fName to be \"unlinked\".\n    BuildName(name, fName, dir, which, sizeof(addr.sun_path), fPromiscuous);\n    strncpy(addr.sun_path, fName, sizeof(addr.sun_path) - 1);\n   \n    jack_log(\"JackServerSocket::Bind : addr.sun_path %s\", addr.sun_path);\n    unlink(fName); // Security...\n\n    if (bind(fSocket, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n        jack_error(\"Cannot bind server to socket err = %s\", strerror(errno));\n        goto error;\n    }\n\n    if (listen(fSocket, 100) < 0) {\n        jack_error(\"Cannot enable listen on server socket err = %s\", strerror(errno));\n        goto error;\n    }\n\n    if (fPromiscuous && (jack_promiscuous_perms(-1, fName, fPromiscuousGid) < 0))\n        goto error;\n\n    return 0;\n\nerror:\n    unlink(fName);\n    close(fSocket);\n    fSocket = -1;\n    return -1;\n}",
  "abstract_func": "int JackServerSocket::Bind(const char* VAR_0, const char* VAR_1, int VAR_2) /* COMMENT_0 */\n{\n    struct sockaddr_un VAR_3;\n\n    if ((VAR_4 = socket(VAR_5, VAR_6, 0)) < 0) {\n        jack_error(\"Cannot create server socket err = %s\", strerror(VAR_7));\n        return -1;\n    }\n\n    VAR_3.sun_family = VAR_5;\n    /* COMMENT_1 */\n    BuildName(VAR_1, VAR_8, VAR_0, VAR_2, sizeof(VAR_3.sun_path), VAR_9);\n    strncpy(VAR_3.sun_path, VAR_8, sizeof(VAR_3.sun_path) - 1);\n   \n    jack_log(\"JackServerSocket::Bind : addr.sun_path %s\", VAR_3.sun_path);\n    unlink(VAR_8); /* COMMENT_2 */\n\n    if (bind(VAR_4, (struct sockaddr*)&VAR_3, sizeof(VAR_3)) < 0) {\n        jack_error(\"Cannot bind server to socket err = %s\", strerror(VAR_7));\n        goto error;\n    }\n\n    if (listen(VAR_4, 100) < 0) {\n        jack_error(\"Cannot enable listen on server socket err = %s\", strerror(VAR_7));\n        goto error;\n    }\n\n    if (VAR_9 && (jack_promiscuous_perms(-1, VAR_8, VAR_10) < 0))\n        goto error;\n\n    return 0;\n\nerror:\n    unlink(VAR_8);\n    close(VAR_4);\n    VAR_4 = -1;\n    return -1;\n}",
  "func_graph_path": "jackaudio/jack2/994e225bbb07a89f56147f7ce7d59beb49f8cfba/JackSocket.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -33,5 +33,6 @@\n error:\n     unlink(fName);\n     close(fSocket);\n+    fSocket = -1;\n     return -1;\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    fSocket = -1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jackaudio/jack2/pull/480",
  "description": {
    "pr_info": {
      "title": "Set fSocket to -1 after close on an error to prevent a double close.",
      "number": 480
    },
    "comment": [
      "Since alsa-plugins >= 1.1.7 now enables the ALSA jack plugin by default with 50-jack.conf, I've been seeing sporadic crashes in Kodi when the sound devices get reenumerated for a udev event. I traced this down to a double close on the audio engine thread concurrent with a close on the udev thread which asserts on EBADF in libudev causing the crash.\r\nAn strace pointed to the double close occuring in posix/JackSocket.cpp:139 and posix/JackSocket.cpp:158.\r\nTo fix this, reset fSocket to -1 after closing on an error to prevent a double close later.\r\nSigned-off-by: Joe Yasi <joe.yasi@gmail.com>",
      "Makes sense, thank you.",
      "Hi Filipe,\n\nAs a follow up, this is a security bug as a double close can cause\nunintended information disclosure in multithreaded programs depending upon\ntiming of the 2nd close. Ubuntu has requested a CVE be filed:\nhttps://cveform.mitre.org/ so I am filing one. From looking through the git\nhistory, this vulnerability looks like it's been around since 2009 in\nversion 1.9.1.\n\n-Joe\n\nOn Wed, Jun 19, 2019 at 6:40 AM Filipe Coelho <notifications@github.com>\nwrote:\n\n> Merged #480 <https://github.com/jackaudio/jack2/pull/480> into develop.\n>\n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/jackaudio/jack2/pull/480?email_source=notifications&email_token=AA22OAAEUP7OTTF6AS7WOILP3IELFA5CNFSM4HZF2PX2YY3PNVWWK3TUL52HS4DFWZEXG43VMVCXMZLOORHG65DJMZUWGYLUNFXW5KTDN5WW2ZLOORPWSZGOSB3LOWY#event-2423699291>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AA22OACNJ4K2GAVVPCODUZLP3IELFANCNFSM4HZF2PXQ>\n> .\n>\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades\n\n**Confidence:** 0.9"
}