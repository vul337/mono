{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/t1_lib.c",
  "func_name": "ssl_scan_serverhello_tlsext",
  "func_before": "static int ssl_scan_serverhello_tlsext(SSL *s, PACKET *pkt, int *al)\n{\n    unsigned int length, type, size;\n    int tlsext_servername = 0;\n    int renegotiate_seen = 0;\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n#endif\n    s->tlsext_ticket_expected = 0;\n\n    OPENSSL_free(s->s3->alpn_selected);\n    s->s3->alpn_selected = NULL;\n#ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED |\n                             SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n\n    s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;\n\n    if (!PACKET_get_net_2(pkt, &length))\n        goto ri_check;\n\n    if (PACKET_remaining(pkt) != length) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    if (!tls1_check_duplicate_extensions(pkt)) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    while (PACKET_get_net_2(pkt, &type) && PACKET_get_net_2(pkt, &size)) {\n        const unsigned char *data;\n        PACKET spkt;\n\n        if (!PACKET_get_sub_packet(pkt, &spkt, size)\n            || !PACKET_peek_bytes(&spkt, &data, size))\n            goto ri_check;\n\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);\n\n        if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_serverhello_renegotiate_ext(s, &spkt, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (s->version == SSL3_VERSION) {\n        } else if (type == TLSEXT_TYPE_server_name) {\n            if (s->tlsext_hostname == NULL || size > 0) {\n                *al = TLS1_AD_UNRECOGNIZED_NAME;\n                return 0;\n            }\n            tlsext_servername = 1;\n        }\n#ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            unsigned int ecpointformatlist_length;\n            if (!PACKET_get_1(&spkt, &ecpointformatlist_length)\n                || ecpointformatlist_length != size - 1) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            if (!s->hit) {\n                s->session->tlsext_ecpointformatlist_length = 0;\n                OPENSSL_free(s->session->tlsext_ecpointformatlist);\n                if ((s->session->tlsext_ecpointformatlist =\n                     OPENSSL_malloc(ecpointformatlist_length)) == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                s->session->tlsext_ecpointformatlist_length =\n                    ecpointformatlist_length;\n                if (!PACKET_copy_bytes(&spkt,\n                                       s->session->tlsext_ecpointformatlist,\n                                       ecpointformatlist_length)) {\n                    *al = TLS1_AD_DECODE_ERROR;\n                    return 0;\n                }\n\n            }\n        }\n#endif                          /* OPENSSL_NO_EC */\n\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, data, size,\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            if (!tls_use_ticket(s) || (size > 0)) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            s->tlsext_ticket_expected = 1;\n        } else if (type == TLSEXT_TYPE_status_request) {\n            /*\n             * MUST be empty and only sent if we've requested a status\n             * request message.\n             */\n            if ((s->tlsext_status_type == -1) || (size > 0)) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /* Set flag to expect CertificateStatus message */\n            s->tlsext_status_expected = 1;\n        }\n#ifndef OPENSSL_NO_CT\n        /*\n         * Only take it if we asked for it - i.e if there is no CT validation\n         * callback set, then a custom extension MAY be processing it, so we\n         * need to let control continue to flow to that.\n         */\n        else if (type == TLSEXT_TYPE_signed_certificate_timestamp &&\n                 s->ct_validation_callback != NULL) {\n            /* Simply copy it off for later processing */\n            if (s->tlsext_scts != NULL) {\n                OPENSSL_free(s->tlsext_scts);\n                s->tlsext_scts = NULL;\n            }\n            s->tlsext_scts_len = size;\n            if (size > 0) {\n                s->tlsext_scts = OPENSSL_malloc(size);\n                if (s->tlsext_scts == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                memcpy(s->tlsext_scts, data, size);\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            unsigned char *selected;\n            unsigned char selected_len;\n            /* We must have requested it. */\n            if (s->ctx->next_proto_select_cb == NULL) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /* The data must be valid */\n            if (!ssl_next_proto_validate(&spkt)) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data,\n                                             size,\n                                             s->\n                                             ctx->next_proto_select_cb_arg) !=\n                SSL_TLSEXT_ERR_OK) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            /*\n             * Could be non-NULL if server has sent multiple NPN extensions in\n             * a single Serverhello\n             */\n            OPENSSL_free(s->next_proto_negotiated);\n            s->next_proto_negotiated = OPENSSL_malloc(selected_len);\n            if (s->next_proto_negotiated == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            memcpy(s->next_proto_negotiated, selected, selected_len);\n            s->next_proto_negotiated_len = selected_len;\n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {\n            unsigned len;\n            /* We must have requested it. */\n            if (!s->s3->alpn_sent) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /*-\n             * The extension data consists of:\n             *   uint16 list_length\n             *   uint8 proto_length;\n             *   uint8 proto[proto_length];\n             */\n            if (!PACKET_get_net_2(&spkt, &len)\n                || PACKET_remaining(&spkt) != len || !PACKET_get_1(&spkt, &len)\n                || PACKET_remaining(&spkt) != len) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            OPENSSL_free(s->s3->alpn_selected);\n            s->s3->alpn_selected = OPENSSL_malloc(len);\n            if (s->s3->alpn_selected == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            if (!PACKET_copy_bytes(&spkt, s->s3->alpn_selected, len)) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            s->s3->alpn_selected_len = len;\n        }\n#ifndef OPENSSL_NO_HEARTBEATS\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) {\n            unsigned int hbtype;\n            if (!PACKET_get_1(&spkt, &hbtype)) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            switch (hbtype) {\n            case 0x01:         /* Server allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Server doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_serverhello_use_srtp_ext(s, &spkt, al))\n                return 0;\n        }\n#endif\n        else if (type == TLSEXT_TYPE_encrypt_then_mac) {\n            /* Ignore if inappropriate ciphersuite */\n            if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD\n                && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)\n                s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n        } else if (type == TLSEXT_TYPE_extended_master_secret) {\n            s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;\n            if (!s->hit)\n                s->session->flags |= SSL_SESS_FLAG_EXTMS;\n        }\n        /*\n         * If this extension type was not otherwise handled, but matches a\n         * custom_cli_ext_record, then send it to the c callback\n         */\n        else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\n            return 0;\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    if (!s->hit && tlsext_servername == 1) {\n        if (s->tlsext_hostname) {\n            if (s->session->tlsext_hostname == NULL) {\n                s->session->tlsext_hostname =\n                    OPENSSL_strdup(s->tlsext_hostname);\n                if (!s->session->tlsext_hostname) {\n                    *al = SSL_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n            } else {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n        }\n    }\n\n ri_check:\n\n    /*\n     * Determine if we need to see RI. Strictly speaking if we want to avoid\n     * an attack we should *always* see RI even on initial server hello\n     * because the client doesn't see any renegotiation during an attack.\n     * However this would mean we could not connect to any server which\n     * doesn't support RI so for the immediate future tolerate RI absence\n     */\n    if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\n        && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    if (s->hit) {\n        /*\n         * Check extended master secret extension is consistent with\n         * original session.\n         */\n        if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) !=\n            !(s->session->flags & SSL_SESS_FLAG_EXTMS)) {\n            *al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT, SSL_R_INCONSISTENT_EXTMS);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
  "abstract_func_before": "static int ssl_scan_serverhello_tlsext(SSL *VAR_0, PACKET *VAR_1, int *VAR_2)\n{\n    unsigned int VAR_3, VAR_4, VAR_5;\n    int VAR_6 = 0;\n    int VAR_7 = 0;\n\n#ifndef VAR_8\n    VAR_0->s3->next_proto_neg_seen = 0;\n#endif\n    VAR_0->tlsext_ticket_expected = 0;\n\n    OPENSSL_free(VAR_0->s3->alpn_selected);\n    VAR_0->s3->alpn_selected = NULL;\n#ifndef VAR_9\n    VAR_0->tlsext_heartbeat &= ~(VAR_10 |\n                             VAR_11);\n#endif\n\n    VAR_0->s3->flags &= ~VAR_12;\n\n    VAR_0->s3->flags &= ~VAR_13;\n\n    if (!PACKET_get_net_2(VAR_1, &VAR_3))\n        goto ri_check;\n\n    if (PACKET_remaining(VAR_1) != VAR_3) {\n        *VAR_2 = VAR_14;\n        return 0;\n    }\n\n    if (!tls1_check_duplicate_extensions(VAR_1)) {\n        *VAR_2 = VAR_14;\n        return 0;\n    }\n\n    while (PACKET_get_net_2(VAR_1, &VAR_4) && PACKET_get_net_2(VAR_1, &VAR_5)) {\n        const unsigned char *VAR_15;\n        PACKET VAR_16;\n\n        if (!PACKET_get_sub_packet(VAR_1, &VAR_16, VAR_5)\n            || !PACKET_peek_bytes(&VAR_16, &VAR_15, VAR_5))\n            goto ri_check;\n\n        if (VAR_0->tlsext_debug_cb)\n            VAR_0->tlsext_debug_cb(VAR_0, 1, VAR_4, VAR_15, VAR_5, VAR_0->tlsext_debug_arg);\n\n        if (VAR_4 == VAR_17) {\n            if (!ssl_parse_serverhello_renegotiate_ext(VAR_0, &VAR_16, VAR_2))\n                return 0;\n            VAR_7 = 1;\n        } else if (VAR_0->version == VAR_18) {\n        } else if (VAR_4 == VAR_19) {\n            if (VAR_0->tlsext_hostname == NULL || VAR_5 > 0) {\n                *VAR_2 = VAR_20;\n                return 0;\n            }\n            VAR_6 = 1;\n        }\n#ifndef VAR_21\n        else if (type == VAR_22) {\n            unsigned int VAR_23;\n            if (!PACKET_get_1(&VAR_16, &VAR_23)\n                || VAR_23 != VAR_5 - 1) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            if (!VAR_0->hit) {\n                VAR_0->session->tlsext_ecpointformatlist_length = 0;\n                OPENSSL_free(VAR_0->session->tlsext_ecpointformatlist);\n                if ((VAR_0->session->tlsext_ecpointformatlist =\n                     OPENSSL_malloc(VAR_23)) == NULL) {\n                    *VAR_2 = VAR_25;\n                    return 0;\n                }\n                VAR_0->session->tlsext_ecpointformatlist_length =\n                    VAR_23;\n                if (!PACKET_copy_bytes(&VAR_16,\n                                       VAR_0->session->tlsext_ecpointformatlist,\n                                       VAR_23)) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n\n            }\n        }\n#endif                          /* COMMENT_0 */\n\n        else if (type == VAR_26) {\n            if (VAR_0->tls_session_ticket_ext_cb &&\n                !VAR_0->tls_session_ticket_ext_cb(VAR_0, VAR_15, VAR_5,\n                                              VAR_0->tls_session_ticket_ext_cb_arg))\n            {\n                *VAR_2 = VAR_25;\n                return 0;\n            }\n            if (!tls_use_ticket(VAR_0) || (VAR_5 > 0)) {\n                *VAR_2 = VAR_27;\n                return 0;\n            }\n            VAR_0->tlsext_ticket_expected = 1;\n        } else if (type == VAR_28) {\n            /* COMMENT_1 */\n                                                                      \n                               \n               \n            if ((VAR_0->tlsext_status_type == -1) || (VAR_5 > 0)) {\n                *VAR_2 = VAR_27;\n                return 0;\n            }\n            /* COMMENT_5 */\n            VAR_0->tlsext_status_expected = 1;\n        }\n#ifndef VAR_29\n        /* COMMENT_6 */\n                                                                             \n                                                                            \n                                                        \n           \n        else if (type == VAR_30 &&\n                 VAR_0->VAR_31 != NULL) {\n            /* COMMENT_11 */\n            if (VAR_0->tlsext_scts != NULL) {\n                OPENSSL_free(VAR_0->tlsext_scts);\n                VAR_0->tlsext_scts = NULL;\n            }\n            VAR_0->tlsext_scts_len = VAR_5;\n            if (VAR_5 > 0) {\n                VAR_0->tlsext_scts = OPENSSL_malloc(VAR_5);\n                if (VAR_0->tlsext_scts == NULL) {\n                    *VAR_2 = VAR_25;\n                    return 0;\n                }\n                memcpy(VAR_0->tlsext_scts, VAR_15, VAR_5);\n            }\n        }\n#endif\n#ifndef VAR_8\n        else if (type == VAR_32 &&\n                 VAR_0->VAR_33->VAR_34.VAR_35 == 0) {\n            unsigned char *VAR_36;\n            unsigned char VAR_37;\n            /* COMMENT_12 */\n            if (VAR_0->ctx->next_proto_select_cb == NULL) {\n                *VAR_2 = VAR_27;\n                return 0;\n            }\n            /* COMMENT_13 */\n            if (!ssl_next_proto_validate(&VAR_16)) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            if (VAR_0->ctx->next_proto_select_cb(VAR_0, &VAR_36, &VAR_37, VAR_15,\n                                             VAR_5,\n                                             VAR_0->\n                                             ctx->next_proto_select_cb_arg) !=\n                VAR_38) {\n                *VAR_2 = VAR_25;\n                return 0;\n            }\n            /* COMMENT_14 */\n                                                                              \n                                   \n               \n            OPENSSL_free(VAR_0->next_proto_negotiated);\n            VAR_0->next_proto_negotiated = OPENSSL_malloc(VAR_37);\n            if (VAR_0->next_proto_negotiated == NULL) {\n                *VAR_2 = VAR_25;\n                return 0;\n            }\n            memcpy(VAR_0->next_proto_negotiated, VAR_36, VAR_37);\n            VAR_0->next_proto_negotiated_len = VAR_37;\n            VAR_0->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == VAR_39) {\n            unsigned VAR_40;\n            /* COMMENT_12 */\n            if (!VAR_0->s3->alpn_sent) {\n                *VAR_2 = VAR_27;\n                return 0;\n            }\n            /* COMMENT_18 */\n                                              \n                                   \n                                    \n                                           \n               \n            if (!PACKET_get_net_2(&VAR_16, &VAR_40)\n                || PACKET_remaining(&VAR_16) != VAR_40 || !PACKET_get_1(&VAR_16, &VAR_40)\n                || PACKET_remaining(&VAR_16) != VAR_40) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            OPENSSL_free(VAR_0->s3->alpn_selected);\n            VAR_0->s3->alpn_selected = OPENSSL_malloc(VAR_40);\n            if (VAR_0->s3->alpn_selected == NULL) {\n                *VAR_2 = VAR_25;\n                return 0;\n            }\n            if (!PACKET_copy_bytes(&VAR_16, VAR_0->s3->alpn_selected, VAR_40)) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            VAR_0->s3->alpn_selected_len = VAR_40;\n        }\n#ifndef VAR_9\n        else if (VAR_41(s) && type == VAR_42) {\n            unsigned int VAR_43;\n            if (!PACKET_get_1(&VAR_16, &VAR_43)) {\n                *VAR_2 = VAR_14;\n                return 0;\n            }\n            switch (VAR_43) {\n            case 0x01:         /* COMMENT_24 */\n                s->tlsext_heartbeat |= VAR_10;\n                break;\n            case 0x02:         /* COMMENT_25 */\n                s->tlsext_heartbeat |= VAR_10;\n                s->tlsext_heartbeat |= VAR_11;\n                break;\n            default:\n                *VAR_2 = VAR_44;\n                return 0;\n            }\n        }\n#endif\n#ifndef VAR_45\n        else if (VAR_41(s) && type == VAR_46) {\n            if (ssl_parse_serverhello_use_srtp_ext(s, &VAR_16, VAR_2))\n                return 0;\n        }\n#endif\n        else if (type == VAR_47) {\n            /* COMMENT_26 */\n            if (s->s3->tmp.new_cipher->algorithm_mac != VAR_48\n                && s->s3->tmp.new_cipher->algorithm_enc != VAR_49)\n                s->s3->flags |= VAR_12;\n        } else if (type == VAR_50) {\n            s->s3->flags |= VAR_13;\n            if (!s->hit)\n                s->session->flags |= VAR_51;\n        }\n        /* COMMENT_27 */\n                                                                          \n                                                                \n           \n        else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\n            return 0;\n    }\n\n    if (PACKET_remaining(VAR_1) != 0) {\n        *al = VAR_14;\n        return 0;\n    }\n\n    if (!s->hit && VAR_6 == 1) {\n        if (s->tlsext_hostname) {\n            if (s->session->tlsext_hostname == NULL) {\n                s->session->tlsext_hostname =\n                    OPENSSL_strdup(s->tlsext_hostname);\n                if (!s->session->tlsext_hostname) {\n                    *al = VAR_52;\n                    return 0;\n                }\n            } else {\n                *al = VAR_14;\n                return 0;\n            }\n        }\n    }\n\n ri_check:\n\n    /* COMMENT_31 */\n                                                                            \n                                                                       \n                                                                         \n                                                                       \n                                                                         \n       \n    if (!VAR_7 && !(s->options & VAR_53)\n        && !(s->options & VAR_54)) {\n        *al = VAR_55;\n        SSLerr(VAR_56,\n               VAR_57);\n        return 0;\n    }\n\n    if (s->hit) {\n        /* COMMENT_38 */\n                                                                    \n                            \n           \n        if (!(s->s3->flags & VAR_13) !=\n            !(s->session->flags & VAR_51)) {\n            *al = VAR_55;\n            SSLerr(VAR_56, VAR_58);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_lib.c/vul/before/0.json",
  "func": "static int ssl_scan_serverhello_tlsext(SSL *s, PACKET *pkt, int *al)\n{\n    unsigned int length, type, size;\n    int tlsext_servername = 0;\n    int renegotiate_seen = 0;\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n#endif\n    s->tlsext_ticket_expected = 0;\n\n    OPENSSL_free(s->s3->alpn_selected);\n    s->s3->alpn_selected = NULL;\n#ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED |\n                             SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n    s->tlsext_use_etm = 0;\n\n    s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;\n\n    if (!PACKET_get_net_2(pkt, &length))\n        goto ri_check;\n\n    if (PACKET_remaining(pkt) != length) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    if (!tls1_check_duplicate_extensions(pkt)) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    while (PACKET_get_net_2(pkt, &type) && PACKET_get_net_2(pkt, &size)) {\n        const unsigned char *data;\n        PACKET spkt;\n\n        if (!PACKET_get_sub_packet(pkt, &spkt, size)\n            || !PACKET_peek_bytes(&spkt, &data, size))\n            goto ri_check;\n\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);\n\n        if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_serverhello_renegotiate_ext(s, &spkt, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (s->version == SSL3_VERSION) {\n        } else if (type == TLSEXT_TYPE_server_name) {\n            if (s->tlsext_hostname == NULL || size > 0) {\n                *al = TLS1_AD_UNRECOGNIZED_NAME;\n                return 0;\n            }\n            tlsext_servername = 1;\n        }\n#ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            unsigned int ecpointformatlist_length;\n            if (!PACKET_get_1(&spkt, &ecpointformatlist_length)\n                || ecpointformatlist_length != size - 1) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            if (!s->hit) {\n                s->session->tlsext_ecpointformatlist_length = 0;\n                OPENSSL_free(s->session->tlsext_ecpointformatlist);\n                if ((s->session->tlsext_ecpointformatlist =\n                     OPENSSL_malloc(ecpointformatlist_length)) == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                s->session->tlsext_ecpointformatlist_length =\n                    ecpointformatlist_length;\n                if (!PACKET_copy_bytes(&spkt,\n                                       s->session->tlsext_ecpointformatlist,\n                                       ecpointformatlist_length)) {\n                    *al = TLS1_AD_DECODE_ERROR;\n                    return 0;\n                }\n\n            }\n        }\n#endif                          /* OPENSSL_NO_EC */\n\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, data, size,\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            if (!tls_use_ticket(s) || (size > 0)) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            s->tlsext_ticket_expected = 1;\n        } else if (type == TLSEXT_TYPE_status_request) {\n            /*\n             * MUST be empty and only sent if we've requested a status\n             * request message.\n             */\n            if ((s->tlsext_status_type == -1) || (size > 0)) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /* Set flag to expect CertificateStatus message */\n            s->tlsext_status_expected = 1;\n        }\n#ifndef OPENSSL_NO_CT\n        /*\n         * Only take it if we asked for it - i.e if there is no CT validation\n         * callback set, then a custom extension MAY be processing it, so we\n         * need to let control continue to flow to that.\n         */\n        else if (type == TLSEXT_TYPE_signed_certificate_timestamp &&\n                 s->ct_validation_callback != NULL) {\n            /* Simply copy it off for later processing */\n            if (s->tlsext_scts != NULL) {\n                OPENSSL_free(s->tlsext_scts);\n                s->tlsext_scts = NULL;\n            }\n            s->tlsext_scts_len = size;\n            if (size > 0) {\n                s->tlsext_scts = OPENSSL_malloc(size);\n                if (s->tlsext_scts == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                memcpy(s->tlsext_scts, data, size);\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            unsigned char *selected;\n            unsigned char selected_len;\n            /* We must have requested it. */\n            if (s->ctx->next_proto_select_cb == NULL) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /* The data must be valid */\n            if (!ssl_next_proto_validate(&spkt)) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data,\n                                             size,\n                                             s->\n                                             ctx->next_proto_select_cb_arg) !=\n                SSL_TLSEXT_ERR_OK) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            /*\n             * Could be non-NULL if server has sent multiple NPN extensions in\n             * a single Serverhello\n             */\n            OPENSSL_free(s->next_proto_negotiated);\n            s->next_proto_negotiated = OPENSSL_malloc(selected_len);\n            if (s->next_proto_negotiated == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            memcpy(s->next_proto_negotiated, selected, selected_len);\n            s->next_proto_negotiated_len = selected_len;\n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {\n            unsigned len;\n            /* We must have requested it. */\n            if (!s->s3->alpn_sent) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /*-\n             * The extension data consists of:\n             *   uint16 list_length\n             *   uint8 proto_length;\n             *   uint8 proto[proto_length];\n             */\n            if (!PACKET_get_net_2(&spkt, &len)\n                || PACKET_remaining(&spkt) != len || !PACKET_get_1(&spkt, &len)\n                || PACKET_remaining(&spkt) != len) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            OPENSSL_free(s->s3->alpn_selected);\n            s->s3->alpn_selected = OPENSSL_malloc(len);\n            if (s->s3->alpn_selected == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            if (!PACKET_copy_bytes(&spkt, s->s3->alpn_selected, len)) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            s->s3->alpn_selected_len = len;\n        }\n#ifndef OPENSSL_NO_HEARTBEATS\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) {\n            unsigned int hbtype;\n            if (!PACKET_get_1(&spkt, &hbtype)) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            switch (hbtype) {\n            case 0x01:         /* Server allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Server doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_serverhello_use_srtp_ext(s, &spkt, al))\n                return 0;\n        }\n#endif\n        else if (type == TLSEXT_TYPE_encrypt_then_mac) {\n            /* Ignore if inappropriate ciphersuite */\n            if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD\n                && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)\n                s->tlsext_use_etm = 1;\n        } else if (type == TLSEXT_TYPE_extended_master_secret) {\n            s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;\n            if (!s->hit)\n                s->session->flags |= SSL_SESS_FLAG_EXTMS;\n        }\n        /*\n         * If this extension type was not otherwise handled, but matches a\n         * custom_cli_ext_record, then send it to the c callback\n         */\n        else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\n            return 0;\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    if (!s->hit && tlsext_servername == 1) {\n        if (s->tlsext_hostname) {\n            if (s->session->tlsext_hostname == NULL) {\n                s->session->tlsext_hostname =\n                    OPENSSL_strdup(s->tlsext_hostname);\n                if (!s->session->tlsext_hostname) {\n                    *al = SSL_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n            } else {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n        }\n    }\n\n ri_check:\n\n    /*\n     * Determine if we need to see RI. Strictly speaking if we want to avoid\n     * an attack we should *always* see RI even on initial server hello\n     * because the client doesn't see any renegotiation during an attack.\n     * However this would mean we could not connect to any server which\n     * doesn't support RI so for the immediate future tolerate RI absence\n     */\n    if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\n        && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    if (s->hit) {\n        /*\n         * Check extended master secret extension is consistent with\n         * original session.\n         */\n        if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) !=\n            !(s->session->flags & SSL_SESS_FLAG_EXTMS)) {\n            *al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT, SSL_R_INCONSISTENT_EXTMS);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
  "abstract_func": "static int ssl_scan_serverhello_tlsext(SSL *VAR_0, PACKET *VAR_1, int *VAR_2)\n{\n    unsigned int VAR_3, VAR_4, VAR_5;\n    int VAR_6 = 0;\n    int VAR_7 = 0;\n\n#ifndef VAR_8\n    VAR_0->s3->next_proto_neg_seen = 0;\n#endif\n    VAR_0->tlsext_ticket_expected = 0;\n\n    OPENSSL_free(VAR_0->s3->alpn_selected);\n    VAR_0->s3->alpn_selected = NULL;\n#ifndef VAR_9\n    VAR_0->tlsext_heartbeat &= ~(VAR_10 |\n                             VAR_11);\n#endif\n\n    VAR_0->tlsext_use_etm = 0;\n\n    VAR_0->s3->flags &= ~VAR_12;\n\n    if (!PACKET_get_net_2(VAR_1, &VAR_3))\n        goto ri_check;\n\n    if (PACKET_remaining(VAR_1) != VAR_3) {\n        *VAR_2 = VAR_13;\n        return 0;\n    }\n\n    if (!tls1_check_duplicate_extensions(VAR_1)) {\n        *VAR_2 = VAR_13;\n        return 0;\n    }\n\n    while (PACKET_get_net_2(VAR_1, &VAR_4) && PACKET_get_net_2(VAR_1, &VAR_5)) {\n        const unsigned char *VAR_14;\n        PACKET VAR_15;\n\n        if (!PACKET_get_sub_packet(VAR_1, &VAR_15, VAR_5)\n            || !PACKET_peek_bytes(&VAR_15, &VAR_14, VAR_5))\n            goto ri_check;\n\n        if (VAR_0->tlsext_debug_cb)\n            VAR_0->tlsext_debug_cb(VAR_0, 1, VAR_4, VAR_14, VAR_5, VAR_0->tlsext_debug_arg);\n\n        if (VAR_4 == VAR_16) {\n            if (!ssl_parse_serverhello_renegotiate_ext(VAR_0, &VAR_15, VAR_2))\n                return 0;\n            VAR_7 = 1;\n        } else if (VAR_0->version == VAR_17) {\n        } else if (VAR_4 == VAR_18) {\n            if (VAR_0->tlsext_hostname == NULL || VAR_5 > 0) {\n                *VAR_2 = VAR_19;\n                return 0;\n            }\n            VAR_6 = 1;\n        }\n#ifndef VAR_20\n        else if (type == VAR_21) {\n            unsigned int VAR_22;\n            if (!PACKET_get_1(&VAR_15, &VAR_22)\n                || VAR_22 != VAR_5 - 1) {\n                *VAR_2 = VAR_23;\n                return 0;\n            }\n            if (!VAR_0->hit) {\n                VAR_0->session->tlsext_ecpointformatlist_length = 0;\n                OPENSSL_free(VAR_0->session->tlsext_ecpointformatlist);\n                if ((VAR_0->session->tlsext_ecpointformatlist =\n                     OPENSSL_malloc(VAR_22)) == NULL) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n                VAR_0->session->tlsext_ecpointformatlist_length =\n                    VAR_22;\n                if (!PACKET_copy_bytes(&VAR_15,\n                                       VAR_0->session->tlsext_ecpointformatlist,\n                                       VAR_22)) {\n                    *VAR_2 = VAR_23;\n                    return 0;\n                }\n\n            }\n        }\n#endif                          /* COMMENT_0 */\n\n        else if (type == VAR_25) {\n            if (VAR_0->tls_session_ticket_ext_cb &&\n                !VAR_0->tls_session_ticket_ext_cb(VAR_0, VAR_14, VAR_5,\n                                              VAR_0->tls_session_ticket_ext_cb_arg))\n            {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            if (!tls_use_ticket(VAR_0) || (VAR_5 > 0)) {\n                *VAR_2 = VAR_26;\n                return 0;\n            }\n            VAR_0->tlsext_ticket_expected = 1;\n        } else if (type == VAR_27) {\n            /* COMMENT_1 */\n                                                                      \n                               \n               \n            if ((VAR_0->tlsext_status_type == -1) || (VAR_5 > 0)) {\n                *VAR_2 = VAR_26;\n                return 0;\n            }\n            /* COMMENT_5 */\n            VAR_0->tlsext_status_expected = 1;\n        }\n#ifndef VAR_28\n        /* COMMENT_6 */\n                                                                             \n                                                                            \n                                                        \n           \n        else if (type == VAR_29 &&\n                 VAR_0->VAR_30 != NULL) {\n            /* COMMENT_11 */\n            if (VAR_0->tlsext_scts != NULL) {\n                OPENSSL_free(VAR_0->tlsext_scts);\n                VAR_0->tlsext_scts = NULL;\n            }\n            VAR_0->tlsext_scts_len = VAR_5;\n            if (VAR_5 > 0) {\n                VAR_0->tlsext_scts = OPENSSL_malloc(VAR_5);\n                if (VAR_0->tlsext_scts == NULL) {\n                    *VAR_2 = VAR_24;\n                    return 0;\n                }\n                memcpy(VAR_0->tlsext_scts, VAR_14, VAR_5);\n            }\n        }\n#endif\n#ifndef VAR_8\n        else if (type == VAR_31 &&\n                 VAR_0->VAR_32->VAR_33.VAR_34 == 0) {\n            unsigned char *VAR_35;\n            unsigned char VAR_36;\n            /* COMMENT_12 */\n            if (VAR_0->ctx->next_proto_select_cb == NULL) {\n                *VAR_2 = VAR_26;\n                return 0;\n            }\n            /* COMMENT_13 */\n            if (!ssl_next_proto_validate(&VAR_15)) {\n                *VAR_2 = VAR_23;\n                return 0;\n            }\n            if (VAR_0->ctx->next_proto_select_cb(VAR_0, &VAR_35, &VAR_36, VAR_14,\n                                             VAR_5,\n                                             VAR_0->\n                                             ctx->next_proto_select_cb_arg) !=\n                VAR_37) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            /* COMMENT_14 */\n                                                                              \n                                   \n               \n            OPENSSL_free(VAR_0->next_proto_negotiated);\n            VAR_0->next_proto_negotiated = OPENSSL_malloc(VAR_36);\n            if (VAR_0->next_proto_negotiated == NULL) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            memcpy(VAR_0->next_proto_negotiated, VAR_35, VAR_36);\n            VAR_0->next_proto_negotiated_len = VAR_36;\n            VAR_0->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == VAR_38) {\n            unsigned VAR_39;\n            /* COMMENT_12 */\n            if (!VAR_0->s3->alpn_sent) {\n                *VAR_2 = VAR_26;\n                return 0;\n            }\n            /* COMMENT_18 */\n                                              \n                                   \n                                    \n                                           \n               \n            if (!PACKET_get_net_2(&VAR_15, &VAR_39)\n                || PACKET_remaining(&VAR_15) != VAR_39 || !PACKET_get_1(&VAR_15, &VAR_39)\n                || PACKET_remaining(&VAR_15) != VAR_39) {\n                *VAR_2 = VAR_23;\n                return 0;\n            }\n            OPENSSL_free(VAR_0->s3->alpn_selected);\n            VAR_0->s3->alpn_selected = OPENSSL_malloc(VAR_39);\n            if (VAR_0->s3->alpn_selected == NULL) {\n                *VAR_2 = VAR_24;\n                return 0;\n            }\n            if (!PACKET_copy_bytes(&VAR_15, VAR_0->s3->alpn_selected, VAR_39)) {\n                *VAR_2 = VAR_23;\n                return 0;\n            }\n            VAR_0->s3->alpn_selected_len = VAR_39;\n        }\n#ifndef VAR_9\n        else if (VAR_40(s) && type == VAR_41) {\n            unsigned int VAR_42;\n            if (!PACKET_get_1(&VAR_15, &VAR_42)) {\n                *VAR_2 = VAR_13;\n                return 0;\n            }\n            switch (VAR_42) {\n            case 0x01:         /* COMMENT_24 */\n                s->tlsext_heartbeat |= VAR_10;\n                break;\n            case 0x02:         /* COMMENT_25 */\n                s->tlsext_heartbeat |= VAR_10;\n                s->tlsext_heartbeat |= VAR_11;\n                break;\n            default:\n                *VAR_2 = VAR_43;\n                return 0;\n            }\n        }\n#endif\n#ifndef VAR_44\n        else if (VAR_40(s) && type == VAR_45) {\n            if (ssl_parse_serverhello_use_srtp_ext(s, &VAR_15, VAR_2))\n                return 0;\n        }\n#endif\n        else if (type == VAR_46) {\n            /* COMMENT_26 */\n            if (s->s3->tmp.new_cipher->algorithm_mac != VAR_47\n                && s->s3->tmp.new_cipher->algorithm_enc != VAR_48)\n                s->tlsext_use_etm = 1;\n        } else if (type == VAR_49) {\n            s->s3->flags |= VAR_12;\n            if (!s->hit)\n                s->session->flags |= VAR_50;\n        }\n        /* COMMENT_27 */\n                                                                          \n                                                                \n           \n        else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\n            return 0;\n    }\n\n    if (PACKET_remaining(VAR_1) != 0) {\n        *al = VAR_13;\n        return 0;\n    }\n\n    if (!s->hit && VAR_6 == 1) {\n        if (s->tlsext_hostname) {\n            if (s->session->tlsext_hostname == NULL) {\n                s->session->tlsext_hostname =\n                    OPENSSL_strdup(s->tlsext_hostname);\n                if (!s->session->tlsext_hostname) {\n                    *al = VAR_51;\n                    return 0;\n                }\n            } else {\n                *al = VAR_13;\n                return 0;\n            }\n        }\n    }\n\n ri_check:\n\n    /* COMMENT_31 */\n                                                                            \n                                                                       \n                                                                         \n                                                                       \n                                                                         \n       \n    if (!VAR_7 && !(s->options & VAR_52)\n        && !(s->options & VAR_53)) {\n        *al = VAR_54;\n        SSLerr(VAR_55,\n               VAR_56);\n        return 0;\n    }\n\n    if (s->hit) {\n        /* COMMENT_38 */\n                                                                    \n                            \n           \n        if (!(s->s3->flags & VAR_12) !=\n            !(s->session->flags & VAR_50)) {\n            *al = VAR_54;\n            SSLerr(VAR_55, VAR_57);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_lib.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n                              SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n #endif\n \n-    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+    s->tlsext_use_etm = 0;\n \n     s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;\n \n@@ -235,7 +235,7 @@\n             /* Ignore if inappropriate ciphersuite */\n             if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD\n                 && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)\n-                s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+                s->tlsext_use_etm = 1;\n         } else if (type == TLSEXT_TYPE_extended_master_secret) {\n             s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;\n             if (!s->hit)",
  "diff_line_info": {
    "deleted_lines": [
      "    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "                s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;"
    ],
    "added_lines": [
      "    s->tlsext_use_etm = 0;",
      "                s->tlsext_use_etm = 1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nThe patch addresses a known security vulnerability (CVE-2017-3733) by correcting how ETM flags are set during TLS renegotiation, preventing a crash that could lead to a DoS attack. The code changes are directly related to the security issue described, and all information is consistent."
}