{
  "cve_id": "CVE-2021-20224",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "ImageMagick",
  "commit_msg": "outside the range of representable values of type 'unsigned char' (#3083)\n\nCo-authored-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>",
  "commit_hash": "5af1dffa4b6ab984b5f13d1e91c95760d75f12a6",
  "git_url": "https://github.com/ImageMagick/ImageMagick/commit/5af1dffa4b6ab984b5f13d1e91c95760d75f12a6",
  "file_path": "MagickCore/quantum-export.c",
  "func_name": "ExportIndexQuantum",
  "func_before": "static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0x01) << 7);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 5);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 3);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 1);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) GetPixelIndex(image,p);\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q=((pixel & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) GetPixelIndex(image,p);\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) GetPixelIndex(image,p);\n          *q=((pixel & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(\n              QuantumScale*GetPixelIndex(image,p)),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
  "abstract_func_before": "static void ExportIndexQuantum(const Image *VAR_0,QuantumInfo *VAR_1,\n  const MagickSizeType VAR_2,const Quantum *magick_restrict VAR_3,\n  unsigned char *magick_restrict VAR_4,ExceptionInfo *VAR_5)\n{\n  ssize_t\n    VAR_6;\n\n  ssize_t\n    VAR_7;\n\n  if (VAR_0->storage_class != VAR_8)\n    {\n      (void) ThrowMagickException(VAR_5,GetMagickModule(),VAR_9,\n        \"ColormappedImageRequired\",\"`%s'\",VAR_0->filename);\n      return;\n    }\n  switch (VAR_1->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        VAR_10;\n\n      for (VAR_6=((ssize_t) VAR_2-7); VAR_6 > 0; VAR_6-=8)\n      {\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4=((VAR_10 & 0x01) << 7);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0x01) << 6);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0x01) << 5);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0x01) << 4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0x01) << 3);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0x01) << 2);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0x01) << 1);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0x01) << 0);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4++;\n      }\n      if ((VAR_2 % 8) != 0)\n        {\n          *VAR_4='\\0';\n          for (VAR_7=7; VAR_7 >= (ssize_t) (8-(VAR_2 % 8)); VAR_7--)\n          {\n            VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n            *VAR_4|=((VAR_10 & 0x01) << (unsigned char) VAR_7);\n            VAR_3+=GetPixelChannels(VAR_0);\n          }\n          VAR_4++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        VAR_10;\n\n      for (VAR_6=0; VAR_6 < (ssize_t) (VAR_2-1) ; VAR_6+=2)\n      {\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4=((VAR_10 & 0xf) << 4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n        *VAR_4|=((VAR_10 & 0xf) << 0);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4++;\n      }\n      if ((VAR_2 % 2) != 0)\n        {\n          VAR_10=(unsigned char) GetPixelIndex(VAR_0,VAR_3);\n          *VAR_4=((VAR_10 & 0xf) << 4);\n          VAR_3+=GetPixelChannels(VAR_0);\n          VAR_4++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopCharPixel((unsigned char) GetPixelIndex(VAR_0,VAR_3),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (VAR_1->format == VAR_11)\n        {\n          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n          {\n            VAR_4=PopShortPixel(VAR_1->endian,SinglePrecisionToHalf(\n              VAR_12*GetPixelIndex(VAR_0,VAR_3)),VAR_4);\n            VAR_3+=GetPixelChannels(VAR_0);\n            VAR_4+=VAR_1->pad;\n          }\n          break;\n        }\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopShortPixel(VAR_1->endian,(unsigned short)\n          GetPixelIndex(VAR_0,VAR_3),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (VAR_1->format == VAR_11)\n        {\n          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n          {\n            VAR_4=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_0,VAR_3),VAR_4);\n            VAR_3+=GetPixelChannels(VAR_0);\n            VAR_4+=VAR_1->pad;\n          }\n          break;\n        }\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopLongPixel(VAR_1->endian,(unsigned int)\n          GetPixelIndex(VAR_0,VAR_3),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (VAR_1->format == VAR_11)\n        {\n          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n          {\n            VAR_4=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_0,VAR_3),VAR_4);\n            VAR_3+=GetPixelChannels(VAR_0);\n            VAR_4+=VAR_1->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopQuantumPixel(VAR_1,GetPixelIndex(VAR_0,VAR_3),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n  }\n}",
  "func_graph_path_before": null,
  "func": "static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const Quantum *magick_restrict p,\n  unsigned char *magick_restrict q,ExceptionInfo *exception)\n{\n  ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n      {\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q=((pixel & 0x01) << 7);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 6);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 5);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 3);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 2);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 1);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0x01) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 8) != 0)\n        {\n          *q='\\0';\n          for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n          {\n            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n            *q|=((pixel & 0x01) << (unsigned char) bit);\n            p+=GetPixelChannels(image);\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n      {\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q=((pixel & 0xf) << 4);\n        p+=GetPixelChannels(image);\n        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n        *q|=((pixel & 0xf) << 0);\n        p+=GetPixelChannels(image);\n        q++;\n      }\n      if ((number_pixels % 2) != 0)\n        {\n          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n          *q=((pixel & 0xf) << 4);\n          p+=GetPixelChannels(image);\n          q++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,SinglePrecisionToHalf(\n              QuantumScale*GetPixelIndex(image,p)),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelIndex(image,p),q);\n            p+=GetPixelChannels(image);\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(image,p),q);\n        p+=GetPixelChannels(image);\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
  "abstract_func": "static void ExportIndexQuantum(const Image *VAR_0,QuantumInfo *VAR_1,\n  const MagickSizeType VAR_2,const Quantum *magick_restrict VAR_3,\n  unsigned char *magick_restrict VAR_4,ExceptionInfo *VAR_5)\n{\n  ssize_t\n    VAR_6;\n\n  ssize_t\n    VAR_7;\n\n  if (VAR_0->storage_class != VAR_8)\n    {\n      (void) ThrowMagickException(VAR_5,GetMagickModule(),VAR_9,\n        \"ColormappedImageRequired\",\"`%s'\",VAR_0->filename);\n      return;\n    }\n  switch (VAR_1->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        VAR_10;\n\n      for (VAR_6=((ssize_t) VAR_2-7); VAR_6 > 0; VAR_6-=8)\n      {\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4=((VAR_10 & 0x01) << 7);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0x01) << 6);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0x01) << 5);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0x01) << 4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0x01) << 3);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0x01) << 2);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0x01) << 1);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0x01) << 0);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4++;\n      }\n      if ((VAR_2 % 8) != 0)\n        {\n          *VAR_4='\\0';\n          for (VAR_7=7; VAR_7 >= (ssize_t) (8-(VAR_2 % 8)); VAR_7--)\n          {\n            VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n            *VAR_4|=((VAR_10 & 0x01) << (unsigned char) VAR_7);\n            VAR_3+=GetPixelChannels(VAR_0);\n          }\n          VAR_4++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        VAR_10;\n\n      for (VAR_6=0; VAR_6 < (ssize_t) (VAR_2-1) ; VAR_6+=2)\n      {\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4=((VAR_10 & 0xf) << 4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n        *VAR_4|=((VAR_10 & 0xf) << 0);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4++;\n      }\n      if ((VAR_2 % 2) != 0)\n        {\n          VAR_10=(unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3));\n          *VAR_4=((VAR_10 & 0xf) << 4);\n          VAR_3+=GetPixelChannels(VAR_0);\n          VAR_4++;\n        }\n      break;\n    }\n    case 8:\n    {\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(VAR_0,VAR_3)),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      if (VAR_1->format == VAR_11)\n        {\n          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n          {\n            VAR_4=PopShortPixel(VAR_1->endian,SinglePrecisionToHalf(\n              VAR_12*GetPixelIndex(VAR_0,VAR_3)),VAR_4);\n            VAR_3+=GetPixelChannels(VAR_0);\n            VAR_4+=VAR_1->pad;\n          }\n          break;\n        }\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopShortPixel(VAR_1->endian,(unsigned short)\n          GetPixelIndex(VAR_0,VAR_3),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      if (VAR_1->format == VAR_11)\n        {\n          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n          {\n            VAR_4=PopFloatPixel(VAR_1,(float) GetPixelIndex(VAR_0,VAR_3),VAR_4);\n            VAR_3+=GetPixelChannels(VAR_0);\n            VAR_4+=VAR_1->pad;\n          }\n          break;\n        }\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopLongPixel(VAR_1->endian,(unsigned int)\n          GetPixelIndex(VAR_0,VAR_3),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (VAR_1->format == VAR_11)\n        {\n          for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n          {\n            VAR_4=PopDoublePixel(VAR_1,(double) GetPixelIndex(VAR_0,VAR_3),VAR_4);\n            VAR_3+=GetPixelChannels(VAR_0);\n            VAR_4+=VAR_1->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (VAR_6=0; VAR_6 < (ssize_t) VAR_2; VAR_6++)\n      {\n        VAR_4=PopQuantumPixel(VAR_1,GetPixelIndex(VAR_0,VAR_3),VAR_4);\n        VAR_3+=GetPixelChannels(VAR_0);\n        VAR_4+=VAR_1->pad;\n      }\n      break;\n    }\n  }\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -23,28 +23,28 @@\n \n       for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n       {\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q=((pixel & 0x01) << 7);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 6);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 5);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 4);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 3);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 2);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 1);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 0);\n         p+=GetPixelChannels(image);\n         q++;\n@@ -54,7 +54,7 @@\n           *q='\\0';\n           for (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n           {\n-            pixel=(unsigned char) GetPixelIndex(image,p);\n+            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n             *q|=((pixel & 0x01) << (unsigned char) bit);\n             p+=GetPixelChannels(image);\n           }\n@@ -69,17 +69,17 @@\n \n       for (x=0; x < (ssize_t) (number_pixels-1) ; x+=2)\n       {\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q=((pixel & 0xf) << 4);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0xf) << 0);\n         p+=GetPixelChannels(image);\n         q++;\n       }\n       if ((number_pixels % 2) != 0)\n         {\n-          pixel=(unsigned char) GetPixelIndex(image,p);\n+          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n           *q=((pixel & 0xf) << 4);\n           p+=GetPixelChannels(image);\n           q++;\n@@ -90,7 +90,7 @@\n     {\n       for (x=0; x < (ssize_t) number_pixels; x++)\n       {\n-        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);\n+        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);\n         p+=GetPixelChannels(image);\n         q+=quantum_info->pad;\n       }",
  "diff_line_info": {
    "deleted_lines": [
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "            pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "        pixel=(unsigned char) GetPixelIndex(image,p);",
      "          pixel=(unsigned char) GetPixelIndex(image,p);",
      "        q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);"
    ],
    "added_lines": [
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "          pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));",
      "        q=PopCharPixel((unsigned char) ((ssize_t) GetPixelIndex(image,p)),q);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ImageMagick/ImageMagick/pull/3083",
  "description": {
    "pr_info": {
      "title": "outside the range of representable values of type 'unsigned char'",
      "number": 3083
    },
    "comment": [
      "### Prerequisites\r\n\r\n- [ ] I have written a descriptive pull-request title\r\n- [ ] I have verified that there are no overlapping [pull-requests](https://github.com/ImageMagick/ImageMagick/pulls) open\r\n- [ ] I have verified that I am following the existing coding patterns and practices as demonstrated in the repository.\r\n\r\n### Description\r\n<!-- A description of the changes proposed in the pull-request\r\n     If you want to change something in the 'www' or 'ImageMagick' folder please\r\n     open an issue here instead: https://github.com/ImageMagick/Website -->\r\n\r\n<!-- Thanks for contributing to ImageMagick! -->\r\nThere is an outside the range of representable values of type 'unsigned char' at MagickCore/quantum-export.c."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}