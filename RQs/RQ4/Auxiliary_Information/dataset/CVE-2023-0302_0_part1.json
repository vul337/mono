{
  "cve_id": "CVE-2023-0302",
  "cwe_ids": [
    "CWE-74"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln\n\n* Reported by @solid-snail via huntrdev\r\n* BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r\n* Reproducer: dwarf_test_func_patched",
  "commit_hash": "961f0e723903011d4f54c2396e44efa91fcc74ce",
  "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
  "file_path": "libr/core/cmd_meta.c",
  "func_name": "cmd_meta_comment",
  "func_before": "static int cmd_meta_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_CC);\n\t\tbreak;\n\tcase ',': // \"CC,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, ',', input + 2);\n\t\tbreak;\n\tcase 'F': // \"CC,\"\n\t\tif (input[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\tconst char *fn = input + 2;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tfn = r_str_trim_head_ro (fn);\n\t\t\tif (comment && *comment) {\n\t\t\t\t// append filename in current comment\n\t\t\t\tchar *nc = r_str_newf (\"%s ,(%s)\", comment, fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\t\tfree (nc);\n\t\t\t} else {\n\t\t\t\tchar *newcomment = r_str_newf (\",(%s)\", fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t\tfree (newcomment);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (comment && *comment) {\n\t\t\t\tchar *cmtfile = r_str_between (comment, \",(\", \")\");\n\t\t\t\tif (cmtfile && *cmtfile) {\n\t\t\t\t\tchar *cwd = getcommapath (core);\n\t\t\t\t\tr_cons_printf (\"%s\"R_SYS_DIR\"%s\\n\", cwd, cmtfile);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t\tfree (cmtfile);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\t\t  const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, at);\n\t\t\t  if (comment) {\n\t\t\t\t  r_cons_println (comment);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: // \"CC\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 0, NULL);\n\t\tbreak;\n\tcase 'f': // \"CCf\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"CCf-\"\n\t\t\t{\n\t\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\t\tif (!arg) {\n\t\t\t\t\targ = core->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, arg, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalBlock *bb;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < bb->size; i++) {\n\t\t\t\t\t\t\tut64 addr = bb->addr + i;\n\t\t\t\t\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, addr, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': // \"CCf,\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, ',', core->offset, input + 3);\n\t\t\tbreak;\n\t\tcase 'j': // \"CCfj\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 'j', core->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': // \"CCf*\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 1, core->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 0, core->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"CCj\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 'j', input + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tchar *out;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tout = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tchar *text;\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tif (comment) {\n\t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n\t\t\tif (text) {\n\t\t\t\tstrcpy (text, comment);\n\t\t\t\tstrcat (text, \" \");\n\t\t\t\tstrcat (text, nc);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\tif (r_config_get_b (core->config, \"cmd.undo\")) {\n\t\t\t\tchar *a = r_str_newf (\"CC-0x%08\"PFMT64x, addr);\n\t\t\t\tchar *b = r_str_newf (\"CC %s@0x%08\"PFMT64x, nc, addr);\n\t\t\t\tRCoreUndo *uc = r_core_undo_new (core->offset, b, a);\n\t\t\t\tr_core_undo_push (core, uc);\n\t\t\t\tfree (a);\n\t\t\t\tfree (b);\n\t\t\t}\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"CC*\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 1, NULL);\n\t\tbreak;\n\tcase '-': // \"CC-\"\n\t\tif (input[2] == '*') { // \"CC-*\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, UT64_MAX, UT64_MAX);\n\t\t} else if (input[2]) { // \"CC-$$+32\"\n\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, arg, 1);\n\t\t} else { // \"CC-\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, core->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"CCu\"\n\t\t//\n\t\t{\n\t\tchar *newcomment;\n\t\tconst char *arg = input + 2;\n\t\twhile (*arg && *arg == ' ') arg++;\n\t\tif (!strncmp (arg, \"base64:\", 7)) {\n\t\t\tchar *s = (char *)sdb_decode (arg + 7, NULL);\n\t\t\tif (s) {\n\t\t\t\tnewcomment = s;\n\t\t\t} else {\n\t\t\t\tnewcomment = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnewcomment = strdup (arg);\n\t\t}\n\t\tif (newcomment) {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (!comment || (comment && !strstr (comment, newcomment))) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t}\n\t\t\tfree (newcomment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"CCa\"\n\t\t{\n\t\tchar *s, *p;\n\t\ts = strchr (input, ' ');\n\t\tif (s) {\n\t\t\ts = strdup (s + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tp = strchr (s, ' ');\n\t\tif (p) {\n\t\t\t*p++ = 0;\n\t\t}\n\t\tut64 addr;\n\t\tif (input[2] == '-') {\n\t\t\tif (input[3]) {\n\t\t\t\taddr = r_num_math (core->num, input+3);\n\t\t\t\tr_meta_del (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT,\n\t\t\t\t\t\taddr, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t\taddr = r_num_math (core->num, s);\n\t\t// Comment at\n\t\tif (p) {\n\t\t\tif (input[2]=='+') {\n\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", comment, p);\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, text);\n\t\t\t\t\tfree (text);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (s);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}",
  "abstract_func_before": "static int cmd_meta_comment(RCore *VAR_0, const char *VAR_1) {\n\tut64 VAR_2 = VAR_0->offset;\n\tswitch (VAR_1[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (VAR_0, VAR_3);\n\t\tbreak;\n\tcase ',': /* COMMENT_0 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, ',', VAR_1 + 2);\n\t\tbreak;\n\tcase 'F': /* COMMENT_0 */\n\t\tif (VAR_1[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (VAR_1[2] == ' ') {\n\t\t\tconst char *VAR_5 = VAR_1 + 2;\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tVAR_5 = r_str_trim_head_ro (VAR_5);\n\t\t\tif (VAR_6 && *VAR_6) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tchar *VAR_7 = r_str_newf (\"%s ,(%s)\", VAR_6, VAR_5);\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_7);\n\t\t\t\tfree (VAR_7);\n\t\t\t} else {\n\t\t\t\tchar *VAR_8 = r_str_newf (\",(%s)\", VAR_5);\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_8);\n\t\t\t\tfree (VAR_8);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tif (VAR_6 && *VAR_6) {\n\t\t\t\tchar *VAR_9 = r_str_between (VAR_6, \",(\", \")\");\n\t\t\t\tif (VAR_9 && *VAR_9) {\n\t\t\t\t\tchar *VAR_10 = getcommapath (VAR_0);\n\t\t\t\t\tr_cons_printf (\"%s\"VAR_11\"%s\\n\", VAR_10, VAR_9);\n\t\t\t\t\tfree (VAR_10);\n\t\t\t\t}\n\t\t\t\tfree (VAR_9);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 VAR_12 = VAR_1[2]? r_num_math (VAR_0->num, VAR_1 + 2): VAR_2;\n\t\t\t  const char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_12);\n\t\t\t  if (VAR_6) {\n\t\t\t\t  r_cons_println (VAR_6);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: /* COMMENT_2 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, 0, NULL);\n\t\tbreak;\n\tcase 'f': /* COMMENT_3 */\n\t\tswitch (VAR_1[2]) {\n\t\tcase '-': /* COMMENT_4 */\n\t\t\t{\n\t\t\t\tut64 VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);\n\t\t\t\tif (!VAR_13) {\n\t\t\t\t\tVAR_13 = VAR_0->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *VAR_14 = r_anal_get_fcn_in (VAR_0->anal, VAR_13, 0);\n\t\t\t\tif (VAR_14) {\n\t\t\t\t\tRAnalBlock *VAR_15;\n\t\t\t\t\tRListIter *VAR_16;\n\t\t\t\t\tr_list_foreach (VAR_14->bbs, VAR_16, VAR_15) {\n\t\t\t\t\t\tint VAR_17;\n\t\t\t\t\t\tfor (VAR_17 = 0; VAR_17 < VAR_15->size; VAR_17++) {\n\t\t\t\t\t\t\tut64 VAR_2 = VAR_15->addr + VAR_17;\n\t\t\t\t\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_2, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': /* COMMENT_5 */\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, ',', VAR_0->offset, VAR_1 + 3);\n\t\t\tbreak;\n\t\tcase 'j': /* COMMENT_6 */\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, 'j', VAR_0->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': /* COMMENT_7 */\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, 1, VAR_0->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, 0, VAR_0->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': /* COMMENT_8 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, 'j', VAR_1 + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tchar *VAR_18;\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tVAR_18 = r_core_editor (VAR_0, NULL, VAR_6);\n\t\t\tif (VAR_18) {\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\tr_core_cmdf (VAR_0, \"CC-@0x%08\"VAR_19, VAR_2);\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tr_meta_set_string (VAR_0->anal,\n\t\t\t\t\t\tVAR_4, VAR_2, VAR_18);\n\t\t\t\tfree (VAR_18);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *VAR_8 = r_str_trim_head_ro (VAR_1 + 2);\n\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\tchar *VAR_20;\n\t\tchar *VAR_7 = strdup (VAR_8);\n\t\tr_str_unescape (VAR_7);\n\t\tif (VAR_6) {\n\t\t\tVAR_20 = malloc (strlen (VAR_6) + strlen (VAR_8) + 2);\n\t\t\tif (VAR_20) {\n\t\t\t\tstrcpy (VAR_20, VAR_6);\n\t\t\t\tstrcat (VAR_20, \" \");\n\t\t\t\tstrcat (VAR_20, VAR_7);\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_20);\n\t\t\t\tfree (VAR_20);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_7);\n\t\t\tif (r_config_get_b (VAR_0->config, \"cmd.undo\")) {\n\t\t\t\tchar *VAR_21 = r_str_newf (\"CC-0x%08\"VAR_19, VAR_2);\n\t\t\t\tchar *VAR_22 = r_str_newf (\"CC %s@0x%08\"VAR_19, VAR_7, VAR_2);\n\t\t\t\tRCoreUndo *VAR_23 = r_core_undo_new (VAR_0->offset, VAR_22, VAR_21);\n\t\t\t\tr_core_undo_push (VAR_0, VAR_23);\n\t\t\t\tfree (VAR_21);\n\t\t\t\tfree (VAR_22);\n\t\t\t}\n\t\t}\n\t\tfree (VAR_7);\n\t\t}\n\t\tbreak;\n\tcase '*': /* COMMENT_11 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, 1, NULL);\n\t\tbreak;\n\tcase '-': /* COMMENT_12 */\n\t\tif (VAR_1[2] == '*') { /* COMMENT_13 */\n\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_24, VAR_24);\n\t\t} else if (VAR_1[2]) { /* COMMENT_14 */\n\t\t\tut64 VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);\n\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_13, 1);\n\t\t} else { /* COMMENT_12 */\n\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_0->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': /* COMMENT_15 */\n\t\t/* COMMENT_16 */\n\t\t{\n\t\tchar *VAR_8;\n\t\tconst char *VAR_13 = VAR_1 + 2;\n\t\twhile (*VAR_13 && *VAR_13 == ' ') VAR_13++;\n\t\tif (!strncmp (VAR_13, \"base64:\", 7)) {\n\t\t\tchar *VAR_25 = (char *)sdb_decode (VAR_13 + 7, NULL);\n\t\t\tif (VAR_25) {\n\t\t\t\tVAR_8 = VAR_25;\n\t\t\t} else {\n\t\t\t\tVAR_8 = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_8 = strdup (VAR_13);\n\t\t}\n\t\tif (VAR_8) {\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tif (!VAR_6 || (VAR_6 && !strstr (VAR_6, VAR_8))) {\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_8);\n\t\t\t}\n\t\t\tfree (VAR_8);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': /* COMMENT_17 */\n\t\t{\n\t\tchar *VAR_25, *VAR_26;\n\t\tVAR_25 = strchr (VAR_1, ' ');\n\t\tif (VAR_25) {\n\t\t\tVAR_25 = strdup (VAR_25 + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tVAR_26 = strchr (VAR_25, ' ');\n\t\tif (VAR_26) {\n\t\t\t*VAR_26++ = 0;\n\t\t}\n\t\tut64 VAR_2;\n\t\tif (VAR_1[2] == '-') {\n\t\t\tif (VAR_1[3]) {\n\t\t\t\tVAR_2 = r_num_math (VAR_0->num, VAR_1+3);\n\t\t\t\tr_meta_del (VAR_0->anal,\n\t\t\t\t\t\tVAR_4,\n\t\t\t\t\t\tVAR_2, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (VAR_25);\n\t\t\treturn true;\n\t\t}\n\t\tVAR_2 = r_num_math (VAR_0->num, VAR_25);\n\t\t/* COMMENT_18 */\n\t\tif (VAR_26) {\n\t\t\tif (VAR_1[2]=='+') {\n\t\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\t\tif (VAR_6) {\n\t\t\t\t\tchar *VAR_20 = r_str_newf (\"%s\\n%s\", VAR_6, VAR_26);\n\t\t\t\t\tr_meta_set (VAR_0->anal, VAR_4, VAR_2, 1, VAR_20);\n\t\t\t\t\tfree (VAR_20);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (VAR_0->anal, VAR_4, VAR_2, 1, VAR_26);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (VAR_0->anal, VAR_4, VAR_2, 1, VAR_26);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (VAR_25);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}",
  "func_graph_path_before": "radareorg/radare2/961f0e723903011d4f54c2396e44efa91fcc74ce/cmd_meta.c/vul/before/0.json",
  "func": "static int cmd_meta_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_CC);\n\t\tbreak;\n\tcase ',': // \"CC,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, ',', input + 2);\n\t\tbreak;\n\tcase 'F': // \"CC,\"\n\t\tif (input[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\tconst char *fn = input + 2;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tfn = r_str_trim_head_ro (fn);\n\t\t\tif (comment && *comment) {\n\t\t\t\t// append filename in current comment\n\t\t\t\tchar *nc = r_str_newf (\"%s ,(%s)\", comment, fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\t\tfree (nc);\n\t\t\t} else {\n\t\t\t\tchar *newcomment = r_str_newf (\",(%s)\", fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t\tfree (newcomment);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (comment && *comment) {\n\t\t\t\tchar *cmtfile = r_str_between (comment, \",(\", \")\");\n\t\t\t\tif (cmtfile && *cmtfile) {\n\t\t\t\t\tchar *cwd = getcommapath (core);\n\t\t\t\t\tr_cons_printf (\"%s\"R_SYS_DIR\"%s\\n\", cwd, cmtfile);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t\tfree (cmtfile);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\t\t  const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, at);\n\t\t\t  if (comment) {\n\t\t\t\t  r_cons_println (comment);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: // \"CC\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 0, NULL);\n\t\tbreak;\n\tcase 'f': // \"CCf\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"CCf-\"\n\t\t\t{\n\t\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\t\tif (!arg) {\n\t\t\t\t\targ = core->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, arg, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalBlock *bb;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < bb->size; i++) {\n\t\t\t\t\t\t\tut64 addr = bb->addr + i;\n\t\t\t\t\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, addr, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': // \"CCf,\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, ',', core->offset, input + 3);\n\t\t\tbreak;\n\t\tcase 'j': // \"CCfj\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 'j', core->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': // \"CCf*\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 1, core->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 0, core->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"CCj\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 'j', input + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tchar *out = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\tr_str_ansi_strip (out);\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tchar *text;\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tr_str_ansi_strip (nc);\n\t\tif (comment) {\n\t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n\t\t\tif (text) {\n\t\t\t\tstrcpy (text, comment);\n\t\t\t\tstrcat (text, \" \");\n\t\t\t\tstrcat (text, nc);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\tif (r_config_get_b (core->config, \"cmd.undo\")) {\n\t\t\t\tchar *a = r_str_newf (\"CC-0x%08\"PFMT64x, addr);\n\t\t\t\tchar *b = r_str_newf (\"CC %s@0x%08\"PFMT64x, nc, addr);\n\t\t\t\tRCoreUndo *uc = r_core_undo_new (core->offset, b, a);\n\t\t\t\tr_core_undo_push (core, uc);\n\t\t\t\tfree (a);\n\t\t\t\tfree (b);\n\t\t\t}\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"CC*\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 1, NULL);\n\t\tbreak;\n\tcase '-': // \"CC-\"\n\t\tif (input[2] == '*') { // \"CC-*\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, UT64_MAX, UT64_MAX);\n\t\t} else if (input[2]) { // \"CC-$$+32\"\n\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, arg, 1);\n\t\t} else { // \"CC-\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, core->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"CCu\"\n\t\t//\n\t\t{\n\t\tchar *newcomment;\n\t\tconst char *arg = input + 2;\n\t\twhile (*arg && *arg == ' ') arg++;\n\t\tif (!strncmp (arg, \"base64:\", 7)) {\n\t\t\tchar *s = (char *)sdb_decode (arg + 7, NULL);\n\t\t\tif (s) {\n\t\t\t\tnewcomment = s;\n\t\t\t} else {\n\t\t\t\tnewcomment = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnewcomment = strdup (arg);\n\t\t}\n\t\tif (newcomment) {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (!comment || (comment && !strstr (comment, newcomment))) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t}\n\t\t\tfree (newcomment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"CCa\"\n\t\t{\n\t\tchar *s, *p;\n\t\ts = strchr (input, ' ');\n\t\tif (s) {\n\t\t\ts = strdup (s + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tp = strchr (s, ' ');\n\t\tif (p) {\n\t\t\t*p++ = 0;\n\t\t}\n\t\tut64 addr;\n\t\tif (input[2] == '-') {\n\t\t\tif (input[3]) {\n\t\t\t\taddr = r_num_math (core->num, input+3);\n\t\t\t\tr_meta_del (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT,\n\t\t\t\t\t\taddr, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t\taddr = r_num_math (core->num, s);\n\t\t// Comment at\n\t\tif (p) {\n\t\t\tif (input[2]=='+') {\n\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", comment, p);\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, text);\n\t\t\t\t\tfree (text);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (s);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}",
  "abstract_func": "static int cmd_meta_comment(RCore *VAR_0, const char *VAR_1) {\n\tut64 VAR_2 = VAR_0->offset;\n\tswitch (VAR_1[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (VAR_0, VAR_3);\n\t\tbreak;\n\tcase ',': /* COMMENT_0 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, ',', VAR_1 + 2);\n\t\tbreak;\n\tcase 'F': /* COMMENT_0 */\n\t\tif (VAR_1[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (VAR_1[2] == ' ') {\n\t\t\tconst char *VAR_5 = VAR_1 + 2;\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tVAR_5 = r_str_trim_head_ro (VAR_5);\n\t\t\tif (VAR_6 && *VAR_6) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tchar *VAR_7 = r_str_newf (\"%s ,(%s)\", VAR_6, VAR_5);\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_7);\n\t\t\t\tfree (VAR_7);\n\t\t\t} else {\n\t\t\t\tchar *VAR_8 = r_str_newf (\",(%s)\", VAR_5);\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_8);\n\t\t\t\tfree (VAR_8);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tif (VAR_6 && *VAR_6) {\n\t\t\t\tchar *VAR_9 = r_str_between (VAR_6, \",(\", \")\");\n\t\t\t\tif (VAR_9 && *VAR_9) {\n\t\t\t\t\tchar *VAR_10 = getcommapath (VAR_0);\n\t\t\t\t\tr_cons_printf (\"%s\"VAR_11\"%s\\n\", VAR_10, VAR_9);\n\t\t\t\t\tfree (VAR_10);\n\t\t\t\t}\n\t\t\t\tfree (VAR_9);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 VAR_12 = VAR_1[2]? r_num_math (VAR_0->num, VAR_1 + 2): VAR_2;\n\t\t\t  const char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_12);\n\t\t\t  if (VAR_6) {\n\t\t\t\t  r_cons_println (VAR_6);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: /* COMMENT_2 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, 0, NULL);\n\t\tbreak;\n\tcase 'f': /* COMMENT_3 */\n\t\tswitch (VAR_1[2]) {\n\t\tcase '-': /* COMMENT_4 */\n\t\t\t{\n\t\t\t\tut64 VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);\n\t\t\t\tif (!VAR_13) {\n\t\t\t\t\tVAR_13 = VAR_0->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *VAR_14 = r_anal_get_fcn_in (VAR_0->anal, VAR_13, 0);\n\t\t\t\tif (VAR_14) {\n\t\t\t\t\tRAnalBlock *VAR_15;\n\t\t\t\t\tRListIter *VAR_16;\n\t\t\t\t\tr_list_foreach (VAR_14->bbs, VAR_16, VAR_15) {\n\t\t\t\t\t\tint VAR_17;\n\t\t\t\t\t\tfor (VAR_17 = 0; VAR_17 < VAR_15->size; VAR_17++) {\n\t\t\t\t\t\t\tut64 VAR_2 = VAR_15->addr + VAR_17;\n\t\t\t\t\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_2, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': /* COMMENT_5 */\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, ',', VAR_0->offset, VAR_1 + 3);\n\t\t\tbreak;\n\t\tcase 'j': /* COMMENT_6 */\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, 'j', VAR_0->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': /* COMMENT_7 */\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, 1, VAR_0->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (VAR_0->anal, VAR_4, 0, VAR_0->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': /* COMMENT_8 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, 'j', VAR_1 + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tchar *VAR_18 = r_core_editor (VAR_0, NULL, VAR_6);\n\t\t\tif (VAR_18) {\n\t\t\t\tr_str_ansi_strip (VAR_18);\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\tr_core_cmdf (VAR_0, \"CC-@0x%08\"VAR_19, VAR_2);\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tr_meta_set_string (VAR_0->anal,\n\t\t\t\t\t\tVAR_4, VAR_2, VAR_18);\n\t\t\t\tfree (VAR_18);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *VAR_8 = r_str_trim_head_ro (VAR_1 + 2);\n\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\tchar *VAR_20;\n\t\tchar *VAR_7 = strdup (VAR_8);\n\t\tr_str_unescape (VAR_7);\n\t\tr_str_ansi_strip (VAR_7);\n\t\tif (VAR_6) {\n\t\t\tVAR_20 = malloc (strlen (VAR_6) + strlen (VAR_8) + 2);\n\t\t\tif (VAR_20) {\n\t\t\t\tstrcpy (VAR_20, VAR_6);\n\t\t\t\tstrcat (VAR_20, \" \");\n\t\t\t\tstrcat (VAR_20, VAR_7);\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_20);\n\t\t\t\tfree (VAR_20);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_7);\n\t\t\tif (r_config_get_b (VAR_0->config, \"cmd.undo\")) {\n\t\t\t\tchar *VAR_21 = r_str_newf (\"CC-0x%08\"VAR_19, VAR_2);\n\t\t\t\tchar *VAR_22 = r_str_newf (\"CC %s@0x%08\"VAR_19, VAR_7, VAR_2);\n\t\t\t\tRCoreUndo *VAR_23 = r_core_undo_new (VAR_0->offset, VAR_22, VAR_21);\n\t\t\t\tr_core_undo_push (VAR_0, VAR_23);\n\t\t\t\tfree (VAR_21);\n\t\t\t\tfree (VAR_22);\n\t\t\t}\n\t\t}\n\t\tfree (VAR_7);\n\t\t}\n\t\tbreak;\n\tcase '*': /* COMMENT_11 */\n\t\tr_meta_print_list_all (VAR_0->anal, VAR_4, 1, NULL);\n\t\tbreak;\n\tcase '-': /* COMMENT_12 */\n\t\tif (VAR_1[2] == '*') { /* COMMENT_13 */\n\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_24, VAR_24);\n\t\t} else if (VAR_1[2]) { /* COMMENT_14 */\n\t\t\tut64 VAR_13 = r_num_math (VAR_0->num, VAR_1 + 2);\n\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_13, 1);\n\t\t} else { /* COMMENT_12 */\n\t\t\tr_meta_del (VAR_0->anal, VAR_4, VAR_0->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': /* COMMENT_15 */\n\t\t/* COMMENT_16 */\n\t\t{\n\t\tchar *VAR_8;\n\t\tconst char *VAR_13 = VAR_1 + 2;\n\t\twhile (*VAR_13 && *VAR_13 == ' ') VAR_13++;\n\t\tif (!strncmp (VAR_13, \"base64:\", 7)) {\n\t\t\tchar *VAR_25 = (char *)sdb_decode (VAR_13 + 7, NULL);\n\t\t\tif (VAR_25) {\n\t\t\t\tVAR_8 = VAR_25;\n\t\t\t} else {\n\t\t\t\tVAR_8 = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_8 = strdup (VAR_13);\n\t\t}\n\t\tif (VAR_8) {\n\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\tif (!VAR_6 || (VAR_6 && !strstr (VAR_6, VAR_8))) {\n\t\t\t\tr_meta_set_string (VAR_0->anal, VAR_4, VAR_2, VAR_8);\n\t\t\t}\n\t\t\tfree (VAR_8);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': /* COMMENT_17 */\n\t\t{\n\t\tchar *VAR_25, *VAR_26;\n\t\tVAR_25 = strchr (VAR_1, ' ');\n\t\tif (VAR_25) {\n\t\t\tVAR_25 = strdup (VAR_25 + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tVAR_26 = strchr (VAR_25, ' ');\n\t\tif (VAR_26) {\n\t\t\t*VAR_26++ = 0;\n\t\t}\n\t\tut64 VAR_2;\n\t\tif (VAR_1[2] == '-') {\n\t\t\tif (VAR_1[3]) {\n\t\t\t\tVAR_2 = r_num_math (VAR_0->num, VAR_1+3);\n\t\t\t\tr_meta_del (VAR_0->anal,\n\t\t\t\t\t\tVAR_4,\n\t\t\t\t\t\tVAR_2, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (VAR_25);\n\t\t\treturn true;\n\t\t}\n\t\tVAR_2 = r_num_math (VAR_0->num, VAR_25);\n\t\t/* COMMENT_18 */\n\t\tif (VAR_26) {\n\t\t\tif (VAR_1[2]=='+') {\n\t\t\t\tconst char *VAR_6 = r_meta_get_string (VAR_0->anal, VAR_4, VAR_2);\n\t\t\t\tif (VAR_6) {\n\t\t\t\t\tchar *VAR_20 = r_str_newf (\"%s\\n%s\", VAR_6, VAR_26);\n\t\t\t\t\tr_meta_set (VAR_0->anal, VAR_4, VAR_2, 1, VAR_20);\n\t\t\t\t\tfree (VAR_20);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (VAR_0->anal, VAR_4, VAR_2, 1, VAR_26);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (VAR_0->anal, VAR_4, VAR_2, 1, VAR_26);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (VAR_25);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}",
  "func_graph_path": "radareorg/radare2/961f0e723903011d4f54c2396e44efa91fcc74ce/cmd_meta.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -90,10 +90,10 @@\n \t\tbreak;\n \tcase '!':\n \t\t{\n-\t\t\tchar *out;\n-\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n-\t\t\tout = r_core_editor (core, NULL, comment);\n+\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n+\t\t\tchar *out = r_core_editor (core, NULL, comment);\n \t\t\tif (out) {\n+\t\t\t\tr_str_ansi_strip (out);\n \t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n \t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n \t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n@@ -111,6 +111,7 @@\n \t\tchar *text;\n \t\tchar *nc = strdup (newcomment);\n \t\tr_str_unescape (nc);\n+\t\tr_str_ansi_strip (nc);\n \t\tif (comment) {\n \t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n \t\t\tif (text) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tchar *out;",
      "\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);",
      "\t\t\tout = r_core_editor (core, NULL, comment);"
    ],
    "added_lines": [
      "\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);",
      "\t\t\tchar *out = r_core_editor (core, NULL, comment);",
      "\t\t\t\tr_str_ansi_strip (out);",
      "\t\tr_str_ansi_strip (nc);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/21231",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/21231: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/21231",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message clearly indicates a security fix for an ANSI Escape Sequence Injection vulnerability, referred to as \"vulns via DWARF.\" The code diff introduces calls to `r_str_ansi_strip`, a function that removes ANSI escape sequences, suggesting an effort to sanitize input and prevent injection attacks.\n\n2. **Consistency Check:** The commit message aligns with the code changes, as both address the issue of ANSI escape sequence injection. The inclusion of the `r_str_ansi_strip` function supports the stated purpose.\n\n3. **Purpose Evaluation:** The changes are aimed at sanitizing input to mitigate a security risk, specifically preventing the injection of ANSI escape sequences that could be exploited.\n\n4. **Security Vulnerability Assessment:** The patch addresses an ANSI escape sequence injection vulnerability, which is a security risk. The use of `r_str_ansi_strip` directly targets this issue by removing potentially harmful escape sequences.\n\n5. **Non-Security Classification:** Not applicable since the patch is identified as a security fix.\n\n6. **Confidence Scoring:** The classification is highly confident due to the explicit mention of a vulnerability, the relevant code changes, and their alignment with security concerns.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}