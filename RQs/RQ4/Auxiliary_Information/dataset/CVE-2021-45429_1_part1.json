{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "cli/yara.c",
  "func_name": "_tmain",
  "func_before": "int _tmain(int argc, const char_t** argv)\n{\n  COMPILER_RESULTS cr;\n\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n  YR_SCANNER* scanner = NULL;\n  SCAN_OPTIONS scan_opts;\n\n  bool arg_is_dir = false;\n  int flags = 0;\n  int result;\n\n  argc = args_parse(options, argc, argv);\n\n  scan_opts.follow_symlinks = follow_symlinks;\n  scan_opts.recursive_search = recursive_search;\n\n  if (show_version)\n  {\n    printf(\"%s\\n\", YR_VERSION);\n    return EXIT_SUCCESS;\n  }\n\n  if (show_help)\n  {\n    printf(\n        \"YARA %s, the pattern matching swiss army knife.\\n\"\n        \"%s\\n\\n\"\n        \"Mandatory arguments to long options are mandatory for \"\n        \"short options too.\\n\\n\",\n        YR_VERSION,\n        USAGE_STRING);\n\n    args_print_usage(options, 43);\n    printf(\n        \"\\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\\n\");\n\n    return EXIT_SUCCESS;\n  }\n\n  if (threads > YR_MAX_THREADS)\n  {\n    fprintf(stderr, \"maximum number of threads is %d\\n\", YR_MAX_THREADS);\n    return EXIT_FAILURE;\n  }\n\n  if (argc < 2)\n  {\n    // After parsing the command-line options we expect two additional\n    // arguments, the rules file and the target file, directory or pid to\n    // be scanned.\n\n    fprintf(stderr, \"yara: wrong number of arguments\\n\");\n    fprintf(stderr, \"%s\\n\\n\", USAGE_STRING);\n    fprintf(stderr, \"Try `--help` for more options\\n\");\n\n    return EXIT_FAILURE;\n  }\n\n#if defined(_WIN32) && defined(_UNICODE)\n  // In Windows set stdout to UTF-8 mode.\n  if (_setmode(_fileno(stdout), _O_U8TEXT) == -1)\n  {\n    return EXIT_FAILURE;\n  }\n#endif\n\n  if (!load_modules_data())\n    exit_with_code(EXIT_FAILURE);\n\n  result = yr_initialize();\n\n  if (result != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"error: initialization error (%d)\\n\", result);\n    exit_with_code(EXIT_FAILURE);\n  }\n\n  yr_set_configuration(YR_CONFIG_STACK_SIZE, &stack_size);\n  yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);\n  yr_set_configuration(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n\n  // Try to load the rules file as a binary file containing\n  // compiled rules first\n\n  if (rules_are_compiled)\n  {\n    // When a binary file containing compiled rules is provided, yara accepts\n    // only two arguments, the compiled rules file and the target to be scanned.\n\n    if (argc != 2)\n    {\n      fprintf(\n          stderr,\n          \"error: can't accept multiple rules files if one of them is in \"\n          \"compiled form.\\n\");\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    // Not using yr_rules_load because it does not have support for unicode\n    // file names. Instead use open _tfopen for openning the file and\n    // yr_rules_load_stream for loading the rules from it.\n\n    FILE* fh = _tfopen(argv[0], _T(\"rb\"));\n\n    if (fh != NULL)\n    {\n      YR_STREAM stream;\n\n      stream.user_data = fh;\n      stream.read = (YR_STREAM_READ_FUNC) fread;\n\n      result = yr_rules_load_stream(&stream, &rules);\n\n      fclose(fh);\n\n      if (result == ERROR_SUCCESS)\n        result = define_external_variables(ext_vars, rules, NULL);\n    }\n    else\n    {\n      result = ERROR_COULD_NOT_OPEN_FILE;\n    }\n  }\n  else\n  {\n    // Rules file didn't contain compiled rules, let's handle it\n    // as a text file containing rules in source form.\n\n    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n      exit_with_code(EXIT_FAILURE);\n\n    result = define_external_variables(ext_vars, NULL, compiler);\n\n    if (result != ERROR_SUCCESS)\n    {\n      print_error(result);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    if (atom_quality_table != NULL)\n    {\n      result = yr_compiler_load_atom_quality_table(\n          compiler, atom_quality_table, 0);\n\n      if (result != ERROR_SUCCESS)\n      {\n        fprintf(stderr, \"error loading atom quality table: \");\n        print_error(result);\n        exit_with_code(EXIT_FAILURE);\n      }\n    }\n\n    cr.errors = 0;\n    cr.warnings = 0;\n\n    yr_compiler_set_callback(compiler, print_compiler_error, &cr);\n\n    if (!compile_files(compiler, argc, argv))\n      exit_with_code(EXIT_FAILURE);\n\n    if (cr.errors > 0)\n      exit_with_code(EXIT_FAILURE);\n\n    if (fail_on_warnings && cr.warnings > 0)\n      exit_with_code(EXIT_FAILURE);\n\n    result = yr_compiler_get_rules(compiler, &rules);\n\n    yr_compiler_destroy(compiler);\n\n    compiler = NULL;\n  }\n\n  if (result != ERROR_SUCCESS)\n  {\n    print_error(result);\n    exit_with_code(EXIT_FAILURE);\n  }\n\n  if (show_stats)\n    print_rules_stats(rules);\n\n  cli_mutex_init(&output_mutex);\n\n  if (fast_scan)\n    flags |= SCAN_FLAGS_FAST_MODE;\n\n  scan_opts.deadline = time(NULL) + timeout;\n\n  arg_is_dir = is_directory(argv[argc - 1]);\n\n  if (scan_list_search && arg_is_dir)\n  {\n    fprintf(stderr, \"error: cannot use a directory as scan list.\\n\");\n    exit_with_code(EXIT_FAILURE);\n  }\n  else if (scan_list_search || arg_is_dir)\n  {\n    if (file_queue_init() != 0)\n    {\n      print_error(ERROR_INTERNAL_FATAL_ERROR);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    THREAD thread[YR_MAX_THREADS];\n    THREAD_ARGS thread_args[YR_MAX_THREADS];\n\n    for (int i = 0; i < threads; i++)\n    {\n      thread_args[i].deadline = scan_opts.deadline;\n      thread_args[i].current_count = 0;\n\n      result = yr_scanner_create(rules, &thread_args[i].scanner);\n\n      if (result != ERROR_SUCCESS)\n      {\n        print_error(result);\n        exit_with_code(EXIT_FAILURE);\n      }\n\n      yr_scanner_set_callback(\n          thread_args[i].scanner, callback, &thread_args[i].callback_args);\n\n      yr_scanner_set_flags(thread_args[i].scanner, flags);\n\n      if (cli_create_thread(\n              &thread[i], scanning_thread, (void*) &thread_args[i]))\n      {\n        print_error(ERROR_COULD_NOT_CREATE_THREAD);\n        exit_with_code(EXIT_FAILURE);\n      }\n    }\n\n    if (arg_is_dir)\n    {\n      scan_dir(argv[argc - 1], &scan_opts);\n    }\n    else\n    {\n      result = populate_scan_list(argv[argc - 1], &scan_opts);\n\n      if (result != ERROR_SUCCESS)\n        exit_with_code(EXIT_FAILURE);\n    }\n\n    file_queue_finish();\n\n    // Wait for scan threads to finish\n    for (int i = 0; i < threads; i++) cli_thread_join(&thread[i]);\n\n    for (int i = 0; i < threads; i++)\n      yr_scanner_destroy(thread_args[i].scanner);\n\n    file_queue_destroy();\n  }\n  else\n  {\n    CALLBACK_ARGS user_data = {argv[argc - 1], 0};\n\n    result = yr_scanner_create(rules, &scanner);\n\n    if (result != ERROR_SUCCESS)\n    {\n      _ftprintf(stderr, _T(\"error: %d\\n\"), result);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    yr_scanner_set_callback(scanner, callback, &user_data);\n    yr_scanner_set_flags(scanner, flags);\n    yr_scanner_set_timeout(scanner, timeout);\n\n    // Assume the last argument is a file first. This assures we try to process\n    // files that start with numbers first.\n    result = scan_file(scanner, argv[argc - 1]);\n\n    if (result == ERROR_COULD_NOT_OPEN_FILE)\n    {\n      // Is it a PID? To be a PID it must be made up entirely of digits.\n      char* endptr = NULL;\n      long pid = _tcstol(argv[argc - 1], &endptr, 10);\n\n      if (pid > 0 && argv[argc - 1] != NULL && *endptr == '\\x00')\n        result = yr_scanner_scan_proc(scanner, (int) pid);\n    }\n\n    if (result != ERROR_SUCCESS)\n    {\n      _ftprintf(stderr, _T(\"error scanning %s: \"), argv[argc - 1]);\n      print_scanner_error(scanner, result);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    if (print_count_only)\n      _tprintf(_T(\"%d\\n\"), user_data.current_count);\n\n#ifdef YR_PROFILING_ENABLED\n    yr_scanner_print_profiling_info(scanner);\n#endif\n  }\n\n  result = EXIT_SUCCESS;\n\n_exit:\n\n  unload_modules_data();\n\n  if (scanner != NULL)\n    yr_scanner_destroy(scanner);\n\n  if (compiler != NULL)\n    yr_compiler_destroy(compiler);\n\n  if (rules != NULL)\n    yr_rules_destroy(rules);\n\n  yr_finalize();\n\n  args_free(options);\n\n  return result;\n}",
  "abstract_func_before": "int _tmain(int VAR_0, const char_t** VAR_1)\n{\n  COMPILER_RESULTS VAR_2;\n\n  YR_COMPILER* VAR_3 = NULL;\n  YR_RULES* VAR_4 = NULL;\n  YR_SCANNER* VAR_5 = NULL;\n  SCAN_OPTIONS VAR_6;\n\n  bool VAR_7 = false;\n  int VAR_8 = 0;\n  int VAR_9;\n\n  VAR_0 = args_parse(VAR_10, VAR_0, VAR_1);\n\n  VAR_6.follow_symlinks = VAR_11;\n  VAR_6.recursive_search = VAR_12;\n\n  if (VAR_13)\n  {\n    printf(\"%s\\n\", VAR_14);\n    return VAR_15;\n  }\n\n  if (VAR_16)\n  {\n    printf(\n        \"YARA %s, the pattern matching swiss army knife.\\n\"\n        \"%s\\n\\n\"\n        \"Mandatory arguments to long options are mandatory for \"\n        \"short options too.\\n\\n\",\n        VAR_14,\n        VAR_17);\n\n    args_print_usage(VAR_10, 43);\n    printf(\n        \"\\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\\n\");\n\n    return VAR_15;\n  }\n\n  if (VAR_18 > VAR_19)\n  {\n    fprintf(VAR_20, \"maximum number of threads is %d\\n\", VAR_19);\n    return VAR_21;\n  }\n\n  if (VAR_0 < 2)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n\n    fprintf(VAR_20, \"yara: wrong number of arguments\\n\");\n    fprintf(VAR_20, \"%s\\n\\n\", VAR_17);\n    fprintf(VAR_20, \"Try `--help` for more options\\n\");\n\n    return VAR_21;\n  }\n\n#if defined(VAR_22) && defined(VAR_23)\n  /* COMMENT_3 */\n  if (_setmode(_fileno(VAR_24), VAR_25) == -1)\n  {\n    return VAR_21;\n  }\n#endif\n\n  if (!load_modules_data())\n    exit_with_code(VAR_21);\n\n  VAR_9 = yr_initialize();\n\n  if (VAR_9 != VAR_26)\n  {\n    fprintf(VAR_20, \"error: initialization error (%d)\\n\", VAR_9);\n    exit_with_code(VAR_21);\n  }\n\n  yr_set_configuration(VAR_27, &VAR_28);\n  yr_set_configuration(VAR_29, &VAR_30);\n  yr_set_configuration(\n      VAR_31, &VAR_32);\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n\n  if (VAR_33)\n  {\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n\n    if (VAR_0 != 2)\n    {\n      fprintf(\n          VAR_20,\n          \"error: can't accept multiple rules files if one of them is in \"\n          \"compiled form.\\n\");\n      exit_with_code(VAR_21);\n    }\n\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n\n    FILE* VAR_34 = _tfopen(VAR_1[0], _T(\"rb\"));\n\n    if (VAR_34 != NULL)\n    {\n      YR_STREAM VAR_35;\n\n      VAR_35.user_data = VAR_34;\n      VAR_35.read = (YR_STREAM_READ_FUNC) VAR_36;\n\n      VAR_9 = yr_rules_load_stream(&VAR_35, &VAR_4);\n\n      fclose(VAR_34);\n\n      if (VAR_9 == VAR_26)\n        VAR_9 = define_external_variables(VAR_37, VAR_4, NULL);\n    }\n    else\n    {\n      VAR_9 = VAR_38;\n    }\n  }\n  else\n  {\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n\n    if (yr_compiler_create(&VAR_3) != VAR_26)\n      exit_with_code(VAR_21);\n\n    VAR_9 = define_external_variables(VAR_37, NULL, VAR_3);\n\n    if (VAR_9 != VAR_26)\n    {\n      print_error(VAR_9);\n      exit_with_code(VAR_21);\n    }\n\n    if (VAR_39 != NULL)\n    {\n      VAR_9 = yr_compiler_load_atom_quality_table(\n          VAR_3, VAR_39, 0);\n\n      if (VAR_9 != VAR_26)\n      {\n        fprintf(VAR_20, \"error loading atom quality table: \");\n        print_error(VAR_9);\n        exit_with_code(VAR_21);\n      }\n    }\n\n    VAR_2.errors = 0;\n    VAR_2.warnings = 0;\n\n    yr_compiler_set_callback(VAR_3, VAR_40, &VAR_2);\n\n    if (!compile_files(VAR_3, VAR_0, VAR_1))\n      exit_with_code(VAR_21);\n\n    if (VAR_2.errors > 0)\n      exit_with_code(VAR_21);\n\n    if (VAR_41 && VAR_2.warnings > 0)\n      exit_with_code(VAR_21);\n\n    VAR_9 = yr_compiler_get_rules(VAR_3, &VAR_4);\n\n    yr_compiler_destroy(VAR_3);\n\n    VAR_3 = NULL;\n  }\n\n  if (VAR_9 != VAR_26)\n  {\n    print_error(VAR_9);\n    exit_with_code(VAR_21);\n  }\n\n  if (VAR_42)\n    print_rules_stats(VAR_4);\n\n  cli_mutex_init(&VAR_43);\n\n  if (VAR_44)\n    VAR_8 |= VAR_45;\n\n  VAR_6.deadline = time(NULL) + VAR_46;\n\n  VAR_7 = is_directory(VAR_1[VAR_0 - 1]);\n\n  if (VAR_47 && VAR_7)\n  {\n    fprintf(VAR_20, \"error: cannot use a directory as scan list.\\n\");\n    exit_with_code(VAR_21);\n  }\n  else if (VAR_47 || VAR_7)\n  {\n    if (file_queue_init() != 0)\n    {\n      print_error(VAR_48);\n      exit_with_code(VAR_21);\n    }\n\n    THREAD VAR_49[VAR_19];\n    THREAD_ARGS VAR_50[VAR_19];\n\n    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)\n    {\n      VAR_50[VAR_51].deadline = VAR_6.deadline;\n      VAR_50[VAR_51].current_count = 0;\n\n      VAR_9 = yr_scanner_create(VAR_4, &VAR_50[VAR_51].scanner);\n\n      if (VAR_9 != VAR_26)\n      {\n        print_error(VAR_9);\n        exit_with_code(VAR_21);\n      }\n\n      yr_scanner_set_callback(\n          VAR_50[VAR_51].scanner, VAR_52, &VAR_50[VAR_51].callback_args);\n\n      yr_scanner_set_flags(VAR_50[VAR_51].scanner, VAR_8);\n\n      if (cli_create_thread(\n              &VAR_49[VAR_51], VAR_53, (void*) &VAR_50[VAR_51]))\n      {\n        print_error(VAR_54);\n        exit_with_code(VAR_21);\n      }\n    }\n\n    if (VAR_7)\n    {\n      scan_dir(VAR_1[VAR_0 - 1], &VAR_6);\n    }\n    else\n    {\n      VAR_9 = populate_scan_list(VAR_1[VAR_0 - 1], &VAR_6);\n\n      if (VAR_9 != VAR_26)\n        exit_with_code(VAR_21);\n    }\n\n    file_queue_finish();\n\n    /* COMMENT_13 */\n    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++) cli_thread_join(&VAR_49[VAR_51]);\n\n    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)\n      yr_scanner_destroy(VAR_50[VAR_51].scanner);\n\n    file_queue_destroy();\n  }\n  else\n  {\n    CALLBACK_ARGS VAR_55 = {VAR_1[VAR_0 - 1], 0};\n\n    VAR_9 = yr_scanner_create(VAR_4, &VAR_5);\n\n    if (VAR_9 != VAR_26)\n    {\n      _ftprintf(VAR_20, _T(\"error: %d\\n\"), VAR_9);\n      exit_with_code(VAR_21);\n    }\n\n    yr_scanner_set_callback(VAR_5, VAR_52, &VAR_55);\n    yr_scanner_set_flags(VAR_5, VAR_8);\n    yr_scanner_set_timeout(VAR_5, VAR_46);\n\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    VAR_9 = scan_file(VAR_5, VAR_1[VAR_0 - 1]);\n\n    if (VAR_9 == VAR_38)\n    {\n      /* COMMENT_16 */\n      char* VAR_56 = NULL;\n      long VAR_57 = _tcstol(VAR_1[VAR_0 - 1], &VAR_56, 10);\n\n      if (VAR_57 > 0 && VAR_1[VAR_0 - 1] != NULL && *VAR_56 == '\\x00')\n        VAR_9 = yr_scanner_scan_proc(VAR_5, (int) VAR_57);\n    }\n\n    if (VAR_9 != VAR_26)\n    {\n      _ftprintf(VAR_20, _T(\"error scanning %s: \"), VAR_1[VAR_0 - 1]);\n      print_scanner_error(VAR_5, VAR_9);\n      exit_with_code(VAR_21);\n    }\n\n    if (VAR_58)\n      _tprintf(_T(\"%d\\n\"), VAR_55.current_count);\n\n#ifdef VAR_59\n    yr_scanner_print_profiling_info(VAR_5);\n#endif\n  }\n\n  VAR_9 = VAR_15;\n\n_exit:\n\n  unload_modules_data();\n\n  if (VAR_5 != NULL)\n    yr_scanner_destroy(VAR_5);\n\n  if (VAR_3 != NULL)\n    yr_compiler_destroy(VAR_3);\n\n  if (VAR_4 != NULL)\n    yr_rules_destroy(VAR_4);\n\n  yr_finalize();\n\n  args_free(VAR_10);\n\n  return VAR_9;\n}",
  "func_graph_path_before": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/yara.c/vul/before/0.json",
  "func": "int _tmain(int argc, const char_t** argv)\n{\n  COMPILER_RESULTS cr;\n\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n  YR_SCANNER* scanner = NULL;\n  SCAN_OPTIONS scan_opts;\n\n  bool arg_is_dir = false;\n  int flags = 0;\n  int result;\n\n  argc = args_parse(options, argc, argv);\n\n  scan_opts.follow_symlinks = follow_symlinks;\n  scan_opts.recursive_search = recursive_search;\n\n  if (show_version)\n  {\n    printf(\"%s\\n\", YR_VERSION);\n    return EXIT_SUCCESS;\n  }\n\n  if (show_help)\n  {\n    printf(\n        \"YARA %s, the pattern matching swiss army knife.\\n\"\n        \"%s\\n\\n\"\n        \"Mandatory arguments to long options are mandatory for \"\n        \"short options too.\\n\\n\",\n        YR_VERSION,\n        USAGE_STRING);\n\n    args_print_usage(options, 43);\n    printf(\n        \"\\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\\n\");\n\n    return EXIT_SUCCESS;\n  }\n\n  if (threads > YR_MAX_THREADS)\n  {\n    fprintf(stderr, \"maximum number of threads is %d\\n\", YR_MAX_THREADS);\n    return EXIT_FAILURE;\n  }\n\n  if (argc < 2)\n  {\n    // After parsing the command-line options we expect two additional\n    // arguments, the rules file and the target file, directory or pid to\n    // be scanned.\n\n    fprintf(stderr, \"yara: wrong number of arguments\\n\");\n    fprintf(stderr, \"%s\\n\\n\", USAGE_STRING);\n    fprintf(stderr, \"Try `--help` for more options\\n\");\n\n    return EXIT_FAILURE;\n  }\n\n#if defined(_WIN32) && defined(_UNICODE)\n  // In Windows set stdout to UTF-8 mode.\n  if (_setmode(_fileno(stdout), _O_U8TEXT) == -1)\n  {\n    return EXIT_FAILURE;\n  }\n#endif\n\n  if (!load_modules_data())\n    exit_with_code(EXIT_FAILURE);\n\n  result = yr_initialize();\n\n  if (result != ERROR_SUCCESS)\n  {\n    fprintf(stderr, \"error: initialization error (%d)\\n\", result);\n    exit_with_code(EXIT_FAILURE);\n  }\n\n  yr_set_configuration_uint32(YR_CONFIG_STACK_SIZE, stack_size);\n\n  yr_set_configuration_uint32(\n      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);\n\n  yr_set_configuration_uint64(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, max_process_memory_chunk);\n\n  // Try to load the rules file as a binary file containing\n  // compiled rules first\n\n  if (rules_are_compiled)\n  {\n    // When a binary file containing compiled rules is provided, yara accepts\n    // only two arguments, the compiled rules file and the target to be scanned.\n\n    if (argc != 2)\n    {\n      fprintf(\n          stderr,\n          \"error: can't accept multiple rules files if one of them is in \"\n          \"compiled form.\\n\");\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    // Not using yr_rules_load because it does not have support for unicode\n    // file names. Instead use open _tfopen for openning the file and\n    // yr_rules_load_stream for loading the rules from it.\n\n    FILE* fh = _tfopen(argv[0], _T(\"rb\"));\n\n    if (fh != NULL)\n    {\n      YR_STREAM stream;\n\n      stream.user_data = fh;\n      stream.read = (YR_STREAM_READ_FUNC) fread;\n\n      result = yr_rules_load_stream(&stream, &rules);\n\n      fclose(fh);\n\n      if (result == ERROR_SUCCESS)\n        result = define_external_variables(ext_vars, rules, NULL);\n    }\n    else\n    {\n      result = ERROR_COULD_NOT_OPEN_FILE;\n    }\n  }\n  else\n  {\n    // Rules file didn't contain compiled rules, let's handle it\n    // as a text file containing rules in source form.\n\n    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n      exit_with_code(EXIT_FAILURE);\n\n    result = define_external_variables(ext_vars, NULL, compiler);\n\n    if (result != ERROR_SUCCESS)\n    {\n      print_error(result);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    if (atom_quality_table != NULL)\n    {\n      result = yr_compiler_load_atom_quality_table(\n          compiler, atom_quality_table, 0);\n\n      if (result != ERROR_SUCCESS)\n      {\n        fprintf(stderr, \"error loading atom quality table: \");\n        print_error(result);\n        exit_with_code(EXIT_FAILURE);\n      }\n    }\n\n    cr.errors = 0;\n    cr.warnings = 0;\n\n    yr_compiler_set_callback(compiler, print_compiler_error, &cr);\n\n    if (!compile_files(compiler, argc, argv))\n      exit_with_code(EXIT_FAILURE);\n\n    if (cr.errors > 0)\n      exit_with_code(EXIT_FAILURE);\n\n    if (fail_on_warnings && cr.warnings > 0)\n      exit_with_code(EXIT_FAILURE);\n\n    result = yr_compiler_get_rules(compiler, &rules);\n\n    yr_compiler_destroy(compiler);\n\n    compiler = NULL;\n  }\n\n  if (result != ERROR_SUCCESS)\n  {\n    print_error(result);\n    exit_with_code(EXIT_FAILURE);\n  }\n\n  if (show_stats)\n    print_rules_stats(rules);\n\n  cli_mutex_init(&output_mutex);\n\n  if (fast_scan)\n    flags |= SCAN_FLAGS_FAST_MODE;\n\n  scan_opts.deadline = time(NULL) + timeout;\n\n  arg_is_dir = is_directory(argv[argc - 1]);\n\n  if (scan_list_search && arg_is_dir)\n  {\n    fprintf(stderr, \"error: cannot use a directory as scan list.\\n\");\n    exit_with_code(EXIT_FAILURE);\n  }\n  else if (scan_list_search || arg_is_dir)\n  {\n    if (file_queue_init() != 0)\n    {\n      print_error(ERROR_INTERNAL_FATAL_ERROR);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    THREAD thread[YR_MAX_THREADS];\n    THREAD_ARGS thread_args[YR_MAX_THREADS];\n\n    for (int i = 0; i < threads; i++)\n    {\n      thread_args[i].deadline = scan_opts.deadline;\n      thread_args[i].current_count = 0;\n\n      result = yr_scanner_create(rules, &thread_args[i].scanner);\n\n      if (result != ERROR_SUCCESS)\n      {\n        print_error(result);\n        exit_with_code(EXIT_FAILURE);\n      }\n\n      yr_scanner_set_callback(\n          thread_args[i].scanner, callback, &thread_args[i].callback_args);\n\n      yr_scanner_set_flags(thread_args[i].scanner, flags);\n\n      if (cli_create_thread(\n              &thread[i], scanning_thread, (void*) &thread_args[i]))\n      {\n        print_error(ERROR_COULD_NOT_CREATE_THREAD);\n        exit_with_code(EXIT_FAILURE);\n      }\n    }\n\n    if (arg_is_dir)\n    {\n      scan_dir(argv[argc - 1], &scan_opts);\n    }\n    else\n    {\n      result = populate_scan_list(argv[argc - 1], &scan_opts);\n\n      if (result != ERROR_SUCCESS)\n        exit_with_code(EXIT_FAILURE);\n    }\n\n    file_queue_finish();\n\n    // Wait for scan threads to finish\n    for (int i = 0; i < threads; i++) cli_thread_join(&thread[i]);\n\n    for (int i = 0; i < threads; i++)\n      yr_scanner_destroy(thread_args[i].scanner);\n\n    file_queue_destroy();\n  }\n  else\n  {\n    CALLBACK_ARGS user_data = {argv[argc - 1], 0};\n\n    result = yr_scanner_create(rules, &scanner);\n\n    if (result != ERROR_SUCCESS)\n    {\n      _ftprintf(stderr, _T(\"error: %d\\n\"), result);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    yr_scanner_set_callback(scanner, callback, &user_data);\n    yr_scanner_set_flags(scanner, flags);\n    yr_scanner_set_timeout(scanner, timeout);\n\n    // Assume the last argument is a file first. This assures we try to process\n    // files that start with numbers first.\n    result = scan_file(scanner, argv[argc - 1]);\n\n    if (result == ERROR_COULD_NOT_OPEN_FILE)\n    {\n      // Is it a PID? To be a PID it must be made up entirely of digits.\n      char* endptr = NULL;\n      long pid = _tcstol(argv[argc - 1], &endptr, 10);\n\n      if (pid > 0 && argv[argc - 1] != NULL && *endptr == '\\x00')\n        result = yr_scanner_scan_proc(scanner, (int) pid);\n    }\n\n    if (result != ERROR_SUCCESS)\n    {\n      _ftprintf(stderr, _T(\"error scanning %s: \"), argv[argc - 1]);\n      print_scanner_error(scanner, result);\n      exit_with_code(EXIT_FAILURE);\n    }\n\n    if (print_count_only)\n      _tprintf(_T(\"%d\\n\"), user_data.current_count);\n\n#ifdef YR_PROFILING_ENABLED\n    yr_scanner_print_profiling_info(scanner);\n#endif\n  }\n\n  result = EXIT_SUCCESS;\n\n_exit:\n\n  unload_modules_data();\n\n  if (scanner != NULL)\n    yr_scanner_destroy(scanner);\n\n  if (compiler != NULL)\n    yr_compiler_destroy(compiler);\n\n  if (rules != NULL)\n    yr_rules_destroy(rules);\n\n  yr_finalize();\n\n  args_free(options);\n\n  return result;\n}",
  "abstract_func": "int _tmain(int VAR_0, const char_t** VAR_1)\n{\n  COMPILER_RESULTS VAR_2;\n\n  YR_COMPILER* VAR_3 = NULL;\n  YR_RULES* VAR_4 = NULL;\n  YR_SCANNER* VAR_5 = NULL;\n  SCAN_OPTIONS VAR_6;\n\n  bool VAR_7 = false;\n  int VAR_8 = 0;\n  int VAR_9;\n\n  VAR_0 = args_parse(VAR_10, VAR_0, VAR_1);\n\n  VAR_6.follow_symlinks = VAR_11;\n  VAR_6.recursive_search = VAR_12;\n\n  if (VAR_13)\n  {\n    printf(\"%s\\n\", VAR_14);\n    return VAR_15;\n  }\n\n  if (VAR_16)\n  {\n    printf(\n        \"YARA %s, the pattern matching swiss army knife.\\n\"\n        \"%s\\n\\n\"\n        \"Mandatory arguments to long options are mandatory for \"\n        \"short options too.\\n\\n\",\n        VAR_14,\n        VAR_17);\n\n    args_print_usage(VAR_10, 43);\n    printf(\n        \"\\nSend bug reports and suggestions to: vmalvarez@virustotal.com.\\n\");\n\n    return VAR_15;\n  }\n\n  if (VAR_18 > VAR_19)\n  {\n    fprintf(VAR_20, \"maximum number of threads is %d\\n\", VAR_19);\n    return VAR_21;\n  }\n\n  if (VAR_0 < 2)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n\n    fprintf(VAR_20, \"yara: wrong number of arguments\\n\");\n    fprintf(VAR_20, \"%s\\n\\n\", VAR_17);\n    fprintf(VAR_20, \"Try `--help` for more options\\n\");\n\n    return VAR_21;\n  }\n\n#if defined(VAR_22) && defined(VAR_23)\n  /* COMMENT_3 */\n  if (_setmode(_fileno(VAR_24), VAR_25) == -1)\n  {\n    return VAR_21;\n  }\n#endif\n\n  if (!load_modules_data())\n    exit_with_code(VAR_21);\n\n  VAR_9 = yr_initialize();\n\n  if (VAR_9 != VAR_26)\n  {\n    fprintf(VAR_20, \"error: initialization error (%d)\\n\", VAR_9);\n    exit_with_code(VAR_21);\n  }\n\n  yr_set_configuration_uint32(VAR_27, VAR_28);\n\n  yr_set_configuration_uint32(\n      VAR_29, VAR_30);\n\n  yr_set_configuration_uint64(\n      VAR_31, VAR_32);\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n\n  if (VAR_33)\n  {\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n\n    if (VAR_0 != 2)\n    {\n      fprintf(\n          VAR_20,\n          \"error: can't accept multiple rules files if one of them is in \"\n          \"compiled form.\\n\");\n      exit_with_code(VAR_21);\n    }\n\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n\n    FILE* VAR_34 = _tfopen(VAR_1[0], _T(\"rb\"));\n\n    if (VAR_34 != NULL)\n    {\n      YR_STREAM VAR_35;\n\n      VAR_35.user_data = VAR_34;\n      VAR_35.read = (YR_STREAM_READ_FUNC) VAR_36;\n\n      VAR_9 = yr_rules_load_stream(&VAR_35, &VAR_4);\n\n      fclose(VAR_34);\n\n      if (VAR_9 == VAR_26)\n        VAR_9 = define_external_variables(VAR_37, VAR_4, NULL);\n    }\n    else\n    {\n      VAR_9 = VAR_38;\n    }\n  }\n  else\n  {\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n\n    if (yr_compiler_create(&VAR_3) != VAR_26)\n      exit_with_code(VAR_21);\n\n    VAR_9 = define_external_variables(VAR_37, NULL, VAR_3);\n\n    if (VAR_9 != VAR_26)\n    {\n      print_error(VAR_9);\n      exit_with_code(VAR_21);\n    }\n\n    if (VAR_39 != NULL)\n    {\n      VAR_9 = yr_compiler_load_atom_quality_table(\n          VAR_3, VAR_39, 0);\n\n      if (VAR_9 != VAR_26)\n      {\n        fprintf(VAR_20, \"error loading atom quality table: \");\n        print_error(VAR_9);\n        exit_with_code(VAR_21);\n      }\n    }\n\n    VAR_2.errors = 0;\n    VAR_2.warnings = 0;\n\n    yr_compiler_set_callback(VAR_3, VAR_40, &VAR_2);\n\n    if (!compile_files(VAR_3, VAR_0, VAR_1))\n      exit_with_code(VAR_21);\n\n    if (VAR_2.errors > 0)\n      exit_with_code(VAR_21);\n\n    if (VAR_41 && VAR_2.warnings > 0)\n      exit_with_code(VAR_21);\n\n    VAR_9 = yr_compiler_get_rules(VAR_3, &VAR_4);\n\n    yr_compiler_destroy(VAR_3);\n\n    VAR_3 = NULL;\n  }\n\n  if (VAR_9 != VAR_26)\n  {\n    print_error(VAR_9);\n    exit_with_code(VAR_21);\n  }\n\n  if (VAR_42)\n    print_rules_stats(VAR_4);\n\n  cli_mutex_init(&VAR_43);\n\n  if (VAR_44)\n    VAR_8 |= VAR_45;\n\n  VAR_6.deadline = time(NULL) + VAR_46;\n\n  VAR_7 = is_directory(VAR_1[VAR_0 - 1]);\n\n  if (VAR_47 && VAR_7)\n  {\n    fprintf(VAR_20, \"error: cannot use a directory as scan list.\\n\");\n    exit_with_code(VAR_21);\n  }\n  else if (VAR_47 || VAR_7)\n  {\n    if (file_queue_init() != 0)\n    {\n      print_error(VAR_48);\n      exit_with_code(VAR_21);\n    }\n\n    THREAD VAR_49[VAR_19];\n    THREAD_ARGS VAR_50[VAR_19];\n\n    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)\n    {\n      VAR_50[VAR_51].deadline = VAR_6.deadline;\n      VAR_50[VAR_51].current_count = 0;\n\n      VAR_9 = yr_scanner_create(VAR_4, &VAR_50[VAR_51].scanner);\n\n      if (VAR_9 != VAR_26)\n      {\n        print_error(VAR_9);\n        exit_with_code(VAR_21);\n      }\n\n      yr_scanner_set_callback(\n          VAR_50[VAR_51].scanner, VAR_52, &VAR_50[VAR_51].callback_args);\n\n      yr_scanner_set_flags(VAR_50[VAR_51].scanner, VAR_8);\n\n      if (cli_create_thread(\n              &VAR_49[VAR_51], VAR_53, (void*) &VAR_50[VAR_51]))\n      {\n        print_error(VAR_54);\n        exit_with_code(VAR_21);\n      }\n    }\n\n    if (VAR_7)\n    {\n      scan_dir(VAR_1[VAR_0 - 1], &VAR_6);\n    }\n    else\n    {\n      VAR_9 = populate_scan_list(VAR_1[VAR_0 - 1], &VAR_6);\n\n      if (VAR_9 != VAR_26)\n        exit_with_code(VAR_21);\n    }\n\n    file_queue_finish();\n\n    /* COMMENT_13 */\n    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++) cli_thread_join(&VAR_49[VAR_51]);\n\n    for (int VAR_51 = 0; VAR_51 < VAR_18; VAR_51++)\n      yr_scanner_destroy(VAR_50[VAR_51].scanner);\n\n    file_queue_destroy();\n  }\n  else\n  {\n    CALLBACK_ARGS VAR_55 = {VAR_1[VAR_0 - 1], 0};\n\n    VAR_9 = yr_scanner_create(VAR_4, &VAR_5);\n\n    if (VAR_9 != VAR_26)\n    {\n      _ftprintf(VAR_20, _T(\"error: %d\\n\"), VAR_9);\n      exit_with_code(VAR_21);\n    }\n\n    yr_scanner_set_callback(VAR_5, VAR_52, &VAR_55);\n    yr_scanner_set_flags(VAR_5, VAR_8);\n    yr_scanner_set_timeout(VAR_5, VAR_46);\n\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    VAR_9 = scan_file(VAR_5, VAR_1[VAR_0 - 1]);\n\n    if (VAR_9 == VAR_38)\n    {\n      /* COMMENT_16 */\n      char* VAR_56 = NULL;\n      long VAR_57 = _tcstol(VAR_1[VAR_0 - 1], &VAR_56, 10);\n\n      if (VAR_57 > 0 && VAR_1[VAR_0 - 1] != NULL && *VAR_56 == '\\x00')\n        VAR_9 = yr_scanner_scan_proc(VAR_5, (int) VAR_57);\n    }\n\n    if (VAR_9 != VAR_26)\n    {\n      _ftprintf(VAR_20, _T(\"error scanning %s: \"), VAR_1[VAR_0 - 1]);\n      print_scanner_error(VAR_5, VAR_9);\n      exit_with_code(VAR_21);\n    }\n\n    if (VAR_58)\n      _tprintf(_T(\"%d\\n\"), VAR_55.current_count);\n\n#ifdef VAR_59\n    yr_scanner_print_profiling_info(VAR_5);\n#endif\n  }\n\n  VAR_9 = VAR_15;\n\n_exit:\n\n  unload_modules_data();\n\n  if (VAR_5 != NULL)\n    yr_scanner_destroy(VAR_5);\n\n  if (VAR_3 != NULL)\n    yr_compiler_destroy(VAR_3);\n\n  if (VAR_4 != NULL)\n    yr_rules_destroy(VAR_4);\n\n  yr_finalize();\n\n  args_free(VAR_10);\n\n  return VAR_9;\n}",
  "func_graph_path": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/yara.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -77,10 +77,13 @@\n     exit_with_code(EXIT_FAILURE);\n   }\n \n-  yr_set_configuration(YR_CONFIG_STACK_SIZE, &stack_size);\n-  yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);\n-  yr_set_configuration(\n-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n+  yr_set_configuration_uint32(YR_CONFIG_STACK_SIZE, stack_size);\n+\n+  yr_set_configuration_uint32(\n+      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);\n+\n+  yr_set_configuration_uint64(\n+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, max_process_memory_chunk);\n \n   // Try to load the rules file as a binary file containing\n   // compiled rules first",
  "diff_line_info": {
    "deleted_lines": [
      "  yr_set_configuration(YR_CONFIG_STACK_SIZE, &stack_size);",
      "  yr_set_configuration(YR_CONFIG_MAX_STRINGS_PER_RULE, &max_strings_per_rule);",
      "  yr_set_configuration(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);"
    ],
    "added_lines": [
      "  yr_set_configuration_uint32(YR_CONFIG_STACK_SIZE, stack_size);",
      "",
      "  yr_set_configuration_uint32(",
      "      YR_CONFIG_MAX_STRINGS_PER_RULE, max_strings_per_rule);",
      "",
      "  yr_set_configuration_uint64(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, max_process_memory_chunk);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": {
    "pr_info": {
      "title": "Fix issue #1616",
      "number": 1621
    },
    "comment": [
      "This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.95"
}