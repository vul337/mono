{
  "cve_id": "CVE-2023-41359",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Make sure we have enough data to read two bytes when validating AIGP\n\nFound when fuzzing:\n\n```\n==3470861==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xffff77801ef7 at pc 0xaaaaba7b3dbc bp 0xffffcff0e760 sp 0xffffcff0df50\nREAD of size 2 at 0xffff77801ef7 thread T0\n    0 0xaaaaba7b3db8 in __asan_memcpy (/home/ubuntu/frr_8_5_2/frr_8_5_2_fuzz_clang/bgpd/bgpd+0x363db8) (BuildId: cc710a2356e31c7f4e4a17595b54de82145a6e21)\n    1 0xaaaaba81a8ac in ptr_get_be16 /home/ubuntu/frr_8_5_2/frr_8_5_2_fuzz_clang/./lib/stream.h:399:2\n    2 0xaaaaba819f2c in bgp_attr_aigp_valid /home/ubuntu/frr_8_5_2/frr_8_5_2_fuzz_clang/bgpd/bgp_attr.c:504:3\n    3 0xaaaaba808c20 in bgp_attr_aigp /home/ubuntu/frr_8_5_2/frr_8_5_2_fuzz_clang/bgpd/bgp_attr.c:3275:7\n    4 0xaaaaba7ff4e0 in bgp_attr_parse /home/ubuntu/frr_8_5_2/frr_8_5_2_fuzz_clang/bgpd/bgp_attr.c:3678:10\n```\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",
  "commit_hash": "f96201e104892e18493f24cf67bb713678e8237b",
  "git_url": "https://github.com/FRRouting/frr/commit/f96201e104892e18493f24cf67bb713678e8237b",
  "file_path": "bgpd/bgp_attr.c",
  "func_name": "bgp_attr_aigp_valid",
  "func_before": "static bool bgp_attr_aigp_valid(uint8_t *pnt, int length)\n{\n\tuint8_t *data = pnt;\n\tuint8_t tlv_type;\n\tuint16_t tlv_length;\n\n\tif (length < 3) {\n\t\tzlog_err(\"Bad AIGP attribute length (MUST be minimum 3): %u\",\n\t\t\t length);\n\t\treturn false;\n\t}\n\n\twhile (length) {\n\t\ttlv_type = *data;\n\t\tptr_get_be16(data + 1, &tlv_length);\n\t\t(void)data;\n\n\t\tif (length < tlv_length) {\n\t\t\tzlog_err(\n\t\t\t\t\"Bad AIGP attribute length: %u, but TLV length: %u\",\n\t\t\t\tlength, tlv_length);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (tlv_length < 3) {\n\t\t\tzlog_err(\"Bad AIGP TLV length (MUST be minimum 3): %u\",\n\t\t\t\t tlv_length);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* AIGP TLV, Length: 11 */\n\t\tif (tlv_type == BGP_AIGP_TLV_METRIC &&\n\t\t    tlv_length != BGP_AIGP_TLV_METRIC_LEN) {\n\t\t\tzlog_err(\"Bad AIGP TLV (%s) length: %u\",\n\t\t\t\t BGP_AIGP_TLV_METRIC_DESC, tlv_length);\n\t\t\treturn false;\n\t\t}\n\n\t\tdata += tlv_length;\n\t\tlength -= tlv_length;\n\t}\n\n\treturn true;\n}",
  "abstract_func_before": "static bool bgp_attr_aigp_valid(uint8_t *VAR_0, int VAR_1)\n{\n\tuint8_t *VAR_2 = VAR_0;\n\tuint8_t VAR_3;\n\tuint16_t VAR_4;\n\n\tif (VAR_1 < 3) {\n\t\tzlog_err(\"Bad AIGP attribute length (MUST be minimum 3): %u\",\n\t\t\t VAR_1);\n\t\treturn false;\n\t}\n\n\twhile (VAR_1) {\n\t\tVAR_3 = *VAR_2;\n\t\tptr_get_be16(VAR_2 + 1, &VAR_4);\n\t\t(void)VAR_2;\n\n\t\tif (VAR_1 < VAR_4) {\n\t\t\tzlog_err(\n\t\t\t\t\"Bad AIGP attribute length: %u, but TLV length: %u\",\n\t\t\t\tVAR_1, VAR_4);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (VAR_4 < 3) {\n\t\t\tzlog_err(\"Bad AIGP TLV length (MUST be minimum 3): %u\",\n\t\t\t\t VAR_4);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_3 == VAR_5 &&\n\t\t    VAR_4 != VAR_6) {\n\t\t\tzlog_err(\"Bad AIGP TLV (%s) length: %u\",\n\t\t\t\t VAR_7, VAR_4);\n\t\t\treturn false;\n\t\t}\n\n\t\tVAR_2 += VAR_4;\n\t\tVAR_1 -= VAR_4;\n\t}\n\n\treturn true;\n}",
  "func_graph_path_before": "FRRouting/frr/f96201e104892e18493f24cf67bb713678e8237b/bgp_attr.c/vul/before/0.json",
  "func": "static bool bgp_attr_aigp_valid(uint8_t *pnt, int length)\n{\n\tuint8_t *data = pnt;\n\tuint8_t tlv_type;\n\tuint16_t tlv_length;\n\tuint8_t *end = data + length;\n\n\tif (length < 3) {\n\t\tzlog_err(\"Bad AIGP attribute length (MUST be minimum 3): %u\",\n\t\t\t length);\n\t\treturn false;\n\t}\n\n\twhile (length) {\n\t\tsize_t data_len = end - data;\n\n\t\ttlv_type = *data;\n\n\t\tif (data_len - 1 < 2)\n\t\t\treturn false;\n\n\t\tptr_get_be16(data + 1, &tlv_length);\n\t\t(void)data;\n\n\t\tif (length < tlv_length) {\n\t\t\tzlog_err(\n\t\t\t\t\"Bad AIGP attribute length: %u, but TLV length: %u\",\n\t\t\t\tlength, tlv_length);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (tlv_length < 3) {\n\t\t\tzlog_err(\"Bad AIGP TLV length (MUST be minimum 3): %u\",\n\t\t\t\t tlv_length);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* AIGP TLV, Length: 11 */\n\t\tif (tlv_type == BGP_AIGP_TLV_METRIC &&\n\t\t    tlv_length != BGP_AIGP_TLV_METRIC_LEN) {\n\t\t\tzlog_err(\"Bad AIGP TLV (%s) length: %u\",\n\t\t\t\t BGP_AIGP_TLV_METRIC_DESC, tlv_length);\n\t\t\treturn false;\n\t\t}\n\n\t\tdata += tlv_length;\n\t\tlength -= tlv_length;\n\t}\n\n\treturn true;\n}",
  "abstract_func": "static bool bgp_attr_aigp_valid(uint8_t *VAR_0, int VAR_1)\n{\n\tuint8_t *VAR_2 = VAR_0;\n\tuint8_t VAR_3;\n\tuint16_t VAR_4;\n\tuint8_t *VAR_5 = VAR_2 + VAR_1;\n\n\tif (VAR_1 < 3) {\n\t\tzlog_err(\"Bad AIGP attribute length (MUST be minimum 3): %u\",\n\t\t\t VAR_1);\n\t\treturn false;\n\t}\n\n\twhile (VAR_1) {\n\t\tsize_t VAR_6 = VAR_5 - VAR_2;\n\n\t\tVAR_3 = *VAR_2;\n\n\t\tif (VAR_6 - 1 < 2)\n\t\t\treturn false;\n\n\t\tptr_get_be16(VAR_2 + 1, &VAR_4);\n\t\t(void)VAR_2;\n\n\t\tif (VAR_1 < VAR_4) {\n\t\t\tzlog_err(\n\t\t\t\t\"Bad AIGP attribute length: %u, but TLV length: %u\",\n\t\t\t\tVAR_1, VAR_4);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (VAR_4 < 3) {\n\t\t\tzlog_err(\"Bad AIGP TLV length (MUST be minimum 3): %u\",\n\t\t\t\t VAR_4);\n\t\t\treturn false;\n\t\t}\n\n\t\t/* COMMENT_0 */\n\t\tif (VAR_3 == VAR_7 &&\n\t\t    VAR_4 != VAR_8) {\n\t\t\tzlog_err(\"Bad AIGP TLV (%s) length: %u\",\n\t\t\t\t VAR_9, VAR_4);\n\t\t\treturn false;\n\t\t}\n\n\t\tVAR_2 += VAR_4;\n\t\tVAR_1 -= VAR_4;\n\t}\n\n\treturn true;\n}",
  "func_graph_path": "FRRouting/frr/f96201e104892e18493f24cf67bb713678e8237b/bgp_attr.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n \tuint8_t *data = pnt;\n \tuint8_t tlv_type;\n \tuint16_t tlv_length;\n+\tuint8_t *end = data + length;\n \n \tif (length < 3) {\n \t\tzlog_err(\"Bad AIGP attribute length (MUST be minimum 3): %u\",\n@@ -11,7 +12,13 @@\n \t}\n \n \twhile (length) {\n+\t\tsize_t data_len = end - data;\n+\n \t\ttlv_type = *data;\n+\n+\t\tif (data_len - 1 < 2)\n+\t\t\treturn false;\n+\n \t\tptr_get_be16(data + 1, &tlv_length);\n \t\t(void)data;\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tuint8_t *end = data + length;",
      "\t\tsize_t data_len = end - data;",
      "",
      "",
      "\t\tif (data_len - 1 < 2)",
      "\t\t\treturn false;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/14232",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/FRRouting/frr/pull/14232: 403 Client Error: Forbidden for url: https://api.github.com/repos/FRRouting/frr/pulls/14232",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a buffer overflow vulnerability found via fuzzing by adding checks to prevent reading beyond allocated memory. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}