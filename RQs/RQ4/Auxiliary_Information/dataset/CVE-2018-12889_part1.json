{
  "cve_id": "CVE-2018-12889",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "cn-uofbasel/ccn-lite",
  "commit_msg": "Fix possible heap bufferoverrun when reading ndn- or ccnx-files",
  "commit_hash": "cd1bd188eaf58b1972cf80ce3a5d3f1c81f14bf1",
  "git_url": "https://github.com/cn-uofbasel/ccn-lite/commit/cd1bd188eaf58b1972cf80ce3a5d3f1c81f14bf1",
  "file_path": "src/ccnl-utils/src/ccn-lite-ctrl.c",
  "func_name": "mkAddToRelayCacheRequest",
  "func_before": "int\nmkAddToRelayCacheRequest(unsigned char *out, char *fname,\n                         char *private_key_path, int *suite)\n{\n    long len = 0, len1 = 0, len2 = 0, len3 = 0;\n    unsigned char *contentobj, *stmt, *out1, h[10], *data;\n    int datalen, chunkflag;\n    struct ccnl_prefix_s *prefix;\n    char *prefix_string = NULL;\n    (void)private_key_path;\n\n    FILE *file = fopen(fname, \"r\");\n    if (!file)\n        return 0;\n    //determine size of the file\n    fseek(file, 0L, SEEK_END);\n    datalen = ftell(file);\n    fseek(file, 0L, SEEK_SET);\n    data = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*datalen);\n    fread(data, datalen, 1, file);\n    fclose(file);\n\n    prefix = getPrefix(data, datalen, suite);\n    if (!prefix) {\n        DEBUGMSG(ERROR, \"  no prefix in file %s\\n\", fname);\n        return -1;\n    }\n    DEBUGMSG(DEBUG, \"  prefix in file: <%s>\\n\", ccnl_prefix_to_path(prefix));\n    prefix_string = ccnl_prefix_to_path_detailed(prefix, 0, 1, 1);\n\n    //Create ccn-lite-ctrl interest object with signature to add content...\n    //out = (unsigned char *) malloc(sizeof(unsigned char)*fsize + 5000);\n    out1 = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 5000);\n    contentobj = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 4000);\n    stmt = (unsigned char *) ccnl_malloc(sizeof(unsigned char)* 1000);\n\n    len = ccnl_ccnb_mkHeader(out, CCN_DTAG_INTEREST, CCN_TT_DTAG);   // interest\n    len += ccnl_ccnb_mkHeader(out+len, CCN_DTAG_NAME, CCN_TT_DTAG);  // name\n\n    len1 += ccnl_ccnb_mkStrBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG, \"ccnx\");\n    len1 += ccnl_ccnb_mkStrBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG, \"\");\n    len1 += ccnl_ccnb_mkStrBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG, \"addcacheobject\");\n\n    DEBUGMSG(DEBUG, \"NAME:%s\\n\", prefix_string);\n\n    len3 += ccnl_ccnb_mkStrBlob(stmt+len3, CCN_DTAG_COMPONENT, CCN_TT_DTAG, prefix_string);\n\n\n    len2 += ccnl_ccnb_mkHeader(contentobj+len2, CCN_DTAG_CONTENTOBJ, CCN_TT_DTAG);   // contentobj\n\n    memset(h, '\\0', sizeof(h));\n    sprintf((char*)h, \"%d\", *suite);\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCNL_DTAG_SUITE, CCN_TT_DTAG,  // suite\n                             (char*) h, strlen((char*)h));\n\n    if(!prefix->chunknum){\n      prefix->chunknum = ccnl_malloc(sizeof(int));\n      *prefix->chunknum = 0;\n      chunkflag = 0;\n    }else{\n      chunkflag = 1;\n    }\n\n    memset(h, '\\0', sizeof(h));\n    sprintf((char*)h, \"%d\", *prefix->chunknum);\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCNL_DTAG_CHUNKNUM, CCN_TT_DTAG,  // chunknum\n                            (char*) h, strlen((char*)h));\n\n    memset(h, '\\0', sizeof(h));\n    sprintf((char*)h, \"%d\", chunkflag);\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCNL_DTAG_CHUNKFLAG, CCN_TT_DTAG,  // chunkflag\n                            (char*) h, strlen((char*)h));\n\n\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCN_DTAG_NAME, CCN_TT_DTAG,  // content\n                             (char*) stmt, len3);\n    contentobj[len2++] = 0; // end-of-contentobj\n\n\n    len1 += ccnl_ccnb_mkBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG,  // comp\n                             (char*) contentobj, len2);\n\n#ifdef USE_SIGNATURES\n    if(private_key_path) len += add_signature(out+len, private_key_path, out1, len1);\n#endif /*USE_SIGNATURES*/\n    memcpy(out+len, out1, len1);\n    len += len1;\n    out[len++] = 0; //name end\n    out[len++] = 0; //interest end\n    // printf(\"Contentlen %d\\n\", len1);\n    ccnl_free(data);\n    ccnl_free(contentobj);\n    ccnl_free(stmt);\n    ccnl_free(prefix);\n    return len;\n}",
  "abstract_func_before": "int\nmkAddToRelayCacheRequest(unsigned char *VAR_0, char *VAR_1,\n                         char *VAR_2, int *VAR_3)\n{\n    long VAR_4 = 0, VAR_5 = 0, VAR_6 = 0, VAR_7 = 0;\n    unsigned char *VAR_8, *VAR_9, *VAR_10, VAR_11[10], *VAR_12;\n    int VAR_13, VAR_14;\n    struct ccnl_prefix_s *VAR_15;\n    char *VAR_16 = NULL;\n    (void)VAR_2;\n\n    FILE *VAR_17 = fopen(VAR_1, \"r\");\n    if (!VAR_17)\n        return 0;\n    /* COMMENT_0 */\n    fseek(VAR_17, 0L, VAR_18);\n    VAR_13 = ftell(VAR_17);\n    fseek(VAR_17, 0L, VAR_19);\n    VAR_12 = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*VAR_13);\n    fread(VAR_12, VAR_13, 1, VAR_17);\n    fclose(VAR_17);\n\n    VAR_15 = getPrefix(VAR_12, VAR_13, VAR_3);\n    if (!VAR_15) {\n        DEBUGMSG(VAR_20, \"  no prefix in file %s\\n\", VAR_1);\n        return -1;\n    }\n    DEBUGMSG(VAR_21, \"  prefix in file: <%s>\\n\", ccnl_prefix_to_path(VAR_15));\n    VAR_16 = ccnl_prefix_to_path_detailed(VAR_15, 0, 1, 1);\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_10 = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 5000);\n    VAR_8 = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 4000);\n    VAR_9 = (unsigned char *) ccnl_malloc(sizeof(unsigned char)* 1000);\n\n    VAR_4 = ccnl_ccnb_mkHeader(VAR_0, VAR_22, VAR_23);   /* COMMENT_3 */\n    VAR_4 += ccnl_ccnb_mkHeader(VAR_0+VAR_4, VAR_24, VAR_23);  /* COMMENT_4 */\n\n    VAR_5 += ccnl_ccnb_mkStrBlob(VAR_10+VAR_5, VAR_25, VAR_23, \"ccnx\");\n    VAR_5 += ccnl_ccnb_mkStrBlob(VAR_10+VAR_5, VAR_25, VAR_23, \"\");\n    VAR_5 += ccnl_ccnb_mkStrBlob(VAR_10+VAR_5, VAR_25, VAR_23, \"addcacheobject\");\n\n    DEBUGMSG(VAR_21, \"NAME:%s\\n\", VAR_16);\n\n    VAR_7 += ccnl_ccnb_mkStrBlob(VAR_9+VAR_7, VAR_25, VAR_23, VAR_16);\n\n\n    VAR_6 += ccnl_ccnb_mkHeader(VAR_8+VAR_6, VAR_26, VAR_23);   /* COMMENT_5 */\n\n    memset(VAR_11, '\\0', sizeof(VAR_11));\n    sprintf((char*)VAR_11, \"%d\", *VAR_3);\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_27, VAR_23,  /* COMMENT_6 */\n                             (char*) VAR_11, strlen((char*)VAR_11));\n\n    if(!VAR_15->chunknum){\n      VAR_15->chunknum = ccnl_malloc(sizeof(int));\n      *VAR_15->chunknum = 0;\n      VAR_14 = 0;\n    }else{\n      VAR_14 = 1;\n    }\n\n    memset(VAR_11, '\\0', sizeof(VAR_11));\n    sprintf((char*)VAR_11, \"%d\", *VAR_15->chunknum);\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_28, VAR_23,  /* COMMENT_7 */\n                            (char*) VAR_11, strlen((char*)VAR_11));\n\n    memset(VAR_11, '\\0', sizeof(VAR_11));\n    sprintf((char*)VAR_11, \"%d\", VAR_14);\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_29, VAR_23,  /* COMMENT_8 */\n                            (char*) VAR_11, strlen((char*)VAR_11));\n\n\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_24, VAR_23,  /* COMMENT_9 */\n                             (char*) VAR_9, VAR_7);\n    VAR_8[VAR_6++] = 0; /* COMMENT_10 */\n\n\n    VAR_5 += ccnl_ccnb_mkBlob(VAR_10+VAR_5, VAR_25, VAR_23,  /* COMMENT_11 */\n                             (char*) VAR_8, VAR_6);\n\n#ifdef VAR_30\n    if(VAR_2) VAR_4 += add_signature(VAR_0+VAR_4, VAR_2, VAR_10, VAR_5);\n#endif /* COMMENT_12 */\n    memcpy(VAR_0+VAR_4, VAR_10, VAR_5);\n    VAR_4 += VAR_5;\n    VAR_0[VAR_4++] = 0; /* COMMENT_13 */\n    VAR_0[VAR_4++] = 0; /* COMMENT_14 */\n    /* COMMENT_15 */\n    ccnl_free(VAR_12);\n    ccnl_free(VAR_8);\n    ccnl_free(VAR_9);\n    ccnl_free(VAR_15);\n    return VAR_4;\n}",
  "func_graph_path_before": "cn-uofbasel/ccn-lite/cd1bd188eaf58b1972cf80ce3a5d3f1c81f14bf1/ccn-lite-ctrl.c/vul/before/0.json",
  "func": "int\nmkAddToRelayCacheRequest(unsigned char *out, char *fname,\n                         char *private_key_path, int *suite)\n{\n    long len = 0, len1 = 0, len2 = 0, len3 = 0;\n    unsigned char *contentobj, *stmt, *out1, h[10], *data;\n    int datalen, chunkflag;\n    struct ccnl_prefix_s *prefix;\n    char *prefix_string = NULL;\n    (void)private_key_path;\n\n    FILE *file = fopen(fname, \"r\");\n    if (!file)\n        return 0;\n    //determine size of the file\n    fseek(file, 0L, SEEK_END);\n    datalen = ftell(file);\n    fseek(file, 0L, SEEK_SET);\n    data = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*datalen+1);\n    memset(data, 0, sizeof(unsigned char)*datalen+1);\n    fread(data, datalen, 1, file);\n    fclose(file);\n\n    prefix = getPrefix(data, datalen, suite);\n    if (!prefix) {\n        DEBUGMSG(ERROR, \"  no prefix in file %s\\n\", fname);\n        return -1;\n    }\n    DEBUGMSG(DEBUG, \"  prefix in file: <%s>\\n\", ccnl_prefix_to_path(prefix));\n    prefix_string = ccnl_prefix_to_path_detailed(prefix, 0, 1, 1);\n\n    //Create ccn-lite-ctrl interest object with signature to add content...\n    //out = (unsigned char *) malloc(sizeof(unsigned char)*fsize + 5000);\n    out1 = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 5000);\n    contentobj = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 4000);\n    stmt = (unsigned char *) ccnl_malloc(sizeof(unsigned char)* 1000);\n\n    len = ccnl_ccnb_mkHeader(out, CCN_DTAG_INTEREST, CCN_TT_DTAG);   // interest\n    len += ccnl_ccnb_mkHeader(out+len, CCN_DTAG_NAME, CCN_TT_DTAG);  // name\n\n    len1 += ccnl_ccnb_mkStrBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG, \"ccnx\");\n    len1 += ccnl_ccnb_mkStrBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG, \"\");\n    len1 += ccnl_ccnb_mkStrBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG, \"addcacheobject\");\n\n    DEBUGMSG(DEBUG, \"NAME:%s\\n\", prefix_string);\n\n    len3 += ccnl_ccnb_mkStrBlob(stmt+len3, CCN_DTAG_COMPONENT, CCN_TT_DTAG, prefix_string);\n\n\n    len2 += ccnl_ccnb_mkHeader(contentobj+len2, CCN_DTAG_CONTENTOBJ, CCN_TT_DTAG);   // contentobj\n\n    memset(h, '\\0', sizeof(h));\n    sprintf((char*)h, \"%d\", *suite);\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCNL_DTAG_SUITE, CCN_TT_DTAG,  // suite\n                             (char*) h, strlen((char*)h));\n\n    if(!prefix->chunknum){\n      prefix->chunknum = ccnl_malloc(sizeof(int));\n      *prefix->chunknum = 0;\n      chunkflag = 0;\n    }else{\n      chunkflag = 1;\n    }\n\n    memset(h, '\\0', sizeof(h));\n    sprintf((char*)h, \"%d\", *prefix->chunknum);\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCNL_DTAG_CHUNKNUM, CCN_TT_DTAG,  // chunknum\n                            (char*) h, strlen((char*)h));\n\n    memset(h, '\\0', sizeof(h));\n    sprintf((char*)h, \"%d\", chunkflag);\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCNL_DTAG_CHUNKFLAG, CCN_TT_DTAG,  // chunkflag\n                            (char*) h, strlen((char*)h));\n\n\n    len2 += ccnl_ccnb_mkBlob(contentobj+len2, CCN_DTAG_NAME, CCN_TT_DTAG,  // content\n                             (char*) stmt, len3);\n    contentobj[len2++] = 0; // end-of-contentobj\n\n\n    len1 += ccnl_ccnb_mkBlob(out1+len1, CCN_DTAG_COMPONENT, CCN_TT_DTAG,  // comp\n                             (char*) contentobj, len2);\n\n#ifdef USE_SIGNATURES\n    if(private_key_path) len += add_signature(out+len, private_key_path, out1, len1);\n#endif /*USE_SIGNATURES*/\n    memcpy(out+len, out1, len1);\n    len += len1;\n    out[len++] = 0; //name end\n    out[len++] = 0; //interest end\n    // printf(\"Contentlen %d\\n\", len1);\n    ccnl_free(data);\n    ccnl_free(contentobj);\n    ccnl_free(stmt);\n    ccnl_free(prefix);\n    return len;\n}",
  "abstract_func": "int\nmkAddToRelayCacheRequest(unsigned char *VAR_0, char *VAR_1,\n                         char *VAR_2, int *VAR_3)\n{\n    long VAR_4 = 0, VAR_5 = 0, VAR_6 = 0, VAR_7 = 0;\n    unsigned char *VAR_8, *VAR_9, *VAR_10, VAR_11[10], *VAR_12;\n    int VAR_13, VAR_14;\n    struct ccnl_prefix_s *VAR_15;\n    char *VAR_16 = NULL;\n    (void)VAR_2;\n\n    FILE *VAR_17 = fopen(VAR_1, \"r\");\n    if (!VAR_17)\n        return 0;\n    /* COMMENT_0 */\n    fseek(VAR_17, 0L, VAR_18);\n    VAR_13 = ftell(VAR_17);\n    fseek(VAR_17, 0L, VAR_19);\n    VAR_12 = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*VAR_13+1);\n    memset(VAR_12, 0, sizeof(unsigned char)*VAR_13+1);\n    fread(VAR_12, VAR_13, 1, VAR_17);\n    fclose(VAR_17);\n\n    VAR_15 = getPrefix(VAR_12, VAR_13, VAR_3);\n    if (!VAR_15) {\n        DEBUGMSG(VAR_20, \"  no prefix in file %s\\n\", VAR_1);\n        return -1;\n    }\n    DEBUGMSG(VAR_21, \"  prefix in file: <%s>\\n\", ccnl_prefix_to_path(VAR_15));\n    VAR_16 = ccnl_prefix_to_path_detailed(VAR_15, 0, 1, 1);\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_10 = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 5000);\n    VAR_8 = (unsigned char *) ccnl_malloc(sizeof(unsigned char) * 4000);\n    VAR_9 = (unsigned char *) ccnl_malloc(sizeof(unsigned char)* 1000);\n\n    VAR_4 = ccnl_ccnb_mkHeader(VAR_0, VAR_22, VAR_23);   /* COMMENT_3 */\n    VAR_4 += ccnl_ccnb_mkHeader(VAR_0+VAR_4, VAR_24, VAR_23);  /* COMMENT_4 */\n\n    VAR_5 += ccnl_ccnb_mkStrBlob(VAR_10+VAR_5, VAR_25, VAR_23, \"ccnx\");\n    VAR_5 += ccnl_ccnb_mkStrBlob(VAR_10+VAR_5, VAR_25, VAR_23, \"\");\n    VAR_5 += ccnl_ccnb_mkStrBlob(VAR_10+VAR_5, VAR_25, VAR_23, \"addcacheobject\");\n\n    DEBUGMSG(VAR_21, \"NAME:%s\\n\", VAR_16);\n\n    VAR_7 += ccnl_ccnb_mkStrBlob(VAR_9+VAR_7, VAR_25, VAR_23, VAR_16);\n\n\n    VAR_6 += ccnl_ccnb_mkHeader(VAR_8+VAR_6, VAR_26, VAR_23);   /* COMMENT_5 */\n\n    memset(VAR_11, '\\0', sizeof(VAR_11));\n    sprintf((char*)VAR_11, \"%d\", *VAR_3);\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_27, VAR_23,  /* COMMENT_6 */\n                             (char*) VAR_11, strlen((char*)VAR_11));\n\n    if(!VAR_15->chunknum){\n      VAR_15->chunknum = ccnl_malloc(sizeof(int));\n      *VAR_15->chunknum = 0;\n      VAR_14 = 0;\n    }else{\n      VAR_14 = 1;\n    }\n\n    memset(VAR_11, '\\0', sizeof(VAR_11));\n    sprintf((char*)VAR_11, \"%d\", *VAR_15->chunknum);\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_28, VAR_23,  /* COMMENT_7 */\n                            (char*) VAR_11, strlen((char*)VAR_11));\n\n    memset(VAR_11, '\\0', sizeof(VAR_11));\n    sprintf((char*)VAR_11, \"%d\", VAR_14);\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_29, VAR_23,  /* COMMENT_8 */\n                            (char*) VAR_11, strlen((char*)VAR_11));\n\n\n    VAR_6 += ccnl_ccnb_mkBlob(VAR_8+VAR_6, VAR_24, VAR_23,  /* COMMENT_9 */\n                             (char*) VAR_9, VAR_7);\n    VAR_8[VAR_6++] = 0; /* COMMENT_10 */\n\n\n    VAR_5 += ccnl_ccnb_mkBlob(VAR_10+VAR_5, VAR_25, VAR_23,  /* COMMENT_11 */\n                             (char*) VAR_8, VAR_6);\n\n#ifdef VAR_30\n    if(VAR_2) VAR_4 += add_signature(VAR_0+VAR_4, VAR_2, VAR_10, VAR_5);\n#endif /* COMMENT_12 */\n    memcpy(VAR_0+VAR_4, VAR_10, VAR_5);\n    VAR_4 += VAR_5;\n    VAR_0[VAR_4++] = 0; /* COMMENT_13 */\n    VAR_0[VAR_4++] = 0; /* COMMENT_14 */\n    /* COMMENT_15 */\n    ccnl_free(VAR_12);\n    ccnl_free(VAR_8);\n    ccnl_free(VAR_9);\n    ccnl_free(VAR_15);\n    return VAR_4;\n}",
  "func_graph_path": "cn-uofbasel/ccn-lite/cd1bd188eaf58b1972cf80ce3a5d3f1c81f14bf1/ccn-lite-ctrl.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,8 @@\n     fseek(file, 0L, SEEK_END);\n     datalen = ftell(file);\n     fseek(file, 0L, SEEK_SET);\n-    data = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*datalen);\n+    data = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*datalen+1);\n+    memset(data, 0, sizeof(unsigned char)*datalen+1);\n     fread(data, datalen, 1, file);\n     fclose(file);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    data = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*datalen);"
    ],
    "added_lines": [
      "    data = (unsigned char *) ccnl_malloc(sizeof(unsigned char)*datalen+1);",
      "    memset(data, 0, sizeof(unsigned char)*datalen+1);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/cn-uofbasel/ccn-lite/pull/280",
  "description": {
    "pr_info": {
      "title": "Fix possible heap bufferoverrun when reading ndn- or ccnx-files",
      "number": 280
    },
    "comment": [
      "This Patch prevents a heap bufferoverrun when reading ndn- or ccnx-files and thus it fixes Issue #279 "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}