{
  "cve_id": "CVE-2019-16754",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "asymcute: don't make the assumption that req->arg is non-NULL\n\nThis fixes a denial of service where an attacker would be able to cause\na NULL pointer dereference by sending a spoofed packet. This attack only\nrequires knowledge about pending message ids.",
  "commit_hash": "30e4823e946949befe74ef94bc48fe43958c28a6",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/30e4823e946949befe74ef94bc48fe43958c28a6",
  "file_path": "sys/net/application_layer/asymcute/asymcute.c",
  "func_name": "_on_unsuback",
  "func_before": "static void _on_unsuback(asymcute_con_t *con, const uint8_t *data, size_t len)\n{\n    mutex_lock(&con->lock);\n    asymcute_req_t *req = _req_preprocess(con, len, MINLEN_UNSUBACK,\n                                          data, IDPOS_UNSUBACK);\n    if (req == NULL) {\n        mutex_unlock(&con->lock);\n        return;\n    }\n\n    /* remove subscription from list */\n    asymcute_sub_t *sub = (asymcute_sub_t *)req->arg;\n    if (con->subscriptions == sub) {\n        con->subscriptions = sub->next;\n    }\n    else {\n        for (asymcute_sub_t *e = con->subscriptions; e && e->next; e = e->next) {\n            if (e->next == sub) {\n                e->next = e->next->next;\n                break;\n            }\n        }\n    }\n\n    /* reset subscription context */\n    sub->topic = NULL;\n\n    /* notify user */\n    mutex_unlock(&req->lock);\n    mutex_unlock(&con->lock);\n    con->user_cb(req, ASYMCUTE_UNSUBSCRIBED);\n}",
  "abstract_func_before": "static void _on_unsuback(asymcute_con_t *VAR_0, const uint8_t *VAR_1, size_t VAR_2)\n{\n    mutex_lock(&VAR_0->lock);\n    asymcute_req_t *VAR_3 = _req_preprocess(VAR_0, VAR_2, VAR_4,\n                                          VAR_1, VAR_5);\n    if (VAR_3 == NULL) {\n        mutex_unlock(&VAR_0->lock);\n        return;\n    }\n\n    /* COMMENT_0 */\n    asymcute_sub_t *VAR_6 = (asymcute_sub_t *)VAR_3->arg;\n    if (VAR_0->subscriptions == VAR_6) {\n        VAR_0->subscriptions = VAR_6->next;\n    }\n    else {\n        for (asymcute_sub_t *VAR_7 = VAR_0->subscriptions; VAR_7 && VAR_7->next; VAR_7 = VAR_7->next) {\n            if (VAR_7->next == VAR_6) {\n                VAR_7->next = VAR_7->next->next;\n                break;\n            }\n        }\n    }\n\n    /* COMMENT_1 */\n    VAR_6->topic = NULL;\n\n    /* COMMENT_2 */\n    mutex_unlock(&VAR_3->lock);\n    mutex_unlock(&VAR_0->lock);\n    VAR_0->user_cb(VAR_3, VAR_8);\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/30e4823e946949befe74ef94bc48fe43958c28a6/asymcute.c/vul/before/0.json",
  "func": "static void _on_unsuback(asymcute_con_t *con, const uint8_t *data, size_t len)\n{\n    mutex_lock(&con->lock);\n    asymcute_req_t *req = _req_preprocess(con, len, MINLEN_UNSUBACK,\n                                          data, IDPOS_UNSUBACK);\n    if (req == NULL) {\n        mutex_unlock(&con->lock);\n        return;\n    }\n\n    /* remove subscription from list */\n    asymcute_sub_t *sub = (asymcute_sub_t *)req->arg;\n    if (sub == NULL) {\n        return;\n    } else if (con->subscriptions == sub) {\n        con->subscriptions = sub->next;\n    }\n    else {\n        for (asymcute_sub_t *e = con->subscriptions; e && e->next; e = e->next) {\n            if (e->next == sub) {\n                e->next = e->next->next;\n                break;\n            }\n        }\n    }\n\n    /* reset subscription context */\n    sub->topic = NULL;\n\n    /* notify user */\n    mutex_unlock(&req->lock);\n    mutex_unlock(&con->lock);\n    con->user_cb(req, ASYMCUTE_UNSUBSCRIBED);\n}",
  "abstract_func": "static void _on_unsuback(asymcute_con_t *VAR_0, const uint8_t *VAR_1, size_t VAR_2)\n{\n    mutex_lock(&VAR_0->lock);\n    asymcute_req_t *VAR_3 = _req_preprocess(VAR_0, VAR_2, VAR_4,\n                                          VAR_1, VAR_5);\n    if (VAR_3 == NULL) {\n        mutex_unlock(&VAR_0->lock);\n        return;\n    }\n\n    /* COMMENT_0 */\n    asymcute_sub_t *VAR_6 = (asymcute_sub_t *)VAR_3->arg;\n    if (VAR_6 == NULL) {\n        return;\n    } else if (VAR_0->subscriptions == VAR_6) {\n        VAR_0->subscriptions = VAR_6->next;\n    }\n    else {\n        for (asymcute_sub_t *VAR_7 = VAR_0->subscriptions; VAR_7 && VAR_7->next; VAR_7 = VAR_7->next) {\n            if (VAR_7->next == VAR_6) {\n                VAR_7->next = VAR_7->next->next;\n                break;\n            }\n        }\n    }\n\n    /* COMMENT_1 */\n    VAR_6->topic = NULL;\n\n    /* COMMENT_2 */\n    mutex_unlock(&VAR_3->lock);\n    mutex_unlock(&VAR_0->lock);\n    VAR_0->user_cb(VAR_3, VAR_8);\n}",
  "func_graph_path": "RIOT-OS/RIOT/30e4823e946949befe74ef94bc48fe43958c28a6/asymcute.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,9 @@\n \n     /* remove subscription from list */\n     asymcute_sub_t *sub = (asymcute_sub_t *)req->arg;\n-    if (con->subscriptions == sub) {\n+    if (sub == NULL) {\n+        return;\n+    } else if (con->subscriptions == sub) {\n         con->subscriptions = sub->next;\n     }\n     else {",
  "diff_line_info": {
    "deleted_lines": [
      "    if (con->subscriptions == sub) {"
    ],
    "added_lines": [
      "    if (sub == NULL) {",
      "        return;",
      "    } else if (con->subscriptions == sub) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/12293",
  "description": {
    "pr_info": {
      "title": "asymcute: Fix null pointer dereference",
      "number": 12293
    },
    "comment": [
      "### Contribution description\r\n\r\nThis PR fixes various null pointer dereferences in `asymcute`. All of\r\nthese are due to the assumption that `req->arg` is always non-NULL.\r\nSince an attacker can spoof mqtt replies this is not neccessarly the\r\ncase.\r\n\r\nThis assumption is made at various places in the code. I only tested\r\nthis with `MQTTSN_SUBACK` messages (`_on_suback` function) but the same\r\nissue should apply to any function accessing `req->arg` without checking\r\nfor `NULL`.\r\n\r\n### Testing procedure\r\n\r\nMy tap setup is as follows:\r\n\r\n```\r\n4: tap0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\r\n    link/ether 72:f3:e4:fd:13:9c brd ff:ff:ff:ff:ff:ff\r\n    inet6 fe80::70f3:e4ff:fefd:139c/64 scope link\r\n       valid_lft forever preferred_lft forever\r\n```\r\n\r\nOn `native`:\r\n\r\n```\r\n$ make -C `examples/asymcute_mqttsn` all-valgrind\r\n$ make -C `examples/asymcute_mqttsn` term-valgrind\r\nmain(): This is RIOT! (Version: UNKNOWN (builddir: /root/RIOT))\r\nAsymcute MQTT-SN example application\r\n\r\nType 'help' to get started and have a look at the README.md for more information.\r\n> connect myclient [fe80::70f3:e4ff:fefd:139c]:2342\r\n```\r\n\r\nBefore the connect request timesout spoof a reply using:\r\n\r\n```\r\nprintf CBMAAAIAAAA= | base64 -d | \\\r\n\tbusybox nc -p 2342 -u 'fe80::70f3:e4ff:fefd:139d%tap0' 49152\r\n```\r\n\r\n`49152` should be the default ephemeral port. The packet must have the\r\nserver address as source address and the server port as source port.\r\n\r\n**Expected result:** The packet should be rejected.\r\n**Actual result:** Segmentation fault + invalid read of size 4.\r\n\r\n### Impact\r\n\r\nThe null pointer dereference should result in a crash on most\r\nplatforms. Thereby allowing a denial of service. The attacker must be\r\nable to spoof a MQTT response which is easy as the ephemeral port is not\r\npicked at random. Additionally, the attacker needs to know a pending\r\nMQTT MsgId, however, those aren't picked at random either and there are\r\nonly `2^8` possible values."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step1: Input Analysis**  \nThe commit message indicates a fix for a denial of service (DoS) vulnerability by preventing a NULL pointer dereference. The vulnerability description confirms that `req->arg` can be NULL if an attacker spoofs MQTT replies. The code diff adds a NULL check before accessing `req->arg`.\n\n**Step2: Consistency Check**  \nThe commit message accurately reflects the code change, which introduces a NULL check to prevent dereference.\n\n**Step3: Purpose Evaluation**  \nThe changes are aimed at fixing a bug that allows an attacker to cause a crash, which is a security issue.\n\n**Step4: Security Vulnerability Assessment**  \nThe patch addresses a NULL pointer dereference that leads to a denial of service, a clear security vulnerability.\n\n**Step5: Non-Security Classification**  \nNot applicable as it is a security fix.\n\n**Step6: Confidence Scoring**  \nConfidence is high as all information consistently points to a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}