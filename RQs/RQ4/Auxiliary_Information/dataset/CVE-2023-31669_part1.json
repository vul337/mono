{
  "cve_id": "CVE-2023-31669",
  "cwe_ids": [
    "CWE-116"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "WebAssembly/wabt",
  "commit_msg": "Improve lexing and parsing of invalid annotations (again)\n\nThis adds a bounds-check to WastLexer::GetText to handle the case when\nthe offset is earlier than token_start (e.g. because GetStringToken\nfound a newline in the string and reset token_start to point at it).\n\nAlso revises GetIdToken -> GetIdChars to stop skipping the initial char\nin an annotation delimiter, which is an idchar+ but not an id token.\n\nAlso fixes the WastParser to handle EOF when reading for the end of an\nannotation, both for code metadata annotations and other kinds.\nPreviously this produced an infinite loop (but only with\n--enable-annotations).\n\nFixes #2165",
  "commit_hash": "44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "file_path": "src/wast-parser.cc",
  "func_name": "WastParser::ParseCodeMetadataAnnotation",
  "func_before": "Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) {\n  WABT_TRACE(ParseCodeMetadataAnnotation);\n  Token tk = Consume();\n  std::string_view name = tk.text();\n  name.remove_prefix(sizeof(\"metadata.code.\") - 1);\n  std::string data_text;\n  CHECK_RESULT(ParseQuotedText(&data_text, false));\n  std::vector<uint8_t> data(data_text.begin(), data_text.end());\n  exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));\n  TokenType rpar = Peek();\n  WABT_USE(rpar);\n  assert(rpar == TokenType::Rpar);\n  Consume();\n  return Result::Ok;\n}",
  "abstract_func_before": "Result WastParser::ParseCodeMetadataAnnotation(ExprList* VAR_0) {\n  WABT_TRACE(VAR_1);\n  Token VAR_2 = Consume();\n  std::string_view VAR_3 = VAR_2.text();\n  VAR_3.remove_prefix(sizeof(\"metadata.code.\") - 1);\n  std::string VAR_4;\n  CHECK_RESULT(ParseQuotedText(&VAR_4, false));\n  std::vector<uint8_t> VAR_5(VAR_4.begin(), VAR_4.end());\n  VAR_0->push_back(std::VAR_6<CodeMetadataExpr>(VAR_3, std::move(VAR_5)));\n  TokenType VAR_7 = Peek();\n  WABT_USE(VAR_7);\n  assert(VAR_7 == TokenType::Rpar);\n  Consume();\n  return Result::Ok;\n}",
  "func_graph_path_before": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/before/0.json",
  "func": "Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) {\n  WABT_TRACE(ParseCodeMetadataAnnotation);\n  Token tk = Consume();\n  std::string_view name = tk.text();\n  name.remove_prefix(sizeof(\"metadata.code.\") - 1);\n  std::string data_text;\n  CHECK_RESULT(ParseQuotedText(&data_text, false));\n  std::vector<uint8_t> data(data_text.begin(), data_text.end());\n  exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));\n  EXPECT(Rpar);\n  return Result::Ok;\n}",
  "abstract_func": "Result WastParser::ParseCodeMetadataAnnotation(ExprList* VAR_0) {\n  WABT_TRACE(VAR_1);\n  Token VAR_2 = Consume();\n  std::string_view VAR_3 = VAR_2.text();\n  VAR_3.remove_prefix(sizeof(\"metadata.code.\") - 1);\n  std::string VAR_4;\n  CHECK_RESULT(ParseQuotedText(&VAR_4, false));\n  std::vector<uint8_t> VAR_5(VAR_4.begin(), VAR_4.end());\n  VAR_0->push_back(std::VAR_6<CodeMetadataExpr>(VAR_3, std::move(VAR_5)));\n  EXPECT(VAR_7);\n  return Result::Ok;\n}",
  "func_graph_path": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,6 @@\n   CHECK_RESULT(ParseQuotedText(&data_text, false));\n   std::vector<uint8_t> data(data_text.begin(), data_text.end());\n   exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));\n-  TokenType rpar = Peek();\n-  WABT_USE(rpar);\n-  assert(rpar == TokenType::Rpar);\n-  Consume();\n+  EXPECT(Rpar);\n   return Result::Ok;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  TokenType rpar = Peek();",
      "  WABT_USE(rpar);",
      "  assert(rpar == TokenType::Rpar);",
      "  Consume();"
    ],
    "added_lines": [
      "  EXPECT(Rpar);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/wabt/pull/2166",
  "description": {
    "pr_info": {
      "title": "Improve lexing and parsing of invalid annotations (again)",
      "number": 2166
    },
    "comment": [
      "This adds a bounds-check to WastLexer::GetText to handle the case when the offset is earlier than token_start (e.g. because GetStringToken found a newline in the string and reset token_start to point to it).\r\n\r\nAlso revises GetIdToken -> GetIdChars to stop skipping the initial char in an annotation delimiter, which is an idchar+ but not an id token.\r\n\r\nAlso fixes the WastParser to handle EOF when reading for the end of an annotation, both for code metadata annotation and other kinds. Previously this produced an infinite loop (but only when --enable-annotations was provided).\r\n\r\nFixes #2165 and adds some more regression tests.\r\n\r\nThis is sort of deja vu after #2150, sigh."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.97,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.97"
}