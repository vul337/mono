{
  "cve_id": "CVE-2022-1714",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix 4 byte oobread in msp430 disassembler ##crash\n\n* Only crashes with asan builds\n* Add missing =SN register\n* Reported by cnitlrt via huntrdev\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0",
  "commit_hash": "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "git_url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "file_path": "libr/bin/format/elf/elf.c",
  "func_name": "store_versioninfo_gnu_verdef",
  "func_before": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tut32 cnt;\n\tsize_t i;\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tElf_(Shdr) *link_shdr = &bin->shdr[shdr->sh_link];\n#ifdef R_BIN_ELF64\n\tif ((int)shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn false;\n\t}\n\tif (shdr->sh_size < sizeof (Elf_(Verdef)) || shdr->sh_size < sizeof (Elf_(Verdaux))) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, 1);\n\tif (!defs) {\n\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\");\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\tfree (defs);\n\t\treturn false;\n\t}\n\tsize_t shsize = shdr->sh_size;\n\tif (shdr->sh_size > bin->size) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Truncating shsize from %d to %d\\n\", (int)shdr->sh_size, (int)bin->size);\n\t\t}\n\t\tif (bin->size > shdr->sh_offset) {\n\t\t\tshsize = bin->size - shdr->sh_offset;\n\t\t} else {\n\t\t\tshsize = bin->size;\n\t\t}\n\t}\n\tend = (char *)defs + shsize; //& shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; cnt < shdr->sh_info && i < shdr->sh_size; cnt++) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tif (vstart + sizeof (*verdef) > end) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j);\n\t\tverdef->vd_flags = READ16 (dfs, j);\n\t\tverdef->vd_ndx = READ16 (dfs, j);\n\t\tverdef->vd_cnt = READ16 (dfs, j);\n\t\tverdef->vd_hash = READ32 (dfs, j);\n\t\tverdef->vd_aux = READ32 (dfs, j);\n\t\tverdef->vd_next = READ32 (dfs, j);\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j);\n\t\taux.vda_next = READ32 (vstart, j);\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; j++) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tif (shdr->sh_size - vstart_off < aux.vda_next) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k);\n\t\t\taux.vda_next = READ32 (vstart, k);\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%u\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next || shdr->sh_size - i < verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\tR_LOG_DEBUG (\"Invalid vd_next in the ELF version\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
  "abstract_func_before": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *VAR_0, VAR_1(Shdr) *VAR_2, int VAR_3) {\n\tconst char *VAR_4 = \"\";\n\tconst char *VAR_5 = \"\";\n\tchar *VAR_6 = NULL;\n\tut8 VAR_7[sizeof (VAR_1(VAR_8))] = {0};\n\tut32 VAR_9;\n\tsize_t VAR_10;\n\tif (VAR_2->sh_link >= VAR_0->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tVAR_1(Shdr) *VAR_11 = &VAR_0->shdr[VAR_2->sh_link];\n#ifdef VAR_12\n\tif ((int)VAR_2->sh_size < 1 || VAR_2->sh_size > VAR_13) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn false;\n\t}\n\tif (VAR_2->sh_size < sizeof (VAR_1(VAR_8)) || VAR_2->sh_size < sizeof (VAR_1(VAR_14))) {\n\t\treturn false;\n\t}\n\tVAR_1(VAR_8) *VAR_15 = calloc (VAR_2->sh_size, 1);\n\tif (!VAR_15) {\n\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\");\n\t\treturn false;\n\t}\n\tif (VAR_0->shstrtab && VAR_2->sh_name < VAR_0->shstrtab_size) {\n\t\tVAR_4 = &VAR_0->shstrtab[VAR_2->sh_name];\n\t}\n\tif (VAR_11 && VAR_0->shstrtab && VAR_11->sh_name < VAR_0->shstrtab_size) {\n\t\tVAR_5 = &VAR_0->shstrtab[VAR_11->sh_name];\n\t}\n\tSdb *VAR_16 = sdb_new0 ();\n\tif (!VAR_16) {\n\t\tfree (VAR_15);\n\t\treturn false;\n\t}\n\tsize_t VAR_17 = VAR_2->sh_size;\n\tif (VAR_2->sh_size > VAR_0->size) {\n\t\tif (VAR_0->verbose) {\n\t\t\teprintf (\"Truncating shsize from %d to %d\\n\", (int)VAR_2->sh_size, (int)VAR_0->size);\n\t\t}\n\t\tif (VAR_0->size > VAR_2->sh_offset) {\n\t\t\tVAR_17 = VAR_0->size - VAR_2->sh_offset;\n\t\t} else {\n\t\t\tVAR_17 = VAR_0->size;\n\t\t}\n\t}\n\tVAR_6 = (char *)VAR_15 + VAR_17; /* COMMENT_0 */\n\tsdb_set (VAR_16, \"section_name\", VAR_4, 0);\n\tsdb_num_set (VAR_16, \"entries\", VAR_2->sh_info, 0);\n\tsdb_num_set (VAR_16, \"addr\", VAR_2->sh_addr, 0);\n\tsdb_num_set (VAR_16, \"offset\", VAR_2->sh_offset, 0);\n\tsdb_num_set (VAR_16, \"link\", VAR_2->sh_link, 0);\n\tsdb_set (VAR_16, \"link_section_name\", VAR_5, 0);\n\n\tfor (VAR_9 = 0, VAR_10 = 0; VAR_9 < VAR_2->sh_info && VAR_10 < VAR_2->sh_size; VAR_9++) {\n\t\tSdb *VAR_18 = sdb_new0 ();\n\t\tchar *VAR_19 = ((char*)VAR_15) + VAR_10;\n\t\tsize_t VAR_20 = VAR_10;\n\t\tchar VAR_21[32] = {0};\n\t\tVAR_1(VAR_8) *VAR_22 = (VAR_1(Verdef)*)VAR_19;\n\t\tVAR_1(Verdaux) VAR_23 = {0};\n\t\tint VAR_24 = 0;\n\t\tint VAR_25 = 0;\n\n\t\tif (VAR_19 + sizeof (*VAR_22) > VAR_6) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (VAR_0->b, VAR_2->sh_offset + VAR_10, VAR_7, sizeof (VAR_1(Verdef)));\n\t\tVAR_22->vd_version = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_flags = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_ndx = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_cnt = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_hash = READ32 (VAR_7, VAR_24);\n\t\tVAR_22->vd_aux = READ32 (VAR_7, VAR_24);\n\t\tVAR_22->vd_next = READ32 (VAR_7, VAR_24);\n\t\tint VAR_26 = VAR_22->vd_aux;\n\t\tif (VAR_26 < 1 || VAR_2->sh_size - VAR_20 < VAR_26) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\t\tVAR_19 += VAR_26;\n\t\tVAR_20 += VAR_26;\n\t\tif (VAR_19 > VAR_6 || VAR_2->sh_size - sizeof (VAR_1(Verdaux)) < VAR_20) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tVAR_24 = 0;\n\t\tVAR_23.vda_name = READ32 (VAR_19, VAR_24);\n\t\tVAR_23.vda_next = READ32 (VAR_19, VAR_24);\n\n\t\tVAR_25 = VAR_10 + VAR_22->vd_aux;\n\t\tif (VAR_23.vda_name > VAR_0->dynstr_size) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (VAR_18, \"idx\", VAR_10, 0);\n\t\tsdb_num_set (VAR_18, \"vd_version\", VAR_22->vd_version, 0);\n\t\tsdb_num_set (VAR_18, \"vd_ndx\", VAR_22->vd_ndx, 0);\n\t\tsdb_num_set (VAR_18, \"vd_cnt\", VAR_22->vd_cnt, 0);\n\t\tsdb_set (VAR_18, \"vda_name\", &VAR_0->dynstr[VAR_23.vda_name], 0);\n\t\tsdb_set (VAR_18, \"flags\", get_ver_flags (VAR_22->vd_flags), 0);\n\n\t\tfor (VAR_24 = 1; VAR_24 < VAR_22->vd_cnt; VAR_24++) {\n\t\t\tint VAR_27;\n\t\t\tSdb *VAR_28 = sdb_new0 ();\n\t\t\tif (VAR_2->sh_size - VAR_20 < VAR_23.vda_next) {\n\t\t\t\tsdb_free (VAR_18);\n\t\t\t\tsdb_free (VAR_28);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tVAR_25 += VAR_23.vda_next;\n\t\t\tVAR_19 += VAR_23.vda_next;\n\t\t\tVAR_20 += VAR_23.vda_next;\n\t\t\tif (VAR_19 > VAR_6 || VAR_2->sh_size - sizeof (VAR_1(Verdaux)) < VAR_20) {\n\t\t\t\tsdb_free (VAR_18);\n\t\t\t\tsdb_free (VAR_28);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tVAR_27 = 0;\n\t\t\tVAR_23.vda_name = READ32 (VAR_19, VAR_27);\n\t\t\tVAR_23.vda_next = READ32 (VAR_19, VAR_27);\n\t\t\tif (VAR_23.vda_name > VAR_0->dynstr_size) {\n\t\t\t\tsdb_free (VAR_18);\n\t\t\t\tsdb_free (VAR_28);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (VAR_28, \"idx\", VAR_25, 0);\n\t\t\tsdb_num_set (VAR_28, \"parent\", VAR_24, 0);\n\t\t\tsdb_set (VAR_28, \"vda_name\", &VAR_0->dynstr[VAR_23.vda_name], 0);\n\t\t\tsnprintf (VAR_21, sizeof (VAR_21), \"parent%d\", VAR_24 - 1);\n\t\t\tsdb_ns_set (VAR_18, VAR_21, VAR_28);\n\t\t}\n\n\t\tsnprintf (VAR_21, sizeof (VAR_21), \"verdef%u\", VAR_9);\n\t\tsdb_ns_set (VAR_16, VAR_21, VAR_18);\n\t\tif (!VAR_22->vd_next || VAR_2->sh_size - VAR_10 < VAR_22->vd_next) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)VAR_22->vd_next < 1) {\n\t\t\tR_LOG_DEBUG (\"Invalid vd_next in the ELF version\");\n\t\t\tbreak;\n\t\t}\n\t\tVAR_10 += VAR_22->vd_next;\n\t}\n\tfree (VAR_15);\n\treturn VAR_16;\nout_error:\n\tfree (VAR_15);\n\tsdb_free (VAR_16);\n\treturn NULL;\n}",
  "func_graph_path_before": null,
  "func": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tut32 cnt;\n\tsize_t i;\n\tif (shdr->sh_link >= bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tElf_(Shdr) *link_shdr = &bin->shdr[shdr->sh_link];\n#ifdef R_BIN_ELF64\n\tif ((int)shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn false;\n\t}\n\tif (shdr->sh_size < sizeof (Elf_(Verdef)) || shdr->sh_size < sizeof (Elf_(Verdaux))) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, 1);\n\tif (!defs) {\n\t\tR_LOG_DEBUG (\"Cannot allocate memory (Check Elf_(Verdef))\");\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\tfree (defs);\n\t\treturn false;\n\t}\n\tsize_t shsize = shdr->sh_size;\n\tif (shdr->sh_size > bin->size) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Truncating shsize from %d to %d\\n\", (int)shdr->sh_size, (int)bin->size);\n\t\t}\n\t\tif (bin->size > shdr->sh_offset) {\n\t\t\tshsize = bin->size - shdr->sh_offset;\n\t\t} else {\n\t\t\tshsize = bin->size;\n\t\t}\n\t}\n\tend = (char *)defs + shsize; //& shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; cnt < shdr->sh_info && i < shdr->sh_size; cnt++) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tsize_t vstart_off = i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tif (vstart + sizeof (*verdef) > end) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j);\n\t\tverdef->vd_flags = READ16 (dfs, j);\n\t\tverdef->vd_ndx = READ16 (dfs, j);\n\t\tverdef->vd_cnt = READ16 (dfs, j);\n\t\tverdef->vd_hash = READ32 (dfs, j);\n\t\tverdef->vd_aux = READ32 (dfs, j);\n\t\tverdef->vd_next = READ32 (dfs, j);\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tvstart_off += vdaux;\n\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j);\n\t\taux.vda_next = READ32 (vstart, j);\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; j++) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tif (shdr->sh_size - vstart_off < aux.vda_next) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tvstart_off += aux.vda_next;\n\t\t\tif (vstart > end || shdr->sh_size - sizeof (Elf_(Verdaux)) < vstart_off) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k);\n\t\t\taux.vda_next = READ32 (vstart, k);\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%u\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next || shdr->sh_size - i < verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\tR_LOG_DEBUG (\"Invalid vd_next in the ELF version\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}\n\tfree (defs);\n\treturn sdb;\nout_error:\n\tfree (defs);\n\tsdb_free (sdb);\n\treturn NULL;\n}",
  "abstract_func": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *VAR_0, VAR_1(Shdr) *VAR_2, int VAR_3) {\n\tconst char *VAR_4 = \"\";\n\tconst char *VAR_5 = \"\";\n\tchar *VAR_6 = NULL;\n\tut8 VAR_7[sizeof (VAR_1(VAR_8))] = {0};\n\tut32 VAR_9;\n\tsize_t VAR_10;\n\tif (VAR_2->sh_link >= VAR_0->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tVAR_1(Shdr) *VAR_11 = &VAR_0->shdr[VAR_2->sh_link];\n#ifdef VAR_12\n\tif ((int)VAR_2->sh_size < 1 || VAR_2->sh_size > VAR_13) {\n#else\n\tif ((int)shdr->sh_size < 1) {\n#endif\n\t\treturn false;\n\t}\n\tif (VAR_2->sh_size < sizeof (VAR_1(VAR_8)) || VAR_2->sh_size < sizeof (VAR_1(VAR_14))) {\n\t\treturn false;\n\t}\n\tVAR_1(VAR_8) *VAR_15 = calloc (VAR_2->sh_size, 1);\n\tif (!VAR_15) {\n\t\tR_LOG_DEBUG (\"Cannot allocate memory (Check Elf_(Verdef))\");\n\t\treturn false;\n\t}\n\tif (VAR_0->shstrtab && VAR_2->sh_name < VAR_0->shstrtab_size) {\n\t\tVAR_4 = &VAR_0->shstrtab[VAR_2->sh_name];\n\t}\n\tif (VAR_11 && VAR_0->shstrtab && VAR_11->sh_name < VAR_0->shstrtab_size) {\n\t\tVAR_5 = &VAR_0->shstrtab[VAR_11->sh_name];\n\t}\n\tSdb *VAR_16 = sdb_new0 ();\n\tif (!VAR_16) {\n\t\tfree (VAR_15);\n\t\treturn false;\n\t}\n\tsize_t VAR_17 = VAR_2->sh_size;\n\tif (VAR_2->sh_size > VAR_0->size) {\n\t\tif (VAR_0->verbose) {\n\t\t\teprintf (\"Truncating shsize from %d to %d\\n\", (int)VAR_2->sh_size, (int)VAR_0->size);\n\t\t}\n\t\tif (VAR_0->size > VAR_2->sh_offset) {\n\t\t\tVAR_17 = VAR_0->size - VAR_2->sh_offset;\n\t\t} else {\n\t\t\tVAR_17 = VAR_0->size;\n\t\t}\n\t}\n\tVAR_6 = (char *)VAR_15 + VAR_17; /* COMMENT_0 */\n\tsdb_set (VAR_16, \"section_name\", VAR_4, 0);\n\tsdb_num_set (VAR_16, \"entries\", VAR_2->sh_info, 0);\n\tsdb_num_set (VAR_16, \"addr\", VAR_2->sh_addr, 0);\n\tsdb_num_set (VAR_16, \"offset\", VAR_2->sh_offset, 0);\n\tsdb_num_set (VAR_16, \"link\", VAR_2->sh_link, 0);\n\tsdb_set (VAR_16, \"link_section_name\", VAR_5, 0);\n\n\tfor (VAR_9 = 0, VAR_10 = 0; VAR_9 < VAR_2->sh_info && VAR_10 < VAR_2->sh_size; VAR_9++) {\n\t\tSdb *VAR_18 = sdb_new0 ();\n\t\tchar *VAR_19 = ((char*)VAR_15) + VAR_10;\n\t\tsize_t VAR_20 = VAR_10;\n\t\tchar VAR_21[32] = {0};\n\t\tVAR_1(VAR_8) *VAR_22 = (VAR_1(Verdef)*)VAR_19;\n\t\tVAR_1(Verdaux) VAR_23 = {0};\n\t\tint VAR_24 = 0;\n\t\tint VAR_25 = 0;\n\n\t\tif (VAR_19 + sizeof (*VAR_22) > VAR_6) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (VAR_0->b, VAR_2->sh_offset + VAR_10, VAR_7, sizeof (VAR_1(Verdef)));\n\t\tVAR_22->vd_version = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_flags = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_ndx = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_cnt = READ16 (VAR_7, VAR_24);\n\t\tVAR_22->vd_hash = READ32 (VAR_7, VAR_24);\n\t\tVAR_22->vd_aux = READ32 (VAR_7, VAR_24);\n\t\tVAR_22->vd_next = READ32 (VAR_7, VAR_24);\n\t\tint VAR_26 = VAR_22->vd_aux;\n\t\tif (VAR_26 < 1 || VAR_2->sh_size - VAR_20 < VAR_26) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\t\tVAR_19 += VAR_26;\n\t\tVAR_20 += VAR_26;\n\t\tif (VAR_19 > VAR_6 || VAR_2->sh_size - sizeof (VAR_1(Verdaux)) < VAR_20) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tVAR_24 = 0;\n\t\tVAR_23.vda_name = READ32 (VAR_19, VAR_24);\n\t\tVAR_23.vda_next = READ32 (VAR_19, VAR_24);\n\n\t\tVAR_25 = VAR_10 + VAR_22->vd_aux;\n\t\tif (VAR_23.vda_name > VAR_0->dynstr_size) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (VAR_18, \"idx\", VAR_10, 0);\n\t\tsdb_num_set (VAR_18, \"vd_version\", VAR_22->vd_version, 0);\n\t\tsdb_num_set (VAR_18, \"vd_ndx\", VAR_22->vd_ndx, 0);\n\t\tsdb_num_set (VAR_18, \"vd_cnt\", VAR_22->vd_cnt, 0);\n\t\tsdb_set (VAR_18, \"vda_name\", &VAR_0->dynstr[VAR_23.vda_name], 0);\n\t\tsdb_set (VAR_18, \"flags\", get_ver_flags (VAR_22->vd_flags), 0);\n\n\t\tfor (VAR_24 = 1; VAR_24 < VAR_22->vd_cnt; VAR_24++) {\n\t\t\tint VAR_27;\n\t\t\tSdb *VAR_28 = sdb_new0 ();\n\t\t\tif (VAR_2->sh_size - VAR_20 < VAR_23.vda_next) {\n\t\t\t\tsdb_free (VAR_18);\n\t\t\t\tsdb_free (VAR_28);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tVAR_25 += VAR_23.vda_next;\n\t\t\tVAR_19 += VAR_23.vda_next;\n\t\t\tVAR_20 += VAR_23.vda_next;\n\t\t\tif (VAR_19 > VAR_6 || VAR_2->sh_size - sizeof (VAR_1(Verdaux)) < VAR_20) {\n\t\t\t\tsdb_free (VAR_18);\n\t\t\t\tsdb_free (VAR_28);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tVAR_27 = 0;\n\t\t\tVAR_23.vda_name = READ32 (VAR_19, VAR_27);\n\t\t\tVAR_23.vda_next = READ32 (VAR_19, VAR_27);\n\t\t\tif (VAR_23.vda_name > VAR_0->dynstr_size) {\n\t\t\t\tsdb_free (VAR_18);\n\t\t\t\tsdb_free (VAR_28);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (VAR_28, \"idx\", VAR_25, 0);\n\t\t\tsdb_num_set (VAR_28, \"parent\", VAR_24, 0);\n\t\t\tsdb_set (VAR_28, \"vda_name\", &VAR_0->dynstr[VAR_23.vda_name], 0);\n\t\t\tsnprintf (VAR_21, sizeof (VAR_21), \"parent%d\", VAR_24 - 1);\n\t\t\tsdb_ns_set (VAR_18, VAR_21, VAR_28);\n\t\t}\n\n\t\tsnprintf (VAR_21, sizeof (VAR_21), \"verdef%u\", VAR_9);\n\t\tsdb_ns_set (VAR_16, VAR_21, VAR_18);\n\t\tif (!VAR_22->vd_next || VAR_2->sh_size - VAR_10 < VAR_22->vd_next) {\n\t\t\tsdb_free (VAR_18);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)VAR_22->vd_next < 1) {\n\t\t\tR_LOG_DEBUG (\"Invalid vd_next in the ELF version\");\n\t\t\tbreak;\n\t\t}\n\t\tVAR_10 += VAR_22->vd_next;\n\t}\n\tfree (VAR_15);\n\treturn VAR_16;\nout_error:\n\tfree (VAR_15);\n\tsdb_free (VAR_16);\n\treturn NULL;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n \t}\n \tElf_(Verdef) *defs = calloc (shdr->sh_size, 1);\n \tif (!defs) {\n-\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\");\n+\t\tR_LOG_DEBUG (\"Cannot allocate memory (Check Elf_(Verdef))\");\n \t\treturn false;\n \t}\n \tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\");"
    ],
    "added_lines": [
      "\t\tR_LOG_DEBUG (\"Cannot allocate memory (Check Elf_(Verdef))\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/20097",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/20097: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/20097",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}