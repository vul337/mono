{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received AXFR, in megabytes\n\nThis prevents resource exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "a014f4c224a7b21f1c648257d1fd1128413129aa",
  "git_url": "https://github.com/PowerDNS/pdns/commit/a014f4c224a7b21f1c648257d1fd1128413129aa",
  "file_path": "pdns/slavecommunicator.cc",
  "func_name": "CommunicatorClass::suck",
  "func_before": "void CommunicatorClass::suck(const string &domain,const string &remote)\n{\n  L<<Logger::Error<<\"Initiating transfer of '\"<<domain<<\"' from remote '\"<<remote<<\"'\"<<endl;\n  UeberBackend B; // fresh UeberBackend\n\n  DomainInfo di;\n  di.backend=0;\n  bool transaction=false;\n  try {\n    DNSSECKeeper dk (&B); // reuse our UeberBackend copy for DNSSECKeeper\n\n    if(!B.getDomainInfo(domain, di) || !di.backend) { // di.backend and B are mostly identical\n      L<<Logger::Error<<\"Can't determine backend for domain '\"<<domain<<\"'\"<<endl;\n      return;\n    }\n    uint32_t domain_id=di.id;\n\n\n    string tsigkeyname, tsigalgorithm, tsigsecret;\n    if(dk.getTSIGForAccess(domain, remote, &tsigkeyname)) {\n      string tsigsecret64;\n      if(B.getTSIGKey(tsigkeyname, &tsigalgorithm, &tsigsecret64)) {\n        B64Decode(tsigsecret64, tsigsecret);\n      } else {\n        L<<Logger::Error<<\"TSIG key '\"<<tsigkeyname<<\"' for domain '\"<<domain<<\"' not found\"<<endl;\n        return;\n      }\n    }\n\n\n    scoped_ptr<AuthLua> pdl;\n    vector<string> scripts;\n    if(B.getDomainMetadata(domain, \"LUA-AXFR-SCRIPT\", scripts) && !scripts.empty()) {\n      try {\n        pdl.reset(new AuthLua(scripts[0]));\n        L<<Logger::Info<<\"Loaded Lua script '\"<<scripts[0]<<\"' to edit the incoming AXFR of '\"<<domain<<\"'\"<<endl;\n      }\n      catch(std::exception& e) {\n        L<<Logger::Error<<\"Failed to load Lua editing script '\"<<scripts[0]<<\"' for incoming AXFR of '\"<<domain<<\"': \"<<e.what()<<endl;\n        return;\n      }\n    }\n\n\n    vector<string> localaddr;\n    ComboAddress laddr;\n    if(B.getDomainMetadata(domain, \"AXFR-SOURCE\", localaddr) && !localaddr.empty()) {\n      try {\n        laddr = ComboAddress(localaddr[0]);\n        L<<Logger::Info<<\"AXFR source for domain '\"<<domain<<\"' set to \"<<localaddr[0]<<endl;\n      }\n      catch(std::exception& e) {\n        L<<Logger::Error<<\"Failed to load AXFR source '\"<<localaddr[0]<<\"' for incoming AXFR of '\"<<domain<<\"': \"<<e.what()<<endl;\n        return;\n      }\n    } else {\n      laddr.sin4.sin_family = 0;\n    }\n\n\n    bool hadDnssecZone = false;\n    bool hadPresigned = false;\n    bool hadNSEC3 = false;\n    NSEC3PARAMRecordContent ns3pr, hadNs3pr;\n    bool isNarrow, hadNarrow=false;\n\n    if(dk.isSecuredZone(domain)) {\n      hadDnssecZone=true;\n      hadPresigned=dk.isPresigned(domain);\n      if (dk.getNSEC3PARAM(domain, &ns3pr, &isNarrow)) {\n        hadNSEC3 = true;\n        hadNs3pr = ns3pr;\n        hadNarrow = isNarrow;\n      }\n    }\n\n\n    bool isDnssecZone = false;\n    bool isPresigned = false;\n    bool isNSEC3 = false;\n    bool optOutFlag = false;\n\n    bool first=true;\n    bool firstNSEC3=true;\n    unsigned int soa_serial = 0;\n    set<string> nsset, qnames, secured;\n    vector<DNSResourceRecord> rrs;\n\n    ComboAddress raddr(remote, 53);\n    AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr);\n    Resolver::res_t recs;\n    while(retriever.getChunk(recs)) {\n      if(first) {\n        L<<Logger::Error<<\"AXFR started for '\"<<domain<<\"'\"<<endl;\n        first=false;\n      }\n\n      for(Resolver::res_t::iterator i=recs.begin();i!=recs.end();++i) {\n        if(i->qtype.getCode() == QType::OPT || i->qtype.getCode() == QType::TSIG) // ignore EDNS0 & TSIG\n          continue;\n\n        if(!endsOn(i->qname, domain)) {\n          L<<Logger::Error<<\"Remote \"<<remote<<\" tried to sneak in out-of-zone data '\"<<i->qname<<\"'|\"<<i->qtype.getName()<<\" during AXFR of zone '\"<<domain<<\"', ignoring\"<<endl;\n          continue;\n        }\n\n        vector<DNSResourceRecord> out;\n        if(!pdl || !pdl->axfrfilter(raddr, domain, *i, out)) {\n          out.push_back(*i);\n        }\n\n        BOOST_FOREACH(DNSResourceRecord& rr, out) {\n          switch(rr.qtype.getCode()) {\n            case QType::NSEC3PARAM: {\n              ns3pr = NSEC3PARAMRecordContent(rr.content);\n              isDnssecZone = isNSEC3 = true;\n              isNarrow = false;\n              continue;\n            }\n            case QType::NSEC3: {\n              NSEC3RecordContent ns3rc(rr.content);\n              if (firstNSEC3) {\n                isDnssecZone = isPresigned = true;\n                firstNSEC3 = false;\n              } else if (optOutFlag != (ns3rc.d_flags & 1))\n                throw PDNSException(\"Zones with a mixture of Opt-Out NSEC3 RRs and non-Opt-Out NSEC3 RRs are not supported.\");\n              optOutFlag = ns3rc.d_flags & 1;\n              if (ns3rc.d_set.count(QType::NS) && !pdns_iequals(rr.qname, domain))\n                secured.insert(toLower(makeRelative(rr.qname, domain)));\n              continue;\n            }\n            case QType::NSEC: {\n              isDnssecZone = isPresigned = true;\n              continue;\n            }\n            case QType::SOA: {\n              if(soa_serial != 0)\n                continue; //skip the last SOA\n              SOAData sd;\n              fillSOAData(rr.content,sd);\n              soa_serial = sd.serial;\n              break;\n            }\n            case QType::NS: {\n              if(!pdns_iequals(rr.qname, domain))\n                nsset.insert(rr.qname);\n              break;\n            }\n            default:\n              break;\n          }\n\n          qnames.insert(rr.qname);\n\n          rr.domain_id=domain_id;\n          rrs.push_back(rr);\n        }\n      }\n    }\n\n    if(isNSEC3) {\n      ns3pr.d_flags = optOutFlag ? 1 : 0;\n    }\n\n\n    if(!isPresigned) {\n      DNSSECKeeper::keyset_t keys = dk.getKeys(domain);\n      if(!keys.empty()) {\n        isDnssecZone = true;\n        isNSEC3 = hadNSEC3;\n        ns3pr = hadNs3pr;\n        optOutFlag = (hadNs3pr.d_flags & 1);\n        isNarrow = hadNarrow;\n      }\n    }\n\n\n    if(isDnssecZone) {\n      if(!isNSEC3)\n        L<<Logger::Info<<\"Adding NSEC ordering information\"<<endl;\n      else if(!isNarrow)\n        L<<Logger::Info<<\"Adding NSEC3 hashed ordering information for '\"<<domain<<\"'\"<<endl;\n      else\n        L<<Logger::Info<<\"Erasing NSEC3 ordering since we are narrow, only setting 'auth' fields\"<<endl;\n    }\n\n\n    transaction=di.backend->startTransaction(domain, domain_id);\n    L<<Logger::Error<<\"Transaction started for '\"<<domain<<\"'\"<<endl;\n\n    // update the presigned flag and NSEC3PARAM\n    if (isDnssecZone) {\n      // update presigned if there was a change\n      if (isPresigned && !hadPresigned) {\n        // zone is now presigned\n        dk.setPresigned(domain);\n      } else if (hadPresigned && !isPresigned) {\n        // zone is no longer presigned\n        dk.unsetPresigned(domain);\n      }\n      // update NSEC3PARAM\n      if (isNSEC3) {\n        // zone is NSEC3, only update if there was a change\n        if (!hadNSEC3 || (hadNarrow  != isNarrow) ||\n            (ns3pr.d_algorithm != hadNs3pr.d_algorithm) ||\n            (ns3pr.d_flags != hadNs3pr.d_flags) ||\n            (ns3pr.d_iterations != hadNs3pr.d_iterations) ||\n            (ns3pr.d_salt != hadNs3pr.d_salt)) {\n          dk.setNSEC3PARAM(domain, ns3pr, isNarrow);\n        }\n      } else if (hadNSEC3 ) {\n         // zone is no longer NSEC3\n         dk.unsetNSEC3PARAM(domain);\n      }\n    } else if (hadDnssecZone) {\n      // zone is no longer signed\n      if (hadPresigned) {\n        // remove presigned\n        dk.unsetPresigned(domain);\n      }\n      if (hadNSEC3) {\n        // unset NSEC3PARAM\n        dk.unsetNSEC3PARAM(domain);\n      }\n    }\n\n    bool doent=true;\n    uint32_t maxent = ::arg().asNum(\"max-ent-entries\");\n    string ordername, shorter;\n    set<string> rrterm;\n    map<string,bool> nonterm;\n\n\n    BOOST_FOREACH(DNSResourceRecord& rr, rrs) {\n\n      if(!isPresigned) {\n        if (rr.qtype.getCode() == QType::RRSIG)\n          continue;\n        if(isDnssecZone && rr.qtype.getCode() == QType::DNSKEY && !::arg().mustDo(\"direct-dnskey\"))\n          continue;\n      }\n\n      // Figure out auth and ents\n      rr.auth=true;\n      shorter=rr.qname;\n      rrterm.clear();\n      do {\n        if(doent) {\n          if (!qnames.count(shorter))\n            rrterm.insert(shorter);\n        }\n        if(nsset.count(shorter) && rr.qtype.getCode() != QType::DS)\n          rr.auth=false;\n\n        if (pdns_iequals(shorter, domain)) // stop at apex\n          break;\n      }while(chopOff(shorter));\n\n      // Insert ents\n      if(doent && !rrterm.empty()) {\n        bool auth;\n        if (!rr.auth && rr.qtype.getCode() == QType::NS) {\n          if (isNSEC3)\n            ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname));\n          auth=(!isNSEC3 || !optOutFlag || secured.count(ordername));\n        } else\n          auth=rr.auth;\n\n        BOOST_FOREACH(const string nt, rrterm){\n          if (!nonterm.count(nt))\n              nonterm.insert(pair<string, bool>(nt, auth));\n            else if (auth)\n              nonterm[nt]=true;\n        }\n\n        if(nonterm.size() > maxent) {\n          L<<Logger::Error<<\"AXFR zone \"<<domain<<\" has too many empty non terminals.\"<<endl;\n          nonterm.clear();\n          doent=false;\n        }\n      }\n\n      // RRSIG is always auth, even inside a delegation\n      if (rr.qtype.getCode() == QType::RRSIG)\n        rr.auth=true;\n\n      // Add ordername and insert record\n      if (isDnssecZone && rr.qtype.getCode() != QType::RRSIG) {\n        if (isNSEC3) {\n          // NSEC3\n          ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname));\n          if(!isNarrow && (rr.auth || (rr.qtype.getCode() == QType::NS && (!optOutFlag || secured.count(ordername))))) {\n            di.backend->feedRecord(rr, &ordername);\n          } else\n            di.backend->feedRecord(rr);\n        } else {\n          // NSEC\n          if (rr.auth || rr.qtype.getCode() == QType::NS) {\n            ordername=toLower(labelReverse(makeRelative(rr.qname, domain)));\n            di.backend->feedRecord(rr, &ordername);\n          } else\n            di.backend->feedRecord(rr);\n        }\n      } else\n        di.backend->feedRecord(rr);\n    }\n\n    // Insert empty non-terminals\n    if(doent && !nonterm.empty()) {\n      if (isNSEC3) {\n        di.backend->feedEnts3(domain_id, domain, nonterm, ns3pr.d_iterations, ns3pr.d_salt, isNarrow);\n      } else\n        di.backend->feedEnts(domain_id, nonterm);\n    }\n\n    di.backend->commitTransaction();\n    transaction = false;\n    di.backend->setFresh(domain_id);\n    PC.purge(domain+\"$\");\n\n\n    L<<Logger::Error<<\"AXFR done for '\"<<domain<<\"', zone committed with serial number \"<<soa_serial<<endl;\n    if(::arg().mustDo(\"slave-renotify\"))\n      notifyDomain(domain);\n  }\n  catch(DBException &re) {\n    L<<Logger::Error<<\"Unable to feed record during incoming AXFR of '\"+domain+\"': \"<<re.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(MOADNSException &re) {\n    L<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+domain+\"' (MOADNSException): \"<<re.what()<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(std::exception &re) {\n    L<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+domain+\"' (std::exception): \"<<re.what()<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(ResolverException &re) {\n    L<<Logger::Error<<\"Unable to AXFR zone '\"+domain+\"' from remote '\"<<remote<<\"' (resolver): \"<<re.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(PDNSException &ae) {\n    L<<Logger::Error<<\"Unable to AXFR zone '\"+domain+\"' from remote '\"<<remote<<\"' (PDNSException): \"<<ae.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n}",
  "abstract_func_before": "void CommunicatorClass::suck(const string &VAR_0,const string &VAR_1)\n{\n  VAR_2<<Logger::Error<<\"Initiating transfer of '\"<<VAR_0<<\"' from remote '\"<<VAR_1<<\"'\"<<VAR_3;\n  UeberBackend VAR_4; /* COMMENT_0 */\n\n  DomainInfo VAR_5;\n  VAR_5.backend=0;\n  bool VAR_6=false;\n  try {\n    DNSSECKeeper VAR_7 (&VAR_4); /* COMMENT_1 */\n\n    if(!VAR_4.getDomainInfo(VAR_0, VAR_5) || !VAR_5.backend) { /* COMMENT_2 */\n      VAR_2<<Logger::Error<<\"Can't determine backend for domain '\"<<VAR_0<<\"'\"<<VAR_3;\n      return;\n    }\n    uint32_t VAR_8=VAR_5.id;\n\n\n    string VAR_9, VAR_10, VAR_11;\n    if(VAR_7.getTSIGForAccess(VAR_0, VAR_1, &VAR_9)) {\n      string VAR_12;\n      if(VAR_4.getTSIGKey(VAR_9, &VAR_10, &VAR_12)) {\n        B64Decode(VAR_12, VAR_11);\n      } else {\n        VAR_2<<Logger::Error<<\"TSIG key '\"<<VAR_9<<\"' for domain '\"<<VAR_0<<\"' not found\"<<VAR_3;\n        return;\n      }\n    }\n\n\n    scoped_ptr<AuthLua> VAR_13;\n    vector<string> VAR_14;\n    if(VAR_4.getDomainMetadata(VAR_0, \"LUA-AXFR-SCRIPT\", VAR_14) && !VAR_14.empty()) {\n      try {\n        VAR_13.reset(new AuthLua(VAR_14[0]));\n        VAR_2<<Logger::Info<<\"Loaded Lua script '\"<<VAR_14[0]<<\"' to edit the incoming AXFR of '\"<<VAR_0<<\"'\"<<VAR_3;\n      }\n      catch(std::exception& VAR_15) {\n        VAR_2<<Logger::Error<<\"Failed to load Lua editing script '\"<<VAR_14[0]<<\"' for incoming AXFR of '\"<<VAR_0<<\"': \"<<VAR_15.what()<<VAR_3;\n        return;\n      }\n    }\n\n\n    vector<string> VAR_16;\n    ComboAddress VAR_17;\n    if(VAR_4.getDomainMetadata(VAR_0, \"AXFR-SOURCE\", VAR_16) && !VAR_16.empty()) {\n      try {\n        VAR_17 = ComboAddress(VAR_16[0]);\n        VAR_2<<Logger::Info<<\"AXFR source for domain '\"<<VAR_0<<\"' set to \"<<VAR_16[0]<<VAR_3;\n      }\n      catch(std::exception& VAR_15) {\n        VAR_2<<Logger::Error<<\"Failed to load AXFR source '\"<<VAR_16[0]<<\"' for incoming AXFR of '\"<<VAR_0<<\"': \"<<VAR_15.what()<<VAR_3;\n        return;\n      }\n    } else {\n      VAR_17.sin4.sin_family = 0;\n    }\n\n\n    bool VAR_18 = false;\n    bool VAR_19 = false;\n    bool VAR_20 = false;\n    NSEC3PARAMRecordContent VAR_21, VAR_22;\n    bool VAR_23, VAR_24=false;\n\n    if(VAR_7.isSecuredZone(VAR_0)) {\n      VAR_18=true;\n      VAR_19=VAR_7.isPresigned(VAR_0);\n      if (VAR_7.getNSEC3PARAM(VAR_0, &VAR_21, &VAR_23)) {\n        VAR_20 = true;\n        VAR_22 = VAR_21;\n        VAR_24 = VAR_23;\n      }\n    }\n\n\n    bool VAR_25 = false;\n    bool VAR_26 = false;\n    bool VAR_27 = false;\n    bool VAR_28 = false;\n\n    bool VAR_29=true;\n    bool VAR_30=true;\n    unsigned int VAR_31 = 0;\n    set<string> VAR_32, VAR_33, VAR_34;\n    vector<DNSResourceRecord> VAR_35;\n\n    ComboAddress VAR_36(VAR_1, 53);\n    AXFRRetriever VAR_37(VAR_36, VAR_0.c_str(), VAR_9, VAR_10, VAR_11, (VAR_17.sin4.sin_family == 0) ? NULL : &VAR_17);\n    Resolver::res_t VAR_38;\n    while(VAR_37.getChunk(VAR_38)) {\n      if(VAR_29) {\n        VAR_2<<Logger::Error<<\"AXFR started for '\"<<VAR_0<<\"'\"<<VAR_3;\n        VAR_29=false;\n      }\n\n      for(Resolver::res_t::iterator VAR_39=VAR_38.begin();VAR_39!=VAR_38.end();++VAR_39) {\n        if(VAR_39->qtype.getCode() == QType::OPT || VAR_39->qtype.getCode() == QType::TSIG) /* COMMENT_3 */\n          continue;\n\n        if(!endsOn(VAR_39->qname, VAR_0)) {\n          VAR_2<<Logger::Error<<\"Remote \"<<VAR_1<<\" tried to sneak in out-of-zone data '\"<<VAR_39->qname<<\"'|\"<<VAR_39->qtype.getName()<<\" during AXFR of zone '\"<<VAR_0<<\"', ignoring\"<<VAR_3;\n          continue;\n        }\n\n        vector<DNSResourceRecord> VAR_40;\n        if(!VAR_13 || !VAR_13->axfrfilter(VAR_36, VAR_0, *VAR_39, VAR_40)) {\n          VAR_40.push_back(*VAR_39);\n        }\n\n        BOOST_FOREACH(DNSResourceRecord& VAR_41, out) {\n          switch(VAR_41.qtype.getCode()) {\n            case QType::NSEC3PARAM: {\n              VAR_21 = NSEC3PARAMRecordContent(VAR_41.content);\n              VAR_25 = VAR_27 = true;\n              VAR_23 = false;\n              continue;\n            }\n            case QType::NSEC3: {\n              NSEC3RecordContent VAR_42(VAR_41.content);\n              if (VAR_30) {\n                VAR_25 = VAR_26 = true;\n                VAR_30 = false;\n              } else if (VAR_28 != (VAR_42.d_flags & 1))\n                throw PDNSException(\"Zones with a mixture of Opt-Out NSEC3 RRs and non-Opt-Out NSEC3 RRs are not supported.\");\n              VAR_28 = VAR_42.d_flags & 1;\n              if (VAR_42.d_set.count(QType::NS) && !pdns_iequals(VAR_41.qname, VAR_0))\n                VAR_34.insert(toLower(makeRelative(VAR_41.qname, VAR_0)));\n              continue;\n            }\n            case QType::NSEC: {\n              VAR_25 = VAR_26 = true;\n              continue;\n            }\n            case QType::SOA: {\n              if(VAR_31 != 0)\n                continue; /* COMMENT_4 */\n              SOAData VAR_43;\n              fillSOAData(VAR_41.content,VAR_43);\n              VAR_31 = VAR_43.serial;\n              break;\n            }\n            case QType::NS: {\n              if(!pdns_iequals(VAR_41.qname, VAR_0))\n                VAR_32.insert(VAR_41.qname);\n              break;\n            }\n            default:\n              break;\n          }\n\n          VAR_33.insert(VAR_41.qname);\n\n          VAR_41.domain_id=VAR_8;\n          VAR_35.push_back(VAR_41);\n        }\n      }\n    }\n\n    if(VAR_27) {\n      VAR_21.d_flags = VAR_28 ? 1 : 0;\n    }\n\n\n    if(!VAR_26) {\n      DNSSECKeeper::keyset_t VAR_44 = VAR_7.getKeys(VAR_0);\n      if(!VAR_44.empty()) {\n        VAR_25 = true;\n        VAR_27 = VAR_20;\n        VAR_21 = VAR_22;\n        VAR_28 = (VAR_22.d_flags & 1);\n        VAR_23 = VAR_24;\n      }\n    }\n\n\n    if(VAR_25) {\n      if(!VAR_27)\n        VAR_2<<Logger::Info<<\"Adding NSEC ordering information\"<<VAR_3;\n      else if(!VAR_23)\n        VAR_2<<Logger::Info<<\"Adding NSEC3 hashed ordering information for '\"<<VAR_0<<\"'\"<<VAR_3;\n      else\n        VAR_2<<Logger::Info<<\"Erasing NSEC3 ordering since we are narrow, only setting 'auth' fields\"<<VAR_3;\n    }\n\n\n    VAR_6=VAR_5.backend->startTransaction(VAR_0, VAR_8);\n    VAR_2<<Logger::Error<<\"Transaction started for '\"<<VAR_0<<\"'\"<<VAR_3;\n\n    /* COMMENT_5 */\n    if (VAR_25) {\n      /* COMMENT_6 */\n      if (VAR_26 && !VAR_19) {\n        /* COMMENT_7 */\n        VAR_7.setPresigned(VAR_0);\n      } else if (VAR_19 && !VAR_26) {\n        /* COMMENT_8 */\n        VAR_7.unsetPresigned(VAR_0);\n      }\n      /* COMMENT_9 */\n      if (VAR_27) {\n        /* COMMENT_10 */\n        if (!VAR_20 || (VAR_24  != VAR_23) ||\n            (VAR_21.d_algorithm != VAR_22.d_algorithm) ||\n            (VAR_21.d_flags != VAR_22.d_flags) ||\n            (VAR_21.d_iterations != VAR_22.d_iterations) ||\n            (VAR_21.d_salt != VAR_22.d_salt)) {\n          VAR_7.setNSEC3PARAM(VAR_0, VAR_21, VAR_23);\n        }\n      } else if (VAR_20 ) {\n         /* COMMENT_11 */\n         VAR_7.unsetNSEC3PARAM(VAR_0);\n      }\n    } else if (VAR_18) {\n      /* COMMENT_12 */\n      if (VAR_19) {\n        /* COMMENT_13 */\n        VAR_7.unsetPresigned(VAR_0);\n      }\n      if (VAR_20) {\n        /* COMMENT_14 */\n        VAR_7.unsetNSEC3PARAM(VAR_0);\n      }\n    }\n\n    bool VAR_45=true;\n    uint32_t VAR_46 = ::arg().asNum(\"max-ent-entries\");\n    string VAR_47, VAR_48;\n    set<string> VAR_49;\n    map<string,bool> VAR_50;\n\n\n    BOOST_FOREACH(DNSResourceRecord& VAR_41, rrs) {\n\n      if(!VAR_26) {\n        if (VAR_41.qtype.getCode() == QType::RRSIG)\n          continue;\n        if(VAR_25 && VAR_41.qtype.getCode() == QType::DNSKEY && !::arg().mustDo(\"direct-dnskey\"))\n          continue;\n      }\n\n      /* COMMENT_15 */\n      VAR_41.auth=true;\n      VAR_48=VAR_41.qname;\n      VAR_49.clear();\n      do {\n        if(VAR_45) {\n          if (!VAR_33.count(VAR_48))\n            VAR_49.insert(VAR_48);\n        }\n        if(VAR_32.count(VAR_48) && VAR_41.qtype.getCode() != QType::DS)\n          VAR_41.auth=false;\n\n        if (pdns_iequals(VAR_48, VAR_0)) /* COMMENT_16 */\n          break;\n      }while(chopOff(VAR_48));\n\n      /* COMMENT_17 */\n      if(VAR_45 && !VAR_49.empty()) {\n        bool VAR_51;\n        if (!VAR_41.auth && VAR_41.qtype.getCode() == QType::NS) {\n          if (VAR_27)\n            VAR_47=toBase32Hex(hashQNameWithSalt(VAR_21.d_iterations, VAR_21.d_salt, VAR_41.qname));\n          VAR_51=(!VAR_27 || !VAR_28 || VAR_34.count(VAR_47));\n        } else\n          VAR_51=VAR_41.auth;\n\n        BOOST_FOREACH(const string VAR_52, rrterm){\n          if (!VAR_50.count(VAR_52))\n              VAR_50.insert(VAR_53<string, bool>(VAR_52, VAR_51));\n            else if (VAR_51)\n              VAR_50[VAR_52]=true;\n        }\n\n        if(VAR_50.size() > VAR_46) {\n          VAR_2<<Logger::Error<<\"AXFR zone \"<<VAR_0<<\" has too many empty non terminals.\"<<VAR_3;\n          VAR_50.clear();\n          VAR_45=false;\n        }\n      }\n\n      /* COMMENT_18 */\n      if (VAR_41.qtype.getCode() == QType::RRSIG)\n        VAR_41.auth=true;\n\n      /* COMMENT_19 */\n      if (VAR_25 && VAR_41.qtype.getCode() != QType::RRSIG) {\n        if (VAR_27) {\n          /* COMMENT_20 */\n          VAR_47=toBase32Hex(hashQNameWithSalt(VAR_21.d_iterations, VAR_21.d_salt, VAR_41.qname));\n          if(!VAR_23 && (VAR_41.auth || (VAR_41.qtype.getCode() == QType::NS && (!VAR_28 || VAR_34.count(VAR_47))))) {\n            VAR_5.backend->feedRecord(VAR_41, &VAR_47);\n          } else\n            VAR_5.backend->feedRecord(VAR_41);\n        } else {\n          /* COMMENT_21 */\n          if (VAR_41.auth || VAR_41.qtype.getCode() == QType::NS) {\n            VAR_47=toLower(labelReverse(makeRelative(VAR_41.qname, VAR_0)));\n            VAR_5.backend->feedRecord(VAR_41, &VAR_47);\n          } else\n            VAR_5.backend->feedRecord(VAR_41);\n        }\n      } else\n        VAR_5.backend->feedRecord(VAR_41);\n    }\n\n    /* COMMENT_22 */\n    if(VAR_45 && !VAR_50.empty()) {\n      if (VAR_27) {\n        VAR_5.backend->feedEnts3(VAR_8, VAR_0, VAR_50, VAR_21.d_iterations, VAR_21.d_salt, VAR_23);\n      } else\n        VAR_5.backend->feedEnts(VAR_8, VAR_50);\n    }\n\n    VAR_5.backend->commitTransaction();\n    VAR_6 = false;\n    VAR_5.backend->setFresh(VAR_8);\n    VAR_54.purge(VAR_0+\"$\");\n\n\n    VAR_2<<Logger::Error<<\"AXFR done for '\"<<VAR_0<<\"', zone committed with serial number \"<<VAR_31<<VAR_3;\n    if(::arg().mustDo(\"slave-renotify\"))\n      notifyDomain(VAR_0);\n  }\n  catch(DBException &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to feed record during incoming AXFR of '\"+VAR_0+\"': \"<<VAR_55.reason<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(MOADNSException &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+VAR_0+\"' (MOADNSException): \"<<VAR_55.what()<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(std::exception &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+VAR_0+\"' (std::exception): \"<<VAR_55.what()<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(ResolverException &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to AXFR zone '\"+VAR_0+\"' from remote '\"<<VAR_1<<\"' (resolver): \"<<VAR_55.reason<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(PDNSException &VAR_56) {\n    VAR_2<<Logger::Error<<\"Unable to AXFR zone '\"+VAR_0+\"' from remote '\"<<VAR_1<<\"' (PDNSException): \"<<VAR_56.reason<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n}",
  "func_graph_path_before": "PowerDNS/pdns/a014f4c224a7b21f1c648257d1fd1128413129aa/slavecommunicator.cc/vul/before/0.json",
  "func": "void CommunicatorClass::suck(const string &domain,const string &remote)\n{\n  L<<Logger::Error<<\"Initiating transfer of '\"<<domain<<\"' from remote '\"<<remote<<\"'\"<<endl;\n  UeberBackend B; // fresh UeberBackend\n\n  DomainInfo di;\n  di.backend=0;\n  bool transaction=false;\n  try {\n    DNSSECKeeper dk (&B); // reuse our UeberBackend copy for DNSSECKeeper\n\n    if(!B.getDomainInfo(domain, di) || !di.backend) { // di.backend and B are mostly identical\n      L<<Logger::Error<<\"Can't determine backend for domain '\"<<domain<<\"'\"<<endl;\n      return;\n    }\n    uint32_t domain_id=di.id;\n\n\n    string tsigkeyname, tsigalgorithm, tsigsecret;\n    if(dk.getTSIGForAccess(domain, remote, &tsigkeyname)) {\n      string tsigsecret64;\n      if(B.getTSIGKey(tsigkeyname, &tsigalgorithm, &tsigsecret64)) {\n        B64Decode(tsigsecret64, tsigsecret);\n      } else {\n        L<<Logger::Error<<\"TSIG key '\"<<tsigkeyname<<\"' for domain '\"<<domain<<\"' not found\"<<endl;\n        return;\n      }\n    }\n\n\n    scoped_ptr<AuthLua> pdl;\n    vector<string> scripts;\n    if(B.getDomainMetadata(domain, \"LUA-AXFR-SCRIPT\", scripts) && !scripts.empty()) {\n      try {\n        pdl.reset(new AuthLua(scripts[0]));\n        L<<Logger::Info<<\"Loaded Lua script '\"<<scripts[0]<<\"' to edit the incoming AXFR of '\"<<domain<<\"'\"<<endl;\n      }\n      catch(std::exception& e) {\n        L<<Logger::Error<<\"Failed to load Lua editing script '\"<<scripts[0]<<\"' for incoming AXFR of '\"<<domain<<\"': \"<<e.what()<<endl;\n        return;\n      }\n    }\n\n\n    vector<string> localaddr;\n    ComboAddress laddr;\n    if(B.getDomainMetadata(domain, \"AXFR-SOURCE\", localaddr) && !localaddr.empty()) {\n      try {\n        laddr = ComboAddress(localaddr[0]);\n        L<<Logger::Info<<\"AXFR source for domain '\"<<domain<<\"' set to \"<<localaddr[0]<<endl;\n      }\n      catch(std::exception& e) {\n        L<<Logger::Error<<\"Failed to load AXFR source '\"<<localaddr[0]<<\"' for incoming AXFR of '\"<<domain<<\"': \"<<e.what()<<endl;\n        return;\n      }\n    } else {\n      laddr.sin4.sin_family = 0;\n    }\n\n\n    bool hadDnssecZone = false;\n    bool hadPresigned = false;\n    bool hadNSEC3 = false;\n    NSEC3PARAMRecordContent ns3pr, hadNs3pr;\n    bool isNarrow, hadNarrow=false;\n\n    if(dk.isSecuredZone(domain)) {\n      hadDnssecZone=true;\n      hadPresigned=dk.isPresigned(domain);\n      if (dk.getNSEC3PARAM(domain, &ns3pr, &isNarrow)) {\n        hadNSEC3 = true;\n        hadNs3pr = ns3pr;\n        hadNarrow = isNarrow;\n      }\n    }\n\n\n    bool isDnssecZone = false;\n    bool isPresigned = false;\n    bool isNSEC3 = false;\n    bool optOutFlag = false;\n\n    bool first=true;\n    bool firstNSEC3=true;\n    unsigned int soa_serial = 0;\n    set<string> nsset, qnames, secured;\n    vector<DNSResourceRecord> rrs;\n\n    ComboAddress raddr(remote, 53);\n    AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n    Resolver::res_t recs;\n    while(retriever.getChunk(recs)) {\n      if(first) {\n        L<<Logger::Error<<\"AXFR started for '\"<<domain<<\"'\"<<endl;\n        first=false;\n      }\n\n      for(Resolver::res_t::iterator i=recs.begin();i!=recs.end();++i) {\n        if(i->qtype.getCode() == QType::OPT || i->qtype.getCode() == QType::TSIG) // ignore EDNS0 & TSIG\n          continue;\n\n        if(!endsOn(i->qname, domain)) {\n          L<<Logger::Error<<\"Remote \"<<remote<<\" tried to sneak in out-of-zone data '\"<<i->qname<<\"'|\"<<i->qtype.getName()<<\" during AXFR of zone '\"<<domain<<\"', ignoring\"<<endl;\n          continue;\n        }\n\n        vector<DNSResourceRecord> out;\n        if(!pdl || !pdl->axfrfilter(raddr, domain, *i, out)) {\n          out.push_back(*i);\n        }\n\n        BOOST_FOREACH(DNSResourceRecord& rr, out) {\n          switch(rr.qtype.getCode()) {\n            case QType::NSEC3PARAM: {\n              ns3pr = NSEC3PARAMRecordContent(rr.content);\n              isDnssecZone = isNSEC3 = true;\n              isNarrow = false;\n              continue;\n            }\n            case QType::NSEC3: {\n              NSEC3RecordContent ns3rc(rr.content);\n              if (firstNSEC3) {\n                isDnssecZone = isPresigned = true;\n                firstNSEC3 = false;\n              } else if (optOutFlag != (ns3rc.d_flags & 1))\n                throw PDNSException(\"Zones with a mixture of Opt-Out NSEC3 RRs and non-Opt-Out NSEC3 RRs are not supported.\");\n              optOutFlag = ns3rc.d_flags & 1;\n              if (ns3rc.d_set.count(QType::NS) && !pdns_iequals(rr.qname, domain))\n                secured.insert(toLower(makeRelative(rr.qname, domain)));\n              continue;\n            }\n            case QType::NSEC: {\n              isDnssecZone = isPresigned = true;\n              continue;\n            }\n            case QType::SOA: {\n              if(soa_serial != 0)\n                continue; //skip the last SOA\n              SOAData sd;\n              fillSOAData(rr.content,sd);\n              soa_serial = sd.serial;\n              break;\n            }\n            case QType::NS: {\n              if(!pdns_iequals(rr.qname, domain))\n                nsset.insert(rr.qname);\n              break;\n            }\n            default:\n              break;\n          }\n\n          qnames.insert(rr.qname);\n\n          rr.domain_id=domain_id;\n          rrs.push_back(rr);\n        }\n      }\n    }\n\n    if(isNSEC3) {\n      ns3pr.d_flags = optOutFlag ? 1 : 0;\n    }\n\n\n    if(!isPresigned) {\n      DNSSECKeeper::keyset_t keys = dk.getKeys(domain);\n      if(!keys.empty()) {\n        isDnssecZone = true;\n        isNSEC3 = hadNSEC3;\n        ns3pr = hadNs3pr;\n        optOutFlag = (hadNs3pr.d_flags & 1);\n        isNarrow = hadNarrow;\n      }\n    }\n\n\n    if(isDnssecZone) {\n      if(!isNSEC3)\n        L<<Logger::Info<<\"Adding NSEC ordering information\"<<endl;\n      else if(!isNarrow)\n        L<<Logger::Info<<\"Adding NSEC3 hashed ordering information for '\"<<domain<<\"'\"<<endl;\n      else\n        L<<Logger::Info<<\"Erasing NSEC3 ordering since we are narrow, only setting 'auth' fields\"<<endl;\n    }\n\n\n    transaction=di.backend->startTransaction(domain, domain_id);\n    L<<Logger::Error<<\"Transaction started for '\"<<domain<<\"'\"<<endl;\n\n    // update the presigned flag and NSEC3PARAM\n    if (isDnssecZone) {\n      // update presigned if there was a change\n      if (isPresigned && !hadPresigned) {\n        // zone is now presigned\n        dk.setPresigned(domain);\n      } else if (hadPresigned && !isPresigned) {\n        // zone is no longer presigned\n        dk.unsetPresigned(domain);\n      }\n      // update NSEC3PARAM\n      if (isNSEC3) {\n        // zone is NSEC3, only update if there was a change\n        if (!hadNSEC3 || (hadNarrow  != isNarrow) ||\n            (ns3pr.d_algorithm != hadNs3pr.d_algorithm) ||\n            (ns3pr.d_flags != hadNs3pr.d_flags) ||\n            (ns3pr.d_iterations != hadNs3pr.d_iterations) ||\n            (ns3pr.d_salt != hadNs3pr.d_salt)) {\n          dk.setNSEC3PARAM(domain, ns3pr, isNarrow);\n        }\n      } else if (hadNSEC3 ) {\n         // zone is no longer NSEC3\n         dk.unsetNSEC3PARAM(domain);\n      }\n    } else if (hadDnssecZone) {\n      // zone is no longer signed\n      if (hadPresigned) {\n        // remove presigned\n        dk.unsetPresigned(domain);\n      }\n      if (hadNSEC3) {\n        // unset NSEC3PARAM\n        dk.unsetNSEC3PARAM(domain);\n      }\n    }\n\n    bool doent=true;\n    uint32_t maxent = ::arg().asNum(\"max-ent-entries\");\n    string ordername, shorter;\n    set<string> rrterm;\n    map<string,bool> nonterm;\n\n\n    BOOST_FOREACH(DNSResourceRecord& rr, rrs) {\n\n      if(!isPresigned) {\n        if (rr.qtype.getCode() == QType::RRSIG)\n          continue;\n        if(isDnssecZone && rr.qtype.getCode() == QType::DNSKEY && !::arg().mustDo(\"direct-dnskey\"))\n          continue;\n      }\n\n      // Figure out auth and ents\n      rr.auth=true;\n      shorter=rr.qname;\n      rrterm.clear();\n      do {\n        if(doent) {\n          if (!qnames.count(shorter))\n            rrterm.insert(shorter);\n        }\n        if(nsset.count(shorter) && rr.qtype.getCode() != QType::DS)\n          rr.auth=false;\n\n        if (pdns_iequals(shorter, domain)) // stop at apex\n          break;\n      }while(chopOff(shorter));\n\n      // Insert ents\n      if(doent && !rrterm.empty()) {\n        bool auth;\n        if (!rr.auth && rr.qtype.getCode() == QType::NS) {\n          if (isNSEC3)\n            ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname));\n          auth=(!isNSEC3 || !optOutFlag || secured.count(ordername));\n        } else\n          auth=rr.auth;\n\n        BOOST_FOREACH(const string nt, rrterm){\n          if (!nonterm.count(nt))\n              nonterm.insert(pair<string, bool>(nt, auth));\n            else if (auth)\n              nonterm[nt]=true;\n        }\n\n        if(nonterm.size() > maxent) {\n          L<<Logger::Error<<\"AXFR zone \"<<domain<<\" has too many empty non terminals.\"<<endl;\n          nonterm.clear();\n          doent=false;\n        }\n      }\n\n      // RRSIG is always auth, even inside a delegation\n      if (rr.qtype.getCode() == QType::RRSIG)\n        rr.auth=true;\n\n      // Add ordername and insert record\n      if (isDnssecZone && rr.qtype.getCode() != QType::RRSIG) {\n        if (isNSEC3) {\n          // NSEC3\n          ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname));\n          if(!isNarrow && (rr.auth || (rr.qtype.getCode() == QType::NS && (!optOutFlag || secured.count(ordername))))) {\n            di.backend->feedRecord(rr, &ordername);\n          } else\n            di.backend->feedRecord(rr);\n        } else {\n          // NSEC\n          if (rr.auth || rr.qtype.getCode() == QType::NS) {\n            ordername=toLower(labelReverse(makeRelative(rr.qname, domain)));\n            di.backend->feedRecord(rr, &ordername);\n          } else\n            di.backend->feedRecord(rr);\n        }\n      } else\n        di.backend->feedRecord(rr);\n    }\n\n    // Insert empty non-terminals\n    if(doent && !nonterm.empty()) {\n      if (isNSEC3) {\n        di.backend->feedEnts3(domain_id, domain, nonterm, ns3pr.d_iterations, ns3pr.d_salt, isNarrow);\n      } else\n        di.backend->feedEnts(domain_id, nonterm);\n    }\n\n    di.backend->commitTransaction();\n    transaction = false;\n    di.backend->setFresh(domain_id);\n    PC.purge(domain+\"$\");\n\n\n    L<<Logger::Error<<\"AXFR done for '\"<<domain<<\"', zone committed with serial number \"<<soa_serial<<endl;\n    if(::arg().mustDo(\"slave-renotify\"))\n      notifyDomain(domain);\n  }\n  catch(DBException &re) {\n    L<<Logger::Error<<\"Unable to feed record during incoming AXFR of '\"+domain+\"': \"<<re.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(MOADNSException &re) {\n    L<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+domain+\"' (MOADNSException): \"<<re.what()<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(std::exception &re) {\n    L<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+domain+\"' (std::exception): \"<<re.what()<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(ResolverException &re) {\n    L<<Logger::Error<<\"Unable to AXFR zone '\"+domain+\"' from remote '\"<<remote<<\"' (resolver): \"<<re.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(PDNSException &ae) {\n    L<<Logger::Error<<\"Unable to AXFR zone '\"+domain+\"' from remote '\"<<remote<<\"' (PDNSException): \"<<ae.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n}",
  "abstract_func": "void CommunicatorClass::suck(const string &VAR_0,const string &VAR_1)\n{\n  VAR_2<<Logger::Error<<\"Initiating transfer of '\"<<VAR_0<<\"' from remote '\"<<VAR_1<<\"'\"<<VAR_3;\n  UeberBackend VAR_4; /* COMMENT_0 */\n\n  DomainInfo VAR_5;\n  VAR_5.backend=0;\n  bool VAR_6=false;\n  try {\n    DNSSECKeeper VAR_7 (&VAR_4); /* COMMENT_1 */\n\n    if(!VAR_4.getDomainInfo(VAR_0, VAR_5) || !VAR_5.backend) { /* COMMENT_2 */\n      VAR_2<<Logger::Error<<\"Can't determine backend for domain '\"<<VAR_0<<\"'\"<<VAR_3;\n      return;\n    }\n    uint32_t VAR_8=VAR_5.id;\n\n\n    string VAR_9, VAR_10, VAR_11;\n    if(VAR_7.getTSIGForAccess(VAR_0, VAR_1, &VAR_9)) {\n      string VAR_12;\n      if(VAR_4.getTSIGKey(VAR_9, &VAR_10, &VAR_12)) {\n        B64Decode(VAR_12, VAR_11);\n      } else {\n        VAR_2<<Logger::Error<<\"TSIG key '\"<<VAR_9<<\"' for domain '\"<<VAR_0<<\"' not found\"<<VAR_3;\n        return;\n      }\n    }\n\n\n    scoped_ptr<AuthLua> VAR_13;\n    vector<string> VAR_14;\n    if(VAR_4.getDomainMetadata(VAR_0, \"LUA-AXFR-SCRIPT\", VAR_14) && !VAR_14.empty()) {\n      try {\n        VAR_13.reset(new AuthLua(VAR_14[0]));\n        VAR_2<<Logger::Info<<\"Loaded Lua script '\"<<VAR_14[0]<<\"' to edit the incoming AXFR of '\"<<VAR_0<<\"'\"<<VAR_3;\n      }\n      catch(std::exception& VAR_15) {\n        VAR_2<<Logger::Error<<\"Failed to load Lua editing script '\"<<VAR_14[0]<<\"' for incoming AXFR of '\"<<VAR_0<<\"': \"<<VAR_15.what()<<VAR_3;\n        return;\n      }\n    }\n\n\n    vector<string> VAR_16;\n    ComboAddress VAR_17;\n    if(VAR_4.getDomainMetadata(VAR_0, \"AXFR-SOURCE\", VAR_16) && !VAR_16.empty()) {\n      try {\n        VAR_17 = ComboAddress(VAR_16[0]);\n        VAR_2<<Logger::Info<<\"AXFR source for domain '\"<<VAR_0<<\"' set to \"<<VAR_16[0]<<VAR_3;\n      }\n      catch(std::exception& VAR_15) {\n        VAR_2<<Logger::Error<<\"Failed to load AXFR source '\"<<VAR_16[0]<<\"' for incoming AXFR of '\"<<VAR_0<<\"': \"<<VAR_15.what()<<VAR_3;\n        return;\n      }\n    } else {\n      VAR_17.sin4.sin_family = 0;\n    }\n\n\n    bool VAR_18 = false;\n    bool VAR_19 = false;\n    bool VAR_20 = false;\n    NSEC3PARAMRecordContent VAR_21, VAR_22;\n    bool VAR_23, VAR_24=false;\n\n    if(VAR_7.isSecuredZone(VAR_0)) {\n      VAR_18=true;\n      VAR_19=VAR_7.isPresigned(VAR_0);\n      if (VAR_7.getNSEC3PARAM(VAR_0, &VAR_21, &VAR_23)) {\n        VAR_20 = true;\n        VAR_22 = VAR_21;\n        VAR_24 = VAR_23;\n      }\n    }\n\n\n    bool VAR_25 = false;\n    bool VAR_26 = false;\n    bool VAR_27 = false;\n    bool VAR_28 = false;\n\n    bool VAR_29=true;\n    bool VAR_30=true;\n    unsigned int VAR_31 = 0;\n    set<string> VAR_32, VAR_33, VAR_34;\n    vector<DNSResourceRecord> VAR_35;\n\n    ComboAddress VAR_36(VAR_1, 53);\n    AXFRRetriever VAR_37(VAR_36, VAR_0.c_str(), VAR_9, VAR_10, VAR_11, (VAR_17.sin4.sin_family == 0) ? NULL : &VAR_17, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n    Resolver::res_t VAR_38;\n    while(VAR_37.getChunk(VAR_38)) {\n      if(VAR_29) {\n        VAR_2<<Logger::Error<<\"AXFR started for '\"<<VAR_0<<\"'\"<<VAR_3;\n        VAR_29=false;\n      }\n\n      for(Resolver::res_t::iterator VAR_39=VAR_38.begin();VAR_39!=VAR_38.end();++VAR_39) {\n        if(VAR_39->qtype.getCode() == QType::OPT || VAR_39->qtype.getCode() == QType::TSIG) /* COMMENT_3 */\n          continue;\n\n        if(!endsOn(VAR_39->qname, VAR_0)) {\n          VAR_2<<Logger::Error<<\"Remote \"<<VAR_1<<\" tried to sneak in out-of-zone data '\"<<VAR_39->qname<<\"'|\"<<VAR_39->qtype.getName()<<\" during AXFR of zone '\"<<VAR_0<<\"', ignoring\"<<VAR_3;\n          continue;\n        }\n\n        vector<DNSResourceRecord> VAR_40;\n        if(!VAR_13 || !VAR_13->axfrfilter(VAR_36, VAR_0, *VAR_39, VAR_40)) {\n          VAR_40.push_back(*VAR_39);\n        }\n\n        BOOST_FOREACH(DNSResourceRecord& VAR_41, out) {\n          switch(VAR_41.qtype.getCode()) {\n            case QType::NSEC3PARAM: {\n              VAR_21 = NSEC3PARAMRecordContent(VAR_41.content);\n              VAR_25 = VAR_27 = true;\n              VAR_23 = false;\n              continue;\n            }\n            case QType::NSEC3: {\n              NSEC3RecordContent VAR_42(VAR_41.content);\n              if (VAR_30) {\n                VAR_25 = VAR_26 = true;\n                VAR_30 = false;\n              } else if (VAR_28 != (VAR_42.d_flags & 1))\n                throw PDNSException(\"Zones with a mixture of Opt-Out NSEC3 RRs and non-Opt-Out NSEC3 RRs are not supported.\");\n              VAR_28 = VAR_42.d_flags & 1;\n              if (VAR_42.d_set.count(QType::NS) && !pdns_iequals(VAR_41.qname, VAR_0))\n                VAR_34.insert(toLower(makeRelative(VAR_41.qname, VAR_0)));\n              continue;\n            }\n            case QType::NSEC: {\n              VAR_25 = VAR_26 = true;\n              continue;\n            }\n            case QType::SOA: {\n              if(VAR_31 != 0)\n                continue; /* COMMENT_4 */\n              SOAData VAR_43;\n              fillSOAData(VAR_41.content,VAR_43);\n              VAR_31 = VAR_43.serial;\n              break;\n            }\n            case QType::NS: {\n              if(!pdns_iequals(VAR_41.qname, VAR_0))\n                VAR_32.insert(VAR_41.qname);\n              break;\n            }\n            default:\n              break;\n          }\n\n          VAR_33.insert(VAR_41.qname);\n\n          VAR_41.domain_id=VAR_8;\n          VAR_35.push_back(VAR_41);\n        }\n      }\n    }\n\n    if(VAR_27) {\n      VAR_21.d_flags = VAR_28 ? 1 : 0;\n    }\n\n\n    if(!VAR_26) {\n      DNSSECKeeper::keyset_t VAR_44 = VAR_7.getKeys(VAR_0);\n      if(!VAR_44.empty()) {\n        VAR_25 = true;\n        VAR_27 = VAR_20;\n        VAR_21 = VAR_22;\n        VAR_28 = (VAR_22.d_flags & 1);\n        VAR_23 = VAR_24;\n      }\n    }\n\n\n    if(VAR_25) {\n      if(!VAR_27)\n        VAR_2<<Logger::Info<<\"Adding NSEC ordering information\"<<VAR_3;\n      else if(!VAR_23)\n        VAR_2<<Logger::Info<<\"Adding NSEC3 hashed ordering information for '\"<<VAR_0<<\"'\"<<VAR_3;\n      else\n        VAR_2<<Logger::Info<<\"Erasing NSEC3 ordering since we are narrow, only setting 'auth' fields\"<<VAR_3;\n    }\n\n\n    VAR_6=VAR_5.backend->startTransaction(VAR_0, VAR_8);\n    VAR_2<<Logger::Error<<\"Transaction started for '\"<<VAR_0<<\"'\"<<VAR_3;\n\n    /* COMMENT_5 */\n    if (VAR_25) {\n      /* COMMENT_6 */\n      if (VAR_26 && !VAR_19) {\n        /* COMMENT_7 */\n        VAR_7.setPresigned(VAR_0);\n      } else if (VAR_19 && !VAR_26) {\n        /* COMMENT_8 */\n        VAR_7.unsetPresigned(VAR_0);\n      }\n      /* COMMENT_9 */\n      if (VAR_27) {\n        /* COMMENT_10 */\n        if (!VAR_20 || (VAR_24  != VAR_23) ||\n            (VAR_21.d_algorithm != VAR_22.d_algorithm) ||\n            (VAR_21.d_flags != VAR_22.d_flags) ||\n            (VAR_21.d_iterations != VAR_22.d_iterations) ||\n            (VAR_21.d_salt != VAR_22.d_salt)) {\n          VAR_7.setNSEC3PARAM(VAR_0, VAR_21, VAR_23);\n        }\n      } else if (VAR_20 ) {\n         /* COMMENT_11 */\n         VAR_7.unsetNSEC3PARAM(VAR_0);\n      }\n    } else if (VAR_18) {\n      /* COMMENT_12 */\n      if (VAR_19) {\n        /* COMMENT_13 */\n        VAR_7.unsetPresigned(VAR_0);\n      }\n      if (VAR_20) {\n        /* COMMENT_14 */\n        VAR_7.unsetNSEC3PARAM(VAR_0);\n      }\n    }\n\n    bool VAR_45=true;\n    uint32_t VAR_46 = ::arg().asNum(\"max-ent-entries\");\n    string VAR_47, VAR_48;\n    set<string> VAR_49;\n    map<string,bool> VAR_50;\n\n\n    BOOST_FOREACH(DNSResourceRecord& VAR_41, rrs) {\n\n      if(!VAR_26) {\n        if (VAR_41.qtype.getCode() == QType::RRSIG)\n          continue;\n        if(VAR_25 && VAR_41.qtype.getCode() == QType::DNSKEY && !::arg().mustDo(\"direct-dnskey\"))\n          continue;\n      }\n\n      /* COMMENT_15 */\n      VAR_41.auth=true;\n      VAR_48=VAR_41.qname;\n      VAR_49.clear();\n      do {\n        if(VAR_45) {\n          if (!VAR_33.count(VAR_48))\n            VAR_49.insert(VAR_48);\n        }\n        if(VAR_32.count(VAR_48) && VAR_41.qtype.getCode() != QType::DS)\n          VAR_41.auth=false;\n\n        if (pdns_iequals(VAR_48, VAR_0)) /* COMMENT_16 */\n          break;\n      }while(chopOff(VAR_48));\n\n      /* COMMENT_17 */\n      if(VAR_45 && !VAR_49.empty()) {\n        bool VAR_51;\n        if (!VAR_41.auth && VAR_41.qtype.getCode() == QType::NS) {\n          if (VAR_27)\n            VAR_47=toBase32Hex(hashQNameWithSalt(VAR_21.d_iterations, VAR_21.d_salt, VAR_41.qname));\n          VAR_51=(!VAR_27 || !VAR_28 || VAR_34.count(VAR_47));\n        } else\n          VAR_51=VAR_41.auth;\n\n        BOOST_FOREACH(const string VAR_52, rrterm){\n          if (!VAR_50.count(VAR_52))\n              VAR_50.insert(VAR_53<string, bool>(VAR_52, VAR_51));\n            else if (VAR_51)\n              VAR_50[VAR_52]=true;\n        }\n\n        if(VAR_50.size() > VAR_46) {\n          VAR_2<<Logger::Error<<\"AXFR zone \"<<VAR_0<<\" has too many empty non terminals.\"<<VAR_3;\n          VAR_50.clear();\n          VAR_45=false;\n        }\n      }\n\n      /* COMMENT_18 */\n      if (VAR_41.qtype.getCode() == QType::RRSIG)\n        VAR_41.auth=true;\n\n      /* COMMENT_19 */\n      if (VAR_25 && VAR_41.qtype.getCode() != QType::RRSIG) {\n        if (VAR_27) {\n          /* COMMENT_20 */\n          VAR_47=toBase32Hex(hashQNameWithSalt(VAR_21.d_iterations, VAR_21.d_salt, VAR_41.qname));\n          if(!VAR_23 && (VAR_41.auth || (VAR_41.qtype.getCode() == QType::NS && (!VAR_28 || VAR_34.count(VAR_47))))) {\n            VAR_5.backend->feedRecord(VAR_41, &VAR_47);\n          } else\n            VAR_5.backend->feedRecord(VAR_41);\n        } else {\n          /* COMMENT_21 */\n          if (VAR_41.auth || VAR_41.qtype.getCode() == QType::NS) {\n            VAR_47=toLower(labelReverse(makeRelative(VAR_41.qname, VAR_0)));\n            VAR_5.backend->feedRecord(VAR_41, &VAR_47);\n          } else\n            VAR_5.backend->feedRecord(VAR_41);\n        }\n      } else\n        VAR_5.backend->feedRecord(VAR_41);\n    }\n\n    /* COMMENT_22 */\n    if(VAR_45 && !VAR_50.empty()) {\n      if (VAR_27) {\n        VAR_5.backend->feedEnts3(VAR_8, VAR_0, VAR_50, VAR_21.d_iterations, VAR_21.d_salt, VAR_23);\n      } else\n        VAR_5.backend->feedEnts(VAR_8, VAR_50);\n    }\n\n    VAR_5.backend->commitTransaction();\n    VAR_6 = false;\n    VAR_5.backend->setFresh(VAR_8);\n    VAR_54.purge(VAR_0+\"$\");\n\n\n    VAR_2<<Logger::Error<<\"AXFR done for '\"<<VAR_0<<\"', zone committed with serial number \"<<VAR_31<<VAR_3;\n    if(::arg().mustDo(\"slave-renotify\"))\n      notifyDomain(VAR_0);\n  }\n  catch(DBException &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to feed record during incoming AXFR of '\"+VAR_0+\"': \"<<VAR_55.reason<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(MOADNSException &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+VAR_0+\"' (MOADNSException): \"<<VAR_55.what()<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(std::exception &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+VAR_0+\"' (std::exception): \"<<VAR_55.what()<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(ResolverException &VAR_55) {\n    VAR_2<<Logger::Error<<\"Unable to AXFR zone '\"+VAR_0+\"' from remote '\"<<VAR_1<<\"' (resolver): \"<<VAR_55.reason<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n  catch(PDNSException &VAR_56) {\n    VAR_2<<Logger::Error<<\"Unable to AXFR zone '\"+VAR_0+\"' from remote '\"<<VAR_1<<\"' (PDNSException): \"<<VAR_56.reason<<VAR_3;\n    if(VAR_5.backend && VAR_6) {\n      VAR_2<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<VAR_0<<\"' AXFR\"<<VAR_3;\n      VAR_5.backend->abortTransaction();\n    }\n  }\n}",
  "func_graph_path": "PowerDNS/pdns/a014f4c224a7b21f1c648257d1fd1128413129aa/slavecommunicator.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -87,7 +87,7 @@\n     vector<DNSResourceRecord> rrs;\n \n     ComboAddress raddr(remote, 53);\n-    AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr);\n+    AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n     Resolver::res_t recs;\n     while(retriever.getChunk(recs)) {\n       if(first) {",
  "diff_line_info": {
    "deleted_lines": [
      "    AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr);"
    ],
    "added_lines": [
      "    AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4134",
  "description": {
    "pr_info": {
      "title": "Add limits to the size of received AXFR, in megabytes",
      "number": 4134
    },
    "comment": [
      "This prevents resource exhaustion in case the master is sending a\nvery large amount of data in an update.\n",
      "Fixes #4128 for 3.4.x.\n",
      "LGTM. pdns.xml edit is useless, 3.x docs are built from markdown on the docs-3X branch.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95\n\nThe analysis indicates that the patch addresses a security issue by preventing resource exhaustion through size limits, aligning with clear and consistent evidence of a security fix."
}