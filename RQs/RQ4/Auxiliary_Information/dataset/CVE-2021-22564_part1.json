{
  "cve_id": "CVE-2021-22564",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libjxl",
  "commit_msg": "Fix out of bounds copy in LoadBorders()\n\nWhen processing groups out of order with an image where the last group\nsize  is smaller than the needed border it was possible to attempt to\nload the right or bottom border from the next group when already\nprocessing the rightmost or bottom group respectively. This situation\nwas causing an out-of-bounds copy on saved Image3F buffer in release\nmode (or hitting a JXL_DASSERT in debug mode).\n\nThe order in which the groups are processed depends on many factors,\nincluding the order in which the threads are scheduled when using\nmultiple threads, and potentially the order of the groups in the file\n(not checked).\n\nAdded a test to force the out-of-order situation in a simulated parallel\nrunner that forces a random order on the tasks. The new test triggers\nthe assert in debug mode, which is now fixed.\n\nFixes #708.",
  "commit_hash": "e05e801278ee1205848e66406a0821f771d47172",
  "git_url": "https://github.com/libjxl/libjxl/commit/e05e801278ee1205848e66406a0821f771d47172",
  "file_path": "lib/jxl/dec_cache.cc",
  "func_name": "LoadBorders",
  "func_before": "void LoadBorders(const Rect& block_rect, size_t hshift, size_t vshift,\n                 const FrameDimensions& frame_dim, size_t padding,\n                 const ImageF& border_storage_h, const ImageF& border_storage_v,\n                 const Rect& r, ImageF* plane_out) {\n  constexpr size_t kGroupDataXBorder = PassesDecoderState::kGroupDataXBorder;\n  constexpr size_t kGroupDataYBorder = PassesDecoderState::kGroupDataYBorder;\n  size_t x0 = DivCeil(block_rect.x0() * kBlockDim, 1 << hshift);\n  size_t x1 =\n      DivCeil((block_rect.x0() + block_rect.xsize()) * kBlockDim, 1 << hshift);\n  size_t y0 = DivCeil(block_rect.y0() * kBlockDim, 1 << vshift);\n  size_t y1 =\n      DivCeil((block_rect.y0() + block_rect.ysize()) * kBlockDim, 1 << vshift);\n  size_t gy = block_rect.y0() / kGroupDimInBlocks;\n  size_t gx = block_rect.x0() / kGroupDimInBlocks;\n  size_t borderx = GroupBorderAssigner::PaddingX(padding);\n  size_t bordery = padding;\n  size_t borderx_write = padding + borderx;\n  size_t bordery_write = padding + bordery;\n  // Limits of the area to copy from, in image coordinates.\n  JXL_DASSERT(r.x0() == 0 || r.x0() >= borderx);\n  size_t x0src = DivCeil(r.x0() == 0 ? r.x0() : r.x0() - borderx, 1 << hshift);\n  size_t x1src =\n      DivCeil(r.x0() + r.xsize() +\n                  (r.x0() + r.xsize() == frame_dim.xsize_padded ? 0 : borderx),\n              1 << hshift);\n  JXL_DASSERT(r.y0() == 0 || r.y0() >= bordery);\n  size_t y0src = DivCeil(r.y0() == 0 ? r.y0() : r.y0() - bordery, 1 << vshift);\n  size_t y1src =\n      DivCeil(r.y0() + r.ysize() +\n                  (r.y0() + r.ysize() == frame_dim.ysize_padded ? 0 : bordery),\n              1 << vshift);\n  // Copy other groups' borders from the border storage.\n  if (y0src < y0) {\n    CopyImageTo(\n        Rect(x0src, (gy * 2 - 1) * bordery_write, x1src - x0src, bordery_write),\n        border_storage_h,\n        Rect(kGroupDataXBorder + x0src - x0, kGroupDataYBorder - bordery_write,\n             x1src - x0src, bordery_write),\n        plane_out);\n  }\n  if (y1src > y1) {\n    CopyImageTo(\n        Rect(x0src, (gy * 2 + 2) * bordery_write, x1src - x0src, bordery_write),\n        border_storage_h,\n        Rect(kGroupDataXBorder + x0src - x0, kGroupDataYBorder + y1 - y0,\n             x1src - x0src, bordery_write),\n        plane_out);\n  }\n  if (x0src < x0) {\n    CopyImageTo(\n        Rect((gx * 2 - 1) * borderx_write, y0src, borderx_write, y1src - y0src),\n        border_storage_v,\n        Rect(kGroupDataXBorder - borderx_write, kGroupDataYBorder + y0src - y0,\n             borderx_write, y1src - y0src),\n        plane_out);\n  }\n  if (x1src > x1) {\n    CopyImageTo(\n        Rect((gx * 2 + 2) * borderx_write, y0src, borderx_write, y1src - y0src),\n        border_storage_v,\n        Rect(kGroupDataXBorder + x1 - x0, kGroupDataYBorder + y0src - y0,\n             borderx_write, y1src - y0src),\n        plane_out);\n  }\n}",
  "abstract_func_before": "void LoadBorders(const Rect& VAR_0, size_t VAR_1, size_t VAR_2,\n                 const FrameDimensions& VAR_3, size_t VAR_4,\n                 const ImageF& VAR_5, const ImageF& VAR_6,\n                 const Rect& VAR_7, ImageF* VAR_8) {\n  constexpr size_t VAR_9 = PassesDecoderState::kGroupDataXBorder;\n  constexpr size_t VAR_10 = PassesDecoderState::kGroupDataYBorder;\n  size_t VAR_11 = DivCeil(VAR_0.x0() * VAR_12, 1 << VAR_1);\n  size_t VAR_13 =\n      DivCeil((VAR_0.x0() + VAR_0.xsize()) * VAR_12, 1 << VAR_1);\n  size_t VAR_14 = DivCeil(VAR_0.y0() * VAR_12, 1 << VAR_2);\n  size_t VAR_15 =\n      DivCeil((VAR_0.y0() + VAR_0.ysize()) * VAR_12, 1 << VAR_2);\n  size_t VAR_16 = VAR_0.y0() / VAR_17;\n  size_t VAR_18 = VAR_0.x0() / VAR_17;\n  size_t VAR_19 = GroupBorderAssigner::PaddingX(VAR_4);\n  size_t VAR_20 = VAR_4;\n  size_t VAR_21 = VAR_4 + VAR_19;\n  size_t VAR_22 = VAR_4 + VAR_20;\n  /* COMMENT_0 */\n  JXL_DASSERT(VAR_7.x0() == 0 || VAR_7.x0() >= VAR_19);\n  size_t VAR_23 = DivCeil(VAR_7.x0() == 0 ? VAR_7.x0() : VAR_7.x0() - VAR_19, 1 << VAR_1);\n  size_t VAR_24 =\n      DivCeil(VAR_7.x0() + VAR_7.xsize() +\n                  (VAR_7.x0() + VAR_7.xsize() == VAR_3.xsize_padded ? 0 : VAR_19),\n              1 << VAR_1);\n  JXL_DASSERT(VAR_7.y0() == 0 || VAR_7.y0() >= VAR_20);\n  size_t VAR_25 = DivCeil(VAR_7.y0() == 0 ? VAR_7.y0() : VAR_7.y0() - VAR_20, 1 << VAR_2);\n  size_t VAR_26 =\n      DivCeil(VAR_7.y0() + VAR_7.ysize() +\n                  (VAR_7.y0() + VAR_7.ysize() == VAR_3.ysize_padded ? 0 : VAR_20),\n              1 << VAR_2);\n  /* COMMENT_1 */\n  if (VAR_25 < VAR_14) {\n    CopyImageTo(\n        Rect(VAR_23, (VAR_16 * 2 - 1) * VAR_22, VAR_24 - VAR_23, VAR_22),\n        VAR_5,\n        Rect(VAR_9 + VAR_23 - VAR_11, VAR_10 - VAR_22,\n             VAR_24 - VAR_23, VAR_22),\n        VAR_8);\n  }\n  if (VAR_26 > VAR_15) {\n    CopyImageTo(\n        Rect(VAR_23, (VAR_16 * 2 + 2) * VAR_22, VAR_24 - VAR_23, VAR_22),\n        VAR_5,\n        Rect(VAR_9 + VAR_23 - VAR_11, VAR_10 + VAR_15 - VAR_14,\n             VAR_24 - VAR_23, VAR_22),\n        VAR_8);\n  }\n  if (VAR_23 < VAR_11) {\n    CopyImageTo(\n        Rect((VAR_18 * 2 - 1) * VAR_21, VAR_25, VAR_21, VAR_26 - VAR_25),\n        VAR_6,\n        Rect(VAR_9 - VAR_21, VAR_10 + VAR_25 - VAR_14,\n             VAR_21, VAR_26 - VAR_25),\n        VAR_8);\n  }\n  if (VAR_24 > VAR_13) {\n    CopyImageTo(\n        Rect((VAR_18 * 2 + 2) * VAR_21, VAR_25, VAR_21, VAR_26 - VAR_25),\n        VAR_6,\n        Rect(VAR_9 + VAR_13 - VAR_11, VAR_10 + VAR_25 - VAR_14,\n             VAR_21, VAR_26 - VAR_25),\n        VAR_8);\n  }\n}",
  "func_graph_path_before": "libjxl/e05e801278ee1205848e66406a0821f771d47172/dec_cache.cc/vul/before/0.json",
  "func": "void LoadBorders(const Rect& block_rect, size_t hshift, size_t vshift,\n                 const FrameDimensions& frame_dim, size_t padding,\n                 const ImageF& border_storage_h, const ImageF& border_storage_v,\n                 const Rect& r, ImageF* plane_out) {\n  constexpr size_t kGroupDataXBorder = PassesDecoderState::kGroupDataXBorder;\n  constexpr size_t kGroupDataYBorder = PassesDecoderState::kGroupDataYBorder;\n  size_t x0 = DivCeil(block_rect.x0() * kBlockDim, 1 << hshift);\n  size_t x1 =\n      DivCeil((block_rect.x0() + block_rect.xsize()) * kBlockDim, 1 << hshift);\n  size_t y0 = DivCeil(block_rect.y0() * kBlockDim, 1 << vshift);\n  size_t y1 =\n      DivCeil((block_rect.y0() + block_rect.ysize()) * kBlockDim, 1 << vshift);\n  size_t gy = block_rect.y0() / kGroupDimInBlocks;\n  size_t gx = block_rect.x0() / kGroupDimInBlocks;\n  size_t borderx = GroupBorderAssigner::PaddingX(padding);\n  size_t bordery = padding;\n  size_t borderx_write = padding + borderx;\n  size_t bordery_write = padding + bordery;\n  // Limits of the area to copy from, in image coordinates.\n  JXL_DASSERT(r.x0() == 0 || r.x0() >= borderx);\n  size_t x0src = DivCeil(r.x0() == 0 ? r.x0() : r.x0() - borderx, 1 << hshift);\n  // r may be such that r.x1 (namely x0() + xsize()) is within borderx of the\n  // right side of the image, so we use min() here.\n  size_t x1src =\n      DivCeil(std::min(r.x0() + r.xsize() + borderx, frame_dim.xsize_padded),\n              1 << hshift);\n  JXL_DASSERT(r.y0() == 0 || r.y0() >= bordery);\n  size_t y0src = DivCeil(r.y0() == 0 ? r.y0() : r.y0() - bordery, 1 << vshift);\n  // Similar to x1, y1 might be closer than bordery from the bottom.\n  size_t y1src =\n      DivCeil(std::min(r.y0() + r.ysize() + bordery, frame_dim.ysize_padded),\n              1 << vshift);\n  // Copy other groups' borders from the border storage.\n  if (y0src < y0) {\n    JXL_DASSERT(gy > 0);\n    CopyImageTo(\n        Rect(x0src, (gy * 2 - 1) * bordery_write, x1src - x0src, bordery_write),\n        border_storage_h,\n        Rect(kGroupDataXBorder + x0src - x0, kGroupDataYBorder - bordery_write,\n             x1src - x0src, bordery_write),\n        plane_out);\n  }\n  if (y1src > y1) {\n    // When copying the bottom border we must not be on the bottom groups.\n    JXL_DASSERT(gy + 1 < frame_dim.ysize_groups);\n    CopyImageTo(\n        Rect(x0src, (gy * 2 + 2) * bordery_write, x1src - x0src, bordery_write),\n        border_storage_h,\n        Rect(kGroupDataXBorder + x0src - x0, kGroupDataYBorder + y1 - y0,\n             x1src - x0src, bordery_write),\n        plane_out);\n  }\n  if (x0src < x0) {\n    JXL_DASSERT(gx > 0);\n    CopyImageTo(\n        Rect((gx * 2 - 1) * borderx_write, y0src, borderx_write, y1src - y0src),\n        border_storage_v,\n        Rect(kGroupDataXBorder - borderx_write, kGroupDataYBorder + y0src - y0,\n             borderx_write, y1src - y0src),\n        plane_out);\n  }\n  if (x1src > x1) {\n    // When copying the right border we must not be on the rightmost groups.\n    JXL_DASSERT(gx + 1 < frame_dim.xsize_groups);\n    CopyImageTo(\n        Rect((gx * 2 + 2) * borderx_write, y0src, borderx_write, y1src - y0src),\n        border_storage_v,\n        Rect(kGroupDataXBorder + x1 - x0, kGroupDataYBorder + y0src - y0,\n             borderx_write, y1src - y0src),\n        plane_out);\n  }\n}",
  "abstract_func": "void LoadBorders(const Rect& VAR_0, size_t VAR_1, size_t VAR_2,\n                 const FrameDimensions& VAR_3, size_t VAR_4,\n                 const ImageF& VAR_5, const ImageF& VAR_6,\n                 const Rect& VAR_7, ImageF* VAR_8) {\n  constexpr size_t VAR_9 = PassesDecoderState::kGroupDataXBorder;\n  constexpr size_t VAR_10 = PassesDecoderState::kGroupDataYBorder;\n  size_t VAR_11 = DivCeil(VAR_0.x0() * VAR_12, 1 << VAR_1);\n  size_t VAR_13 =\n      DivCeil((VAR_0.x0() + VAR_0.xsize()) * VAR_12, 1 << VAR_1);\n  size_t VAR_14 = DivCeil(VAR_0.y0() * VAR_12, 1 << VAR_2);\n  size_t VAR_15 =\n      DivCeil((VAR_0.y0() + VAR_0.ysize()) * VAR_12, 1 << VAR_2);\n  size_t VAR_16 = VAR_0.y0() / VAR_17;\n  size_t VAR_18 = VAR_0.x0() / VAR_17;\n  size_t VAR_19 = GroupBorderAssigner::PaddingX(VAR_4);\n  size_t VAR_20 = VAR_4;\n  size_t VAR_21 = VAR_4 + VAR_19;\n  size_t VAR_22 = VAR_4 + VAR_20;\n  /* COMMENT_0 */\n  JXL_DASSERT(VAR_7.x0() == 0 || VAR_7.x0() >= VAR_19);\n  size_t VAR_23 = DivCeil(VAR_7.x0() == 0 ? VAR_7.x0() : VAR_7.x0() - VAR_19, 1 << VAR_1);\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  size_t VAR_24 =\n      DivCeil(std::min(VAR_7.x0() + VAR_7.xsize() + VAR_19, VAR_3.xsize_padded),\n              1 << VAR_1);\n  JXL_DASSERT(VAR_7.y0() == 0 || VAR_7.y0() >= VAR_20);\n  size_t VAR_25 = DivCeil(VAR_7.y0() == 0 ? VAR_7.y0() : VAR_7.y0() - VAR_20, 1 << VAR_2);\n  /* COMMENT_3 */\n  size_t VAR_26 =\n      DivCeil(std::min(VAR_7.y0() + VAR_7.ysize() + VAR_20, VAR_3.ysize_padded),\n              1 << VAR_2);\n  /* COMMENT_4 */\n  if (VAR_25 < VAR_14) {\n    JXL_DASSERT(VAR_16 > 0);\n    CopyImageTo(\n        Rect(VAR_23, (VAR_16 * 2 - 1) * VAR_22, VAR_24 - VAR_23, VAR_22),\n        VAR_5,\n        Rect(VAR_9 + VAR_23 - VAR_11, VAR_10 - VAR_22,\n             VAR_24 - VAR_23, VAR_22),\n        VAR_8);\n  }\n  if (VAR_26 > VAR_15) {\n    /* COMMENT_5 */\n    JXL_DASSERT(VAR_16 + 1 < VAR_3.ysize_groups);\n    CopyImageTo(\n        Rect(VAR_23, (VAR_16 * 2 + 2) * VAR_22, VAR_24 - VAR_23, VAR_22),\n        VAR_5,\n        Rect(VAR_9 + VAR_23 - VAR_11, VAR_10 + VAR_15 - VAR_14,\n             VAR_24 - VAR_23, VAR_22),\n        VAR_8);\n  }\n  if (VAR_23 < VAR_11) {\n    JXL_DASSERT(VAR_18 > 0);\n    CopyImageTo(\n        Rect((VAR_18 * 2 - 1) * VAR_21, VAR_25, VAR_21, VAR_26 - VAR_25),\n        VAR_6,\n        Rect(VAR_9 - VAR_21, VAR_10 + VAR_25 - VAR_14,\n             VAR_21, VAR_26 - VAR_25),\n        VAR_8);\n  }\n  if (VAR_24 > VAR_13) {\n    /* COMMENT_6 */\n    JXL_DASSERT(VAR_18 + 1 < VAR_3.xsize_groups);\n    CopyImageTo(\n        Rect((VAR_18 * 2 + 2) * VAR_21, VAR_25, VAR_21, VAR_26 - VAR_25),\n        VAR_6,\n        Rect(VAR_9 + VAR_13 - VAR_11, VAR_10 + VAR_25 - VAR_14,\n             VAR_21, VAR_26 - VAR_25),\n        VAR_8);\n  }\n}",
  "func_graph_path": "libjxl/e05e801278ee1205848e66406a0821f771d47172/dec_cache.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,18 +19,20 @@\n   // Limits of the area to copy from, in image coordinates.\n   JXL_DASSERT(r.x0() == 0 || r.x0() >= borderx);\n   size_t x0src = DivCeil(r.x0() == 0 ? r.x0() : r.x0() - borderx, 1 << hshift);\n+  // r may be such that r.x1 (namely x0() + xsize()) is within borderx of the\n+  // right side of the image, so we use min() here.\n   size_t x1src =\n-      DivCeil(r.x0() + r.xsize() +\n-                  (r.x0() + r.xsize() == frame_dim.xsize_padded ? 0 : borderx),\n+      DivCeil(std::min(r.x0() + r.xsize() + borderx, frame_dim.xsize_padded),\n               1 << hshift);\n   JXL_DASSERT(r.y0() == 0 || r.y0() >= bordery);\n   size_t y0src = DivCeil(r.y0() == 0 ? r.y0() : r.y0() - bordery, 1 << vshift);\n+  // Similar to x1, y1 might be closer than bordery from the bottom.\n   size_t y1src =\n-      DivCeil(r.y0() + r.ysize() +\n-                  (r.y0() + r.ysize() == frame_dim.ysize_padded ? 0 : bordery),\n+      DivCeil(std::min(r.y0() + r.ysize() + bordery, frame_dim.ysize_padded),\n               1 << vshift);\n   // Copy other groups' borders from the border storage.\n   if (y0src < y0) {\n+    JXL_DASSERT(gy > 0);\n     CopyImageTo(\n         Rect(x0src, (gy * 2 - 1) * bordery_write, x1src - x0src, bordery_write),\n         border_storage_h,\n@@ -39,6 +41,8 @@\n         plane_out);\n   }\n   if (y1src > y1) {\n+    // When copying the bottom border we must not be on the bottom groups.\n+    JXL_DASSERT(gy + 1 < frame_dim.ysize_groups);\n     CopyImageTo(\n         Rect(x0src, (gy * 2 + 2) * bordery_write, x1src - x0src, bordery_write),\n         border_storage_h,\n@@ -47,6 +51,7 @@\n         plane_out);\n   }\n   if (x0src < x0) {\n+    JXL_DASSERT(gx > 0);\n     CopyImageTo(\n         Rect((gx * 2 - 1) * borderx_write, y0src, borderx_write, y1src - y0src),\n         border_storage_v,\n@@ -55,6 +60,8 @@\n         plane_out);\n   }\n   if (x1src > x1) {\n+    // When copying the right border we must not be on the rightmost groups.\n+    JXL_DASSERT(gx + 1 < frame_dim.xsize_groups);\n     CopyImageTo(\n         Rect((gx * 2 + 2) * borderx_write, y0src, borderx_write, y1src - y0src),\n         border_storage_v,",
  "diff_line_info": {
    "deleted_lines": [
      "      DivCeil(r.x0() + r.xsize() +",
      "                  (r.x0() + r.xsize() == frame_dim.xsize_padded ? 0 : borderx),",
      "      DivCeil(r.y0() + r.ysize() +",
      "                  (r.y0() + r.ysize() == frame_dim.ysize_padded ? 0 : bordery),"
    ],
    "added_lines": [
      "  // r may be such that r.x1 (namely x0() + xsize()) is within borderx of the",
      "  // right side of the image, so we use min() here.",
      "      DivCeil(std::min(r.x0() + r.xsize() + borderx, frame_dim.xsize_padded),",
      "  // Similar to x1, y1 might be closer than bordery from the bottom.",
      "      DivCeil(std::min(r.y0() + r.ysize() + bordery, frame_dim.ysize_padded),",
      "    JXL_DASSERT(gy > 0);",
      "    // When copying the bottom border we must not be on the bottom groups.",
      "    JXL_DASSERT(gy + 1 < frame_dim.ysize_groups);",
      "    JXL_DASSERT(gx > 0);",
      "    // When copying the right border we must not be on the rightmost groups.",
      "    JXL_DASSERT(gx + 1 < frame_dim.xsize_groups);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libjxl/libjxl/pull/775",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libjxl/libjxl/pull/775: 403 Client Error: Forbidden for url: https://api.github.com/repos/libjxl/libjxl/pulls/775",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}