{
  "cve_id": "CVE-2021-27186",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "fluent/fluent-bit",
  "commit_msg": "Add additional check returned from flb_malloc\n\nThis PR tries to address the issue raised in 3044 where\nmemory pointer returned from flb_malloc was not checked for NULL.\nCredit to raminfp.\n\nThis PR fixes the 3044.\n\nSigned-off-by: Yong Tang <yong.tang.github@outlook.com>",
  "commit_hash": "a5d1721c8e3e62c30eb05609ece152fa689dbc35",
  "git_url": "https://github.com/fluent/fluent-bit/commit/a5d1721c8e3e62c30eb05609ece152fa689dbc35",
  "file_path": "src/flb_avro.c",
  "func_name": "flb_msgpack_raw_to_avro_sds",
  "func_before": "flb_sds_t flb_msgpack_raw_to_avro_sds(const void *in_buf, size_t in_size, struct flb_avro_fields *ctx)\n{\n    msgpack_unpacked result;\n    msgpack_object *root;\n\n    size_t avro_buffer_size = in_size * 3;\n    char *out_buff = flb_malloc(avro_buffer_size);\n\n    avro_writer_t awriter;\n    flb_debug(\"in flb_msgpack_raw_to_avro_sds\\n\");\n    flb_debug(\"schemaID:%s:\\n\", ctx->schema_id);\n    flb_debug(\"schema string:%s:\\n\", ctx->schema_str);\n\n    size_t schema_json_len = flb_sds_len(ctx->schema_str);\n\n    avro_value_t  aobject;\n\n    assert(in_buf != NULL);\n\n    avro_value_iface_t  *aclass = NULL;\n    avro_schema_t aschema;\n\n    aclass = flb_avro_init(&aobject, (char *)ctx->schema_str, schema_json_len, &aschema);\n\n    if (!aclass) {\n        flb_error(\"Failed init avro:%s:n\", avro_strerror());\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, in_buf, in_size, NULL) != MSGPACK_UNPACK_SUCCESS) {\n        flb_error(\"msgpack_unpack problem\\n\");\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    root = &result.data;\n\n    // create the avro object\n    // then serialize it into a buffer for the downstream\n    flb_debug(\"calling flb_msgpack_to_avro\\n\");\n\n    if (flb_msgpack_to_avro(&aobject, root) != FLB_TRUE) {\n        flb_errno();\n        flb_error(\"Failed msgpack to avro\\n\");\n        msgpack_unpacked_destroy(&result);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    flb_debug(\"before avro_writer_memory\\n\");\n    awriter = avro_writer_memory(out_buff, avro_buffer_size);\n    if (awriter == NULL) {\n        flb_error(\"Unable to init avro writer\\n\");\n        msgpack_unpacked_destroy(&result);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    // write the magic byte stuff\n    //  write one bye of \\0\n    //  this is followed by\n    //  16 bytes of the schemaid where the schemaid is in hex\n    //  in this implementation the schemaid is the md5hash of the avro schema\n    int rval;\n    rval = avro_write(awriter, \"\\0\", 1);\n    if (rval != 0) {\n        flb_error(\"Unable to write magic byte\\n\");\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    // write the schemaid\n    // its md5hash of the avro schema\n    // it looks like this c4b52aaf22429c7f9eb8c30270bc1795\n    const char *pos = ctx->schema_id;\n    unsigned char val[16];\n    size_t count;\n    for (count = 0; count < sizeof val/sizeof *val; count++) {\n            sscanf(pos, \"%2hhx\", &val[count]);\n            pos += 2;\n    }\n    \n    // write it into a buffer which can be passed to librdkafka\n    rval = avro_write(awriter, val, 16);\n    if (rval != 0) {\n        flb_error(\"Unable to write schemaid\\n\");\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n\tif (avro_value_write(awriter, &aobject)) {\n\t\tflb_error(\"Unable to write avro value to memory buffer\\nMessage: %s\\n\", avro_strerror());\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n\t\treturn NULL;\n\t}\n\n    flb_debug(\"before avro_writer_flush\\n\");\n\n    avro_writer_flush(awriter);\n\n    int64_t bytes_written = avro_writer_tell(awriter);\n\n    // by here the entire object should be fully serialized into the sds buffer\n    avro_writer_free(awriter);\n    avro_value_decref(&aobject);\n\tavro_value_iface_decref(aclass);\n    avro_schema_decref(aschema);\n    msgpack_unpacked_destroy(&result);\n \n    flb_debug(\"after memory free:bytes written:%zu:\\n\", bytes_written);\n\n    flb_sds_t ret =  flb_sds_create_len(out_buff, bytes_written);\n\n    flb_free(out_buff);\n\n    flb_debug(\"shrunk flb sds:\\n\");\n    flb_debug(\"sds len:%zu:\\n\", flb_sds_len(ret));\n    flb_debug(\"sds alloc:%zu:\\n\", flb_sds_alloc(ret));\n    flb_debug(\"sds avail:%zu:\\n\", flb_sds_avail(ret));\n\n    return ret;\n\n}",
  "abstract_func_before": "flb_sds_t flb_msgpack_raw_to_avro_sds(const void *VAR_0, size_t VAR_1, struct flb_avro_fields *VAR_2)\n{\n    msgpack_unpacked VAR_3;\n    msgpack_object *VAR_4;\n\n    size_t VAR_5 = VAR_1 * 3;\n    char *VAR_6 = flb_malloc(VAR_5);\n\n    avro_writer_t VAR_7;\n    flb_debug(\"in flb_msgpack_raw_to_avro_sds\\n\");\n    flb_debug(\"schemaID:%s:\\n\", VAR_2->schema_id);\n    flb_debug(\"schema string:%s:\\n\", VAR_2->schema_str);\n\n    size_t VAR_8 = flb_sds_len(VAR_2->schema_str);\n\n    avro_value_t  VAR_9;\n\n    assert(VAR_0 != NULL);\n\n    avro_value_iface_t  *VAR_10 = NULL;\n    avro_schema_t VAR_11;\n\n    VAR_10 = flb_avro_init(&VAR_9, (char *)VAR_2->schema_str, VAR_8, &VAR_11);\n\n    if (!VAR_10) {\n        flb_error(\"Failed init avro:%s:n\", avro_strerror());\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    msgpack_unpacked_init(&VAR_3);\n    if (msgpack_unpack_next(&VAR_3, VAR_0, VAR_1, NULL) != VAR_12) {\n        flb_error(\"msgpack_unpack problem\\n\");\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    VAR_4 = &VAR_3.data;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    flb_debug(\"calling flb_msgpack_to_avro\\n\");\n\n    if (flb_msgpack_to_avro(&VAR_9, VAR_4) != VAR_13) {\n        flb_errno();\n        flb_error(\"Failed msgpack to avro\\n\");\n        msgpack_unpacked_destroy(&VAR_3);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    flb_debug(\"before avro_writer_memory\\n\");\n    VAR_7 = avro_writer_memory(VAR_6, VAR_5);\n    if (VAR_7 == NULL) {\n        flb_error(\"Unable to init avro writer\\n\");\n        msgpack_unpacked_destroy(&VAR_3);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    int VAR_14;\n    VAR_14 = avro_write(VAR_7, \"\\0\", 1);\n    if (VAR_14 != 0) {\n        flb_error(\"Unable to write magic byte\\n\");\n        avro_writer_free(VAR_7);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        msgpack_unpacked_destroy(&VAR_3);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    const char *VAR_15 = VAR_2->schema_id;\n    unsigned char VAR_16[16];\n    size_t VAR_17;\n    for (VAR_17 = 0; VAR_17 < sizeof VAR_16/sizeof *VAR_16; VAR_17++) {\n            sscanf(VAR_15, \"%2hhx\", &VAR_16[VAR_17]);\n            VAR_15 += 2;\n    }\n    \n    /* COMMENT_10 */\n    VAR_14 = avro_write(VAR_7, VAR_16, 16);\n    if (VAR_14 != 0) {\n        flb_error(\"Unable to write schemaid\\n\");\n        avro_writer_free(VAR_7);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        msgpack_unpacked_destroy(&VAR_3);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n\tif (avro_value_write(VAR_7, &VAR_9)) {\n\t\tflb_error(\"Unable to write avro value to memory buffer\\nMessage: %s\\n\", avro_strerror());\n        avro_writer_free(VAR_7);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        msgpack_unpacked_destroy(&VAR_3);\n        flb_free(VAR_6);\n\t\treturn NULL;\n\t}\n\n    flb_debug(\"before avro_writer_flush\\n\");\n\n    avro_writer_flush(VAR_7);\n\n    int64_t VAR_18 = avro_writer_tell(VAR_7);\n\n    /* COMMENT_11 */\n    avro_writer_free(VAR_7);\n    avro_value_decref(&VAR_9);\n\tavro_value_iface_decref(VAR_10);\n    avro_schema_decref(VAR_11);\n    msgpack_unpacked_destroy(&VAR_3);\n \n    flb_debug(\"after memory free:bytes written:%zu:\\n\", VAR_18);\n\n    flb_sds_t VAR_19 =  flb_sds_create_len(VAR_6, VAR_18);\n\n    flb_free(VAR_6);\n\n    flb_debug(\"shrunk flb sds:\\n\");\n    flb_debug(\"sds len:%zu:\\n\", flb_sds_len(VAR_19));\n    flb_debug(\"sds alloc:%zu:\\n\", flb_sds_alloc(VAR_19));\n    flb_debug(\"sds avail:%zu:\\n\", flb_sds_avail(VAR_19));\n\n    return VAR_19;\n\n}",
  "func_graph_path_before": "fluent/fluent-bit/a5d1721c8e3e62c30eb05609ece152fa689dbc35/flb_avro.c/vul/before/0.json",
  "func": "flb_sds_t flb_msgpack_raw_to_avro_sds(const void *in_buf, size_t in_size, struct flb_avro_fields *ctx)\n{\n    msgpack_unpacked result;\n    msgpack_object *root;\n\n    size_t avro_buffer_size = in_size * 3;\n    char *out_buff = flb_malloc(avro_buffer_size);\n    if (!out_buff) {\n        flb_errno();\n        return NULL;\n    }\n\n    avro_writer_t awriter;\n    flb_debug(\"in flb_msgpack_raw_to_avro_sds\\n\");\n    flb_debug(\"schemaID:%s:\\n\", ctx->schema_id);\n    flb_debug(\"schema string:%s:\\n\", ctx->schema_str);\n\n    size_t schema_json_len = flb_sds_len(ctx->schema_str);\n\n    avro_value_t  aobject;\n\n    assert(in_buf != NULL);\n\n    avro_value_iface_t  *aclass = NULL;\n    avro_schema_t aschema;\n\n    aclass = flb_avro_init(&aobject, (char *)ctx->schema_str, schema_json_len, &aschema);\n\n    if (!aclass) {\n        flb_error(\"Failed init avro:%s:n\", avro_strerror());\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, in_buf, in_size, NULL) != MSGPACK_UNPACK_SUCCESS) {\n        flb_error(\"msgpack_unpack problem\\n\");\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    root = &result.data;\n\n    // create the avro object\n    // then serialize it into a buffer for the downstream\n    flb_debug(\"calling flb_msgpack_to_avro\\n\");\n\n    if (flb_msgpack_to_avro(&aobject, root) != FLB_TRUE) {\n        flb_errno();\n        flb_error(\"Failed msgpack to avro\\n\");\n        msgpack_unpacked_destroy(&result);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    flb_debug(\"before avro_writer_memory\\n\");\n    awriter = avro_writer_memory(out_buff, avro_buffer_size);\n    if (awriter == NULL) {\n        flb_error(\"Unable to init avro writer\\n\");\n        msgpack_unpacked_destroy(&result);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    // write the magic byte stuff\n    //  write one bye of \\0\n    //  this is followed by\n    //  16 bytes of the schemaid where the schemaid is in hex\n    //  in this implementation the schemaid is the md5hash of the avro schema\n    int rval;\n    rval = avro_write(awriter, \"\\0\", 1);\n    if (rval != 0) {\n        flb_error(\"Unable to write magic byte\\n\");\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    // write the schemaid\n    // its md5hash of the avro schema\n    // it looks like this c4b52aaf22429c7f9eb8c30270bc1795\n    const char *pos = ctx->schema_id;\n    unsigned char val[16];\n    size_t count;\n    for (count = 0; count < sizeof val/sizeof *val; count++) {\n            sscanf(pos, \"%2hhx\", &val[count]);\n            pos += 2;\n    }\n    \n    // write it into a buffer which can be passed to librdkafka\n    rval = avro_write(awriter, val, 16);\n    if (rval != 0) {\n        flb_error(\"Unable to write schemaid\\n\");\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n\tif (avro_value_write(awriter, &aobject)) {\n\t\tflb_error(\"Unable to write avro value to memory buffer\\nMessage: %s\\n\", avro_strerror());\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n\t\treturn NULL;\n\t}\n\n    flb_debug(\"before avro_writer_flush\\n\");\n\n    avro_writer_flush(awriter);\n\n    int64_t bytes_written = avro_writer_tell(awriter);\n\n    // by here the entire object should be fully serialized into the sds buffer\n    avro_writer_free(awriter);\n    avro_value_decref(&aobject);\n\tavro_value_iface_decref(aclass);\n    avro_schema_decref(aschema);\n    msgpack_unpacked_destroy(&result);\n \n    flb_debug(\"after memory free:bytes written:%zu:\\n\", bytes_written);\n\n    flb_sds_t ret =  flb_sds_create_len(out_buff, bytes_written);\n\n    flb_free(out_buff);\n\n    flb_debug(\"shrunk flb sds:\\n\");\n    flb_debug(\"sds len:%zu:\\n\", flb_sds_len(ret));\n    flb_debug(\"sds alloc:%zu:\\n\", flb_sds_alloc(ret));\n    flb_debug(\"sds avail:%zu:\\n\", flb_sds_avail(ret));\n\n    return ret;\n\n}",
  "abstract_func": "flb_sds_t flb_msgpack_raw_to_avro_sds(const void *VAR_0, size_t VAR_1, struct flb_avro_fields *VAR_2)\n{\n    msgpack_unpacked VAR_3;\n    msgpack_object *VAR_4;\n\n    size_t VAR_5 = VAR_1 * 3;\n    char *VAR_6 = flb_malloc(VAR_5);\n    if (!VAR_6) {\n        flb_errno();\n        return NULL;\n    }\n\n    avro_writer_t VAR_7;\n    flb_debug(\"in flb_msgpack_raw_to_avro_sds\\n\");\n    flb_debug(\"schemaID:%s:\\n\", VAR_2->schema_id);\n    flb_debug(\"schema string:%s:\\n\", VAR_2->schema_str);\n\n    size_t VAR_8 = flb_sds_len(VAR_2->schema_str);\n\n    avro_value_t  VAR_9;\n\n    assert(VAR_0 != NULL);\n\n    avro_value_iface_t  *VAR_10 = NULL;\n    avro_schema_t VAR_11;\n\n    VAR_10 = flb_avro_init(&VAR_9, (char *)VAR_2->schema_str, VAR_8, &VAR_11);\n\n    if (!VAR_10) {\n        flb_error(\"Failed init avro:%s:n\", avro_strerror());\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    msgpack_unpacked_init(&VAR_3);\n    if (msgpack_unpack_next(&VAR_3, VAR_0, VAR_1, NULL) != VAR_12) {\n        flb_error(\"msgpack_unpack problem\\n\");\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    VAR_4 = &VAR_3.data;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    flb_debug(\"calling flb_msgpack_to_avro\\n\");\n\n    if (flb_msgpack_to_avro(&VAR_9, VAR_4) != VAR_13) {\n        flb_errno();\n        flb_error(\"Failed msgpack to avro\\n\");\n        msgpack_unpacked_destroy(&VAR_3);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    flb_debug(\"before avro_writer_memory\\n\");\n    VAR_7 = avro_writer_memory(VAR_6, VAR_5);\n    if (VAR_7 == NULL) {\n        flb_error(\"Unable to init avro writer\\n\");\n        msgpack_unpacked_destroy(&VAR_3);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    int VAR_14;\n    VAR_14 = avro_write(VAR_7, \"\\0\", 1);\n    if (VAR_14 != 0) {\n        flb_error(\"Unable to write magic byte\\n\");\n        avro_writer_free(VAR_7);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        msgpack_unpacked_destroy(&VAR_3);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    const char *VAR_15 = VAR_2->schema_id;\n    unsigned char VAR_16[16];\n    size_t VAR_17;\n    for (VAR_17 = 0; VAR_17 < sizeof VAR_16/sizeof *VAR_16; VAR_17++) {\n            sscanf(VAR_15, \"%2hhx\", &VAR_16[VAR_17]);\n            VAR_15 += 2;\n    }\n    \n    /* COMMENT_10 */\n    VAR_14 = avro_write(VAR_7, VAR_16, 16);\n    if (VAR_14 != 0) {\n        flb_error(\"Unable to write schemaid\\n\");\n        avro_writer_free(VAR_7);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        msgpack_unpacked_destroy(&VAR_3);\n        flb_free(VAR_6);\n        return NULL;\n    }\n\n\tif (avro_value_write(VAR_7, &VAR_9)) {\n\t\tflb_error(\"Unable to write avro value to memory buffer\\nMessage: %s\\n\", avro_strerror());\n        avro_writer_free(VAR_7);\n        avro_value_decref(&VAR_9);\n        avro_value_iface_decref(VAR_10);\n        avro_schema_decref(VAR_11);\n        msgpack_unpacked_destroy(&VAR_3);\n        flb_free(VAR_6);\n\t\treturn NULL;\n\t}\n\n    flb_debug(\"before avro_writer_flush\\n\");\n\n    avro_writer_flush(VAR_7);\n\n    int64_t VAR_18 = avro_writer_tell(VAR_7);\n\n    /* COMMENT_11 */\n    avro_writer_free(VAR_7);\n    avro_value_decref(&VAR_9);\n\tavro_value_iface_decref(VAR_10);\n    avro_schema_decref(VAR_11);\n    msgpack_unpacked_destroy(&VAR_3);\n \n    flb_debug(\"after memory free:bytes written:%zu:\\n\", VAR_18);\n\n    flb_sds_t VAR_19 =  flb_sds_create_len(VAR_6, VAR_18);\n\n    flb_free(VAR_6);\n\n    flb_debug(\"shrunk flb sds:\\n\");\n    flb_debug(\"sds len:%zu:\\n\", flb_sds_len(VAR_19));\n    flb_debug(\"sds alloc:%zu:\\n\", flb_sds_alloc(VAR_19));\n    flb_debug(\"sds avail:%zu:\\n\", flb_sds_avail(VAR_19));\n\n    return VAR_19;\n\n}",
  "func_graph_path": "fluent/fluent-bit/a5d1721c8e3e62c30eb05609ece152fa689dbc35/flb_avro.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,10 @@\n \n     size_t avro_buffer_size = in_size * 3;\n     char *out_buff = flb_malloc(avro_buffer_size);\n+    if (!out_buff) {\n+        flb_errno();\n+        return NULL;\n+    }\n \n     avro_writer_t awriter;\n     flb_debug(\"in flb_msgpack_raw_to_avro_sds\\n\");",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (!out_buff) {",
      "        flb_errno();",
      "        return NULL;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fluent/fluent-bit/pull/3045",
  "description": {
    "pr_info": {
      "title": "Add additional check returned from flb_malloc",
      "number": 3045
    },
    "comment": [
      "This PR tries to address the issue raised in #3044 where\r\nmemory pointer returned from flb_malloc was not checked for NULL.\r\nCredit to @raminfp.\r\n\r\nThis PR fixes the #3044.\r\n\r\nSigned-off-by: Yong Tang <yong.tang.github@outlook.com>\r\n\r\nExample config:\r\n```\r\n$ cat fluent-bit.conf \r\n[INPUT]\r\n    Name  cpu\r\n\r\n[OUTPUT]\r\n    Name        kafka\r\n    Match       *\r\n    Brokers     192.168.1.3:9092\r\n    Topics      test\r\n```\r\n\r\nValgrind:\r\n```\r\n$ valgrind --leak-check=full  bin/fluent-bit -c fluent-bit.conf \r\n==493573== Memcheck, a memory error detector\r\n==493573== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==493573== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==493573== Command: bin/fluent-bit -c fluent-bit.conf\r\n==493573== \r\nFluent Bit v1.7.0\r\n* Copyright (C) 2019-2020 The Fluent Bit Authors\r\n* Copyright (C) 2015-2018 Treasure Data\r\n* Fluent Bit is a CNCF sub-project under the umbrella of Fluentd\r\n* https://fluentbit.io\r\n\r\n[2021/02/09 15:14:50] [ info] [engine] started (pid=493573)\r\n[2021/02/09 15:14:50] [ info] [storage] version=1.1.0, initializing...\r\n[2021/02/09 15:14:50] [ info] [storage] in-memory\r\n[2021/02/09 15:14:50] [ info] [storage] normal synchronization mode, checksum disabled, max_chunks_up=128\r\n[2021/02/09 15:14:50] [ info] [output:kafka:kafka.0] brokers='192.168.1.3:9092' topics='test'\r\n[2021/02/09 15:14:50] [ info] [sp] stream processor started\r\n^C[2021/02/09 15:14:53] [engine] caught signal (SIGINT)\r\n[2021/02/09 15:14:53] [ info] [input] pausing cpu.0\r\n[2021/02/09 15:14:53] [ warn] [engine] service will stop in 5 seconds\r\n[2021/02/09 15:14:57] [ info] [engine] service stopped\r\n==493573== \r\n==493573== HEAP SUMMARY:\r\n==493573==     in use at exit: 0 bytes in 0 blocks\r\n==493573==   total heap usage: 398 allocs, 398 frees, 688,865 bytes allocated\r\n==493573== \r\n==493573== All heap blocks were freed -- no leaks are possible\r\n==493573== \r\n==493573== For lists of detected and suppressed errors, rerun with: -s\r\n==493573== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n```\r\n\r\n<!-- Provide summary of changes -->\r\n\r\n<!-- Issue number, if available. E.g. \"Fixes #31\", \"Addresses #42, #77\" -->\r\n\r\n----\r\nEnter `[N/A]` in the box, if an item is not applicable to your change.\r\n\r\n**Testing**\r\nBefore we can approve your change; please submit the following in a comment:\r\n- [x] Example configuration file for the change\r\n- [x] Debug log output from testing the change\r\n<!-- Invoke Fluent Bit and Valgrind as: $ valgrind ./bin/fluent-bit <args> -->\r\n- [x] Attached [Valgrind](https://valgrind.org/docs/manual/quick-start.html) output that shows no leaks or memory corruption was found\r\n\r\n**Documentation**\r\n<!-- Docs can be edited at https://github.com/fluent/fluent-bit-docs -->\r\n- [N/A] Documentation required for this feature\r\n\r\n<!--  Doc PR (not required but highly recommended) -->\r\n\r\n----\r\n\r\nFluent Bit is licensed under Apache 2.0, by submitting this pull request I understand that this code will be released under the terms of that license.\r\n",
      "thanks @yongtang .\r\n\r\nAbout the commit messages, please check this one: https://github.com/fluent/fluent-bit/blob/master/CONTRIBUTING.md#commit-changes",
      "@edsiper Ah I didn't notice the commit message before. Will take note and apply for future commits."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0  \nThe patch addresses a memory management issue, specifically a missing NULL check after a memory allocation, which is a security concern as it could lead to null pointer dereferences and application crashes. The changes directly fix this vulnerability, making it a security fix.\n\n**Confidence:** 1.0  \nThe commit message clearly states the issue and the fix, and the code changes directly address the problem. Additionally, the Valgrind output confirms no memory leaks, further supporting the classification."
}