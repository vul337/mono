{
  "cve_id": "CVE-2023-42299",
  "cwe_ids": [
    "CWE-787",
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "AcademySoftwareFoundation/OpenImageIO",
  "commit_msg": "reformatting",
  "commit_hash": "a613a365d23855a7438b0f04c25dced34df85ae0",
  "git_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/commit/a613a365d23855a7438b0f04c25dced34df85ae0",
  "file_path": "src/gif.imageio/gifinput.cpp",
  "func_name": "GIFInput::read_subimage_data",
  "func_before": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* colormap = NULL;\n    int colormap_count;\n    if (m_gif_file->Image.ColorMap) {  // local colormap\n        colormap = m_gif_file->Image.ColorMap->Colors;\n        colormap_count = m_gif_file->Image.ColorMap->ColorCount;\n    } else if (m_gif_file->SColorMap) {  // global colormap\n        colormap = m_gif_file->SColorMap->Colors;\n        colormap_count = m_gif_file->SColorMap->ColorCount;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) {\n        // make whole canvas transparent\n        std::fill(m_canvas.begin(), m_canvas.end(), 0x00);\n    }\n\n    // decode scanline index if image is interlaced\n    bool interlacing = m_spec.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    // get subimage dimensions and draw it on canvas\n    int window_height = m_gif_file->Image.Height;\n    int window_width  = m_gif_file->Image.Width;\n    int window_top    = m_gif_file->Image.Top;\n    int window_left   = m_gif_file->Image.Left;\n    std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]);\n    for (int wy = 0; wy < window_height; wy++) {\n        if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) {\n            report_last_error();\n            return false;\n        }\n        int y = window_top\n                + (interlacing ? decode_line_number(wy, window_height) : wy);\n        if (0 <= y && y < m_spec.height) {\n            for (int wx = 0; wx < window_width; wx++) {\n                if (fscanline[wx] >= colormap_count) {\n                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n                             fscanline[wx], wx, y, colormap_count);\n                    return false;\n                }\n                int x   = window_left + wx;\n                int idx = m_spec.nchannels * (y * m_spec.width + x);\n                if (0 <= x && x < m_spec.width\n                    && fscanline[wx] != m_transparent_color) {\n                    m_canvas[idx]     = colormap[fscanline[wx]].Red;\n                    m_canvas[idx + 1] = colormap[fscanline[wx]].Green;\n                    m_canvas[idx + 2] = colormap[fscanline[wx]].Blue;\n                    m_canvas[idx + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "abstract_func_before": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* VAR_0 = NULL;\n    int VAR_1;\n    if (VAR_2->Image.ColorMap) {  /* COMMENT_0 */\n        VAR_0 = VAR_2->Image.ColorMap->Colors;\n        VAR_1 = VAR_2->Image.ColorMap->ColorCount;\n    } else if (VAR_2->SColorMap) {  /* COMMENT_1 */\n        VAR_0 = VAR_2->SColorMap->Colors;\n        VAR_1 = VAR_2->SColorMap->ColorCount;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (VAR_3 == 0 || VAR_4 == VAR_5) {\n        /* COMMENT_2 */\n        std::fill(VAR_6.begin(), VAR_6.end(), 0x00);\n    }\n\n    /* COMMENT_3 */\n    bool VAR_7 = VAR_8.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    /* COMMENT_4 */\n    int VAR_9 = VAR_2->Image.Height;\n    int VAR_10  = VAR_2->Image.Width;\n    int VAR_11    = VAR_2->Image.Top;\n    int VAR_12   = VAR_2->Image.Left;\n    std::unique_ptr<unsigned char[]> VAR_13(new unsigned char[VAR_10]);\n    for (int VAR_14 = 0; VAR_14 < VAR_9; VAR_14++) {\n        if (DGifGetLine(VAR_2, &VAR_13[0], VAR_10) == VAR_15) {\n            report_last_error();\n            return false;\n        }\n        int VAR_16 = VAR_11\n                + (VAR_7 ? decode_line_number(VAR_14, VAR_9) : VAR_14);\n        if (0 <= VAR_16 && VAR_16 < VAR_8.height) {\n            for (int VAR_17 = 0; VAR_17 < VAR_10; VAR_17++) {\n                if (VAR_13[VAR_17] >= VAR_1) {\n                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n                             VAR_13[VAR_17], VAR_17, VAR_16, VAR_1);\n                    return false;\n                }\n                int VAR_18   = VAR_12 + VAR_17;\n                int VAR_19 = VAR_8.nchannels * (VAR_16 * VAR_8.width + VAR_18);\n                if (0 <= VAR_18 && VAR_18 < VAR_8.width\n                    && VAR_13[VAR_17] != VAR_20) {\n                    VAR_6[VAR_19]     = VAR_0[VAR_13[VAR_17]].Red;\n                    VAR_6[VAR_19 + 1] = VAR_0[VAR_13[VAR_17]].Green;\n                    VAR_6[VAR_19 + 2] = VAR_0[VAR_13[VAR_17]].Blue;\n                    VAR_6[VAR_19 + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/OpenImageIO/a613a365d23855a7438b0f04c25dced34df85ae0/gifinput.cpp/vul/before/0.json",
  "func": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* colormap = NULL;\n    int colormap_count;\n    if (m_gif_file->Image.ColorMap) {  // local colormap\n        colormap = m_gif_file->Image.ColorMap->Colors;\n        colormap_count = m_gif_file->Image.ColorMap->ColorCount;\n    } else if (m_gif_file->SColorMap) {  // global colormap\n        colormap = m_gif_file->SColorMap->Colors;\n        colormap_count = m_gif_file->SColorMap->ColorCount;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) {\n        // make whole canvas transparent\n        std::fill(m_canvas.begin(), m_canvas.end(), 0x00);\n    }\n\n    // decode scanline index if image is interlaced\n    bool interlacing = m_spec.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    // get subimage dimensions and draw it on canvas\n    int window_height = m_gif_file->Image.Height;\n    int window_width  = m_gif_file->Image.Width;\n    int window_top    = m_gif_file->Image.Top;\n    int window_left   = m_gif_file->Image.Left;\n    std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]);\n    for (int wy = 0; wy < window_height; wy++) {\n        if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) {\n            report_last_error();\n            return false;\n        }\n        int y = window_top\n                + (interlacing ? decode_line_number(wy, window_height) : wy);\n        if (0 <= y && y < m_spec.height) {\n            for (int wx = 0; wx < window_width; wx++) {\n                if (fscanline[wx] >= colormap_count) {\n                    errorfmt(\n                        \"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n                        fscanline[wx], wx, y, colormap_count);\n                    return false;\n                }\n                int x   = window_left + wx;\n                int idx = m_spec.nchannels * (y * m_spec.width + x);\n                if (0 <= x && x < m_spec.width\n                    && fscanline[wx] != m_transparent_color) {\n                    m_canvas[idx]     = colormap[fscanline[wx]].Red;\n                    m_canvas[idx + 1] = colormap[fscanline[wx]].Green;\n                    m_canvas[idx + 2] = colormap[fscanline[wx]].Blue;\n                    m_canvas[idx + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "abstract_func": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* VAR_0 = NULL;\n    int VAR_1;\n    if (VAR_2->Image.ColorMap) {  /* COMMENT_0 */\n        VAR_0 = VAR_2->Image.ColorMap->Colors;\n        VAR_1 = VAR_2->Image.ColorMap->ColorCount;\n    } else if (VAR_2->SColorMap) {  /* COMMENT_1 */\n        VAR_0 = VAR_2->SColorMap->Colors;\n        VAR_1 = VAR_2->SColorMap->ColorCount;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (VAR_3 == 0 || VAR_4 == VAR_5) {\n        /* COMMENT_2 */\n        std::fill(VAR_6.begin(), VAR_6.end(), 0x00);\n    }\n\n    /* COMMENT_3 */\n    bool VAR_7 = VAR_8.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    /* COMMENT_4 */\n    int VAR_9 = VAR_2->Image.Height;\n    int VAR_10  = VAR_2->Image.Width;\n    int VAR_11    = VAR_2->Image.Top;\n    int VAR_12   = VAR_2->Image.Left;\n    std::unique_ptr<unsigned char[]> VAR_13(new unsigned char[VAR_10]);\n    for (int VAR_14 = 0; VAR_14 < VAR_9; VAR_14++) {\n        if (DGifGetLine(VAR_2, &VAR_13[0], VAR_10) == VAR_15) {\n            report_last_error();\n            return false;\n        }\n        int VAR_16 = VAR_11\n                + (VAR_7 ? decode_line_number(VAR_14, VAR_9) : VAR_14);\n        if (0 <= VAR_16 && VAR_16 < VAR_8.height) {\n            for (int VAR_17 = 0; VAR_17 < VAR_10; VAR_17++) {\n                if (VAR_13[VAR_17] >= VAR_1) {\n                    errorfmt(\n                        \"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n                        VAR_13[VAR_17], VAR_17, VAR_16, VAR_1);\n                    return false;\n                }\n                int VAR_18   = VAR_12 + VAR_17;\n                int VAR_19 = VAR_8.nchannels * (VAR_16 * VAR_8.width + VAR_18);\n                if (0 <= VAR_18 && VAR_18 < VAR_8.width\n                    && VAR_13[VAR_17] != VAR_20) {\n                    VAR_6[VAR_19]     = VAR_0[VAR_13[VAR_17]].Red;\n                    VAR_6[VAR_19 + 1] = VAR_0[VAR_13[VAR_17]].Green;\n                    VAR_6[VAR_19 + 2] = VAR_0[VAR_13[VAR_17]].Blue;\n                    VAR_6[VAR_19 + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "func_graph_path": "AcademySoftwareFoundation/OpenImageIO/a613a365d23855a7438b0f04c25dced34df85ae0/gifinput.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,8 +38,9 @@\n         if (0 <= y && y < m_spec.height) {\n             for (int wx = 0; wx < window_width; wx++) {\n                 if (fscanline[wx] >= colormap_count) {\n-                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n-                             fscanline[wx], wx, y, colormap_count);\n+                    errorfmt(\n+                        \"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n+                        fscanline[wx], wx, y, colormap_count);\n                     return false;\n                 }\n                 int x   = window_left + wx;",
  "diff_line_info": {
    "deleted_lines": [
      "                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",",
      "                             fscanline[wx], wx, y, colormap_count);"
    ],
    "added_lines": [
      "                    errorfmt(",
      "                        \"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",",
      "                        fscanline[wx], wx, y, colormap_count);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/pull/3841",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/AcademySoftwareFoundation/OpenImageIO/pull/3841: 403 Client Error: Forbidden for url: https://api.github.com/repos/AcademySoftwareFoundation/OpenImageIO/issues/3841/comments",
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Output:**  \n**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 0.8"
}