{
  "cve_id": "CVE-2020-26682",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "outline: fix overflows in outline processing\n\nThis commit enforces strict invariant on ASS_Outline\nto contain point coordinates into predetermined range.\n\nFixes https://github.com/libass/libass/issues/431.",
  "commit_hash": "676f9dc5b52ef406c5527bdadbcb947f11392929",
  "git_url": "https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929",
  "file_path": "libass/ass_outline.c",
  "func_name": "outline_stroke",
  "func_before": "bool outline_stroke(ASS_Outline *result, ASS_Outline *result1,\n                    const ASS_Outline *path, int xbord, int ybord, int eps)\n{\n    outline_alloc(result,  2 * path->n_points, 2 * path->n_segments);\n    outline_alloc(result1, 2 * path->n_points, 2 * path->n_segments);\n    if (!result->max_points || !result1->max_points)\n        return false;\n\n    const int dir = 3;\n    int rad = FFMAX(xbord, ybord);\n    assert(rad >= eps);\n\n    StrokerState str;\n    str.result[0] = result;\n    str.result[1] = result1;\n    str.contour_first[0] = 0;\n    str.contour_first[1] = 0;\n    str.xbord = xbord;\n    str.ybord = ybord;\n    str.xscale = 1.0 / FFMAX(eps, xbord);\n    str.yscale = 1.0 / FFMAX(eps, ybord);\n    str.eps = eps;\n\n    str.contour_start = true;\n    double rel_err = (double) eps / rad;\n    str.merge_cos = 1 - rel_err;\n    double e = sqrt(2 * rel_err);\n    str.split_cos = 1 + 8 * rel_err - 4 * (1 + rel_err) * e;\n    str.min_len = rel_err / 4;\n    str.err_q = 8 * (1 + rel_err) * (1 + rel_err);\n    str.err_c = 390 * rel_err * rel_err;\n    str.err_a = e;\n\n    for (size_t i = 0; i < path->n_points; i++) {\n        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)\n            return false;\n        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)\n            return false;\n    }\n\n    ASS_Vector *start = path->points, *cur = start;\n    for (size_t i = 0; i < path->n_segments; i++) {\n        if (start == cur)\n            str.last_point = *start;\n\n        int n = path->segments[i] & OUTLINE_COUNT_MASK;\n        cur += n;\n\n        ASS_Vector *end = cur;\n        if (path->segments[i] & OUTLINE_CONTOUR_END) {\n            end = start;\n            start = cur;\n        }\n\n        switch (n) {\n        case OUTLINE_LINE_SEGMENT:\n            if (!add_line(&str, *end, dir))\n                return false;\n            break;\n\n        case OUTLINE_QUADRATIC_SPLINE:\n            if (!add_quadratic(&str, cur[-1], *end, dir))\n                return false;\n            break;\n\n        case OUTLINE_CUBIC_SPLINE:\n            if (!add_cubic(&str, cur[-2], cur[-1], *end, dir))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n\n        if (start == cur && !close_contour(&str, dir))\n            return false;\n    }\n    assert(start == cur && cur == path->points + path->n_points);\n    return true;\n}",
  "abstract_func_before": "bool outline_stroke(ASS_Outline *VAR_0, ASS_Outline *VAR_1,\n                    const ASS_Outline *VAR_2, int VAR_3, int VAR_4, int VAR_5)\n{\n    outline_alloc(VAR_0,  2 * VAR_2->n_points, 2 * VAR_2->n_segments);\n    outline_alloc(VAR_1, 2 * VAR_2->n_points, 2 * VAR_2->n_segments);\n    if (!VAR_0->max_points || !VAR_1->max_points)\n        return false;\n\n    const int VAR_6 = 3;\n    int VAR_7 = FFMAX(VAR_3, VAR_4);\n    assert(VAR_7 >= VAR_5);\n\n    StrokerState VAR_8;\n    VAR_8.result[0] = VAR_0;\n    VAR_8.result[1] = VAR_1;\n    VAR_8.contour_first[0] = 0;\n    VAR_8.contour_first[1] = 0;\n    VAR_8.xbord = VAR_3;\n    VAR_8.ybord = VAR_4;\n    VAR_8.xscale = 1.0 / FFMAX(VAR_5, VAR_3);\n    VAR_8.yscale = 1.0 / FFMAX(VAR_5, VAR_4);\n    VAR_8.eps = VAR_5;\n\n    VAR_8.contour_start = true;\n    double VAR_9 = (double) VAR_5 / VAR_7;\n    VAR_8.merge_cos = 1 - VAR_9;\n    double VAR_10 = sqrt(2 * VAR_9);\n    VAR_8.split_cos = 1 + 8 * VAR_9 - 4 * (1 + VAR_9) * VAR_10;\n    VAR_8.min_len = VAR_9 / 4;\n    VAR_8.err_q = 8 * (1 + VAR_9) * (1 + VAR_9);\n    VAR_8.err_c = 390 * VAR_9 * VAR_9;\n    VAR_8.err_a = VAR_10;\n\n    for (size_t VAR_11 = 0; VAR_11 < VAR_2->n_points; VAR_11++) {\n        if (VAR_2->points[VAR_11].x < VAR_12 || VAR_2->points[VAR_11].x > VAR_13)\n            return false;\n        if (VAR_2->points[VAR_11].y < VAR_12 || VAR_2->points[VAR_11].y > VAR_13)\n            return false;\n    }\n\n    ASS_Vector *VAR_14 = VAR_2->points, *VAR_15 = VAR_14;\n    for (size_t VAR_11 = 0; VAR_11 < VAR_2->n_segments; VAR_11++) {\n        if (VAR_14 == VAR_15)\n            VAR_8.last_point = *VAR_14;\n\n        int VAR_16 = VAR_2->segments[VAR_11] & VAR_17;\n        VAR_15 += VAR_16;\n\n        ASS_Vector *VAR_18 = VAR_15;\n        if (VAR_2->segments[VAR_11] & VAR_19) {\n            VAR_18 = VAR_14;\n            VAR_14 = VAR_15;\n        }\n\n        switch (VAR_16) {\n        case VAR_20:\n            if (!add_line(&VAR_8, *VAR_18, VAR_6))\n                return false;\n            break;\n\n        case VAR_21:\n            if (!add_quadratic(&VAR_8, VAR_15[-1], *VAR_18, VAR_6))\n                return false;\n            break;\n\n        case VAR_22:\n            if (!add_cubic(&VAR_8, VAR_15[-2], VAR_15[-1], *VAR_18, VAR_6))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n\n        if (VAR_14 == VAR_15 && !close_contour(&VAR_8, VAR_6))\n            return false;\n    }\n    assert(VAR_14 == VAR_15 && VAR_15 == VAR_2->points + VAR_2->n_points);\n    return true;\n}",
  "func_graph_path_before": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/4.json",
  "func": "bool outline_stroke(ASS_Outline *result, ASS_Outline *result1,\n                    const ASS_Outline *path, int xbord, int ybord, int eps)\n{\n    outline_alloc(result,  2 * path->n_points, 2 * path->n_segments);\n    outline_alloc(result1, 2 * path->n_points, 2 * path->n_segments);\n    if (!result->max_points || !result1->max_points)\n        return false;\n\n    const int dir = 3;\n    int rad = FFMAX(xbord, ybord);\n    assert(rad >= eps && rad <= OUTLINE_MAX);\n\n    StrokerState str;\n    str.result[0] = result;\n    str.result[1] = result1;\n    str.contour_first[0] = 0;\n    str.contour_first[1] = 0;\n    str.xbord = xbord;\n    str.ybord = ybord;\n    str.xscale = 1.0 / FFMAX(eps, xbord);\n    str.yscale = 1.0 / FFMAX(eps, ybord);\n    str.eps = eps;\n\n    str.contour_start = true;\n    double rel_err = (double) eps / rad;\n    str.merge_cos = 1 - rel_err;\n    double e = sqrt(2 * rel_err);\n    str.split_cos = 1 + 8 * rel_err - 4 * (1 + rel_err) * e;\n    str.min_len = rel_err / 4;\n    str.err_q = 8 * (1 + rel_err) * (1 + rel_err);\n    str.err_c = 390 * rel_err * rel_err;\n    str.err_a = e;\n\n#ifndef NDEBUG\n    for (size_t i = 0; i < path->n_points; i++)\n        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);\n#endif\n\n    ASS_Vector *start = path->points, *cur = start;\n    for (size_t i = 0; i < path->n_segments; i++) {\n        if (start == cur)\n            str.last_point = *start;\n\n        int n = path->segments[i] & OUTLINE_COUNT_MASK;\n        cur += n;\n\n        ASS_Vector *end = cur;\n        if (path->segments[i] & OUTLINE_CONTOUR_END) {\n            end = start;\n            start = cur;\n        }\n\n        switch (n) {\n        case OUTLINE_LINE_SEGMENT:\n            if (!add_line(&str, *end, dir))\n                return false;\n            break;\n\n        case OUTLINE_QUADRATIC_SPLINE:\n            if (!add_quadratic(&str, cur[-1], *end, dir))\n                return false;\n            break;\n\n        case OUTLINE_CUBIC_SPLINE:\n            if (!add_cubic(&str, cur[-2], cur[-1], *end, dir))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n\n        if (start == cur && !close_contour(&str, dir))\n            return false;\n    }\n    assert(start == cur && cur == path->points + path->n_points);\n    return true;\n}",
  "abstract_func": "bool outline_stroke(ASS_Outline *VAR_0, ASS_Outline *VAR_1,\n                    const ASS_Outline *VAR_2, int VAR_3, int VAR_4, int VAR_5)\n{\n    outline_alloc(VAR_0,  2 * VAR_2->n_points, 2 * VAR_2->n_segments);\n    outline_alloc(VAR_1, 2 * VAR_2->n_points, 2 * VAR_2->n_segments);\n    if (!VAR_0->max_points || !VAR_1->max_points)\n        return false;\n\n    const int VAR_6 = 3;\n    int VAR_7 = FFMAX(VAR_3, VAR_4);\n    assert(VAR_7 >= VAR_5 && VAR_7 <= VAR_8);\n\n    StrokerState VAR_9;\n    VAR_9.result[0] = VAR_0;\n    VAR_9.result[1] = VAR_1;\n    VAR_9.contour_first[0] = 0;\n    VAR_9.contour_first[1] = 0;\n    VAR_9.xbord = VAR_3;\n    VAR_9.ybord = VAR_4;\n    VAR_9.xscale = 1.0 / FFMAX(VAR_5, VAR_3);\n    VAR_9.yscale = 1.0 / FFMAX(VAR_5, VAR_4);\n    VAR_9.eps = VAR_5;\n\n    VAR_9.contour_start = true;\n    double VAR_10 = (double) VAR_5 / VAR_7;\n    VAR_9.merge_cos = 1 - VAR_10;\n    double VAR_11 = sqrt(2 * VAR_10);\n    VAR_9.split_cos = 1 + 8 * VAR_10 - 4 * (1 + VAR_10) * VAR_11;\n    VAR_9.min_len = VAR_10 / 4;\n    VAR_9.err_q = 8 * (1 + VAR_10) * (1 + VAR_10);\n    VAR_9.err_c = 390 * VAR_10 * VAR_10;\n    VAR_9.err_a = VAR_11;\n\n#ifndef VAR_12\n    for (size_t VAR_13 = 0; VAR_13 < VAR_2->n_points; VAR_13++)\n        assert(abs(VAR_2->points[VAR_13].x) <= VAR_8 && abs(VAR_2->points[VAR_13].y) <= VAR_8);\n#endif\n\n    ASS_Vector *VAR_14 = VAR_2->points, *VAR_15 = VAR_14;\n    for (size_t VAR_13 = 0; VAR_13 < VAR_2->n_segments; VAR_13++) {\n        if (VAR_14 == VAR_15)\n            VAR_9.last_point = *VAR_14;\n\n        int VAR_16 = VAR_2->segments[VAR_13] & VAR_17;\n        VAR_15 += VAR_16;\n\n        ASS_Vector *VAR_18 = VAR_15;\n        if (VAR_2->segments[VAR_13] & VAR_19) {\n            VAR_18 = VAR_14;\n            VAR_14 = VAR_15;\n        }\n\n        switch (VAR_16) {\n        case VAR_20:\n            if (!add_line(&VAR_9, *VAR_18, VAR_6))\n                return false;\n            break;\n\n        case VAR_21:\n            if (!add_quadratic(&VAR_9, VAR_15[-1], *VAR_18, VAR_6))\n                return false;\n            break;\n\n        case VAR_22:\n            if (!add_cubic(&VAR_9, VAR_15[-2], VAR_15[-1], *VAR_18, VAR_6))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n\n        if (VAR_14 == VAR_15 && !close_contour(&VAR_9, VAR_6))\n            return false;\n    }\n    assert(VAR_14 == VAR_15 && VAR_15 == VAR_2->points + VAR_2->n_points);\n    return true;\n}",
  "func_graph_path": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \n     const int dir = 3;\n     int rad = FFMAX(xbord, ybord);\n-    assert(rad >= eps);\n+    assert(rad >= eps && rad <= OUTLINE_MAX);\n \n     StrokerState str;\n     str.result[0] = result;\n@@ -31,12 +31,10 @@\n     str.err_c = 390 * rel_err * rel_err;\n     str.err_a = e;\n \n-    for (size_t i = 0; i < path->n_points; i++) {\n-        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)\n-            return false;\n-        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)\n-            return false;\n-    }\n+#ifndef NDEBUG\n+    for (size_t i = 0; i < path->n_points; i++)\n+        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);\n+#endif\n \n     ASS_Vector *start = path->points, *cur = start;\n     for (size_t i = 0; i < path->n_segments; i++) {",
  "diff_line_info": {
    "deleted_lines": [
      "    assert(rad >= eps);",
      "    for (size_t i = 0; i < path->n_points; i++) {",
      "        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)",
      "            return false;",
      "        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)",
      "            return false;",
      "    }"
    ],
    "added_lines": [
      "    assert(rad >= eps && rad <= OUTLINE_MAX);",
      "#ifndef NDEBUG",
      "    for (size_t i = 0; i < path->n_points; i++)",
      "        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);",
      "#endif"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/432",
  "description": {
    "pr_info": {
      "title": "Fix overflows in outline processing",
      "number": 432
    },
    "comment": [
      "I've added a couple of checks for overflows in outline pipeline. Should fix #431, but I'm not familiar with that fuzzing business so I can't ascertain it for now.",
      "Can confirm that this fixes #431. \r\n\r\nOverflow checks seem fine to me. *(Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess)*",
      "> Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess\r\n\r\nMaybe it's even better to get rid of `OUTLINE_MIN` altogether and use `-OUTLINE_MAX` instead.",
      "New, more strict version. `max(abs(x), abs(y)) <= OUTLINE_MAX` is now enforced invariant of `ASS_Outline` instead of some ad hoc check. Also I've got rid of `OUTLINE_MIN`.",
      "@MrSmile \r\n\r\n```\r\nass_outline.c:53:12: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^\r\nass_outline.c:53:12: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^~~\r\n           labs\r\nass_outline.c:53:41: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^\r\nass_outline.c:53:41: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^~~\r\n                                        labs\r\n```",
      "FT docs specify that `FT_Pos` is 16.16 or 26.6 fixed-point representation, so I'm not sure what's better, to cast into `int32_t` or use `labs` here.",
      "Just use `labs`. In a way, this will also serve as a sanity check to ensure the FT docs aren’t lying."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}