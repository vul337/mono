{
  "cve_id": "CVE-2021-32277",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "Restrict SBR frame length to 960 and 1024 samples.\n\nFixes #59 and #60.",
  "commit_hash": "c78251b2b5d41ea840fd61ab9502b3d3036bd747",
  "git_url": "https://github.com/knik0/faad2/commit/c78251b2b5d41ea840fd61ab9502b3d3036bd747",
  "file_path": "libfaad/syntax.c",
  "func_name": "DRM_aac_scalable_main_element",
  "func_before": "void DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                                   bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t retval = 0;\n    uint8_t channels = hDecoder->fr_channels = 0;\n    uint8_t ch;\n    uint8_t this_layer_stereo = (hDecoder->channelConfiguration > 1) ? 1 : 0;\n    element cpe = {0};\n    ic_stream *ics1 = &(cpe.ics1);\n    ic_stream *ics2 = &(cpe.ics2);\n    int16_t *spec_data;\n    ALIGN int16_t spec_data1[1024] = {0};\n    ALIGN int16_t spec_data2[1024] = {0};\n\n    hDecoder->fr_ch_ele = 0;\n\n    hInfo->error = DRM_aac_scalable_main_header(hDecoder, ics1, ics2, ld, this_layer_stereo);\n    if (hInfo->error > 0)\n        return;\n\n    cpe.common_window = 1;\n    if (this_layer_stereo)\n    {\n        hDecoder->element_id[0] = ID_CPE;\n        if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else {\n        hDecoder->element_id[0] = ID_SCE;\n    }\n\n    if (this_layer_stereo)\n    {\n        cpe.channel        = 0;\n        cpe.paired_channel = 1;\n    }\n\n\n    /* Stereo2 / Mono1 */\n    ics1->tns_data_present = faad_get1bit(ld);\n\n#if defined(LTP_DEC)\n    ics1->ltp.data_present = faad_get1bit(ld);\n#elif defined (DRM)\n    if(faad_get1bit(ld)) {\n         hInfo->error = 26;\n         return;\n    }\n#else\n    faad_get1bit(ld);\n#endif\n\n    hInfo->error = side_info(hDecoder, &cpe, ld, ics1, 1);\n    if (hInfo->error > 0)\n        return;\n    if (this_layer_stereo)\n    {\n        /* Stereo3 */\n        ics2->tns_data_present = faad_get1bit(ld);\n#ifdef LTP_DEC\n        ics1->ltp.data_present =\n#endif\n            faad_get1bit(ld);\n        hInfo->error = side_info(hDecoder, &cpe, ld, ics2, 1);\n        if (hInfo->error > 0)\n            return;\n    }\n    /* Stereo4 / Mono2 */\n    if (ics1->tns_data_present)\n        tns_data(ics1, &(ics1->tns), ld);\n    if (this_layer_stereo)\n    {\n        /* Stereo5 */\n        if (ics2->tns_data_present)\n            tns_data(ics2, &(ics2->tns), ld);\n    }\n\n#ifdef DRM\n    /* CRC check */\n    if (hDecoder->object_type == DRM_ER_LC)\n    {\n        if ((hInfo->error = (uint8_t)faad_check_CRC(ld, (uint16_t)faad_get_processed_bits(ld) - 8)) > 0)\n            return;\n    }\n#endif\n\n    /* Stereo6 / Mono3 */\n    /* error resilient spectral data decoding */\n    if ((hInfo->error = reordered_spectral_data(hDecoder, ics1, ld, spec_data1)) > 0)\n    {\n        return;\n    }\n    if (this_layer_stereo)\n    {\n        /* Stereo7 */\n        /* error resilient spectral data decoding */\n        if ((hInfo->error = reordered_spectral_data(hDecoder, ics2, ld, spec_data2)) > 0)\n        {\n            return;\n        }\n    }\n\n\n#ifdef DRM\n#ifdef SBR_DEC\n    /* In case of DRM we need to read the SBR info before channel reconstruction */\n    if ((hDecoder->sbr_present_flag == 1) && (hDecoder->object_type == DRM_ER_LC))\n    {\n        bitfile ld_sbr = {0};\n        uint32_t i;\n        uint16_t count = 0;\n        uint8_t *revbuffer;\n        uint8_t *prevbufstart;\n        uint8_t *pbufend;\n\n        /* all forward bitreading should be finished at this point */\n        uint32_t bitsconsumed = faad_get_processed_bits(ld);\n        uint32_t buffer_size = faad_origbitbuffer_size(ld);\n        uint8_t *buffer = (uint8_t*)faad_origbitbuffer(ld);\n\n        if (bitsconsumed + 8 > buffer_size*8)\n        {\n            hInfo->error = 14;\n            return;\n        }\n\n        if (!hDecoder->sbr[0])\n        {\n            hDecoder->sbr[0] = sbrDecodeInit(hDecoder->frameLength, hDecoder->element_id[0],\n                2*get_sample_rate(hDecoder->sf_index), 0 /* ds SBR */, 1);\n        }\n\n        /* Reverse bit reading of SBR data in DRM audio frame */\n        revbuffer = (uint8_t*)faad_malloc(buffer_size*sizeof(uint8_t));\n        prevbufstart = revbuffer;\n        pbufend = &buffer[buffer_size - 1];\n        for (i = 0; i < buffer_size; i++)\n            *prevbufstart++ = tabFlipbits[*pbufend--];\n\n        /* Set SBR data */\n        /* consider 8 bits from AAC-CRC */\n        /* SBR buffer size is original buffer size minus AAC buffer size */\n        count = (uint16_t)bit2byte(buffer_size*8 - bitsconsumed);\n        faad_initbits(&ld_sbr, revbuffer, count);\n\n        hDecoder->sbr[0]->sample_rate = get_sample_rate(hDecoder->sf_index);\n        hDecoder->sbr[0]->sample_rate *= 2;\n\n        faad_getbits(&ld_sbr, 8); /* Skip 8-bit CRC */\n\n        hDecoder->sbr[0]->ret = sbr_extension_data(&ld_sbr, hDecoder->sbr[0], count, hDecoder->postSeekResetFlag);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->sbr[0]->ps_used)\n        {\n            hDecoder->ps_used[0] = 1;\n            hDecoder->ps_used_global = 1;\n        }\n#endif\n\n        if (ld_sbr.error)\n        {\n            hDecoder->sbr[0]->ret = 1;\n        }\n\n        /* check CRC */\n        /* no need to check it if there was already an error */\n        if (hDecoder->sbr[0]->ret == 0)\n            hDecoder->sbr[0]->ret = (uint8_t)faad_check_CRC(&ld_sbr, (uint16_t)faad_get_processed_bits(&ld_sbr) - 8);\n\n        /* SBR data was corrupted, disable it until the next header */\n        if (hDecoder->sbr[0]->ret != 0)\n        {\n            hDecoder->sbr[0]->header_count = 0;\n        }\n\n        faad_endbits(&ld_sbr);\n\n        if (revbuffer)\n            faad_free(revbuffer);\n    }\n#endif\n#endif\n\n    if (this_layer_stereo)\n    {\n        hInfo->error = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe, spec_data1, spec_data2);\n        if (hInfo->error > 0)\n            return;\n    } else {\n        hInfo->error = reconstruct_single_channel(hDecoder, ics1, &cpe, spec_data1);\n        if (hInfo->error > 0)\n            return;\n    }\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n\n    return;\n}",
  "abstract_func_before": "void DRM_aac_scalable_main_element(NeAACDecStruct *VAR_0, NeAACDecFrameInfo *VAR_1,\n                                   bitfile *VAR_2, program_config *VAR_3, drc_info *VAR_4)\n{\n    uint8_t VAR_5 = 0;\n    uint8_t VAR_6 = VAR_0->fr_channels = 0;\n    uint8_t VAR_7;\n    uint8_t VAR_8 = (VAR_0->channelConfiguration > 1) ? 1 : 0;\n    element VAR_9 = {0};\n    ic_stream *VAR_10 = &(VAR_9.ics1);\n    ic_stream *VAR_11 = &(VAR_9.ics2);\n    int16_t *VAR_12;\n    ALIGN int16_t VAR_13[1024] = {0};\n    ALIGN int16_t VAR_14[1024] = {0};\n\n    VAR_0->fr_ch_ele = 0;\n\n    VAR_1->error = DRM_aac_scalable_main_header(VAR_0, VAR_10, VAR_11, VAR_2, VAR_8);\n    if (VAR_1->error > 0)\n        return;\n\n    VAR_9.common_window = 1;\n    if (VAR_8)\n    {\n        VAR_0->element_id[0] = VAR_15;\n        if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n            VAR_0->element_output_channels[VAR_0->fr_ch_ele] = 2;\n    } else {\n        VAR_0->element_id[0] = VAR_16;\n    }\n\n    if (VAR_8)\n    {\n        VAR_9.channel        = 0;\n        VAR_9.paired_channel = 1;\n    }\n\n\n    /* COMMENT_0 */\n    VAR_10->tns_data_present = faad_get1bit(VAR_2);\n\n#if defined(VAR_17)\n    VAR_10->ltp.data_present = faad_get1bit(VAR_2);\n#elif defined (VAR_18)\n    if(faad_get1bit(VAR_2)) {\n         VAR_1->error = 26;\n         return;\n    }\n#else\n    faad_get1bit(VAR_2);\n#endif\n\n    VAR_1->error = side_info(VAR_0, &VAR_9, VAR_2, VAR_10, 1);\n    if (VAR_1->error > 0)\n        return;\n    if (VAR_8)\n    {\n        /* COMMENT_1 */\n        VAR_11->tns_data_present = faad_get1bit(VAR_2);\n#ifdef VAR_17\n        VAR_10->ltp.data_present =\n#endif\n            faad_get1bit(VAR_2);\n        VAR_1->error = side_info(VAR_0, &VAR_9, VAR_2, VAR_11, 1);\n        if (VAR_1->error > 0)\n            return;\n    }\n    /* COMMENT_2 */\n    if (VAR_10->tns_data_present)\n        tns_data(VAR_10, &(VAR_10->tns), VAR_2);\n    if (VAR_8)\n    {\n        /* COMMENT_3 */\n        if (VAR_11->tns_data_present)\n            tns_data(VAR_11, &(VAR_11->tns), VAR_2);\n    }\n\n#ifdef VAR_18\n    /* COMMENT_4 */\n    if (VAR_0->object_type == VAR_19)\n    {\n        if ((VAR_1->error = (uint8_t)faad_check_CRC(VAR_2, (uint16_t)faad_get_processed_bits(VAR_2) - 8)) > 0)\n            return;\n    }\n#endif\n\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if ((VAR_1->error = reordered_spectral_data(VAR_0, VAR_10, VAR_2, VAR_13)) > 0)\n    {\n        return;\n    }\n    if (VAR_8)\n    {\n        /* COMMENT_7 */\n        /* COMMENT_6 */\n        if ((VAR_1->error = reordered_spectral_data(VAR_0, VAR_11, VAR_2, VAR_14)) > 0)\n        {\n            return;\n        }\n    }\n\n\n#ifdef VAR_18\n#ifdef VAR_20\n    /* COMMENT_8 */\n    if ((VAR_0->sbr_present_flag == 1) && (VAR_0->object_type == VAR_19))\n    {\n        bitfile VAR_21 = {0};\n        uint32_t VAR_22;\n        uint16_t VAR_23 = 0;\n        uint8_t *VAR_24;\n        uint8_t *VAR_25;\n        uint8_t *VAR_26;\n\n        /* COMMENT_9 */\n        uint32_t VAR_27 = faad_get_processed_bits(VAR_2);\n        uint32_t VAR_28 = faad_origbitbuffer_size(VAR_2);\n        uint8_t *VAR_29 = (uint8_t*)faad_origbitbuffer(VAR_2);\n\n        if (VAR_27 + 8 > VAR_28*8)\n        {\n            VAR_1->error = 14;\n            return;\n        }\n\n        if (!VAR_0->sbr[0])\n        {\n            VAR_0->sbr[0] = sbrDecodeInit(VAR_0->frameLength, VAR_0->element_id[0],\n                2*get_sample_rate(VAR_0->sf_index), 0 /* COMMENT_10 */, 1);\n        }\n\n        /* COMMENT_11 */\n        VAR_24 = (uint8_t*)faad_malloc(VAR_28*sizeof(uint8_t));\n        VAR_25 = VAR_24;\n        VAR_26 = &VAR_29[VAR_28 - 1];\n        for (VAR_22 = 0; VAR_22 < VAR_28; VAR_22++)\n            *VAR_25++ = VAR_30[*VAR_26--];\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        VAR_23 = (uint16_t)bit2byte(VAR_28*8 - VAR_27);\n        faad_initbits(&VAR_21, VAR_24, VAR_23);\n\n        VAR_0->sbr[0]->sample_rate = get_sample_rate(VAR_0->sf_index);\n        VAR_0->sbr[0]->sample_rate *= 2;\n\n        faad_getbits(&VAR_21, 8); /* COMMENT_15 */\n\n        VAR_0->sbr[0]->ret = sbr_extension_data(&VAR_21, VAR_0->sbr[0], VAR_23, VAR_0->postSeekResetFlag);\n#if (defined(VAR_31) || defined(VAR_32))\n        if (VAR_0->sbr[0]->ps_used)\n        {\n            VAR_0->ps_used[0] = 1;\n            VAR_0->ps_used_global = 1;\n        }\n#endif\n\n        if (VAR_21.error)\n        {\n            VAR_0->sbr[0]->ret = 1;\n        }\n\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        if (VAR_0->sbr[0]->ret == 0)\n            VAR_0->sbr[0]->ret = (uint8_t)faad_check_CRC(&VAR_21, (uint16_t)faad_get_processed_bits(&VAR_21) - 8);\n\n        /* COMMENT_18 */\n        if (VAR_0->sbr[0]->ret != 0)\n        {\n            VAR_0->sbr[0]->header_count = 0;\n        }\n\n        faad_endbits(&VAR_21);\n\n        if (VAR_24)\n            faad_free(VAR_24);\n    }\n#endif\n#endif\n\n    if (VAR_8)\n    {\n        VAR_1->error = reconstruct_channel_pair(VAR_0, VAR_10, VAR_11, &VAR_9, VAR_13, VAR_14);\n        if (VAR_1->error > 0)\n            return;\n    } else {\n        VAR_1->error = reconstruct_single_channel(VAR_0, VAR_10, &VAR_9, VAR_13);\n        if (VAR_1->error > 0)\n            return;\n    }\n\n    /* COMMENT_19 */\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2)\n    {\n        /* COMMENT_20 */\n        VAR_0->internal_channel[VAR_6] = VAR_6;\n        VAR_0->internal_channel[VAR_6+1] = VAR_6+1;\n    } else {\n        VAR_0->internal_channel[VAR_6] = VAR_6;\n    }\n\n    VAR_0->fr_channels += VAR_0->element_output_channels[VAR_0->fr_ch_ele];\n    VAR_0->fr_ch_ele++;\n\n    return;\n}",
  "func_graph_path_before": "knik0/faad2/c78251b2b5d41ea840fd61ab9502b3d3036bd747/syntax.c/vul/before/0.json",
  "func": "void DRM_aac_scalable_main_element(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                                   bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t retval = 0;\n    uint8_t channels = hDecoder->fr_channels = 0;\n    uint8_t ch;\n    uint8_t this_layer_stereo = (hDecoder->channelConfiguration > 1) ? 1 : 0;\n    element cpe = {0};\n    ic_stream *ics1 = &(cpe.ics1);\n    ic_stream *ics2 = &(cpe.ics2);\n    int16_t *spec_data;\n    ALIGN int16_t spec_data1[1024] = {0};\n    ALIGN int16_t spec_data2[1024] = {0};\n\n    hDecoder->fr_ch_ele = 0;\n\n    hInfo->error = DRM_aac_scalable_main_header(hDecoder, ics1, ics2, ld, this_layer_stereo);\n    if (hInfo->error > 0)\n        return;\n\n    cpe.common_window = 1;\n    if (this_layer_stereo)\n    {\n        hDecoder->element_id[0] = ID_CPE;\n        if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else {\n        hDecoder->element_id[0] = ID_SCE;\n    }\n\n    if (this_layer_stereo)\n    {\n        cpe.channel        = 0;\n        cpe.paired_channel = 1;\n    }\n\n\n    /* Stereo2 / Mono1 */\n    ics1->tns_data_present = faad_get1bit(ld);\n\n#if defined(LTP_DEC)\n    ics1->ltp.data_present = faad_get1bit(ld);\n#elif defined (DRM)\n    if(faad_get1bit(ld)) {\n         hInfo->error = 26;\n         return;\n    }\n#else\n    faad_get1bit(ld);\n#endif\n\n    hInfo->error = side_info(hDecoder, &cpe, ld, ics1, 1);\n    if (hInfo->error > 0)\n        return;\n    if (this_layer_stereo)\n    {\n        /* Stereo3 */\n        ics2->tns_data_present = faad_get1bit(ld);\n#ifdef LTP_DEC\n        ics1->ltp.data_present =\n#endif\n            faad_get1bit(ld);\n        hInfo->error = side_info(hDecoder, &cpe, ld, ics2, 1);\n        if (hInfo->error > 0)\n            return;\n    }\n    /* Stereo4 / Mono2 */\n    if (ics1->tns_data_present)\n        tns_data(ics1, &(ics1->tns), ld);\n    if (this_layer_stereo)\n    {\n        /* Stereo5 */\n        if (ics2->tns_data_present)\n            tns_data(ics2, &(ics2->tns), ld);\n    }\n\n#ifdef DRM\n    /* CRC check */\n    if (hDecoder->object_type == DRM_ER_LC)\n    {\n        if ((hInfo->error = (uint8_t)faad_check_CRC(ld, (uint16_t)faad_get_processed_bits(ld) - 8)) > 0)\n            return;\n    }\n#endif\n\n    /* Stereo6 / Mono3 */\n    /* error resilient spectral data decoding */\n    if ((hInfo->error = reordered_spectral_data(hDecoder, ics1, ld, spec_data1)) > 0)\n    {\n        return;\n    }\n    if (this_layer_stereo)\n    {\n        /* Stereo7 */\n        /* error resilient spectral data decoding */\n        if ((hInfo->error = reordered_spectral_data(hDecoder, ics2, ld, spec_data2)) > 0)\n        {\n            return;\n        }\n    }\n\n\n#ifdef DRM\n#ifdef SBR_DEC\n    /* In case of DRM we need to read the SBR info before channel reconstruction */\n    if ((hDecoder->sbr_present_flag == 1) && (hDecoder->object_type == DRM_ER_LC))\n    {\n        bitfile ld_sbr = {0};\n        uint32_t i;\n        uint16_t count = 0;\n        uint8_t *revbuffer;\n        uint8_t *prevbufstart;\n        uint8_t *pbufend;\n\n        /* all forward bitreading should be finished at this point */\n        uint32_t bitsconsumed = faad_get_processed_bits(ld);\n        uint32_t buffer_size = faad_origbitbuffer_size(ld);\n        uint8_t *buffer = (uint8_t*)faad_origbitbuffer(ld);\n\n        if (bitsconsumed + 8 > buffer_size*8)\n        {\n            hInfo->error = 14;\n            return;\n        }\n\n        if (!hDecoder->sbr[0])\n        {\n            hDecoder->sbr[0] = sbrDecodeInit(hDecoder->frameLength, hDecoder->element_id[0],\n                2*get_sample_rate(hDecoder->sf_index), 0 /* ds SBR */, 1);\n        }\n        if (!hDecoder->sbr[0])\n        {\n            hInfo->error = 19;\n            return;\n        }\n\n        /* Reverse bit reading of SBR data in DRM audio frame */\n        revbuffer = (uint8_t*)faad_malloc(buffer_size*sizeof(uint8_t));\n        prevbufstart = revbuffer;\n        pbufend = &buffer[buffer_size - 1];\n        for (i = 0; i < buffer_size; i++)\n            *prevbufstart++ = tabFlipbits[*pbufend--];\n\n        /* Set SBR data */\n        /* consider 8 bits from AAC-CRC */\n        /* SBR buffer size is original buffer size minus AAC buffer size */\n        count = (uint16_t)bit2byte(buffer_size*8 - bitsconsumed);\n        faad_initbits(&ld_sbr, revbuffer, count);\n\n        hDecoder->sbr[0]->sample_rate = get_sample_rate(hDecoder->sf_index);\n        hDecoder->sbr[0]->sample_rate *= 2;\n\n        faad_getbits(&ld_sbr, 8); /* Skip 8-bit CRC */\n\n        hDecoder->sbr[0]->ret = sbr_extension_data(&ld_sbr, hDecoder->sbr[0], count, hDecoder->postSeekResetFlag);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->sbr[0]->ps_used)\n        {\n            hDecoder->ps_used[0] = 1;\n            hDecoder->ps_used_global = 1;\n        }\n#endif\n\n        if (ld_sbr.error)\n        {\n            hDecoder->sbr[0]->ret = 1;\n        }\n\n        /* check CRC */\n        /* no need to check it if there was already an error */\n        if (hDecoder->sbr[0]->ret == 0)\n            hDecoder->sbr[0]->ret = (uint8_t)faad_check_CRC(&ld_sbr, (uint16_t)faad_get_processed_bits(&ld_sbr) - 8);\n\n        /* SBR data was corrupted, disable it until the next header */\n        if (hDecoder->sbr[0]->ret != 0)\n        {\n            hDecoder->sbr[0]->header_count = 0;\n        }\n\n        faad_endbits(&ld_sbr);\n\n        if (revbuffer)\n            faad_free(revbuffer);\n    }\n#endif\n#endif\n\n    if (this_layer_stereo)\n    {\n        hInfo->error = reconstruct_channel_pair(hDecoder, ics1, ics2, &cpe, spec_data1, spec_data2);\n        if (hInfo->error > 0)\n            return;\n    } else {\n        hInfo->error = reconstruct_single_channel(hDecoder, ics1, &cpe, spec_data1);\n        if (hInfo->error > 0)\n            return;\n    }\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n\n    return;\n}",
  "abstract_func": "void DRM_aac_scalable_main_element(NeAACDecStruct *VAR_0, NeAACDecFrameInfo *VAR_1,\n                                   bitfile *VAR_2, program_config *VAR_3, drc_info *VAR_4)\n{\n    uint8_t VAR_5 = 0;\n    uint8_t VAR_6 = VAR_0->fr_channels = 0;\n    uint8_t VAR_7;\n    uint8_t VAR_8 = (VAR_0->channelConfiguration > 1) ? 1 : 0;\n    element VAR_9 = {0};\n    ic_stream *VAR_10 = &(VAR_9.ics1);\n    ic_stream *VAR_11 = &(VAR_9.ics2);\n    int16_t *VAR_12;\n    ALIGN int16_t VAR_13[1024] = {0};\n    ALIGN int16_t VAR_14[1024] = {0};\n\n    VAR_0->fr_ch_ele = 0;\n\n    VAR_1->error = DRM_aac_scalable_main_header(VAR_0, VAR_10, VAR_11, VAR_2, VAR_8);\n    if (VAR_1->error > 0)\n        return;\n\n    VAR_9.common_window = 1;\n    if (VAR_8)\n    {\n        VAR_0->element_id[0] = VAR_15;\n        if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)\n            VAR_0->element_output_channels[VAR_0->fr_ch_ele] = 2;\n    } else {\n        VAR_0->element_id[0] = VAR_16;\n    }\n\n    if (VAR_8)\n    {\n        VAR_9.channel        = 0;\n        VAR_9.paired_channel = 1;\n    }\n\n\n    /* COMMENT_0 */\n    VAR_10->tns_data_present = faad_get1bit(VAR_2);\n\n#if defined(VAR_17)\n    VAR_10->ltp.data_present = faad_get1bit(VAR_2);\n#elif defined (VAR_18)\n    if(faad_get1bit(VAR_2)) {\n         VAR_1->error = 26;\n         return;\n    }\n#else\n    faad_get1bit(VAR_2);\n#endif\n\n    VAR_1->error = side_info(VAR_0, &VAR_9, VAR_2, VAR_10, 1);\n    if (VAR_1->error > 0)\n        return;\n    if (VAR_8)\n    {\n        /* COMMENT_1 */\n        VAR_11->tns_data_present = faad_get1bit(VAR_2);\n#ifdef VAR_17\n        VAR_10->ltp.data_present =\n#endif\n            faad_get1bit(VAR_2);\n        VAR_1->error = side_info(VAR_0, &VAR_9, VAR_2, VAR_11, 1);\n        if (VAR_1->error > 0)\n            return;\n    }\n    /* COMMENT_2 */\n    if (VAR_10->tns_data_present)\n        tns_data(VAR_10, &(VAR_10->tns), VAR_2);\n    if (VAR_8)\n    {\n        /* COMMENT_3 */\n        if (VAR_11->tns_data_present)\n            tns_data(VAR_11, &(VAR_11->tns), VAR_2);\n    }\n\n#ifdef VAR_18\n    /* COMMENT_4 */\n    if (VAR_0->object_type == VAR_19)\n    {\n        if ((VAR_1->error = (uint8_t)faad_check_CRC(VAR_2, (uint16_t)faad_get_processed_bits(VAR_2) - 8)) > 0)\n            return;\n    }\n#endif\n\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if ((VAR_1->error = reordered_spectral_data(VAR_0, VAR_10, VAR_2, VAR_13)) > 0)\n    {\n        return;\n    }\n    if (VAR_8)\n    {\n        /* COMMENT_7 */\n        /* COMMENT_6 */\n        if ((VAR_1->error = reordered_spectral_data(VAR_0, VAR_11, VAR_2, VAR_14)) > 0)\n        {\n            return;\n        }\n    }\n\n\n#ifdef VAR_18\n#ifdef VAR_20\n    /* COMMENT_8 */\n    if ((VAR_0->sbr_present_flag == 1) && (VAR_0->object_type == VAR_19))\n    {\n        bitfile VAR_21 = {0};\n        uint32_t VAR_22;\n        uint16_t VAR_23 = 0;\n        uint8_t *VAR_24;\n        uint8_t *VAR_25;\n        uint8_t *VAR_26;\n\n        /* COMMENT_9 */\n        uint32_t VAR_27 = faad_get_processed_bits(VAR_2);\n        uint32_t VAR_28 = faad_origbitbuffer_size(VAR_2);\n        uint8_t *VAR_29 = (uint8_t*)faad_origbitbuffer(VAR_2);\n\n        if (VAR_27 + 8 > VAR_28*8)\n        {\n            VAR_1->error = 14;\n            return;\n        }\n\n        if (!VAR_0->sbr[0])\n        {\n            VAR_0->sbr[0] = sbrDecodeInit(VAR_0->frameLength, VAR_0->element_id[0],\n                2*get_sample_rate(VAR_0->sf_index), 0 /* COMMENT_10 */, 1);\n        }\n        if (!VAR_0->sbr[0])\n        {\n            VAR_1->error = 19;\n            return;\n        }\n\n        /* COMMENT_11 */\n        VAR_24 = (uint8_t*)faad_malloc(VAR_28*sizeof(uint8_t));\n        VAR_25 = VAR_24;\n        VAR_26 = &VAR_29[VAR_28 - 1];\n        for (VAR_22 = 0; VAR_22 < VAR_28; VAR_22++)\n            *VAR_25++ = VAR_30[*VAR_26--];\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        VAR_23 = (uint16_t)bit2byte(VAR_28*8 - VAR_27);\n        faad_initbits(&VAR_21, VAR_24, VAR_23);\n\n        VAR_0->sbr[0]->sample_rate = get_sample_rate(VAR_0->sf_index);\n        VAR_0->sbr[0]->sample_rate *= 2;\n\n        faad_getbits(&VAR_21, 8); /* COMMENT_15 */\n\n        VAR_0->sbr[0]->ret = sbr_extension_data(&VAR_21, VAR_0->sbr[0], VAR_23, VAR_0->postSeekResetFlag);\n#if (defined(VAR_31) || defined(VAR_32))\n        if (VAR_0->sbr[0]->ps_used)\n        {\n            VAR_0->ps_used[0] = 1;\n            VAR_0->ps_used_global = 1;\n        }\n#endif\n\n        if (VAR_21.error)\n        {\n            VAR_0->sbr[0]->ret = 1;\n        }\n\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        if (VAR_0->sbr[0]->ret == 0)\n            VAR_0->sbr[0]->ret = (uint8_t)faad_check_CRC(&VAR_21, (uint16_t)faad_get_processed_bits(&VAR_21) - 8);\n\n        /* COMMENT_18 */\n        if (VAR_0->sbr[0]->ret != 0)\n        {\n            VAR_0->sbr[0]->header_count = 0;\n        }\n\n        faad_endbits(&VAR_21);\n\n        if (VAR_24)\n            faad_free(VAR_24);\n    }\n#endif\n#endif\n\n    if (VAR_8)\n    {\n        VAR_1->error = reconstruct_channel_pair(VAR_0, VAR_10, VAR_11, &VAR_9, VAR_13, VAR_14);\n        if (VAR_1->error > 0)\n            return;\n    } else {\n        VAR_1->error = reconstruct_single_channel(VAR_0, VAR_10, &VAR_9, VAR_13);\n        if (VAR_1->error > 0)\n            return;\n    }\n\n    /* COMMENT_19 */\n    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2)\n    {\n        /* COMMENT_20 */\n        VAR_0->internal_channel[VAR_6] = VAR_6;\n        VAR_0->internal_channel[VAR_6+1] = VAR_6+1;\n    } else {\n        VAR_0->internal_channel[VAR_6] = VAR_6;\n    }\n\n    VAR_0->fr_channels += VAR_0->element_output_channels[VAR_0->fr_ch_ele];\n    VAR_0->fr_ch_ele++;\n\n    return;\n}",
  "func_graph_path": "knik0/faad2/c78251b2b5d41ea840fd61ab9502b3d3036bd747/syntax.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -128,6 +128,11 @@\n             hDecoder->sbr[0] = sbrDecodeInit(hDecoder->frameLength, hDecoder->element_id[0],\n                 2*get_sample_rate(hDecoder->sf_index), 0 /* ds SBR */, 1);\n         }\n+        if (!hDecoder->sbr[0])\n+        {\n+            hInfo->error = 19;\n+            return;\n+        }\n \n         /* Reverse bit reading of SBR data in DRM audio frame */\n         revbuffer = (uint8_t*)faad_malloc(buffer_size*sizeof(uint8_t));",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (!hDecoder->sbr[0])",
      "        {",
      "            hInfo->error = 19;",
      "            return;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/63",
  "description": {
    "pr_info": {
      "title": "Fix various issues",
      "number": 63
    },
    "comment": [
      "I tried to fix some of the outstanding issues. Please test and double check if you have time.",
      "Wow, thanks!\r\n\r\n~~Could you please elaborate which \"outstanding issues\" exactly each commit addresses?~~",
      "Never mind, I should have read the commit messages!",
      "I don't have a chance to test all your changes, but they look all reasonable to me. I'll apply them in good faith, thank you very much! ",
      "Since you seem to be knowledgeable of the code and the data format, could you probably have a look at https://github.com/knik0/faad2/commit/466b01d504d7e45f1e9169ac90b3e34ab94aed14 and the linked issues at the mixx bug tracker, please? ",
      "Do you happen to have any more fixes in the line? I'd like to tag the current state as a new release anytime soon but don't want to get in the way if you have more to apply. ",
      "See #65. There is no rush on it though. It sounds like it #64 is more important to get out in the wild since it fixes a regression."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}