{
  "cve_id": "CVE-2018-4868",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Add check for DataBuf.size_ in Jp2Image::readMetadata()\n\nWhen parsing a subBox that is a ColorHeader, a length is extracted\nfrom the input file and fed directly into DataBuf() (which calls\nmalloc). A crafted input file can provide arbitrarily (up to\nmax(uint32_t)-8) large values and result in excessive memory\nallocation.\n\nThis commit adds a check for the new size of DataBuf so that it is not\nlarger than the remaining size of the file.\n\nThis fixes #202 aka CVE-2018-4868",
  "commit_hash": "fcb42570519f8cf924b0302b09062a60aa565fbe",
  "git_url": "https://github.com/Exiv2/exiv2/commit/fcb42570519f8cf924b0302b09062a60aa565fbe",
  "file_path": "src/jp2image.cpp",
  "func_name": "Jp2Image::readMetadata",
  "func_before": "void Jp2Image::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(9, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(14);\n            throw Error(3, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n#ifdef DEBUG\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n#ifdef DEBUG\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n                            DataBuf data(Safe::add(subBox.length, static_cast<uint32_t>(8)));\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(58);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef DEBUG\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        io_->seek(subBox.length, Exiv2::BasicIo::cur);\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (rawData.size_ > 0)\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef DEBUG\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(14);\n        }\n\n    }",
  "abstract_func_before": "void Jp2Image::readMetadata()\n    {\n#ifdef VAR_0\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << VAR_1->path() << std::endl;\n#endif\n        if (VAR_1->open() != 0)\n        {\n            throw Error(9, VAR_1->path(), strError());\n        }\n        IoCloser VAR_2(*VAR_1);\n        /* COMMENT_0 */\n        if (!isJp2Type(*VAR_1, true))\n        {\n            if (VAR_1->error() || VAR_1->eof()) throw Error(14);\n            throw Error(3, \"JPEG-2000\");\n        }\n\n        long              VAR_3  = 0;\n        Jp2BoxHeader      VAR_4       = {0,0};\n        Jp2BoxHeader      VAR_5    = {0,0};\n        Jp2ImageHeaderBox VAR_6      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        VAR_7      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (VAR_1->read((byte*)&VAR_4, sizeof(VAR_4)) == sizeof(VAR_4))\n        {\n            VAR_3   = VAR_1->tell();\n            VAR_4.length = getLong((byte*)&VAR_4.length, VAR_8);\n            VAR_4.type   = getLong((byte*)&VAR_4.type, VAR_8);\n#ifdef VAR_0\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << VAR_3\n                      << \" box type: \" << toAscii(VAR_4.type)\n                      << \" length: \" << VAR_4.length\n                      << std::endl;\n#endif\n\n            if (VAR_4.length == 0) return ;\n\n            if (VAR_4.length == 1)\n            {\n                /* COMMENT_1 */\n            }\n\n            switch(VAR_4.type)\n            {\n                case VAR_9:\n                {\n#ifdef VAR_0\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long VAR_10 = VAR_1->tell();\n\n                    while (VAR_1->read((byte*)&VAR_5, sizeof(VAR_5)) == sizeof(VAR_5) && VAR_5.length )\n                    {\n                        VAR_5.length = getLong((byte*)&VAR_5.length, VAR_8);\n                        VAR_5.type   = getLong((byte*)&VAR_5.type, VAR_8);\n#ifdef VAR_0\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(VAR_5.type) << \" length = \" << VAR_5.length << std::endl;\n#endif\n                        if(VAR_5.type == VAR_11 && VAR_5.length != 15)\n                        {\n#ifdef VAR_0\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long VAR_12 = 3 ; /* COMMENT_2 */\n                            DataBuf VAR_13(Safe::add(VAR_5.length, VAR_14<uint32_t>(8)));\n                            VAR_1->read(VAR_13.pData_,VAR_13.size_);\n                            const long    VAR_15 = getULong(VAR_13.pData_+VAR_12, VAR_8);\n                            /* COMMENT_3 */\n                            /* COMMENT_4 */\n                            if (VAR_15 > VAR_13.size_ - VAR_12) {\n                                throw Error(58);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(VAR_16.pData_,VAR_13.pData_+VAR_12,VAR_16.size_);\n#ifdef VAR_0\n                            const char* VAR_17 = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* VAR_18 = fopen(VAR_17,\"wb\");\n                            if ( VAR_18 ) {\n                                fwrite(VAR_16.pData_,VAR_16.size_,1,VAR_18);\n                                fclose(VAR_18);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << VAR_16.size_<< \" bytes to \" << VAR_17 << std::endl ;\n#endif\n                            setIccProfile(VAR_16);\n                        }\n\n                        if( VAR_5.type == VAR_19)\n                        {\n                            VAR_1->read((byte*)&VAR_6, sizeof(VAR_6));\n#ifdef VAR_0\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            VAR_6.imageHeight            = getLong((byte*)&VAR_6.imageHeight, VAR_8);\n                            VAR_6.imageWidth             = getLong((byte*)&VAR_6.imageWidth, VAR_8);\n                            VAR_6.componentCount         = getShort((byte*)&VAR_6.componentCount, VAR_8);\n                            VAR_6.compressionTypeProfile = getShort((byte*)&VAR_6.compressionTypeProfile, VAR_8);\n\n                            VAR_20  = VAR_6.imageWidth;\n                            VAR_21 = VAR_6.imageHeight;\n                        }\n\n                        VAR_1->seek(VAR_10,BasicIo::beg);\n                        VAR_1->seek(VAR_5.length, Exiv2::BasicIo::cur);\n                        VAR_10 = VAR_1->tell();\n                    }\n                    break;\n                }\n\n                case VAR_22:\n                {\n#ifdef VAR_0\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (VAR_1->read((byte*)&VAR_7, sizeof(VAR_7)) == sizeof(VAR_7))\n                    {\n                        DataBuf VAR_23;\n                        long    VAR_24;\n                        bool    VAR_25 = memcmp(VAR_7.uuid, VAR_26, sizeof(VAR_7))==0;\n                        bool    VAR_27 = memcmp(VAR_7.uuid, VAR_28, sizeof(VAR_7))==0;\n                        bool    VAR_29  = memcmp(VAR_7.uuid, VAR_30 , sizeof(VAR_7))==0;\n\n                        if(VAR_25)\n                        {\n#ifdef VAR_0\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            VAR_23.alloc(VAR_4.length - (sizeof(VAR_4) + sizeof(VAR_7)));\n                            VAR_24 = VAR_1->read(VAR_23.pData_, VAR_23.size_);\n                            if (VAR_1->error()) throw Error(14);\n                            if (VAR_24 != VAR_23.size_) throw Error(20);\n\n                            if (VAR_23.size_ > 0)\n                            {\n                                /* COMMENT_5 */\n                                long VAR_31 = (     (VAR_23.pData_[0]      == VAR_23.pData_[1])\n                                           &&    (VAR_23.pData_[0]=='I' || VAR_23.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                /* COMMENT_6 */\n                                const byte VAR_32[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long VAR_33=0 ; VAR_31 < 0 && VAR_33 < VAR_23.size_-(long)sizeof(VAR_32) ; VAR_33++)\n                                {\n                                    if (memcmp(VAR_32, &VAR_23.pData_[VAR_33], sizeof(VAR_32)) == 0)\n                                    {\n                                        VAR_31 = VAR_33+sizeof(VAR_32);\n#ifndef VAR_34\n                                        VAR_35 << \"Reading non-standard UUID-EXIF_bad box in \" << VAR_1->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                /* COMMENT_7 */\n                                if (VAR_31 >= 0 )\n                                {\n#ifdef VAR_0\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << VAR_31 << std::endl;\n#endif\n                                    ByteOrder VAR_36 = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      VAR_23.pData_ + VAR_31,\n                                                                      VAR_23.size_ - VAR_31);\n                                    setByteOrder(VAR_36);\n                                }\n                            }\n                            else\n                            {\n#ifndef VAR_34\n                                VAR_35 << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                VAR_37.clear();\n                            }\n                        }\n\n                        if(VAR_27)\n                        {\n#ifdef VAR_0\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            VAR_23.alloc(VAR_4.length - (sizeof(VAR_4) + sizeof(VAR_7)));\n                            VAR_24 = VAR_1->read(VAR_23.pData_, VAR_23.size_);\n                            if (VAR_1->error()) throw Error(14);\n                            if (VAR_24 != VAR_23.size_) throw Error(20);\n\n                            if (IptcParser::decode(VAR_38, VAR_23.pData_, VAR_23.size_))\n                            {\n#ifndef VAR_34\n                                VAR_35 << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                VAR_38.clear();\n                            }\n                        }\n\n                        if(VAR_29)\n                        {\n#ifdef VAR_0\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            VAR_23.alloc(VAR_4.length - (uint32_t)(sizeof(VAR_4) + sizeof(VAR_7)));\n                            VAR_24 = VAR_1->read(VAR_23.pData_, VAR_23.size_);\n                            if (VAR_1->error()) throw Error(14);\n                            if (VAR_24 != VAR_23.size_) throw Error(20);\n                            VAR_39.assign(VAR_40<char *>(VAR_23.pData_), VAR_23.size_);\n\n                            std::string::size_type VAR_41 = VAR_39.find_first_of('<');\n                            if (VAR_41 != std::string::npos && VAR_41 > 0)\n                            {\n#ifndef VAR_34\n                                VAR_35 << \"Removing \" << VAR_14<uint32_t>(VAR_41)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                VAR_39 = VAR_39.substr(VAR_41);\n                            }\n\n                            if (VAR_39.size() > 0 && XmpParser::decode(VAR_42, VAR_39))\n                            {\n#ifndef VAR_34\n                                VAR_35 << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            /* COMMENT_8 */\n            VAR_1->seek(VAR_14<long>(VAR_3 - sizeof(VAR_4) + VAR_4.length), BasicIo::beg);\n            if (VAR_1->error()) throw Error(14);\n        }\n\n    }",
  "func_graph_path_before": "Exiv2/exiv2/fcb42570519f8cf924b0302b09062a60aa565fbe/jp2image.cpp/vul/before/0.json",
  "func": "void Jp2Image::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(9, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(14);\n            throw Error(3, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n#ifdef DEBUG\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n#ifdef DEBUG\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n\t\t\t    const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n\t\t\t    // data_length makes no sense if it is larger than the rest of the file\n\t\t\t    if (data_length > io_->size() - io_->tell()) {\n\t\t\t\tthrow Error(58);\n\t\t\t    }\n                            DataBuf data(data_length);\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(58);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef DEBUG\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        io_->seek(subBox.length, Exiv2::BasicIo::cur);\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (rawData.size_ > 0)\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef DEBUG\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(14);\n        }\n\n    }",
  "abstract_func": "void Jp2Image::readMetadata()\n    {\n#ifdef VAR_0\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << VAR_1->path() << std::endl;\n#endif\n        if (VAR_1->open() != 0)\n        {\n            throw Error(9, VAR_1->path(), strError());\n        }\n        IoCloser VAR_2(*VAR_1);\n        /* COMMENT_0 */\n        if (!isJp2Type(*VAR_1, true))\n        {\n            if (VAR_1->error() || VAR_1->eof()) throw Error(14);\n            throw Error(3, \"JPEG-2000\");\n        }\n\n        long              VAR_3  = 0;\n        Jp2BoxHeader      VAR_4       = {0,0};\n        Jp2BoxHeader      VAR_5    = {0,0};\n        Jp2ImageHeaderBox VAR_6      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        VAR_7      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (VAR_1->read((byte*)&VAR_4, sizeof(VAR_4)) == sizeof(VAR_4))\n        {\n            VAR_3   = VAR_1->tell();\n            VAR_4.length = getLong((byte*)&VAR_4.length, VAR_8);\n            VAR_4.type   = getLong((byte*)&VAR_4.type, VAR_8);\n#ifdef VAR_0\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << VAR_3\n                      << \" box type: \" << toAscii(VAR_4.type)\n                      << \" length: \" << VAR_4.length\n                      << std::endl;\n#endif\n\n            if (VAR_4.length == 0) return ;\n\n            if (VAR_4.length == 1)\n            {\n                /* COMMENT_1 */\n            }\n\n            switch(VAR_4.type)\n            {\n                case VAR_9:\n                {\n#ifdef VAR_0\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long VAR_10 = VAR_1->tell();\n\n                    while (VAR_1->read((byte*)&VAR_5, sizeof(VAR_5)) == sizeof(VAR_5) && VAR_5.length )\n                    {\n                        VAR_5.length = getLong((byte*)&VAR_5.length, VAR_8);\n                        VAR_5.type   = getLong((byte*)&VAR_5.type, VAR_8);\n#ifdef VAR_0\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(VAR_5.type) << \" length = \" << VAR_5.length << std::endl;\n#endif\n                        if(VAR_5.type == VAR_11 && VAR_5.length != 15)\n                        {\n#ifdef VAR_0\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long VAR_12 = 3 ; /* COMMENT_2 */\n\t\t\t    const size_t VAR_13 = Safe::add(VAR_5.length, VAR_14<uint32_t>(8));\n\t\t\t    /* COMMENT_3 */\n\t\t\t    if (VAR_13 > VAR_1->size() - VAR_1->tell()) {\n\t\t\t\tthrow Error(58);\n\t\t\t    }\n                            DataBuf data(data_length);\n                            VAR_1->read(VAR_15.pData_,VAR_15.size_);\n                            const long    VAR_16 = getULong(VAR_15.pData_+VAR_12, VAR_8);\n                            /* COMMENT_4 */\n                            /* COMMENT_5 */\n                            if (VAR_16 > VAR_15.size_ - VAR_12) {\n                                throw Error(58);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(VAR_17.pData_,VAR_15.pData_+VAR_12,VAR_17.size_);\n#ifdef VAR_0\n                            const char* VAR_18 = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* VAR_19 = fopen(VAR_18,\"wb\");\n                            if ( VAR_19 ) {\n                                fwrite(VAR_17.pData_,VAR_17.size_,1,VAR_19);\n                                fclose(VAR_19);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << VAR_17.size_<< \" bytes to \" << VAR_18 << std::endl ;\n#endif\n                            setIccProfile(VAR_17);\n                        }\n\n                        if( VAR_5.type == VAR_20)\n                        {\n                            VAR_1->read((byte*)&VAR_6, sizeof(VAR_6));\n#ifdef VAR_0\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            VAR_6.imageHeight            = getLong((byte*)&VAR_6.imageHeight, VAR_8);\n                            VAR_6.imageWidth             = getLong((byte*)&VAR_6.imageWidth, VAR_8);\n                            VAR_6.componentCount         = getShort((byte*)&VAR_6.componentCount, VAR_8);\n                            VAR_6.compressionTypeProfile = getShort((byte*)&VAR_6.compressionTypeProfile, VAR_8);\n\n                            VAR_21  = VAR_6.imageWidth;\n                            VAR_22 = VAR_6.imageHeight;\n                        }\n\n                        VAR_1->seek(VAR_10,BasicIo::beg);\n                        VAR_1->seek(VAR_5.length, Exiv2::BasicIo::cur);\n                        VAR_10 = VAR_1->tell();\n                    }\n                    break;\n                }\n\n                case VAR_23:\n                {\n#ifdef VAR_0\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (VAR_1->read((byte*)&VAR_7, sizeof(VAR_7)) == sizeof(VAR_7))\n                    {\n                        DataBuf VAR_24;\n                        long    VAR_25;\n                        bool    VAR_26 = memcmp(VAR_7.uuid, VAR_27, sizeof(VAR_7))==0;\n                        bool    VAR_28 = memcmp(VAR_7.uuid, VAR_29, sizeof(VAR_7))==0;\n                        bool    VAR_30  = memcmp(VAR_7.uuid, VAR_31 , sizeof(VAR_7))==0;\n\n                        if(VAR_26)\n                        {\n#ifdef VAR_0\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            VAR_24.alloc(VAR_4.length - (sizeof(VAR_4) + sizeof(VAR_7)));\n                            VAR_25 = VAR_1->read(VAR_24.pData_, VAR_24.size_);\n                            if (VAR_1->error()) throw Error(14);\n                            if (VAR_25 != VAR_24.size_) throw Error(20);\n\n                            if (VAR_24.size_ > 0)\n                            {\n                                /* COMMENT_6 */\n                                long VAR_32 = (     (VAR_24.pData_[0]      == VAR_24.pData_[1])\n                                           &&    (VAR_24.pData_[0]=='I' || VAR_24.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                /* COMMENT_7 */\n                                const byte VAR_33[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long VAR_34=0 ; VAR_32 < 0 && VAR_34 < VAR_24.size_-(long)sizeof(VAR_33) ; VAR_34++)\n                                {\n                                    if (memcmp(VAR_33, &VAR_24.pData_[VAR_34], sizeof(VAR_33)) == 0)\n                                    {\n                                        VAR_32 = VAR_34+sizeof(VAR_33);\n#ifndef VAR_35\n                                        VAR_36 << \"Reading non-standard UUID-EXIF_bad box in \" << VAR_1->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                /* COMMENT_8 */\n                                if (VAR_32 >= 0 )\n                                {\n#ifdef VAR_0\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << VAR_32 << std::endl;\n#endif\n                                    ByteOrder VAR_37 = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      VAR_24.pData_ + VAR_32,\n                                                                      VAR_24.size_ - VAR_32);\n                                    setByteOrder(VAR_37);\n                                }\n                            }\n                            else\n                            {\n#ifndef VAR_35\n                                VAR_36 << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                VAR_38.clear();\n                            }\n                        }\n\n                        if(VAR_28)\n                        {\n#ifdef VAR_0\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            VAR_24.alloc(VAR_4.length - (sizeof(VAR_4) + sizeof(VAR_7)));\n                            VAR_25 = VAR_1->read(VAR_24.pData_, VAR_24.size_);\n                            if (VAR_1->error()) throw Error(14);\n                            if (VAR_25 != VAR_24.size_) throw Error(20);\n\n                            if (IptcParser::decode(VAR_39, VAR_24.pData_, VAR_24.size_))\n                            {\n#ifndef VAR_35\n                                VAR_36 << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                VAR_39.clear();\n                            }\n                        }\n\n                        if(VAR_30)\n                        {\n#ifdef VAR_0\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            VAR_24.alloc(VAR_4.length - (uint32_t)(sizeof(VAR_4) + sizeof(VAR_7)));\n                            VAR_25 = VAR_1->read(VAR_24.pData_, VAR_24.size_);\n                            if (VAR_1->error()) throw Error(14);\n                            if (VAR_25 != VAR_24.size_) throw Error(20);\n                            VAR_40.assign(VAR_41<char *>(VAR_24.pData_), VAR_24.size_);\n\n                            std::string::size_type VAR_42 = VAR_40.find_first_of('<');\n                            if (VAR_42 != std::string::npos && VAR_42 > 0)\n                            {\n#ifndef VAR_35\n                                VAR_36 << \"Removing \" << VAR_14<uint32_t>(VAR_42)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                VAR_40 = VAR_40.substr(VAR_42);\n                            }\n\n                            if (VAR_40.size() > 0 && XmpParser::decode(VAR_43, VAR_40))\n                            {\n#ifndef VAR_35\n                                VAR_36 << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            /* COMMENT_9 */\n            VAR_1->seek(VAR_14<long>(VAR_3 - sizeof(VAR_4) + VAR_4.length), BasicIo::beg);\n            if (VAR_1->error()) throw Error(14);\n        }\n\n    }",
  "func_graph_path": "Exiv2/exiv2/fcb42570519f8cf924b0302b09062a60aa565fbe/jp2image.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,12 @@\n #endif\n \n                             const long pad = 3 ; // 3 padding bytes 2 0 0\n-                            DataBuf data(Safe::add(subBox.length, static_cast<uint32_t>(8)));\n+\t\t\t    const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n+\t\t\t    // data_length makes no sense if it is larger than the rest of the file\n+\t\t\t    if (data_length > io_->size() - io_->tell()) {\n+\t\t\t\tthrow Error(58);\n+\t\t\t    }\n+                            DataBuf data(data_length);\n                             io_->read(data.pData_,data.size_);\n                             const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                             // subtracting pad from data.size_ is safe:",
  "diff_line_info": {
    "deleted_lines": [
      "                            DataBuf data(Safe::add(subBox.length, static_cast<uint32_t>(8)));"
    ],
    "added_lines": [
      "\t\t\t    const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));",
      "\t\t\t    // data_length makes no sense if it is larger than the rest of the file",
      "\t\t\t    if (data_length > io_->size() - io_->tell()) {",
      "\t\t\t\tthrow Error(58);",
      "\t\t\t    }",
      "                            DataBuf data(data_length);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/207",
  "description": {
    "pr_info": {
      "title": "Fix CVE-2018-4868",
      "number": 207
    },
    "comment": [
      "When parsing a subBox that is a ColorHeader, a length is extracted from the input file and fed directly into DataBuf() (which calls malloc). A crafted input file can provide arbitrarily (up to max(uint32_t)-8) large values and result in excessive memory allocation.\r\n\r\nThis PR adds a check for the new size of DataBuf so that it is not larger than the remaining size of the file. The reproducer is also added to the test suite.\r\n\r\nThis fixes #202 aka CVE-2018-4868.",
      "Please do not use the update branch button, it results in an extremely messy history when a PR exits for a longer time (especially if you press the button multiple times). It is harder to cherry-pick commits in a non-linear history and is a burden for package maintainers who have to backport patches.\r\n\r\nThe contribution guide mentions that we should instead rebase the changes on top of master before merging them, that way the commit history stays linear. I have just done that & we can merge this once travis is green again.",
      "Sorry if I sounded a little harsh, I was typing that in a hurry. \r\n\r\nThanks for your review :)",
      "So many hidden rules in GitHub.  Well they might be in a documentation, however I can't understand the documentation!  We'll get there with many things.  You'll see.\r\n\r\nIncidentally, I will do everything that I can to avoid changing test/data/bugfixes-test.out and going to run `$ cd tests ; python3 runner.py` from test/Makefile.  I don't think we need to rewrite test/bugfixes-test.out at the moment.  For new tests, I'll try to add them to the \"new\" test harness.  If I'm unable to do that, I'll add a simple bash script for the moment on a case-by-case basis.  For sure, I don't know how to test #223 using the new test harness and that's what I'd like to discuss with you 1-to-1.",
      "The rebase stuff is our \"rule\" and not from github, it's point `5.` in [CONTRIBUTING.md](https://github.com/Exiv2/exiv2/blob/master/CONTRIBUTING.md)",
      "Dan:  I've written my test for #223 in bash and it fetches binary images using curl from the buildserver.\r\n\r\nSure, I want to write it using your python test harness.  I tried to do this during the week and didn't know how to get the job done.  Of course, I can read all your python code and figure it out - however I would prefer to discuss it with you 1-to-1.   Or, if you prefer, I can document my puzzles and you can answer them for me.   Here's the current version of my bash script:\r\n```\r\n#!/bin/bash\r\n\r\nsource ./functions.source\r\ncd \"$testdir\"\r\n\r\nmkdir -p reference\r\nthis=$(basename $0)\r\nreference=reference\r\noutput=$this.out\r\n\r\n##\r\n# Reference output\r\ncat > $reference/$output <<END_OF_FILE\r\nExif.Fujifilm.Color                          Short       1  Monochrome\r\nExif.Fujifilm.Color                          Short       1  Sepia\r\nExif.Fujifilm.Color                          Short       1  Monochrome+G Filter\r\nExif.Fujifilm.Color                          Short       1  Monochrome+R Filter\r\nExif.Fujifilm.Color                          Short       1  Monochrome+Ye Filter\r\nEND_OF_FILE\r\n\r\n##\r\n# run the tests\r\nrm -rf $output\r\nfor testfile in 223-Monochrome.jpg 223-Sepia.jpg \\\r\n                223-Monochrome+G.jpg 223-Monochrome+R.jpg 223-Monochrome+Y.jpg ; do\r\n\tif [ ! -e $reference/$testfile ]; then (\r\n\t   cd   $reference\r\n\t   curl --silent -O http://exiv2.dyndns.org:8080/userContent/testfiles/223/$testfile\r\n\t) fi\r\n\trunTest exiv2 -pa --grep Fujifilm.Color $reference/$testfile >>$output\r\ndone\r\n\r\n##\r\n# report result\r\ncat $output | tr -d $'\\r' > $output.stripped\r\nmv  $output.stripped $output\r\necho -n \"$this \" ; reportTest   $output $reference/$output\r\n\r\n# That's all Folks!\r\n##\r\n```",
      "I think we really shouldn't be pulling in data over the internet during\ntests, as that makes the tests depend on a functioning internet\nconnection or silently fail.\n\nImho we should consider Luis' suggestion from a few weeks ago to create\na new repository for testfiles for exiv2 that manages them via git\nlfs. You'll essentially get the same, the files are stored on a\nwebserver and do not blow up the repo size, but it all still looks like\ngit. We could then embed that repository via a git submodule.\n\nConcerning your actual problem, this will involve some additional work,\nas the test suite was not intended to download files. Could you take a\nlook at tests/doc.md? That should cover everything that the test suite\ncan do. This would be especially helpful for me, as I could find out\nwhere the documentation is lacking & improve it.\n\nI'll take a look how to pull in the test files, shouldn't be that hard\nwith Python's urllib.\n\nRobin Mills <notifications@github.com> writes:\n\n> Dan:  I've written my test for #223 in bash and it fetches binary images using curl from the buildserver.\n>\n> Sure, I want to write it using your python test harness.  I tried to do this during the week and didn't know how to get the job done.  Of course, I can read all your python code and figure it out - however I would prefer to discuss it with you 1-to-1.   Or, if you prefer, I can document my puzzles and you can answer them for me.   Here's the current version of my bash script:\n> ```\n> #!/bin/bash\n>\n> source ./functions.source\n> cd \"$testdir\"\n>\n> mkdir -p reference\n> this=$(basename $0)\n> reference=reference\n> output=$this.out\n>\n> ##\n> # Reference output\n> cat > $reference/$output <<END_OF_FILE\n> Exif.Fujifilm.Color                          Short       1  Monochrome\n> Exif.Fujifilm.Color                          Short       1  Sepia\n> Exif.Fujifilm.Color                          Short       1  Monochrome+G Filter\n> Exif.Fujifilm.Color                          Short       1  Monochrome+R Filter\n> Exif.Fujifilm.Color                          Short       1  Monochrome+Ye Filter\n> END_OF_FILE\n>\n> ##\n> # run the tests\n> rm -rf $output\n> for testfile in 223-Monochrome.jpg 223-Sepia.jpg \\\n>                 223-Monochrome+G.jpg 223-Monochrome+R.jpg 223-Monochrome+Y.jpg ; do\n> \tif [ ! -e $reference/$testfile ]; then (\n> \t   cd   $reference\n> \t   curl --silent -O http://exiv2.dyndns.org:8080/userContent/testfiles/223/$testfile\n> \t) fi\n> \trunTest exiv2 -pa --grep Fujifilm.Color $reference/$testfile >>$output\n> done\n>\n> ##\n> # report result\n> cat $output | tr -d $'\\r' > $output.stripped\n> mv  $output.stripped $output\n> echo -n \"$this \" ; reportTest   $output $reference/$output\n>\n> # That's all Folks!\n> ##\n> ```\n>\n> -- \n> You are receiving this because you modified the open/close state.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/Exiv2/exiv2/pull/207#issuecomment-362834442\n",
      "Thanks, Dan.  I used svn to store test files for video and eps.  Git?  Sure, why not.  Because of my lack of skill with git, you'll understand why I haven't adopted that solution in this script. \r\n\r\nHowever both the \"new\" test harness and my efforts here use the concept of storing the \"reference output\" in the script and not in an external monolith such as test/data/bugfixes-test.out.\r\n\r\nThe puzzle isn't how to get the file (with curl/svn/git/urllib), the puzzle is that I haven't discovered how to run the test on multiple files and how to represent the \"reference output\".   For me, another important object is to be able to run a single script (rather than a collection such as test/bugfixes-text.sh).\r\n\r\nSo, we are in strong agreement about the direction and I'm asking for a little assistance to get onto our agreed/chosen road. ",
      "Robin Mills <notifications@github.com> writes:\n\n> Thanks, Dan.  I used svn to store test files for video and eps.  Git?  Sure, why not.  Because of my lack of skill with git, you'll understand why I haven't adopted that solution in this script. \n>\nSure, no problem. Creating another repository for that is also a little\nbit more work.\n\nI'll put this on my todo list.\n\n> However both the \"new\" test harness and my efforts here use the concept of storing the \"reference output\" in the script and not in an external monolith such as test/data/bugfixes-test.out.\n>\n> The puzzle isn't how to get the file (with curl/svn/git/urllib), the puzzle is that I haven't discovered how to run the test on multiple files and how to represent the \"reference output\".   For me, another important object is to be able to run a single script (rather than a collection such as test/bugfixes-text.sh).\n>\n\nTake a look at tests/bugfixes/github/test_issue_20.py\n\nTo run exiv2 multiple times, you just have provide the test suite with a\nlist of commands to run (and of course a list of stdout, stderr and\nreturn values).\n\nTo download your files, you have to write a custom setUp() function\n(that is the standard pre-test function in python's unittest framework)\nand a tearDown() that will delete them again. But this might be a little\ntricky for the start, so we can discuss that on slack.\n\n> So, we are in strong agreement about the direction and I'm asking for a little assistance to get onto our agreed/chosen road. \n>\n> -- \n> You are receiving this because you modified the open/close state.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/Exiv2/exiv2/pull/207#issuecomment-362993388\n",
      "Thanks for those pointers.\r\n\r\nIt's a dry cold frosty sunny morning (1) in England so I'm going out to run and will investigate your suggestions after lunch.  I don't want to delete downloaded test images as they will never change.  It's the script (and reference output) that may change and will be checked in with the code.\r\n\r\nI hope things are good with you at work.  Thank You for all the effort you are putting into Exiv2."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}