{
  "cve_id": "CVE-2018-8099",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "index: convert `read_entry` to return entry size via an out-param\n\nThe function `read_entry` does not conform to our usual coding style of\nreturning stuff via the out parameter and to use the return value for\nreporting errors. Due to most of our code conforming to that pattern, it\nhas become quite natural for us to actually return `-1` in case there is\nany error, which has also slipped in with commit 5625d86b9 (index:\nsupport index v4, 2016-05-17). As the function returns an `size_t` only,\nthough, the return value is wrapped around, causing the caller of\n`read_tree` to continue with an invalid index entry. Ultimately, this\ncan lead to a double-free.\n\nImprove code and fix the bug by converting the function to return the\nindex entry size via an out parameter and only using the return value to\nindicate errors.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
  "commit_hash": "58a6fe94cb851f71214dbefac3f9bffee437d6fe",
  "git_url": "https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe",
  "file_path": "src/index.c",
  "func_name": "read_entry",
  "func_before": "static size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn 0;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn 0;\n\t}\n\n\tgit__free(tmp_path);\n\treturn entry_size;\n}",
  "abstract_func_before": "static size_t read_entry(\n\tgit_index_entry **VAR_0,\n\tgit_index *VAR_1,\n\tconst void *VAR_2,\n\tsize_t VAR_3,\n\tconst char *VAR_4)\n{\n\tsize_t VAR_5, VAR_6;\n\tconst char *VAR_7;\n\tstruct entry_short VAR_8;\n\tgit_index_entry VAR_9 = {{0}};\n\tbool VAR_10 = VAR_1->version >= VAR_11;\n\tchar *VAR_12 = NULL;\n\n\tif (VAR_13 + VAR_14 > VAR_3)\n\t\treturn 0;\n\n\t/* COMMENT_0 */\n\tmemcpy(&VAR_8, VAR_2, sizeof(struct entry_short));\n\n\tVAR_9.ctime.seconds = (git_time_t)ntohl(VAR_8.ctime.seconds);\n\tVAR_9.ctime.nanoseconds = ntohl(VAR_8.ctime.nanoseconds);\n\tVAR_9.mtime.seconds = (git_time_t)ntohl(VAR_8.mtime.seconds);\n\tVAR_9.mtime.nanoseconds = ntohl(VAR_8.mtime.nanoseconds);\n\tVAR_9.dev = ntohl(VAR_8.dev);\n\tVAR_9.ino = ntohl(VAR_8.ino);\n\tVAR_9.mode = ntohl(VAR_8.mode);\n\tVAR_9.uid = ntohl(VAR_8.uid);\n\tVAR_9.gid = ntohl(VAR_8.gid);\n\tVAR_9.file_size = ntohl(VAR_8.file_size);\n\tgit_oid_cpy(&VAR_9.id, &VAR_8.oid);\n\tVAR_9.flags = ntohs(VAR_8.flags);\n\n\tif (VAR_9.flags & VAR_15) {\n\t\tuint16_t VAR_16;\n\t\tsize_t VAR_17;\n\n\t\tVAR_17 = offsetof(struct VAR_18, VAR_19);\n\t\tmemcpy(&VAR_16, (const char *) VAR_2 + VAR_17,\n\t\t\tsizeof(VAR_16));\n\t\tVAR_16 = ntohs(VAR_16);\n\n\t\tmemcpy(&VAR_9.flags_extended, &VAR_16, sizeof(VAR_16));\n\t\tVAR_7 = (const char *) VAR_2 + offsetof(struct VAR_18, VAR_20);\n\t} else\n\t\tVAR_7 = (const char *) VAR_2 + offsetof(struct entry_short, VAR_20);\n\n\tif (!VAR_10) {\n\t\tVAR_5 = VAR_9.flags & VAR_21;\n\n\t\t/* COMMENT_1 */\n                                       \n\t\tif (VAR_5 == 0xFFF) {\n\t\t\tconst char *VAR_22;\n\n\t\t\tVAR_22 = memchr(VAR_7, '\\0', VAR_3);\n\t\t\tif (VAR_22 == NULL)\n\t\t\t\treturn 0;\n\n\t\t\tVAR_5 = VAR_22 - VAR_7;\n\t\t}\n\n\t\tVAR_6 = index_entry_size(VAR_5, 0, VAR_9.flags);\n\t\tVAR_9.path = (char *)VAR_7;\n\t} else {\n\t\tsize_t VAR_23;\n\t\tsize_t VAR_24 = git_decode_varint((const unsigned char *)VAR_7,\n\t\t\t\t\t\t     &VAR_23);\n\t\tsize_t VAR_25 = strlen(VAR_4);\n\t\tsize_t VAR_26 = VAR_25 - VAR_24;\n\t\tsize_t VAR_27 = strlen(VAR_7 + VAR_23);\n\t\tsize_t VAR_28;\n\n\t\tif (VAR_23 == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_26, VAR_27);\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_28, 1);\n\t\tVAR_12 = git__malloc(VAR_28);\n\t\tGITERR_CHECK_ALLOC(VAR_12);\n\n\t\tmemcpy(VAR_12, VAR_4, VAR_26);\n\t\tmemcpy(VAR_12 + VAR_26, VAR_7 + VAR_23, VAR_27 + 1);\n\t\tVAR_6 = index_entry_size(VAR_27, VAR_23, VAR_9.flags);\n\t\tVAR_9.path = VAR_12;\n\t}\n\n\tif (VAR_13 + VAR_6 > VAR_3)\n\t\treturn 0;\n\n\tif (index_entry_dup(VAR_0, VAR_1, &VAR_9) < 0) {\n\t\tgit__free(VAR_12);\n\t\treturn 0;\n\t}\n\n\tgit__free(VAR_12);\n\treturn VAR_6;\n}",
  "func_graph_path_before": "libgit2/58a6fe94cb851f71214dbefac3f9bffee437d6fe/index.c/vul/before/1.json",
  "func": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
  "abstract_func": "static int read_entry(\n\tgit_index_entry **VAR_0,\n\tsize_t *VAR_1,\n\tgit_index *VAR_2,\n\tconst void *VAR_3,\n\tsize_t VAR_4,\n\tconst char *VAR_5)\n{\n\tsize_t VAR_6, VAR_7;\n\tconst char *VAR_8;\n\tstruct entry_short VAR_9;\n\tgit_index_entry VAR_10 = {{0}};\n\tbool VAR_11 = VAR_2->version >= VAR_12;\n\tchar *VAR_13 = NULL;\n\n\tif (VAR_14 + VAR_15 > VAR_4)\n\t\treturn -1;\n\n\t/* COMMENT_0 */\n\tmemcpy(&VAR_9, VAR_3, sizeof(struct entry_short));\n\n\tVAR_10.ctime.seconds = (git_time_t)ntohl(VAR_9.ctime.seconds);\n\tVAR_10.ctime.nanoseconds = ntohl(VAR_9.ctime.nanoseconds);\n\tVAR_10.mtime.seconds = (git_time_t)ntohl(VAR_9.mtime.seconds);\n\tVAR_10.mtime.nanoseconds = ntohl(VAR_9.mtime.nanoseconds);\n\tVAR_10.dev = ntohl(VAR_9.dev);\n\tVAR_10.ino = ntohl(VAR_9.ino);\n\tVAR_10.mode = ntohl(VAR_9.mode);\n\tVAR_10.uid = ntohl(VAR_9.uid);\n\tVAR_10.gid = ntohl(VAR_9.gid);\n\tVAR_10.file_size = ntohl(VAR_9.file_size);\n\tgit_oid_cpy(&VAR_10.id, &VAR_9.oid);\n\tVAR_10.flags = ntohs(VAR_9.flags);\n\n\tif (VAR_10.flags & VAR_16) {\n\t\tuint16_t VAR_17;\n\t\tsize_t VAR_18;\n\n\t\tVAR_18 = offsetof(struct VAR_19, VAR_20);\n\t\tmemcpy(&VAR_17, (const char *) VAR_3 + VAR_18,\n\t\t\tsizeof(VAR_17));\n\t\tVAR_17 = ntohs(VAR_17);\n\n\t\tmemcpy(&VAR_10.flags_extended, &VAR_17, sizeof(VAR_17));\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct VAR_19, VAR_21);\n\t} else\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct entry_short, VAR_21);\n\n\tif (!VAR_11) {\n\t\tVAR_6 = VAR_10.flags & VAR_22;\n\n\t\t/* COMMENT_1 */\n                                       \n\t\tif (VAR_6 == 0xFFF) {\n\t\t\tconst char *VAR_23;\n\n\t\t\tVAR_23 = memchr(VAR_8, '\\0', VAR_4);\n\t\t\tif (VAR_23 == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tVAR_6 = VAR_23 - VAR_8;\n\t\t}\n\n\t\tVAR_7 = index_entry_size(VAR_6, 0, VAR_10.flags);\n\t\tVAR_10.path = (char *)VAR_8;\n\t} else {\n\t\tsize_t VAR_24;\n\t\tsize_t VAR_25 = git_decode_varint((const unsigned char *)VAR_8,\n\t\t\t\t\t\t     &VAR_24);\n\t\tsize_t VAR_26 = strlen(VAR_5);\n\t\tsize_t VAR_27 = VAR_26 - VAR_25;\n\t\tsize_t VAR_28 = strlen(VAR_8 + VAR_24);\n\t\tsize_t VAR_29;\n\n\t\tif (VAR_24 == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_29, VAR_27, VAR_28);\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_29, VAR_29, 1);\n\t\tVAR_13 = git__malloc(VAR_29);\n\t\tGITERR_CHECK_ALLOC(VAR_13);\n\n\t\tmemcpy(VAR_13, VAR_5, VAR_27);\n\t\tmemcpy(VAR_13 + VAR_27, VAR_8 + VAR_24, VAR_28 + 1);\n\t\tVAR_7 = index_entry_size(VAR_28, VAR_24, VAR_10.flags);\n\t\tVAR_10.path = VAR_13;\n\t}\n\n\tif (VAR_7 == 0)\n\t\treturn -1;\n\n\tif (VAR_14 + VAR_7 > VAR_4)\n\t\treturn -1;\n\n\tif (index_entry_dup(VAR_0, VAR_2, &VAR_10) < 0) {\n\t\tgit__free(VAR_13);\n\t\treturn -1;\n\t}\n\n\tgit__free(VAR_13);\n\t*VAR_1 = VAR_7;\n\treturn 0;\n}",
  "func_graph_path": "libgit2/58a6fe94cb851f71214dbefac3f9bffee437d6fe/index.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n-static size_t read_entry(\n+static int read_entry(\n \tgit_index_entry **out,\n+\tsize_t *out_size,\n \tgit_index *index,\n \tconst void *buffer,\n \tsize_t buffer_size,\n@@ -13,7 +14,7 @@\n \tchar *tmp_path = NULL;\n \n \tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \t/* buffer is not guaranteed to be aligned */\n \tmemcpy(&source, buffer, sizeof(struct entry_short));\n@@ -55,7 +56,7 @@\n \n \t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n \t\t\tif (path_end == NULL)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn -1;\n \n \t\t\tpath_length = path_end - path_ptr;\n \t\t}\n@@ -85,14 +86,18 @@\n \t\tentry.path = tmp_path;\n \t}\n \n+\tif (entry_size == 0)\n+\t\treturn -1;\n+\n \tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \tif (index_entry_dup(out, index, &entry) < 0) {\n \t\tgit__free(tmp_path);\n-\t\treturn 0;\n+\t\treturn -1;\n \t}\n \n \tgit__free(tmp_path);\n-\treturn entry_size;\n+\t*out_size = entry_size;\n+\treturn 0;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "static size_t read_entry(",
      "\t\treturn 0;",
      "\t\t\t\treturn 0;",
      "\t\treturn 0;",
      "\t\treturn 0;",
      "\treturn entry_size;"
    ],
    "added_lines": [
      "static int read_entry(",
      "\tsize_t *out_size,",
      "\t\treturn -1;",
      "\t\t\t\treturn -1;",
      "\tif (entry_size == 0)",
      "\t\treturn -1;",
      "",
      "\t\treturn -1;",
      "\t\treturn -1;",
      "\t*out_size = entry_size;",
      "\treturn 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4575",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libgit2/libgit2/pull/4575: 403 Client Error: Forbidden for url: https://api.github.com/repos/libgit2/libgit2/pulls/4575",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses a bug that could cause a double-free, which is a security issue. The code changes fix error handling, making it a security vulnerability fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}