{
  "cve_id": "CVE-2021-46344",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Check rest initializer existence after pattern finalization\n\nSince the scanner info is not present for invalid destructuring patterns we can only ensure the existence of the rest element after the pattern is finalized.\nThis patch fixes #4928.\n\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",
  "commit_hash": "9a8cf58f2252aa825049e9d2fd5071983c6a20be",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/9a8cf58f2252aa825049e9d2fd5071983c6a20be",
  "file_path": "jerry-core/parser/js/js-parser-expr.c",
  "func_name": "parser_parse_object_initializer",
  "func_before": "static void\nparser_parse_object_initializer (parser_context_t *context_p, /**< context */\n                                 parser_pattern_flags_t flags) /**< flags */\n{\n  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);\n\n  /* 12.14.5.2:  ObjectAssignmentPattern : { } */\n  if (lexer_check_next_character (context_p, LIT_CHAR_RIGHT_BRACE))\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_REQUIRE_OBJECT_COERCIBLE);\n    lexer_consume_next_character (context_p);\n    parser_pattern_finalize (context_p, flags, &end_pos);\n    return;\n  }\n\n  cbc_ext_opcode_t context_opcode = CBC_EXT_OBJ_INIT_CONTEXT_CREATE;\n\n  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)\n  {\n    context_opcode = CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE;\n  }\n\n  parser_emit_cbc_ext (context_p, context_opcode);\n\n  while (true)\n  {\n    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_OBJECT_PATTERN);\n\n    uint16_t prop_index = context_p->lit_object.index;\n    parser_line_counter_t start_line = context_p->token.line;\n    parser_line_counter_t start_column = context_p->token.column;\n    uint16_t push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_PROP_LITERAL;\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      break;\n    }\n\n    if (context_p->token.type == LEXER_THREE_DOTS)\n    {\n      lexer_next_token (context_p);\n\n      flags |= PARSER_PATTERN_REST_ELEMENT;\n\n      if (parser_pattern_process_assignment (context_p,\n                                             flags,\n                                             CBC_EXT_OBJ_INIT_PUSH_REST,\n                                             PARSER_PATTERN_RHS_NO_LIT,\n                                             LEXER_RIGHT_BRACE))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);\n      }\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);\n      }\n\n      /* Checked at the end because there might be syntax errors before. */\n      JERRY_ASSERT (flags & PARSER_PATTERN_HAS_REST_ELEMENT);\n      break;\n    }\n\n    if (context_p->token.type == LEXER_RIGHT_SQUARE)\n    {\n      prop_index = PARSER_PATTERN_RHS_NO_LIT;\n      push_prop_opcode =\n        ((flags & PARSER_PATTERN_HAS_REST_ELEMENT) ? CBC_EXT_INITIALIZER_PUSH_NAME : CBC_EXT_INITIALIZER_PUSH_PROP);\n    }\n    else if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)\n    {\n      push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_NAME_LITERAL;\n    }\n\n    if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n    {\n      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);\n      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n    }\n\n    lexer_next_token (context_p);\n\n    if (context_p->token.type == LEXER_COLON)\n    {\n      lexer_next_token (context_p);\n      parser_pattern_process_assignment (context_p, flags, push_prop_opcode, prop_index, LEXER_RIGHT_BRACE);\n    }\n    else\n    {\n      if (push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_NAME || push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_PROP)\n      {\n        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);\n      }\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE && context_p->token.type != LEXER_ASSIGN\n          && context_p->token.type != LEXER_COMMA)\n      {\n        parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);\n      }\n\n      parser_reparse_as_common_identifier (context_p, start_line, start_column);\n\n      if (flags & PARSER_PATTERN_ARGUMENTS)\n      {\n        if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)\n        {\n          parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n        }\n        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;\n      }\n\n#if JERRY_MODULE_SYSTEM\n      parser_module_append_export_name (context_p);\n#endif /* JERRY_MODULE_SYSTEM */\n\n      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n\n      lexer_next_token (context_p);\n      JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_ASSIGN\n                    || context_p->token.type == LEXER_COMMA);\n\n      parser_pattern_form_assignment (context_p, flags, push_prop_opcode, prop_index, start_line);\n#if JERRY_LINE_INFO\n      parser_line_info_append (context_p, start_line, start_column);\n#endif /* JERRY_LINE_INFO */\n    }\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      break;\n    }\n    else if (context_p->token.type != LEXER_COMMA)\n    {\n      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);\n    }\n  }\n\n  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)\n  {\n    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth,\n                            (PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION - PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION));\n  }\n\n  parser_emit_cbc_ext (context_p, CBC_EXT_OBJ_INIT_CONTEXT_END);\n\n  parser_pattern_finalize (context_p, flags, &end_pos);\n}",
  "abstract_func_before": "static void\nparser_parse_object_initializer (parser_context_t *VAR_0, /* COMMENT_0 */\n                                 parser_pattern_flags_t VAR_1) /* COMMENT_1 */\n{\n  parser_pattern_end_marker_t VAR_2 = parser_pattern_get_target (VAR_0, VAR_1);\n\n  /* COMMENT_2 */\n  if (lexer_check_next_character (VAR_0, VAR_3))\n  {\n    parser_emit_cbc_ext (VAR_0, VAR_4);\n    lexer_consume_next_character (VAR_0);\n    parser_pattern_finalize (VAR_0, VAR_1, &VAR_2);\n    return;\n  }\n\n  cbc_ext_opcode_t VAR_5 = VAR_6;\n\n  if (VAR_1 & VAR_7)\n  {\n    VAR_5 = VAR_8;\n  }\n\n  parser_emit_cbc_ext (VAR_0, VAR_5);\n\n  while (true)\n  {\n    lexer_expect_object_literal_id (VAR_0, VAR_9);\n\n    uint16_t VAR_10 = VAR_0->lit_object.index;\n    parser_line_counter_t VAR_11 = VAR_0->token.line;\n    parser_line_counter_t VAR_12 = VAR_0->token.column;\n    uint16_t VAR_13 = VAR_14;\n\n    if (VAR_0->token.type == VAR_15)\n    {\n      break;\n    }\n\n    if (VAR_0->token.type == VAR_16)\n    {\n      lexer_next_token (VAR_0);\n\n      VAR_1 |= VAR_17;\n\n      if (parser_pattern_process_assignment (VAR_0,\n                                             VAR_1,\n                                             VAR_18,\n                                             VAR_19,\n                                             VAR_15))\n      {\n        parser_raise_error (VAR_0, VAR_20);\n      }\n\n      if (VAR_0->token.type != VAR_15)\n      {\n        parser_raise_error (VAR_0, VAR_21);\n      }\n\n      /* COMMENT_3 */\n      JERRY_ASSERT (VAR_1 & VAR_7);\n      break;\n    }\n\n    if (VAR_0->token.type == VAR_22)\n    {\n      VAR_10 = VAR_19;\n      VAR_13 =\n        ((VAR_1 & VAR_7) ? VAR_23 : VAR_24);\n    }\n    else if (VAR_1 & VAR_7)\n    {\n      VAR_13 = VAR_25;\n    }\n\n    if (VAR_0->next_scanner_info_p->source_p == VAR_0->source_p)\n    {\n      JERRY_ASSERT (VAR_0->next_scanner_info_p->type == VAR_26);\n      parser_raise_error (VAR_0, VAR_27);\n    }\n\n    lexer_next_token (VAR_0);\n\n    if (VAR_0->token.type == VAR_28)\n    {\n      lexer_next_token (VAR_0);\n      parser_pattern_process_assignment (VAR_0, VAR_1, VAR_13, VAR_10, VAR_15);\n    }\n    else\n    {\n      if (VAR_13 == VAR_23 || VAR_13 == VAR_24)\n      {\n        parser_raise_error (VAR_0, VAR_29);\n      }\n\n      if (VAR_0->token.type != VAR_15 && VAR_0->token.type != VAR_30\n          && VAR_0->token.type != VAR_31)\n      {\n        parser_raise_error (VAR_0, VAR_32);\n      }\n\n      parser_reparse_as_common_identifier (VAR_0, VAR_11, VAR_12);\n\n      if (VAR_1 & VAR_33)\n      {\n        if (VAR_0->lit_object.literal_p->status_flags & VAR_34)\n        {\n          parser_raise_error (VAR_0, VAR_27);\n        }\n        VAR_0->lit_object.literal_p->status_flags |= VAR_34;\n      }\n\n#if VAR_35\n      parser_module_append_export_name (VAR_0);\n#endif /* COMMENT_4 */\n\n      parser_emit_cbc_literal_from_token (VAR_0, VAR_36);\n\n      lexer_next_token (VAR_0);\n      JERRY_ASSERT (VAR_0->token.type == VAR_15 || VAR_0->token.type == VAR_30\n                    || VAR_0->token.type == VAR_31);\n\n      parser_pattern_form_assignment (VAR_0, VAR_1, VAR_13, VAR_10, VAR_11);\n#if VAR_37\n      parser_line_info_append (VAR_0, VAR_11, VAR_12);\n#endif /* COMMENT_5 */\n    }\n\n    if (VAR_0->token.type == VAR_15)\n    {\n      break;\n    }\n    else if (VAR_0->token.type != VAR_31)\n    {\n      parser_raise_error (VAR_0, VAR_32);\n    }\n  }\n\n  if (VAR_1 & VAR_7)\n  {\n    PARSER_MINUS_EQUAL_U16 (VAR_0->stack_depth,\n                            (VAR_38 - VAR_39));\n  }\n\n  parser_emit_cbc_ext (VAR_0, VAR_40);\n\n  parser_pattern_finalize (VAR_0, VAR_1, &VAR_2);\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/9a8cf58f2252aa825049e9d2fd5071983c6a20be/js-parser-expr.c/vul/before/0.json",
  "func": "static void\nparser_parse_object_initializer (parser_context_t *context_p, /**< context */\n                                 parser_pattern_flags_t flags) /**< flags */\n{\n  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);\n\n  /* 12.14.5.2:  ObjectAssignmentPattern : { } */\n  if (lexer_check_next_character (context_p, LIT_CHAR_RIGHT_BRACE))\n  {\n    parser_emit_cbc_ext (context_p, CBC_EXT_REQUIRE_OBJECT_COERCIBLE);\n    lexer_consume_next_character (context_p);\n    parser_pattern_finalize (context_p, flags, &end_pos);\n    return;\n  }\n\n#ifndef JERRY_NDEBUG\n  bool rest_found = false;\n#endif /* !defined(JERRY_NDEBUG) */\n\n  cbc_ext_opcode_t context_opcode = CBC_EXT_OBJ_INIT_CONTEXT_CREATE;\n\n  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)\n  {\n    context_opcode = CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE;\n  }\n\n  parser_emit_cbc_ext (context_p, context_opcode);\n\n  while (true)\n  {\n    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_OBJECT_PATTERN);\n\n    uint16_t prop_index = context_p->lit_object.index;\n    parser_line_counter_t start_line = context_p->token.line;\n    parser_line_counter_t start_column = context_p->token.column;\n    uint16_t push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_PROP_LITERAL;\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      break;\n    }\n\n    if (context_p->token.type == LEXER_THREE_DOTS)\n    {\n      lexer_next_token (context_p);\n\n      flags |= PARSER_PATTERN_REST_ELEMENT;\n\n      if (parser_pattern_process_assignment (context_p,\n                                             flags,\n                                             CBC_EXT_OBJ_INIT_PUSH_REST,\n                                             PARSER_PATTERN_RHS_NO_LIT,\n                                             LEXER_RIGHT_BRACE))\n      {\n        parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_ASSIGNMENT);\n      }\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE)\n      {\n        parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);\n      }\n\n#ifndef JERRY_NDEBUG\n      rest_found = true;\n#endif /* !defined(JERRY_NDEBUG) */\n      break;\n    }\n\n    if (context_p->token.type == LEXER_RIGHT_SQUARE)\n    {\n      prop_index = PARSER_PATTERN_RHS_NO_LIT;\n      push_prop_opcode =\n        ((flags & PARSER_PATTERN_HAS_REST_ELEMENT) ? CBC_EXT_INITIALIZER_PUSH_NAME : CBC_EXT_INITIALIZER_PUSH_PROP);\n    }\n    else if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)\n    {\n      push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_NAME_LITERAL;\n    }\n\n    if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n    {\n      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);\n      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n    }\n\n    lexer_next_token (context_p);\n\n    if (context_p->token.type == LEXER_COLON)\n    {\n      lexer_next_token (context_p);\n      parser_pattern_process_assignment (context_p, flags, push_prop_opcode, prop_index, LEXER_RIGHT_BRACE);\n    }\n    else\n    {\n      if (push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_NAME || push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_PROP)\n      {\n        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);\n      }\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE && context_p->token.type != LEXER_ASSIGN\n          && context_p->token.type != LEXER_COMMA)\n      {\n        parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);\n      }\n\n      parser_reparse_as_common_identifier (context_p, start_line, start_column);\n\n      if (flags & PARSER_PATTERN_ARGUMENTS)\n      {\n        if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)\n        {\n          parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n        }\n        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;\n      }\n\n#if JERRY_MODULE_SYSTEM\n      parser_module_append_export_name (context_p);\n#endif /* JERRY_MODULE_SYSTEM */\n\n      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);\n\n      lexer_next_token (context_p);\n      JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_ASSIGN\n                    || context_p->token.type == LEXER_COMMA);\n\n      parser_pattern_form_assignment (context_p, flags, push_prop_opcode, prop_index, start_line);\n#if JERRY_LINE_INFO\n      parser_line_info_append (context_p, start_line, start_column);\n#endif /* JERRY_LINE_INFO */\n    }\n\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      break;\n    }\n    else if (context_p->token.type != LEXER_COMMA)\n    {\n      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);\n    }\n  }\n\n  if (flags & PARSER_PATTERN_HAS_REST_ELEMENT)\n  {\n    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth,\n                            (PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION - PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION));\n  }\n\n  parser_emit_cbc_ext (context_p, CBC_EXT_OBJ_INIT_CONTEXT_END);\n\n  parser_pattern_finalize (context_p, flags, &end_pos);\n\n#ifndef JERRY_NDEBUG\n  /* Checked at the end because there might be syntax errors before. */\n  JERRY_ASSERT (!!(flags & PARSER_PATTERN_HAS_REST_ELEMENT) == rest_found);\n#endif /* !defined(JERRY_NDEBUG) */\n}",
  "abstract_func": "static void\nparser_parse_object_initializer (parser_context_t *VAR_0, /* COMMENT_0 */\n                                 parser_pattern_flags_t VAR_1) /* COMMENT_1 */\n{\n  parser_pattern_end_marker_t VAR_2 = parser_pattern_get_target (VAR_0, VAR_1);\n\n  /* COMMENT_2 */\n  if (lexer_check_next_character (VAR_0, VAR_3))\n  {\n    parser_emit_cbc_ext (VAR_0, VAR_4);\n    lexer_consume_next_character (VAR_0);\n    parser_pattern_finalize (VAR_0, VAR_1, &VAR_2);\n    return;\n  }\n\n#ifndef VAR_5\n  bool VAR_6 = false;\n#endif /* COMMENT_3 */\n\n  cbc_ext_opcode_t VAR_7 = VAR_8;\n\n  if (VAR_1 & VAR_9)\n  {\n    VAR_7 = VAR_10;\n  }\n\n  parser_emit_cbc_ext (VAR_0, VAR_7);\n\n  while (true)\n  {\n    lexer_expect_object_literal_id (VAR_0, VAR_11);\n\n    uint16_t VAR_12 = VAR_0->lit_object.index;\n    parser_line_counter_t VAR_13 = VAR_0->token.line;\n    parser_line_counter_t VAR_14 = VAR_0->token.column;\n    uint16_t VAR_15 = VAR_16;\n\n    if (VAR_0->token.type == VAR_17)\n    {\n      break;\n    }\n\n    if (VAR_0->token.type == VAR_18)\n    {\n      lexer_next_token (VAR_0);\n\n      VAR_1 |= VAR_19;\n\n      if (parser_pattern_process_assignment (VAR_0,\n                                             VAR_1,\n                                             VAR_20,\n                                             VAR_21,\n                                             VAR_17))\n      {\n        parser_raise_error (VAR_0, VAR_22);\n      }\n\n      if (VAR_0->token.type != VAR_17)\n      {\n        parser_raise_error (VAR_0, VAR_23);\n      }\n\n#ifndef VAR_5\n      VAR_6 = true;\n#endif /* COMMENT_3 */\n      break;\n    }\n\n    if (VAR_0->token.type == VAR_24)\n    {\n      VAR_12 = VAR_21;\n      VAR_15 =\n        ((VAR_1 & VAR_9) ? VAR_25 : VAR_26);\n    }\n    else if (VAR_1 & VAR_9)\n    {\n      VAR_15 = VAR_27;\n    }\n\n    if (VAR_0->next_scanner_info_p->source_p == VAR_0->source_p)\n    {\n      JERRY_ASSERT (VAR_0->next_scanner_info_p->type == VAR_28);\n      parser_raise_error (VAR_0, VAR_29);\n    }\n\n    lexer_next_token (VAR_0);\n\n    if (VAR_0->token.type == VAR_30)\n    {\n      lexer_next_token (VAR_0);\n      parser_pattern_process_assignment (VAR_0, VAR_1, VAR_15, VAR_12, VAR_17);\n    }\n    else\n    {\n      if (VAR_15 == VAR_25 || VAR_15 == VAR_26)\n      {\n        parser_raise_error (VAR_0, VAR_31);\n      }\n\n      if (VAR_0->token.type != VAR_17 && VAR_0->token.type != VAR_32\n          && VAR_0->token.type != VAR_33)\n      {\n        parser_raise_error (VAR_0, VAR_34);\n      }\n\n      parser_reparse_as_common_identifier (VAR_0, VAR_13, VAR_14);\n\n      if (VAR_1 & VAR_35)\n      {\n        if (VAR_0->lit_object.literal_p->status_flags & VAR_36)\n        {\n          parser_raise_error (VAR_0, VAR_29);\n        }\n        VAR_0->lit_object.literal_p->status_flags |= VAR_36;\n      }\n\n#if VAR_37\n      parser_module_append_export_name (VAR_0);\n#endif /* COMMENT_4 */\n\n      parser_emit_cbc_literal_from_token (VAR_0, VAR_38);\n\n      lexer_next_token (VAR_0);\n      JERRY_ASSERT (VAR_0->token.type == VAR_17 || VAR_0->token.type == VAR_32\n                    || VAR_0->token.type == VAR_33);\n\n      parser_pattern_form_assignment (VAR_0, VAR_1, VAR_15, VAR_12, VAR_13);\n#if VAR_39\n      parser_line_info_append (VAR_0, VAR_13, VAR_14);\n#endif /* COMMENT_5 */\n    }\n\n    if (VAR_0->token.type == VAR_17)\n    {\n      break;\n    }\n    else if (VAR_0->token.type != VAR_33)\n    {\n      parser_raise_error (VAR_0, VAR_34);\n    }\n  }\n\n  if (VAR_1 & VAR_9)\n  {\n    PARSER_MINUS_EQUAL_U16 (VAR_0->stack_depth,\n                            (VAR_40 - VAR_41));\n  }\n\n  parser_emit_cbc_ext (VAR_0, VAR_42);\n\n  parser_pattern_finalize (VAR_0, VAR_1, &VAR_2);\n\n#ifndef VAR_5\n  /* COMMENT_6 */\n  JERRY_ASSERT (!!(VAR_1 & VAR_9) == VAR_6);\n#endif /* COMMENT_3 */\n}",
  "func_graph_path": "jerryscript-project/jerryscript/9a8cf58f2252aa825049e9d2fd5071983c6a20be/js-parser-expr.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,10 @@\n     parser_pattern_finalize (context_p, flags, &end_pos);\n     return;\n   }\n+\n+#ifndef JERRY_NDEBUG\n+  bool rest_found = false;\n+#endif /* !defined(JERRY_NDEBUG) */\n \n   cbc_ext_opcode_t context_opcode = CBC_EXT_OBJ_INIT_CONTEXT_CREATE;\n \n@@ -56,8 +60,9 @@\n         parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);\n       }\n \n-      /* Checked at the end because there might be syntax errors before. */\n-      JERRY_ASSERT (flags & PARSER_PATTERN_HAS_REST_ELEMENT);\n+#ifndef JERRY_NDEBUG\n+      rest_found = true;\n+#endif /* !defined(JERRY_NDEBUG) */\n       break;\n     }\n \n@@ -144,4 +149,9 @@\n   parser_emit_cbc_ext (context_p, CBC_EXT_OBJ_INIT_CONTEXT_END);\n \n   parser_pattern_finalize (context_p, flags, &end_pos);\n+\n+#ifndef JERRY_NDEBUG\n+  /* Checked at the end because there might be syntax errors before. */\n+  JERRY_ASSERT (!!(flags & PARSER_PATTERN_HAS_REST_ELEMENT) == rest_found);\n+#endif /* !defined(JERRY_NDEBUG) */\n }",
  "diff_line_info": {
    "deleted_lines": [
      "      /* Checked at the end because there might be syntax errors before. */",
      "      JERRY_ASSERT (flags & PARSER_PATTERN_HAS_REST_ELEMENT);"
    ],
    "added_lines": [
      "",
      "#ifndef JERRY_NDEBUG",
      "  bool rest_found = false;",
      "#endif /* !defined(JERRY_NDEBUG) */",
      "#ifndef JERRY_NDEBUG",
      "      rest_found = true;",
      "#endif /* !defined(JERRY_NDEBUG) */",
      "",
      "#ifndef JERRY_NDEBUG",
      "  /* Checked at the end because there might be syntax errors before. */",
      "  JERRY_ASSERT (!!(flags & PARSER_PATTERN_HAS_REST_ELEMENT) == rest_found);",
      "#endif /* !defined(JERRY_NDEBUG) */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4950",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/jerryscript-project/jerryscript/pull/4950: 403 Client Error: Forbidden for url: https://api.github.com/repos/jerryscript-project/jerryscript/pulls/4950",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}