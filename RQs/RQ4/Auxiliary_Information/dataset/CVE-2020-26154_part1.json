{
  "cve_id": "CVE-2020-26154",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libproxy",
  "commit_msg": "Fix buffer overflow when PAC is enabled\n\nThe bug was found on Windows 10 (MINGW64) when PAC is enabled. It turned\nout to be the large PAC file (more than 102400 bytes) returned by a\nlocal proxy program with no content-length present.",
  "commit_hash": "4411b523545b22022b4be7d0cac25aa170ae1d3e",
  "git_url": "https://github.com/libproxy/libproxy/commit/4411b523545b22022b4be7d0cac25aa170ae1d3e",
  "file_path": "libproxy/url.cpp",
  "func_name": "url::get_pac",
  "func_before": "char* url::get_pac() {\n\tint sock = -1;\n\tbool chunked = false;\n\tunsigned long int content_length = 0, status = 0;\n\tchar* buffer = NULL;\n\tstring request;\n\n\t// In case of a file:// url we open the file and read it\n\tif (m_scheme == \"file\" || m_scheme == \"pac+file\") {\n\t\tstruct stat st;\n\t\tif ((sock = ::open(m_path.c_str(), O_RDONLY)) < 0)\n\t\t\treturn NULL;\n\n\t\tif (!fstat(sock, &st) && st.st_size < PAC_MAX_SIZE) {\n\t\t\tbuffer = new char[st.st_size+1];\n\t\t\tmemset(buffer, 0, st.st_size+1);\n\t\t\tif (read(sock, buffer, st.st_size) == 0) {\n\t\t\t\tdelete[] buffer;\n\t\t\t\tbuffer = NULL;\n\t\t\t}\n\t\t}\n\t\tclose(sock);\n\t\treturn buffer;\n\t}\n\n\t// DNS lookup of host\n\tif (!get_ips(true))\n\t\treturn NULL;\n\n\t// Iterate through each IP trying to make a connection\n\t// Stop at the first one\n\tfor (int i=0 ; m_ips[i] ; i++) {\n\t\tsock = socket(m_ips[i]->sa_family, SOCK_STREAM, 0);\n\t\tif (sock < 0) continue;\n\n\t\tif (m_ips[i]->sa_family == AF_INET &&\n\t\t\t!connect(sock, m_ips[i], sizeof(struct sockaddr_in)))\n\t\t\tbreak;\n\t\telse if (m_ips[i]->sa_family == AF_INET6 &&\n\t\t\t!connect(sock, m_ips[i], sizeof(struct sockaddr_in6)))\n\t\t\tbreak;\n\n\t\tclosesocket(sock);\n\t\tsock = -1;\n\t}\n\n\t// Test our socket\n\tif (sock < 0) return NULL;\n\n\t// Build the request string\n\trequest  = \"GET \" + (m_path.size() > 0 ? m_path : \"/\") + m_query + \" HTTP/1.1\\r\\n\";\n\trequest += \"Host: \" + m_host + \"\\r\\n\";\n\trequest += \"Accept: \" + string(PAC_MIME_TYPE) + \"\\r\\n\";\n\trequest += \"Connection: close\\r\\n\";\n\trequest += \"\\r\\n\";\n\n\t// Send HTTP request\n\tif ((size_t) send(sock, request.c_str(), request.size(), 0) != request.size()) {\n\t\tclosesocket(sock);\n\t\treturn NULL;\n\t}\n\n\t/* Verify status line */\n\tstring line = recvline(sock);\n\tif (sscanf(line.c_str(), \"HTTP/1.%*d %lu\", &status) == 1 && status == 200) {\n\t\t/* Check for correct mime type and content length */\n\t\tcontent_length = 0;\n\t\tfor (line = recvline(sock) ; line != \"\\r\" && line != \"\" ; line = recvline(sock)) {\n\t\t\t// Check for chunked encoding\n\t\t\tif (line.find(\"Content-Transfer-Encoding: chunked\") == 0 || line.find(\"Transfer-Encoding: chunked\") == 0)\n\t\t\t\tchunked = true;\n\n\t\t\t// Check for content length\n\t\t\telse if (content_length == 0)\n\t\t\t\tsscanf(line.c_str(), \"Content-Length: %lu\", &content_length);\n\t\t}\n\n\t\t// Get content\n\t\tunsigned int recvd = 0;\n\t\tbuffer = new char[PAC_MAX_SIZE];\n\t\tmemset(buffer, 0, PAC_MAX_SIZE);\n\t\tdo {\n\t\t\tunsigned int chunk_length;\n\n\t\t\tif (chunked) {\n\t\t\t\t// Discard the empty line if we received a previous chunk\n\t\t\t\tif (recvd > 0) recvline(sock);\n\n\t\t\t\t// Get the chunk-length line as an integer\n\t\t\t\tif (sscanf(recvline(sock).c_str(), \"%x\", &chunk_length) != 1 || chunk_length == 0) break;\n\n\t\t\t\t// Add this chunk to our content length,\n\t\t\t\t// ensuring that we aren't over our max size\n\t\t\t\tcontent_length += chunk_length;\n\t\t\t}\n\n\t\t\tif (content_length >= PAC_MAX_SIZE) break;\n\n\t\t\twhile (content_length == 0 || recvd != content_length) {\n\t\t\t\tint r = recv(sock, buffer + recvd,\n\t\t\t\t             content_length == 0 ? PAC_HTTP_BLOCK_SIZE\n\t\t\t\t                                 : content_length - recvd, 0);\n\t\t\t\tif (r <= 0) {\n\t\t\t\t\tchunked = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trecvd += r;\n\t\t\t}\n\t\t} while (chunked);\n\n\t\tif (content_length != 0 && string(buffer).size() != content_length) {\n\t\t\tdelete[] buffer;\n\t\t\tbuffer = NULL;\n\t\t}\n\t}\n\n\t// Clean up\n\tshutdown(sock, SHUT_RDWR);\n\tclosesocket(sock);\n\treturn buffer;\n}",
  "abstract_func_before": "char* url::get_pac() {\n\tint VAR_0 = -1;\n\tbool VAR_1 = false;\n\tunsigned long int VAR_2 = 0, VAR_3 = 0;\n\tchar* VAR_4 = NULL;\n\tstring VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_6 == \"file\" || VAR_6 == \"pac+file\") {\n\t\tstruct stat VAR_7;\n\t\tif ((VAR_0 = ::open(VAR_8.c_str(), VAR_9)) < 0)\n\t\t\treturn NULL;\n\n\t\tif (!fstat(VAR_0, &VAR_7) && VAR_7.st_size < VAR_10) {\n\t\t\tVAR_4 = new char[VAR_7.st_size+1];\n\t\t\tmemset(VAR_4, 0, VAR_7.st_size+1);\n\t\t\tif (read(VAR_0, VAR_4, VAR_7.st_size) == 0) {\n\t\t\t\tdelete[] VAR_4;\n\t\t\t\tVAR_4 = NULL;\n\t\t\t}\n\t\t}\n\t\tclose(VAR_0);\n\t\treturn VAR_4;\n\t}\n\n\t/* COMMENT_1 */\n\tif (!get_ips(true))\n\t\treturn NULL;\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\tfor (int VAR_11=0 ; VAR_12[VAR_11] ; VAR_11++) {\n\t\tVAR_0 = socket(VAR_12[VAR_11]->sa_family, VAR_13, 0);\n\t\tif (VAR_0 < 0) continue;\n\n\t\tif (VAR_12[VAR_11]->sa_family == VAR_14 &&\n\t\t\t!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in)))\n\t\t\tbreak;\n\t\telse if (VAR_12[VAR_11]->sa_family == VAR_15 &&\n\t\t\t!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in6)))\n\t\t\tbreak;\n\n\t\tclosesocket(VAR_0);\n\t\tVAR_0 = -1;\n\t}\n\n\t/* COMMENT_4 */\n\tif (VAR_0 < 0) return NULL;\n\n\t/* COMMENT_5 */\n\tVAR_5  = \"GET \" + (VAR_8.size() > 0 ? VAR_8 : \"/\") + VAR_16 + \" HTTP/1.1\\r\\n\";\n\tVAR_5 += \"Host: \" + VAR_17 + \"\\r\\n\";\n\tVAR_5 += \"Accept: \" + string(VAR_18) + \"\\r\\n\";\n\tVAR_5 += \"Connection: close\\r\\n\";\n\tVAR_5 += \"\\r\\n\";\n\n\t/* COMMENT_6 */\n\tif ((size_t) send(VAR_0, VAR_5.c_str(), VAR_5.size(), 0) != VAR_5.size()) {\n\t\tclosesocket(VAR_0);\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_7 */\n\tstring VAR_19 = recvline(VAR_0);\n\tif (sscanf(VAR_19.c_str(), \"HTTP/1.%*d %lu\", &VAR_3) == 1 && VAR_3 == 200) {\n\t\t/* COMMENT_8 */\n\t\tVAR_2 = 0;\n\t\tfor (VAR_19 = recvline(VAR_0) ; VAR_19 != \"\\r\" && VAR_19 != \"\" ; VAR_19 = recvline(VAR_0)) {\n\t\t\t/* COMMENT_9 */\n\t\t\tif (VAR_19.find(\"Content-Transfer-Encoding: chunked\") == 0 || VAR_19.find(\"Transfer-Encoding: chunked\") == 0)\n\t\t\t\tVAR_1 = true;\n\n\t\t\t/* COMMENT_10 */\n\t\t\telse if (VAR_2 == 0)\n\t\t\t\tsscanf(VAR_19.c_str(), \"Content-Length: %lu\", &VAR_2);\n\t\t}\n\n\t\t/* COMMENT_11 */\n\t\tunsigned int VAR_20 = 0;\n\t\tVAR_4 = new char[VAR_10];\n\t\tmemset(VAR_4, 0, VAR_10);\n\t\tdo {\n\t\t\tunsigned int VAR_21;\n\n\t\t\tif (VAR_1) {\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tif (VAR_20 > 0) recvline(VAR_0);\n\n\t\t\t\t/* COMMENT_13 */\n\t\t\t\tif (sscanf(recvline(VAR_0).c_str(), \"%x\", &VAR_21) != 1 || VAR_21 == 0) break;\n\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tVAR_2 += VAR_21;\n\t\t\t}\n\n\t\t\tif (VAR_2 >= VAR_10) break;\n\n\t\t\twhile (VAR_2 == 0 || VAR_20 != VAR_2) {\n\t\t\t\tint VAR_22 = recv(VAR_0, VAR_4 + VAR_20,\n\t\t\t\t             VAR_2 == 0 ? VAR_23\n\t\t\t\t                                 : VAR_2 - VAR_20, 0);\n\t\t\t\tif (VAR_22 <= 0) {\n\t\t\t\t\tVAR_1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_20 += VAR_22;\n\t\t\t}\n\t\t} while (VAR_1);\n\n\t\tif (VAR_2 != 0 && string(VAR_4).size() != VAR_2) {\n\t\t\tdelete[] VAR_4;\n\t\t\tVAR_4 = NULL;\n\t\t}\n\t}\n\n\t/* COMMENT_16 */\n\tshutdown(VAR_0, VAR_24);\n\tclosesocket(VAR_0);\n\treturn VAR_4;\n}",
  "func_graph_path_before": "libproxy/4411b523545b22022b4be7d0cac25aa170ae1d3e/url.cpp/vul/before/0.json",
  "func": "char* url::get_pac() {\n\tint sock = -1;\n\tbool chunked = false;\n\tunsigned long int content_length = 0, status = 0;\n\tchar* buffer = NULL;\n\tstring request;\n\n\t// In case of a file:// url we open the file and read it\n\tif (m_scheme == \"file\" || m_scheme == \"pac+file\") {\n\t\tstruct stat st;\n\t\tif ((sock = ::open(m_path.c_str(), O_RDONLY)) < 0)\n\t\t\treturn NULL;\n\n\t\tif (!fstat(sock, &st) && st.st_size < PAC_MAX_SIZE) {\n\t\t\tbuffer = new char[st.st_size+1];\n\t\t\tmemset(buffer, 0, st.st_size+1);\n\t\t\tif (read(sock, buffer, st.st_size) == 0) {\n\t\t\t\tdelete[] buffer;\n\t\t\t\tbuffer = NULL;\n\t\t\t}\n\t\t}\n\t\tclose(sock);\n\t\treturn buffer;\n\t}\n\n\t// DNS lookup of host\n\tif (!get_ips(true))\n\t\treturn NULL;\n\n\t// Iterate through each IP trying to make a connection\n\t// Stop at the first one\n\tfor (int i=0 ; m_ips[i] ; i++) {\n\t\tsock = socket(m_ips[i]->sa_family, SOCK_STREAM, 0);\n\t\tif (sock < 0) continue;\n\n\t\tif (m_ips[i]->sa_family == AF_INET &&\n\t\t\t!connect(sock, m_ips[i], sizeof(struct sockaddr_in)))\n\t\t\tbreak;\n\t\telse if (m_ips[i]->sa_family == AF_INET6 &&\n\t\t\t!connect(sock, m_ips[i], sizeof(struct sockaddr_in6)))\n\t\t\tbreak;\n\n\t\tclosesocket(sock);\n\t\tsock = -1;\n\t}\n\n\t// Test our socket\n\tif (sock < 0) return NULL;\n\n\t// Build the request string\n\trequest  = \"GET \" + (m_path.size() > 0 ? m_path : \"/\") + m_query + \" HTTP/1.1\\r\\n\";\n\trequest += \"Host: \" + m_host + \"\\r\\n\";\n\trequest += \"Accept: \" + string(PAC_MIME_TYPE) + \"\\r\\n\";\n\trequest += \"Connection: close\\r\\n\";\n\trequest += \"\\r\\n\";\n\n\t// Send HTTP request\n\tif ((size_t) send(sock, request.c_str(), request.size(), 0) != request.size()) {\n\t\tclosesocket(sock);\n\t\treturn NULL;\n\t}\n\n\t/* Verify status line */\n\tstring line = recvline(sock);\n\tif (sscanf(line.c_str(), \"HTTP/1.%*d %lu\", &status) == 1 && status == 200) {\n\t\t/* Check for correct mime type and content length */\n\t\tcontent_length = 0;\n\t\tfor (line = recvline(sock) ; line != \"\\r\" && line != \"\" ; line = recvline(sock)) {\n\t\t\t// Check for chunked encoding\n\t\t\tif (line.find(\"Content-Transfer-Encoding: chunked\") == 0 || line.find(\"Transfer-Encoding: chunked\") == 0)\n\t\t\t\tchunked = true;\n\n\t\t\t// Check for content length\n\t\t\telse if (content_length == 0)\n\t\t\t\tsscanf(line.c_str(), \"Content-Length: %lu\", &content_length);\n\t\t}\n\n\t\t// Get content\n\t\tstd::vector<char> dynamic_buffer;\n\t\tdo {\n\t\t\tunsigned int chunk_length;\n\n\t\t\tif (chunked) {\n\t\t\t\t// Discard the empty line if we received a previous chunk\n\t\t\t\tif (!dynamic_buffer.empty()) recvline(sock);\n\n\t\t\t\t// Get the chunk-length line as an integer\n\t\t\t\tif (sscanf(recvline(sock).c_str(), \"%x\", &chunk_length) != 1 || chunk_length == 0) break;\n\n\t\t\t\t// Add this chunk to our content length,\n\t\t\t\t// ensuring that we aren't over our max size\n\t\t\t\tcontent_length += chunk_length;\n\t\t\t}\n\n\t\t\tif (content_length >= PAC_MAX_SIZE) break;\n\n\t\t\twhile (content_length == 0 || dynamic_buffer.size() != content_length) {\n\t\t\t\t// Calculate length to recv\n\t\t\t\tunsigned int length_to_read = PAC_HTTP_BLOCK_SIZE;\n\t\t\t\tif (content_length > 0)\n\t\t\t\t\tlength_to_read = content_length - dynamic_buffer.size();\n\n\t\t\t\t// Prepare buffer\n\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() + length_to_read);\n\n\t\t\t\tint r = recv(sock, dynamic_buffer.data() + dynamic_buffer.size() - length_to_read, length_to_read, 0);\n\n\t\t\t\t// Shrink buffer to fit\n\t\t\t\tif (r >= 0)\n\t\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() - length_to_read + r);\n\n\t\t\t\t// PAC size too large, discard\n\t\t\t\tif (dynamic_buffer.size() >= PAC_MAX_SIZE) {\n\t\t\t\t\tchunked = false;\n\t\t\t\t\tdynamic_buffer.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (r <= 0) {\n\t\t\t\t\tchunked = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (chunked);\n\n\t\tif (content_length == 0 || content_length == dynamic_buffer.size()) {\n\t\t\tbuffer = new char[dynamic_buffer.size() + 1];\n\t\t\tif (!dynamic_buffer.empty()) {\n\t\t\t\tmemcpy(buffer, dynamic_buffer.data(), dynamic_buffer.size());\n\t\t\t}\n\t\t\tbuffer[dynamic_buffer.size()] = '\\0';\n\t\t}\n\t}\n\n\t// Clean up\n\tshutdown(sock, SHUT_RDWR);\n\tclosesocket(sock);\n\treturn buffer;\n}",
  "abstract_func": "char* url::get_pac() {\n\tint VAR_0 = -1;\n\tbool VAR_1 = false;\n\tunsigned long int VAR_2 = 0, VAR_3 = 0;\n\tchar* VAR_4 = NULL;\n\tstring VAR_5;\n\n\t/* COMMENT_0 */\n\tif (VAR_6 == \"file\" || VAR_6 == \"pac+file\") {\n\t\tstruct stat VAR_7;\n\t\tif ((VAR_0 = ::open(VAR_8.c_str(), VAR_9)) < 0)\n\t\t\treturn NULL;\n\n\t\tif (!fstat(VAR_0, &VAR_7) && VAR_7.st_size < VAR_10) {\n\t\t\tVAR_4 = new char[VAR_7.st_size+1];\n\t\t\tmemset(VAR_4, 0, VAR_7.st_size+1);\n\t\t\tif (read(VAR_0, VAR_4, VAR_7.st_size) == 0) {\n\t\t\t\tdelete[] VAR_4;\n\t\t\t\tVAR_4 = NULL;\n\t\t\t}\n\t\t}\n\t\tclose(VAR_0);\n\t\treturn VAR_4;\n\t}\n\n\t/* COMMENT_1 */\n\tif (!get_ips(true))\n\t\treturn NULL;\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\tfor (int VAR_11=0 ; VAR_12[VAR_11] ; VAR_11++) {\n\t\tVAR_0 = socket(VAR_12[VAR_11]->sa_family, VAR_13, 0);\n\t\tif (VAR_0 < 0) continue;\n\n\t\tif (VAR_12[VAR_11]->sa_family == VAR_14 &&\n\t\t\t!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in)))\n\t\t\tbreak;\n\t\telse if (VAR_12[VAR_11]->sa_family == VAR_15 &&\n\t\t\t!connect(VAR_0, VAR_12[VAR_11], sizeof(struct sockaddr_in6)))\n\t\t\tbreak;\n\n\t\tclosesocket(VAR_0);\n\t\tVAR_0 = -1;\n\t}\n\n\t/* COMMENT_4 */\n\tif (VAR_0 < 0) return NULL;\n\n\t/* COMMENT_5 */\n\tVAR_5  = \"GET \" + (VAR_8.size() > 0 ? VAR_8 : \"/\") + VAR_16 + \" HTTP/1.1\\r\\n\";\n\tVAR_5 += \"Host: \" + VAR_17 + \"\\r\\n\";\n\tVAR_5 += \"Accept: \" + string(VAR_18) + \"\\r\\n\";\n\tVAR_5 += \"Connection: close\\r\\n\";\n\tVAR_5 += \"\\r\\n\";\n\n\t/* COMMENT_6 */\n\tif ((size_t) send(VAR_0, VAR_5.c_str(), VAR_5.size(), 0) != VAR_5.size()) {\n\t\tclosesocket(VAR_0);\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_7 */\n\tstring VAR_19 = recvline(VAR_0);\n\tif (sscanf(VAR_19.c_str(), \"HTTP/1.%*d %lu\", &VAR_3) == 1 && VAR_3 == 200) {\n\t\t/* COMMENT_8 */\n\t\tVAR_2 = 0;\n\t\tfor (VAR_19 = recvline(VAR_0) ; VAR_19 != \"\\r\" && VAR_19 != \"\" ; VAR_19 = recvline(VAR_0)) {\n\t\t\t/* COMMENT_9 */\n\t\t\tif (VAR_19.find(\"Content-Transfer-Encoding: chunked\") == 0 || VAR_19.find(\"Transfer-Encoding: chunked\") == 0)\n\t\t\t\tVAR_1 = true;\n\n\t\t\t/* COMMENT_10 */\n\t\t\telse if (VAR_2 == 0)\n\t\t\t\tsscanf(VAR_19.c_str(), \"Content-Length: %lu\", &VAR_2);\n\t\t}\n\n\t\t/* COMMENT_11 */\n\t\tstd::vector<char> VAR_20;\n\t\tdo {\n\t\t\tunsigned int VAR_21;\n\n\t\t\tif (VAR_1) {\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tif (!VAR_20.empty()) recvline(VAR_0);\n\n\t\t\t\t/* COMMENT_13 */\n\t\t\t\tif (sscanf(recvline(VAR_0).c_str(), \"%x\", &VAR_21) != 1 || VAR_21 == 0) break;\n\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tVAR_2 += VAR_21;\n\t\t\t}\n\n\t\t\tif (VAR_2 >= VAR_10) break;\n\n\t\t\twhile (VAR_2 == 0 || VAR_20.size() != VAR_2) {\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\tunsigned int VAR_22 = VAR_23;\n\t\t\t\tif (VAR_2 > 0)\n\t\t\t\t\tVAR_22 = VAR_2 - VAR_20.size();\n\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_20.resize(VAR_20.size() + VAR_22);\n\n\t\t\t\tint VAR_24 = recv(VAR_0, VAR_20.data() + VAR_20.size() - VAR_22, VAR_22, 0);\n\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tif (VAR_24 >= 0)\n\t\t\t\t\tVAR_20.resize(VAR_20.size() - VAR_22 + VAR_24);\n\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tif (VAR_20.size() >= VAR_10) {\n\t\t\t\t\tVAR_1 = false;\n\t\t\t\t\tVAR_20.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_24 <= 0) {\n\t\t\t\t\tVAR_1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (VAR_1);\n\n\t\tif (VAR_2 == 0 || VAR_2 == VAR_20.size()) {\n\t\t\tVAR_4 = new char[VAR_20.size() + 1];\n\t\t\tif (!VAR_20.empty()) {\n\t\t\t\tmemcpy(VAR_4, VAR_20.data(), VAR_20.size());\n\t\t\t}\n\t\t\tVAR_4[VAR_20.size()] = '\\0';\n\t\t}\n\t}\n\n\t/* COMMENT_20 */\n\tshutdown(VAR_0, VAR_25);\n\tclosesocket(VAR_0);\n\treturn VAR_4;\n}",
  "func_graph_path": "libproxy/4411b523545b22022b4be7d0cac25aa170ae1d3e/url.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -76,15 +76,13 @@\n \t\t}\n \n \t\t// Get content\n-\t\tunsigned int recvd = 0;\n-\t\tbuffer = new char[PAC_MAX_SIZE];\n-\t\tmemset(buffer, 0, PAC_MAX_SIZE);\n+\t\tstd::vector<char> dynamic_buffer;\n \t\tdo {\n \t\t\tunsigned int chunk_length;\n \n \t\t\tif (chunked) {\n \t\t\t\t// Discard the empty line if we received a previous chunk\n-\t\t\t\tif (recvd > 0) recvline(sock);\n+\t\t\t\tif (!dynamic_buffer.empty()) recvline(sock);\n \n \t\t\t\t// Get the chunk-length line as an integer\n \t\t\t\tif (sscanf(recvline(sock).c_str(), \"%x\", &chunk_length) != 1 || chunk_length == 0) break;\n@@ -96,21 +94,41 @@\n \n \t\t\tif (content_length >= PAC_MAX_SIZE) break;\n \n-\t\t\twhile (content_length == 0 || recvd != content_length) {\n-\t\t\t\tint r = recv(sock, buffer + recvd,\n-\t\t\t\t             content_length == 0 ? PAC_HTTP_BLOCK_SIZE\n-\t\t\t\t                                 : content_length - recvd, 0);\n+\t\t\twhile (content_length == 0 || dynamic_buffer.size() != content_length) {\n+\t\t\t\t// Calculate length to recv\n+\t\t\t\tunsigned int length_to_read = PAC_HTTP_BLOCK_SIZE;\n+\t\t\t\tif (content_length > 0)\n+\t\t\t\t\tlength_to_read = content_length - dynamic_buffer.size();\n+\n+\t\t\t\t// Prepare buffer\n+\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() + length_to_read);\n+\n+\t\t\t\tint r = recv(sock, dynamic_buffer.data() + dynamic_buffer.size() - length_to_read, length_to_read, 0);\n+\n+\t\t\t\t// Shrink buffer to fit\n+\t\t\t\tif (r >= 0)\n+\t\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() - length_to_read + r);\n+\n+\t\t\t\t// PAC size too large, discard\n+\t\t\t\tif (dynamic_buffer.size() >= PAC_MAX_SIZE) {\n+\t\t\t\t\tchunked = false;\n+\t\t\t\t\tdynamic_buffer.clear();\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n \t\t\t\tif (r <= 0) {\n \t\t\t\t\tchunked = false;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\trecvd += r;\n \t\t\t}\n \t\t} while (chunked);\n \n-\t\tif (content_length != 0 && string(buffer).size() != content_length) {\n-\t\t\tdelete[] buffer;\n-\t\t\tbuffer = NULL;\n+\t\tif (content_length == 0 || content_length == dynamic_buffer.size()) {\n+\t\t\tbuffer = new char[dynamic_buffer.size() + 1];\n+\t\t\tif (!dynamic_buffer.empty()) {\n+\t\t\t\tmemcpy(buffer, dynamic_buffer.data(), dynamic_buffer.size());\n+\t\t\t}\n+\t\t\tbuffer[dynamic_buffer.size()] = '\\0';\n \t\t}\n \t}\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tunsigned int recvd = 0;",
      "\t\tbuffer = new char[PAC_MAX_SIZE];",
      "\t\tmemset(buffer, 0, PAC_MAX_SIZE);",
      "\t\t\t\tif (recvd > 0) recvline(sock);",
      "\t\t\twhile (content_length == 0 || recvd != content_length) {",
      "\t\t\t\tint r = recv(sock, buffer + recvd,",
      "\t\t\t\t             content_length == 0 ? PAC_HTTP_BLOCK_SIZE",
      "\t\t\t\t                                 : content_length - recvd, 0);",
      "\t\t\t\trecvd += r;",
      "\t\tif (content_length != 0 && string(buffer).size() != content_length) {",
      "\t\t\tdelete[] buffer;",
      "\t\t\tbuffer = NULL;"
    ],
    "added_lines": [
      "\t\tstd::vector<char> dynamic_buffer;",
      "\t\t\t\tif (!dynamic_buffer.empty()) recvline(sock);",
      "\t\t\twhile (content_length == 0 || dynamic_buffer.size() != content_length) {",
      "\t\t\t\t// Calculate length to recv",
      "\t\t\t\tunsigned int length_to_read = PAC_HTTP_BLOCK_SIZE;",
      "\t\t\t\tif (content_length > 0)",
      "\t\t\t\t\tlength_to_read = content_length - dynamic_buffer.size();",
      "",
      "\t\t\t\t// Prepare buffer",
      "\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() + length_to_read);",
      "",
      "\t\t\t\tint r = recv(sock, dynamic_buffer.data() + dynamic_buffer.size() - length_to_read, length_to_read, 0);",
      "",
      "\t\t\t\t// Shrink buffer to fit",
      "\t\t\t\tif (r >= 0)",
      "\t\t\t\t\tdynamic_buffer.resize(dynamic_buffer.size() - length_to_read + r);",
      "",
      "\t\t\t\t// PAC size too large, discard",
      "\t\t\t\tif (dynamic_buffer.size() >= PAC_MAX_SIZE) {",
      "\t\t\t\t\tchunked = false;",
      "\t\t\t\t\tdynamic_buffer.clear();",
      "\t\t\t\t\tbreak;",
      "\t\t\t\t}",
      "",
      "\t\tif (content_length == 0 || content_length == dynamic_buffer.size()) {",
      "\t\t\tbuffer = new char[dynamic_buffer.size() + 1];",
      "\t\t\tif (!dynamic_buffer.empty()) {",
      "\t\t\t\tmemcpy(buffer, dynamic_buffer.data(), dynamic_buffer.size());",
      "\t\t\t}",
      "\t\t\tbuffer[dynamic_buffer.size()] = '\\0';"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libproxy/libproxy/pull/126",
  "description": {
    "pr_info": {
      "title": "Fix buffer overflow when PAC is enabled",
      "number": 126
    },
    "comment": [
      "The bug was found on Windows 10 (MINGW64) when PAC is enabled. It turned\r\nout to be the large PAC file (more than 102400 bytes) returned by a\r\nlocal proxy program with no content-length present.",
      "I'll encourage you to request a CVE for this issue using https://cveform.mitre.org/.",
      "> I'll encourage you to request a CVE for this issue using https://cveform.mitre.org/.\r\n\r\n[CVE-2020-26154](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-26154) was assigned by MITRE to this issue.",
      "Is this patch going to get merged?",
      "hey, when will the patch be merged? or what would be the manual way applying this patch? it is assigned as a critical vulnerability"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Output:**  \n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}