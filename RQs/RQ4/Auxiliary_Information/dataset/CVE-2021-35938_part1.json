{
  "cve_id": "CVE-2021-35938",
  "cwe_ids": [
    "CWE-59"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rpm-software-management/rpm",
  "commit_msg": "Set file metadata via fd-based ops for everything but symlinks\n\nRegular file ops are fd-based already, for the rest we need to open them\nmanually. Files with temporary suffix must never be followed, for\ndirectories (and pre-existing FA_TOUCHed files) use the rpm symlink\n\"root or target owner allowed\" rule wrt following.\n\nThis mostly fixes CVE-2021-35938, but as we're not yet using dirfd-based\noperatiosn for everything there are corner cases left undone. And then\nthere's the plugin API which needs updating for all this.",
  "commit_hash": "25a435e90844ea98fe5eb7bef22c1aecf3a9c033",
  "git_url": "https://github.com/rpm-software-management/rpm/commit/25a435e90844ea98fe5eb7bef22c1aecf3a9c033",
  "file_path": "lib/fsm.c",
  "func_name": "rpmPackageFilesInstall",
  "func_before": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
  "abstract_func_before": "int rpmPackageFilesInstall(rpmts VAR_0, rpmte VAR_1, rpmfiles VAR_2,\n              rpmpsm VAR_3, char ** VAR_4)\n{\n    FD_t VAR_5 = rpmtePayload(VAR_1);\n    rpmfi VAR_6 = NULL;\n    rpmfs VAR_7 = rpmteGetFileStates(VAR_1);\n    rpmPlugins VAR_8 = rpmtsPlugins(VAR_0);\n    int VAR_9 = 0;\n    int VAR_10 = -1;\n    int VAR_11 = rpmfilesFC(VAR_2);\n    int VAR_12 = (rpmtsFlags(VAR_0) & VAR_13) ? 1 : 0;\n    int VAR_14 = (rpmtsFlags(VAR_0) & VAR_15) ? 1 : 0;\n    int VAR_16 = -1;\n    char *VAR_17 = NULL;\n    struct filedata_s *VAR_18 = xcalloc(VAR_11, sizeof(*VAR_18));\n    struct filedata_s *VAR_19 = NULL;\n    struct diriter_s VAR_20 = { -1 };\n\n    /* COMMENT_0 */\n    rasprintf(&VAR_17, \";%08x\", (unsigned)rpmtsGetTid(VAR_0));\n\n    /* COMMENT_1 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_21);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\tif (rpmfiFFlags(VAR_6) & VAR_23)\n            VAR_22->action = VAR_24;\n\telse\n\t    VAR_22->action = rpmfsGetAction(VAR_7, VAR_10);\n\tVAR_22->skip = XFA_SKIPPING(VAR_22->action);\n\tif (XFA_CREATING(VAR_22->action) && !S_ISDIR(rpmfiFMode(VAR_6)))\n\t    VAR_22->suffix = VAR_17;\n\tVAR_22->fpath = fsmFsPath(VAR_6, VAR_22->suffix);\n\n\t/* COMMENT_2 */\n\tVAR_9 = rpmfiStat(VAR_6, 1, &VAR_22->sb);\n\n\t/* COMMENT_3 */\n\tVAR_22->setmeta = (VAR_22->skip == 0) &&\n\t\t      (VAR_22->sb.st_nlink == 1 || VAR_22->action == VAR_25);\n\n\tsetFileState(VAR_7, VAR_10);\n\tfsmDebug(VAR_22->fpath, VAR_22->action, &VAR_22->sb);\n\n\tVAR_22->stage = VAR_26;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    if (VAR_9)\n\tgoto exit;\n\n    VAR_6 = fsmIter(VAR_5, VAR_2,\n\t\t VAR_5 ? VAR_27 : VAR_21, &VAR_20);\n\n    if (VAR_6 == NULL) {\n        VAR_9 = VAR_28;\n        goto exit;\n    }\n\n    /* COMMENT_4 */\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n\t/* COMMENT_5 */\n                                                                \n                                                               \n                                                              \n            \n    \n\tif (VAR_22->skip && VAR_19 && rpmfiArchiveHasContent(VAR_6))\n\t    VAR_22 = VAR_19;\n\n        if (!VAR_22->skip) {\n\t    int VAR_29 = -1;\n\t    /* COMMENT_11 */\n\t    if (!VAR_22->suffix && VAR_22 != VAR_19) {\n\t\tVAR_9 = fsmBackup(VAR_20.dirfd, VAR_6, VAR_22->action);\n\t    }\n\n\t    if (!VAR_9) {\n\t\tVAR_9 = ensureDir(VAR_8, rpmfiDN(VAR_6), 0,\n\t\t\t\t(VAR_22->action == VAR_30), 0, &VAR_20.dirfd);\n\t    }\n\n\t    /* COMMENT_12 */\n\t    VAR_9 = rpmpluginsCallFsmFilePre(VAR_8, VAR_6, VAR_22->fpath,\n\t\t\t\t\t  VAR_22->sb.st_mode, VAR_22->action);\n\t    if (VAR_9)\n\t\tgoto setmeta; /* COMMENT_13 */\n\n\t    /* COMMENT_14 */\n\t    if (!VAR_22->suffix) {\n\t\tif (VAR_22->action == VAR_25) {\n\t\t    struct stat VAR_31;\n\t\t    VAR_9 = fsmStat(VAR_20.dirfd, VAR_22->fpath, 1, &VAR_31);\n\t\t} else {\n\t\t    VAR_9 = fsmVerify(VAR_20.dirfd, VAR_22->fpath, VAR_6);\n\t\t}\n\t    } else {\n\t\tVAR_9 = VAR_32;\n\t    }\n\n\t    /* COMMENT_15 */\n\t    if (VAR_9 == VAR_32 && VAR_22->action == VAR_25) {\n\t\trpmlog(VAR_33, \"file %s vanished unexpectedly\\n\",\n\t\t\tVAR_22->fpath);\n\t\tVAR_22->action = VAR_30;\n\t\tfsmDebug(VAR_22->fpath, VAR_22->action, &VAR_22->sb);\n\t    }\n\n\t    /* COMMENT_16 */\n\t    if (VAR_22->action == VAR_25)\n\t\tgoto setmeta;\n\n            if (S_ISREG(VAR_22->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_32) {\n\t\t    VAR_9 = fsmMkfile(VAR_20.dirfd, VAR_6, VAR_22, VAR_2, VAR_3, VAR_12,\n\t\t\t\t   &VAR_19, &VAR_16, &VAR_29);\n\t\t}\n            } else if (S_ISDIR(VAR_22->sb.st_mode)) {\n                if (VAR_9 == VAR_32) {\n                    mode_t VAR_34 = VAR_22->sb.st_mode;\n                    VAR_34 &= ~07777;\n                    VAR_34 |=  00700;\n                    VAR_9 = fsmMkdir(VAR_20.dirfd, VAR_22->fpath, VAR_34);\n                }\n            } else if (S_ISLNK(VAR_22->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_32) {\n\t\t    VAR_9 = fsmSymlink(rpmfiFLink(VAR_6), VAR_20.dirfd, VAR_22->fpath);\n\t\t}\n            } else if (S_ISFIFO(VAR_22->sb.st_mode)) {\n                /* COMMENT_17 */\n                if (VAR_9 == VAR_32) {\n                    VAR_9 = fsmMkfifo(VAR_20.dirfd, VAR_22->fpath, 0000);\n                }\n            } else if (S_ISCHR(VAR_22->sb.st_mode) ||\n                       S_ISBLK(VAR_22->sb.st_mode) ||\n                       S_ISSOCK(VAR_22->sb.st_mode))\n            {\n                if (VAR_9 == VAR_32) {\n                    VAR_9 = fsmMknod(VAR_20.dirfd, VAR_22->fpath, VAR_22->sb.st_mode, VAR_22->sb.st_rdev);\n                }\n            } else {\n                /* COMMENT_18 */\n                if (!IS_DEV_LOG(VAR_22->fpath))\n                    VAR_9 = VAR_35;\n            }\n\nsetmeta:\n\t    if (!VAR_9 && VAR_22->setmeta) {\n\t\tVAR_9 = fsmSetmeta(VAR_29, VAR_20.dirfd, VAR_22->fpath,\n\t\t\t\tVAR_6, VAR_8, VAR_22->action,\n\t\t\t\t&VAR_22->sb, VAR_14);\n\t    }\n\n\t    if (VAR_29 != VAR_16)\n\t\tfsmClose(&VAR_29);\n\t}\n\n\t/* COMMENT_19 */\n\tif (VAR_9)\n\t    *VAR_4 = xstrdup(VAR_22->fpath);\n\telse\n\t    rpmpsmNotify(VAR_3, VAR_36, rpmfiArchiveTell(VAR_6));\n\tVAR_22->stage = VAR_37;\n    }\n    VAR_6 = fsmIterFini(VAR_6, &VAR_20);\n\n    if (!VAR_9 && VAR_10 < 0 && VAR_10 != VAR_38)\n\tVAR_9 = VAR_10;\n\n    /* COMMENT_20 */\n    VAR_6 = fsmIter(NULL, VAR_2, VAR_21, &VAR_20);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n\tif (!VAR_22->skip) {\n\t    if (!VAR_9)\n\t\tVAR_9 = ensureDir(NULL, rpmfiDN(VAR_6), 0, 0, 0, &VAR_20.dirfd);\n\n\t    /* COMMENT_21 */\n\t    if (!VAR_9 && VAR_22->suffix)\n\t\tVAR_9 = fsmBackup(VAR_20.dirfd, VAR_6, VAR_22->action);\n\n\t    if (!VAR_9)\n\t\tVAR_9 = fsmCommit(VAR_20.dirfd, &VAR_22->fpath, VAR_6, VAR_22->action, VAR_22->suffix);\n\n\t    if (!VAR_9)\n\t\tVAR_22->stage = VAR_39;\n\t    else\n\t\t*VAR_4 = xstrdup(VAR_22->fpath);\n\n\t    /* COMMENT_22 */\n\t    rpmpluginsCallFsmFilePost(VAR_8, VAR_6, VAR_22->fpath,\n\t\t\t\t      VAR_22->sb.st_mode, VAR_22->action, VAR_9);\n\t}\n    }\n    VAR_6 = fsmIterFini(VAR_6, &VAR_20);\n\n    /* COMMENT_23 */\n    if (VAR_9) {\n\tVAR_6 = fsmIter(NULL, VAR_2, VAR_40, &VAR_20);\n\twhile ((VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\t    struct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n\t    /* COMMENT_24 */\n\t    if (ensureDir(NULL, rpmfiDN(VAR_6), 0, 0, 1, &VAR_20.dirfd))\n\t\tcontinue;\n\n\t    if (VAR_22->stage > VAR_41 && !VAR_22->skip) {\n\t\t(void) fsmRemove(VAR_20.dirfd, VAR_22->fpath, VAR_22->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(VAR_0, VAR_42), fdOp(VAR_5, VAR_43));\n    rpmswAdd(rpmtsOp(VAR_0, VAR_44), fdOp(VAR_5, VAR_45));\n\nexit:\n    VAR_6 = fsmIterFini(VAR_6, &VAR_20);\n    Fclose(VAR_5);\n    free(VAR_17);\n    for (int VAR_46 = 0; VAR_46 < VAR_11; VAR_46++)\n\tfree(VAR_18[VAR_46].fpath);\n    free(VAR_18);\n\n    return VAR_9;\n}",
  "func_graph_path_before": "rpm-software-management/rpm/25a435e90844ea98fe5eb7bef22c1aecf3a9c033/fsm.c/vul/before/0.json",
  "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\n\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n\t\t/* Only follow safe symlinks, and never on temporary files */\n\t\tfd = fsmOpenat(di.dirfd, fp->fpath,\n\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);\n\t\tif (fd < 0)\n\t\t    rc = RPMERR_OPEN_FAILED;\n\t    }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
  "abstract_func": "int rpmPackageFilesInstall(rpmts VAR_0, rpmte VAR_1, rpmfiles VAR_2,\n              rpmpsm VAR_3, char ** VAR_4)\n{\n    FD_t VAR_5 = rpmtePayload(VAR_1);\n    rpmfi VAR_6 = NULL;\n    rpmfs VAR_7 = rpmteGetFileStates(VAR_1);\n    rpmPlugins VAR_8 = rpmtsPlugins(VAR_0);\n    int VAR_9 = 0;\n    int VAR_10 = -1;\n    int VAR_11 = rpmfilesFC(VAR_2);\n    int VAR_12 = (rpmtsFlags(VAR_0) & VAR_13) ? 1 : 0;\n    int VAR_14 = (rpmtsFlags(VAR_0) & VAR_15) ? 1 : 0;\n    int VAR_16 = -1;\n    char *VAR_17 = NULL;\n    struct filedata_s *VAR_18 = xcalloc(VAR_11, sizeof(*VAR_18));\n    struct filedata_s *VAR_19 = NULL;\n    struct diriter_s VAR_20 = { -1 };\n\n    /* COMMENT_0 */\n    rasprintf(&VAR_17, \";%08x\", (unsigned)rpmtsGetTid(VAR_0));\n\n    /* COMMENT_1 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_21);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\tif (rpmfiFFlags(VAR_6) & VAR_23)\n            VAR_22->action = VAR_24;\n\telse\n\t    VAR_22->action = rpmfsGetAction(VAR_7, VAR_10);\n\tVAR_22->skip = XFA_SKIPPING(VAR_22->action);\n\tif (XFA_CREATING(VAR_22->action) && !S_ISDIR(rpmfiFMode(VAR_6)))\n\t    VAR_22->suffix = VAR_17;\n\tVAR_22->fpath = fsmFsPath(VAR_6, VAR_22->suffix);\n\n\t/* COMMENT_2 */\n\tVAR_9 = rpmfiStat(VAR_6, 1, &VAR_22->sb);\n\n\t/* COMMENT_3 */\n\tVAR_22->setmeta = (VAR_22->skip == 0) &&\n\t\t      (VAR_22->sb.st_nlink == 1 || VAR_22->action == VAR_25);\n\n\tsetFileState(VAR_7, VAR_10);\n\tfsmDebug(VAR_22->fpath, VAR_22->action, &VAR_22->sb);\n\n\tVAR_22->stage = VAR_26;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    if (VAR_9)\n\tgoto exit;\n\n    VAR_6 = fsmIter(VAR_5, VAR_2,\n\t\t VAR_5 ? VAR_27 : VAR_21, &VAR_20);\n\n    if (VAR_6 == NULL) {\n        VAR_9 = VAR_28;\n        goto exit;\n    }\n\n    /* COMMENT_4 */\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n\t/* COMMENT_5 */\n                                                                \n                                                               \n                                                              \n            \n    \n\tif (VAR_22->skip && VAR_19 && rpmfiArchiveHasContent(VAR_6))\n\t    VAR_22 = VAR_19;\n\n        if (!VAR_22->skip) {\n\t    int VAR_29 = -1;\n\t    /* COMMENT_11 */\n\t    if (!VAR_22->suffix && VAR_22 != VAR_19) {\n\t\tVAR_9 = fsmBackup(VAR_20.dirfd, VAR_6, VAR_22->action);\n\t    }\n\n\t    if (!VAR_9) {\n\t\tVAR_9 = ensureDir(VAR_8, rpmfiDN(VAR_6), 0,\n\t\t\t\t(VAR_22->action == VAR_30), 0, &VAR_20.dirfd);\n\t    }\n\n\t    /* COMMENT_12 */\n\t    VAR_9 = rpmpluginsCallFsmFilePre(VAR_8, VAR_6, VAR_22->fpath,\n\t\t\t\t\t  VAR_22->sb.st_mode, VAR_22->action);\n\t    if (VAR_9)\n\t\tgoto setmeta; /* COMMENT_13 */\n\n\t    /* COMMENT_14 */\n\t    if (!VAR_22->suffix) {\n\t\tif (VAR_22->action == VAR_25) {\n\t\t    struct stat VAR_31;\n\t\t    VAR_9 = fsmStat(VAR_20.dirfd, VAR_22->fpath, 1, &VAR_31);\n\t\t} else {\n\t\t    VAR_9 = fsmVerify(VAR_20.dirfd, VAR_22->fpath, VAR_6);\n\t\t}\n\t    } else {\n\t\tVAR_9 = VAR_32;\n\t    }\n\n\t    /* COMMENT_15 */\n\t    if (VAR_9 == VAR_32 && VAR_22->action == VAR_25) {\n\t\trpmlog(VAR_33, \"file %s vanished unexpectedly\\n\",\n\t\t\tVAR_22->fpath);\n\t\tVAR_22->action = VAR_30;\n\t\tfsmDebug(VAR_22->fpath, VAR_22->action, &VAR_22->sb);\n\t    }\n\n\t    /* COMMENT_16 */\n\t    if (VAR_22->action == VAR_25)\n\t\tgoto setmeta;\n\n            if (S_ISREG(VAR_22->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_32) {\n\t\t    VAR_9 = fsmMkfile(VAR_20.dirfd, VAR_6, VAR_22, VAR_2, VAR_3, VAR_12,\n\t\t\t\t   &VAR_19, &VAR_16, &VAR_29);\n\t\t}\n            } else if (S_ISDIR(VAR_22->sb.st_mode)) {\n                if (VAR_9 == VAR_32) {\n                    mode_t VAR_34 = VAR_22->sb.st_mode;\n                    VAR_34 &= ~07777;\n                    VAR_34 |=  00700;\n                    VAR_9 = fsmMkdir(VAR_20.dirfd, VAR_22->fpath, VAR_34);\n                }\n            } else if (S_ISLNK(VAR_22->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_32) {\n\t\t    VAR_9 = fsmSymlink(rpmfiFLink(VAR_6), VAR_20.dirfd, VAR_22->fpath);\n\t\t}\n            } else if (S_ISFIFO(VAR_22->sb.st_mode)) {\n                /* COMMENT_17 */\n                if (VAR_9 == VAR_32) {\n                    VAR_9 = fsmMkfifo(VAR_20.dirfd, VAR_22->fpath, 0000);\n                }\n            } else if (S_ISCHR(VAR_22->sb.st_mode) ||\n                       S_ISBLK(VAR_22->sb.st_mode) ||\n                       S_ISSOCK(VAR_22->sb.st_mode))\n            {\n                if (VAR_9 == VAR_32) {\n                    VAR_9 = fsmMknod(VAR_20.dirfd, VAR_22->fpath, VAR_22->sb.st_mode, VAR_22->sb.st_rdev);\n                }\n            } else {\n                /* COMMENT_18 */\n                if (!IS_DEV_LOG(VAR_22->fpath))\n                    VAR_9 = VAR_35;\n            }\n\n\t    if (!VAR_9 && VAR_29 == -1 && !S_ISLNK(VAR_22->sb.st_mode)) {\n\t\t/* COMMENT_19 */\n\t\tVAR_29 = fsmOpenat(VAR_20.dirfd, VAR_22->fpath,\n\t\t\t\tVAR_22->suffix ? VAR_36 : 0);\n\t\tif (VAR_29 < 0)\n\t\t    VAR_9 = VAR_37;\n\t    }\n\nsetmeta:\n\t    if (!VAR_9 && VAR_22->setmeta) {\n\t\tVAR_9 = fsmSetmeta(VAR_29, VAR_20.dirfd, VAR_22->fpath,\n\t\t\t\tVAR_6, VAR_8, VAR_22->action,\n\t\t\t\t&VAR_22->sb, VAR_14);\n\t    }\n\n\t    if (VAR_29 != VAR_16)\n\t\tfsmClose(&VAR_29);\n\t}\n\n\t/* COMMENT_20 */\n\tif (VAR_9)\n\t    *VAR_4 = xstrdup(VAR_22->fpath);\n\telse\n\t    rpmpsmNotify(VAR_3, VAR_38, rpmfiArchiveTell(VAR_6));\n\tVAR_22->stage = VAR_39;\n    }\n    VAR_6 = fsmIterFini(VAR_6, &VAR_20);\n\n    if (!VAR_9 && VAR_10 < 0 && VAR_10 != VAR_40)\n\tVAR_9 = VAR_10;\n\n    /* COMMENT_21 */\n    VAR_6 = fsmIter(NULL, VAR_2, VAR_21, &VAR_20);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n\tif (!VAR_22->skip) {\n\t    if (!VAR_9)\n\t\tVAR_9 = ensureDir(NULL, rpmfiDN(VAR_6), 0, 0, 0, &VAR_20.dirfd);\n\n\t    /* COMMENT_22 */\n\t    if (!VAR_9 && VAR_22->suffix)\n\t\tVAR_9 = fsmBackup(VAR_20.dirfd, VAR_6, VAR_22->action);\n\n\t    if (!VAR_9)\n\t\tVAR_9 = fsmCommit(VAR_20.dirfd, &VAR_22->fpath, VAR_6, VAR_22->action, VAR_22->suffix);\n\n\t    if (!VAR_9)\n\t\tVAR_22->stage = VAR_41;\n\t    else\n\t\t*VAR_4 = xstrdup(VAR_22->fpath);\n\n\t    /* COMMENT_23 */\n\t    rpmpluginsCallFsmFilePost(VAR_8, VAR_6, VAR_22->fpath,\n\t\t\t\t      VAR_22->sb.st_mode, VAR_22->action, VAR_9);\n\t}\n    }\n    VAR_6 = fsmIterFini(VAR_6, &VAR_20);\n\n    /* COMMENT_24 */\n    if (VAR_9) {\n\tVAR_6 = fsmIter(NULL, VAR_2, VAR_42, &VAR_20);\n\twhile ((VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\t    struct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n\t    /* COMMENT_25 */\n\t    if (ensureDir(NULL, rpmfiDN(VAR_6), 0, 0, 1, &VAR_20.dirfd))\n\t\tcontinue;\n\n\t    if (VAR_22->stage > VAR_43 && !VAR_22->skip) {\n\t\t(void) fsmRemove(VAR_20.dirfd, VAR_22->fpath, VAR_22->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(VAR_0, VAR_44), fdOp(VAR_5, VAR_45));\n    rpmswAdd(rpmtsOp(VAR_0, VAR_46), fdOp(VAR_5, VAR_47));\n\nexit:\n    VAR_6 = fsmIterFini(VAR_6, &VAR_20);\n    Fclose(VAR_5);\n    free(VAR_17);\n    for (int VAR_48 = 0; VAR_48 < VAR_11; VAR_48++)\n\tfree(VAR_18[VAR_48].fpath);\n    free(VAR_18);\n\n    return VAR_9;\n}",
  "func_graph_path": "rpm-software-management/rpm/25a435e90844ea98fe5eb7bef22c1aecf3a9c033/fsm.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -146,6 +146,14 @@\n                     rc = RPMERR_UNKNOWN_FILETYPE;\n             }\n \n+\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n+\t\t/* Only follow safe symlinks, and never on temporary files */\n+\t\tfd = fsmOpenat(di.dirfd, fp->fpath,\n+\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);\n+\t\tif (fd < 0)\n+\t\t    rc = RPMERR_OPEN_FAILED;\n+\t    }\n+\n setmeta:\n \t    if (!rc && fp->setmeta) {\n \t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {",
      "\t\t/* Only follow safe symlinks, and never on temporary files */",
      "\t\tfd = fsmOpenat(di.dirfd, fp->fpath,",
      "\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);",
      "\t\tif (fd < 0)",
      "\t\t    rc = RPMERR_OPEN_FAILED;",
      "\t    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/rpm/pull/1919",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/rpm-software-management/rpm/pull/1919: 403 Client Error: Forbidden for url: https://api.github.com/repos/rpm-software-management/rpm/pulls/1919",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}