{
  "cve_id": "CVE-2023-4322",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix 1byte heap oobread in the brainfuck disassembler\n\n* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/\n* Kudos to @7resp4ss for reporting",
  "commit_hash": "ba919adb74ac368bf76b150a00347ded78b572dd",
  "git_url": "https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd",
  "file_path": "libr/core/cmd_anal.c",
  "func_name": "_anal_calls",
  "func_before": "static void _anal_calls(RCore *core, ut64 addr, ut64 addr_end, bool printCommands, bool importsOnly) {\n\tRAnalOp op = {0};\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\tconst int addrbytes = core->io->addrbytes;\n\tconst int bsz = 4096;\n\tint bufi = 0;\n\tint bufi_max = bsz - 16;\n\tif (addr_end - addr > UT32_MAX) {\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsz);\n\tut8 *block0 = calloc (1, bsz);\n\tut8 *block1 = malloc (bsz);\n\tif (!buf || !block0 || !block1) {\n\t\tfree (buf);\n\t\tfree (block0);\n\t\tfree (block1);\n\t\treturn;\n\t}\n\tmemset (block1, -1, bsz);\n\tint minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (minop < 1) {\n\t\tminop = 1;\n\t}\n\tint setBits = r_config_get_i (core->config, \"asm.bits\");\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end && !r_cons_is_breaked ()) {\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > bufi_max) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\t(void)r_io_read_at (core->io, addr, buf, bsz);\n\t\t}\n\t\tif (!memcmp (buf, block0, bsz) || !memcmp (buf, block1, bsz)) {\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\t\tif (hint && hint->bits) {\n\t\t\tsetBits = hint->bits;\n\t\t}\n\t\tr_anal_hint_free (hint);\n\t\tif (setBits != core->rasm->config->bits) {\n\t\t\tr_config_set_i (core->config, \"asm.bits\", setBits);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tbool isValidCall = true;\n\t\t\t\tif (importsOnly) {\n\t\t\t\t\tRFlagItem *f = r_flag_get_i (core->flags, op.jump);\n\t\t\t\t\tif (!f || !strstr (f->name, \"imp.\")) {\n\t\t\t\t\t\tisValidCall = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRBinReloc *rel = r_core_getreloc (core, addr, op.size);\n\t\t\t\tif (rel && (rel->import || rel->symbol)) {\n\t\t\t\t\tisValidCall = false;\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n\t\t\t\t\tut8 buf[4] = {0};\n\t\t\t\t\tr_io_read_at (core->io, op.jump, buf, 4);\n\t\t\t\t\tisValidCall = memcmp (buf, \"\\x00\\x00\\x00\\x00\", 4);\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n#if JAYRO_03\n\t\t\t\t\tif (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {\n\t\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\t\t\tif (!fcn) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tif (printCommands) {\n\t\t\t\t\t\tr_cons_printf (\"ax 0x%08\" PFMT64x \" 0x%08\" PFMT64x \"\\n\", op.jump, addr);\n\t\t\t\t\t\tr_cons_printf (\"af @ 0x%08\" PFMT64x\"\\n\", op.jump);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// add xref here\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, addr, op.jump, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t\tif (r_io_is_valid_offset (core->io, op.jump, 1)) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\tif ((int)op.size < 1) {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += op.size;\n\t\tbufi += addrbytes * op.size;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tfree (block0);\n\tfree (block1);\n}",
  "abstract_func_before": "static void _anal_calls(RCore *VAR_0, ut64 VAR_1, ut64 VAR_2, bool VAR_3, bool VAR_4) {\n\tRAnalOp VAR_5 = {0};\n\tint VAR_6 = r_config_get_i (VAR_0->config, \"anal.depth\");\n\tconst int VAR_7 = VAR_0->io->addrbytes;\n\tconst int VAR_8 = 4096;\n\tint VAR_9 = 0;\n\tint VAR_10 = VAR_8 - 16;\n\tif (VAR_2 - VAR_1 > VAR_11) {\n\t\treturn;\n\t}\n\tut8 *VAR_12 = malloc (VAR_8);\n\tut8 *VAR_13 = calloc (1, VAR_8);\n\tut8 *VAR_14 = malloc (VAR_8);\n\tif (!VAR_12 || !VAR_13 || !VAR_14) {\n\t\tfree (VAR_12);\n\t\tfree (VAR_13);\n\t\tfree (VAR_14);\n\t\treturn;\n\t}\n\tmemset (VAR_14, -1, VAR_8);\n\tint VAR_15 = r_anal_archinfo (VAR_0->anal, VAR_16);\n\tif (VAR_15 < 1) {\n\t\tVAR_15 = 1;\n\t}\n\tint VAR_17 = r_config_get_i (VAR_0->config, \"asm.bits\");\n\tr_cons_break_push (NULL, NULL);\n\twhile (VAR_1 < VAR_2 && !r_cons_is_breaked ()) {\n\t\t/* COMMENT_0 */\n\t\tif (VAR_9 > VAR_10) {\n\t\t\tVAR_9 = 0;\n\t\t}\n\t\tif (!VAR_9) {\n\t\t\t(void)r_io_read_at (VAR_0->io, VAR_1, VAR_12, VAR_8);\n\t\t}\n\t\tif (!memcmp (VAR_12, VAR_13, VAR_8) || !memcmp (VAR_12, VAR_14, VAR_8)) {\n\t\t\tVAR_1 += VAR_8;\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalHint *VAR_18 = r_anal_hint_get (VAR_0->anal, VAR_1);\n\t\tif (VAR_18 && VAR_18->bits) {\n\t\t\tVAR_17 = VAR_18->bits;\n\t\t}\n\t\tr_anal_hint_free (VAR_18);\n\t\tif (VAR_17 != VAR_0->rasm->config->bits) {\n\t\t\tr_config_set_i (VAR_0->config, \"asm.bits\", VAR_17);\n\t\t}\n\t\tif (r_anal_op (VAR_0->anal, &VAR_5, VAR_1, VAR_12 + VAR_9, VAR_8 - VAR_9, 0) > 0) {\n\t\t\tif (VAR_5.size < 1) {\n\t\t\t\tVAR_5.size = VAR_15;\n\t\t\t}\n\t\t\tif (VAR_5.type == VAR_19) {\n\t\t\t\tbool VAR_20 = true;\n\t\t\t\tif (VAR_4) {\n\t\t\t\t\tRFlagItem *VAR_21 = r_flag_get_i (VAR_0->flags, VAR_5.jump);\n\t\t\t\t\tif (!VAR_21 || !strstr (VAR_21->name, \"imp.\")) {\n\t\t\t\t\t\tVAR_20 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRBinReloc *VAR_22 = r_core_getreloc (VAR_0, VAR_1, VAR_5.size);\n\t\t\t\tif (VAR_22 && (VAR_22->import || VAR_22->symbol)) {\n\t\t\t\t\tVAR_20 = false;\n\t\t\t\t}\n\t\t\t\tif (VAR_20) {\n\t\t\t\t\tut8 VAR_12[4] = {0};\n\t\t\t\t\tr_io_read_at (VAR_0->io, VAR_5.jump, VAR_12, 4);\n\t\t\t\t\tVAR_20 = memcmp (VAR_12, \"\\x00\\x00\\x00\\x00\", 4);\n\t\t\t\t}\n\t\t\t\tif (VAR_20) {\n#if VAR_23\n\t\t\t\t\tif (!anal_is_bad_call (VAR_0, VAR_24, VAR_25, VAR_1, VAR_12, VAR_9)) {\n\t\t\t\t\t\tVAR_26 = r_anal_get_fcn_in (VAR_0->anal, VAR_5.jump, VAR_27);\n\t\t\t\t\t\tif (!VAR_26) {\n\t\t\t\t\t\t\tr_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_28, VAR_6 - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tif (VAR_3) {\n\t\t\t\t\t\tr_cons_printf (\"ax 0x%08\" VAR_29 \" 0x%08\" VAR_29 \"\\n\", VAR_5.jump, VAR_1);\n\t\t\t\t\t\tr_cons_printf (\"af @ 0x%08\" VAR_29\"\\n\", VAR_5.jump);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_1 */\n\t\t\t\t\t\tr_anal_xrefs_set (VAR_0->anal, VAR_1, VAR_5.jump, VAR_28);\n\t\t\t\t\t\tif (r_io_is_valid_offset (VAR_0->io, VAR_5.jump, 1)) {\n\t\t\t\t\t\t\tr_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_28, VAR_6 - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_5.size = VAR_15;\n\t\t}\n\t\tif ((int)VAR_5.size < 1) {\n\t\t\tVAR_5.size = VAR_15;\n\t\t}\n\t\tVAR_1 += VAR_5.size;\n\t\tVAR_9 += VAR_7 * VAR_5.size;\n\t\tr_anal_op_fini (&VAR_5);\n\t}\n\tr_cons_break_pop ();\n\tfree (VAR_12);\n\tfree (VAR_13);\n\tfree (VAR_14);\n}",
  "func_graph_path_before": "radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/before/1.json",
  "func": "static void _anal_calls(RCore *core, ut64 addr, ut64 addr_end, bool printCommands, bool importsOnly) {\n\tRAnalOp op = {0};\n\tint depth = r_config_get_i (core->config, \"anal.depth\");\n\tconst int addrbytes = core->io->addrbytes;\n\tconst int bsz = 4096;\n\tint bufi = 0;\n\tint bufi_max = bsz - 16;\n\tif (addr_end - addr > UT32_MAX) {\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsz);\n\tut8 *block0 = calloc (1, bsz);\n\tut8 *block1 = malloc (bsz);\n\tif (!buf || !block0 || !block1) {\n\t\tfree (buf);\n\t\tfree (block0);\n\t\tfree (block1);\n\t\treturn;\n\t}\n\tmemset (block1, -1, bsz);\n\tint minop = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (minop < 1) {\n\t\tminop = 1;\n\t}\n\tint setBits = r_config_get_i (core->config, \"asm.bits\");\n\tr_cons_break_push (NULL, NULL);\n\twhile (addr < addr_end && !r_cons_is_breaked ()) {\n\t\t// TODO: too many ioreads here\n\t\tif (bufi > bufi_max) {\n\t\t\tbufi = 0;\n\t\t}\n\t\tif (!bufi) {\n\t\t\t(void)r_io_read_at (core->io, addr, buf, bsz);\n\t\t}\n\t\tif (!memcmp (buf, block0, bsz) || !memcmp (buf, block1, bsz)) {\n\t\t\taddr += bsz;\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalHint *hint = r_anal_hint_get (core->anal, addr);\n\t\tif (hint && hint->bits) {\n\t\t\tsetBits = hint->bits;\n\t\t}\n\t\tr_anal_hint_free (hint);\n\t\tif (setBits != core->rasm->config->bits) {\n\t\t\tr_config_set_i (core->config, \"asm.bits\", setBits);\n\t\t}\n\t\tif (r_anal_op (core->anal, &op, addr, buf + bufi, bsz - bufi, 0) > 0) {\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = minop;\n\t\t\t}\n\t\t\tif (op.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\tbool isValidCall = true;\n\t\t\t\tif (importsOnly) {\n\t\t\t\t\tRFlagItem *f = r_flag_get_i (core->flags, op.jump);\n\t\t\t\t\tif (!f || !strstr (f->name, \"imp.\")) {\n\t\t\t\t\t\tisValidCall = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRBinReloc *rel = r_core_getreloc (core, addr, op.size);\n\t\t\t\tif (rel && (rel->import || rel->symbol)) {\n\t\t\t\t\tisValidCall = false;\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n\t\t\t\t\tut8 zbuf[4] = {0};\n\t\t\t\t\tr_io_read_at (core->io, op.jump, zbuf, 4);\n\t\t\t\t\tisValidCall = memcmp (zbuf, \"\\x00\\x00\\x00\\x00\", 4);\n\t\t\t\t}\n\t\t\t\tif (isValidCall) {\n#if JAYRO_03\n\t\t\t\t\tif (!anal_is_bad_call (core, from, to, addr, buf, bufi)) {\n\t\t\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, op.jump, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\t\t\tif (!fcn) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tif (printCommands) {\n\t\t\t\t\t\tr_cons_printf (\"ax 0x%08\" PFMT64x \" 0x%08\" PFMT64x \"\\n\", op.jump, addr);\n\t\t\t\t\t\tr_cons_printf (\"af @ 0x%08\" PFMT64x\"\\n\", op.jump);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// add xref here\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, addr, op.jump, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t\tif (r_io_is_valid_offset (core->io, op.jump, 1)) {\n\t\t\t\t\t\t\tr_core_anal_fcn (core, op.jump, addr, R_ANAL_REF_TYPE_CALL, depth - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\top.size = minop;\n\t\t}\n\t\tif ((int)op.size < 1) {\n\t\t\top.size = minop;\n\t\t}\n\t\taddr += op.size;\n\t\tbufi += addrbytes * op.size;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tfree (block0);\n\tfree (block1);\n}",
  "abstract_func": "static void _anal_calls(RCore *VAR_0, ut64 VAR_1, ut64 VAR_2, bool VAR_3, bool VAR_4) {\n\tRAnalOp VAR_5 = {0};\n\tint VAR_6 = r_config_get_i (VAR_0->config, \"anal.depth\");\n\tconst int VAR_7 = VAR_0->io->addrbytes;\n\tconst int VAR_8 = 4096;\n\tint VAR_9 = 0;\n\tint VAR_10 = VAR_8 - 16;\n\tif (VAR_2 - VAR_1 > VAR_11) {\n\t\treturn;\n\t}\n\tut8 *VAR_12 = malloc (VAR_8);\n\tut8 *VAR_13 = calloc (1, VAR_8);\n\tut8 *VAR_14 = malloc (VAR_8);\n\tif (!VAR_12 || !VAR_13 || !VAR_14) {\n\t\tfree (VAR_12);\n\t\tfree (VAR_13);\n\t\tfree (VAR_14);\n\t\treturn;\n\t}\n\tmemset (VAR_14, -1, VAR_8);\n\tint VAR_15 = r_anal_archinfo (VAR_0->anal, VAR_16);\n\tif (VAR_15 < 1) {\n\t\tVAR_15 = 1;\n\t}\n\tint VAR_17 = r_config_get_i (VAR_0->config, \"asm.bits\");\n\tr_cons_break_push (NULL, NULL);\n\twhile (VAR_1 < VAR_2 && !r_cons_is_breaked ()) {\n\t\t/* COMMENT_0 */\n\t\tif (VAR_9 > VAR_10) {\n\t\t\tVAR_9 = 0;\n\t\t}\n\t\tif (!VAR_9) {\n\t\t\t(void)r_io_read_at (VAR_0->io, VAR_1, VAR_12, VAR_8);\n\t\t}\n\t\tif (!memcmp (VAR_12, VAR_13, VAR_8) || !memcmp (VAR_12, VAR_14, VAR_8)) {\n\t\t\tVAR_1 += VAR_8;\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalHint *VAR_18 = r_anal_hint_get (VAR_0->anal, VAR_1);\n\t\tif (VAR_18 && VAR_18->bits) {\n\t\t\tVAR_17 = VAR_18->bits;\n\t\t}\n\t\tr_anal_hint_free (VAR_18);\n\t\tif (VAR_17 != VAR_0->rasm->config->bits) {\n\t\t\tr_config_set_i (VAR_0->config, \"asm.bits\", VAR_17);\n\t\t}\n\t\tif (r_anal_op (VAR_0->anal, &VAR_5, VAR_1, VAR_12 + VAR_9, VAR_8 - VAR_9, 0) > 0) {\n\t\t\tif (VAR_5.size < 1) {\n\t\t\t\tVAR_5.size = VAR_15;\n\t\t\t}\n\t\t\tif (VAR_5.type == VAR_19) {\n\t\t\t\tbool VAR_20 = true;\n\t\t\t\tif (VAR_4) {\n\t\t\t\t\tRFlagItem *VAR_21 = r_flag_get_i (VAR_0->flags, VAR_5.jump);\n\t\t\t\t\tif (!VAR_21 || !strstr (VAR_21->name, \"imp.\")) {\n\t\t\t\t\t\tVAR_20 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRBinReloc *VAR_22 = r_core_getreloc (VAR_0, VAR_1, VAR_5.size);\n\t\t\t\tif (VAR_22 && (VAR_22->import || VAR_22->symbol)) {\n\t\t\t\t\tVAR_20 = false;\n\t\t\t\t}\n\t\t\t\tif (VAR_20) {\n\t\t\t\t\tut8 VAR_23[4] = {0};\n\t\t\t\t\tr_io_read_at (VAR_0->io, VAR_5.jump, VAR_23, 4);\n\t\t\t\t\tVAR_20 = memcmp (VAR_23, \"\\x00\\x00\\x00\\x00\", 4);\n\t\t\t\t}\n\t\t\t\tif (VAR_20) {\n#if VAR_24\n\t\t\t\t\tif (!anal_is_bad_call (VAR_0, VAR_25, VAR_26, VAR_1, VAR_12, VAR_9)) {\n\t\t\t\t\t\tVAR_27 = r_anal_get_fcn_in (VAR_0->anal, VAR_5.jump, VAR_28);\n\t\t\t\t\t\tif (!VAR_27) {\n\t\t\t\t\t\t\tr_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_29, VAR_6 - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#else\n\t\t\t\t\tif (VAR_3) {\n\t\t\t\t\t\tr_cons_printf (\"ax 0x%08\" VAR_30 \" 0x%08\" VAR_30 \"\\n\", VAR_5.jump, VAR_1);\n\t\t\t\t\t\tr_cons_printf (\"af @ 0x%08\" VAR_30\"\\n\", VAR_5.jump);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_1 */\n\t\t\t\t\t\tr_anal_xrefs_set (VAR_0->anal, VAR_1, VAR_5.jump, VAR_29);\n\t\t\t\t\t\tif (r_io_is_valid_offset (VAR_0->io, VAR_5.jump, 1)) {\n\t\t\t\t\t\t\tr_core_anal_fcn (VAR_0, VAR_5.jump, VAR_1, VAR_29, VAR_6 - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_5.size = VAR_15;\n\t\t}\n\t\tif ((int)VAR_5.size < 1) {\n\t\t\tVAR_5.size = VAR_15;\n\t\t}\n\t\tVAR_1 += VAR_5.size;\n\t\tVAR_9 += VAR_7 * VAR_5.size;\n\t\tr_anal_op_fini (&VAR_5);\n\t}\n\tr_cons_break_pop ();\n\tfree (VAR_12);\n\tfree (VAR_13);\n\tfree (VAR_14);\n}",
  "func_graph_path": "radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/cmd_anal.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -61,9 +61,9 @@\n \t\t\t\t\tisValidCall = false;\n \t\t\t\t}\n \t\t\t\tif (isValidCall) {\n-\t\t\t\t\tut8 buf[4] = {0};\n-\t\t\t\t\tr_io_read_at (core->io, op.jump, buf, 4);\n-\t\t\t\t\tisValidCall = memcmp (buf, \"\\x00\\x00\\x00\\x00\", 4);\n+\t\t\t\t\tut8 zbuf[4] = {0};\n+\t\t\t\t\tr_io_read_at (core->io, op.jump, zbuf, 4);\n+\t\t\t\t\tisValidCall = memcmp (zbuf, \"\\x00\\x00\\x00\\x00\", 4);\n \t\t\t\t}\n \t\t\t\tif (isValidCall) {\n #if JAYRO_03",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\tut8 buf[4] = {0};",
      "\t\t\t\t\tr_io_read_at (core->io, op.jump, buf, 4);",
      "\t\t\t\t\tisValidCall = memcmp (buf, \"\\x00\\x00\\x00\\x00\", 4);"
    ],
    "added_lines": [
      "\t\t\t\t\tut8 zbuf[4] = {0};",
      "\t\t\t\t\tr_io_read_at (core->io, op.jump, zbuf, 4);",
      "\t\t\t\t\tisValidCall = memcmp (zbuf, \"\\x00\\x00\\x00\\x00\", 4);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/22154",
  "description": {
    "pr_info": {
      "title": "Fix 1byte heap oobread in the brainfuck disassembler",
      "number": 22154
    },
    "comment": [
      "* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/\r\n* Kudos to @7resp4ss for reporting\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n\r\n**Copilot**\r\n\r\n<!--\r\ncopilot:all\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}