{
  "cve_id": "CVE-2020-26682",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "outline: fix overflows in outline processing\n\nThis commit enforces strict invariant on ASS_Outline\nto contain point coordinates into predetermined range.\n\nFixes https://github.com/libass/libass/issues/431.",
  "commit_hash": "676f9dc5b52ef406c5527bdadbcb947f11392929",
  "git_url": "https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929",
  "file_path": "libass/ass_outline.c",
  "func_name": "outline_transform_2d",
  "func_before": "bool outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,\n                         const double m[2][3])\n{\n    if (!source || !source->n_points) {\n        outline_clear(outline);\n        return true;\n    }\n\n    if (!outline_alloc(outline, source->n_points, source->n_segments))\n        return false;\n\n    const ASS_Vector *pt = source->points;\n    for (size_t i = 0; i < source->n_points; i++) {\n        double v[2];\n        for (int k = 0; k < 2; k++)\n            v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];\n\n        outline->points[i].x = lrint(v[0]);\n        outline->points[i].y = lrint(v[1]);\n    }\n    memcpy(outline->segments, source->segments, source->n_segments);\n    outline->n_points = source->n_points;\n    outline->n_segments = source->n_segments;\n    return true;\n}",
  "abstract_func_before": "bool outline_transform_2d(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,\n                         const double VAR_2[2][3])\n{\n    if (!VAR_1 || !VAR_1->n_points) {\n        outline_clear(VAR_0);\n        return true;\n    }\n\n    if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))\n        return false;\n\n    const ASS_Vector *VAR_3 = VAR_1->points;\n    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++) {\n        double VAR_5[2];\n        for (int VAR_6 = 0; VAR_6 < 2; VAR_6++)\n            VAR_5[VAR_6] = VAR_2[VAR_6][0] * VAR_3[VAR_4].x + VAR_2[VAR_6][1] * VAR_3[VAR_4].y + VAR_2[VAR_6][2];\n\n        VAR_0->points[VAR_4].x = lrint(VAR_5[0]);\n        VAR_0->points[VAR_4].y = lrint(VAR_5[1]);\n    }\n    memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);\n    VAR_0->n_points = VAR_1->n_points;\n    VAR_0->n_segments = VAR_1->n_segments;\n    return true;\n}",
  "func_graph_path_before": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/3.json",
  "func": "bool outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,\n                         const double m[2][3])\n{\n    if (!source || !source->n_points) {\n        outline_clear(outline);\n        return true;\n    }\n\n    if (!outline_alloc(outline, source->n_points, source->n_segments))\n        return false;\n\n    const ASS_Vector *pt = source->points;\n    for (size_t i = 0; i < source->n_points; i++) {\n        double v[2];\n        for (int k = 0; k < 2; k++)\n            v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];\n\n        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {\n            outline_free(outline);\n            return false;\n        }\n        outline->points[i].x = lrint(v[0]);\n        outline->points[i].y = lrint(v[1]);\n    }\n    memcpy(outline->segments, source->segments, source->n_segments);\n    outline->n_points = source->n_points;\n    outline->n_segments = source->n_segments;\n    return true;\n}",
  "abstract_func": "bool outline_transform_2d(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,\n                         const double VAR_2[2][3])\n{\n    if (!VAR_1 || !VAR_1->n_points) {\n        outline_clear(VAR_0);\n        return true;\n    }\n\n    if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))\n        return false;\n\n    const ASS_Vector *VAR_3 = VAR_1->points;\n    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++) {\n        double VAR_5[2];\n        for (int VAR_6 = 0; VAR_6 < 2; VAR_6++)\n            VAR_5[VAR_6] = VAR_2[VAR_6][0] * VAR_3[VAR_4].x + VAR_2[VAR_6][1] * VAR_3[VAR_4].y + VAR_2[VAR_6][2];\n\n        if (!(fabs(VAR_5[0]) < VAR_7 && fabs(VAR_5[1]) < VAR_7)) {\n            outline_free(VAR_0);\n            return false;\n        }\n        VAR_0->points[VAR_4].x = lrint(VAR_5[0]);\n        VAR_0->points[VAR_4].y = lrint(VAR_5[1]);\n    }\n    memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);\n    VAR_0->n_points = VAR_1->n_points;\n    VAR_0->n_segments = VAR_1->n_segments;\n    return true;\n}",
  "func_graph_path": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,10 @@\n         for (int k = 0; k < 2; k++)\n             v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];\n \n+        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {\n+            outline_free(outline);\n+            return false;\n+        }\n         outline->points[i].x = lrint(v[0]);\n         outline->points[i].y = lrint(v[1]);\n     }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {",
      "            outline_free(outline);",
      "            return false;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/432",
  "description": {
    "pr_info": {
      "title": "Fix overflows in outline processing",
      "number": 432
    },
    "comment": [
      "I've added a couple of checks for overflows in outline pipeline. Should fix #431, but I'm not familiar with that fuzzing business so I can't ascertain it for now.",
      "Can confirm that this fixes #431. \r\n\r\nOverflow checks seem fine to me. *(Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess)*",
      "> Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess\r\n\r\nMaybe it's even better to get rid of `OUTLINE_MIN` altogether and use `-OUTLINE_MAX` instead.",
      "New, more strict version. `max(abs(x), abs(y)) <= OUTLINE_MAX` is now enforced invariant of `ASS_Outline` instead of some ad hoc check. Also I've got rid of `OUTLINE_MIN`.",
      "@MrSmile \r\n\r\n```\r\nass_outline.c:53:12: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^\r\nass_outline.c:53:12: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^~~\r\n           labs\r\nass_outline.c:53:41: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^\r\nass_outline.c:53:41: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^~~\r\n                                        labs\r\n```",
      "FT docs specify that `FT_Pos` is 16.16 or 26.6 fixed-point representation, so I'm not sure what's better, to cast into `int32_t` or use `labs` here.",
      "Just use `labs`. In a way, this will also serve as a sanity check to ensure the FT docs arenâ€™t lying."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}