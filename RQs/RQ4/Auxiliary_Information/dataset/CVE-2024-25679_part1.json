{
  "cve_id": "CVE-2024-25679",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "p-quic/pquic",
  "commit_msg": "discard the keys after handshake is done; use the correct original_destination_connection_id; discard the re-transmission packets correctly; limit the active_connection_id",
  "commit_hash": "2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "git_url": "https://github.com/p-quic/pquic/commit/2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "file_path": "picoquic/frames.c",
  "func_name": "parse_new_connection_id_frame",
  "func_before": "protoop_arg_t parse_new_connection_id_frame(picoquic_cnx_t* cnx)\n{\n    uint8_t* bytes = (uint8_t *) cnx->protoop_inputv[0];\n    const uint8_t* bytes_max = (const uint8_t *) cnx->protoop_inputv[1];\n\n    int ack_needed = 1;\n    int is_retransmittable = 1;\n    new_connection_id_frame_t *frame = malloc(sizeof(new_connection_id_frame_t));\n    if (!frame) {\n        printf(\"Failed to allocate memory for new_connection_id_frame_t\\n\");\n        protoop_save_outputs(cnx, frame, ack_needed, is_retransmittable);\n        return (protoop_arg_t) NULL;\n    }\n\n    if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||\n        (bytes = picoquic_frames_varint_decode(bytes, bytes_max, &frame->retire_prior_to)) == NULL ||\n        (bytes = picoquic_frames_uint8_decode(bytes, bytes_max, &frame->connection_id.id_len)) == NULL ||\n        (frame->connection_id.id_len > PICOQUIC_CONNECTION_ID_MAX_SIZE) ||\n        (bytes = (bytes + frame->connection_id.id_len + 16 <= bytes_max ? bytes : NULL)) == NULL)\n    {\n        bytes = NULL;\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_FRAME_FORMAT_ERROR,\n            picoquic_frame_type_new_connection_id);\n        free(frame);\n        frame = NULL;\n    }\n    else\n    {\n        /* Memory bounds have been checked, so everything should be safe now */\n        memcpy(&frame->connection_id.id, bytes, frame->connection_id.id_len);\n        bytes += frame->connection_id.id_len;\n        memcpy(&frame->stateless_reset_token, bytes, 16);\n        bytes += 16;\n    }\n\n    protoop_save_outputs(cnx, frame, ack_needed, is_retransmittable);\n    return (protoop_arg_t) bytes;\n}",
  "abstract_func_before": "protoop_arg_t parse_new_connection_id_frame(picoquic_cnx_t* VAR_0)\n{\n    uint8_t* VAR_1 = (uint8_t *) VAR_0->protoop_inputv[0];\n    const uint8_t* VAR_2 = (const uint8_t *) VAR_0->protoop_inputv[1];\n\n    int VAR_3 = 1;\n    int VAR_4 = 1;\n    new_connection_id_frame_t *VAR_5 = malloc(sizeof(new_connection_id_frame_t));\n    if (!VAR_5) {\n        printf(\"Failed to allocate memory for new_connection_id_frame_t\\n\");\n        protoop_save_outputs(VAR_0, VAR_5, VAR_3, VAR_4);\n        return (protoop_arg_t) NULL;\n    }\n\n    if ((VAR_1 = picoquic_frames_varint_decode(VAR_1 + picoquic_varint_skip(VAR_1), VAR_2, &VAR_5->sequence)) == NULL ||\n        (VAR_1 = picoquic_frames_varint_decode(VAR_1, VAR_2, &VAR_5->retire_prior_to)) == NULL ||\n        (VAR_1 = picoquic_frames_uint8_decode(VAR_1, VAR_2, &VAR_5->connection_id.id_len)) == NULL ||\n        (VAR_5->connection_id.id_len > VAR_6) ||\n        (VAR_1 = (VAR_1 + VAR_5->connection_id.id_len + 16 <= VAR_2 ? VAR_1 : NULL)) == NULL)\n    {\n        VAR_1 = NULL;\n        picoquic_connection_error(VAR_0, VAR_7,\n            VAR_8);\n        free(VAR_5);\n        VAR_5 = NULL;\n    }\n    else\n    {\n        /* COMMENT_0 */\n        memcpy(&VAR_5->connection_id.id, VAR_1, VAR_5->connection_id.id_len);\n        VAR_1 += VAR_5->connection_id.id_len;\n        memcpy(&VAR_5->stateless_reset_token, VAR_1, 16);\n        VAR_1 += 16;\n    }\n\n    protoop_save_outputs(VAR_0, VAR_5, VAR_3, VAR_4);\n    return (protoop_arg_t) VAR_1;\n}",
  "func_graph_path_before": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/frames.c/vul/before/0.json",
  "func": "protoop_arg_t parse_new_connection_id_frame(picoquic_cnx_t* cnx)\n{\n    uint8_t* bytes = (uint8_t *) cnx->protoop_inputv[0];\n    const uint8_t* bytes_max = (const uint8_t *) cnx->protoop_inputv[1];\n\n    int ack_needed = 1;\n    int is_retransmittable = 1;\n    new_connection_id_frame_t *frame = malloc(sizeof(new_connection_id_frame_t));\n    if (!frame) {\n        printf(\"Failed to allocate memory for new_connection_id_frame_t\\n\");\n        protoop_save_outputs(cnx, frame, ack_needed, is_retransmittable);\n        return (protoop_arg_t) NULL;\n    }\n\n    if (cnx->active_connection_id_count >= cnx->local_parameters.active_connection_id_limit) {\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_CONNECTION_ID_LIMIT_ERROR, picoquic_frame_type_new_connection_id);\n        picoquic_reinsert_by_wake_time(cnx->quic, cnx, picoquic_current_time());\n        return (protoop_arg_t) NULL;\n    } else if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||\n        (bytes = picoquic_frames_varint_decode(bytes, bytes_max, &frame->retire_prior_to)) == NULL ||\n        (bytes = picoquic_frames_uint8_decode(bytes, bytes_max, &frame->connection_id.id_len)) == NULL ||\n        (frame->connection_id.id_len > PICOQUIC_CONNECTION_ID_MAX_SIZE) ||\n        (bytes = (bytes + frame->connection_id.id_len + 16 <= bytes_max ? bytes : NULL)) == NULL)\n    {\n        bytes = NULL;\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_FRAME_FORMAT_ERROR,\n            picoquic_frame_type_new_connection_id);\n        free(frame);\n        frame = NULL;\n    }\n    else\n    {\n        /* Memory bounds have been checked, so everything should be safe now */\n        memcpy(&frame->connection_id.id, bytes, frame->connection_id.id_len);\n        bytes += frame->connection_id.id_len;\n        memcpy(&frame->stateless_reset_token, bytes, 16);\n        bytes += 16;\n        cnx->active_connection_id_count++;\n    }\n\n    protoop_save_outputs(cnx, frame, ack_needed, is_retransmittable);\n    return (protoop_arg_t) bytes;\n}",
  "abstract_func": "protoop_arg_t parse_new_connection_id_frame(picoquic_cnx_t* VAR_0)\n{\n    uint8_t* VAR_1 = (uint8_t *) VAR_0->protoop_inputv[0];\n    const uint8_t* VAR_2 = (const uint8_t *) VAR_0->protoop_inputv[1];\n\n    int VAR_3 = 1;\n    int VAR_4 = 1;\n    new_connection_id_frame_t *VAR_5 = malloc(sizeof(new_connection_id_frame_t));\n    if (!VAR_5) {\n        printf(\"Failed to allocate memory for new_connection_id_frame_t\\n\");\n        protoop_save_outputs(VAR_0, VAR_5, VAR_3, VAR_4);\n        return (protoop_arg_t) NULL;\n    }\n\n    if (VAR_0->active_connection_id_count >= VAR_0->local_parameters.active_connection_id_limit) {\n        picoquic_connection_error(VAR_0, VAR_6, VAR_7);\n        picoquic_reinsert_by_wake_time(VAR_0->quic, VAR_0, picoquic_current_time());\n        return (protoop_arg_t) NULL;\n    } else if ((VAR_1 = picoquic_frames_varint_decode(VAR_1 + picoquic_varint_skip(VAR_1), VAR_2, &VAR_5->sequence)) == NULL ||\n        (VAR_1 = picoquic_frames_varint_decode(VAR_1, VAR_2, &VAR_5->retire_prior_to)) == NULL ||\n        (VAR_1 = picoquic_frames_uint8_decode(VAR_1, VAR_2, &VAR_5->connection_id.id_len)) == NULL ||\n        (VAR_5->connection_id.id_len > VAR_8) ||\n        (VAR_1 = (VAR_1 + VAR_5->connection_id.id_len + 16 <= VAR_2 ? VAR_1 : NULL)) == NULL)\n    {\n        VAR_1 = NULL;\n        picoquic_connection_error(VAR_0, VAR_9,\n            VAR_7);\n        free(VAR_5);\n        VAR_5 = NULL;\n    }\n    else\n    {\n        /* COMMENT_0 */\n        memcpy(&VAR_5->connection_id.id, VAR_1, VAR_5->connection_id.id_len);\n        VAR_1 += VAR_5->connection_id.id_len;\n        memcpy(&VAR_5->stateless_reset_token, VAR_1, 16);\n        VAR_1 += 16;\n        VAR_0->active_connection_id_count++;\n    }\n\n    protoop_save_outputs(VAR_0, VAR_5, VAR_3, VAR_4);\n    return (protoop_arg_t) VAR_1;\n}",
  "func_graph_path": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/frames.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,11 @@\n         return (protoop_arg_t) NULL;\n     }\n \n-    if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||\n+    if (cnx->active_connection_id_count >= cnx->local_parameters.active_connection_id_limit) {\n+        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_CONNECTION_ID_LIMIT_ERROR, picoquic_frame_type_new_connection_id);\n+        picoquic_reinsert_by_wake_time(cnx->quic, cnx, picoquic_current_time());\n+        return (protoop_arg_t) NULL;\n+    } else if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||\n         (bytes = picoquic_frames_varint_decode(bytes, bytes_max, &frame->retire_prior_to)) == NULL ||\n         (bytes = picoquic_frames_uint8_decode(bytes, bytes_max, &frame->connection_id.id_len)) == NULL ||\n         (frame->connection_id.id_len > PICOQUIC_CONNECTION_ID_MAX_SIZE) ||\n@@ -31,6 +35,7 @@\n         bytes += frame->connection_id.id_len;\n         memcpy(&frame->stateless_reset_token, bytes, 16);\n         bytes += 16;\n+        cnx->active_connection_id_count++;\n     }\n \n     protoop_save_outputs(cnx, frame, ack_needed, is_retransmittable);",
  "diff_line_info": {
    "deleted_lines": [
      "    if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||"
    ],
    "added_lines": [
      "    if (cnx->active_connection_id_count >= cnx->local_parameters.active_connection_id_limit) {",
      "        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_CONNECTION_ID_LIMIT_ERROR, picoquic_frame_type_new_connection_id);",
      "        picoquic_reinsert_by_wake_time(cnx->quic, cnx, picoquic_current_time());",
      "        return (protoop_arg_t) NULL;",
      "    } else if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||",
      "        cnx->active_connection_id_count++;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/p-quic/pquic/pull/39",
  "description": {
    "pr_info": {
      "title": "Minor Fix",
      "number": 39
    },
    "comment": [
      "Hi, I try to fix the bugs in #34 #35 #36 and #38.\r\n\r\nCan you validate these fixes please.\r\n",
      "The code looks good. Have you done any test to ensure it fixes these issues ?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}