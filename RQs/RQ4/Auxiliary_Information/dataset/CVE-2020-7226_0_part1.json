{
  "cve_id": "CVE-2020-7226",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "vt-middleware/cryptacular",
  "commit_msg": "Define new ciphertext header format.\n\nNew format does not allocate any memory until HMAC check passes, which\nguards against untrusted input. All encryption components have been\nupdated to use the new header, while preserving backward compatibility\nto decrypt messages encrypted with the old format. The decoding process\nfor the old header has been hardened to impose reasonable limits on header\nfields: nonce sizes up to 255 bytes, key names up to 500 bytes.\n\nFixes #52.",
  "commit_hash": "8c6c7528f1e24c6b71f3e36db0cb8a697256ce25",
  "git_url": "https://github.com/vt-middleware/cryptacular/commit/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25",
  "file_path": "src/main/java/org/cryptacular/bean/AbstractBlockCipherBean.java",
  "func_name": "process",
  "func_before": "@Override\n  protected byte[] process(final CiphertextHeader header, final boolean mode, final byte[] input)\n  {\n    final BlockCipherAdapter cipher = newCipher(header, mode);\n    final byte[] headerBytes = header.encode();\n    int outOff;\n    final int inOff;\n    final int length;\n    final byte[] output;\n    if (mode) {\n      final int outSize = headerBytes.length + cipher.getOutputSize(input.length);\n      output = new byte[outSize];\n      System.arraycopy(headerBytes, 0, output, 0, headerBytes.length);\n      inOff = 0;\n      outOff = headerBytes.length;\n      length = input.length;\n    } else {\n      length = input.length - headerBytes.length;\n\n      final int outSize = cipher.getOutputSize(length);\n      output = new byte[outSize];\n      inOff = headerBytes.length;\n      outOff = 0;\n    }\n    outOff += cipher.processBytes(input, inOff, length, output, outOff);\n    outOff += cipher.doFinal(output, outOff);\n    if (outOff < output.length) {\n      final byte[] copy = new byte[outOff];\n      System.arraycopy(output, 0, copy, 0, outOff);\n      return copy;\n    }\n    return output;\n  }",
  "abstract_func_before": "@Override\n  protected byte[] process(final CiphertextHeader VAR_0, final boolean VAR_1, final byte[] VAR_2)\n  {\n    final BlockCipherAdapter VAR_3 = newCipher(VAR_0, VAR_1);\n    final byte[] VAR_4 = VAR_0.encode();\n    int VAR_5;\n    final int VAR_6;\n    final int VAR_7;\n    final byte[] VAR_8;\n    if (VAR_1) {\n      final int VAR_9 = VAR_4.length + VAR_3.getOutputSize(VAR_2.length);\n      VAR_8 = new byte[VAR_9];\n      VAR_10.arraycopy(VAR_4, 0, VAR_8, 0, VAR_4.length);\n      VAR_6 = 0;\n      VAR_5 = VAR_4.length;\n      VAR_7 = VAR_2.length;\n    } else {\n      VAR_7 = VAR_2.length - VAR_4.length;\n\n      final int VAR_9 = VAR_3.getOutputSize(VAR_7);\n      VAR_8 = new byte[VAR_9];\n      VAR_6 = VAR_4.length;\n      VAR_5 = 0;\n    }\n    VAR_5 += VAR_3.processBytes(VAR_2, VAR_6, VAR_7, VAR_8, VAR_5);\n    VAR_5 += VAR_3.doFinal(VAR_8, VAR_5);\n    if (VAR_5 < VAR_8.length) {\n      final byte[] VAR_11 = new byte[VAR_5];\n      VAR_10.arraycopy(VAR_8, 0, VAR_11, 0, VAR_5);\n      return VAR_11;\n    }\n    return VAR_8;\n  }",
  "func_graph_path_before": "vt-middleware/cryptacular/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25/AbstractBlockCipherBean.java/vul/before/1.json",
  "func": "@Override\n  protected byte[] process(final CiphertextHeader header, final boolean mode, final byte[] input)\n  {\n    final BlockCipherAdapter cipher = newCipher(header, mode);\n    int outOff;\n    final int inOff;\n    final int length;\n    final byte[] output;\n    if (mode) {\n      final byte[] headerBytes = header.encode();\n      final int outSize = headerBytes.length + cipher.getOutputSize(input.length);\n      output = new byte[outSize];\n      System.arraycopy(headerBytes, 0, output, 0, headerBytes.length);\n      inOff = 0;\n      outOff = headerBytes.length;\n      length = input.length;\n    } else {\n      outOff = 0;\n      inOff = header.getLength();\n      length = input.length - inOff;\n\n      final int outSize = cipher.getOutputSize(length);\n      output = new byte[outSize];\n    }\n    outOff += cipher.processBytes(input, inOff, length, output, outOff);\n    outOff += cipher.doFinal(output, outOff);\n    if (outOff < output.length) {\n      final byte[] copy = new byte[outOff];\n      System.arraycopy(output, 0, copy, 0, outOff);\n      return copy;\n    }\n    return output;\n  }",
  "abstract_func": "@Override\n  protected byte[] process(final CiphertextHeader VAR_0, final boolean VAR_1, final byte[] VAR_2)\n  {\n    final BlockCipherAdapter VAR_3 = newCipher(VAR_0, VAR_1);\n    int VAR_4;\n    final int VAR_5;\n    final int VAR_6;\n    final byte[] VAR_7;\n    if (VAR_1) {\n      final byte[] VAR_8 = VAR_0.encode();\n      final int VAR_9 = VAR_8.length + VAR_3.getOutputSize(VAR_2.length);\n      VAR_7 = new byte[VAR_9];\n      VAR_10.arraycopy(VAR_8, 0, VAR_7, 0, VAR_8.length);\n      VAR_5 = 0;\n      VAR_4 = VAR_8.length;\n      VAR_6 = VAR_2.length;\n    } else {\n      VAR_4 = 0;\n      VAR_5 = VAR_0.getLength();\n      VAR_6 = VAR_2.length - VAR_5;\n\n      final int VAR_9 = VAR_3.getOutputSize(VAR_6);\n      VAR_7 = new byte[VAR_9];\n    }\n    VAR_4 += VAR_3.processBytes(VAR_2, VAR_5, VAR_6, VAR_7, VAR_4);\n    VAR_4 += VAR_3.doFinal(VAR_7, VAR_4);\n    if (VAR_4 < VAR_7.length) {\n      final byte[] VAR_11 = new byte[VAR_4];\n      VAR_10.arraycopy(VAR_7, 0, VAR_11, 0, VAR_4);\n      return VAR_11;\n    }\n    return VAR_7;\n  }",
  "func_graph_path": "vt-middleware/cryptacular/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25/AbstractBlockCipherBean.java/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,12 @@\n   protected byte[] process(final CiphertextHeader header, final boolean mode, final byte[] input)\n   {\n     final BlockCipherAdapter cipher = newCipher(header, mode);\n-    final byte[] headerBytes = header.encode();\n     int outOff;\n     final int inOff;\n     final int length;\n     final byte[] output;\n     if (mode) {\n+      final byte[] headerBytes = header.encode();\n       final int outSize = headerBytes.length + cipher.getOutputSize(input.length);\n       output = new byte[outSize];\n       System.arraycopy(headerBytes, 0, output, 0, headerBytes.length);\n@@ -15,12 +15,12 @@\n       outOff = headerBytes.length;\n       length = input.length;\n     } else {\n-      length = input.length - headerBytes.length;\n+      outOff = 0;\n+      inOff = header.getLength();\n+      length = input.length - inOff;\n \n       final int outSize = cipher.getOutputSize(length);\n       output = new byte[outSize];\n-      inOff = headerBytes.length;\n-      outOff = 0;\n     }\n     outOff += cipher.processBytes(input, inOff, length, output, outOff);\n     outOff += cipher.doFinal(output, outOff);",
  "diff_line_info": {
    "deleted_lines": [
      "    final byte[] headerBytes = header.encode();",
      "      length = input.length - headerBytes.length;",
      "      inOff = headerBytes.length;",
      "      outOff = 0;"
    ],
    "added_lines": [
      "      final byte[] headerBytes = header.encode();",
      "      outOff = 0;",
      "      inOff = header.getLength();",
      "      length = input.length - inOff;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/vt-middleware/cryptacular/pull/53",
  "description": {
    "pr_info": {
      "title": "Define new ciphertext header format.",
      "number": 53
    },
    "comment": [
      "New format does not allocate any memory until HMAC check passes, which\r\nguards against untrusted input. All encryption components have been\r\nupdated to use the new header, while preserving backward compatibility\r\nto decrypt messages encrypted with the old format. The decoding process\r\nfor the old header has been hardened to impose reasonable limits on header\r\nfields: nonce sizes up to 255 bytes, key names up to 500 bytes.\r\n\r\nFixes #52."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}