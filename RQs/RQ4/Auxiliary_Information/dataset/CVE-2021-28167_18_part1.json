{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveOpenJDKInvokeHandle",
  "func_before": "j9object_t\nresolveOpenJDKInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n\tj9object_t result = *invokeCache;\n\n\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\tif ((NULL == result) && canRunJavaCode) {\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t\t/* Resolve the class. */\n\t\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (resolvedClass != NULL) {\n\t\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n\t\t\tresult = (j9object_t)vmThread->returnValue;\n\n\t\t\tif (vmThread->currentException != NULL) {\n\t\t\t\t/* Already a pending exception */\n\t\t\t\tresult = NULL;\n\t\t\t} else if (result == NULL) {\n\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t\t} else {\n\t\t\t\t/* Only write the value in if it is not null */\n\t\t\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n\n\t\t\t\t/* Ensure that result array elements are written before the array reference is stored */\n\t\t\t\tVM_AtomicSupport::writeBarrier();\n\t\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, ramClass, invokeCache, NULL, result)) {\n\t\t\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n\t\t\t\t\tresult = *invokeCache;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tTrc_VM_resolveInvokeHandle_Exit(vmThread, result);\n\treturn result;\n#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tTrc_VM_Assert_ShouldNeverHappen();\n\treturn NULL;\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n}",
  "abstract_func_before": "j9object_t\nresolveOpenJDKInvokeHandle(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n#if defined(VAR_4)\n\tbool VAR_5 = J9_ARE_NO_BITS_SET(VAR_3, VAR_6 | VAR_7);\n\tJ9RAMMethodRef *VAR_8 = (J9RAMMethodRef*)VAR_1 + VAR_2;\n\tUDATA VAR_9 = VAR_8->methodIndexAndArgCount >> 8;\n\tJ9Class *VAR_10 = J9_CLASS_FROM_CP(VAR_1);\n\tj9object_t *VAR_11 = VAR_10->invokeCache + VAR_9;\n\tj9object_t VAR_12 = *VAR_11;\n\n\tTrc_VM_resolveInvokeHandle_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\tif ((NULL == VAR_12) && VAR_5) {\n\t\tJ9ROMMethodRef *VAR_13 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\t\tJ9ROMNameAndSignature *VAR_14 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_13);\n\n\t\t/* COMMENT_0 */\n\t\tJ9Class *VAR_15 = resolveClassRef(VAR_0, VAR_1, VAR_13->classRefCPIndex, VAR_3);\n\t\tif (VAR_15 != NULL) {\n\t\t\tsendResolveOpenJDKInvokeHandle(VAR_0, VAR_1, VAR_2, VAR_16, VAR_15, VAR_14);\n\t\t\tVAR_12 = (j9object_t)VAR_0->returnValue;\n\n\t\t\tif (VAR_0->currentException != NULL) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tVAR_12 = NULL;\n\t\t\t} else if (VAR_12 == NULL) {\n\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_17, NULL);\n\t\t\t} else {\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tJ9MemoryManagerFunctions *VAR_18 = VAR_0->javaVM->memoryManagerFunctions;\n\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tVM_AtomicSupport::writeBarrier();\n\t\t\t\tif (0 == VAR_18->j9gc_objaccess_staticCompareAndSwapObject(VAR_0, VAR_10, VAR_11, NULL, VAR_12)) {\n\t\t\t\t\t/* COMMENT_4 */\n\t\t\t\t\tVAR_12 = *VAR_11;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tTrc_VM_resolveInvokeHandle_Exit(VAR_0, VAR_12);\n\treturn VAR_12;\n#else /* COMMENT_5 */\n\tTrc_VM_Assert_ShouldNeverHappen();\n\treturn NULL;\n#endif /* COMMENT_5 */\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/10.json",
  "func": "j9object_t\nresolveOpenJDKInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n\tj9object_t result = *invokeCache;\n\n\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\tAssert_VM_true(J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE));\n\n\tif ((NULL == result) && canRunJavaCode) {\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t\t/* Resolve the class. */\n\t\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (resolvedClass != NULL) {\n\t\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n\t\t\tresult = (j9object_t)vmThread->returnValue;\n\n\t\t\tif (vmThread->currentException != NULL) {\n\t\t\t\t/* Already a pending exception */\n\t\t\t\tresult = NULL;\n\t\t\t} else if (result == NULL) {\n\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t\t} else {\n\t\t\t\t/* Only write the value in if it is not null */\n\t\t\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n\n\t\t\t\t/* Ensure that result array elements are written before the array reference is stored */\n\t\t\t\tVM_AtomicSupport::writeBarrier();\n\t\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, ramClass, invokeCache, NULL, result)) {\n\t\t\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n\t\t\t\t\tresult = *invokeCache;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tTrc_VM_resolveInvokeHandle_Exit(vmThread, result);\n\treturn result;\n#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tTrc_VM_Assert_ShouldNeverHappen();\n\treturn NULL;\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n}",
  "abstract_func": "j9object_t\nresolveOpenJDKInvokeHandle(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n#if defined(VAR_4)\n\tbool VAR_5 = J9_ARE_NO_BITS_SET(VAR_3, VAR_6 | VAR_7);\n\tJ9RAMMethodRef *VAR_8 = (J9RAMMethodRef*)VAR_1 + VAR_2;\n\tUDATA VAR_9 = VAR_8->methodIndexAndArgCount >> 8;\n\tJ9Class *VAR_10 = J9_CLASS_FROM_CP(VAR_1);\n\tj9object_t *VAR_11 = VAR_10->invokeCache + VAR_9;\n\tj9object_t VAR_12 = *VAR_11;\n\n\tTrc_VM_resolveInvokeHandle_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\tAssert_VM_true(J9_ARE_NO_BITS_SET(VAR_3, VAR_13));\n\n\tif ((NULL == VAR_12) && VAR_5) {\n\t\tJ9ROMMethodRef *VAR_14 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\t\tJ9ROMNameAndSignature *VAR_15 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_14);\n\n\t\t/* COMMENT_0 */\n\t\tJ9Class *VAR_16 = resolveClassRef(VAR_0, VAR_1, VAR_14->classRefCPIndex, VAR_3);\n\t\tif (VAR_16 != NULL) {\n\t\t\tsendResolveOpenJDKInvokeHandle(VAR_0, VAR_1, VAR_2, VAR_17, VAR_16, VAR_15);\n\t\t\tVAR_12 = (j9object_t)VAR_0->returnValue;\n\n\t\t\tif (VAR_0->currentException != NULL) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tVAR_12 = NULL;\n\t\t\t} else if (VAR_12 == NULL) {\n\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_18, NULL);\n\t\t\t} else {\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tJ9MemoryManagerFunctions *VAR_19 = VAR_0->javaVM->memoryManagerFunctions;\n\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tVM_AtomicSupport::writeBarrier();\n\t\t\t\tif (0 == VAR_19->j9gc_objaccess_staticCompareAndSwapObject(VAR_0, VAR_10, VAR_11, NULL, VAR_12)) {\n\t\t\t\t\t/* COMMENT_4 */\n\t\t\t\t\tVAR_12 = *VAR_11;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tTrc_VM_resolveInvokeHandle_Exit(VAR_0, VAR_12);\n\treturn VAR_12;\n#else /* COMMENT_5 */\n\tTrc_VM_Assert_ShouldNeverHappen();\n\treturn NULL;\n#endif /* COMMENT_5 */\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/10.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,8 @@\n \tj9object_t result = *invokeCache;\n \n \tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n+\n+\tAssert_VM_true(J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE));\n \n \tif ((NULL == result) && canRunJavaCode) {\n \t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\tAssert_VM_true(J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/eclipse-openj9/openj9/pull/12148: 403 Client Error: Forbidden for url: https://api.github.com/repos/eclipse-openj9/openj9/pulls/12148",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9\n\nThe patch addresses a class loading issue without security implications, focusing on core functionality. The code changes correct class resolution and constant pool handling, aligning with a non-security bug fix."
}