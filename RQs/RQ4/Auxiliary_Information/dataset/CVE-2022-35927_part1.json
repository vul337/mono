{
  "cve_id": "CVE-2022-35927",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "Validate the length in the DIO prefix info option.",
  "commit_hash": "4fffab0e632c4d01910fa957d1fd9ef321eb87d2",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/4fffab0e632c4d01910fa957d1fd9ef321eb87d2",
  "file_path": "os/net/routing/rpl-classic/rpl-icmp6.c",
  "func_name": "dio_input",
  "func_before": "static void\ndio_input(void)\n{\n  unsigned char *buffer;\n  uint8_t buffer_length;\n  rpl_dio_t dio;\n  uint8_t subopt_type;\n  int i;\n  int len;\n  uip_ipaddr_t from;\n\n  memset(&dio, 0, sizeof(dio));\n\n  /* Set default values in case the DIO configuration option is missing. */\n  dio.dag_intdoubl = RPL_DIO_INTERVAL_DOUBLINGS;\n  dio.dag_intmin = RPL_DIO_INTERVAL_MIN;\n  dio.dag_redund = RPL_DIO_REDUNDANCY;\n  dio.dag_min_hoprankinc = RPL_MIN_HOPRANKINC;\n  dio.dag_max_rankinc = RPL_MAX_RANKINC;\n  dio.ocp = RPL_OF_OCP;\n  dio.default_lifetime = RPL_DEFAULT_LIFETIME;\n  dio.lifetime_unit = RPL_DEFAULT_LIFETIME_UNIT;\n\n  uip_ipaddr_copy(&from, &UIP_IP_BUF->srcipaddr);\n\n  /* DAG Information Object */\n  LOG_INFO(\"Received a DIO from \");\n  LOG_INFO_6ADDR(&from);\n  LOG_INFO_(\"\\n\");\n\n  buffer_length = uip_len - uip_l3_icmp_hdr_len;\n\n  /* Process the DIO base option. */\n  i = 0;\n  buffer = UIP_ICMP_PAYLOAD;\n\n  dio.instance_id = buffer[i++];\n  dio.version = buffer[i++];\n  dio.rank = get16(buffer, i);\n  i += 2;\n\n  LOG_DBG(\"Incoming DIO (id, ver, rank) = (%u,%u,%u)\\n\",\n         (unsigned)dio.instance_id,\n         (unsigned)dio.version,\n         (unsigned)dio.rank);\n\n  dio.grounded = buffer[i] & RPL_DIO_GROUNDED;\n  dio.mop = (buffer[i]& RPL_DIO_MOP_MASK) >> RPL_DIO_MOP_SHIFT;\n  dio.preference = buffer[i++] & RPL_DIO_PREFERENCE_MASK;\n\n  dio.dtsn = buffer[i++];\n  /* two reserved bytes */\n  i += 2;\n\n  memcpy(&dio.dag_id, buffer + i, sizeof(dio.dag_id));\n  i += sizeof(dio.dag_id);\n\n  LOG_DBG(\"Incoming DIO (dag_id, pref) = (\");\n  LOG_DBG_6ADDR(&dio.dag_id);\n  LOG_DBG_(\", %u)\\n\", dio.preference);\n\n  /* Check if there are any DIO suboptions. */\n  for(; i < buffer_length; i += len) {\n    subopt_type = buffer[i];\n    if(subopt_type == RPL_OPTION_PAD1) {\n      len = 1;\n    } else {\n      /* Suboption with a two-byte header + payload */\n      len = 2 + buffer[i + 1];\n    }\n\n    if(len + i > buffer_length) {\n      LOG_WARN(\"Invalid DIO packet\\n\");\n      RPL_STAT(rpl_stats.malformed_msgs++);\n      goto discard;\n    }\n\n    LOG_DBG(\"Incoming DIO (option, length) = (%u, %u)\\n\", subopt_type, len - 2);\n\n    switch(subopt_type) {\n      case RPL_OPTION_DAG_METRIC_CONTAINER:\n        if(len < 6) {\n          LOG_WARN(\"Invalid DAG MC, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n        dio.mc.type = buffer[i + 2];\n        dio.mc.flags = buffer[i + 3] << 1;\n        dio.mc.flags |= buffer[i + 4] >> 7;\n        dio.mc.aggr = (buffer[i + 4] >> 4) & 0x3;\n        dio.mc.prec = buffer[i + 4] & 0xf;\n        dio.mc.length = buffer[i + 5];\n\n        if(dio.mc.type == RPL_DAG_MC_NONE) {\n          /* No metric container: do nothing */\n        } else if(dio.mc.type == RPL_DAG_MC_ETX) {\n          dio.mc.obj.etx = get16(buffer, i + 6);\n\n          LOG_DBG(\"DAG MC: type %u, flags %u, aggr %u, prec %u, length %u, ETX %u\\n\",\n                 (unsigned)dio.mc.type,\n                 (unsigned)dio.mc.flags,\n                 (unsigned)dio.mc.aggr,\n                 (unsigned)dio.mc.prec,\n                 (unsigned)dio.mc.length,\n                 (unsigned)dio.mc.obj.etx);\n        } else if(dio.mc.type == RPL_DAG_MC_ENERGY) {\n          dio.mc.obj.energy.flags = buffer[i + 6];\n          dio.mc.obj.energy.energy_est = buffer[i + 7];\n        } else {\n          LOG_WARN(\"Unhandled DAG MC type: %u\\n\", (unsigned)dio.mc.type);\n          goto discard;\n        }\n        break;\n      case RPL_OPTION_ROUTE_INFO:\n        if(len < 9) {\n          LOG_WARN(\"Invalid destination prefix option, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n\n        /* The flags field includes the preference value. */\n        dio.destination_prefix.length = buffer[i + 2];\n        dio.destination_prefix.flags = buffer[i + 3];\n        dio.destination_prefix.lifetime = get32(buffer, i + 4);\n\n        if(((dio.destination_prefix.length + 7) / 8) + 8 <= len &&\n           dio.destination_prefix.length <= 128) {\n          LOG_INFO(\"Copying destination prefix\\n\");\n          memcpy(&dio.destination_prefix.prefix, &buffer[i + 8],\n                 (dio.destination_prefix.length + 7) / 8);\n        } else {\n          LOG_WARN(\"Invalid route info option, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n\n        break;\n      case RPL_OPTION_DAG_CONF:\n        if(len != 16) {\n          LOG_WARN(\"Invalid DAG configuration option, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n\n        /* Path control field not yet implemented - at i + 2 */\n        dio.dag_intdoubl = buffer[i + 3];\n        dio.dag_intmin = buffer[i + 4];\n        dio.dag_redund = buffer[i + 5];\n        dio.dag_max_rankinc = get16(buffer, i + 6);\n        dio.dag_min_hoprankinc = get16(buffer, i + 8);\n        dio.ocp = get16(buffer, i + 10);\n        /* buffer + 12 is reserved */\n        dio.default_lifetime = buffer[i + 13];\n        dio.lifetime_unit = get16(buffer, i + 14);\n        LOG_INFO(\"DAG conf:dbl=%d, min=%d red=%d maxinc=%d mininc=%d ocp=%d d_l=%u l_u=%u\\n\",\n               dio.dag_intdoubl, dio.dag_intmin, dio.dag_redund,\n               dio.dag_max_rankinc, dio.dag_min_hoprankinc, dio.ocp,\n               dio.default_lifetime, dio.lifetime_unit);\n        break;\n      case RPL_OPTION_PREFIX_INFO:\n        if(len != 32) {\n          LOG_WARN(\"Invalid DAG prefix info, len != 32\\n\");\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n        dio.prefix_info.length = buffer[i + 2];\n        dio.prefix_info.flags = buffer[i + 3];\n        /* valid lifetime is ingnored for now - at i + 4 */\n        /* preferred lifetime stored in lifetime */\n        dio.prefix_info.lifetime = get32(buffer, i + 8);\n        /* 32-bit reserved at i + 12 */\n        LOG_INFO(\"Copying prefix information\\n\");\n        memcpy(&dio.prefix_info.prefix, &buffer[i + 16], 16);\n        break;\n      default:\n        LOG_WARN(\"Unsupported suboption type in DIO: %u\\n\",\n               (unsigned)subopt_type);\n    }\n  }\n\n#ifdef RPL_DEBUG_DIO_INPUT\n  RPL_DEBUG_DIO_INPUT(&from, &dio);\n#endif\n\n  rpl_process_dio(&from, &dio);\n\ndiscard:\n  uipbuf_clear();\n}",
  "abstract_func_before": "static void\ndio_input(void)\n{\n  unsigned char *VAR_0;\n  uint8_t VAR_1;\n  rpl_dio_t VAR_2;\n  uint8_t VAR_3;\n  int VAR_4;\n  int VAR_5;\n  uip_ipaddr_t VAR_6;\n\n  memset(&VAR_2, 0, sizeof(VAR_2));\n\n  /* COMMENT_0 */\n  VAR_2.dag_intdoubl = VAR_7;\n  VAR_2.dag_intmin = VAR_8;\n  VAR_2.dag_redund = VAR_9;\n  VAR_2.dag_min_hoprankinc = VAR_10;\n  VAR_2.dag_max_rankinc = VAR_11;\n  VAR_2.ocp = VAR_12;\n  VAR_2.default_lifetime = VAR_13;\n  VAR_2.lifetime_unit = VAR_14;\n\n  uip_ipaddr_copy(&VAR_6, &VAR_15->srcipaddr);\n\n  /* COMMENT_1 */\n  LOG_INFO(\"Received a DIO from \");\n  LOG_INFO_6ADDR(&VAR_6);\n  LOG_INFO_(\"\\n\");\n\n  VAR_1 = VAR_16 - VAR_17;\n\n  /* COMMENT_2 */\n  VAR_4 = 0;\n  VAR_0 = VAR_18;\n\n  VAR_2.instance_id = VAR_0[VAR_4++];\n  VAR_2.version = VAR_0[VAR_4++];\n  VAR_2.rank = get16(VAR_0, VAR_4);\n  VAR_4 += 2;\n\n  LOG_DBG(\"Incoming DIO (id, ver, rank) = (%u,%u,%u)\\n\",\n         (unsigned)VAR_2.instance_id,\n         (unsigned)VAR_2.version,\n         (unsigned)VAR_2.rank);\n\n  VAR_2.grounded = VAR_0[VAR_4] & VAR_19;\n  VAR_2.mop = (VAR_0[VAR_4]& VAR_20) >> VAR_21;\n  VAR_2.preference = VAR_0[VAR_4++] & VAR_22;\n\n  VAR_2.dtsn = VAR_0[VAR_4++];\n  /* COMMENT_3 */\n  VAR_4 += 2;\n\n  memcpy(&VAR_2.dag_id, VAR_0 + VAR_4, sizeof(VAR_2.dag_id));\n  VAR_4 += sizeof(VAR_2.dag_id);\n\n  LOG_DBG(\"Incoming DIO (dag_id, pref) = (\");\n  LOG_DBG_6ADDR(&VAR_2.dag_id);\n  LOG_DBG_(\", %u)\\n\", VAR_2.preference);\n\n  /* COMMENT_4 */\n  for(; VAR_4 < VAR_1; VAR_4 += VAR_5) {\n    VAR_3 = VAR_0[VAR_4];\n    if(VAR_3 == VAR_23) {\n      VAR_5 = 1;\n    } else {\n      /* COMMENT_5 */\n      VAR_5 = 2 + VAR_0[VAR_4 + 1];\n    }\n\n    if(VAR_5 + VAR_4 > VAR_1) {\n      LOG_WARN(\"Invalid DIO packet\\n\");\n      RPL_STAT(VAR_24.malformed_msgs++);\n      goto discard;\n    }\n\n    LOG_DBG(\"Incoming DIO (option, length) = (%u, %u)\\n\", VAR_3, VAR_5 - 2);\n\n    switch(VAR_3) {\n      case VAR_25:\n        if(VAR_5 < 6) {\n          LOG_WARN(\"Invalid DAG MC, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n        VAR_2.mc.type = VAR_0[VAR_4 + 2];\n        VAR_2.mc.flags = VAR_0[VAR_4 + 3] << 1;\n        VAR_2.mc.flags |= VAR_0[VAR_4 + 4] >> 7;\n        VAR_2.mc.aggr = (VAR_0[VAR_4 + 4] >> 4) & 0x3;\n        VAR_2.mc.prec = VAR_0[VAR_4 + 4] & 0xf;\n        VAR_2.mc.length = VAR_0[VAR_4 + 5];\n\n        if(VAR_2.mc.type == VAR_26) {\n          /* COMMENT_6 */\n        } else if(VAR_2.mc.type == VAR_27) {\n          VAR_2.mc.obj.etx = get16(VAR_0, VAR_4 + 6);\n\n          LOG_DBG(\"DAG MC: type %u, flags %u, aggr %u, prec %u, length %u, ETX %u\\n\",\n                 (unsigned)VAR_2.mc.type,\n                 (unsigned)VAR_2.mc.flags,\n                 (unsigned)VAR_2.mc.aggr,\n                 (unsigned)VAR_2.mc.prec,\n                 (unsigned)VAR_2.mc.length,\n                 (unsigned)VAR_2.mc.obj.etx);\n        } else if(VAR_2.mc.type == VAR_28) {\n          VAR_2.mc.obj.energy.flags = VAR_0[VAR_4 + 6];\n          VAR_2.mc.obj.energy.energy_est = VAR_0[VAR_4 + 7];\n        } else {\n          LOG_WARN(\"Unhandled DAG MC type: %u\\n\", (unsigned)VAR_2.mc.type);\n          goto discard;\n        }\n        break;\n      case VAR_29:\n        if(VAR_5 < 9) {\n          LOG_WARN(\"Invalid destination prefix option, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n\n        /* COMMENT_7 */\n        VAR_2.destination_prefix.length = VAR_0[VAR_4 + 2];\n        VAR_2.destination_prefix.flags = VAR_0[VAR_4 + 3];\n        VAR_2.destination_prefix.lifetime = get32(VAR_0, VAR_4 + 4);\n\n        if(((VAR_2.destination_prefix.length + 7) / 8) + 8 <= VAR_5 &&\n           VAR_2.destination_prefix.length <= 128) {\n          LOG_INFO(\"Copying destination prefix\\n\");\n          memcpy(&VAR_2.destination_prefix.prefix, &VAR_0[VAR_4 + 8],\n                 (VAR_2.destination_prefix.length + 7) / 8);\n        } else {\n          LOG_WARN(\"Invalid route info option, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n\n        break;\n      case VAR_30:\n        if(VAR_5 != 16) {\n          LOG_WARN(\"Invalid DAG configuration option, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n\n        /* COMMENT_8 */\n        VAR_2.dag_intdoubl = VAR_0[VAR_4 + 3];\n        VAR_2.dag_intmin = VAR_0[VAR_4 + 4];\n        VAR_2.dag_redund = VAR_0[VAR_4 + 5];\n        VAR_2.dag_max_rankinc = get16(VAR_0, VAR_4 + 6);\n        VAR_2.dag_min_hoprankinc = get16(VAR_0, VAR_4 + 8);\n        VAR_2.ocp = get16(VAR_0, VAR_4 + 10);\n        /* COMMENT_9 */\n        VAR_2.default_lifetime = VAR_0[VAR_4 + 13];\n        VAR_2.lifetime_unit = get16(VAR_0, VAR_4 + 14);\n        LOG_INFO(\"DAG conf:dbl=%d, min=%d red=%d maxinc=%d mininc=%d ocp=%d d_l=%u l_u=%u\\n\",\n               VAR_2.dag_intdoubl, VAR_2.dag_intmin, VAR_2.dag_redund,\n               VAR_2.dag_max_rankinc, VAR_2.dag_min_hoprankinc, VAR_2.ocp,\n               VAR_2.default_lifetime, VAR_2.lifetime_unit);\n        break;\n      case VAR_31:\n        if(VAR_5 != 32) {\n          LOG_WARN(\"Invalid DAG prefix info, len != 32\\n\");\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n        VAR_2.prefix_info.length = VAR_0[VAR_4 + 2];\n        VAR_2.prefix_info.flags = VAR_0[VAR_4 + 3];\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        VAR_2.prefix_info.lifetime = get32(VAR_0, VAR_4 + 8);\n        /* COMMENT_12 */\n        LOG_INFO(\"Copying prefix information\\n\");\n        memcpy(&VAR_2.prefix_info.prefix, &VAR_0[VAR_4 + 16], 16);\n        break;\n      default:\n        LOG_WARN(\"Unsupported suboption type in DIO: %u\\n\",\n               (unsigned)VAR_3);\n    }\n  }\n\n#ifdef VAR_32\n  VAR_32(&VAR_6, &VAR_2);\n#endif\n\n  rpl_process_dio(&VAR_6, &VAR_2);\n\ndiscard:\n  uipbuf_clear();\n}",
  "func_graph_path_before": "contiki-ng/4fffab0e632c4d01910fa957d1fd9ef321eb87d2/rpl-icmp6.c/vul/before/0.json",
  "func": "static void\ndio_input(void)\n{\n  unsigned char *buffer;\n  uint8_t buffer_length;\n  rpl_dio_t dio;\n  uint8_t subopt_type;\n  int i;\n  int len;\n  uip_ipaddr_t from;\n\n  memset(&dio, 0, sizeof(dio));\n\n  /* Set default values in case the DIO configuration option is missing. */\n  dio.dag_intdoubl = RPL_DIO_INTERVAL_DOUBLINGS;\n  dio.dag_intmin = RPL_DIO_INTERVAL_MIN;\n  dio.dag_redund = RPL_DIO_REDUNDANCY;\n  dio.dag_min_hoprankinc = RPL_MIN_HOPRANKINC;\n  dio.dag_max_rankinc = RPL_MAX_RANKINC;\n  dio.ocp = RPL_OF_OCP;\n  dio.default_lifetime = RPL_DEFAULT_LIFETIME;\n  dio.lifetime_unit = RPL_DEFAULT_LIFETIME_UNIT;\n\n  uip_ipaddr_copy(&from, &UIP_IP_BUF->srcipaddr);\n\n  /* DAG Information Object */\n  LOG_INFO(\"Received a DIO from \");\n  LOG_INFO_6ADDR(&from);\n  LOG_INFO_(\"\\n\");\n\n  buffer_length = uip_len - uip_l3_icmp_hdr_len;\n\n  /* Process the DIO base option. */\n  i = 0;\n  buffer = UIP_ICMP_PAYLOAD;\n\n  dio.instance_id = buffer[i++];\n  dio.version = buffer[i++];\n  dio.rank = get16(buffer, i);\n  i += 2;\n\n  LOG_DBG(\"Incoming DIO (id, ver, rank) = (%u,%u,%u)\\n\",\n         (unsigned)dio.instance_id,\n         (unsigned)dio.version,\n         (unsigned)dio.rank);\n\n  dio.grounded = buffer[i] & RPL_DIO_GROUNDED;\n  dio.mop = (buffer[i]& RPL_DIO_MOP_MASK) >> RPL_DIO_MOP_SHIFT;\n  dio.preference = buffer[i++] & RPL_DIO_PREFERENCE_MASK;\n\n  dio.dtsn = buffer[i++];\n  /* two reserved bytes */\n  i += 2;\n\n  memcpy(&dio.dag_id, buffer + i, sizeof(dio.dag_id));\n  i += sizeof(dio.dag_id);\n\n  LOG_DBG(\"Incoming DIO (dag_id, pref) = (\");\n  LOG_DBG_6ADDR(&dio.dag_id);\n  LOG_DBG_(\", %u)\\n\", dio.preference);\n\n  /* Check if there are any DIO suboptions. */\n  for(; i < buffer_length; i += len) {\n    subopt_type = buffer[i];\n    if(subopt_type == RPL_OPTION_PAD1) {\n      len = 1;\n    } else {\n      /* Suboption with a two-byte header + payload */\n      len = 2 + buffer[i + 1];\n    }\n\n    if(len + i > buffer_length) {\n      LOG_WARN(\"Invalid DIO packet\\n\");\n      RPL_STAT(rpl_stats.malformed_msgs++);\n      goto discard;\n    }\n\n    LOG_DBG(\"Incoming DIO (option, length) = (%u, %u)\\n\", subopt_type, len - 2);\n\n    switch(subopt_type) {\n      case RPL_OPTION_DAG_METRIC_CONTAINER:\n        if(len < 6) {\n          LOG_WARN(\"Invalid DAG MC, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n        dio.mc.type = buffer[i + 2];\n        dio.mc.flags = buffer[i + 3] << 1;\n        dio.mc.flags |= buffer[i + 4] >> 7;\n        dio.mc.aggr = (buffer[i + 4] >> 4) & 0x3;\n        dio.mc.prec = buffer[i + 4] & 0xf;\n        dio.mc.length = buffer[i + 5];\n\n        if(dio.mc.type == RPL_DAG_MC_NONE) {\n          /* No metric container: do nothing */\n        } else if(dio.mc.type == RPL_DAG_MC_ETX) {\n          dio.mc.obj.etx = get16(buffer, i + 6);\n\n          LOG_DBG(\"DAG MC: type %u, flags %u, aggr %u, prec %u, length %u, ETX %u\\n\",\n                 (unsigned)dio.mc.type,\n                 (unsigned)dio.mc.flags,\n                 (unsigned)dio.mc.aggr,\n                 (unsigned)dio.mc.prec,\n                 (unsigned)dio.mc.length,\n                 (unsigned)dio.mc.obj.etx);\n        } else if(dio.mc.type == RPL_DAG_MC_ENERGY) {\n          dio.mc.obj.energy.flags = buffer[i + 6];\n          dio.mc.obj.energy.energy_est = buffer[i + 7];\n        } else {\n          LOG_WARN(\"Unhandled DAG MC type: %u\\n\", (unsigned)dio.mc.type);\n          goto discard;\n        }\n        break;\n      case RPL_OPTION_ROUTE_INFO:\n        if(len < 9) {\n          LOG_WARN(\"Invalid destination prefix option, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n\n        /* The flags field includes the preference value. */\n        dio.destination_prefix.length = buffer[i + 2];\n        dio.destination_prefix.flags = buffer[i + 3];\n        dio.destination_prefix.lifetime = get32(buffer, i + 4);\n\n        if(((dio.destination_prefix.length + 7) / 8) + 8 <= len &&\n           dio.destination_prefix.length <= 128) {\n          LOG_INFO(\"Copying destination prefix\\n\");\n          memcpy(&dio.destination_prefix.prefix, &buffer[i + 8],\n                 (dio.destination_prefix.length + 7) / 8);\n        } else {\n          LOG_WARN(\"Invalid route info option, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n\n        break;\n      case RPL_OPTION_DAG_CONF:\n        if(len != 16) {\n          LOG_WARN(\"Invalid DAG configuration option, len = %d\\n\", len);\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n\n        /* Path control field not yet implemented - at i + 2 */\n        dio.dag_intdoubl = buffer[i + 3];\n        dio.dag_intmin = buffer[i + 4];\n        dio.dag_redund = buffer[i + 5];\n        dio.dag_max_rankinc = get16(buffer, i + 6);\n        dio.dag_min_hoprankinc = get16(buffer, i + 8);\n        dio.ocp = get16(buffer, i + 10);\n        /* buffer + 12 is reserved */\n        dio.default_lifetime = buffer[i + 13];\n        dio.lifetime_unit = get16(buffer, i + 14);\n        LOG_INFO(\"DAG conf:dbl=%d, min=%d red=%d maxinc=%d mininc=%d ocp=%d d_l=%u l_u=%u\\n\",\n               dio.dag_intdoubl, dio.dag_intmin, dio.dag_redund,\n               dio.dag_max_rankinc, dio.dag_min_hoprankinc, dio.ocp,\n               dio.default_lifetime, dio.lifetime_unit);\n        break;\n      case RPL_OPTION_PREFIX_INFO:\n        if(len != 32) {\n          LOG_WARN(\"Invalid DAG prefix info, len != 32\\n\");\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n        dio.prefix_info.length = buffer[i + 2];\n\n        if(dio.prefix_info.length > sizeof(uip_ipaddr_t) * 8) {\n          LOG_WARN(\"Invalid DAG prefix info, len %u > %u\\n\",\n                   dio.prefix_info.length, (unsigned)(sizeof(uip_ipaddr_t) * 8));\n          RPL_STAT(rpl_stats.malformed_msgs++);\n          goto discard;\n        }\n\n        dio.prefix_info.flags = buffer[i + 3];\n        /* valid lifetime is ingnored for now - at i + 4 */\n        /* preferred lifetime stored in lifetime */\n        dio.prefix_info.lifetime = get32(buffer, i + 8);\n        /* 32-bit reserved at i + 12 */\n        LOG_INFO(\"Copying prefix information\\n\");\n        memcpy(&dio.prefix_info.prefix, &buffer[i + 16], 16);\n        break;\n      default:\n        LOG_WARN(\"Unsupported suboption type in DIO: %u\\n\",\n               (unsigned)subopt_type);\n    }\n  }\n\n#ifdef RPL_DEBUG_DIO_INPUT\n  RPL_DEBUG_DIO_INPUT(&from, &dio);\n#endif\n\n  rpl_process_dio(&from, &dio);\n\ndiscard:\n  uipbuf_clear();\n}",
  "abstract_func": "static void\ndio_input(void)\n{\n  unsigned char *VAR_0;\n  uint8_t VAR_1;\n  rpl_dio_t VAR_2;\n  uint8_t VAR_3;\n  int VAR_4;\n  int VAR_5;\n  uip_ipaddr_t VAR_6;\n\n  memset(&VAR_2, 0, sizeof(VAR_2));\n\n  /* COMMENT_0 */\n  VAR_2.dag_intdoubl = VAR_7;\n  VAR_2.dag_intmin = VAR_8;\n  VAR_2.dag_redund = VAR_9;\n  VAR_2.dag_min_hoprankinc = VAR_10;\n  VAR_2.dag_max_rankinc = VAR_11;\n  VAR_2.ocp = VAR_12;\n  VAR_2.default_lifetime = VAR_13;\n  VAR_2.lifetime_unit = VAR_14;\n\n  uip_ipaddr_copy(&VAR_6, &VAR_15->srcipaddr);\n\n  /* COMMENT_1 */\n  LOG_INFO(\"Received a DIO from \");\n  LOG_INFO_6ADDR(&VAR_6);\n  LOG_INFO_(\"\\n\");\n\n  VAR_1 = VAR_16 - VAR_17;\n\n  /* COMMENT_2 */\n  VAR_4 = 0;\n  VAR_0 = VAR_18;\n\n  VAR_2.instance_id = VAR_0[VAR_4++];\n  VAR_2.version = VAR_0[VAR_4++];\n  VAR_2.rank = get16(VAR_0, VAR_4);\n  VAR_4 += 2;\n\n  LOG_DBG(\"Incoming DIO (id, ver, rank) = (%u,%u,%u)\\n\",\n         (unsigned)VAR_2.instance_id,\n         (unsigned)VAR_2.version,\n         (unsigned)VAR_2.rank);\n\n  VAR_2.grounded = VAR_0[VAR_4] & VAR_19;\n  VAR_2.mop = (VAR_0[VAR_4]& VAR_20) >> VAR_21;\n  VAR_2.preference = VAR_0[VAR_4++] & VAR_22;\n\n  VAR_2.dtsn = VAR_0[VAR_4++];\n  /* COMMENT_3 */\n  VAR_4 += 2;\n\n  memcpy(&VAR_2.dag_id, VAR_0 + VAR_4, sizeof(VAR_2.dag_id));\n  VAR_4 += sizeof(VAR_2.dag_id);\n\n  LOG_DBG(\"Incoming DIO (dag_id, pref) = (\");\n  LOG_DBG_6ADDR(&VAR_2.dag_id);\n  LOG_DBG_(\", %u)\\n\", VAR_2.preference);\n\n  /* COMMENT_4 */\n  for(; VAR_4 < VAR_1; VAR_4 += VAR_5) {\n    VAR_3 = VAR_0[VAR_4];\n    if(VAR_3 == VAR_23) {\n      VAR_5 = 1;\n    } else {\n      /* COMMENT_5 */\n      VAR_5 = 2 + VAR_0[VAR_4 + 1];\n    }\n\n    if(VAR_5 + VAR_4 > VAR_1) {\n      LOG_WARN(\"Invalid DIO packet\\n\");\n      RPL_STAT(VAR_24.malformed_msgs++);\n      goto discard;\n    }\n\n    LOG_DBG(\"Incoming DIO (option, length) = (%u, %u)\\n\", VAR_3, VAR_5 - 2);\n\n    switch(VAR_3) {\n      case VAR_25:\n        if(VAR_5 < 6) {\n          LOG_WARN(\"Invalid DAG MC, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n        VAR_2.mc.type = VAR_0[VAR_4 + 2];\n        VAR_2.mc.flags = VAR_0[VAR_4 + 3] << 1;\n        VAR_2.mc.flags |= VAR_0[VAR_4 + 4] >> 7;\n        VAR_2.mc.aggr = (VAR_0[VAR_4 + 4] >> 4) & 0x3;\n        VAR_2.mc.prec = VAR_0[VAR_4 + 4] & 0xf;\n        VAR_2.mc.length = VAR_0[VAR_4 + 5];\n\n        if(VAR_2.mc.type == VAR_26) {\n          /* COMMENT_6 */\n        } else if(VAR_2.mc.type == VAR_27) {\n          VAR_2.mc.obj.etx = get16(VAR_0, VAR_4 + 6);\n\n          LOG_DBG(\"DAG MC: type %u, flags %u, aggr %u, prec %u, length %u, ETX %u\\n\",\n                 (unsigned)VAR_2.mc.type,\n                 (unsigned)VAR_2.mc.flags,\n                 (unsigned)VAR_2.mc.aggr,\n                 (unsigned)VAR_2.mc.prec,\n                 (unsigned)VAR_2.mc.length,\n                 (unsigned)VAR_2.mc.obj.etx);\n        } else if(VAR_2.mc.type == VAR_28) {\n          VAR_2.mc.obj.energy.flags = VAR_0[VAR_4 + 6];\n          VAR_2.mc.obj.energy.energy_est = VAR_0[VAR_4 + 7];\n        } else {\n          LOG_WARN(\"Unhandled DAG MC type: %u\\n\", (unsigned)VAR_2.mc.type);\n          goto discard;\n        }\n        break;\n      case VAR_29:\n        if(VAR_5 < 9) {\n          LOG_WARN(\"Invalid destination prefix option, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n\n        /* COMMENT_7 */\n        VAR_2.destination_prefix.length = VAR_0[VAR_4 + 2];\n        VAR_2.destination_prefix.flags = VAR_0[VAR_4 + 3];\n        VAR_2.destination_prefix.lifetime = get32(VAR_0, VAR_4 + 4);\n\n        if(((VAR_2.destination_prefix.length + 7) / 8) + 8 <= VAR_5 &&\n           VAR_2.destination_prefix.length <= 128) {\n          LOG_INFO(\"Copying destination prefix\\n\");\n          memcpy(&VAR_2.destination_prefix.prefix, &VAR_0[VAR_4 + 8],\n                 (VAR_2.destination_prefix.length + 7) / 8);\n        } else {\n          LOG_WARN(\"Invalid route info option, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n\n        break;\n      case VAR_30:\n        if(VAR_5 != 16) {\n          LOG_WARN(\"Invalid DAG configuration option, len = %d\\n\", VAR_5);\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n\n        /* COMMENT_8 */\n        VAR_2.dag_intdoubl = VAR_0[VAR_4 + 3];\n        VAR_2.dag_intmin = VAR_0[VAR_4 + 4];\n        VAR_2.dag_redund = VAR_0[VAR_4 + 5];\n        VAR_2.dag_max_rankinc = get16(VAR_0, VAR_4 + 6);\n        VAR_2.dag_min_hoprankinc = get16(VAR_0, VAR_4 + 8);\n        VAR_2.ocp = get16(VAR_0, VAR_4 + 10);\n        /* COMMENT_9 */\n        VAR_2.default_lifetime = VAR_0[VAR_4 + 13];\n        VAR_2.lifetime_unit = get16(VAR_0, VAR_4 + 14);\n        LOG_INFO(\"DAG conf:dbl=%d, min=%d red=%d maxinc=%d mininc=%d ocp=%d d_l=%u l_u=%u\\n\",\n               VAR_2.dag_intdoubl, VAR_2.dag_intmin, VAR_2.dag_redund,\n               VAR_2.dag_max_rankinc, VAR_2.dag_min_hoprankinc, VAR_2.ocp,\n               VAR_2.default_lifetime, VAR_2.lifetime_unit);\n        break;\n      case VAR_31:\n        if(VAR_5 != 32) {\n          LOG_WARN(\"Invalid DAG prefix info, len != 32\\n\");\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n        VAR_2.prefix_info.length = VAR_0[VAR_4 + 2];\n\n        if(VAR_2.prefix_info.length > sizeof(uip_ipaddr_t) * 8) {\n          LOG_WARN(\"Invalid DAG prefix info, len %u > %u\\n\",\n                   VAR_2.prefix_info.length, (unsigned)(sizeof(uip_ipaddr_t) * 8));\n          RPL_STAT(VAR_24.malformed_msgs++);\n          goto discard;\n        }\n\n        VAR_2.prefix_info.flags = VAR_0[VAR_4 + 3];\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        VAR_2.prefix_info.lifetime = get32(VAR_0, VAR_4 + 8);\n        /* COMMENT_12 */\n        LOG_INFO(\"Copying prefix information\\n\");\n        memcpy(&VAR_2.prefix_info.prefix, &VAR_0[VAR_4 + 16], 16);\n        break;\n      default:\n        LOG_WARN(\"Unsupported suboption type in DIO: %u\\n\",\n               (unsigned)VAR_3);\n    }\n  }\n\n#ifdef VAR_32\n  VAR_32(&VAR_6, &VAR_2);\n#endif\n\n  rpl_process_dio(&VAR_6, &VAR_2);\n\ndiscard:\n  uipbuf_clear();\n}",
  "func_graph_path": "contiki-ng/4fffab0e632c4d01910fa957d1fd9ef321eb87d2/rpl-icmp6.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -164,6 +164,14 @@\n           goto discard;\n         }\n         dio.prefix_info.length = buffer[i + 2];\n+\n+        if(dio.prefix_info.length > sizeof(uip_ipaddr_t) * 8) {\n+          LOG_WARN(\"Invalid DAG prefix info, len %u > %u\\n\",\n+                   dio.prefix_info.length, (unsigned)(sizeof(uip_ipaddr_t) * 8));\n+          RPL_STAT(rpl_stats.malformed_msgs++);\n+          goto discard;\n+        }\n+\n         dio.prefix_info.flags = buffer[i + 3];\n         /* valid lifetime is ingnored for now - at i + 4 */\n         /* preferred lifetime stored in lifetime */",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "        if(dio.prefix_info.length > sizeof(uip_ipaddr_t) * 8) {",
      "          LOG_WARN(\"Invalid DAG prefix info, len %u > %u\\n\",",
      "                   dio.prefix_info.length, (unsigned)(sizeof(uip_ipaddr_t) * 8));",
      "          RPL_STAT(rpl_stats.malformed_msgs++);",
      "          goto discard;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1589",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/contiki-ng/contiki-ng/pull/1589: 403 Client Error: Forbidden for url: https://api.github.com/repos/contiki-ng/contiki-ng/pulls/1589",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0\n\nThe patch addresses a buffer overflow issue, a known security vulnerability, by adding a validation check for input length. The commit message and code changes align perfectly, making this a clear security fix."
}