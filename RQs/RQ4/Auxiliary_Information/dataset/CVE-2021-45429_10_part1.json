{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/scan.c",
  "func_name": "_yr_scan_verify_chained_string_match",
  "func_before": "static int _yr_scan_verify_chained_string_match(\n    YR_STRING* matching_string,\n    YR_SCAN_CONTEXT* context,\n    const uint8_t* match_data,\n    uint64_t match_base,\n    uint64_t match_offset,\n    int32_t match_length)\n{\n  YR_DEBUG_FPRINTF(\n      2,\n      stderr,\n      \"- %s (match_data=%p match_base=%\" PRIx64 \" match_offset=0x%\" PRIx64\n      \" match_length=%'d) {} \\n\",\n      __FUNCTION__,\n      match_data,\n      match_base,\n      match_offset,\n      match_length);\n\n  YR_STRING* string;\n  YR_MATCH* match;\n  YR_MATCH* next_match;\n  YR_MATCH* new_match;\n\n  uint64_t lowest_offset;\n  uint64_t ending_offset;\n  int32_t full_chain_length;\n\n  bool add_match = false;\n\n  if (matching_string->chained_to == NULL)\n  {\n    // The matching string is the head of the chain, this match should be\n    // added to the list of unconfirmed matches. The match will remain\n    // unconfirmed until all the strings in the chain are found with the\n    // correct distances between them.\n    add_match = true;\n  }\n  else\n  {\n    // If some unconfirmed match exists, the lowest possible offset where the\n    // whole string chain can match is the offset of the first string in the\n    // list of unconfirmed matches. Unconfirmed matches are sorted in ascending\n    // offset order. If no unconfirmed match exists, the lowest possible offset\n    // is the offset of the current match.\n    match = context->unconfirmed_matches[matching_string->idx].head;\n\n    if (match != NULL)\n      lowest_offset = match->offset;\n    else\n      lowest_offset = match_offset;\n\n    // Iterate over the list of unconfirmed matches for the string that\n    // precedes the currently matching string. If we have a string chain like:\n    // S1 <- S2 <- S3, and we just found a match for S2, we are iterating the\n    // list of unconfirmed matches of S1.\n    match = context->unconfirmed_matches[matching_string->chained_to->idx].head;\n\n    while (match != NULL)\n    {\n      // Store match->next so that we can use it later for advancing in the\n      // list, if _yr_scan_remove_match_from_list is called, match->next is\n      // set to NULL, that's why we store its current value before that happens.\n      next_match = match->next;\n\n      // The unconfirmed match starts at match->offset and finishes at\n      // ending_offset.\n      ending_offset = match->offset + match->match_length;\n\n      if (ending_offset + matching_string->chain_gap_max < lowest_offset)\n      {\n        // If the current match is too far away from the unconfirmed match,\n        // remove the unconfirmed match from the list because it has been\n        // negatively confirmed (i.e: we can be sure that this unconfirmed\n        // match can't be an actual match)\n        _yr_scan_remove_match_from_list(\n            match,\n            &context->unconfirmed_matches[matching_string->chained_to->idx]);\n      }\n      else if (\n          ending_offset + matching_string->chain_gap_max >= match_offset &&\n          ending_offset + matching_string->chain_gap_min <= match_offset)\n      {\n        // If the distance between the end of the unconfirmed match and the\n        // start of the current match is within the range specified in the\n        // regexp or hex string, this could be an actual match.\n        add_match = true;\n        break;\n      }\n\n      match = next_match;\n    }\n  }\n\n  if (add_match)\n  {\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))\n\n    if (STRING_IS_CHAIN_TAIL(matching_string))\n    {\n      // The matching string is the tail of the string chain. It must be\n      // chained to some other string.\n      assert(matching_string->chained_to != NULL);\n\n      // Iterate over the list of unconfirmed matches of the preceding string\n      // in the chain and update the chain_length field for each of them. This\n      // is a recursive operation that will update the chain_length field for\n      // every unconfirmed match in all the strings in the chain up to the head\n      // of the chain.\n      match =\n          context->unconfirmed_matches[matching_string->chained_to->idx].head;\n\n      while (match != NULL)\n      {\n        ending_offset = match->offset + match->match_length;\n\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          _yr_scan_update_match_chain_length(\n              context, matching_string->chained_to, match, 1);\n        }\n\n        match = match->next;\n      }\n\n      full_chain_length = 0;\n      string = matching_string;\n\n      while (string->chained_to != NULL)\n      {\n        full_chain_length++;\n        string = string->chained_to;\n      }\n\n      // \"string\" points now to the head of the strings chain.\n      match = context->unconfirmed_matches[string->idx].head;\n\n      // Iterate over the list of unconfirmed matches of the head of the chain,\n      // and move to the list of confirmed matches those with a chain_length\n      // equal to full_chain_length, which means that the whole chain has been\n      // confirmed to match.\n      while (match != NULL)\n      {\n        next_match = match->next;\n\n        if (match->chain_length == full_chain_length)\n        {\n          _yr_scan_remove_match_from_list(\n              match, &context->unconfirmed_matches[string->idx]);\n\n          match->match_length = (int32_t)(\n              match_offset - match->offset + match_length);\n\n          match->data_length = yr_min(\n              match->match_length, (int32_t) max_match_data);\n\n          match->data = yr_notebook_alloc(\n              context->matches_notebook, match->data_length);\n\n          if (match->data == NULL)\n            return ERROR_INSUFFICIENT_MEMORY;\n\n          memcpy(\n              (void*) match->data,\n              match_data - match_offset + match->offset,\n              match->data_length);\n\n          FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n              match, &context->matches[string->idx], false));\n        }\n\n        match = next_match;\n      }\n    }\n    else  // It's a part of a chain, but not the tail.\n    {\n      new_match = yr_notebook_alloc(\n          context->matches_notebook, sizeof(YR_MATCH));\n\n      if (new_match == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      new_match->base = match_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->chain_length = 0;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n      new_match->is_private = STRING_IS_PRIVATE(matching_string);\n\n      // A copy of the matching data is written to the matches_arena, the\n      // amount of data copies is limited by YR_CONFIG_MAX_MATCH_DATA.\n      new_match->data_length = yr_min(match_length, (int32_t) max_match_data);\n\n      if (new_match->data_length > 0)\n      {\n        new_match->data = yr_notebook_alloc(\n            context->matches_notebook, new_match->data_length);\n\n        if (new_match->data == NULL)\n          return ERROR_INSUFFICIENT_MEMORY;\n\n        memcpy((void*) new_match->data, match_data, new_match->data_length);\n      }\n      else\n      {\n        new_match->data = NULL;\n      }\n\n      // Add the match to the list of unconfirmed matches because the string\n      // is part of a chain but not its tail, so we can't be sure the this is\n      // an actual match until finding the remaining parts of the chain.\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &context->unconfirmed_matches[matching_string->idx],\n          false));\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
  "abstract_func_before": "static int _yr_scan_verify_chained_string_match(\n    YR_STRING* VAR_0,\n    YR_SCAN_CONTEXT* VAR_1,\n    const uint8_t* VAR_2,\n    uint64_t VAR_3,\n    uint64_t VAR_4,\n    int32_t VAR_5)\n{\n  YR_DEBUG_FPRINTF(\n      2,\n      VAR_6,\n      \"- %s (match_data=%p match_base=%\" VAR_7 \" match_offset=0x%\" VAR_7\n      \" match_length=%'d) {} \\n\",\n      VAR_8,\n      VAR_2,\n      VAR_3,\n      VAR_4,\n      VAR_5);\n\n  YR_STRING* VAR_9;\n  YR_MATCH* VAR_10;\n  YR_MATCH* VAR_11;\n  YR_MATCH* VAR_12;\n\n  uint64_t VAR_13;\n  uint64_t VAR_14;\n  int32_t VAR_15;\n\n  bool VAR_16 = false;\n\n  if (VAR_0->chained_to == NULL)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    VAR_16 = true;\n  }\n  else\n  {\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    VAR_10 = VAR_1->unconfirmed_matches[VAR_0->idx].head;\n\n    if (VAR_10 != NULL)\n      VAR_13 = VAR_10->offset;\n    else\n      VAR_13 = VAR_4;\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    VAR_10 = VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;\n\n    while (VAR_10 != NULL)\n    {\n      /* COMMENT_13 */\n      /* COMMENT_14 */\n      /* COMMENT_15 */\n      VAR_11 = VAR_10->next;\n\n      /* COMMENT_16 */\n      /* COMMENT_17 */\n      VAR_14 = VAR_10->offset + VAR_10->match_length;\n\n      if (VAR_14 + VAR_0->chain_gap_max < VAR_13)\n      {\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        _yr_scan_remove_match_from_list(\n            VAR_10,\n            &VAR_1->unconfirmed_matches[VAR_0->chained_to->idx]);\n      }\n      else if (\n          VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&\n          VAR_14 + VAR_0->chain_gap_min <= VAR_4)\n      {\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        VAR_16 = true;\n        break;\n      }\n\n      VAR_10 = VAR_11;\n    }\n  }\n\n  if (VAR_16)\n  {\n    uint32_t VAR_17;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration(VAR_18, &VAR_17))\n\n    if (STRING_IS_CHAIN_TAIL(VAR_0))\n    {\n      /* COMMENT_25 */\n      /* COMMENT_26 */\n      assert(VAR_0->chained_to != NULL);\n\n      /* COMMENT_27 */\n      /* COMMENT_28 */\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      VAR_10 =\n          VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;\n\n      while (VAR_10 != NULL)\n      {\n        VAR_14 = VAR_10->offset + VAR_10->match_length;\n\n        if (VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&\n            VAR_14 + VAR_0->chain_gap_min <= VAR_4)\n        {\n          _yr_scan_update_match_chain_length(\n              VAR_1, VAR_0->chained_to, VAR_10, 1);\n        }\n\n        VAR_10 = VAR_10->next;\n      }\n\n      VAR_15 = 0;\n      VAR_9 = VAR_0;\n\n      while (VAR_9->chained_to != NULL)\n      {\n        VAR_15++;\n        VAR_9 = VAR_9->chained_to;\n      }\n\n      /* COMMENT_32 */\n      VAR_10 = VAR_1->unconfirmed_matches[VAR_9->idx].head;\n\n      /* COMMENT_33 */\n      /* COMMENT_34 */\n      /* COMMENT_35 */\n      /* COMMENT_36 */\n      while (VAR_10 != NULL)\n      {\n        VAR_11 = VAR_10->next;\n\n        if (VAR_10->chain_length == VAR_15)\n        {\n          _yr_scan_remove_match_from_list(\n              VAR_10, &VAR_1->unconfirmed_matches[VAR_9->idx]);\n\n          VAR_10->match_length = (int32_t)(\n              VAR_4 - VAR_10->offset + VAR_5);\n\n          VAR_10->data_length = yr_min(\n              VAR_10->match_length, (int32_t) VAR_17);\n\n          VAR_10->data = yr_notebook_alloc(\n              VAR_1->matches_notebook, VAR_10->data_length);\n\n          if (VAR_10->data == NULL)\n            return VAR_19;\n\n          memcpy(\n              (void*) VAR_10->data,\n              VAR_2 - VAR_4 + VAR_10->offset,\n              VAR_10->data_length);\n\n          FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n              VAR_10, &VAR_1->matches[VAR_9->idx], false));\n        }\n\n        VAR_10 = VAR_11;\n      }\n    }\n    else  /* COMMENT_37 */\n    {\n      VAR_12 = yr_notebook_alloc(\n          VAR_1->matches_notebook, sizeof(YR_MATCH));\n\n      if (VAR_12 == NULL)\n        return VAR_19;\n\n      VAR_12->base = VAR_3;\n      VAR_12->offset = VAR_4;\n      VAR_12->match_length = VAR_5;\n      VAR_12->chain_length = 0;\n      VAR_12->prev = NULL;\n      VAR_12->next = NULL;\n      VAR_12->is_private = STRING_IS_PRIVATE(VAR_0);\n\n      /* COMMENT_38 */\n      /* COMMENT_39 */\n      VAR_12->data_length = yr_min(VAR_5, (int32_t) VAR_17);\n\n      if (VAR_12->data_length > 0)\n      {\n        VAR_12->data = yr_notebook_alloc(\n            VAR_1->matches_notebook, VAR_12->data_length);\n\n        if (VAR_12->data == NULL)\n          return VAR_19;\n\n        memcpy((void*) VAR_12->data, VAR_2, VAR_12->data_length);\n      }\n      else\n      {\n        VAR_12->data = NULL;\n      }\n\n      /* COMMENT_40 */\n      /* COMMENT_41 */\n      /* COMMENT_42 */\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          VAR_12,\n          &VAR_1->unconfirmed_matches[VAR_0->idx],\n          false));\n    }\n  }\n\n  return VAR_20;\n}",
  "func_graph_path_before": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/before/1.json",
  "func": "static int _yr_scan_verify_chained_string_match(\n    YR_STRING* matching_string,\n    YR_SCAN_CONTEXT* context,\n    const uint8_t* match_data,\n    uint64_t match_base,\n    uint64_t match_offset,\n    int32_t match_length)\n{\n  YR_DEBUG_FPRINTF(\n      2,\n      stderr,\n      \"- %s (match_data=%p match_base=%\" PRIx64 \" match_offset=0x%\" PRIx64\n      \" match_length=%'d) {} \\n\",\n      __FUNCTION__,\n      match_data,\n      match_base,\n      match_offset,\n      match_length);\n\n  YR_STRING* string;\n  YR_MATCH* match;\n  YR_MATCH* next_match;\n  YR_MATCH* new_match;\n\n  uint64_t lowest_offset;\n  uint64_t ending_offset;\n  int32_t full_chain_length;\n\n  bool add_match = false;\n\n  if (matching_string->chained_to == NULL)\n  {\n    // The matching string is the head of the chain, this match should be\n    // added to the list of unconfirmed matches. The match will remain\n    // unconfirmed until all the strings in the chain are found with the\n    // correct distances between them.\n    add_match = true;\n  }\n  else\n  {\n    // If some unconfirmed match exists, the lowest possible offset where the\n    // whole string chain can match is the offset of the first string in the\n    // list of unconfirmed matches. Unconfirmed matches are sorted in ascending\n    // offset order. If no unconfirmed match exists, the lowest possible offset\n    // is the offset of the current match.\n    match = context->unconfirmed_matches[matching_string->idx].head;\n\n    if (match != NULL)\n      lowest_offset = match->offset;\n    else\n      lowest_offset = match_offset;\n\n    // Iterate over the list of unconfirmed matches for the string that\n    // precedes the currently matching string. If we have a string chain like:\n    // S1 <- S2 <- S3, and we just found a match for S2, we are iterating the\n    // list of unconfirmed matches of S1.\n    match = context->unconfirmed_matches[matching_string->chained_to->idx].head;\n\n    while (match != NULL)\n    {\n      // Store match->next so that we can use it later for advancing in the\n      // list, if _yr_scan_remove_match_from_list is called, match->next is\n      // set to NULL, that's why we store its current value before that happens.\n      next_match = match->next;\n\n      // The unconfirmed match starts at match->offset and finishes at\n      // ending_offset.\n      ending_offset = match->offset + match->match_length;\n\n      if (ending_offset + matching_string->chain_gap_max < lowest_offset)\n      {\n        // If the current match is too far away from the unconfirmed match,\n        // remove the unconfirmed match from the list because it has been\n        // negatively confirmed (i.e: we can be sure that this unconfirmed\n        // match can't be an actual match)\n        _yr_scan_remove_match_from_list(\n            match,\n            &context->unconfirmed_matches[matching_string->chained_to->idx]);\n      }\n      else if (\n          ending_offset + matching_string->chain_gap_max >= match_offset &&\n          ending_offset + matching_string->chain_gap_min <= match_offset)\n      {\n        // If the distance between the end of the unconfirmed match and the\n        // start of the current match is within the range specified in the\n        // regexp or hex string, this could be an actual match.\n        add_match = true;\n        break;\n      }\n\n      match = next_match;\n    }\n  }\n\n  if (add_match)\n  {\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))\n\n    if (STRING_IS_CHAIN_TAIL(matching_string))\n    {\n      // The matching string is the tail of the string chain. It must be\n      // chained to some other string.\n      assert(matching_string->chained_to != NULL);\n\n      // Iterate over the list of unconfirmed matches of the preceding string\n      // in the chain and update the chain_length field for each of them. This\n      // is a recursive operation that will update the chain_length field for\n      // every unconfirmed match in all the strings in the chain up to the head\n      // of the chain.\n      match =\n          context->unconfirmed_matches[matching_string->chained_to->idx].head;\n\n      while (match != NULL)\n      {\n        ending_offset = match->offset + match->match_length;\n\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          _yr_scan_update_match_chain_length(\n              context, matching_string->chained_to, match, 1);\n        }\n\n        match = match->next;\n      }\n\n      full_chain_length = 0;\n      string = matching_string;\n\n      while (string->chained_to != NULL)\n      {\n        full_chain_length++;\n        string = string->chained_to;\n      }\n\n      // \"string\" points now to the head of the strings chain.\n      match = context->unconfirmed_matches[string->idx].head;\n\n      // Iterate over the list of unconfirmed matches of the head of the chain,\n      // and move to the list of confirmed matches those with a chain_length\n      // equal to full_chain_length, which means that the whole chain has been\n      // confirmed to match.\n      while (match != NULL)\n      {\n        next_match = match->next;\n\n        if (match->chain_length == full_chain_length)\n        {\n          _yr_scan_remove_match_from_list(\n              match, &context->unconfirmed_matches[string->idx]);\n\n          match->match_length =\n              (int32_t) (match_offset - match->offset + match_length);\n\n          match->data_length = yr_min(\n              match->match_length, (int32_t) max_match_data);\n\n          match->data = yr_notebook_alloc(\n              context->matches_notebook, match->data_length);\n\n          if (match->data == NULL)\n            return ERROR_INSUFFICIENT_MEMORY;\n\n          memcpy(\n              (void*) match->data,\n              match_data - match_offset + match->offset,\n              match->data_length);\n\n          FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n              match, &context->matches[string->idx], false));\n        }\n\n        match = next_match;\n      }\n    }\n    else  // It's a part of a chain, but not the tail.\n    {\n      new_match = yr_notebook_alloc(\n          context->matches_notebook, sizeof(YR_MATCH));\n\n      if (new_match == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      new_match->base = match_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->chain_length = 0;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n      new_match->is_private = STRING_IS_PRIVATE(matching_string);\n\n      // A copy of the matching data is written to the matches_arena, the\n      // amount of data copies is limited by YR_CONFIG_MAX_MATCH_DATA.\n      new_match->data_length = yr_min(match_length, (int32_t) max_match_data);\n\n      if (new_match->data_length > 0)\n      {\n        new_match->data = yr_notebook_alloc(\n            context->matches_notebook, new_match->data_length);\n\n        if (new_match->data == NULL)\n          return ERROR_INSUFFICIENT_MEMORY;\n\n        memcpy((void*) new_match->data, match_data, new_match->data_length);\n      }\n      else\n      {\n        new_match->data = NULL;\n      }\n\n      // Add the match to the list of unconfirmed matches because the string\n      // is part of a chain but not its tail, so we can't be sure the this is\n      // an actual match until finding the remaining parts of the chain.\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &context->unconfirmed_matches[matching_string->idx],\n          false));\n    }\n  }\n\n  return ERROR_SUCCESS;\n}",
  "abstract_func": "static int _yr_scan_verify_chained_string_match(\n    YR_STRING* VAR_0,\n    YR_SCAN_CONTEXT* VAR_1,\n    const uint8_t* VAR_2,\n    uint64_t VAR_3,\n    uint64_t VAR_4,\n    int32_t VAR_5)\n{\n  YR_DEBUG_FPRINTF(\n      2,\n      VAR_6,\n      \"- %s (match_data=%p match_base=%\" VAR_7 \" match_offset=0x%\" VAR_7\n      \" match_length=%'d) {} \\n\",\n      VAR_8,\n      VAR_2,\n      VAR_3,\n      VAR_4,\n      VAR_5);\n\n  YR_STRING* VAR_9;\n  YR_MATCH* VAR_10;\n  YR_MATCH* VAR_11;\n  YR_MATCH* VAR_12;\n\n  uint64_t VAR_13;\n  uint64_t VAR_14;\n  int32_t VAR_15;\n\n  bool VAR_16 = false;\n\n  if (VAR_0->chained_to == NULL)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    VAR_16 = true;\n  }\n  else\n  {\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    VAR_10 = VAR_1->unconfirmed_matches[VAR_0->idx].head;\n\n    if (VAR_10 != NULL)\n      VAR_13 = VAR_10->offset;\n    else\n      VAR_13 = VAR_4;\n\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    VAR_10 = VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;\n\n    while (VAR_10 != NULL)\n    {\n      /* COMMENT_13 */\n      /* COMMENT_14 */\n      /* COMMENT_15 */\n      VAR_11 = VAR_10->next;\n\n      /* COMMENT_16 */\n      /* COMMENT_17 */\n      VAR_14 = VAR_10->offset + VAR_10->match_length;\n\n      if (VAR_14 + VAR_0->chain_gap_max < VAR_13)\n      {\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        _yr_scan_remove_match_from_list(\n            VAR_10,\n            &VAR_1->unconfirmed_matches[VAR_0->chained_to->idx]);\n      }\n      else if (\n          VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&\n          VAR_14 + VAR_0->chain_gap_min <= VAR_4)\n      {\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        VAR_16 = true;\n        break;\n      }\n\n      VAR_10 = VAR_11;\n    }\n  }\n\n  if (VAR_16)\n  {\n    uint32_t VAR_17;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration_uint32(VAR_18, &VAR_17))\n\n    if (STRING_IS_CHAIN_TAIL(VAR_0))\n    {\n      /* COMMENT_25 */\n      /* COMMENT_26 */\n      assert(VAR_0->chained_to != NULL);\n\n      /* COMMENT_27 */\n      /* COMMENT_28 */\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      VAR_10 =\n          VAR_1->unconfirmed_matches[VAR_0->chained_to->idx].head;\n\n      while (VAR_10 != NULL)\n      {\n        VAR_14 = VAR_10->offset + VAR_10->match_length;\n\n        if (VAR_14 + VAR_0->chain_gap_max >= VAR_4 &&\n            VAR_14 + VAR_0->chain_gap_min <= VAR_4)\n        {\n          _yr_scan_update_match_chain_length(\n              VAR_1, VAR_0->chained_to, VAR_10, 1);\n        }\n\n        VAR_10 = VAR_10->next;\n      }\n\n      VAR_15 = 0;\n      VAR_9 = VAR_0;\n\n      while (VAR_9->chained_to != NULL)\n      {\n        VAR_15++;\n        VAR_9 = VAR_9->chained_to;\n      }\n\n      /* COMMENT_32 */\n      VAR_10 = VAR_1->unconfirmed_matches[VAR_9->idx].head;\n\n      /* COMMENT_33 */\n      /* COMMENT_34 */\n      /* COMMENT_35 */\n      /* COMMENT_36 */\n      while (VAR_10 != NULL)\n      {\n        VAR_11 = VAR_10->next;\n\n        if (VAR_10->chain_length == VAR_15)\n        {\n          _yr_scan_remove_match_from_list(\n              VAR_10, &VAR_1->unconfirmed_matches[VAR_9->idx]);\n\n          VAR_10->match_length =\n              (int32_t) (VAR_4 - VAR_10->offset + VAR_5);\n\n          VAR_10->data_length = yr_min(\n              VAR_10->match_length, (int32_t) VAR_17);\n\n          VAR_10->data = yr_notebook_alloc(\n              VAR_1->matches_notebook, VAR_10->data_length);\n\n          if (VAR_10->data == NULL)\n            return VAR_19;\n\n          memcpy(\n              (void*) VAR_10->data,\n              VAR_2 - VAR_4 + VAR_10->offset,\n              VAR_10->data_length);\n\n          FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n              VAR_10, &VAR_1->matches[VAR_9->idx], false));\n        }\n\n        VAR_10 = VAR_11;\n      }\n    }\n    else  /* COMMENT_37 */\n    {\n      VAR_12 = yr_notebook_alloc(\n          VAR_1->matches_notebook, sizeof(YR_MATCH));\n\n      if (VAR_12 == NULL)\n        return VAR_19;\n\n      VAR_12->base = VAR_3;\n      VAR_12->offset = VAR_4;\n      VAR_12->match_length = VAR_5;\n      VAR_12->chain_length = 0;\n      VAR_12->prev = NULL;\n      VAR_12->next = NULL;\n      VAR_12->is_private = STRING_IS_PRIVATE(VAR_0);\n\n      /* COMMENT_38 */\n      /* COMMENT_39 */\n      VAR_12->data_length = yr_min(VAR_5, (int32_t) VAR_17);\n\n      if (VAR_12->data_length > 0)\n      {\n        VAR_12->data = yr_notebook_alloc(\n            VAR_1->matches_notebook, VAR_12->data_length);\n\n        if (VAR_12->data == NULL)\n          return VAR_19;\n\n        memcpy((void*) VAR_12->data, VAR_2, VAR_12->data_length);\n      }\n      else\n      {\n        VAR_12->data = NULL;\n      }\n\n      /* COMMENT_40 */\n      /* COMMENT_41 */\n      /* COMMENT_42 */\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          VAR_12,\n          &VAR_1->unconfirmed_matches[VAR_0->idx],\n          false));\n    }\n  }\n\n  return VAR_20;\n}",
  "func_graph_path": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -97,7 +97,7 @@\n     uint32_t max_match_data;\n \n     FAIL_ON_ERROR(\n-        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))\n+        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))\n \n     if (STRING_IS_CHAIN_TAIL(matching_string))\n     {\n@@ -152,8 +152,8 @@\n           _yr_scan_remove_match_from_list(\n               match, &context->unconfirmed_matches[string->idx]);\n \n-          match->match_length = (int32_t)(\n-              match_offset - match->offset + match_length);\n+          match->match_length =\n+              (int32_t) (match_offset - match->offset + match_length);\n \n           match->data_length = yr_min(\n               match->match_length, (int32_t) max_match_data);",
  "diff_line_info": {
    "deleted_lines": [
      "        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))",
      "          match->match_length = (int32_t)(",
      "              match_offset - match->offset + match_length);"
    ],
    "added_lines": [
      "        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data))",
      "          match->match_length =",
      "              (int32_t) (match_offset - match->offset + match_length);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": {
    "pr_info": {
      "title": "Fix issue #1616",
      "number": 1621
    },
    "comment": [
      "This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9\n\n**Step-by-Step Explanation:**\n1. **Input Analysis:** The commit introduces new API functions for uint32/uint64 settings and modifies configuration access, without mentioning security.\n2. **Consistency Check:** The code changes align with the commit message, focusing on API enhancements.\n3. **Purpose Evaluation:** The changes enhance API capabilities and refactor code for clarity, indicating non-security improvements.\n4. **Security Assessment:** No mention of security issues or vulnerability fixes.\n5. **Non-Security Classification:** The changes are for API feature expansion, fitting into Defect Remediation & Feature Upgrades.\n6. **Confidence Scoring:** 0.9 due to clear, consistent information without security context."
}