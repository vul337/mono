{
  "cve_id": "CVE-2023-23759",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebookincubator/fizz",
  "commit_msg": "Check HelloRetryRequest cipher consistency earlier.\n\nCVE-2023-23759\r\n\r\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>\r\n\r\nDifferential Revision: D42508182",
  "commit_hash": "8d3649841597bedfb6986c30431ebad0eb215265",
  "git_url": "https://github.com/facebookincubator/fizz/commit/8d3649841597bedfb6986c30431ebad0eb215265",
  "file_path": "fizz/server/ServerProtocol.cpp",
  "func_name": "EventHandler<ServerTypes, StateEnum::ExpectingClientHello, Event::ClientHello>::\n    handle",
  "func_before": "AsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingClientHello, Event::ClientHello>::\n    handle(const State& state, Param param) {\n  ClientHello chlo = std::move(*param.asClientHello());\n\n  auto cookieState = getCookieState(chlo, state.context()->getCookieCipher());\n\n  if (state.handshakeContext() && cookieState.has_value()) {\n    throw FizzException(\n        \"cookie after statefull hrr\", AlertDescription::illegal_parameter);\n  }\n\n  ECHStatus echStatus;\n  ECHState echState;\n  std::tie(echStatus, echState) = processECH(cookieState, state, chlo);\n\n  addHandshakeLogging(state, chlo);\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after client hello\", AlertDescription::unexpected_message);\n  }\n\n  auto version =\n      negotiateVersion(chlo, state.context()->getSupportedVersions());\n\n  if (state.version().has_value() &&\n      (!version || *version != *state.version())) {\n    throw FizzException(\n        \"version mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  if (!version) {\n    if (getExtension<ClientEarlyData>(chlo.extensions)) {\n      throw FizzException(\n          \"supported version mismatch with early data\",\n          AlertDescription::protocol_version);\n    }\n    if (state.context()->getVersionFallbackEnabled()) {\n      AttemptVersionFallback fallback;\n      // Re-encode to put the record layer header back on. This won't\n      // necessarily preserve it byte-for-byte, but it isn't authenticated so\n      // should be ok.\n      fallback.clientHello =\n          PlaintextWriteRecordLayer()\n              .writeInitialClientHello(std::move(*chlo.originalEncoding))\n              .data;\n      return actions(\n          MutateState(&Transition<StateEnum::Error>), std::move(fallback));\n    } else {\n      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n      state.context()->getReplayCache());\n\n  auto results =\n      collectAll(resStateResult.futureResState, replayCacheResultFuture);\n\n  using FutureResultType = std::tuple<\n      folly::Try<std::pair<PskType, Optional<ResumptionState>>>,\n      folly::Try<ReplayCacheResult>>;\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(results),\n      [&state,\n       chlo = std::move(chlo),\n       cookieState = std::move(cookieState),\n       version = *version,\n       cipher,\n       pskMode = resStateResult.pskMode,\n       echStatus,\n       echState = std::move(echState),\n       obfuscatedAge =\n           resStateResult.obfuscatedAge](FutureResultType result) mutable {\n        auto& resumption = *std::get<0>(result);\n        auto pskType = resumption.first;\n        auto resState = std::move(resumption.second);\n        auto replayCacheResult = *std::get<1>(result);\n\n        if (resState) {\n          if (!validateResumptionState(*resState, *pskMode, version, cipher)) {\n            pskType = PskType::Rejected;\n            pskMode = folly::none;\n            resState = folly::none;\n          }\n        } else {\n          pskMode = folly::none;\n        }\n\n        auto legacySessionId = chlo.legacy_session_id->clone();\n\n        // If we successfully resumed, set the handshake time to the ticket's\n        // handshake time to preserve it across ticket updates. If not, set it\n        // to now.\n        std::chrono::system_clock::time_point handshakeTime;\n        if (resState) {\n          handshakeTime = resState->handshakeTime;\n        } else {\n          handshakeTime = state.context()->getClock().getCurrentTime();\n        }\n\n        std::unique_ptr<KeyScheduler> scheduler;\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        if (state.cipher().has_value() && cipher != *state.cipher()) {\n          throw FizzException(\n              \"cipher mismatch with previous negotiation\",\n              AlertDescription::illegal_parameter);\n        }\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n\n        auto earlyDataType = negotiateEarlyDataType(\n            state.context()->getAcceptEarlyData(version),\n            chlo,\n            resState,\n            cipher,\n            state.keyExchangeType(),\n            cookieState,\n            alpn,\n            replayCacheResult,\n            clockSkew,\n            state.context()->getClockSkewTolerance(),\n            state.appTokenValidator());\n\n        std::unique_ptr<EncryptedReadRecordLayer> earlyReadRecordLayer;\n        Buf earlyExporterMaster;\n        folly::Optional<SecretAvailable> earlyReadSecretAvailable;\n        if (earlyDataType == EarlyDataType::Accepted) {\n          auto earlyContext = handshakeContext->getHandshakeContext();\n          auto earlyReadSecret = scheduler->getSecret(\n              EarlySecrets::ClientEarlyTraffic, earlyContext->coalesce());\n          if (!state.context()->getOmitEarlyRecordLayer()) {\n            earlyReadRecordLayer =\n                state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                    EncryptionLevel::EarlyData);\n            earlyReadRecordLayer->setProtocolVersion(version);\n\n            Protocol::setAead(\n                *earlyReadRecordLayer,\n                cipher,\n                folly::range(earlyReadSecret.secret),\n                *state.context()->getFactory(),\n                *scheduler);\n          }\n\n          earlyReadSecretAvailable =\n              SecretAvailable(std::move(earlyReadSecret));\n          earlyExporterMaster = folly::IOBuf::copyBuffer(\n              scheduler\n                  ->getSecret(\n                      EarlySecrets::EarlyExporter, earlyContext->coalesce())\n                  .secret);\n        }\n\n        Optional<NamedGroup> group;\n        KeyExchangeType keyExchangeType;\n        SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> kexResultFuture =\n            folly::none;\n        std::unique_ptr<KeyExchange> kex = nullptr;\n\n        if (!pskMode || *pskMode != PskKeyExchangeMode::psk_ke) {\n          Optional<Buf> clientShare;\n          std::tie(group, clientShare) = negotiateGroup(\n              version, chlo, state.context()->getSupportedGroups());\n          if (!clientShare) {\n            VLOG(8) << \"Did not find key share for \" << toString(*group);\n            if (state.group().has_value() || cookieState) {\n              throw FizzException(\n                  \"key share not found for already negotiated group\",\n                  AlertDescription::illegal_parameter);\n            }\n\n            // If we were otherwise going to accept early data we now need to\n            // reject it. It's a little ugly to change our previous early data\n            // decision, but doing it this way allows us to move the key\n            // schedule forward as we do the key exchange.\n            if (earlyDataType == EarlyDataType::Accepted) {\n              earlyDataType = EarlyDataType::Rejected;\n            }\n\n            message_hash chloHash;\n            chloHash.hash = handshakeContext->getHandshakeContext();\n            handshakeContext =\n                state.context()->getFactory()->makeHandshakeContext(cipher);\n            handshakeContext->appendToTranscript(\n                encodeHandshake(std::move(chloHash)));\n\n            auto hrr = getHelloRetryRequest(\n                version,\n                cipher,\n                *group,\n                legacySessionId ? legacySessionId->clone() : nullptr,\n                *handshakeContext);\n\n            if (echStatus == ECHStatus::Accepted) {\n              // Set up acceptance scheduler\n              auto echScheduler =\n                  state.context()->getFactory()->makeKeyScheduler(cipher);\n              echScheduler->deriveEarlySecret(folly::range(chlo.random));\n              // Add acceptance extension\n              ech::setAcceptConfirmation(\n                  hrr, handshakeContext->clone(), std::move(echScheduler));\n            }\n\n            auto encodedHelloRetryRequest = encodeHandshake(std::move(hrr));\n            handshakeContext->appendToTranscript(encodedHelloRetryRequest);\n\n            WriteToSocket serverFlight;\n            serverFlight.contents.emplace_back(\n                state.writeRecordLayer()->writeHandshake(\n                    std::move(encodedHelloRetryRequest)));\n\n            if (legacySessionId && !legacySessionId->empty()) {\n              TLSContent writeCCS;\n              writeCCS.encryptionLevel = EncryptionLevel::Plaintext;\n              writeCCS.contentType = ContentType::change_cipher_spec;\n              writeCCS.data = folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n              serverFlight.contents.emplace_back(std::move(writeCCS));\n            }\n\n            // Create a new record layer in case we need to skip early data.\n            auto newReadRecordLayer =\n                state.context()->getFactory()->makePlaintextReadRecordLayer();\n            newReadRecordLayer->setSkipEncryptedRecords(\n                earlyDataType == EarlyDataType::Rejected);\n\n            return SemiFuture<Actions>(actions(\n                MutateState([handshakeContext = std::move(handshakeContext),\n                             version,\n                             cipher,\n                             group,\n                             earlyDataType,\n                             replayCacheResult,\n                             newReadRecordLayer = std::move(newReadRecordLayer),\n                             echStatus,\n                             echState =\n                                 std::move(echState)](State& newState) mutable {\n                  // Save some information about the current state to be\n                  // validated when we get the second client hello. We don't\n                  // validate that the second client hello matches the first\n                  // as strictly as we could according to the spec however.\n                  newState.handshakeContext() = std::move(handshakeContext);\n                  newState.version() = version;\n                  newState.cipher() = cipher;\n                  newState.group() = group;\n                  newState.keyExchangeType() =\n                      KeyExchangeType::HelloRetryRequest;\n                  newState.earlyDataType() = earlyDataType;\n                  newState.replayCacheResult() = replayCacheResult;\n                  newState.readRecordLayer() = std::move(newReadRecordLayer);\n                  newState.echStatus() = echStatus;\n                  if (echStatus == ECHStatus::Accepted) {\n                    newState.echState() = std::move(echState);\n                  }\n                }),\n                std::move(serverFlight),\n                MutateState(&Transition<StateEnum::ExpectingClientHello>)));\n          }\n\n          if (state.keyExchangeType().has_value()) {\n            keyExchangeType = *state.keyExchangeType();\n          } else {\n            keyExchangeType = KeyExchangeType::OneRtt;\n          }\n\n          // The exceptions in SemiFutures will be processed in\n          // detail::processEvent.\n          kex = state.context()->getFactory()->makeKeyExchange(\n              *group, Factory::KeyExchangeMode::Server);\n          kexResultFuture =\n              doKexFuture(kex.get(), std::move(clientShare.value()));\n        } else {\n          keyExchangeType = KeyExchangeType::None;\n        }\n\n        return runOnCallerIfComplete(\n            state.executor(),\n            std::move(kexResultFuture),\n            [&state,\n             scheduler = std::move(scheduler),\n             handshakeContext = std::move(handshakeContext),\n             cipher,\n             group,\n             echStatus,\n             earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n             earlyReadSecretAvailable = std::move(earlyReadSecretAvailable),\n             earlyExporterMaster = std::move(earlyExporterMaster),\n             pskType,\n             pskMode,\n             version,\n             keyExchangeType,\n             earlyDataType,\n             replayCacheResult,\n             alpn = std::move(alpn),\n             clockSkew,\n             appToken = std::move(appToken),\n             legacySessionId = std::move(legacySessionId),\n             handshakeTime,\n             chlo = std::move(chlo),\n             cookieState = std::move(cookieState),\n             resState = std::move(resState),\n             // Hold kex until the doKexFuture finished.\n             kex = std::move(kex)](\n                Optional<AsyncKeyExchange::DoKexResult> kexResult) mutable {\n              Optional<Buf> serverShare;\n              if (kexResult.hasValue()) {\n                serverShare = std::move(kexResult.value().ourKeyShare);\n                scheduler->deriveHandshakeSecret(\n                    kexResult.value().sharedSecret->coalesce());\n              } else {\n                DCHECK(keyExchangeType == KeyExchangeType::None);\n                scheduler->deriveHandshakeSecret();\n              }\n              std::vector<Extension> additionalExtensions;\n              if (state.extensions()) {\n                additionalExtensions = state.extensions()->getExtensions(chlo);\n              }\n\n              if (state.group().has_value() &&\n                  (!group || *group != *state.group())) {\n                throw FizzException(\n                    \"group mismatch with previous negotiation\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              // Cookies are not required to have already negotiated the group\n              // but if they did it must match (psk_ke is still allowed as we\n              // may not know if we are accepting the psk when sending the\n              // cookie).\n              if (cookieState && cookieState->group && group &&\n                  *group != *cookieState->group) {\n                throw FizzException(\n                    \"group mismatch with cookie\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              auto serverHello = getServerHello(\n                  version,\n                  state.context()->getFactory()->makeRandom(),\n                  cipher,\n                  resState.has_value(),\n                  group,\n                  std::move(serverShare),\n                  legacySessionId ? legacySessionId->clone() : nullptr);\n\n              folly::Optional<std::vector<ech::ECHConfig>> echRetryConfigs;\n              if (echStatus == ECHStatus::Accepted) {\n                // Set up acceptance scheduler\n                auto echScheduler =\n                    state.context()->getFactory()->makeKeyScheduler(cipher);\n                echScheduler->deriveEarlySecret(folly::range(chlo.random));\n                // Add acceptance extension\n                ech::setAcceptConfirmation(\n                    serverHello,\n                    handshakeContext->clone(),\n                    std::move(echScheduler));\n              } else if (echStatus == ECHStatus::Rejected) {\n                auto decrypter = state.context()->getECHDecrypter();\n                echRetryConfigs = decrypter->getRetryConfigs();\n              }\n\n              auto encodedServerHello = encodeHandshake(std::move(serverHello));\n              handshakeContext->appendToTranscript(encodedServerHello);\n\n              // Derive handshake keys.\n              auto handshakeWriteRecordLayer =\n                  state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeWriteRecordLayer->setProtocolVersion(version);\n              auto handshakeWriteSecret = scheduler->getSecret(\n                  HandshakeSecrets::ServerHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeWriteRecordLayer,\n                  cipher,\n                  folly::range(handshakeWriteSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n\n              auto handshakeReadRecordLayer =\n                  state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeReadRecordLayer->setProtocolVersion(version);\n              handshakeReadRecordLayer->setSkipFailedDecryption(\n                  earlyDataType == EarlyDataType::Rejected);\n              auto handshakeReadSecret = scheduler->getSecret(\n                  HandshakeSecrets::ClientHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeReadRecordLayer,\n                  cipher,\n                  folly::range(handshakeReadSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n              auto clientHandshakeSecret =\n                  folly::IOBuf::copyBuffer(handshakeReadSecret.secret);\n\n              auto encodedEncryptedExt = getEncryptedExt(\n                  *handshakeContext,\n                  alpn,\n                  earlyDataType,\n                  std::move(echRetryConfigs),\n                  std::move(additionalExtensions));\n\n              /*\n               * Determine we are requesting client auth.\n               * If yes, add CertificateRequest to handshake write and\n               * transcript.\n               */\n              bool requestClientAuth = state.context()->getClientAuthMode() !=\n                      ClientAuthMode::None &&\n                  !resState;\n              Optional<Buf> encodedCertRequest;\n              if (requestClientAuth) {\n                encodedCertRequest = getCertificateRequest(\n                    state.context()->getSupportedSigSchemes(),\n                    state.context()->getClientCertVerifier().get(),\n                    *handshakeContext);\n              }\n\n              /*\n               * Set the cert and signature scheme we are using.\n               * If sending new cert, add Certificate to handshake write and\n               * transcript.\n               */\n              Optional<Buf> encodedCertificate;\n              SemiFuture<Optional<Buf>> signature = folly::none;\n              Optional<SignatureScheme> sigScheme;\n              Optional<std::shared_ptr<const Cert>> serverCert;\n              std::shared_ptr<const Cert> clientCert;\n              Optional<CertificateCompressionAlgorithm> certCompressionAlgo;\n              if (!resState) { // TODO or reauth\n                std::shared_ptr<const SelfCert> originalSelfCert;\n                std::tie(originalSelfCert, sigScheme) =\n                    chooseCert(*state.context(), chlo);\n\n                std::tie(encodedCertificate, certCompressionAlgo) =\n                    getCertificate(\n                        originalSelfCert,\n                        *state.context(),\n                        chlo,\n                        *handshakeContext);\n\n                auto toBeSigned = handshakeContext->getHandshakeContext();\n                auto asyncSelfCert =\n                    dynamic_cast<const AsyncSelfCert*>(originalSelfCert.get());\n                if (asyncSelfCert) {\n                  signature = asyncSelfCert->signFuture(\n                      *sigScheme,\n                      CertificateVerifyContext::Server,\n                      std::move(toBeSigned));\n                } else {\n                  signature = folly::makeSemiFuture<Optional<Buf>>(\n                      originalSelfCert->sign(\n                          *sigScheme,\n                          CertificateVerifyContext::Server,\n                          toBeSigned->coalesce()));\n                }\n                serverCert = std::move(originalSelfCert);\n              } else {\n                serverCert = std::move(resState->serverCert);\n                clientCert = std::move(resState->clientCert);\n              }\n\n              auto clientRandom = std::move(chlo.random);\n\n              return runOnCallerIfComplete(\n                  state.executor(),\n                  std::move(signature),\n                  [&state,\n                   scheduler = std::move(scheduler),\n                   handshakeContext = std::move(handshakeContext),\n                   cipher,\n                   clientRandom = std::move(clientRandom),\n                   group,\n                   echStatus,\n                   encodedServerHello = std::move(encodedServerHello),\n                   handshakeWriteRecordLayer =\n                       std::move(handshakeWriteRecordLayer),\n                   handshakeWriteSecret = std::move(handshakeWriteSecret),\n                   handshakeReadRecordLayer =\n                       std::move(handshakeReadRecordLayer),\n                   handshakeReadSecret = std::move(handshakeReadSecret),\n                   earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n                   earlyReadSecretAvailable =\n                       std::move(earlyReadSecretAvailable),\n                   earlyExporterMaster = std::move(earlyExporterMaster),\n                   clientHandshakeSecret = std::move(clientHandshakeSecret),\n                   encodedEncryptedExt = std::move(encodedEncryptedExt),\n                   encodedCertificate = std::move(encodedCertificate),\n                   encodedCertRequest = std::move(encodedCertRequest),\n                   requestClientAuth,\n                   pskType,\n                   pskMode,\n                   sigScheme,\n                   version,\n                   keyExchangeType,\n                   earlyDataType,\n                   replayCacheResult,\n                   serverCert = std::move(serverCert),\n                   clientCert = std::move(clientCert),\n                   alpn = std::move(alpn),\n                   clockSkew,\n                   appToken = std::move(appToken),\n                   legacySessionId = std::move(legacySessionId),\n                   serverCertCompAlgo = certCompressionAlgo,\n                   handshakeTime](Optional<Buf> sig) mutable {\n                    Optional<Buf> encodedCertificateVerify;\n                    if (sig) {\n                      encodedCertificateVerify = getCertificateVerify(\n                          *sigScheme, std::move(*sig), *handshakeContext);\n                    }\n\n                    auto encodedFinished = Protocol::getFinished(\n                        folly::range(handshakeWriteSecret.secret),\n                        *handshakeContext);\n\n                    folly::IOBufQueue combined;\n                    if (encodedCertificate) {\n                      if (encodedCertRequest) {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertRequest));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      } else {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      }\n                    } else {\n                      combined.append(std::move(encodedEncryptedExt));\n                      combined.append(std::move(encodedFinished));\n                    }\n\n                    // Some middleboxes appear to break if the first encrypted\n                    // record is larger than ~1300 bytes (likely if it does not\n                    // fit in the first packet).\n                    auto serverEncrypted =\n                        handshakeWriteRecordLayer->writeHandshake(\n                            combined.splitAtMost(1000));\n                    if (!combined.empty()) {\n                      auto splitRecord =\n                          handshakeWriteRecordLayer->writeHandshake(\n                              combined.move());\n                      // Split record must have the same encryption level as the\n                      // main handshake.\n                      DCHECK(\n                          splitRecord.encryptionLevel ==\n                          serverEncrypted.encryptionLevel);\n                      serverEncrypted.data->prependChain(\n                          std::move(splitRecord.data));\n                    }\n\n                    WriteToSocket serverFlight;\n                    serverFlight.contents.emplace_back(\n                        state.writeRecordLayer()->writeHandshake(\n                            std::move(encodedServerHello)));\n                    if (legacySessionId && !legacySessionId->empty()) {\n                      TLSContent ccsWrite;\n                      ccsWrite.encryptionLevel = EncryptionLevel::Plaintext;\n                      ccsWrite.contentType = ContentType::change_cipher_spec;\n                      ccsWrite.data =\n                          folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n                      serverFlight.contents.emplace_back(std::move(ccsWrite));\n                    }\n                    serverFlight.contents.emplace_back(\n                        std::move(serverEncrypted));\n\n                    scheduler->deriveMasterSecret();\n                    auto clientFinishedContext =\n                        handshakeContext->getHandshakeContext();\n                    auto exporterMasterVector = scheduler->getSecret(\n                        MasterSecrets::ExporterMaster,\n                        clientFinishedContext->coalesce());\n                    auto exporterMaster = folly::IOBuf::copyBuffer(\n                        folly::range(exporterMasterVector.secret));\n\n                    scheduler->deriveAppTrafficSecrets(\n                        clientFinishedContext->coalesce());\n                    auto appTrafficWriteRecordLayer =\n                        state.context()\n                            ->getFactory()\n                            ->makeEncryptedWriteRecordLayer(\n                                EncryptionLevel::AppTraffic);\n                    appTrafficWriteRecordLayer->setProtocolVersion(version);\n                    auto writeSecret = scheduler->getSecret(\n                        AppTrafficSecrets::ServerAppTraffic);\n                    Protocol::setAead(\n                        *appTrafficWriteRecordLayer,\n                        cipher,\n                        folly::range(writeSecret.secret),\n                        *state.context()->getFactory(),\n                        *scheduler);\n\n                    // If we have previously dealt with early data (before a\n                    // HelloRetryRequest), don't overwrite the previous result.\n                    auto earlyDataTypeSave = state.earlyDataType()\n                        ? *state.earlyDataType()\n                        : earlyDataType;\n\n                    SecretAvailable handshakeReadSecretAvailable(\n                        std::move(handshakeReadSecret));\n                    SecretAvailable handshakeWriteSecretAvailable(\n                        std::move(handshakeWriteSecret));\n                    SecretAvailable appWriteSecretAvailable(\n                        std::move(writeSecret));\n\n                    // Save all the necessary state except for the read record\n                    // layer, which is done separately as it varies if early\n                    // data was accepted.\n                    MutateState saveState(\n                        [appTrafficWriteRecordLayer =\n                             std::move(appTrafficWriteRecordLayer),\n                         handshakeContext = std::move(handshakeContext),\n                         scheduler = std::move(scheduler),\n                         exporterMaster = std::move(exporterMaster),\n                         serverCert = std::move(serverCert),\n                         clientCert = std::move(clientCert),\n                         cipher,\n                         group,\n                         sigScheme,\n                         clientHandshakeSecret =\n                             std::move(clientHandshakeSecret),\n                         pskType,\n                         pskMode,\n                         version,\n                         keyExchangeType,\n                         alpn = std::move(alpn),\n                         earlyDataTypeSave,\n                         replayCacheResult,\n                         clockSkew,\n                         appToken = std::move(appToken),\n                         serverCertCompAlgo,\n                         echStatus,\n                         clientRandom = std::move(clientRandom),\n                         handshakeTime = std::move(handshakeTime)](\n                            State& newState) mutable {\n                          newState.writeRecordLayer() =\n                              std::move(appTrafficWriteRecordLayer);\n                          newState.handshakeContext() =\n                              std::move(handshakeContext);\n                          newState.keyScheduler() = std::move(scheduler);\n                          newState.exporterMasterSecret() =\n                              std::move(exporterMaster);\n                          newState.serverCert() = std::move(*serverCert);\n                          newState.clientCert() = std::move(clientCert);\n                          newState.version() = version;\n                          newState.cipher() = cipher;\n                          newState.group() = group;\n                          newState.sigScheme() = sigScheme;\n                          newState.clientHandshakeSecret() =\n                              std::move(clientHandshakeSecret);\n                          newState.pskType() = pskType;\n                          newState.pskMode() = pskMode;\n                          newState.keyExchangeType() = keyExchangeType;\n                          newState.earlyDataType() = earlyDataTypeSave;\n                          newState.replayCacheResult() = replayCacheResult;\n                          newState.alpn() = std::move(alpn);\n                          newState.clientClockSkew() = clockSkew;\n                          newState.appToken() = std::move(appToken);\n                          newState.serverCertCompAlgo() = serverCertCompAlgo;\n                          newState.handshakeTime() = std::move(handshakeTime);\n                          newState.clientRandom() = std::move(clientRandom);\n                          newState.echStatus() = echStatus;\n                          newState.echState() = folly::none;\n                        });\n\n                    if (earlyDataType == EarlyDataType::Accepted) {\n                      if (state.context()->getOmitEarlyRecordLayer()) {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::ExpectingFinished>),\n                            ReportEarlyHandshakeSuccess());\n\n                      } else {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyReadRecordLayer =\n                                             std::move(earlyReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(earlyReadRecordLayer);\n                              newState.handshakeReadRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::AcceptingEarlyData>),\n                            ReportEarlyHandshakeSuccess());\n                      }\n                    } else {\n                      auto transition = requestClientAuth\n                          ? Transition<StateEnum::ExpectingCertificate>\n                          : Transition<StateEnum::ExpectingFinished>;\n                      return actions(\n                          MutateState([handshakeReadRecordLayer =\n                                           std::move(handshakeReadRecordLayer)](\n                                          State& newState) mutable {\n                            newState.readRecordLayer() =\n                                std::move(handshakeReadRecordLayer);\n                          }),\n                          std::move(saveState),\n                          std::move(handshakeReadSecretAvailable),\n                          std::move(handshakeWriteSecretAvailable),\n                          std::move(appWriteSecretAvailable),\n                          std::move(serverFlight),\n                          MutateState(transition));\n                    }\n                  });\n            });\n      });\n}",
  "abstract_func_before": "AsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingClientHello, Event::ClientHello>::\n    handle(const State& VAR_0, Param VAR_1) {\n  ClientHello VAR_2 = std::move(*VAR_1.asClientHello());\n\n  auto VAR_3 = getCookieState(VAR_2, VAR_0.context()->getCookieCipher());\n\n  if (VAR_0.handshakeContext() && VAR_3.has_value()) {\n    throw FizzException(\n        \"cookie after statefull hrr\", AlertDescription::illegal_parameter);\n  }\n\n  ECHStatus VAR_4;\n  ECHState VAR_5;\n  std::tie(VAR_4, VAR_5) = processECH(VAR_3, VAR_0, VAR_2);\n\n  addHandshakeLogging(VAR_0, VAR_2);\n\n  if (VAR_0.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after client hello\", AlertDescription::unexpected_message);\n  }\n\n  auto VAR_6 =\n      negotiateVersion(VAR_2, VAR_0.context()->getSupportedVersions());\n\n  if (VAR_0.version().has_value() &&\n      (!VAR_6 || *VAR_6 != *VAR_0.version())) {\n    throw FizzException(\n        \"version mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  if (!VAR_6) {\n    if (VAR_7<ClientEarlyData>(VAR_2.extensions)) {\n      throw FizzException(\n          \"supported version mismatch with early data\",\n          AlertDescription::protocol_version);\n    }\n    if (VAR_0.context()->getVersionFallbackEnabled()) {\n      AttemptVersionFallback VAR_8;\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_8.clientHello =\n          PlaintextWriteRecordLayer()\n              .writeInitialClientHello(std::move(*VAR_2.originalEncoding))\n              .data;\n      return actions(\n          MutateState(&VAR_9<StateEnum::Error>), std::move(VAR_8));\n    } else {\n      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  VAR_0.writeRecordLayer()->setProtocolVersion(*VAR_6);\n\n  validateClientHello(VAR_2);\n\n  auto VAR_10 = negotiateCipher(VAR_2, VAR_0.context()->getSupportedCiphers());\n\n  verifyCookieState(VAR_3, *VAR_6, VAR_10);\n\n  auto VAR_11 = getResumptionState(\n      VAR_2,\n      VAR_0.context()->getTicketCipher(),\n      VAR_0.context()->getSupportedPskModes());\n\n  auto VAR_12 = getReplayCacheResult(\n      VAR_2,\n      VAR_0.context()->getAcceptEarlyData(*VAR_6),\n      VAR_0.context()->getReplayCache());\n\n  auto VAR_13 =\n      collectAll(VAR_11.futureResState, VAR_12);\n\n  using FutureResultType = std::tuple<\n      folly::Try<std::pair<VAR_14, Optional<ResumptionState>>>,\n      folly::Try<ReplayCacheResult>>;\n  return runOnCallerIfComplete(\n      VAR_0.executor(),\n      std::move(VAR_13),\n      [&VAR_0,\n       VAR_2 = std::move(VAR_2),\n       VAR_3 = std::move(VAR_3),\n       VAR_6 = *VAR_6,\n       VAR_10,\n       VAR_15 = VAR_11.pskMode,\n       VAR_4,\n       VAR_5 = std::move(VAR_5),\n       VAR_16 =\n           VAR_11.obfuscatedAge](FutureResultType VAR_17) mutable {\n        auto& VAR_18 = *std::VAR_19<0>(VAR_17);\n        auto VAR_20 = VAR_18.first;\n        auto VAR_21 = std::move(VAR_18.second);\n        auto VAR_22 = *std::VAR_19<1>(VAR_17);\n\n        if (VAR_21) {\n          if (!validateResumptionState(*VAR_21, *VAR_15, VAR_6, VAR_10)) {\n            VAR_20 = PskType::Rejected;\n            VAR_15 = folly::none;\n            VAR_21 = folly::none;\n          }\n        } else {\n          VAR_15 = folly::none;\n        }\n\n        auto VAR_23 = VAR_2.legacy_session_id->clone();\n\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        std::chrono::system_clock::time_point VAR_24;\n        if (VAR_21) {\n          VAR_24 = VAR_21->handshakeTime;\n        } else {\n          VAR_24 = VAR_0.context()->getClock().getCurrentTime();\n        }\n\n        std::unique_ptr<KeyScheduler> VAR_25;\n        std::unique_ptr<HandshakeContext> VAR_26;\n        std::tie(VAR_25, VAR_26) = setupSchedulerAndContext(\n            *VAR_0.context()->getFactory(),\n            VAR_10,\n            VAR_2,\n            VAR_21,\n            VAR_3,\n            VAR_20,\n            std::move(VAR_0.handshakeContext()),\n            VAR_6);\n\n        if (VAR_0.cipher().has_value() && VAR_10 != *VAR_0.cipher()) {\n          throw FizzException(\n              \"cipher mismatch with previous negotiation\",\n              AlertDescription::illegal_parameter);\n        }\n\n        auto VAR_27 = negotiateAlpn(VAR_2, folly::none, *VAR_0.context());\n\n        auto VAR_28 = getClockSkew(\n            VAR_21,\n            VAR_16,\n            VAR_0.context()->getClock().getCurrentTime());\n\n        auto VAR_29 = getAppToken(VAR_21);\n\n        auto VAR_30 = negotiateEarlyDataType(\n            VAR_0.context()->getAcceptEarlyData(VAR_6),\n            VAR_2,\n            VAR_21,\n            VAR_10,\n            VAR_0.keyExchangeType(),\n            VAR_3,\n            VAR_27,\n            VAR_22,\n            VAR_28,\n            VAR_0.context()->getClockSkewTolerance(),\n            VAR_0.appTokenValidator());\n\n        std::unique_ptr<EncryptedReadRecordLayer> VAR_31;\n        Buf VAR_32;\n        folly::Optional<SecretAvailable> VAR_33;\n        if (VAR_30 == EarlyDataType::Accepted) {\n          auto VAR_34 = VAR_26->getHandshakeContext();\n          auto VAR_35 = VAR_25->getSecret(\n              EarlySecrets::ClientEarlyTraffic, VAR_34->coalesce());\n          if (!VAR_0.context()->getOmitEarlyRecordLayer()) {\n            VAR_31 =\n                VAR_0.context()->getFactory()->makeEncryptedReadRecordLayer(\n                    EncryptionLevel::EarlyData);\n            VAR_31->setProtocolVersion(VAR_6);\n\n            Protocol::setAead(\n                *VAR_31,\n                VAR_10,\n                folly::range(VAR_35.secret),\n                *VAR_0.context()->getFactory(),\n                *VAR_25);\n          }\n\n          VAR_33 =\n              SecretAvailable(std::move(VAR_35));\n          VAR_32 = folly::IOBuf::copyBuffer(\n              VAR_25\n                  ->getSecret(\n                      EarlySecrets::EarlyExporter, VAR_34->coalesce())\n                  .secret);\n        }\n\n        Optional<NamedGroup> VAR_36;\n        KeyExchangeType VAR_37;\n        SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> VAR_38 =\n            folly::none;\n        std::unique_ptr<KeyExchange> VAR_39 = nullptr;\n\n        if (!VAR_15 || *VAR_15 != PskKeyExchangeMode::psk_ke) {\n          Optional<Buf> VAR_40;\n          std::tie(VAR_36, VAR_40) = negotiateGroup(\n              VAR_6, VAR_2, VAR_0.context()->getSupportedGroups());\n          if (!VAR_40) {\n            VLOG(8) << \"Did not find key share for \" << toString(*VAR_36);\n            if (VAR_0.group().has_value() || VAR_3) {\n              throw FizzException(\n                  \"key share not found for already negotiated group\",\n                  AlertDescription::illegal_parameter);\n            }\n\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            if (VAR_30 == EarlyDataType::Accepted) {\n              VAR_30 = EarlyDataType::Rejected;\n            }\n\n            message_hash VAR_41;\n            VAR_41.hash = VAR_26->getHandshakeContext();\n            VAR_26 =\n                VAR_0.context()->getFactory()->makeHandshakeContext(VAR_10);\n            VAR_26->appendToTranscript(\n                encodeHandshake(std::move(VAR_41)));\n\n            auto VAR_42 = getHelloRetryRequest(\n                VAR_6,\n                VAR_10,\n                *VAR_36,\n                VAR_23 ? VAR_23->clone() : nullptr,\n                *VAR_26);\n\n            if (VAR_4 == ECHStatus::Accepted) {\n              /* COMMENT_10 */\n              auto VAR_43 =\n                  VAR_0.context()->getFactory()->makeKeyScheduler(VAR_10);\n              VAR_43->deriveEarlySecret(folly::range(VAR_2.random));\n              /* COMMENT_11 */\n              ech::setAcceptConfirmation(\n                  VAR_42, VAR_26->clone(), std::move(VAR_43));\n            }\n\n            auto VAR_44 = encodeHandshake(std::move(VAR_42));\n            VAR_26->appendToTranscript(VAR_44);\n\n            WriteToSocket VAR_45;\n            VAR_45.contents.emplace_back(\n                VAR_0.writeRecordLayer()->writeHandshake(\n                    std::move(VAR_44)));\n\n            if (VAR_23 && !VAR_23->empty()) {\n              TLSContent VAR_46;\n              VAR_46.encryptionLevel = EncryptionLevel::Plaintext;\n              VAR_46.contentType = ContentType::change_cipher_spec;\n              VAR_46.data = folly::IOBuf::wrapBuffer(VAR_47);\n              VAR_45.contents.emplace_back(std::move(VAR_46));\n            }\n\n            /* COMMENT_12 */\n            auto VAR_48 =\n                VAR_0.context()->getFactory()->makePlaintextReadRecordLayer();\n            VAR_48->setSkipEncryptedRecords(\n                VAR_30 == EarlyDataType::Rejected);\n\n            return SemiFuture<Actions>(actions(\n                MutateState([VAR_26 = std::move(VAR_26),\n                             VAR_6,\n                             VAR_10,\n                             VAR_36,\n                             VAR_30,\n                             VAR_22,\n                             VAR_48 = std::move(VAR_48),\n                             VAR_4,\n                             VAR_5 =\n                                 std::move(VAR_5)](State& VAR_49) mutable {\n                  /* COMMENT_13 */\n                  /* COMMENT_14 */\n                  /* COMMENT_15 */\n                  /* COMMENT_16 */\n                  VAR_49.handshakeContext() = std::move(VAR_26);\n                  VAR_49.version() = VAR_6;\n                  VAR_49.cipher() = VAR_10;\n                  VAR_49.group() = VAR_36;\n                  VAR_49.keyExchangeType() =\n                      KeyExchangeType::HelloRetryRequest;\n                  VAR_49.earlyDataType() = VAR_30;\n                  VAR_49.replayCacheResult() = VAR_22;\n                  VAR_49.readRecordLayer() = std::move(VAR_48);\n                  VAR_49.echStatus() = VAR_4;\n                  if (VAR_4 == ECHStatus::Accepted) {\n                    VAR_49.echState() = std::move(VAR_5);\n                  }\n                }),\n                std::move(VAR_45),\n                MutateState(&VAR_9<StateEnum::ExpectingClientHello>)));\n          }\n\n          if (VAR_0.keyExchangeType().has_value()) {\n            VAR_37 = *VAR_0.keyExchangeType();\n          } else {\n            VAR_37 = KeyExchangeType::OneRtt;\n          }\n\n          /* COMMENT_17 */\n          /* COMMENT_18 */\n          VAR_39 = VAR_0.context()->getFactory()->makeKeyExchange(\n              *VAR_36, Factory::KeyExchangeMode::Server);\n          VAR_38 =\n              doKexFuture(VAR_39.get(), std::move(VAR_40.value()));\n        } else {\n          VAR_37 = KeyExchangeType::None;\n        }\n\n        return runOnCallerIfComplete(\n            VAR_0.executor(),\n            std::move(VAR_38),\n            [&VAR_0,\n             VAR_25 = std::move(VAR_25),\n             VAR_26 = std::move(VAR_26),\n             VAR_10,\n             VAR_36,\n             VAR_4,\n             VAR_31 = std::move(VAR_31),\n             VAR_33 = std::move(VAR_33),\n             VAR_32 = std::move(VAR_32),\n             VAR_20,\n             VAR_15,\n             VAR_6,\n             VAR_37,\n             VAR_30,\n             VAR_22,\n             VAR_27 = std::move(VAR_27),\n             VAR_28,\n             VAR_29 = std::move(VAR_29),\n             VAR_23 = std::move(VAR_23),\n             VAR_24,\n             VAR_2 = std::move(VAR_2),\n             VAR_3 = std::move(VAR_3),\n             VAR_21 = std::move(VAR_21),\n             /* COMMENT_19 */\n             VAR_39 = std::move(VAR_39)](\n                Optional<AsyncKeyExchange::DoKexResult> VAR_50) mutable {\n              Optional<Buf> VAR_51;\n              if (VAR_50.hasValue()) {\n                VAR_51 = std::move(VAR_50.value().ourKeyShare);\n                VAR_25->deriveHandshakeSecret(\n                    VAR_50.value().sharedSecret->coalesce());\n              } else {\n                DCHECK(VAR_37 == KeyExchangeType::None);\n                VAR_25->deriveHandshakeSecret();\n              }\n              std::vector<Extension> VAR_52;\n              if (VAR_0.extensions()) {\n                VAR_52 = VAR_0.extensions()->getExtensions(VAR_2);\n              }\n\n              if (VAR_0.group().has_value() &&\n                  (!VAR_36 || *VAR_36 != *VAR_0.group())) {\n                throw FizzException(\n                    \"group mismatch with previous negotiation\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              /* COMMENT_20 */\n              /* COMMENT_21 */\n              /* COMMENT_22 */\n              /* COMMENT_23 */\n              if (VAR_3 && VAR_3->group && VAR_36 &&\n                  *VAR_36 != *VAR_3->group) {\n                throw FizzException(\n                    \"group mismatch with cookie\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              auto VAR_53 = getServerHello(\n                  VAR_6,\n                  VAR_0.context()->getFactory()->makeRandom(),\n                  VAR_10,\n                  VAR_21.has_value(),\n                  VAR_36,\n                  std::move(VAR_51),\n                  VAR_23 ? VAR_23->clone() : nullptr);\n\n              folly::Optional<std::vector<ech::ECHConfig>> VAR_54;\n              if (VAR_4 == ECHStatus::Accepted) {\n                /* COMMENT_10 */\n                auto VAR_43 =\n                    VAR_0.context()->getFactory()->makeKeyScheduler(VAR_10);\n                VAR_43->deriveEarlySecret(folly::range(VAR_2.random));\n                /* COMMENT_11 */\n                ech::setAcceptConfirmation(\n                    VAR_53,\n                    VAR_26->clone(),\n                    std::move(VAR_43));\n              } else if (VAR_4 == ECHStatus::Rejected) {\n                auto VAR_55 = VAR_0.context()->getECHDecrypter();\n                VAR_54 = VAR_55->getRetryConfigs();\n              }\n\n              auto VAR_56 = encodeHandshake(std::move(VAR_53));\n              VAR_26->appendToTranscript(VAR_56);\n\n              /* COMMENT_24 */\n              auto VAR_57 =\n                  VAR_0.context()->getFactory()->makeEncryptedWriteRecordLayer(\n                      EncryptionLevel::Handshake);\n              VAR_57->setProtocolVersion(VAR_6);\n              auto VAR_58 = VAR_25->getSecret(\n                  HandshakeSecrets::ServerHandshakeTraffic,\n                  VAR_26->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *VAR_57,\n                  VAR_10,\n                  folly::range(VAR_58.secret),\n                  *VAR_0.context()->getFactory(),\n                  *VAR_25);\n\n              auto VAR_59 =\n                  VAR_0.context()->getFactory()->makeEncryptedReadRecordLayer(\n                      EncryptionLevel::Handshake);\n              VAR_59->setProtocolVersion(VAR_6);\n              VAR_59->setSkipFailedDecryption(\n                  VAR_30 == EarlyDataType::Rejected);\n              auto VAR_60 = VAR_25->getSecret(\n                  HandshakeSecrets::ClientHandshakeTraffic,\n                  VAR_26->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *VAR_59,\n                  VAR_10,\n                  folly::range(VAR_60.secret),\n                  *VAR_0.context()->getFactory(),\n                  *VAR_25);\n              auto VAR_61 =\n                  folly::IOBuf::copyBuffer(VAR_60.secret);\n\n              auto VAR_62 = getEncryptedExt(\n                  *VAR_26,\n                  VAR_27,\n                  VAR_30,\n                  std::move(VAR_54),\n                  std::move(VAR_52));\n\n              /* COMMENT_25 */\n                                                         \n                                                                      \n                            \n                 \n              bool VAR_63 = VAR_0.context()->getClientAuthMode() !=\n                      ClientAuthMode::None &&\n                  !VAR_21;\n              Optional<Buf> VAR_64;\n              if (VAR_63) {\n                VAR_64 = getCertificateRequest(\n                    VAR_0.context()->getSupportedSigSchemes(),\n                    VAR_0.context()->getClientCertVerifier().get(),\n                    *VAR_26);\n              }\n\n              /* COMMENT_30 */\n                                                                \n                                                                            \n                            \n                 \n              Optional<Buf> VAR_65;\n              SemiFuture<Optional<Buf>> VAR_66 = folly::none;\n              Optional<SignatureScheme> VAR_67;\n              Optional<std::shared_ptr<const Cert>> VAR_68;\n              std::shared_ptr<const Cert> VAR_69;\n              Optional<CertificateCompressionAlgorithm> VAR_70;\n              if (!VAR_21) { /* COMMENT_35 */\n                std::shared_ptr<const SelfCert> VAR_71;\n                std::tie(VAR_71, VAR_67) =\n                    chooseCert(*VAR_0.context(), VAR_2);\n\n                std::tie(VAR_65, VAR_70) =\n                    getCertificate(\n                        VAR_71,\n                        *VAR_0.context(),\n                        VAR_2,\n                        *VAR_26);\n\n                auto VAR_72 = VAR_26->getHandshakeContext();\n                auto VAR_73 =\n                    VAR_74<const AsyncSelfCert*>(VAR_71.get());\n                if (VAR_73) {\n                  VAR_66 = VAR_73->signFuture(\n                      *VAR_67,\n                      CertificateVerifyContext::Server,\n                      std::move(VAR_72));\n                } else {\n                  VAR_66 = folly::VAR_75<Optional<Buf>>(\n                      VAR_71->sign(\n                          *VAR_67,\n                          CertificateVerifyContext::Server,\n                          VAR_72->coalesce()));\n                }\n                VAR_68 = std::move(VAR_71);\n              } else {\n                VAR_68 = std::move(VAR_21->serverCert);\n                VAR_69 = std::move(VAR_21->clientCert);\n              }\n\n              auto VAR_76 = std::move(VAR_2.random);\n\n              return runOnCallerIfComplete(\n                  VAR_0.executor(),\n                  std::move(VAR_66),\n                  [&VAR_0,\n                   VAR_25 = std::move(VAR_25),\n                   VAR_26 = std::move(VAR_26),\n                   VAR_10,\n                   VAR_76 = std::move(VAR_76),\n                   VAR_36,\n                   VAR_4,\n                   VAR_56 = std::move(VAR_56),\n                   VAR_57 =\n                       std::move(VAR_57),\n                   VAR_58 = std::move(VAR_58),\n                   VAR_59 =\n                       std::move(VAR_59),\n                   VAR_60 = std::move(VAR_60),\n                   VAR_31 = std::move(VAR_31),\n                   VAR_33 =\n                       std::move(VAR_33),\n                   VAR_32 = std::move(VAR_32),\n                   VAR_61 = std::move(VAR_61),\n                   VAR_62 = std::move(VAR_62),\n                   VAR_65 = std::move(VAR_65),\n                   VAR_64 = std::move(VAR_64),\n                   VAR_63,\n                   VAR_20,\n                   VAR_15,\n                   VAR_67,\n                   VAR_6,\n                   VAR_37,\n                   VAR_30,\n                   VAR_22,\n                   VAR_68 = std::move(VAR_68),\n                   VAR_69 = std::move(VAR_69),\n                   VAR_27 = std::move(VAR_27),\n                   VAR_28,\n                   VAR_29 = std::move(VAR_29),\n                   VAR_23 = std::move(VAR_23),\n                   VAR_77 = VAR_70,\n                   VAR_24](Optional<Buf> VAR_78) mutable {\n                    Optional<Buf> VAR_79;\n                    if (VAR_78) {\n                      VAR_79 = getCertificateVerify(\n                          *VAR_67, std::move(*VAR_78), *VAR_26);\n                    }\n\n                    auto VAR_80 = Protocol::getFinished(\n                        folly::range(VAR_58.secret),\n                        *VAR_26);\n\n                    folly::IOBufQueue VAR_81;\n                    if (VAR_65) {\n                      if (VAR_64) {\n                        VAR_81.append(std::move(VAR_62));\n                        VAR_81.append(std::move(*VAR_64));\n                        VAR_81.append(std::move(*VAR_65));\n                        VAR_81.append(std::move(*VAR_79));\n                        VAR_81.append(std::move(VAR_80));\n                      } else {\n                        VAR_81.append(std::move(VAR_62));\n                        VAR_81.append(std::move(*VAR_65));\n                        VAR_81.append(std::move(*VAR_79));\n                        VAR_81.append(std::move(VAR_80));\n                      }\n                    } else {\n                      VAR_81.append(std::move(VAR_62));\n                      VAR_81.append(std::move(VAR_80));\n                    }\n\n                    /* COMMENT_36 */\n                    /* COMMENT_37 */\n                    /* COMMENT_38 */\n                    auto VAR_82 =\n                        VAR_57->writeHandshake(\n                            VAR_81.splitAtMost(1000));\n                    if (!VAR_81.empty()) {\n                      auto VAR_83 =\n                          VAR_57->writeHandshake(\n                              VAR_81.move());\n                      /* COMMENT_39 */\n                      /* COMMENT_40 */\n                      DCHECK(\n                          VAR_83.encryptionLevel ==\n                          VAR_82.encryptionLevel);\n                      VAR_82.data->prependChain(\n                          std::move(VAR_83.data));\n                    }\n\n                    WriteToSocket VAR_45;\n                    VAR_45.contents.emplace_back(\n                        VAR_0.writeRecordLayer()->writeHandshake(\n                            std::move(VAR_56)));\n                    if (VAR_23 && !VAR_23->empty()) {\n                      TLSContent VAR_84;\n                      VAR_84.encryptionLevel = EncryptionLevel::Plaintext;\n                      VAR_84.contentType = ContentType::change_cipher_spec;\n                      VAR_84.data =\n                          folly::IOBuf::wrapBuffer(VAR_47);\n                      VAR_45.contents.emplace_back(std::move(VAR_84));\n                    }\n                    VAR_45.contents.emplace_back(\n                        std::move(VAR_82));\n\n                    VAR_25->deriveMasterSecret();\n                    auto VAR_85 =\n                        VAR_26->getHandshakeContext();\n                    auto VAR_86 = VAR_25->getSecret(\n                        MasterSecrets::ExporterMaster,\n                        VAR_85->coalesce());\n                    auto VAR_87 = folly::IOBuf::copyBuffer(\n                        folly::range(VAR_86.secret));\n\n                    VAR_25->deriveAppTrafficSecrets(\n                        VAR_85->coalesce());\n                    auto VAR_88 =\n                        VAR_0.context()\n                            ->getFactory()\n                            ->makeEncryptedWriteRecordLayer(\n                                EncryptionLevel::AppTraffic);\n                    VAR_88->setProtocolVersion(VAR_6);\n                    auto VAR_89 = VAR_25->getSecret(\n                        AppTrafficSecrets::ServerAppTraffic);\n                    Protocol::setAead(\n                        *VAR_88,\n                        VAR_10,\n                        folly::range(VAR_89.secret),\n                        *VAR_0.context()->getFactory(),\n                        *VAR_25);\n\n                    /* COMMENT_41 */\n                    /* COMMENT_42 */\n                    auto VAR_90 = VAR_0.earlyDataType()\n                        ? *VAR_0.earlyDataType()\n                        : VAR_30;\n\n                    SecretAvailable handshakeReadSecretAvailable(\n                        std::move(handshakeReadSecret));\n                    SecretAvailable handshakeWriteSecretAvailable(\n                        std::move(handshakeWriteSecret));\n                    SecretAvailable appWriteSecretAvailable(\n                        std::move(writeSecret));\n\n                    /* COMMENT_43 */\n                    /* COMMENT_44 */\n                    /* COMMENT_45 */\n                    MutateState VAR_91(\n                        [VAR_88 =\n                             std::move(VAR_88),\n                         VAR_26 = std::move(VAR_26),\n                         VAR_25 = std::move(VAR_25),\n                         VAR_87 = std::move(VAR_87),\n                         VAR_68 = std::move(VAR_68),\n                         VAR_69 = std::move(VAR_69),\n                         VAR_10,\n                         VAR_36,\n                         VAR_67,\n                         VAR_61 =\n                             std::move(VAR_61),\n                         VAR_20,\n                         VAR_15,\n                         VAR_6,\n                         VAR_37,\n                         VAR_27 = std::move(VAR_27),\n                         VAR_90,\n                         VAR_22,\n                         VAR_28,\n                         VAR_29 = std::move(VAR_29),\n                         VAR_77,\n                         VAR_4,\n                         VAR_76 = std::move(VAR_76),\n                         VAR_24 = std::move(VAR_24)](\n                            State& VAR_49) mutable {\n                          VAR_49.writeRecordLayer() =\n                              std::move(VAR_88);\n                          VAR_49.handshakeContext() =\n                              std::move(VAR_26);\n                          VAR_49.keyScheduler() = std::move(VAR_25);\n                          VAR_49.exporterMasterSecret() =\n                              std::move(VAR_87);\n                          VAR_49.serverCert() = std::move(*VAR_68);\n                          VAR_49.clientCert() = std::move(VAR_69);\n                          VAR_49.version() = VAR_6;\n                          VAR_49.cipher() = VAR_10;\n                          VAR_49.group() = VAR_36;\n                          VAR_49.sigScheme() = VAR_67;\n                          VAR_49.clientHandshakeSecret() =\n                              std::move(VAR_61);\n                          VAR_49.pskType() = VAR_20;\n                          VAR_49.pskMode() = VAR_15;\n                          VAR_49.keyExchangeType() = VAR_37;\n                          VAR_49.earlyDataType() = VAR_90;\n                          VAR_49.replayCacheResult() = VAR_22;\n                          VAR_49.alpn() = std::move(VAR_27);\n                          VAR_49.clientClockSkew() = VAR_28;\n                          VAR_49.appToken() = std::move(VAR_29);\n                          VAR_49.serverCertCompAlgo() = VAR_77;\n                          VAR_49.handshakeTime() = std::move(VAR_24);\n                          VAR_49.clientRandom() = std::move(VAR_76);\n                          VAR_49.echStatus() = VAR_4;\n                          VAR_49.echState() = folly::none;\n                        });\n\n                    if (VAR_30 == EarlyDataType::Accepted) {\n                      if (VAR_0.context()->getOmitEarlyRecordLayer()) {\n                        return actions(\n                            MutateState([VAR_59 = std::move(\n                                             VAR_59),\n                                         VAR_32 =\n                                             std::move(VAR_32)](\n                                            State& VAR_49) mutable {\n                              VAR_49.readRecordLayer() =\n                                  std::move(VAR_59);\n                              VAR_49.earlyExporterMasterSecret() =\n                                  std::move(VAR_32);\n                            }),\n                            std::move(VAR_91),\n                            std::move(*VAR_33),\n                            std::move(VAR_92),\n                            std::move(VAR_93),\n                            std::move(VAR_94),\n                            std::move(VAR_45),\n                            MutateState(\n                                &VAR_9<StateEnum::ExpectingFinished>),\n                            ReportEarlyHandshakeSuccess());\n\n                      } else {\n                        return actions(\n                            MutateState([VAR_59 = std::move(\n                                             VAR_59),\n                                         VAR_31 =\n                                             std::move(VAR_31),\n                                         VAR_32 =\n                                             std::move(VAR_32)](\n                                            State& VAR_49) mutable {\n                              VAR_49.readRecordLayer() =\n                                  std::move(VAR_31);\n                              VAR_49.handshakeReadRecordLayer() =\n                                  std::move(VAR_59);\n                              VAR_49.earlyExporterMasterSecret() =\n                                  std::move(VAR_32);\n                            }),\n                            std::move(VAR_91),\n                            std::move(*VAR_33),\n                            std::move(VAR_92),\n                            std::move(VAR_93),\n                            std::move(VAR_94),\n                            std::move(VAR_45),\n                            MutateState(\n                                &VAR_9<StateEnum::AcceptingEarlyData>),\n                            ReportEarlyHandshakeSuccess());\n                      }\n                    } else {\n                      auto VAR_95 = VAR_63\n                          ? VAR_9<StateEnum::ExpectingCertificate>\n                          : VAR_9<StateEnum::ExpectingFinished>;\n                      return actions(\n                          MutateState([VAR_59 =\n                                           std::move(VAR_59)](\n                                          State& VAR_49) mutable {\n                            VAR_49.readRecordLayer() =\n                                std::move(VAR_59);\n                          }),\n                          std::move(VAR_91),\n                          std::move(VAR_92),\n                          std::move(VAR_93),\n                          std::move(VAR_94),\n                          std::move(VAR_45),\n                          MutateState(VAR_95));\n                    }\n                  });\n            });\n      });\n}",
  "func_graph_path_before": "facebookincubator/fizz/8d3649841597bedfb6986c30431ebad0eb215265/ServerProtocol.cpp/vul/before/0.json",
  "func": "AsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingClientHello, Event::ClientHello>::\n    handle(const State& state, Param param) {\n  ClientHello chlo = std::move(*param.asClientHello());\n\n  auto cookieState = getCookieState(chlo, state.context()->getCookieCipher());\n\n  if (state.handshakeContext() && cookieState.has_value()) {\n    throw FizzException(\n        \"cookie after statefull hrr\", AlertDescription::illegal_parameter);\n  }\n\n  ECHStatus echStatus;\n  ECHState echState;\n  std::tie(echStatus, echState) = processECH(cookieState, state, chlo);\n\n  addHandshakeLogging(state, chlo);\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after client hello\", AlertDescription::unexpected_message);\n  }\n\n  auto version =\n      negotiateVersion(chlo, state.context()->getSupportedVersions());\n\n  if (state.version().has_value() &&\n      (!version || *version != *state.version())) {\n    throw FizzException(\n        \"version mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  if (!version) {\n    if (getExtension<ClientEarlyData>(chlo.extensions)) {\n      throw FizzException(\n          \"supported version mismatch with early data\",\n          AlertDescription::protocol_version);\n    }\n    if (state.context()->getVersionFallbackEnabled()) {\n      AttemptVersionFallback fallback;\n      // Re-encode to put the record layer header back on. This won't\n      // necessarily preserve it byte-for-byte, but it isn't authenticated so\n      // should be ok.\n      fallback.clientHello =\n          PlaintextWriteRecordLayer()\n              .writeInitialClientHello(std::move(*chlo.originalEncoding))\n              .data;\n      return actions(\n          MutateState(&Transition<StateEnum::Error>), std::move(fallback));\n    } else {\n      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  if (state.cipher().has_value() && cipher != *state.cipher()) {\n    throw FizzException(\n        \"cipher mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n      state.context()->getReplayCache());\n\n  auto results =\n      collectAll(resStateResult.futureResState, replayCacheResultFuture);\n\n  using FutureResultType = std::tuple<\n      folly::Try<std::pair<PskType, Optional<ResumptionState>>>,\n      folly::Try<ReplayCacheResult>>;\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(results),\n      [&state,\n       chlo = std::move(chlo),\n       cookieState = std::move(cookieState),\n       version = *version,\n       cipher,\n       pskMode = resStateResult.pskMode,\n       echStatus,\n       echState = std::move(echState),\n       obfuscatedAge =\n           resStateResult.obfuscatedAge](FutureResultType result) mutable {\n        auto& resumption = *std::get<0>(result);\n        auto pskType = resumption.first;\n        auto resState = std::move(resumption.second);\n        auto replayCacheResult = *std::get<1>(result);\n\n        if (resState) {\n          if (!validateResumptionState(*resState, *pskMode, version, cipher)) {\n            pskType = PskType::Rejected;\n            pskMode = folly::none;\n            resState = folly::none;\n          }\n        } else {\n          pskMode = folly::none;\n        }\n\n        auto legacySessionId = chlo.legacy_session_id->clone();\n\n        // If we successfully resumed, set the handshake time to the ticket's\n        // handshake time to preserve it across ticket updates. If not, set it\n        // to now.\n        std::chrono::system_clock::time_point handshakeTime;\n        if (resState) {\n          handshakeTime = resState->handshakeTime;\n        } else {\n          handshakeTime = state.context()->getClock().getCurrentTime();\n        }\n\n        std::unique_ptr<KeyScheduler> scheduler;\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n\n        auto earlyDataType = negotiateEarlyDataType(\n            state.context()->getAcceptEarlyData(version),\n            chlo,\n            resState,\n            cipher,\n            state.keyExchangeType(),\n            cookieState,\n            alpn,\n            replayCacheResult,\n            clockSkew,\n            state.context()->getClockSkewTolerance(),\n            state.appTokenValidator());\n\n        std::unique_ptr<EncryptedReadRecordLayer> earlyReadRecordLayer;\n        Buf earlyExporterMaster;\n        folly::Optional<SecretAvailable> earlyReadSecretAvailable;\n        if (earlyDataType == EarlyDataType::Accepted) {\n          auto earlyContext = handshakeContext->getHandshakeContext();\n          auto earlyReadSecret = scheduler->getSecret(\n              EarlySecrets::ClientEarlyTraffic, earlyContext->coalesce());\n          if (!state.context()->getOmitEarlyRecordLayer()) {\n            earlyReadRecordLayer =\n                state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                    EncryptionLevel::EarlyData);\n            earlyReadRecordLayer->setProtocolVersion(version);\n\n            Protocol::setAead(\n                *earlyReadRecordLayer,\n                cipher,\n                folly::range(earlyReadSecret.secret),\n                *state.context()->getFactory(),\n                *scheduler);\n          }\n\n          earlyReadSecretAvailable =\n              SecretAvailable(std::move(earlyReadSecret));\n          earlyExporterMaster = folly::IOBuf::copyBuffer(\n              scheduler\n                  ->getSecret(\n                      EarlySecrets::EarlyExporter, earlyContext->coalesce())\n                  .secret);\n        }\n\n        Optional<NamedGroup> group;\n        KeyExchangeType keyExchangeType;\n        SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> kexResultFuture =\n            folly::none;\n        std::unique_ptr<KeyExchange> kex = nullptr;\n\n        if (!pskMode || *pskMode != PskKeyExchangeMode::psk_ke) {\n          Optional<Buf> clientShare;\n          std::tie(group, clientShare) = negotiateGroup(\n              version, chlo, state.context()->getSupportedGroups());\n          if (!clientShare) {\n            VLOG(8) << \"Did not find key share for \" << toString(*group);\n            if (state.group().has_value() || cookieState) {\n              throw FizzException(\n                  \"key share not found for already negotiated group\",\n                  AlertDescription::illegal_parameter);\n            }\n\n            // If we were otherwise going to accept early data we now need to\n            // reject it. It's a little ugly to change our previous early data\n            // decision, but doing it this way allows us to move the key\n            // schedule forward as we do the key exchange.\n            if (earlyDataType == EarlyDataType::Accepted) {\n              earlyDataType = EarlyDataType::Rejected;\n            }\n\n            message_hash chloHash;\n            chloHash.hash = handshakeContext->getHandshakeContext();\n            handshakeContext =\n                state.context()->getFactory()->makeHandshakeContext(cipher);\n            handshakeContext->appendToTranscript(\n                encodeHandshake(std::move(chloHash)));\n\n            auto hrr = getHelloRetryRequest(\n                version,\n                cipher,\n                *group,\n                legacySessionId ? legacySessionId->clone() : nullptr,\n                *handshakeContext);\n\n            if (echStatus == ECHStatus::Accepted) {\n              // Set up acceptance scheduler\n              auto echScheduler =\n                  state.context()->getFactory()->makeKeyScheduler(cipher);\n              echScheduler->deriveEarlySecret(folly::range(chlo.random));\n              // Add acceptance extension\n              ech::setAcceptConfirmation(\n                  hrr, handshakeContext->clone(), std::move(echScheduler));\n            }\n\n            auto encodedHelloRetryRequest = encodeHandshake(std::move(hrr));\n            handshakeContext->appendToTranscript(encodedHelloRetryRequest);\n\n            WriteToSocket serverFlight;\n            serverFlight.contents.emplace_back(\n                state.writeRecordLayer()->writeHandshake(\n                    std::move(encodedHelloRetryRequest)));\n\n            if (legacySessionId && !legacySessionId->empty()) {\n              TLSContent writeCCS;\n              writeCCS.encryptionLevel = EncryptionLevel::Plaintext;\n              writeCCS.contentType = ContentType::change_cipher_spec;\n              writeCCS.data = folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n              serverFlight.contents.emplace_back(std::move(writeCCS));\n            }\n\n            // Create a new record layer in case we need to skip early data.\n            auto newReadRecordLayer =\n                state.context()->getFactory()->makePlaintextReadRecordLayer();\n            newReadRecordLayer->setSkipEncryptedRecords(\n                earlyDataType == EarlyDataType::Rejected);\n\n            return SemiFuture<Actions>(actions(\n                MutateState([handshakeContext = std::move(handshakeContext),\n                             version,\n                             cipher,\n                             group,\n                             earlyDataType,\n                             replayCacheResult,\n                             newReadRecordLayer = std::move(newReadRecordLayer),\n                             echStatus,\n                             echState =\n                                 std::move(echState)](State& newState) mutable {\n                  // Save some information about the current state to be\n                  // validated when we get the second client hello. We don't\n                  // validate that the second client hello matches the first\n                  // as strictly as we could according to the spec however.\n                  newState.handshakeContext() = std::move(handshakeContext);\n                  newState.version() = version;\n                  newState.cipher() = cipher;\n                  newState.group() = group;\n                  newState.keyExchangeType() =\n                      KeyExchangeType::HelloRetryRequest;\n                  newState.earlyDataType() = earlyDataType;\n                  newState.replayCacheResult() = replayCacheResult;\n                  newState.readRecordLayer() = std::move(newReadRecordLayer);\n                  newState.echStatus() = echStatus;\n                  if (echStatus == ECHStatus::Accepted) {\n                    newState.echState() = std::move(echState);\n                  }\n                }),\n                std::move(serverFlight),\n                MutateState(&Transition<StateEnum::ExpectingClientHello>)));\n          }\n\n          if (state.keyExchangeType().has_value()) {\n            keyExchangeType = *state.keyExchangeType();\n          } else {\n            keyExchangeType = KeyExchangeType::OneRtt;\n          }\n\n          // The exceptions in SemiFutures will be processed in\n          // detail::processEvent.\n          kex = state.context()->getFactory()->makeKeyExchange(\n              *group, Factory::KeyExchangeMode::Server);\n          kexResultFuture =\n              doKexFuture(kex.get(), std::move(clientShare.value()));\n        } else {\n          keyExchangeType = KeyExchangeType::None;\n        }\n\n        return runOnCallerIfComplete(\n            state.executor(),\n            std::move(kexResultFuture),\n            [&state,\n             scheduler = std::move(scheduler),\n             handshakeContext = std::move(handshakeContext),\n             cipher,\n             group,\n             echStatus,\n             earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n             earlyReadSecretAvailable = std::move(earlyReadSecretAvailable),\n             earlyExporterMaster = std::move(earlyExporterMaster),\n             pskType,\n             pskMode,\n             version,\n             keyExchangeType,\n             earlyDataType,\n             replayCacheResult,\n             alpn = std::move(alpn),\n             clockSkew,\n             appToken = std::move(appToken),\n             legacySessionId = std::move(legacySessionId),\n             handshakeTime,\n             chlo = std::move(chlo),\n             cookieState = std::move(cookieState),\n             resState = std::move(resState),\n             // Hold kex until the doKexFuture finished.\n             kex = std::move(kex)](\n                Optional<AsyncKeyExchange::DoKexResult> kexResult) mutable {\n              Optional<Buf> serverShare;\n              if (kexResult.hasValue()) {\n                serverShare = std::move(kexResult.value().ourKeyShare);\n                scheduler->deriveHandshakeSecret(\n                    kexResult.value().sharedSecret->coalesce());\n              } else {\n                DCHECK(keyExchangeType == KeyExchangeType::None);\n                scheduler->deriveHandshakeSecret();\n              }\n              std::vector<Extension> additionalExtensions;\n              if (state.extensions()) {\n                additionalExtensions = state.extensions()->getExtensions(chlo);\n              }\n\n              if (state.group().has_value() &&\n                  (!group || *group != *state.group())) {\n                throw FizzException(\n                    \"group mismatch with previous negotiation\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              // Cookies are not required to have already negotiated the group\n              // but if they did it must match (psk_ke is still allowed as we\n              // may not know if we are accepting the psk when sending the\n              // cookie).\n              if (cookieState && cookieState->group && group &&\n                  *group != *cookieState->group) {\n                throw FizzException(\n                    \"group mismatch with cookie\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              auto serverHello = getServerHello(\n                  version,\n                  state.context()->getFactory()->makeRandom(),\n                  cipher,\n                  resState.has_value(),\n                  group,\n                  std::move(serverShare),\n                  legacySessionId ? legacySessionId->clone() : nullptr);\n\n              folly::Optional<std::vector<ech::ECHConfig>> echRetryConfigs;\n              if (echStatus == ECHStatus::Accepted) {\n                // Set up acceptance scheduler\n                auto echScheduler =\n                    state.context()->getFactory()->makeKeyScheduler(cipher);\n                echScheduler->deriveEarlySecret(folly::range(chlo.random));\n                // Add acceptance extension\n                ech::setAcceptConfirmation(\n                    serverHello,\n                    handshakeContext->clone(),\n                    std::move(echScheduler));\n              } else if (echStatus == ECHStatus::Rejected) {\n                auto decrypter = state.context()->getECHDecrypter();\n                echRetryConfigs = decrypter->getRetryConfigs();\n              }\n\n              auto encodedServerHello = encodeHandshake(std::move(serverHello));\n              handshakeContext->appendToTranscript(encodedServerHello);\n\n              // Derive handshake keys.\n              auto handshakeWriteRecordLayer =\n                  state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeWriteRecordLayer->setProtocolVersion(version);\n              auto handshakeWriteSecret = scheduler->getSecret(\n                  HandshakeSecrets::ServerHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeWriteRecordLayer,\n                  cipher,\n                  folly::range(handshakeWriteSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n\n              auto handshakeReadRecordLayer =\n                  state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeReadRecordLayer->setProtocolVersion(version);\n              handshakeReadRecordLayer->setSkipFailedDecryption(\n                  earlyDataType == EarlyDataType::Rejected);\n              auto handshakeReadSecret = scheduler->getSecret(\n                  HandshakeSecrets::ClientHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeReadRecordLayer,\n                  cipher,\n                  folly::range(handshakeReadSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n              auto clientHandshakeSecret =\n                  folly::IOBuf::copyBuffer(handshakeReadSecret.secret);\n\n              auto encodedEncryptedExt = getEncryptedExt(\n                  *handshakeContext,\n                  alpn,\n                  earlyDataType,\n                  std::move(echRetryConfigs),\n                  std::move(additionalExtensions));\n\n              /*\n               * Determine we are requesting client auth.\n               * If yes, add CertificateRequest to handshake write and\n               * transcript.\n               */\n              bool requestClientAuth = state.context()->getClientAuthMode() !=\n                      ClientAuthMode::None &&\n                  !resState;\n              Optional<Buf> encodedCertRequest;\n              if (requestClientAuth) {\n                encodedCertRequest = getCertificateRequest(\n                    state.context()->getSupportedSigSchemes(),\n                    state.context()->getClientCertVerifier().get(),\n                    *handshakeContext);\n              }\n\n              /*\n               * Set the cert and signature scheme we are using.\n               * If sending new cert, add Certificate to handshake write and\n               * transcript.\n               */\n              Optional<Buf> encodedCertificate;\n              SemiFuture<Optional<Buf>> signature = folly::none;\n              Optional<SignatureScheme> sigScheme;\n              Optional<std::shared_ptr<const Cert>> serverCert;\n              std::shared_ptr<const Cert> clientCert;\n              Optional<CertificateCompressionAlgorithm> certCompressionAlgo;\n              if (!resState) { // TODO or reauth\n                std::shared_ptr<const SelfCert> originalSelfCert;\n                std::tie(originalSelfCert, sigScheme) =\n                    chooseCert(*state.context(), chlo);\n\n                std::tie(encodedCertificate, certCompressionAlgo) =\n                    getCertificate(\n                        originalSelfCert,\n                        *state.context(),\n                        chlo,\n                        *handshakeContext);\n\n                auto toBeSigned = handshakeContext->getHandshakeContext();\n                auto asyncSelfCert =\n                    dynamic_cast<const AsyncSelfCert*>(originalSelfCert.get());\n                if (asyncSelfCert) {\n                  signature = asyncSelfCert->signFuture(\n                      *sigScheme,\n                      CertificateVerifyContext::Server,\n                      std::move(toBeSigned));\n                } else {\n                  signature = folly::makeSemiFuture<Optional<Buf>>(\n                      originalSelfCert->sign(\n                          *sigScheme,\n                          CertificateVerifyContext::Server,\n                          toBeSigned->coalesce()));\n                }\n                serverCert = std::move(originalSelfCert);\n              } else {\n                serverCert = std::move(resState->serverCert);\n                clientCert = std::move(resState->clientCert);\n              }\n\n              auto clientRandom = std::move(chlo.random);\n\n              return runOnCallerIfComplete(\n                  state.executor(),\n                  std::move(signature),\n                  [&state,\n                   scheduler = std::move(scheduler),\n                   handshakeContext = std::move(handshakeContext),\n                   cipher,\n                   clientRandom = std::move(clientRandom),\n                   group,\n                   echStatus,\n                   encodedServerHello = std::move(encodedServerHello),\n                   handshakeWriteRecordLayer =\n                       std::move(handshakeWriteRecordLayer),\n                   handshakeWriteSecret = std::move(handshakeWriteSecret),\n                   handshakeReadRecordLayer =\n                       std::move(handshakeReadRecordLayer),\n                   handshakeReadSecret = std::move(handshakeReadSecret),\n                   earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n                   earlyReadSecretAvailable =\n                       std::move(earlyReadSecretAvailable),\n                   earlyExporterMaster = std::move(earlyExporterMaster),\n                   clientHandshakeSecret = std::move(clientHandshakeSecret),\n                   encodedEncryptedExt = std::move(encodedEncryptedExt),\n                   encodedCertificate = std::move(encodedCertificate),\n                   encodedCertRequest = std::move(encodedCertRequest),\n                   requestClientAuth,\n                   pskType,\n                   pskMode,\n                   sigScheme,\n                   version,\n                   keyExchangeType,\n                   earlyDataType,\n                   replayCacheResult,\n                   serverCert = std::move(serverCert),\n                   clientCert = std::move(clientCert),\n                   alpn = std::move(alpn),\n                   clockSkew,\n                   appToken = std::move(appToken),\n                   legacySessionId = std::move(legacySessionId),\n                   serverCertCompAlgo = certCompressionAlgo,\n                   handshakeTime](Optional<Buf> sig) mutable {\n                    Optional<Buf> encodedCertificateVerify;\n                    if (sig) {\n                      encodedCertificateVerify = getCertificateVerify(\n                          *sigScheme, std::move(*sig), *handshakeContext);\n                    }\n\n                    auto encodedFinished = Protocol::getFinished(\n                        folly::range(handshakeWriteSecret.secret),\n                        *handshakeContext);\n\n                    folly::IOBufQueue combined;\n                    if (encodedCertificate) {\n                      if (encodedCertRequest) {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertRequest));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      } else {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      }\n                    } else {\n                      combined.append(std::move(encodedEncryptedExt));\n                      combined.append(std::move(encodedFinished));\n                    }\n\n                    // Some middleboxes appear to break if the first encrypted\n                    // record is larger than ~1300 bytes (likely if it does not\n                    // fit in the first packet).\n                    auto serverEncrypted =\n                        handshakeWriteRecordLayer->writeHandshake(\n                            combined.splitAtMost(1000));\n                    if (!combined.empty()) {\n                      auto splitRecord =\n                          handshakeWriteRecordLayer->writeHandshake(\n                              combined.move());\n                      // Split record must have the same encryption level as the\n                      // main handshake.\n                      DCHECK(\n                          splitRecord.encryptionLevel ==\n                          serverEncrypted.encryptionLevel);\n                      serverEncrypted.data->prependChain(\n                          std::move(splitRecord.data));\n                    }\n\n                    WriteToSocket serverFlight;\n                    serverFlight.contents.emplace_back(\n                        state.writeRecordLayer()->writeHandshake(\n                            std::move(encodedServerHello)));\n                    if (legacySessionId && !legacySessionId->empty()) {\n                      TLSContent ccsWrite;\n                      ccsWrite.encryptionLevel = EncryptionLevel::Plaintext;\n                      ccsWrite.contentType = ContentType::change_cipher_spec;\n                      ccsWrite.data =\n                          folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n                      serverFlight.contents.emplace_back(std::move(ccsWrite));\n                    }\n                    serverFlight.contents.emplace_back(\n                        std::move(serverEncrypted));\n\n                    scheduler->deriveMasterSecret();\n                    auto clientFinishedContext =\n                        handshakeContext->getHandshakeContext();\n                    auto exporterMasterVector = scheduler->getSecret(\n                        MasterSecrets::ExporterMaster,\n                        clientFinishedContext->coalesce());\n                    auto exporterMaster = folly::IOBuf::copyBuffer(\n                        folly::range(exporterMasterVector.secret));\n\n                    scheduler->deriveAppTrafficSecrets(\n                        clientFinishedContext->coalesce());\n                    auto appTrafficWriteRecordLayer =\n                        state.context()\n                            ->getFactory()\n                            ->makeEncryptedWriteRecordLayer(\n                                EncryptionLevel::AppTraffic);\n                    appTrafficWriteRecordLayer->setProtocolVersion(version);\n                    auto writeSecret = scheduler->getSecret(\n                        AppTrafficSecrets::ServerAppTraffic);\n                    Protocol::setAead(\n                        *appTrafficWriteRecordLayer,\n                        cipher,\n                        folly::range(writeSecret.secret),\n                        *state.context()->getFactory(),\n                        *scheduler);\n\n                    // If we have previously dealt with early data (before a\n                    // HelloRetryRequest), don't overwrite the previous result.\n                    auto earlyDataTypeSave = state.earlyDataType()\n                        ? *state.earlyDataType()\n                        : earlyDataType;\n\n                    SecretAvailable handshakeReadSecretAvailable(\n                        std::move(handshakeReadSecret));\n                    SecretAvailable handshakeWriteSecretAvailable(\n                        std::move(handshakeWriteSecret));\n                    SecretAvailable appWriteSecretAvailable(\n                        std::move(writeSecret));\n\n                    // Save all the necessary state except for the read record\n                    // layer, which is done separately as it varies if early\n                    // data was accepted.\n                    MutateState saveState(\n                        [appTrafficWriteRecordLayer =\n                             std::move(appTrafficWriteRecordLayer),\n                         handshakeContext = std::move(handshakeContext),\n                         scheduler = std::move(scheduler),\n                         exporterMaster = std::move(exporterMaster),\n                         serverCert = std::move(serverCert),\n                         clientCert = std::move(clientCert),\n                         cipher,\n                         group,\n                         sigScheme,\n                         clientHandshakeSecret =\n                             std::move(clientHandshakeSecret),\n                         pskType,\n                         pskMode,\n                         version,\n                         keyExchangeType,\n                         alpn = std::move(alpn),\n                         earlyDataTypeSave,\n                         replayCacheResult,\n                         clockSkew,\n                         appToken = std::move(appToken),\n                         serverCertCompAlgo,\n                         echStatus,\n                         clientRandom = std::move(clientRandom),\n                         handshakeTime = std::move(handshakeTime)](\n                            State& newState) mutable {\n                          newState.writeRecordLayer() =\n                              std::move(appTrafficWriteRecordLayer);\n                          newState.handshakeContext() =\n                              std::move(handshakeContext);\n                          newState.keyScheduler() = std::move(scheduler);\n                          newState.exporterMasterSecret() =\n                              std::move(exporterMaster);\n                          newState.serverCert() = std::move(*serverCert);\n                          newState.clientCert() = std::move(clientCert);\n                          newState.version() = version;\n                          newState.cipher() = cipher;\n                          newState.group() = group;\n                          newState.sigScheme() = sigScheme;\n                          newState.clientHandshakeSecret() =\n                              std::move(clientHandshakeSecret);\n                          newState.pskType() = pskType;\n                          newState.pskMode() = pskMode;\n                          newState.keyExchangeType() = keyExchangeType;\n                          newState.earlyDataType() = earlyDataTypeSave;\n                          newState.replayCacheResult() = replayCacheResult;\n                          newState.alpn() = std::move(alpn);\n                          newState.clientClockSkew() = clockSkew;\n                          newState.appToken() = std::move(appToken);\n                          newState.serverCertCompAlgo() = serverCertCompAlgo;\n                          newState.handshakeTime() = std::move(handshakeTime);\n                          newState.clientRandom() = std::move(clientRandom);\n                          newState.echStatus() = echStatus;\n                          newState.echState() = folly::none;\n                        });\n\n                    if (earlyDataType == EarlyDataType::Accepted) {\n                      if (state.context()->getOmitEarlyRecordLayer()) {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::ExpectingFinished>),\n                            ReportEarlyHandshakeSuccess());\n\n                      } else {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyReadRecordLayer =\n                                             std::move(earlyReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(earlyReadRecordLayer);\n                              newState.handshakeReadRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::AcceptingEarlyData>),\n                            ReportEarlyHandshakeSuccess());\n                      }\n                    } else {\n                      auto transition = requestClientAuth\n                          ? Transition<StateEnum::ExpectingCertificate>\n                          : Transition<StateEnum::ExpectingFinished>;\n                      return actions(\n                          MutateState([handshakeReadRecordLayer =\n                                           std::move(handshakeReadRecordLayer)](\n                                          State& newState) mutable {\n                            newState.readRecordLayer() =\n                                std::move(handshakeReadRecordLayer);\n                          }),\n                          std::move(saveState),\n                          std::move(handshakeReadSecretAvailable),\n                          std::move(handshakeWriteSecretAvailable),\n                          std::move(appWriteSecretAvailable),\n                          std::move(serverFlight),\n                          MutateState(transition));\n                    }\n                  });\n            });\n      });\n}",
  "abstract_func": "AsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingClientHello, Event::ClientHello>::\n    handle(const State& VAR_0, Param VAR_1) {\n  ClientHello VAR_2 = std::move(*VAR_1.asClientHello());\n\n  auto VAR_3 = getCookieState(VAR_2, VAR_0.context()->getCookieCipher());\n\n  if (VAR_0.handshakeContext() && VAR_3.has_value()) {\n    throw FizzException(\n        \"cookie after statefull hrr\", AlertDescription::illegal_parameter);\n  }\n\n  ECHStatus VAR_4;\n  ECHState VAR_5;\n  std::tie(VAR_4, VAR_5) = processECH(VAR_3, VAR_0, VAR_2);\n\n  addHandshakeLogging(VAR_0, VAR_2);\n\n  if (VAR_0.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after client hello\", AlertDescription::unexpected_message);\n  }\n\n  auto VAR_6 =\n      negotiateVersion(VAR_2, VAR_0.context()->getSupportedVersions());\n\n  if (VAR_0.version().has_value() &&\n      (!VAR_6 || *VAR_6 != *VAR_0.version())) {\n    throw FizzException(\n        \"version mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  if (!VAR_6) {\n    if (VAR_7<ClientEarlyData>(VAR_2.extensions)) {\n      throw FizzException(\n          \"supported version mismatch with early data\",\n          AlertDescription::protocol_version);\n    }\n    if (VAR_0.context()->getVersionFallbackEnabled()) {\n      AttemptVersionFallback VAR_8;\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      VAR_8.clientHello =\n          PlaintextWriteRecordLayer()\n              .writeInitialClientHello(std::move(*VAR_2.originalEncoding))\n              .data;\n      return actions(\n          MutateState(&VAR_9<StateEnum::Error>), std::move(VAR_8));\n    } else {\n      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  VAR_0.writeRecordLayer()->setProtocolVersion(*VAR_6);\n\n  validateClientHello(VAR_2);\n\n  auto VAR_10 = negotiateCipher(VAR_2, VAR_0.context()->getSupportedCiphers());\n\n  if (VAR_0.cipher().has_value() && VAR_10 != *VAR_0.cipher()) {\n    throw FizzException(\n        \"cipher mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  verifyCookieState(VAR_3, *VAR_6, VAR_10);\n\n  auto VAR_11 = getResumptionState(\n      VAR_2,\n      VAR_0.context()->getTicketCipher(),\n      VAR_0.context()->getSupportedPskModes());\n\n  auto VAR_12 = getReplayCacheResult(\n      VAR_2,\n      VAR_0.context()->getAcceptEarlyData(*VAR_6),\n      VAR_0.context()->getReplayCache());\n\n  auto VAR_13 =\n      collectAll(VAR_11.futureResState, VAR_12);\n\n  using FutureResultType = std::tuple<\n      folly::Try<std::pair<VAR_14, Optional<ResumptionState>>>,\n      folly::Try<ReplayCacheResult>>;\n  return runOnCallerIfComplete(\n      VAR_0.executor(),\n      std::move(VAR_13),\n      [&VAR_0,\n       VAR_2 = std::move(VAR_2),\n       VAR_3 = std::move(VAR_3),\n       VAR_6 = *VAR_6,\n       VAR_10,\n       VAR_15 = VAR_11.pskMode,\n       VAR_4,\n       VAR_5 = std::move(VAR_5),\n       VAR_16 =\n           VAR_11.obfuscatedAge](FutureResultType VAR_17) mutable {\n        auto& VAR_18 = *std::VAR_19<0>(VAR_17);\n        auto VAR_20 = VAR_18.first;\n        auto VAR_21 = std::move(VAR_18.second);\n        auto VAR_22 = *std::VAR_19<1>(VAR_17);\n\n        if (VAR_21) {\n          if (!validateResumptionState(*VAR_21, *VAR_15, VAR_6, VAR_10)) {\n            VAR_20 = PskType::Rejected;\n            VAR_15 = folly::none;\n            VAR_21 = folly::none;\n          }\n        } else {\n          VAR_15 = folly::none;\n        }\n\n        auto VAR_23 = VAR_2.legacy_session_id->clone();\n\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        std::chrono::system_clock::time_point VAR_24;\n        if (VAR_21) {\n          VAR_24 = VAR_21->handshakeTime;\n        } else {\n          VAR_24 = VAR_0.context()->getClock().getCurrentTime();\n        }\n\n        std::unique_ptr<KeyScheduler> VAR_25;\n        std::unique_ptr<HandshakeContext> VAR_26;\n        std::tie(VAR_25, VAR_26) = setupSchedulerAndContext(\n            *VAR_0.context()->getFactory(),\n            VAR_10,\n            VAR_2,\n            VAR_21,\n            VAR_3,\n            VAR_20,\n            std::move(VAR_0.handshakeContext()),\n            VAR_6);\n\n        auto VAR_27 = negotiateAlpn(VAR_2, folly::none, *VAR_0.context());\n\n        auto VAR_28 = getClockSkew(\n            VAR_21,\n            VAR_16,\n            VAR_0.context()->getClock().getCurrentTime());\n\n        auto VAR_29 = getAppToken(VAR_21);\n\n        auto VAR_30 = negotiateEarlyDataType(\n            VAR_0.context()->getAcceptEarlyData(VAR_6),\n            VAR_2,\n            VAR_21,\n            VAR_10,\n            VAR_0.keyExchangeType(),\n            VAR_3,\n            VAR_27,\n            VAR_22,\n            VAR_28,\n            VAR_0.context()->getClockSkewTolerance(),\n            VAR_0.appTokenValidator());\n\n        std::unique_ptr<EncryptedReadRecordLayer> VAR_31;\n        Buf VAR_32;\n        folly::Optional<SecretAvailable> VAR_33;\n        if (VAR_30 == EarlyDataType::Accepted) {\n          auto VAR_34 = VAR_26->getHandshakeContext();\n          auto VAR_35 = VAR_25->getSecret(\n              EarlySecrets::ClientEarlyTraffic, VAR_34->coalesce());\n          if (!VAR_0.context()->getOmitEarlyRecordLayer()) {\n            VAR_31 =\n                VAR_0.context()->getFactory()->makeEncryptedReadRecordLayer(\n                    EncryptionLevel::EarlyData);\n            VAR_31->setProtocolVersion(VAR_6);\n\n            Protocol::setAead(\n                *VAR_31,\n                VAR_10,\n                folly::range(VAR_35.secret),\n                *VAR_0.context()->getFactory(),\n                *VAR_25);\n          }\n\n          VAR_33 =\n              SecretAvailable(std::move(VAR_35));\n          VAR_32 = folly::IOBuf::copyBuffer(\n              VAR_25\n                  ->getSecret(\n                      EarlySecrets::EarlyExporter, VAR_34->coalesce())\n                  .secret);\n        }\n\n        Optional<NamedGroup> VAR_36;\n        KeyExchangeType VAR_37;\n        SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> VAR_38 =\n            folly::none;\n        std::unique_ptr<KeyExchange> VAR_39 = nullptr;\n\n        if (!VAR_15 || *VAR_15 != PskKeyExchangeMode::psk_ke) {\n          Optional<Buf> VAR_40;\n          std::tie(VAR_36, VAR_40) = negotiateGroup(\n              VAR_6, VAR_2, VAR_0.context()->getSupportedGroups());\n          if (!VAR_40) {\n            VLOG(8) << \"Did not find key share for \" << toString(*VAR_36);\n            if (VAR_0.group().has_value() || VAR_3) {\n              throw FizzException(\n                  \"key share not found for already negotiated group\",\n                  AlertDescription::illegal_parameter);\n            }\n\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            if (VAR_30 == EarlyDataType::Accepted) {\n              VAR_30 = EarlyDataType::Rejected;\n            }\n\n            message_hash VAR_41;\n            VAR_41.hash = VAR_26->getHandshakeContext();\n            VAR_26 =\n                VAR_0.context()->getFactory()->makeHandshakeContext(VAR_10);\n            VAR_26->appendToTranscript(\n                encodeHandshake(std::move(VAR_41)));\n\n            auto VAR_42 = getHelloRetryRequest(\n                VAR_6,\n                VAR_10,\n                *VAR_36,\n                VAR_23 ? VAR_23->clone() : nullptr,\n                *VAR_26);\n\n            if (VAR_4 == ECHStatus::Accepted) {\n              /* COMMENT_10 */\n              auto VAR_43 =\n                  VAR_0.context()->getFactory()->makeKeyScheduler(VAR_10);\n              VAR_43->deriveEarlySecret(folly::range(VAR_2.random));\n              /* COMMENT_11 */\n              ech::setAcceptConfirmation(\n                  VAR_42, VAR_26->clone(), std::move(VAR_43));\n            }\n\n            auto VAR_44 = encodeHandshake(std::move(VAR_42));\n            VAR_26->appendToTranscript(VAR_44);\n\n            WriteToSocket VAR_45;\n            VAR_45.contents.emplace_back(\n                VAR_0.writeRecordLayer()->writeHandshake(\n                    std::move(VAR_44)));\n\n            if (VAR_23 && !VAR_23->empty()) {\n              TLSContent VAR_46;\n              VAR_46.encryptionLevel = EncryptionLevel::Plaintext;\n              VAR_46.contentType = ContentType::change_cipher_spec;\n              VAR_46.data = folly::IOBuf::wrapBuffer(VAR_47);\n              VAR_45.contents.emplace_back(std::move(VAR_46));\n            }\n\n            /* COMMENT_12 */\n            auto VAR_48 =\n                VAR_0.context()->getFactory()->makePlaintextReadRecordLayer();\n            VAR_48->setSkipEncryptedRecords(\n                VAR_30 == EarlyDataType::Rejected);\n\n            return SemiFuture<Actions>(actions(\n                MutateState([VAR_26 = std::move(VAR_26),\n                             VAR_6,\n                             VAR_10,\n                             VAR_36,\n                             VAR_30,\n                             VAR_22,\n                             VAR_48 = std::move(VAR_48),\n                             VAR_4,\n                             VAR_5 =\n                                 std::move(VAR_5)](State& VAR_49) mutable {\n                  /* COMMENT_13 */\n                  /* COMMENT_14 */\n                  /* COMMENT_15 */\n                  /* COMMENT_16 */\n                  VAR_49.handshakeContext() = std::move(VAR_26);\n                  VAR_49.version() = VAR_6;\n                  VAR_49.cipher() = VAR_10;\n                  VAR_49.group() = VAR_36;\n                  VAR_49.keyExchangeType() =\n                      KeyExchangeType::HelloRetryRequest;\n                  VAR_49.earlyDataType() = VAR_30;\n                  VAR_49.replayCacheResult() = VAR_22;\n                  VAR_49.readRecordLayer() = std::move(VAR_48);\n                  VAR_49.echStatus() = VAR_4;\n                  if (VAR_4 == ECHStatus::Accepted) {\n                    VAR_49.echState() = std::move(VAR_5);\n                  }\n                }),\n                std::move(VAR_45),\n                MutateState(&VAR_9<StateEnum::ExpectingClientHello>)));\n          }\n\n          if (VAR_0.keyExchangeType().has_value()) {\n            VAR_37 = *VAR_0.keyExchangeType();\n          } else {\n            VAR_37 = KeyExchangeType::OneRtt;\n          }\n\n          /* COMMENT_17 */\n          /* COMMENT_18 */\n          VAR_39 = VAR_0.context()->getFactory()->makeKeyExchange(\n              *VAR_36, Factory::KeyExchangeMode::Server);\n          VAR_38 =\n              doKexFuture(VAR_39.get(), std::move(VAR_40.value()));\n        } else {\n          VAR_37 = KeyExchangeType::None;\n        }\n\n        return runOnCallerIfComplete(\n            VAR_0.executor(),\n            std::move(VAR_38),\n            [&VAR_0,\n             VAR_25 = std::move(VAR_25),\n             VAR_26 = std::move(VAR_26),\n             VAR_10,\n             VAR_36,\n             VAR_4,\n             VAR_31 = std::move(VAR_31),\n             VAR_33 = std::move(VAR_33),\n             VAR_32 = std::move(VAR_32),\n             VAR_20,\n             VAR_15,\n             VAR_6,\n             VAR_37,\n             VAR_30,\n             VAR_22,\n             VAR_27 = std::move(VAR_27),\n             VAR_28,\n             VAR_29 = std::move(VAR_29),\n             VAR_23 = std::move(VAR_23),\n             VAR_24,\n             VAR_2 = std::move(VAR_2),\n             VAR_3 = std::move(VAR_3),\n             VAR_21 = std::move(VAR_21),\n             /* COMMENT_19 */\n             VAR_39 = std::move(VAR_39)](\n                Optional<AsyncKeyExchange::DoKexResult> VAR_50) mutable {\n              Optional<Buf> VAR_51;\n              if (VAR_50.hasValue()) {\n                VAR_51 = std::move(VAR_50.value().ourKeyShare);\n                VAR_25->deriveHandshakeSecret(\n                    VAR_50.value().sharedSecret->coalesce());\n              } else {\n                DCHECK(VAR_37 == KeyExchangeType::None);\n                VAR_25->deriveHandshakeSecret();\n              }\n              std::vector<Extension> VAR_52;\n              if (VAR_0.extensions()) {\n                VAR_52 = VAR_0.extensions()->getExtensions(VAR_2);\n              }\n\n              if (VAR_0.group().has_value() &&\n                  (!VAR_36 || *VAR_36 != *VAR_0.group())) {\n                throw FizzException(\n                    \"group mismatch with previous negotiation\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              /* COMMENT_20 */\n              /* COMMENT_21 */\n              /* COMMENT_22 */\n              /* COMMENT_23 */\n              if (VAR_3 && VAR_3->group && VAR_36 &&\n                  *VAR_36 != *VAR_3->group) {\n                throw FizzException(\n                    \"group mismatch with cookie\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              auto VAR_53 = getServerHello(\n                  VAR_6,\n                  VAR_0.context()->getFactory()->makeRandom(),\n                  VAR_10,\n                  VAR_21.has_value(),\n                  VAR_36,\n                  std::move(VAR_51),\n                  VAR_23 ? VAR_23->clone() : nullptr);\n\n              folly::Optional<std::vector<ech::ECHConfig>> VAR_54;\n              if (VAR_4 == ECHStatus::Accepted) {\n                /* COMMENT_10 */\n                auto VAR_43 =\n                    VAR_0.context()->getFactory()->makeKeyScheduler(VAR_10);\n                VAR_43->deriveEarlySecret(folly::range(VAR_2.random));\n                /* COMMENT_11 */\n                ech::setAcceptConfirmation(\n                    VAR_53,\n                    VAR_26->clone(),\n                    std::move(VAR_43));\n              } else if (VAR_4 == ECHStatus::Rejected) {\n                auto VAR_55 = VAR_0.context()->getECHDecrypter();\n                VAR_54 = VAR_55->getRetryConfigs();\n              }\n\n              auto VAR_56 = encodeHandshake(std::move(VAR_53));\n              VAR_26->appendToTranscript(VAR_56);\n\n              /* COMMENT_24 */\n              auto VAR_57 =\n                  VAR_0.context()->getFactory()->makeEncryptedWriteRecordLayer(\n                      EncryptionLevel::Handshake);\n              VAR_57->setProtocolVersion(VAR_6);\n              auto VAR_58 = VAR_25->getSecret(\n                  HandshakeSecrets::ServerHandshakeTraffic,\n                  VAR_26->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *VAR_57,\n                  VAR_10,\n                  folly::range(VAR_58.secret),\n                  *VAR_0.context()->getFactory(),\n                  *VAR_25);\n\n              auto VAR_59 =\n                  VAR_0.context()->getFactory()->makeEncryptedReadRecordLayer(\n                      EncryptionLevel::Handshake);\n              VAR_59->setProtocolVersion(VAR_6);\n              VAR_59->setSkipFailedDecryption(\n                  VAR_30 == EarlyDataType::Rejected);\n              auto VAR_60 = VAR_25->getSecret(\n                  HandshakeSecrets::ClientHandshakeTraffic,\n                  VAR_26->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *VAR_59,\n                  VAR_10,\n                  folly::range(VAR_60.secret),\n                  *VAR_0.context()->getFactory(),\n                  *VAR_25);\n              auto VAR_61 =\n                  folly::IOBuf::copyBuffer(VAR_60.secret);\n\n              auto VAR_62 = getEncryptedExt(\n                  *VAR_26,\n                  VAR_27,\n                  VAR_30,\n                  std::move(VAR_54),\n                  std::move(VAR_52));\n\n              /* COMMENT_25 */\n                                                         \n                                                                      \n                            \n                 \n              bool VAR_63 = VAR_0.context()->getClientAuthMode() !=\n                      ClientAuthMode::None &&\n                  !VAR_21;\n              Optional<Buf> VAR_64;\n              if (VAR_63) {\n                VAR_64 = getCertificateRequest(\n                    VAR_0.context()->getSupportedSigSchemes(),\n                    VAR_0.context()->getClientCertVerifier().get(),\n                    *VAR_26);\n              }\n\n              /* COMMENT_30 */\n                                                                \n                                                                            \n                            \n                 \n              Optional<Buf> VAR_65;\n              SemiFuture<Optional<Buf>> VAR_66 = folly::none;\n              Optional<SignatureScheme> VAR_67;\n              Optional<std::shared_ptr<const Cert>> VAR_68;\n              std::shared_ptr<const Cert> VAR_69;\n              Optional<CertificateCompressionAlgorithm> VAR_70;\n              if (!VAR_21) { /* COMMENT_35 */\n                std::shared_ptr<const SelfCert> VAR_71;\n                std::tie(VAR_71, VAR_67) =\n                    chooseCert(*VAR_0.context(), VAR_2);\n\n                std::tie(VAR_65, VAR_70) =\n                    getCertificate(\n                        VAR_71,\n                        *VAR_0.context(),\n                        VAR_2,\n                        *VAR_26);\n\n                auto VAR_72 = VAR_26->getHandshakeContext();\n                auto VAR_73 =\n                    VAR_74<const AsyncSelfCert*>(VAR_71.get());\n                if (VAR_73) {\n                  VAR_66 = VAR_73->signFuture(\n                      *VAR_67,\n                      CertificateVerifyContext::Server,\n                      std::move(VAR_72));\n                } else {\n                  VAR_66 = folly::VAR_75<Optional<Buf>>(\n                      VAR_71->sign(\n                          *VAR_67,\n                          CertificateVerifyContext::Server,\n                          VAR_72->coalesce()));\n                }\n                VAR_68 = std::move(VAR_71);\n              } else {\n                VAR_68 = std::move(VAR_21->serverCert);\n                VAR_69 = std::move(VAR_21->clientCert);\n              }\n\n              auto VAR_76 = std::move(VAR_2.random);\n\n              return runOnCallerIfComplete(\n                  VAR_0.executor(),\n                  std::move(VAR_66),\n                  [&VAR_0,\n                   VAR_25 = std::move(VAR_25),\n                   VAR_26 = std::move(VAR_26),\n                   VAR_10,\n                   VAR_76 = std::move(VAR_76),\n                   VAR_36,\n                   VAR_4,\n                   VAR_56 = std::move(VAR_56),\n                   VAR_57 =\n                       std::move(VAR_57),\n                   VAR_58 = std::move(VAR_58),\n                   VAR_59 =\n                       std::move(VAR_59),\n                   VAR_60 = std::move(VAR_60),\n                   VAR_31 = std::move(VAR_31),\n                   VAR_33 =\n                       std::move(VAR_33),\n                   VAR_32 = std::move(VAR_32),\n                   VAR_61 = std::move(VAR_61),\n                   VAR_62 = std::move(VAR_62),\n                   VAR_65 = std::move(VAR_65),\n                   VAR_64 = std::move(VAR_64),\n                   VAR_63,\n                   VAR_20,\n                   VAR_15,\n                   VAR_67,\n                   VAR_6,\n                   VAR_37,\n                   VAR_30,\n                   VAR_22,\n                   VAR_68 = std::move(VAR_68),\n                   VAR_69 = std::move(VAR_69),\n                   VAR_27 = std::move(VAR_27),\n                   VAR_28,\n                   VAR_29 = std::move(VAR_29),\n                   VAR_23 = std::move(VAR_23),\n                   VAR_77 = VAR_70,\n                   VAR_24](Optional<Buf> VAR_78) mutable {\n                    Optional<Buf> VAR_79;\n                    if (VAR_78) {\n                      VAR_79 = getCertificateVerify(\n                          *VAR_67, std::move(*VAR_78), *VAR_26);\n                    }\n\n                    auto VAR_80 = Protocol::getFinished(\n                        folly::range(VAR_58.secret),\n                        *VAR_26);\n\n                    folly::IOBufQueue VAR_81;\n                    if (VAR_65) {\n                      if (VAR_64) {\n                        VAR_81.append(std::move(VAR_62));\n                        VAR_81.append(std::move(*VAR_64));\n                        VAR_81.append(std::move(*VAR_65));\n                        VAR_81.append(std::move(*VAR_79));\n                        VAR_81.append(std::move(VAR_80));\n                      } else {\n                        VAR_81.append(std::move(VAR_62));\n                        VAR_81.append(std::move(*VAR_65));\n                        VAR_81.append(std::move(*VAR_79));\n                        VAR_81.append(std::move(VAR_80));\n                      }\n                    } else {\n                      VAR_81.append(std::move(VAR_62));\n                      VAR_81.append(std::move(VAR_80));\n                    }\n\n                    /* COMMENT_36 */\n                    /* COMMENT_37 */\n                    /* COMMENT_38 */\n                    auto VAR_82 =\n                        VAR_57->writeHandshake(\n                            VAR_81.splitAtMost(1000));\n                    if (!VAR_81.empty()) {\n                      auto VAR_83 =\n                          VAR_57->writeHandshake(\n                              VAR_81.move());\n                      /* COMMENT_39 */\n                      /* COMMENT_40 */\n                      DCHECK(\n                          VAR_83.encryptionLevel ==\n                          VAR_82.encryptionLevel);\n                      VAR_82.data->prependChain(\n                          std::move(VAR_83.data));\n                    }\n\n                    WriteToSocket VAR_45;\n                    VAR_45.contents.emplace_back(\n                        VAR_0.writeRecordLayer()->writeHandshake(\n                            std::move(VAR_56)));\n                    if (VAR_23 && !VAR_23->empty()) {\n                      TLSContent VAR_84;\n                      VAR_84.encryptionLevel = EncryptionLevel::Plaintext;\n                      VAR_84.contentType = ContentType::change_cipher_spec;\n                      VAR_84.data =\n                          folly::IOBuf::wrapBuffer(VAR_47);\n                      VAR_45.contents.emplace_back(std::move(VAR_84));\n                    }\n                    VAR_45.contents.emplace_back(\n                        std::move(VAR_82));\n\n                    VAR_25->deriveMasterSecret();\n                    auto VAR_85 =\n                        VAR_26->getHandshakeContext();\n                    auto VAR_86 = VAR_25->getSecret(\n                        MasterSecrets::ExporterMaster,\n                        VAR_85->coalesce());\n                    auto VAR_87 = folly::IOBuf::copyBuffer(\n                        folly::range(VAR_86.secret));\n\n                    VAR_25->deriveAppTrafficSecrets(\n                        VAR_85->coalesce());\n                    auto VAR_88 =\n                        VAR_0.context()\n                            ->getFactory()\n                            ->makeEncryptedWriteRecordLayer(\n                                EncryptionLevel::AppTraffic);\n                    VAR_88->setProtocolVersion(VAR_6);\n                    auto VAR_89 = VAR_25->getSecret(\n                        AppTrafficSecrets::ServerAppTraffic);\n                    Protocol::setAead(\n                        *VAR_88,\n                        VAR_10,\n                        folly::range(VAR_89.secret),\n                        *VAR_0.context()->getFactory(),\n                        *VAR_25);\n\n                    /* COMMENT_41 */\n                    /* COMMENT_42 */\n                    auto VAR_90 = VAR_0.earlyDataType()\n                        ? *VAR_0.earlyDataType()\n                        : VAR_30;\n\n                    SecretAvailable handshakeReadSecretAvailable(\n                        std::move(handshakeReadSecret));\n                    SecretAvailable handshakeWriteSecretAvailable(\n                        std::move(handshakeWriteSecret));\n                    SecretAvailable appWriteSecretAvailable(\n                        std::move(writeSecret));\n\n                    /* COMMENT_43 */\n                    /* COMMENT_44 */\n                    /* COMMENT_45 */\n                    MutateState VAR_91(\n                        [VAR_88 =\n                             std::move(VAR_88),\n                         VAR_26 = std::move(VAR_26),\n                         VAR_25 = std::move(VAR_25),\n                         VAR_87 = std::move(VAR_87),\n                         VAR_68 = std::move(VAR_68),\n                         VAR_69 = std::move(VAR_69),\n                         VAR_10,\n                         VAR_36,\n                         VAR_67,\n                         VAR_61 =\n                             std::move(VAR_61),\n                         VAR_20,\n                         VAR_15,\n                         VAR_6,\n                         VAR_37,\n                         VAR_27 = std::move(VAR_27),\n                         VAR_90,\n                         VAR_22,\n                         VAR_28,\n                         VAR_29 = std::move(VAR_29),\n                         VAR_77,\n                         VAR_4,\n                         VAR_76 = std::move(VAR_76),\n                         VAR_24 = std::move(VAR_24)](\n                            State& VAR_49) mutable {\n                          VAR_49.writeRecordLayer() =\n                              std::move(VAR_88);\n                          VAR_49.handshakeContext() =\n                              std::move(VAR_26);\n                          VAR_49.keyScheduler() = std::move(VAR_25);\n                          VAR_49.exporterMasterSecret() =\n                              std::move(VAR_87);\n                          VAR_49.serverCert() = std::move(*VAR_68);\n                          VAR_49.clientCert() = std::move(VAR_69);\n                          VAR_49.version() = VAR_6;\n                          VAR_49.cipher() = VAR_10;\n                          VAR_49.group() = VAR_36;\n                          VAR_49.sigScheme() = VAR_67;\n                          VAR_49.clientHandshakeSecret() =\n                              std::move(VAR_61);\n                          VAR_49.pskType() = VAR_20;\n                          VAR_49.pskMode() = VAR_15;\n                          VAR_49.keyExchangeType() = VAR_37;\n                          VAR_49.earlyDataType() = VAR_90;\n                          VAR_49.replayCacheResult() = VAR_22;\n                          VAR_49.alpn() = std::move(VAR_27);\n                          VAR_49.clientClockSkew() = VAR_28;\n                          VAR_49.appToken() = std::move(VAR_29);\n                          VAR_49.serverCertCompAlgo() = VAR_77;\n                          VAR_49.handshakeTime() = std::move(VAR_24);\n                          VAR_49.clientRandom() = std::move(VAR_76);\n                          VAR_49.echStatus() = VAR_4;\n                          VAR_49.echState() = folly::none;\n                        });\n\n                    if (VAR_30 == EarlyDataType::Accepted) {\n                      if (VAR_0.context()->getOmitEarlyRecordLayer()) {\n                        return actions(\n                            MutateState([VAR_59 = std::move(\n                                             VAR_59),\n                                         VAR_32 =\n                                             std::move(VAR_32)](\n                                            State& VAR_49) mutable {\n                              VAR_49.readRecordLayer() =\n                                  std::move(VAR_59);\n                              VAR_49.earlyExporterMasterSecret() =\n                                  std::move(VAR_32);\n                            }),\n                            std::move(VAR_91),\n                            std::move(*VAR_33),\n                            std::move(VAR_92),\n                            std::move(VAR_93),\n                            std::move(VAR_94),\n                            std::move(VAR_45),\n                            MutateState(\n                                &VAR_9<StateEnum::ExpectingFinished>),\n                            ReportEarlyHandshakeSuccess());\n\n                      } else {\n                        return actions(\n                            MutateState([VAR_59 = std::move(\n                                             VAR_59),\n                                         VAR_31 =\n                                             std::move(VAR_31),\n                                         VAR_32 =\n                                             std::move(VAR_32)](\n                                            State& VAR_49) mutable {\n                              VAR_49.readRecordLayer() =\n                                  std::move(VAR_31);\n                              VAR_49.handshakeReadRecordLayer() =\n                                  std::move(VAR_59);\n                              VAR_49.earlyExporterMasterSecret() =\n                                  std::move(VAR_32);\n                            }),\n                            std::move(VAR_91),\n                            std::move(*VAR_33),\n                            std::move(VAR_92),\n                            std::move(VAR_93),\n                            std::move(VAR_94),\n                            std::move(VAR_45),\n                            MutateState(\n                                &VAR_9<StateEnum::AcceptingEarlyData>),\n                            ReportEarlyHandshakeSuccess());\n                      }\n                    } else {\n                      auto VAR_95 = VAR_63\n                          ? VAR_9<StateEnum::ExpectingCertificate>\n                          : VAR_9<StateEnum::ExpectingFinished>;\n                      return actions(\n                          MutateState([VAR_59 =\n                                           std::move(VAR_59)](\n                                          State& VAR_49) mutable {\n                            VAR_49.readRecordLayer() =\n                                std::move(VAR_59);\n                          }),\n                          std::move(VAR_91),\n                          std::move(VAR_92),\n                          std::move(VAR_93),\n                          std::move(VAR_94),\n                          std::move(VAR_45),\n                          MutateState(VAR_95));\n                    }\n                  });\n            });\n      });\n}",
  "func_graph_path": "facebookincubator/fizz/8d3649841597bedfb6986c30431ebad0eb215265/ServerProtocol.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -60,6 +60,12 @@\n \n   auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n \n+  if (state.cipher().has_value() && cipher != *state.cipher()) {\n+    throw FizzException(\n+        \"cipher mismatch with previous negotiation\",\n+        AlertDescription::illegal_parameter);\n+  }\n+\n   verifyCookieState(cookieState, *version, cipher);\n \n   auto resStateResult = getResumptionState(\n@@ -129,12 +135,6 @@\n             pskType,\n             std::move(state.handshakeContext()),\n             version);\n-\n-        if (state.cipher().has_value() && cipher != *state.cipher()) {\n-          throw FizzException(\n-              \"cipher mismatch with previous negotiation\",\n-              AlertDescription::illegal_parameter);\n-        }\n \n         auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n ",
  "diff_line_info": {
    "deleted_lines": [
      "",
      "        if (state.cipher().has_value() && cipher != *state.cipher()) {",
      "          throw FizzException(",
      "              \"cipher mismatch with previous negotiation\",",
      "              AlertDescription::illegal_parameter);",
      "        }"
    ],
    "added_lines": [
      "  if (state.cipher().has_value() && cipher != *state.cipher()) {",
      "    throw FizzException(",
      "        \"cipher mismatch with previous negotiation\",",
      "        AlertDescription::illegal_parameter);",
      "  }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebookincubator/fizz/pull/86",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 86
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}