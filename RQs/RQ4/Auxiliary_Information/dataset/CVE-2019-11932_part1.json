{
  "cve_id": "CVE-2019-11932",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "koral--/android-gif-drawable",
  "commit_msg": "Do not realloc array if new raster size is 0.\n\nif realloc() is called with 0 size it may return NULL and this will be incorrectly handled\nas not enough memory and (also) rasterBits will be freed by realloc but we will not update\nit.",
  "commit_hash": "4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9",
  "git_url": "https://github.com/koral--/android-gif-drawable/commit/4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9",
  "file_path": "android-gif-drawable/src/main/c/decoding.c",
  "func_name": "DDGifSlurp",
  "func_before": "void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {\n\tGifRecordType RecordType;\n\tGifByteType *ExtData;\n\tint ExtFunction;\n\tGifFileType *gifFilePtr;\n\tgifFilePtr = info->gifFilePtr;\n\tuint_fast32_t lastAllocatedGCBIndex = 0;\n\tdo {\n\t\tif (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\tbool isInitialPass = !decode && !exitAfterFrame;\n\t\tswitch (RecordType) {\n\t\t\tcase IMAGE_DESC_RECORD_TYPE:\n\n\t\t\t\tif (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tgifFilePtr->SWidth += widthOverflow;\n\t\t\t\t\t\tgifFilePtr->SHeight += heightOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];\n\t\t\t\t\tint_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (topOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Top -= topOverflow;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tif (leftOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Left -= leftOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(info, &lastAllocatedGCBIndex)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (decode) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n\t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n\t\t\t\t\t\tif (tmpRasterBits == NULL) {\n\t\t\t\t\t\t\tgifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->rasterBits = tmpRasterBits;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (gifFilePtr->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t i, j;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The way an interlaced image should be read -\n\t\t\t\t\t\t * offsets and jumps...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* Need to perform 4 passes on the image */\n\t\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\t\tfor (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (info->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *dst = info->rasterBits;\n\t\t\t\t\t\tunsigned char *src = info->rasterBits;\n\t\t\t\t\t\tunsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const srcEndLine = src + gifFilePtr->Image.Width;\n\t\t\t\t\t\t\tunsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*dst = *src;\n\t\t\t\t\t\t\t\tdst++;\n\t\t\t\t\t\t\t\tsrc += info->sampleSize;\n\t\t\t\t\t\t\t} while (src < srcEndLine);\n\t\t\t\t\t\t\tdst = dstEndLine;\n\t\t\t\t\t\t\tsrc = srcNextLineStart;\n\t\t\t\t\t\t} while (src < srcEndImage);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (ExtData != NULL);\n\t\t\t\t\tif (exitAfterFrame) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t\tif (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tupdateGCB(info, &lastAllocatedGCBIndex);\n\t\t\t\t\tif (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (ExtData != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Should be trapped by DGifGetRecordType */\n\t\t\t\tbreak;\n\t\t}\n\t} while (RecordType != TERMINATE_RECORD_TYPE);\n\n\tinfo->rewindFunction(info);\n}",
  "abstract_func_before": "void DDGifSlurp(GifInfo *VAR_0, bool VAR_1, bool VAR_2) {\n\tGifRecordType VAR_3;\n\tGifByteType *VAR_4;\n\tint VAR_5;\n\tGifFileType *VAR_6;\n\tVAR_6 = VAR_0->gifFilePtr;\n\tuint_fast32_t VAR_7 = 0;\n\tdo {\n\t\tif (DGifGetRecordType(VAR_6, &VAR_3) == VAR_8) {\n\t\t\tbreak;\n\t\t}\n\t\tbool VAR_9 = !VAR_1 && !VAR_2;\n\t\tswitch (VAR_3) {\n\t\t\tcase VAR_10:\n\n\t\t\t\tif (DGifGetImageDesc(VAR_6, VAR_9) == VAR_8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_9) {\n\t\t\t\t\tint_fast32_t VAR_11 = VAR_6->Image.Width - VAR_6->SWidth;\n\t\t\t\t\tint_fast32_t VAR_12 = VAR_6->Image.Height - VAR_6->SHeight;\n\t\t\t\t\tif (VAR_11 > 0 || VAR_12 > 0) {\n\t\t\t\t\t\tVAR_6->SWidth += VAR_11;\n\t\t\t\t\t\tVAR_6->SHeight += VAR_12;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *VAR_13 = &VAR_6->SavedImages[VAR_6->ImageCount - 1];\n\t\t\t\t\tint_fast32_t VAR_14 = VAR_6->Image.Top + VAR_6->Image.Height - VAR_6->SHeight;\n\t\t\t\t\tif (VAR_14 > 0) {\n\t\t\t\t\t\tVAR_13->ImageDesc.Top -= VAR_14;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t VAR_15 = VAR_6->Image.Left + VAR_6->Image.Width - VAR_6->SWidth;\n\t\t\t\t\tif (VAR_15 > 0) {\n\t\t\t\t\t\tVAR_13->ImageDesc.Left -= VAR_15;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(VAR_0, &VAR_7)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (VAR_1) {\n\t\t\t\t\tint_fast32_t VAR_11 = VAR_6->Image.Width - VAR_0->originalWidth;\n\t\t\t\t\tint_fast32_t VAR_12 = VAR_6->Image.Height - VAR_0->originalHeight;\n\t\t\t\t\tconst uint_fast32_t VAR_16 = VAR_6->Image.Width * VAR_6->Image.Height;\n\t\t\t\t\tif (VAR_16 > VAR_0->rasterSize || VAR_11 > 0 || VAR_12 > 0) {\n\t\t\t\t\t\tvoid *VAR_17 = reallocarray(VAR_0->rasterBits, VAR_16, sizeof(VAR_18));\n\t\t\t\t\t\tif (VAR_17 == NULL) {\n\t\t\t\t\t\t\tVAR_6->Error = VAR_19;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_0->rasterBits = VAR_17;\n\t\t\t\t\t\tVAR_0->rasterSize = VAR_16;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_6->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t VAR_20, VAR_21;\n\t\t\t\t\t\t/* COMMENT_0 */\n                                                     \n                             \n         \n\t\t\t\t\t\tuint_fast8_t VAR_22[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t VAR_23[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* COMMENT_4 */\n\t\t\t\t\t\tfor (VAR_20 = 0; VAR_20 < 4; VAR_20++)\n\t\t\t\t\t\t\tfor (VAR_21 = VAR_22[VAR_20]; VAR_21 < VAR_6->Image.Height; VAR_21 += VAR_23[VAR_20]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(VAR_6, VAR_0->rasterBits + VAR_21 * VAR_6->Image.Width, VAR_6->Image.Width) == VAR_8)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(VAR_6, VAR_0->rasterBits, VAR_6->Image.Width * VAR_6->Image.Height) == VAR_8) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (VAR_0->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *VAR_24 = VAR_0->rasterBits;\n\t\t\t\t\t\tunsigned char *VAR_25 = VAR_0->rasterBits;\n\t\t\t\t\t\tunsigned char *const VAR_26 = VAR_0->rasterBits + VAR_6->Image.Width * VAR_6->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *VAR_27 = VAR_25 + VAR_6->Image.Width * VAR_0->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const VAR_28 = VAR_25 + VAR_6->Image.Width;\n\t\t\t\t\t\t\tunsigned char *VAR_29 = VAR_24 + VAR_6->Image.Width / VAR_0->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*VAR_24 = *VAR_25;\n\t\t\t\t\t\t\t\tVAR_24++;\n\t\t\t\t\t\t\t\tVAR_25 += VAR_0->sampleSize;\n\t\t\t\t\t\t\t} while (VAR_25 < VAR_28);\n\t\t\t\t\t\t\tVAR_24 = VAR_29;\n\t\t\t\t\t\t\tVAR_25 = VAR_27;\n\t\t\t\t\t\t} while (VAR_25 < VAR_26);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(VAR_6, &VAR_4) == VAR_8) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (VAR_4 != NULL);\n\t\t\t\t\tif (VAR_2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_30:\n\t\t\t\tif (DGifGetExtension(VAR_6, &VAR_5, &VAR_4) == VAR_8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (VAR_9) {\n\t\t\t\t\tupdateGCB(VAR_0, &VAR_7);\n\t\t\t\t\tif (readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (VAR_4 != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(VAR_6, &VAR_4) == VAR_8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_9 && readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_31:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* COMMENT_5 */\n\t\t\t\tbreak;\n\t\t}\n\t} while (VAR_3 != VAR_31);\n\n\tVAR_0->rewindFunction(VAR_0);\n}",
  "func_graph_path_before": "koral--/android-gif-drawable/4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9/decoding.c/vul/before/0.json",
  "func": "void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {\n\tGifRecordType RecordType;\n\tGifByteType *ExtData;\n\tint ExtFunction;\n\tGifFileType *gifFilePtr;\n\tgifFilePtr = info->gifFilePtr;\n\tuint_fast32_t lastAllocatedGCBIndex = 0;\n\tdo {\n\t\tif (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\tbool isInitialPass = !decode && !exitAfterFrame;\n\t\tswitch (RecordType) {\n\t\t\tcase IMAGE_DESC_RECORD_TYPE:\n\n\t\t\t\tif (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tgifFilePtr->SWidth += widthOverflow;\n\t\t\t\t\t\tgifFilePtr->SHeight += heightOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];\n\t\t\t\t\tint_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (topOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Top -= topOverflow;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tif (leftOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Left -= leftOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(info, &lastAllocatedGCBIndex)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (decode) {\n\t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\tif (newRasterSize == 0) {\n\t\t\t\t\t\tfree(info->rasterBits);\n\t\t\t\t\t\tinfo->rasterBits = NULL;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n\t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n\t\t\t\t\t\tif (tmpRasterBits == NULL) {\n\t\t\t\t\t\t\tgifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->rasterBits = tmpRasterBits;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (gifFilePtr->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t i, j;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The way an interlaced image should be read -\n\t\t\t\t\t\t * offsets and jumps...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* Need to perform 4 passes on the image */\n\t\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\t\tfor (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (info->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *dst = info->rasterBits;\n\t\t\t\t\t\tunsigned char *src = info->rasterBits;\n\t\t\t\t\t\tunsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const srcEndLine = src + gifFilePtr->Image.Width;\n\t\t\t\t\t\t\tunsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*dst = *src;\n\t\t\t\t\t\t\t\tdst++;\n\t\t\t\t\t\t\t\tsrc += info->sampleSize;\n\t\t\t\t\t\t\t} while (src < srcEndLine);\n\t\t\t\t\t\t\tdst = dstEndLine;\n\t\t\t\t\t\t\tsrc = srcNextLineStart;\n\t\t\t\t\t\t} while (src < srcEndImage);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (ExtData != NULL);\n\t\t\t\t\tif (exitAfterFrame) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t\tif (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tupdateGCB(info, &lastAllocatedGCBIndex);\n\t\t\t\t\tif (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (ExtData != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Should be trapped by DGifGetRecordType */\n\t\t\t\tbreak;\n\t\t}\n\t} while (RecordType != TERMINATE_RECORD_TYPE);\n\n\tinfo->rewindFunction(info);\n}",
  "abstract_func": "void DDGifSlurp(GifInfo *VAR_0, bool VAR_1, bool VAR_2) {\n\tGifRecordType VAR_3;\n\tGifByteType *VAR_4;\n\tint VAR_5;\n\tGifFileType *VAR_6;\n\tVAR_6 = VAR_0->gifFilePtr;\n\tuint_fast32_t VAR_7 = 0;\n\tdo {\n\t\tif (DGifGetRecordType(VAR_6, &VAR_3) == VAR_8) {\n\t\t\tbreak;\n\t\t}\n\t\tbool VAR_9 = !VAR_1 && !VAR_2;\n\t\tswitch (VAR_3) {\n\t\t\tcase VAR_10:\n\n\t\t\t\tif (DGifGetImageDesc(VAR_6, VAR_9) == VAR_8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_9) {\n\t\t\t\t\tint_fast32_t VAR_11 = VAR_6->Image.Width - VAR_6->SWidth;\n\t\t\t\t\tint_fast32_t VAR_12 = VAR_6->Image.Height - VAR_6->SHeight;\n\t\t\t\t\tif (VAR_11 > 0 || VAR_12 > 0) {\n\t\t\t\t\t\tVAR_6->SWidth += VAR_11;\n\t\t\t\t\t\tVAR_6->SHeight += VAR_12;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *VAR_13 = &VAR_6->SavedImages[VAR_6->ImageCount - 1];\n\t\t\t\t\tint_fast32_t VAR_14 = VAR_6->Image.Top + VAR_6->Image.Height - VAR_6->SHeight;\n\t\t\t\t\tif (VAR_14 > 0) {\n\t\t\t\t\t\tVAR_13->ImageDesc.Top -= VAR_14;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t VAR_15 = VAR_6->Image.Left + VAR_6->Image.Width - VAR_6->SWidth;\n\t\t\t\t\tif (VAR_15 > 0) {\n\t\t\t\t\t\tVAR_13->ImageDesc.Left -= VAR_15;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(VAR_0, &VAR_7)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (VAR_1) {\n\t\t\t\t\tconst uint_fast32_t VAR_16 = VAR_6->Image.Width * VAR_6->Image.Height;\n\t\t\t\t\tif (VAR_16 == 0) {\n\t\t\t\t\t\tfree(VAR_0->rasterBits);\n\t\t\t\t\t\tVAR_0->rasterBits = NULL;\n\t\t\t\t\t\tVAR_0->rasterSize = VAR_16;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst int_fast32_t VAR_11 = VAR_6->Image.Width - VAR_0->originalWidth;\n\t\t\t\t\tconst int_fast32_t VAR_12 = VAR_6->Image.Height - VAR_0->originalHeight;\n\t\t\t\t\tif (VAR_16 > VAR_0->rasterSize || VAR_11 > 0 || VAR_12 > 0) {\n\t\t\t\t\t\tvoid *VAR_17 = reallocarray(VAR_0->rasterBits, VAR_16, sizeof(VAR_18));\n\t\t\t\t\t\tif (VAR_17 == NULL) {\n\t\t\t\t\t\t\tVAR_6->Error = VAR_19;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_0->rasterBits = VAR_17;\n\t\t\t\t\t\tVAR_0->rasterSize = VAR_16;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_6->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t VAR_20, VAR_21;\n\t\t\t\t\t\t/* COMMENT_0 */\n                                                     \n                             \n         \n\t\t\t\t\t\tuint_fast8_t VAR_22[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t VAR_23[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* COMMENT_4 */\n\t\t\t\t\t\tfor (VAR_20 = 0; VAR_20 < 4; VAR_20++)\n\t\t\t\t\t\t\tfor (VAR_21 = VAR_22[VAR_20]; VAR_21 < VAR_6->Image.Height; VAR_21 += VAR_23[VAR_20]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(VAR_6, VAR_0->rasterBits + VAR_21 * VAR_6->Image.Width, VAR_6->Image.Width) == VAR_8)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(VAR_6, VAR_0->rasterBits, VAR_6->Image.Width * VAR_6->Image.Height) == VAR_8) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (VAR_0->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *VAR_24 = VAR_0->rasterBits;\n\t\t\t\t\t\tunsigned char *VAR_25 = VAR_0->rasterBits;\n\t\t\t\t\t\tunsigned char *const VAR_26 = VAR_0->rasterBits + VAR_6->Image.Width * VAR_6->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *VAR_27 = VAR_25 + VAR_6->Image.Width * VAR_0->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const VAR_28 = VAR_25 + VAR_6->Image.Width;\n\t\t\t\t\t\t\tunsigned char *VAR_29 = VAR_24 + VAR_6->Image.Width / VAR_0->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*VAR_24 = *VAR_25;\n\t\t\t\t\t\t\t\tVAR_24++;\n\t\t\t\t\t\t\t\tVAR_25 += VAR_0->sampleSize;\n\t\t\t\t\t\t\t} while (VAR_25 < VAR_28);\n\t\t\t\t\t\t\tVAR_24 = VAR_29;\n\t\t\t\t\t\t\tVAR_25 = VAR_27;\n\t\t\t\t\t\t} while (VAR_25 < VAR_26);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(VAR_6, &VAR_4) == VAR_8) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (VAR_4 != NULL);\n\t\t\t\t\tif (VAR_2) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_30:\n\t\t\t\tif (DGifGetExtension(VAR_6, &VAR_5, &VAR_4) == VAR_8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (VAR_9) {\n\t\t\t\t\tupdateGCB(VAR_0, &VAR_7);\n\t\t\t\t\tif (readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (VAR_4 != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(VAR_6, &VAR_4) == VAR_8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_9 && readExtensions(VAR_5, VAR_4, VAR_0) == VAR_8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_31:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* COMMENT_5 */\n\t\t\t\tbreak;\n\t\t}\n\t} while (VAR_3 != VAR_31);\n\n\tVAR_0->rewindFunction(VAR_0);\n}",
  "func_graph_path": "koral--/android-gif-drawable/4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9/decoding.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -40,9 +40,15 @@\n \t\t\t\t}\n \n \t\t\t\tif (decode) {\n-\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n-\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n \t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n+\t\t\t\t\tif (newRasterSize == 0) {\n+\t\t\t\t\t\tfree(info->rasterBits);\n+\t\t\t\t\t\tinfo->rasterBits = NULL;\n+\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n+\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n \t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n \t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n \t\t\t\t\t\tif (tmpRasterBits == NULL) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;",
      "\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;"
    ],
    "added_lines": [
      "\t\t\t\t\tif (newRasterSize == 0) {",
      "\t\t\t\t\t\tfree(info->rasterBits);",
      "\t\t\t\t\t\tinfo->rasterBits = NULL;",
      "\t\t\t\t\t\tinfo->rasterSize = newRasterSize;",
      "\t\t\t\t\t\treturn;",
      "\t\t\t\t\t}",
      "\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;",
      "\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/koral--/android-gif-drawable/pull/673",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/koral--/android-gif-drawable/pull/673: 403 Client Error: Forbidden for url: https://api.github.com/repos/koral--/android-gif-drawable/pulls/673",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses a memory management issue leading to a potential double-free scenario, classified as a security vulnerability. The code changes match the commit message and vulnerability description, indicating a clear intent to fix a security issue.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}