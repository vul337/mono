{
  "cve_id": "CVE-2020-18378",
  "cwe_ids": [
    "CWE-787",
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "WebAssembly/binaryen",
  "commit_msg": "fix  breakage",
  "commit_hash": "cc47475d76b21284565bd69b9701f50396d6068e",
  "git_url": "https://github.com/WebAssembly/binaryen/commit/cc47475d76b21284565bd69b9701f50396d6068e",
  "file_path": "src/ir/ExpressionAnalyzer.cpp",
  "func_name": "ExpressionAnalyzer::flexibleEqual",
  "func_before": "bool ExpressionAnalyzer::flexibleEqual(Expression* left, Expression* right, ExprComparer comparer) {\n  std::vector<Name> nameStack;\n  std::map<Name, std::vector<Name>> rightNames; // for each name on the left, the stack of names on the right (a stack, since names are scoped and can nest duplicatively\n  Nop popNameMarker;\n  std::vector<Expression*> leftStack;\n  std::vector<Expression*> rightStack;\n\n  auto noteNames = [&](Name left, Name right) {\n    if (left.is() != right.is()) return false;\n    if (left.is()) {\n      nameStack.push_back(left);\n      rightNames[left].push_back(right);\n      leftStack.push_back(&popNameMarker);\n      rightStack.push_back(&popNameMarker);\n    }\n    return true;\n  };\n  auto checkNames = [&](Name left, Name right) {\n    auto iter = rightNames.find(left);\n    if (iter == rightNames.end()) return left == right; // non-internal name\n    return iter->second.back() == right;\n  };\n  auto popName = [&]() {\n    auto left = nameStack.back();\n    nameStack.pop_back();\n    rightNames[left].pop_back();\n  };\n\n  leftStack.push_back(left);\n  rightStack.push_back(right);\n\n  while (leftStack.size() > 0 && rightStack.size() > 0) {\n    left = leftStack.back();\n    leftStack.pop_back();\n    right = rightStack.back();\n    rightStack.pop_back();\n    if (!left != !right) return false;\n    if (!left) continue;\n    if (left == &popNameMarker) {\n      popName();\n      continue;\n    }\n    if (comparer(left, right)) continue; // comparison hook, before all the rest\n    // continue with normal structural comparison\n    if (left->_id != right->_id) return false;\n    // Compare immediate values\n    #define CHECK(clazz, what) \\\n      if (left->cast<clazz>()->what != right->cast<clazz>()->what) return false;\n    switch (left->_id) {\n      case Expression::Id::BlockId: {\n        if (!noteNames(left->cast<Block>()->name, right->cast<Block>()->name)) return false;\n        CHECK(Block, list.size());\n        break;\n      }\n      case Expression::Id::LoopId: {\n        if (!noteNames(left->cast<Loop>()->name, right->cast<Loop>()->name)) return false;\n        break;\n      }\n      case Expression::Id::BreakId: {\n        if (!checkNames(left->cast<Break>()->name, right->cast<Break>()->name)) return false;\n        break;\n      }\n      case Expression::Id::SwitchId: {\n        CHECK(Switch, targets.size());\n        for (Index i = 0; i < left->cast<Switch>()->targets.size(); i++) {\n          if (!checkNames(left->cast<Switch>()->targets[i], right->cast<Switch>()->targets[i])) return false;\n        }\n        if (!checkNames(left->cast<Switch>()->default_, right->cast<Switch>()->default_)) return false;\n        break;\n      }\n      case Expression::Id::CallId: {\n        CHECK(Call, target);\n        CHECK(Call, operands.size());\n        break;\n      }\n      case Expression::Id::CallIndirectId: {\n        CHECK(CallIndirect, fullType);\n        CHECK(CallIndirect, operands.size());\n        break;\n      }\n      case Expression::Id::GetLocalId: {\n        CHECK(GetLocal, index);\n        break;\n      }\n      case Expression::Id::SetLocalId: {\n        CHECK(SetLocal, index);\n        CHECK(SetLocal, type); // for tee/set\n        break;\n      }\n      case Expression::Id::GetGlobalId: {\n        CHECK(GetGlobal, name);\n        break;\n      }\n      case Expression::Id::SetGlobalId: {\n        CHECK(SetGlobal, name);\n        break;\n      }\n      case Expression::Id::LoadId: {\n        CHECK(Load, bytes);\n        if (LoadUtils::isSignRelevant(left->cast<Load>()) &&\n            LoadUtils::isSignRelevant(right->cast<Load>())) {\n          CHECK(Load, signed_);\n        }\n        CHECK(Load, offset);\n        CHECK(Load, align);\n        CHECK(Load, isAtomic);\n        break;\n      }\n      case Expression::Id::StoreId: {\n        CHECK(Store, bytes);\n        CHECK(Store, offset);\n        CHECK(Store, align);\n        CHECK(Store, valueType);\n        CHECK(Store, isAtomic);\n        break;\n      }\n      case Expression::Id::AtomicCmpxchgId: {\n        CHECK(AtomicCmpxchg, bytes);\n        CHECK(AtomicCmpxchg, offset);\n        break;\n      }\n      case Expression::Id::AtomicRMWId: {\n        CHECK(AtomicRMW, op);\n        CHECK(AtomicRMW, bytes);\n        CHECK(AtomicRMW, offset);\n        break;\n      }\n      case Expression::Id::AtomicWaitId: {\n        CHECK(AtomicWait, expectedType);\n        break;\n      }\n      case Expression::Id::AtomicWakeId: {\n        break;\n      }\n      case Expression::Id::SIMDExtractId: {\n        CHECK(SIMDExtract, op);\n        CHECK(SIMDExtract, index);\n        break;\n      }\n      case Expression::Id::SIMDReplaceId: {\n        CHECK(SIMDReplace, op);\n        CHECK(SIMDReplace, index);\n        break;\n      }\n      case Expression::Id::SIMDShuffleId: {\n        CHECK(SIMDShuffle, mask);\n        break;\n      }\n      case Expression::Id::SIMDBitselectId: {\n        break;\n      }\n      case Expression::Id::SIMDShiftId: {\n        CHECK(SIMDShift, op);\n        break;\n      }\n      case Expression::Id::MemoryInitId: {\n        CHECK(MemoryInit, segment);\n        PUSH(MemoryInit, dest);\n        PUSH(MemoryInit, offset);\n        PUSH(MemoryInit, size);\n        break;\n      }\n      case Expression::Id::DataDropId: {\n        CHECK(DataDrop, segment);\n        break;\n      }\n      case Expression::Id::MemoryCopyId: {\n        PUSH(MemoryCopy, dest);\n        PUSH(MemoryCopy, source);\n        PUSH(MemoryCopy, size);\n        break;\n      }\n      case Expression::Id::MemoryFillId: {\n        PUSH(MemoryFill, dest);\n        PUSH(MemoryFill, value);\n        PUSH(MemoryFill, size);\n        break;\n      }\n      case Expression::Id::ConstId: {\n        if (left->cast<Const>()->value != right->cast<Const>()->value) {\n          return false;\n        }\n        break;\n      }\n      case Expression::Id::UnaryId: {\n        CHECK(Unary, op);\n        break;\n      }\n      case Expression::Id::BinaryId: {\n        CHECK(Binary, op);\n        break;\n      }\n      case Expression::Id::HostId: {\n        CHECK(Host, op);\n        CHECK(Host, nameOperand);\n        CHECK(Host, operands.size());\n        break;\n      }\n      case Expression::Id::NopId: {\n        break;\n      }\n      case Expression::Id::UnreachableId: {\n        break;\n      }\n      case Expression::Id::InvalidId:\n      case Expression::Id::NumExpressionIds: {\n        WASM_UNREACHABLE();\n      }\n      case Expression::Id::IfId:\n      case Expression::Id::SelectId:\n      case Expression::Id::DropId:\n      case Expression::Id::ReturnId: {\n        break; // some nodes have no immediate fields\n      }\n    }\n    // Add child nodes\n    for (auto* child : ChildIterator(left)) {\n      leftStack.push_back(child);\n    }\n    for (auto* child : ChildIterator(right)) {\n      rightStack.push_back(child);\n    }\n    #undef CHECK\n    #undef PUSH\n  }\n  if (leftStack.size() > 0 || rightStack.size() > 0) return false;\n  return true;\n}",
  "abstract_func_before": "bool ExpressionAnalyzer::flexibleEqual(Expression* VAR_0, Expression* VAR_1, ExprComparer VAR_2) {\n  std::vector<Name> VAR_3;\n  std::map<Name, std::vector<Name>> VAR_4; /* COMMENT_0 */\n  Nop VAR_5;\n  std::vector<Expression*> VAR_6;\n  std::vector<Expression*> VAR_7;\n\n  auto VAR_8 = [&](Name VAR_0, Name VAR_1) {\n    if (VAR_0.is() != VAR_1.is()) return false;\n    if (VAR_0.is()) {\n      VAR_3.push_back(VAR_0);\n      VAR_4[VAR_0].push_back(VAR_1);\n      VAR_6.push_back(&VAR_5);\n      VAR_7.push_back(&VAR_5);\n    }\n    return true;\n  };\n  auto VAR_9 = [&](Name VAR_0, Name VAR_1) {\n    auto VAR_10 = VAR_4.find(VAR_0);\n    if (VAR_10 == VAR_4.end()) return VAR_0 == VAR_1; /* COMMENT_1 */\n    return VAR_10->second.back() == VAR_1;\n  };\n  auto VAR_11 = [&]() {\n    auto VAR_0 = VAR_3.back();\n    VAR_3.pop_back();\n    VAR_4[VAR_0].pop_back();\n  };\n\n  VAR_6.push_back(VAR_0);\n  VAR_7.push_back(VAR_1);\n\n  while (VAR_6.size() > 0 && VAR_7.size() > 0) {\n    VAR_0 = VAR_6.back();\n    VAR_6.pop_back();\n    VAR_1 = VAR_7.back();\n    VAR_7.pop_back();\n    if (!VAR_0 != !VAR_1) return false;\n    if (!VAR_0) continue;\n    if (VAR_0 == &VAR_5) {\n      VAR_11();\n      continue;\n    }\n    if (VAR_2(VAR_0, VAR_1)) continue; /* COMMENT_2 */\n    /* COMMENT_3 */\n    if (VAR_0->_id != VAR_1->_id) return false;\n    /* COMMENT_4 */\n    #define CHECK(VAR_12, VAR_13) \\\n      if (left->cast<clazz>()->what != right->cast<clazz>()->what) return false;\n    switch (VAR_0->_id) {\n      case Expression::Id::BlockId: {\n        if (!VAR_8(VAR_0->cast<Block>()->name, VAR_1->cast<Block>()->name)) return false;\n        CHECK(Block, VAR_14.size());\n        break;\n      }\n      case Expression::Id::LoopId: {\n        if (!VAR_8(VAR_0->cast<Loop>()->name, VAR_1->cast<Loop>()->name)) return false;\n        break;\n      }\n      case Expression::Id::BreakId: {\n        if (!VAR_9(VAR_0->cast<Break>()->name, VAR_1->cast<Break>()->name)) return false;\n        break;\n      }\n      case Expression::Id::SwitchId: {\n        CHECK(VAR_15, VAR_16.size());\n        for (Index VAR_17 = 0; VAR_17 < VAR_0->cast<VAR_15>()->targets.size(); VAR_17++) {\n          if (!VAR_9(VAR_0->cast<Switch>()->targets[VAR_17], VAR_1->cast<Switch>()->targets[VAR_17])) return false;\n        }\n        if (!VAR_9(VAR_0->cast<Switch>()->default_, VAR_1->cast<Switch>()->default_)) return false;\n        break;\n      }\n      case Expression::Id::CallId: {\n        CHECK(VAR_18, VAR_19);\n        CHECK(VAR_18, VAR_20.size());\n        break;\n      }\n      case Expression::Id::CallIndirectId: {\n        CHECK(VAR_21, VAR_22);\n        CHECK(VAR_21, VAR_20.size());\n        break;\n      }\n      case Expression::Id::GetLocalId: {\n        CHECK(VAR_23, VAR_24);\n        break;\n      }\n      case Expression::Id::SetLocalId: {\n        CHECK(VAR_25, VAR_24);\n        CHECK(VAR_25, VAR_26); /* COMMENT_5 */\n        break;\n      }\n      case Expression::Id::GetGlobalId: {\n        CHECK(VAR_27, VAR_28);\n        break;\n      }\n      case Expression::Id::SetGlobalId: {\n        CHECK(VAR_29, VAR_28);\n        break;\n      }\n      case Expression::Id::LoadId: {\n        CHECK(VAR_30, VAR_31);\n        if (LoadUtils::isSignRelevant(VAR_0->cast<Load>()) &&\n            LoadUtils::isSignRelevant(VAR_1->cast<Load>())) {\n          CHECK(Load, VAR_32);\n        }\n        CHECK(Load, VAR_33);\n        CHECK(Load, VAR_34);\n        CHECK(Load, VAR_35);\n        break;\n      }\n      case Expression::Id::StoreId: {\n        CHECK(VAR_36, VAR_31);\n        CHECK(VAR_36, VAR_33);\n        CHECK(VAR_36, VAR_34);\n        CHECK(VAR_36, VAR_37);\n        CHECK(VAR_36, VAR_35);\n        break;\n      }\n      case Expression::Id::AtomicCmpxchgId: {\n        CHECK(VAR_38, VAR_31);\n        CHECK(VAR_38, VAR_33);\n        break;\n      }\n      case Expression::Id::AtomicRMWId: {\n        CHECK(VAR_39, VAR_40);\n        CHECK(VAR_39, VAR_31);\n        CHECK(VAR_39, VAR_33);\n        break;\n      }\n      case Expression::Id::AtomicWaitId: {\n        CHECK(VAR_41, VAR_42);\n        break;\n      }\n      case Expression::Id::AtomicWakeId: {\n        break;\n      }\n      case Expression::Id::SIMDExtractId: {\n        CHECK(VAR_43, VAR_40);\n        CHECK(VAR_43, VAR_24);\n        break;\n      }\n      case Expression::Id::SIMDReplaceId: {\n        CHECK(VAR_44, VAR_40);\n        CHECK(VAR_44, VAR_24);\n        break;\n      }\n      case Expression::Id::SIMDShuffleId: {\n        CHECK(VAR_45, VAR_46);\n        break;\n      }\n      case Expression::Id::SIMDBitselectId: {\n        break;\n      }\n      case Expression::Id::SIMDShiftId: {\n        CHECK(VAR_47, VAR_40);\n        break;\n      }\n      case Expression::Id::MemoryInitId: {\n        CHECK(VAR_48, VAR_49);\n        PUSH(VAR_48, VAR_50);\n        PUSH(VAR_48, VAR_33);\n        PUSH(VAR_48, VAR_51);\n        break;\n      }\n      case Expression::Id::DataDropId: {\n        CHECK(VAR_52, VAR_49);\n        break;\n      }\n      case Expression::Id::MemoryCopyId: {\n        PUSH(VAR_53, VAR_50);\n        PUSH(VAR_53, VAR_54);\n        PUSH(VAR_53, VAR_51);\n        break;\n      }\n      case Expression::Id::MemoryFillId: {\n        PUSH(VAR_55, VAR_50);\n        PUSH(VAR_55, VAR_56);\n        PUSH(VAR_55, VAR_51);\n        break;\n      }\n      case Expression::Id::ConstId: {\n        if (VAR_0->cast<Const>()->value != VAR_1->cast<Const>()->value) {\n          return false;\n        }\n        break;\n      }\n      case Expression::Id::UnaryId: {\n        CHECK(VAR_57, VAR_40);\n        break;\n      }\n      case Expression::Id::BinaryId: {\n        CHECK(VAR_58, VAR_40);\n        break;\n      }\n      case Expression::Id::HostId: {\n        CHECK(VAR_59, VAR_40);\n        CHECK(VAR_59, VAR_60);\n        CHECK(VAR_59, VAR_20.size());\n        break;\n      }\n      case Expression::Id::NopId: {\n        break;\n      }\n      case Expression::Id::UnreachableId: {\n        break;\n      }\n      case Expression::Id::InvalidId:\n      case Expression::Id::NumExpressionIds: {\n        WASM_UNREACHABLE();\n      }\n      case Expression::Id::IfId:\n      case Expression::Id::SelectId:\n      case Expression::Id::DropId:\n      case Expression::Id::ReturnId: {\n        break; /* COMMENT_6 */\n      }\n    }\n    /* COMMENT_7 */\n    for (auto* VAR_61 : ChildIterator(VAR_0)) {\n      VAR_6.push_back(VAR_61);\n    }\n    for (auto* VAR_61 : ChildIterator(VAR_1)) {\n      VAR_7.push_back(VAR_61);\n    }\n    #undef CHECK\n    #undef PUSH\n  }\n  if (VAR_6.size() > 0 || VAR_7.size() > 0) return false;\n  return true;\n}",
  "func_graph_path_before": "WebAssembly/binaryen/cc47475d76b21284565bd69b9701f50396d6068e/ExpressionAnalyzer.cpp/vul/before/0.json",
  "func": "bool ExpressionAnalyzer::flexibleEqual(Expression* left, Expression* right, ExprComparer comparer) {\n  std::vector<Name> nameStack;\n  std::map<Name, std::vector<Name>> rightNames; // for each name on the left, the stack of names on the right (a stack, since names are scoped and can nest duplicatively\n  Nop popNameMarker;\n  std::vector<Expression*> leftStack;\n  std::vector<Expression*> rightStack;\n\n  auto noteNames = [&](Name left, Name right) {\n    if (left.is() != right.is()) return false;\n    if (left.is()) {\n      nameStack.push_back(left);\n      rightNames[left].push_back(right);\n      leftStack.push_back(&popNameMarker);\n      rightStack.push_back(&popNameMarker);\n    }\n    return true;\n  };\n  auto checkNames = [&](Name left, Name right) {\n    auto iter = rightNames.find(left);\n    if (iter == rightNames.end()) return left == right; // non-internal name\n    return iter->second.back() == right;\n  };\n  auto popName = [&]() {\n    auto left = nameStack.back();\n    nameStack.pop_back();\n    rightNames[left].pop_back();\n  };\n\n  leftStack.push_back(left);\n  rightStack.push_back(right);\n\n  while (leftStack.size() > 0 && rightStack.size() > 0) {\n    left = leftStack.back();\n    leftStack.pop_back();\n    right = rightStack.back();\n    rightStack.pop_back();\n    if (!left != !right) return false;\n    if (!left) continue;\n    if (left == &popNameMarker) {\n      popName();\n      continue;\n    }\n    if (comparer(left, right)) continue; // comparison hook, before all the rest\n    // continue with normal structural comparison\n    if (left->_id != right->_id) return false;\n    // Compare immediate values\n    #define CHECK(clazz, what) \\\n      if (left->cast<clazz>()->what != right->cast<clazz>()->what) return false;\n    switch (left->_id) {\n      case Expression::Id::BlockId: {\n        if (!noteNames(left->cast<Block>()->name, right->cast<Block>()->name)) return false;\n        CHECK(Block, list.size());\n        break;\n      }\n      case Expression::Id::LoopId: {\n        if (!noteNames(left->cast<Loop>()->name, right->cast<Loop>()->name)) return false;\n        break;\n      }\n      case Expression::Id::BreakId: {\n        if (!checkNames(left->cast<Break>()->name, right->cast<Break>()->name)) return false;\n        break;\n      }\n      case Expression::Id::SwitchId: {\n        CHECK(Switch, targets.size());\n        for (Index i = 0; i < left->cast<Switch>()->targets.size(); i++) {\n          if (!checkNames(left->cast<Switch>()->targets[i], right->cast<Switch>()->targets[i])) return false;\n        }\n        if (!checkNames(left->cast<Switch>()->default_, right->cast<Switch>()->default_)) return false;\n        break;\n      }\n      case Expression::Id::CallId: {\n        CHECK(Call, target);\n        CHECK(Call, operands.size());\n        break;\n      }\n      case Expression::Id::CallIndirectId: {\n        CHECK(CallIndirect, fullType);\n        CHECK(CallIndirect, operands.size());\n        break;\n      }\n      case Expression::Id::GetLocalId: {\n        CHECK(GetLocal, index);\n        break;\n      }\n      case Expression::Id::SetLocalId: {\n        CHECK(SetLocal, index);\n        CHECK(SetLocal, type); // for tee/set\n        break;\n      }\n      case Expression::Id::GetGlobalId: {\n        CHECK(GetGlobal, name);\n        break;\n      }\n      case Expression::Id::SetGlobalId: {\n        CHECK(SetGlobal, name);\n        break;\n      }\n      case Expression::Id::LoadId: {\n        CHECK(Load, bytes);\n        if (LoadUtils::isSignRelevant(left->cast<Load>()) &&\n            LoadUtils::isSignRelevant(right->cast<Load>())) {\n          CHECK(Load, signed_);\n        }\n        CHECK(Load, offset);\n        CHECK(Load, align);\n        CHECK(Load, isAtomic);\n        break;\n      }\n      case Expression::Id::StoreId: {\n        CHECK(Store, bytes);\n        CHECK(Store, offset);\n        CHECK(Store, align);\n        CHECK(Store, valueType);\n        CHECK(Store, isAtomic);\n        break;\n      }\n      case Expression::Id::AtomicCmpxchgId: {\n        CHECK(AtomicCmpxchg, bytes);\n        CHECK(AtomicCmpxchg, offset);\n        break;\n      }\n      case Expression::Id::AtomicRMWId: {\n        CHECK(AtomicRMW, op);\n        CHECK(AtomicRMW, bytes);\n        CHECK(AtomicRMW, offset);\n        break;\n      }\n      case Expression::Id::AtomicWaitId: {\n        CHECK(AtomicWait, expectedType);\n        break;\n      }\n      case Expression::Id::AtomicWakeId: {\n        break;\n      }\n      case Expression::Id::SIMDExtractId: {\n        CHECK(SIMDExtract, op);\n        CHECK(SIMDExtract, index);\n        break;\n      }\n      case Expression::Id::SIMDReplaceId: {\n        CHECK(SIMDReplace, op);\n        CHECK(SIMDReplace, index);\n        break;\n      }\n      case Expression::Id::SIMDShuffleId: {\n        CHECK(SIMDShuffle, mask);\n        break;\n      }\n      case Expression::Id::SIMDBitselectId: {\n        break;\n      }\n      case Expression::Id::SIMDShiftId: {\n        CHECK(SIMDShift, op);\n        break;\n      }\n      case Expression::Id::MemoryInitId: {\n        CHECK(MemoryInit, segment);\n        break;\n      }\n      case Expression::Id::DataDropId: {\n        CHECK(DataDrop, segment);\n        break;\n      }\n      case Expression::Id::MemoryCopyId: {\n        break;\n      }\n      case Expression::Id::MemoryFillId: {\n        break;\n      }\n      case Expression::Id::ConstId: {\n        if (left->cast<Const>()->value != right->cast<Const>()->value) {\n          return false;\n        }\n        break;\n      }\n      case Expression::Id::UnaryId: {\n        CHECK(Unary, op);\n        break;\n      }\n      case Expression::Id::BinaryId: {\n        CHECK(Binary, op);\n        break;\n      }\n      case Expression::Id::HostId: {\n        CHECK(Host, op);\n        CHECK(Host, nameOperand);\n        CHECK(Host, operands.size());\n        break;\n      }\n      case Expression::Id::NopId: {\n        break;\n      }\n      case Expression::Id::UnreachableId: {\n        break;\n      }\n      case Expression::Id::InvalidId:\n      case Expression::Id::NumExpressionIds: {\n        WASM_UNREACHABLE();\n      }\n      case Expression::Id::IfId:\n      case Expression::Id::SelectId:\n      case Expression::Id::DropId:\n      case Expression::Id::ReturnId: {\n        break; // some nodes have no immediate fields\n      }\n    }\n    // Add child nodes\n    for (auto* child : ChildIterator(left)) {\n      leftStack.push_back(child);\n    }\n    for (auto* child : ChildIterator(right)) {\n      rightStack.push_back(child);\n    }\n    #undef CHECK\n  }\n  if (leftStack.size() > 0 || rightStack.size() > 0) return false;\n  return true;\n}",
  "abstract_func": "bool ExpressionAnalyzer::flexibleEqual(Expression* VAR_0, Expression* VAR_1, ExprComparer VAR_2) {\n  std::vector<Name> VAR_3;\n  std::map<Name, std::vector<Name>> VAR_4; /* COMMENT_0 */\n  Nop VAR_5;\n  std::vector<Expression*> VAR_6;\n  std::vector<Expression*> VAR_7;\n\n  auto VAR_8 = [&](Name VAR_0, Name VAR_1) {\n    if (VAR_0.is() != VAR_1.is()) return false;\n    if (VAR_0.is()) {\n      VAR_3.push_back(VAR_0);\n      VAR_4[VAR_0].push_back(VAR_1);\n      VAR_6.push_back(&VAR_5);\n      VAR_7.push_back(&VAR_5);\n    }\n    return true;\n  };\n  auto VAR_9 = [&](Name VAR_0, Name VAR_1) {\n    auto VAR_10 = VAR_4.find(VAR_0);\n    if (VAR_10 == VAR_4.end()) return VAR_0 == VAR_1; /* COMMENT_1 */\n    return VAR_10->second.back() == VAR_1;\n  };\n  auto VAR_11 = [&]() {\n    auto VAR_0 = VAR_3.back();\n    VAR_3.pop_back();\n    VAR_4[VAR_0].pop_back();\n  };\n\n  VAR_6.push_back(VAR_0);\n  VAR_7.push_back(VAR_1);\n\n  while (VAR_6.size() > 0 && VAR_7.size() > 0) {\n    VAR_0 = VAR_6.back();\n    VAR_6.pop_back();\n    VAR_1 = VAR_7.back();\n    VAR_7.pop_back();\n    if (!VAR_0 != !VAR_1) return false;\n    if (!VAR_0) continue;\n    if (VAR_0 == &VAR_5) {\n      VAR_11();\n      continue;\n    }\n    if (VAR_2(VAR_0, VAR_1)) continue; /* COMMENT_2 */\n    /* COMMENT_3 */\n    if (VAR_0->_id != VAR_1->_id) return false;\n    /* COMMENT_4 */\n    #define CHECK(VAR_12, VAR_13) \\\n      if (left->cast<clazz>()->what != right->cast<clazz>()->what) return false;\n    switch (VAR_0->_id) {\n      case Expression::Id::BlockId: {\n        if (!VAR_8(VAR_0->cast<Block>()->name, VAR_1->cast<Block>()->name)) return false;\n        CHECK(Block, VAR_14.size());\n        break;\n      }\n      case Expression::Id::LoopId: {\n        if (!VAR_8(VAR_0->cast<Loop>()->name, VAR_1->cast<Loop>()->name)) return false;\n        break;\n      }\n      case Expression::Id::BreakId: {\n        if (!VAR_9(VAR_0->cast<Break>()->name, VAR_1->cast<Break>()->name)) return false;\n        break;\n      }\n      case Expression::Id::SwitchId: {\n        CHECK(VAR_15, VAR_16.size());\n        for (Index VAR_17 = 0; VAR_17 < VAR_0->cast<VAR_15>()->targets.size(); VAR_17++) {\n          if (!VAR_9(VAR_0->cast<Switch>()->targets[VAR_17], VAR_1->cast<Switch>()->targets[VAR_17])) return false;\n        }\n        if (!VAR_9(VAR_0->cast<Switch>()->default_, VAR_1->cast<Switch>()->default_)) return false;\n        break;\n      }\n      case Expression::Id::CallId: {\n        CHECK(VAR_18, VAR_19);\n        CHECK(VAR_18, VAR_20.size());\n        break;\n      }\n      case Expression::Id::CallIndirectId: {\n        CHECK(VAR_21, VAR_22);\n        CHECK(VAR_21, VAR_20.size());\n        break;\n      }\n      case Expression::Id::GetLocalId: {\n        CHECK(VAR_23, VAR_24);\n        break;\n      }\n      case Expression::Id::SetLocalId: {\n        CHECK(VAR_25, VAR_24);\n        CHECK(VAR_25, VAR_26); /* COMMENT_5 */\n        break;\n      }\n      case Expression::Id::GetGlobalId: {\n        CHECK(VAR_27, VAR_28);\n        break;\n      }\n      case Expression::Id::SetGlobalId: {\n        CHECK(VAR_29, VAR_28);\n        break;\n      }\n      case Expression::Id::LoadId: {\n        CHECK(VAR_30, VAR_31);\n        if (LoadUtils::isSignRelevant(VAR_0->cast<Load>()) &&\n            LoadUtils::isSignRelevant(VAR_1->cast<Load>())) {\n          CHECK(Load, VAR_32);\n        }\n        CHECK(Load, VAR_33);\n        CHECK(Load, VAR_34);\n        CHECK(Load, VAR_35);\n        break;\n      }\n      case Expression::Id::StoreId: {\n        CHECK(VAR_36, VAR_31);\n        CHECK(VAR_36, VAR_33);\n        CHECK(VAR_36, VAR_34);\n        CHECK(VAR_36, VAR_37);\n        CHECK(VAR_36, VAR_35);\n        break;\n      }\n      case Expression::Id::AtomicCmpxchgId: {\n        CHECK(VAR_38, VAR_31);\n        CHECK(VAR_38, VAR_33);\n        break;\n      }\n      case Expression::Id::AtomicRMWId: {\n        CHECK(VAR_39, VAR_40);\n        CHECK(VAR_39, VAR_31);\n        CHECK(VAR_39, VAR_33);\n        break;\n      }\n      case Expression::Id::AtomicWaitId: {\n        CHECK(VAR_41, VAR_42);\n        break;\n      }\n      case Expression::Id::AtomicWakeId: {\n        break;\n      }\n      case Expression::Id::SIMDExtractId: {\n        CHECK(VAR_43, VAR_40);\n        CHECK(VAR_43, VAR_24);\n        break;\n      }\n      case Expression::Id::SIMDReplaceId: {\n        CHECK(VAR_44, VAR_40);\n        CHECK(VAR_44, VAR_24);\n        break;\n      }\n      case Expression::Id::SIMDShuffleId: {\n        CHECK(VAR_45, VAR_46);\n        break;\n      }\n      case Expression::Id::SIMDBitselectId: {\n        break;\n      }\n      case Expression::Id::SIMDShiftId: {\n        CHECK(VAR_47, VAR_40);\n        break;\n      }\n      case Expression::Id::MemoryInitId: {\n        CHECK(VAR_48, VAR_49);\n        break;\n      }\n      case Expression::Id::DataDropId: {\n        CHECK(VAR_50, VAR_49);\n        break;\n      }\n      case Expression::Id::MemoryCopyId: {\n        break;\n      }\n      case Expression::Id::MemoryFillId: {\n        break;\n      }\n      case Expression::Id::ConstId: {\n        if (VAR_0->cast<Const>()->value != VAR_1->cast<Const>()->value) {\n          return false;\n        }\n        break;\n      }\n      case Expression::Id::UnaryId: {\n        CHECK(VAR_51, VAR_40);\n        break;\n      }\n      case Expression::Id::BinaryId: {\n        CHECK(VAR_52, VAR_40);\n        break;\n      }\n      case Expression::Id::HostId: {\n        CHECK(VAR_53, VAR_40);\n        CHECK(VAR_53, VAR_54);\n        CHECK(VAR_53, VAR_20.size());\n        break;\n      }\n      case Expression::Id::NopId: {\n        break;\n      }\n      case Expression::Id::UnreachableId: {\n        break;\n      }\n      case Expression::Id::InvalidId:\n      case Expression::Id::NumExpressionIds: {\n        WASM_UNREACHABLE();\n      }\n      case Expression::Id::IfId:\n      case Expression::Id::SelectId:\n      case Expression::Id::DropId:\n      case Expression::Id::ReturnId: {\n        break; /* COMMENT_6 */\n      }\n    }\n    /* COMMENT_7 */\n    for (auto* VAR_55 : ChildIterator(VAR_0)) {\n      VAR_6.push_back(VAR_55);\n    }\n    for (auto* VAR_55 : ChildIterator(VAR_1)) {\n      VAR_7.push_back(VAR_55);\n    }\n    #undef CHECK\n  }\n  if (VAR_6.size() > 0 || VAR_7.size() > 0) return false;\n  return true;\n}",
  "func_graph_path": "WebAssembly/binaryen/cc47475d76b21284565bd69b9701f50396d6068e/ExpressionAnalyzer.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -155,9 +155,6 @@\n       }\n       case Expression::Id::MemoryInitId: {\n         CHECK(MemoryInit, segment);\n-        PUSH(MemoryInit, dest);\n-        PUSH(MemoryInit, offset);\n-        PUSH(MemoryInit, size);\n         break;\n       }\n       case Expression::Id::DataDropId: {\n@@ -165,15 +162,9 @@\n         break;\n       }\n       case Expression::Id::MemoryCopyId: {\n-        PUSH(MemoryCopy, dest);\n-        PUSH(MemoryCopy, source);\n-        PUSH(MemoryCopy, size);\n         break;\n       }\n       case Expression::Id::MemoryFillId: {\n-        PUSH(MemoryFill, dest);\n-        PUSH(MemoryFill, value);\n-        PUSH(MemoryFill, size);\n         break;\n       }\n       case Expression::Id::ConstId: {\n@@ -221,7 +212,6 @@\n       rightStack.push_back(child);\n     }\n     #undef CHECK\n-    #undef PUSH\n   }\n   if (leftStack.size() > 0 || rightStack.size() > 0) return false;\n   return true;",
  "diff_line_info": {
    "deleted_lines": [
      "        PUSH(MemoryInit, dest);",
      "        PUSH(MemoryInit, offset);",
      "        PUSH(MemoryInit, size);",
      "        PUSH(MemoryCopy, dest);",
      "        PUSH(MemoryCopy, source);",
      "        PUSH(MemoryCopy, size);",
      "        PUSH(MemoryFill, dest);",
      "        PUSH(MemoryFill, value);",
      "        PUSH(MemoryFill, size);",
      "    #undef PUSH"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/binaryen/pull/1901",
  "description": {
    "pr_info": {
      "title": "Fix merge breakage",
      "number": 1901
    },
    "comment": [
      "We landed two PRs that had a logic conflict but not a source conflict (bulk memory added ops, comparison optimization removed the need for PUSH ops that bulk memory added).\r\n",
      "Landing to fix urgent breakage."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 1.0"
}