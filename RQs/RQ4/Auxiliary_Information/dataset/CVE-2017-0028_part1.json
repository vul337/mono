{
  "cve_id": "CVE-2017-0028",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "chakra-core/ChakraCore",
  "commit_msg": "[CVE-2017-0028] Fix binding of 'async' identifier in the presence of async arrow function.",
  "commit_hash": "402f3d967c0a905ec5b9ca9c240783d3f2c15724",
  "git_url": "https://github.com/chakra-core/ChakraCore/commit/402f3d967c0a905ec5b9ca9c240783d3f2c15724",
  "file_path": "lib/Parser/Parse.cpp",
  "func_name": "Parser::ParseTerm",
  "func_before": "ParseNodePtr Parser::ParseTerm(BOOL fAllowCall,\n    LPCOLESTR pNameHint,\n    uint32 *pHintLength,\n    uint32 *pShortNameOffset,\n    _Inout_opt_ IdentToken* pToken /*= nullptr*/,\n    bool fUnaryOrParen /*= false*/,\n    _Out_opt_ BOOL* pfCanAssign /*= nullptr*/,\n    _Inout_opt_ BOOL* pfLikelyPattern /*= nullptr*/,\n    _Out_opt_ bool* pfIsDotOrIndex /*= nullptr*/,\n    _Inout_opt_ charcount_t *plastRParen /*= nullptr*/)\n{\n    ParseNodePtr pnode = nullptr;\n    charcount_t ichMin = 0;\n    size_t iecpMin = 0;\n    size_t iuMin;\n    IdentToken term;\n    BOOL fInNew = FALSE;\n    BOOL fCanAssign = TRUE;\n    bool isAsyncExpr = false;\n    bool isLambdaExpr = false;\n    Assert(pToken == nullptr || pToken->tk == tkNone); // Must be empty initially\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n\n    switch (m_token.tk)\n    {\n    case tkID:\n    {\n        PidRefStack *ref = nullptr;\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n        charcount_t ichLim = m_pscan->IchLimTok();\n        size_t iecpLim = m_pscan->IecpLimTok();\n        ichMin = m_pscan->IchMinTok();\n        iecpMin  = m_pscan->IecpMinTok();\n\n        if (pid == wellKnownPropertyPids.async &&\n            m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            isAsyncExpr = true;\n        }\n\n        bool previousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(isAsyncExpr);\n        m_pscan->Scan();\n        m_pscan->SetAwaitIsKeyword(previousAwaitIsKeyword);\n\n        // We search for an Async expression (a function declaration or an async lambda expression)\n        if (isAsyncExpr && !m_pscan->FHadNewLine())\n        {\n            if (m_token.tk == tkFUNCTION)\n            {\n                goto LFunction;\n            }\n            else if (m_token.tk == tkID || m_token.tk == tkAWAIT)\n            {\n                isLambdaExpr = true;\n                goto LFunction;\n            }\n        }\n\n        // Don't push a reference if this is a single lambda parameter, because we'll reparse with\n        // a correct function ID.\n        if (m_token.tk != tkDArrow)\n        {\n            ref = this->PushPidRef(pid);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNameNode(pid);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = ichLim;\n            pnode->sxPid.SetSymRef(ref);\n        }\n        else\n        {\n            // Remember the identifier start and end in case it turns out to be a statement label.\n            term.tk = tkID;\n            term.pid = pid; // Record the identifier for detection of eval\n            term.ichMin = static_cast<charcount_t>(iecpMin);\n            term.ichLim = static_cast<charcount_t>(iecpLim);\n        }\n        CheckArgumentsUse(pid, GetCurrentFunctionNode());\n        break;\n    }\n\n    case tkTHIS:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopThis>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkLParen:\n    {\n        ichMin = m_pscan->IchMinTok();\n        iuMin = m_pscan->IecpMinTok();\n        m_pscan->Scan();\n        if (m_token.tk == tkRParen)\n        {\n            // Empty parens can only be legal as an empty parameter list to a lambda declaration.\n            // We're in a lambda if the next token is =>.\n            fAllowCall = FALSE;\n            m_pscan->Scan();\n\n            // If the token after the right paren is not => or if there was a newline between () and => this is a syntax error\n            if (!m_doingFastScan && (m_token.tk != tkDArrow || m_pscan->FHadNewLine()))\n            {\n                Error(ERRsyntax);\n            }\n\n            if (buildAST)\n            {\n                pnode = CreateNodeWithScanner<knopEmpty>();\n            }\n            break;\n        }\n\n        // Advance the block ID here in case this parenthetical expression turns out to be a lambda parameter list.\n        // That way the pid ref stacks will be created in their correct final form, and we can simply fix\n        // up function ID's.\n        uint saveNextBlockId = m_nextBlockId;\n        uint saveCurrBlockId = GetCurrentBlock()->sxBlock.blockId;\n        GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n\n        this->m_parenDepth++;\n        pnode = ParseExpr<buildAST>(koplNo, &fCanAssign, TRUE, FALSE, nullptr, nullptr /*nameLength*/, nullptr  /*pShortNameOffset*/, &term, true, nullptr, plastRParen);\n        this->m_parenDepth--;\n\n        if (buildAST && plastRParen)\n        {\n            *plastRParen = m_pscan->IchLimTok();\n        }\n\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        GetCurrentBlock()->sxBlock.blockId = saveCurrBlockId;\n        if (m_token.tk == tkDArrow)\n        {\n            // We're going to rewind and reinterpret the expression as a parameter list.\n            // Put back the original next-block-ID so the existing pid ref stacks will be correct.\n            m_nextBlockId = saveNextBlockId;\n        }\n\n        // Emit a deferred ... error if one was parsed.\n        if (m_deferEllipsisError && m_token.tk != tkDArrow)\n        {\n            m_pscan->SeekTo(m_EllipsisErrLoc);\n            Error(ERRInvalidSpreadUse);\n        }\n        else\n        {\n            m_deferEllipsisError = false;\n        }\n        break;\n    }\n\n    case tkIntCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateIntNodeWithScanner(m_token.GetLong());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFltCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFlt>();\n            pnode->sxFlt.dbl = m_token.GetDouble();\n            pnode->sxFlt.maybeInt = m_token.GetDoubleMayBeInt();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkStrCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateStrNodeWithScanner(m_token.GetStr());\n        }\n        else\n        {\n            // Subtract the string literal length from the total char count for the purpose\n            // of deciding whether to defer parsing and byte code generation.\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - m_pscan->IchMinTok());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkTRUE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopTrue>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFALSE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFalse>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNULL:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopNull>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkDiv:\n    case tkAsgDiv:\n        pnode = ParseRegExp<buildAST>();\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNEW:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n\n        if (m_token.tk == tkDot && m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseMetaProperty<buildAST>(tkNEW, ichMin, &fCanAssign);\n\n            m_pscan->Scan();\n        }\n        else\n        {\n            ParseNodePtr pnodeExpr = ParseTerm<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n            if (buildAST)\n            {\n                pnode = CreateCallNode(knopNew, pnodeExpr, nullptr);\n                pnode->ichMin = ichMin;\n            }\n            fInNew = TRUE;\n            fCanAssign = FALSE;\n        }\n        break;\n    }\n\n    case tkLBrack:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n        pnode = ParseArrayLiteral<buildAST>();\n        if (buildAST)\n        {\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n\n        if (this->m_arrayDepth == 0)\n        {\n            Assert(m_pscan->IchLimTok() - ichMin > m_funcInArray);\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - ichMin - this->m_funcInArray);\n            this->m_funcInArray = 0;\n            this->m_funcInArrayDepth = 0;\n        }\n        ChkCurTok(tkRBrack, ERRnoRbrack);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkLCurly:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->ScanForcingPid();\n        ParseNodePtr pnodeMemberList = ParseMemberList<buildAST>(pNameHint, pHintLength);\n        if (buildAST)\n        {\n            pnode = CreateUniNode(knopObject, pnodeMemberList);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n        ChkCurTok(tkRCurly, ERRnoRcurly);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkFUNCTION:\n    {\nLFunction :\n        if (m_grfscr & fscrDeferredFncExpression)\n        {\n            // The top-level deferred function body was defined by a function expression whose parsing was deferred. We are now\n            // parsing it, so unset the flag so that any nested functions are parsed normally. This flag is only applicable the\n            // first time we see it.\n            //\n            // Normally, deferred functions will be parsed in ParseStatement upon encountering the 'function' token. The first\n            // token of the source code of the function may not a 'function' token though, so we still need to reset this flag\n            // for the first function we parse. This can happen in compat modes, for instance, for a function expression enclosed\n            // in parentheses, where the legacy behavior was to include the parentheses in the function's source code.\n            m_grfscr &= ~fscrDeferredFncExpression;\n        }\n        ushort flags = fFncNoFlgs;\n        if (isLambdaExpr)\n        {\n            flags |= fFncLambda;\n        }\n        if (isAsyncExpr)\n        {\n            flags |= fFncAsync;\n        }\n        pnode = ParseFncDecl<buildAST>(flags, pNameHint, false, true, fUnaryOrParen);\n        if (isAsyncExpr)\n        {\n            pnode->sxFnc.cbMin = iecpMin;\n            pnode->ichMin = ichMin;\n        }\n        fCanAssign = FALSE;\n        break;\n    }\n\n    case tkCLASS:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseClassDecl<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        fCanAssign = FALSE;\n        break;\n\n    case tkStrTmplBasic:\n    case tkStrTmplBegin:\n        pnode = ParseStringTemplateDecl<buildAST>(nullptr);\n        fCanAssign = FALSE;\n        break;\n\n    case tkSUPER:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseSuper<buildAST>(pnode, !!fAllowCall);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        break;\n\n    case tkCASE:\n    {\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        ParseNodePtr pnodeUnused;\n        pnode = ParseCase<buildAST>(&pnodeUnused);\n        break;\n    }\n\n    case tkELSE:\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        m_pscan->Scan();\n        ParseStatement<buildAST>();\n        break;\n\n    default:\n    LUnknown :\n        Error(ERRsyntax);\n        break;\n    }\n\n    pnode = ParsePostfixOperators<buildAST>(pnode, fAllowCall, fInNew, isAsyncExpr, &fCanAssign, &term, pfIsDotOrIndex);\n\n    // Pass back identifier if requested\n    if (pToken && term.tk == tkID)\n    {\n        *pToken = term;\n    }\n\n    if (pfCanAssign)\n    {\n        *pfCanAssign = fCanAssign;\n    }\n\n    return pnode;\n}",
  "abstract_func_before": "ParseNodePtr Parser::ParseTerm(BOOL VAR_0,\n    LPCOLESTR VAR_1,\n    uint32 *VAR_2,\n    uint32 *VAR_3,\n    _Inout_opt_ VAR_4* VAR_5 /* COMMENT_0 */,\n    bool VAR_6 /* COMMENT_1 */,\n    _Out_opt_ BOOL* VAR_7 /* COMMENT_0 */,\n    _Inout_opt_ BOOL* VAR_8 /* COMMENT_0 */,\n    _Out_opt_ bool* VAR_9 /* COMMENT_0 */,\n    _Inout_opt_ VAR_10 *VAR_11 /* COMMENT_0 */)\n{\n    ParseNodePtr VAR_12 = nullptr;\n    charcount_t VAR_13 = 0;\n    size_t VAR_14 = 0;\n    size_t VAR_15;\n    IdentToken VAR_16;\n    BOOL VAR_17 = FALSE;\n    BOOL VAR_18 = TRUE;\n    bool VAR_19 = false;\n    bool VAR_20 = false;\n    Assert(VAR_5 == nullptr || VAR_5->tk == VAR_21); /* COMMENT_2 */\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(VAR_22, Js::Constants::MinStackParseOneTerm);\n    }\n    else\n    {\n        PROBE_STACK(VAR_22, Js::Constants::MinStackParseOneTerm);\n    }\n\n    switch (VAR_23.tk)\n    {\n    case VAR_24:\n    {\n        PidRefStack *VAR_25 = nullptr;\n        IdentPtr VAR_26 = VAR_23.GetIdentifier(VAR_27);\n        charcount_t VAR_28 = VAR_29->IchLimTok();\n        size_t VAR_30 = VAR_29->IecpLimTok();\n        VAR_13 = VAR_29->IchMinTok();\n        VAR_14  = VAR_29->IecpMinTok();\n\n        if (VAR_26 == VAR_31.async &&\n            VAR_22->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            VAR_19 = true;\n        }\n\n        bool VAR_32 = VAR_29->SetAwaitIsKeyword(VAR_19);\n        VAR_29->Scan();\n        VAR_29->SetAwaitIsKeyword(VAR_32);\n\n        /* COMMENT_3 */\n        if (VAR_19 && !VAR_29->FHadNewLine())\n        {\n            if (VAR_23.tk == VAR_33)\n            {\n                goto LFunction;\n            }\n            else if (VAR_23.tk == VAR_24 || VAR_23.tk == VAR_34)\n            {\n                VAR_20 = true;\n                goto LFunction;\n            }\n        }\n\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        if (VAR_23.tk != VAR_35)\n        {\n            VAR_25 = this->PushPidRef(VAR_26);\n        }\n\n        if (VAR_36)\n        {\n            VAR_12 = CreateNameNode(VAR_26);\n            VAR_12->ichMin = VAR_13;\n            VAR_12->ichLim = VAR_28;\n            VAR_12->sxPid.SetSymRef(VAR_25);\n        }\n        else\n        {\n            /* COMMENT_6 */\n            VAR_16.tk = VAR_24;\n            VAR_16.pid = VAR_26; /* COMMENT_7 */\n            VAR_16.ichMin = VAR_37<charcount_t>(VAR_14);\n            VAR_16.ichLim = VAR_37<charcount_t>(VAR_30);\n        }\n        CheckArgumentsUse(VAR_26, GetCurrentFunctionNode());\n        break;\n    }\n\n    case VAR_38:\n        if (VAR_36)\n        {\n            VAR_12 = VAR_39<knopThis>();\n        }\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_40:\n    {\n        VAR_13 = VAR_29->IchMinTok();\n        VAR_15 = VAR_29->IecpMinTok();\n        VAR_29->Scan();\n        if (VAR_23.tk == VAR_41)\n        {\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            VAR_0 = FALSE;\n            VAR_29->Scan();\n\n            /* COMMENT_10 */\n            if (!VAR_42 && (VAR_23.tk != VAR_35 || VAR_29->FHadNewLine()))\n            {\n                Error(VAR_43);\n            }\n\n            if (VAR_36)\n            {\n                VAR_12 = VAR_39<knopEmpty>();\n            }\n            break;\n        }\n\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        uint VAR_44 = VAR_45;\n        uint VAR_46 = GetCurrentBlock()->sxBlock.blockId;\n        GetCurrentBlock()->sxBlock.blockId = VAR_45++;\n\n        this->m_parenDepth++;\n        VAR_12 = VAR_47<buildAST>(VAR_48, &VAR_18, TRUE, FALSE, nullptr, nullptr /* COMMENT_14 */, nullptr  /* COMMENT_15 */, &VAR_16, true, nullptr, VAR_11);\n        this->m_parenDepth--;\n\n        if (buildAST && VAR_11)\n        {\n            *VAR_11 = VAR_29->IchLimTok();\n        }\n\n        ChkCurTok(VAR_41, VAR_49);\n\n        GetCurrentBlock()->sxBlock.blockId = VAR_46;\n        if (VAR_23.tk == VAR_35)\n        {\n            /* COMMENT_16 */\n            /* COMMENT_17 */\n            VAR_45 = VAR_44;\n        }\n\n        /* COMMENT_18 */\n        if (VAR_50 && VAR_23.tk != VAR_35)\n        {\n            VAR_29->SeekTo(VAR_51);\n            Error(VAR_52);\n        }\n        else\n        {\n            VAR_50 = false;\n        }\n        break;\n    }\n\n    case VAR_53:\n        if (IsStrictMode() && VAR_29->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(VAR_54);\n        }\n\n        if (buildAST)\n        {\n            VAR_12 = CreateIntNodeWithScanner(VAR_23.GetLong());\n        }\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_55:\n        if (IsStrictMode() && VAR_29->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(VAR_54);\n        }\n\n        if (buildAST)\n        {\n            VAR_12 = VAR_39<knopFlt>();\n            VAR_12->sxFlt.dbl = VAR_23.GetDouble();\n            VAR_12->sxFlt.maybeInt = VAR_23.GetDoubleMayBeInt();\n        }\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_56:\n        if (IsStrictMode() && VAR_29->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(VAR_54);\n        }\n\n        if (buildAST)\n        {\n            VAR_12 = CreateStrNodeWithScanner(VAR_23.GetStr());\n        }\n        else\n        {\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            this->ReduceDeferredScriptLength(VAR_29->IchLimTok() - VAR_29->IchMinTok());\n        }\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_57:\n        if (buildAST)\n        {\n            VAR_12 = VAR_39<knopTrue>();\n        }\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_58:\n        if (buildAST)\n        {\n            VAR_12 = VAR_39<knopFalse>();\n        }\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_59:\n        if (buildAST)\n        {\n            VAR_12 = VAR_39<knopNull>();\n        }\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_60:\n    case VAR_61:\n        VAR_12 = VAR_62<buildAST>();\n        VAR_18 = FALSE;\n        VAR_29->Scan();\n        break;\n\n    case VAR_63:\n    {\n        VAR_13 = VAR_29->IchMinTok();\n        VAR_29->Scan();\n\n        if (VAR_23.tk == VAR_64 && VAR_22->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            VAR_12 = VAR_65<buildAST>(VAR_63, VAR_13, &VAR_18);\n\n            VAR_29->Scan();\n        }\n        else\n        {\n            ParseNodePtr VAR_66 = VAR_67<buildAST>(FALSE, VAR_1, VAR_2, VAR_3);\n            if (buildAST)\n            {\n                VAR_12 = CreateCallNode(VAR_68, VAR_66, nullptr);\n                VAR_12->ichMin = VAR_13;\n            }\n            VAR_17 = TRUE;\n            VAR_18 = FALSE;\n        }\n        break;\n    }\n\n    case VAR_69:\n    {\n        VAR_13 = VAR_29->IchMinTok();\n        VAR_29->Scan();\n        VAR_12 = VAR_70<buildAST>();\n        if (buildAST)\n        {\n            VAR_12->ichMin = VAR_13;\n            VAR_12->ichLim = VAR_29->IchLimTok();\n        }\n\n        if (this->m_arrayDepth == 0)\n        {\n            Assert(VAR_29->IchLimTok() - VAR_13 > VAR_71);\n            this->ReduceDeferredScriptLength(VAR_29->IchLimTok() - VAR_13 - this->m_funcInArray);\n            this->m_funcInArray = 0;\n            this->m_funcInArrayDepth = 0;\n        }\n        ChkCurTok(VAR_72, VAR_73);\n        if (!IsES6DestructuringEnabled())\n        {\n            VAR_18 = FALSE;\n        }\n        else if (VAR_8 != nullptr && !IsPostFixOperators())\n        {\n            *VAR_8 = TRUE;\n        }\n        break;\n    }\n\n    case VAR_74:\n    {\n        VAR_13 = VAR_29->IchMinTok();\n        VAR_29->ScanForcingPid();\n        ParseNodePtr VAR_75 = VAR_76<buildAST>(VAR_1, VAR_2);\n        if (buildAST)\n        {\n            VAR_12 = CreateUniNode(VAR_77, VAR_75);\n            VAR_12->ichMin = VAR_13;\n            VAR_12->ichLim = VAR_29->IchLimTok();\n        }\n        ChkCurTok(VAR_78, VAR_79);\n        if (!IsES6DestructuringEnabled())\n        {\n            VAR_18 = FALSE;\n        }\n        else if (VAR_8 != nullptr && !IsPostFixOperators())\n        {\n            *VAR_8 = TRUE;\n        }\n        break;\n    }\n\n    case VAR_33:\n    {\nLFunction :\n        if (VAR_80 & VAR_81)\n        {\n            /* COMMENT_21 */\n            /* COMMENT_22 */\n            /* COMMENT_23 */\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            /* COMMENT_26 */\n            /* COMMENT_27 */\n            /* COMMENT_28 */\n            VAR_80 &= ~VAR_81;\n        }\n        ushort VAR_82 = VAR_83;\n        if (VAR_20)\n        {\n            VAR_82 |= VAR_84;\n        }\n        if (VAR_19)\n        {\n            VAR_82 |= VAR_85;\n        }\n        VAR_12 = VAR_86<buildAST>(VAR_82, VAR_1, false, true, VAR_6);\n        if (VAR_19)\n        {\n            VAR_12->sxFnc.cbMin = VAR_14;\n            VAR_12->ichMin = VAR_13;\n        }\n        VAR_18 = FALSE;\n        break;\n    }\n\n    case VAR_87:\n        if (VAR_22->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            VAR_12 = VAR_88<buildAST>(FALSE, VAR_1, VAR_2, VAR_3);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        VAR_18 = FALSE;\n        break;\n\n    case VAR_89:\n    case VAR_90:\n        VAR_12 = VAR_91<buildAST>(nullptr);\n        VAR_18 = FALSE;\n        break;\n\n    case VAR_92:\n        if (VAR_22->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            VAR_12 = VAR_93<buildAST>(VAR_12, !!VAR_0);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        break;\n\n    case VAR_94:\n    {\n        if (!VAR_42)\n        {\n            goto LUnknown;\n        }\n        ParseNodePtr VAR_95;\n        VAR_12 = VAR_96<buildAST>(&VAR_95);\n        break;\n    }\n\n    case VAR_97:\n        if (!VAR_42)\n        {\n            goto LUnknown;\n        }\n        VAR_29->Scan();\n        VAR_98<buildAST>();\n        break;\n\n    default:\n    LUnknown :\n        Error(VAR_43);\n        break;\n    }\n\n    VAR_12 = VAR_99<buildAST>(VAR_12, VAR_0, VAR_17, VAR_19, &VAR_18, &VAR_16, VAR_9);\n\n    /* COMMENT_29 */\n    if (VAR_5 && VAR_16.tk == VAR_24)\n    {\n        *VAR_5 = VAR_16;\n    }\n\n    if (VAR_7)\n    {\n        *VAR_7 = VAR_18;\n    }\n\n    return VAR_12;\n}",
  "func_graph_path_before": null,
  "func": "ParseNodePtr Parser::ParseTerm(BOOL fAllowCall,\n    LPCOLESTR pNameHint,\n    uint32 *pHintLength,\n    uint32 *pShortNameOffset,\n    _Inout_opt_ IdentToken* pToken /*= nullptr*/,\n    bool fUnaryOrParen /*= false*/,\n    _Out_opt_ BOOL* pfCanAssign /*= nullptr*/,\n    _Inout_opt_ BOOL* pfLikelyPattern /*= nullptr*/,\n    _Out_opt_ bool* pfIsDotOrIndex /*= nullptr*/,\n    _Inout_opt_ charcount_t *plastRParen /*= nullptr*/)\n{\n    ParseNodePtr pnode = nullptr;\n    PidRefStack *savedTopAsyncRef = nullptr;\n    charcount_t ichMin = 0;\n    size_t iecpMin = 0;\n    size_t iuMin;\n    IdentToken term;\n    BOOL fInNew = FALSE;\n    BOOL fCanAssign = TRUE;\n    bool isAsyncExpr = false;\n    bool isLambdaExpr = false;\n    Assert(pToken == nullptr || pToken->tk == tkNone); // Must be empty initially\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n    else\n    {\n        PROBE_STACK(m_scriptContext, Js::Constants::MinStackParseOneTerm);\n    }\n\n    switch (m_token.tk)\n    {\n    case tkID:\n    {\n        PidRefStack *ref = nullptr;\n        IdentPtr pid = m_token.GetIdentifier(m_phtbl);\n        charcount_t ichLim = m_pscan->IchLimTok();\n        size_t iecpLim = m_pscan->IecpLimTok();\n        ichMin = m_pscan->IchMinTok();\n        iecpMin  = m_pscan->IecpMinTok();\n\n        if (pid == wellKnownPropertyPids.async &&\n            m_scriptContext->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            isAsyncExpr = true;\n        }\n\n        bool previousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(isAsyncExpr);\n        m_pscan->Scan();\n        m_pscan->SetAwaitIsKeyword(previousAwaitIsKeyword);\n\n        // We search for an Async expression (a function declaration or an async lambda expression)\n        if (isAsyncExpr && !m_pscan->FHadNewLine())\n        {\n            if (m_token.tk == tkFUNCTION)\n            {\n                goto LFunction;\n            }\n            else if (m_token.tk == tkID || m_token.tk == tkAWAIT)\n            {\n                isLambdaExpr = true;\n                goto LFunction;\n            }\n            else if (m_token.tk == tkLParen)\n            {\n                // This is potentially an async arrow function. Save the state of the async references\n                // in case it needs to be restored. (Note that the case of a single parameter with no ()'s\n                // is detected upstream and need not be handled here.)\n                savedTopAsyncRef = pid->GetTopRef();\n            }\n        }\n\n        // Don't push a reference if this is a single lambda parameter, because we'll reparse with\n        // a correct function ID.\n        if (m_token.tk != tkDArrow)\n        {\n            ref = this->PushPidRef(pid);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNameNode(pid);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = ichLim;\n            pnode->sxPid.SetSymRef(ref);\n        }\n        else\n        {\n            // Remember the identifier start and end in case it turns out to be a statement label.\n            term.tk = tkID;\n            term.pid = pid; // Record the identifier for detection of eval\n            term.ichMin = static_cast<charcount_t>(iecpMin);\n            term.ichLim = static_cast<charcount_t>(iecpLim);\n        }\n        CheckArgumentsUse(pid, GetCurrentFunctionNode());\n        break;\n    }\n\n    case tkTHIS:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopThis>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkLParen:\n    {\n        ichMin = m_pscan->IchMinTok();\n        iuMin = m_pscan->IecpMinTok();\n        m_pscan->Scan();\n        if (m_token.tk == tkRParen)\n        {\n            // Empty parens can only be legal as an empty parameter list to a lambda declaration.\n            // We're in a lambda if the next token is =>.\n            fAllowCall = FALSE;\n            m_pscan->Scan();\n\n            // If the token after the right paren is not => or if there was a newline between () and => this is a syntax error\n            if (!m_doingFastScan && (m_token.tk != tkDArrow || m_pscan->FHadNewLine()))\n            {\n                Error(ERRsyntax);\n            }\n\n            if (buildAST)\n            {\n                pnode = CreateNodeWithScanner<knopEmpty>();\n            }\n            break;\n        }\n\n        // Advance the block ID here in case this parenthetical expression turns out to be a lambda parameter list.\n        // That way the pid ref stacks will be created in their correct final form, and we can simply fix\n        // up function ID's.\n        uint saveNextBlockId = m_nextBlockId;\n        uint saveCurrBlockId = GetCurrentBlock()->sxBlock.blockId;\n        GetCurrentBlock()->sxBlock.blockId = m_nextBlockId++;\n\n        this->m_parenDepth++;\n        pnode = ParseExpr<buildAST>(koplNo, &fCanAssign, TRUE, FALSE, nullptr, nullptr /*nameLength*/, nullptr  /*pShortNameOffset*/, &term, true, nullptr, plastRParen);\n        this->m_parenDepth--;\n\n        if (buildAST && plastRParen)\n        {\n            *plastRParen = m_pscan->IchLimTok();\n        }\n\n        ChkCurTok(tkRParen, ERRnoRparen);\n\n        GetCurrentBlock()->sxBlock.blockId = saveCurrBlockId;\n        if (m_token.tk == tkDArrow)\n        {\n            // We're going to rewind and reinterpret the expression as a parameter list.\n            // Put back the original next-block-ID so the existing pid ref stacks will be correct.\n            m_nextBlockId = saveNextBlockId;\n        }\n\n        // Emit a deferred ... error if one was parsed.\n        if (m_deferEllipsisError && m_token.tk != tkDArrow)\n        {\n            m_pscan->SeekTo(m_EllipsisErrLoc);\n            Error(ERRInvalidSpreadUse);\n        }\n        else\n        {\n            m_deferEllipsisError = false;\n        }\n        break;\n    }\n\n    case tkIntCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateIntNodeWithScanner(m_token.GetLong());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFltCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFlt>();\n            pnode->sxFlt.dbl = m_token.GetDouble();\n            pnode->sxFlt.maybeInt = m_token.GetDoubleMayBeInt();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkStrCon:\n        if (IsStrictMode() && m_pscan->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(ERRES5NoOctal);\n        }\n\n        if (buildAST)\n        {\n            pnode = CreateStrNodeWithScanner(m_token.GetStr());\n        }\n        else\n        {\n            // Subtract the string literal length from the total char count for the purpose\n            // of deciding whether to defer parsing and byte code generation.\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - m_pscan->IchMinTok());\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkTRUE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopTrue>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkFALSE:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopFalse>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNULL:\n        if (buildAST)\n        {\n            pnode = CreateNodeWithScanner<knopNull>();\n        }\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkDiv:\n    case tkAsgDiv:\n        pnode = ParseRegExp<buildAST>();\n        fCanAssign = FALSE;\n        m_pscan->Scan();\n        break;\n\n    case tkNEW:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n\n        if (m_token.tk == tkDot && m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseMetaProperty<buildAST>(tkNEW, ichMin, &fCanAssign);\n\n            m_pscan->Scan();\n        }\n        else\n        {\n            ParseNodePtr pnodeExpr = ParseTerm<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n            if (buildAST)\n            {\n                pnode = CreateCallNode(knopNew, pnodeExpr, nullptr);\n                pnode->ichMin = ichMin;\n            }\n            fInNew = TRUE;\n            fCanAssign = FALSE;\n        }\n        break;\n    }\n\n    case tkLBrack:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->Scan();\n        pnode = ParseArrayLiteral<buildAST>();\n        if (buildAST)\n        {\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n\n        if (this->m_arrayDepth == 0)\n        {\n            Assert(m_pscan->IchLimTok() - ichMin > m_funcInArray);\n            this->ReduceDeferredScriptLength(m_pscan->IchLimTok() - ichMin - this->m_funcInArray);\n            this->m_funcInArray = 0;\n            this->m_funcInArrayDepth = 0;\n        }\n        ChkCurTok(tkRBrack, ERRnoRbrack);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkLCurly:\n    {\n        ichMin = m_pscan->IchMinTok();\n        m_pscan->ScanForcingPid();\n        ParseNodePtr pnodeMemberList = ParseMemberList<buildAST>(pNameHint, pHintLength);\n        if (buildAST)\n        {\n            pnode = CreateUniNode(knopObject, pnodeMemberList);\n            pnode->ichMin = ichMin;\n            pnode->ichLim = m_pscan->IchLimTok();\n        }\n        ChkCurTok(tkRCurly, ERRnoRcurly);\n        if (!IsES6DestructuringEnabled())\n        {\n            fCanAssign = FALSE;\n        }\n        else if (pfLikelyPattern != nullptr && !IsPostFixOperators())\n        {\n            *pfLikelyPattern = TRUE;\n        }\n        break;\n    }\n\n    case tkFUNCTION:\n    {\nLFunction :\n        if (m_grfscr & fscrDeferredFncExpression)\n        {\n            // The top-level deferred function body was defined by a function expression whose parsing was deferred. We are now\n            // parsing it, so unset the flag so that any nested functions are parsed normally. This flag is only applicable the\n            // first time we see it.\n            //\n            // Normally, deferred functions will be parsed in ParseStatement upon encountering the 'function' token. The first\n            // token of the source code of the function may not a 'function' token though, so we still need to reset this flag\n            // for the first function we parse. This can happen in compat modes, for instance, for a function expression enclosed\n            // in parentheses, where the legacy behavior was to include the parentheses in the function's source code.\n            m_grfscr &= ~fscrDeferredFncExpression;\n        }\n        ushort flags = fFncNoFlgs;\n        if (isLambdaExpr)\n        {\n            flags |= fFncLambda;\n        }\n        if (isAsyncExpr)\n        {\n            flags |= fFncAsync;\n        }\n        pnode = ParseFncDecl<buildAST>(flags, pNameHint, false, true, fUnaryOrParen);\n        if (isAsyncExpr)\n        {\n            pnode->sxFnc.cbMin = iecpMin;\n            pnode->ichMin = ichMin;\n        }\n        fCanAssign = FALSE;\n        break;\n    }\n\n    case tkCLASS:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseClassDecl<buildAST>(FALSE, pNameHint, pHintLength, pShortNameOffset);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        fCanAssign = FALSE;\n        break;\n\n    case tkStrTmplBasic:\n    case tkStrTmplBegin:\n        pnode = ParseStringTemplateDecl<buildAST>(nullptr);\n        fCanAssign = FALSE;\n        break;\n\n    case tkSUPER:\n        if (m_scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            pnode = ParseSuper<buildAST>(pnode, !!fAllowCall);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        break;\n\n    case tkCASE:\n    {\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        ParseNodePtr pnodeUnused;\n        pnode = ParseCase<buildAST>(&pnodeUnused);\n        break;\n    }\n\n    case tkELSE:\n        if (!m_doingFastScan)\n        {\n            goto LUnknown;\n        }\n        m_pscan->Scan();\n        ParseStatement<buildAST>();\n        break;\n\n    default:\n    LUnknown :\n        Error(ERRsyntax);\n        break;\n    }\n\n    pnode = ParsePostfixOperators<buildAST>(pnode, fAllowCall, fInNew, isAsyncExpr, &fCanAssign, &term, pfIsDotOrIndex);\n\n    if (savedTopAsyncRef != nullptr &&\n        this->m_token.tk == tkDArrow)\n    {\n        // This is an async arrow function; we're going to back up and reparse it.\n        // Make sure we don't leave behind a bogus reference to the 'async' identifier.\n        for (IdentPtr pid = wellKnownPropertyPids.async; pid->GetTopRef() != savedTopAsyncRef;)\n        {\n            Assert(pid->GetTopRef() != nullptr);\n            pid->RemovePrevPidRef(nullptr);\n        }\n    }\n\n    // Pass back identifier if requested\n    if (pToken && term.tk == tkID)\n    {\n        *pToken = term;\n    }\n\n    if (pfCanAssign)\n    {\n        *pfCanAssign = fCanAssign;\n    }\n\n    return pnode;\n}",
  "abstract_func": "ParseNodePtr Parser::ParseTerm(BOOL VAR_0,\n    LPCOLESTR VAR_1,\n    uint32 *VAR_2,\n    uint32 *VAR_3,\n    _Inout_opt_ VAR_4* VAR_5 /* COMMENT_0 */,\n    bool VAR_6 /* COMMENT_1 */,\n    _Out_opt_ BOOL* VAR_7 /* COMMENT_0 */,\n    _Inout_opt_ BOOL* VAR_8 /* COMMENT_0 */,\n    _Out_opt_ bool* VAR_9 /* COMMENT_0 */,\n    _Inout_opt_ VAR_10 *VAR_11 /* COMMENT_0 */)\n{\n    ParseNodePtr VAR_12 = nullptr;\n    PidRefStack *VAR_13 = nullptr;\n    charcount_t VAR_14 = 0;\n    size_t VAR_15 = 0;\n    size_t VAR_16;\n    IdentToken VAR_17;\n    BOOL VAR_18 = FALSE;\n    BOOL VAR_19 = TRUE;\n    bool VAR_20 = false;\n    bool VAR_21 = false;\n    Assert(VAR_5 == nullptr || VAR_5->tk == VAR_22); /* COMMENT_2 */\n\n    if (this->IsBackgroundParser())\n    {\n        PROBE_STACK_NO_DISPOSE(VAR_23, Js::Constants::MinStackParseOneTerm);\n    }\n    else\n    {\n        PROBE_STACK(VAR_23, Js::Constants::MinStackParseOneTerm);\n    }\n\n    switch (VAR_24.tk)\n    {\n    case VAR_25:\n    {\n        PidRefStack *VAR_26 = nullptr;\n        IdentPtr VAR_27 = VAR_24.GetIdentifier(VAR_28);\n        charcount_t VAR_29 = VAR_30->IchLimTok();\n        size_t VAR_31 = VAR_30->IecpLimTok();\n        VAR_14 = VAR_30->IchMinTok();\n        VAR_15  = VAR_30->IecpMinTok();\n\n        if (VAR_27 == VAR_32.async &&\n            VAR_23->GetConfig()->IsES7AsyncAndAwaitEnabled())\n        {\n            VAR_20 = true;\n        }\n\n        bool VAR_33 = VAR_30->SetAwaitIsKeyword(VAR_20);\n        VAR_30->Scan();\n        VAR_30->SetAwaitIsKeyword(VAR_33);\n\n        /* COMMENT_3 */\n        if (VAR_20 && !VAR_30->FHadNewLine())\n        {\n            if (VAR_24.tk == VAR_34)\n            {\n                goto LFunction;\n            }\n            else if (VAR_24.tk == VAR_25 || VAR_24.tk == VAR_35)\n            {\n                VAR_21 = true;\n                goto LFunction;\n            }\n            else if (VAR_24.tk == VAR_36)\n            {\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                VAR_13 = VAR_27->GetTopRef();\n            }\n        }\n\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_24.tk != VAR_37)\n        {\n            VAR_26 = this->PushPidRef(VAR_27);\n        }\n\n        if (VAR_38)\n        {\n            VAR_12 = CreateNameNode(VAR_27);\n            VAR_12->ichMin = VAR_14;\n            VAR_12->ichLim = VAR_29;\n            VAR_12->sxPid.SetSymRef(VAR_26);\n        }\n        else\n        {\n            /* COMMENT_9 */\n            VAR_17.tk = VAR_25;\n            VAR_17.pid = VAR_27; /* COMMENT_10 */\n            VAR_17.ichMin = VAR_39<charcount_t>(VAR_15);\n            VAR_17.ichLim = VAR_39<charcount_t>(VAR_31);\n        }\n        CheckArgumentsUse(VAR_27, GetCurrentFunctionNode());\n        break;\n    }\n\n    case VAR_40:\n        if (VAR_38)\n        {\n            VAR_12 = VAR_41<knopThis>();\n        }\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_36:\n    {\n        VAR_14 = VAR_30->IchMinTok();\n        VAR_16 = VAR_30->IecpMinTok();\n        VAR_30->Scan();\n        if (VAR_24.tk == VAR_42)\n        {\n            /* COMMENT_11 */\n            /* COMMENT_12 */\n            VAR_0 = FALSE;\n            VAR_30->Scan();\n\n            /* COMMENT_13 */\n            if (!VAR_43 && (VAR_24.tk != VAR_37 || VAR_30->FHadNewLine()))\n            {\n                Error(VAR_44);\n            }\n\n            if (VAR_38)\n            {\n                VAR_12 = VAR_41<knopEmpty>();\n            }\n            break;\n        }\n\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        uint VAR_45 = VAR_46;\n        uint VAR_47 = GetCurrentBlock()->sxBlock.blockId;\n        GetCurrentBlock()->sxBlock.blockId = VAR_46++;\n\n        this->m_parenDepth++;\n        VAR_12 = VAR_48<buildAST>(VAR_49, &VAR_19, TRUE, FALSE, nullptr, nullptr /* COMMENT_17 */, nullptr  /* COMMENT_18 */, &VAR_17, true, nullptr, VAR_11);\n        this->m_parenDepth--;\n\n        if (buildAST && VAR_11)\n        {\n            *VAR_11 = VAR_30->IchLimTok();\n        }\n\n        ChkCurTok(VAR_42, VAR_50);\n\n        GetCurrentBlock()->sxBlock.blockId = VAR_47;\n        if (VAR_24.tk == VAR_37)\n        {\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            VAR_46 = VAR_45;\n        }\n\n        /* COMMENT_21 */\n        if (VAR_51 && VAR_24.tk != VAR_37)\n        {\n            VAR_30->SeekTo(VAR_52);\n            Error(VAR_53);\n        }\n        else\n        {\n            VAR_51 = false;\n        }\n        break;\n    }\n\n    case VAR_54:\n        if (IsStrictMode() && VAR_30->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(VAR_55);\n        }\n\n        if (buildAST)\n        {\n            VAR_12 = CreateIntNodeWithScanner(VAR_24.GetLong());\n        }\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_56:\n        if (IsStrictMode() && VAR_30->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(VAR_55);\n        }\n\n        if (buildAST)\n        {\n            VAR_12 = VAR_41<knopFlt>();\n            VAR_12->sxFlt.dbl = VAR_24.GetDouble();\n            VAR_12->sxFlt.maybeInt = VAR_24.GetDoubleMayBeInt();\n        }\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_57:\n        if (IsStrictMode() && VAR_30->IsOctOrLeadingZeroOnLastTKNumber())\n        {\n            Error(VAR_55);\n        }\n\n        if (buildAST)\n        {\n            VAR_12 = CreateStrNodeWithScanner(VAR_24.GetStr());\n        }\n        else\n        {\n            /* COMMENT_22 */\n            /* COMMENT_23 */\n            this->ReduceDeferredScriptLength(VAR_30->IchLimTok() - VAR_30->IchMinTok());\n        }\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_58:\n        if (buildAST)\n        {\n            VAR_12 = VAR_41<knopTrue>();\n        }\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_59:\n        if (buildAST)\n        {\n            VAR_12 = VAR_41<knopFalse>();\n        }\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_60:\n        if (buildAST)\n        {\n            VAR_12 = VAR_41<knopNull>();\n        }\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_61:\n    case VAR_62:\n        VAR_12 = VAR_63<buildAST>();\n        VAR_19 = FALSE;\n        VAR_30->Scan();\n        break;\n\n    case VAR_64:\n    {\n        VAR_14 = VAR_30->IchMinTok();\n        VAR_30->Scan();\n\n        if (VAR_24.tk == VAR_65 && VAR_23->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            VAR_12 = VAR_66<buildAST>(VAR_64, VAR_14, &VAR_19);\n\n            VAR_30->Scan();\n        }\n        else\n        {\n            ParseNodePtr VAR_67 = VAR_68<buildAST>(FALSE, VAR_1, VAR_2, VAR_3);\n            if (buildAST)\n            {\n                VAR_12 = CreateCallNode(VAR_69, VAR_67, nullptr);\n                VAR_12->ichMin = VAR_14;\n            }\n            VAR_18 = TRUE;\n            VAR_19 = FALSE;\n        }\n        break;\n    }\n\n    case VAR_70:\n    {\n        VAR_14 = VAR_30->IchMinTok();\n        VAR_30->Scan();\n        VAR_12 = VAR_71<buildAST>();\n        if (buildAST)\n        {\n            VAR_12->ichMin = VAR_14;\n            VAR_12->ichLim = VAR_30->IchLimTok();\n        }\n\n        if (this->m_arrayDepth == 0)\n        {\n            Assert(VAR_30->IchLimTok() - VAR_14 > VAR_72);\n            this->ReduceDeferredScriptLength(VAR_30->IchLimTok() - VAR_14 - this->m_funcInArray);\n            this->m_funcInArray = 0;\n            this->m_funcInArrayDepth = 0;\n        }\n        ChkCurTok(VAR_73, VAR_74);\n        if (!IsES6DestructuringEnabled())\n        {\n            VAR_19 = FALSE;\n        }\n        else if (VAR_8 != nullptr && !IsPostFixOperators())\n        {\n            *VAR_8 = TRUE;\n        }\n        break;\n    }\n\n    case VAR_75:\n    {\n        VAR_14 = VAR_30->IchMinTok();\n        VAR_30->ScanForcingPid();\n        ParseNodePtr VAR_76 = VAR_77<buildAST>(VAR_1, VAR_2);\n        if (buildAST)\n        {\n            VAR_12 = CreateUniNode(VAR_78, VAR_76);\n            VAR_12->ichMin = VAR_14;\n            VAR_12->ichLim = VAR_30->IchLimTok();\n        }\n        ChkCurTok(VAR_79, VAR_80);\n        if (!IsES6DestructuringEnabled())\n        {\n            VAR_19 = FALSE;\n        }\n        else if (VAR_8 != nullptr && !IsPostFixOperators())\n        {\n            *VAR_8 = TRUE;\n        }\n        break;\n    }\n\n    case VAR_34:\n    {\nLFunction :\n        if (VAR_81 & VAR_82)\n        {\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            /* COMMENT_26 */\n            /* COMMENT_27 */\n            /* COMMENT_28 */\n            /* COMMENT_29 */\n            /* COMMENT_30 */\n            /* COMMENT_31 */\n            VAR_81 &= ~VAR_82;\n        }\n        ushort VAR_83 = VAR_84;\n        if (VAR_21)\n        {\n            VAR_83 |= VAR_85;\n        }\n        if (VAR_20)\n        {\n            VAR_83 |= VAR_86;\n        }\n        VAR_12 = VAR_87<buildAST>(VAR_83, VAR_1, false, true, VAR_6);\n        if (VAR_20)\n        {\n            VAR_12->sxFnc.cbMin = VAR_15;\n            VAR_12->ichMin = VAR_14;\n        }\n        VAR_19 = FALSE;\n        break;\n    }\n\n    case VAR_88:\n        if (VAR_23->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            VAR_12 = VAR_89<buildAST>(FALSE, VAR_1, VAR_2, VAR_3);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        VAR_19 = FALSE;\n        break;\n\n    case VAR_90:\n    case VAR_91:\n        VAR_12 = VAR_92<buildAST>(nullptr);\n        VAR_19 = FALSE;\n        break;\n\n    case VAR_93:\n        if (VAR_23->GetConfig()->IsES6ClassAndExtendsEnabled())\n        {\n            VAR_12 = VAR_94<buildAST>(VAR_12, !!VAR_0);\n        }\n        else\n        {\n            goto LUnknown;\n        }\n        break;\n\n    case VAR_95:\n    {\n        if (!VAR_43)\n        {\n            goto LUnknown;\n        }\n        ParseNodePtr VAR_96;\n        VAR_12 = VAR_97<buildAST>(&VAR_96);\n        break;\n    }\n\n    case VAR_98:\n        if (!VAR_43)\n        {\n            goto LUnknown;\n        }\n        VAR_30->Scan();\n        VAR_99<buildAST>();\n        break;\n\n    default:\n    LUnknown :\n        Error(VAR_44);\n        break;\n    }\n\n    VAR_12 = VAR_100<buildAST>(VAR_12, VAR_0, VAR_18, VAR_20, &VAR_19, &VAR_17, VAR_9);\n\n    if (VAR_13 != nullptr &&\n        this->m_token.tk == VAR_37)\n    {\n        /* COMMENT_32 */\n        /* COMMENT_33 */\n        for (IdentPtr VAR_27 = VAR_32.async; VAR_27->GetTopRef() != VAR_13;)\n        {\n            Assert(VAR_27->GetTopRef() != nullptr);\n            VAR_27->RemovePrevPidRef(nullptr);\n        }\n    }\n\n    /* COMMENT_34 */\n    if (VAR_5 && VAR_17.tk == VAR_25)\n    {\n        *VAR_5 = VAR_17;\n    }\n\n    if (VAR_7)\n    {\n        *VAR_7 = VAR_19;\n    }\n\n    return VAR_12;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n     _Inout_opt_ charcount_t *plastRParen /*= nullptr*/)\n {\n     ParseNodePtr pnode = nullptr;\n+    PidRefStack *savedTopAsyncRef = nullptr;\n     charcount_t ichMin = 0;\n     size_t iecpMin = 0;\n     size_t iuMin;\n@@ -62,6 +63,13 @@\n                 isLambdaExpr = true;\n                 goto LFunction;\n             }\n+            else if (m_token.tk == tkLParen)\n+            {\n+                // This is potentially an async arrow function. Save the state of the async references\n+                // in case it needs to be restored. (Note that the case of a single parameter with no ()'s\n+                // is detected upstream and need not be handled here.)\n+                savedTopAsyncRef = pid->GetTopRef();\n+            }\n         }\n \n         // Don't push a reference if this is a single lambda parameter, because we'll reparse with\n@@ -416,6 +424,18 @@\n \n     pnode = ParsePostfixOperators<buildAST>(pnode, fAllowCall, fInNew, isAsyncExpr, &fCanAssign, &term, pfIsDotOrIndex);\n \n+    if (savedTopAsyncRef != nullptr &&\n+        this->m_token.tk == tkDArrow)\n+    {\n+        // This is an async arrow function; we're going to back up and reparse it.\n+        // Make sure we don't leave behind a bogus reference to the 'async' identifier.\n+        for (IdentPtr pid = wellKnownPropertyPids.async; pid->GetTopRef() != savedTopAsyncRef;)\n+        {\n+            Assert(pid->GetTopRef() != nullptr);\n+            pid->RemovePrevPidRef(nullptr);\n+        }\n+    }\n+\n     // Pass back identifier if requested\n     if (pToken && term.tk == tkID)\n     {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    PidRefStack *savedTopAsyncRef = nullptr;",
      "            else if (m_token.tk == tkLParen)",
      "            {",
      "                // This is potentially an async arrow function. Save the state of the async references",
      "                // in case it needs to be restored. (Note that the case of a single parameter with no ()'s",
      "                // is detected upstream and need not be handled here.)",
      "                savedTopAsyncRef = pid->GetTopRef();",
      "            }",
      "    if (savedTopAsyncRef != nullptr &&",
      "        this->m_token.tk == tkDArrow)",
      "    {",
      "        // This is an async arrow function; we're going to back up and reparse it.",
      "        // Make sure we don't leave behind a bogus reference to the 'async' identifier.",
      "        for (IdentPtr pid = wellKnownPropertyPids.async; pid->GetTopRef() != savedTopAsyncRef;)",
      "        {",
      "            Assert(pid->GetTopRef() != nullptr);",
      "            pid->RemovePrevPidRef(nullptr);",
      "        }",
      "    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/chakra-core/ChakraCore/pull/2697",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/chakra-core/ChakraCore/pull/2697: 403 Client Error: Forbidden for url: https://api.github.com/repos/chakra-core/ChakraCore/pulls/2697",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit message explicitly references a CVE identifier (CVE-2017-0028), and the code changes address issues related to the 'async' identifier binding in async arrow functions, which is a known security vulnerability. The patch fixes a security weakness, confirming it as a security vulnerability fix."
}