{
  "cve_id": "CVE-2017-9780",
  "cwe_ids": [
    "CWE-732"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "flatpak",
  "commit_msg": "Use new libostree APIs to reject world-writable/suid content\n\nThis uses the new libostree APIs that landed recently to ensure\nthat we reject any files with mode outside of `0775` for system\nhelper pulls, and we also mask directory modes during checkout.\n\nHowever, this does *not* fix up any already downloaded content.\nFor that, one could uninstall/reinstall; or a future patch could\ndo a one-time fixup pass.\n\nNote that I am not aware of a way for flatpak applications to escalate their\nprivileges directly with this flaw; the bubblewrap `PR_SET_NO_NEW_PRIVS` turns\nof setuid. However, in combination with code execution on the host via another\nmechanism (e.g. unsandboxed app), a setuid app injected could be used to gain\nfull host privileges.\n\nAt this time we're not aware of any flatpak content exploiting this issue.\n\nCloses: https://github.com/flatpak/flatpak/issues/845",
  "commit_hash": "aed5d0919830c02e490f669fc36bd9af42e632d6",
  "git_url": "https://github.com/flatpak/flatpak/commit/aed5d0919830c02e490f669fc36bd9af42e632d6",
  "file_path": "common/flatpak-dir.c",
  "func_name": "flatpak_dir_deploy_appstream",
  "func_before": "gboolean\nflatpak_dir_deploy_appstream (FlatpakDir          *self,\n                              const char          *remote,\n                              const char          *arch,\n                              gboolean            *out_changed,\n                              GCancellable        *cancellable,\n                              GError             **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) checkout_dir = NULL;\n  g_autoptr(GFile) real_checkout_dir = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autofree char *arch_path = NULL;\n  gboolean checkout_exists;\n  g_autofree char *remote_and_branch = NULL;\n  const char *old_checksum = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autofree char *branch = NULL;\n  g_autoptr(GFile) old_checkout_dir = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GError) tmp_error = NULL;\n  g_autofree char *checkout_dir_path = NULL;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  glnx_fd_close int dfd = -1;\n  g_autoptr(GFileInfo) file_info = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n  arch_dir = g_file_get_child (remote_dir, arch);\n  active_link = g_file_get_child (arch_dir, \"active\");\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n\n  arch_path = g_file_get_path (arch_dir);\n  if (g_mkdir_with_parents (arch_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, arch_path, TRUE, &dfd, error))\n    return FALSE;\n\n  old_checksum = NULL;\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info != NULL)\n    old_checksum =  g_file_info_get_symlink_target (file_info);\n\n  branch = g_strdup_printf (\"appstream/%s\", arch);\n  remote_and_branch = g_strdup_printf (\"%s:%s\", remote, branch);\n  if (!ostree_repo_resolve_rev (self->repo, remote_and_branch, TRUE, &new_checksum, error))\n    return FALSE;\n\n  real_checkout_dir = g_file_get_child (arch_dir, new_checksum);\n  checkout_exists = g_file_query_exists (real_checkout_dir, NULL);\n\n  if (old_checksum != NULL && new_checksum != NULL &&\n      strcmp (old_checksum, new_checksum) == 0 &&\n      checkout_exists)\n    {\n      if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n        return FALSE;\n\n      if (out_changed)\n        *out_changed = FALSE;\n\n      return TRUE; /* No changes, don't checkout */\n    }\n\n  {\n    g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", new_checksum);\n    g_autoptr(GFile) tmp_dir_template = g_file_get_child (arch_dir, template);\n    checkout_dir_path = g_file_get_path (tmp_dir_template);\n    if (g_mkdtemp_full (checkout_dir_path, 0755) == NULL)\n      {\n        g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  checkout_dir = g_file_new_for_path (checkout_dir_path);\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n\n  if (!ostree_repo_checkout_at (self->repo, &options,\n                                AT_FDCWD, checkout_dir_path, new_checksum,\n                                cancellable, error))\n    return FALSE;\n\n  glnx_gen_temp_name (tmpname);\n  active_tmp_link = g_file_get_child (arch_dir, tmpname);\n\n  if (!g_file_make_symbolic_link (active_tmp_link, new_checksum, cancellable, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  /* By now the checkout to the temporary directory is on disk, as is the temporary\n     symlink pointing to the final target. */\n\n  if (!g_file_move (checkout_dir, real_checkout_dir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (active_tmp_link,\n                            active_link,\n                            cancellable, error))\n    return FALSE;\n\n  if (old_checksum != NULL &&\n      g_strcmp0 (old_checksum, new_checksum) != 0)\n    {\n      old_checkout_dir = g_file_get_child (arch_dir, old_checksum);\n      if (!flatpak_rm_rf (old_checkout_dir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old appstream checkout: %s\\n\", tmp_error->message);\n    }\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  /* If we added a new checkout, touch the toplevel dir to tell people that they need\n     to re-scan */\n  if (!checkout_exists)\n    {\n      g_autofree char *appstream_dir_path = g_file_get_path (appstream_dir);\n      utime (appstream_dir_path, NULL);\n    }\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}",
  "abstract_func_before": "gboolean\nflatpak_dir_deploy_appstream (FlatpakDir          *VAR_0,\n                              const char          *VAR_1,\n                              const char          *VAR_2,\n                              gboolean            *VAR_3,\n                              GCancellable        *VAR_4,\n                              GError             **VAR_5)\n{\n  VAR_6(GFile) VAR_7 = NULL;\n  VAR_6(GFile) VAR_8 = NULL;\n  VAR_6(GFile) VAR_9 = NULL;\n  VAR_6(GFile) VAR_10 = NULL;\n  VAR_6(GFile) VAR_11 = NULL;\n  VAR_6(GFile) VAR_12 = NULL;\n  g_autofree char *VAR_13 = NULL;\n  gboolean VAR_14;\n  g_autofree char *VAR_15 = NULL;\n  const char *VAR_16 = NULL;\n  g_autofree char *VAR_17 = NULL;\n  VAR_6(GFile) VAR_18 = NULL;\n  g_autofree char *VAR_19 = NULL;\n  VAR_6(GFile) VAR_20 = NULL;\n  VAR_6(GFile) VAR_21 = NULL;\n  VAR_6(GError) VAR_22 = NULL;\n  g_autofree char *VAR_23 = NULL;\n  OstreeRepoCheckoutAtOptions VAR_24 = { 0, };\n  glnx_fd_close VAR_25 VAR_26 = -1;\n  VAR_6(GFileInfo) VAR_27 = NULL;\n  g_autofree char *VAR_28 = g_strdup (\".active-XXXXXX\");\n\n  VAR_7 = g_file_get_child (flatpak_dir_get_path (VAR_0), \"appstream\");\n  VAR_8 = g_file_get_child (VAR_7, VAR_1);\n  VAR_9 = g_file_get_child (VAR_8, VAR_2);\n  VAR_18 = g_file_get_child (VAR_9, \"active\");\n  VAR_12 = g_file_get_child (VAR_9, \".timestamp\");\n\n  VAR_13 = g_file_get_path (VAR_9);\n  if (g_mkdir_with_parents (VAR_13, 0755) != 0)\n    {\n      glnx_set_error_from_errno (VAR_5);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (VAR_29, VAR_13, TRUE, &VAR_26, VAR_5))\n    return FALSE;\n\n  VAR_16 = NULL;\n  VAR_27 = g_file_query_info (VAR_18, VAR_30,\n                                 VAR_31,\n                                 VAR_4, NULL);\n  if (VAR_27 != NULL)\n    VAR_16 =  g_file_info_get_symlink_target (VAR_27);\n\n  VAR_19 = g_strdup_printf (\"appstream/%s\", VAR_2);\n  VAR_15 = g_strdup_printf (\"%s:%s\", VAR_1, VAR_19);\n  if (!ostree_repo_resolve_rev (VAR_0->repo, VAR_15, TRUE, &VAR_17, VAR_5))\n    return FALSE;\n\n  VAR_11 = g_file_get_child (VAR_9, VAR_17);\n  VAR_14 = g_file_query_exists (VAR_11, NULL);\n\n  if (VAR_16 != NULL && VAR_17 != NULL &&\n      strcmp (VAR_16, VAR_17) == 0 &&\n      VAR_14)\n    {\n      if (!g_file_replace_contents (VAR_12, \"\", 0, NULL, FALSE,\n                                    VAR_32, NULL, NULL, VAR_5))\n        return FALSE;\n\n      if (VAR_3)\n        *VAR_3 = FALSE;\n\n      return TRUE; /* COMMENT_0 */\n    }\n\n  {\n    g_autofree char *VAR_33 = g_strdup_printf (\".%s-XXXXXX\", VAR_17);\n    VAR_6(GFile) VAR_34 = g_file_get_child (VAR_9, VAR_33);\n    VAR_23 = g_file_get_path (VAR_34);\n    if (g_mkdtemp_full (VAR_23, 0755) == NULL)\n      {\n        g_set_error (VAR_5, VAR_35, VAR_36,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  VAR_10 = g_file_new_for_path (VAR_23);\n\n  VAR_24.mode = VAR_37;\n  VAR_24.overwrite_mode = VAR_38;\n  VAR_24.enable_fsync = FALSE; /* COMMENT_1 */\n\n  if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                VAR_29, VAR_23, VAR_17,\n                                VAR_4, VAR_5))\n    return FALSE;\n\n  glnx_gen_temp_name (VAR_28);\n  VAR_21 = g_file_get_child (VAR_9, VAR_28);\n\n  if (!g_file_make_symbolic_link (VAR_21, VAR_17, VAR_4, VAR_5))\n    return FALSE;\n\n  if (syncfs (VAR_26) != 0)\n    {\n      glnx_set_error_from_errno (VAR_5);\n      return FALSE;\n    }\n\n  /* COMMENT_2 */\n                                             \n\n  if (!g_file_move (VAR_10, VAR_11, VAR_39,\n                    VAR_4, NULL, NULL, VAR_5))\n    return FALSE;\n\n  if (syncfs (VAR_26) != 0)\n    {\n      glnx_set_error_from_errno (VAR_5);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (VAR_21,\n                            VAR_18,\n                            VAR_4, VAR_5))\n    return FALSE;\n\n  if (VAR_16 != NULL &&\n      g_strcmp0 (VAR_16, VAR_17) != 0)\n    {\n      VAR_20 = g_file_get_child (VAR_9, VAR_16);\n      if (!flatpak_rm_rf (VAR_20, VAR_4, &VAR_22))\n        g_warning (\"Unable to remove old appstream checkout: %s\\n\", VAR_22->message);\n    }\n\n  if (!g_file_replace_contents (VAR_12, \"\", 0, NULL, FALSE,\n                                VAR_32, NULL, NULL, VAR_5))\n    return FALSE;\n\n  /* COMMENT_4 */\n                  \n  if (!VAR_14)\n    {\n      g_autofree char *VAR_40 = g_file_get_path (VAR_7);\n      utime (VAR_40, NULL);\n    }\n\n  if (VAR_3)\n    *VAR_3 = TRUE;\n\n  return TRUE;\n}",
  "func_graph_path_before": "flatpak/aed5d0919830c02e490f669fc36bd9af42e632d6/flatpak-dir.c/vul/before/1.json",
  "func": "gboolean\nflatpak_dir_deploy_appstream (FlatpakDir          *self,\n                              const char          *remote,\n                              const char          *arch,\n                              gboolean            *out_changed,\n                              GCancellable        *cancellable,\n                              GError             **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) checkout_dir = NULL;\n  g_autoptr(GFile) real_checkout_dir = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autofree char *arch_path = NULL;\n  gboolean checkout_exists;\n  g_autofree char *remote_and_branch = NULL;\n  const char *old_checksum = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autofree char *branch = NULL;\n  g_autoptr(GFile) old_checkout_dir = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GError) tmp_error = NULL;\n  g_autofree char *checkout_dir_path = NULL;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  glnx_fd_close int dfd = -1;\n  g_autoptr(GFileInfo) file_info = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n  arch_dir = g_file_get_child (remote_dir, arch);\n  active_link = g_file_get_child (arch_dir, \"active\");\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n\n  arch_path = g_file_get_path (arch_dir);\n  if (g_mkdir_with_parents (arch_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, arch_path, TRUE, &dfd, error))\n    return FALSE;\n\n  old_checksum = NULL;\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info != NULL)\n    old_checksum =  g_file_info_get_symlink_target (file_info);\n\n  branch = g_strdup_printf (\"appstream/%s\", arch);\n  remote_and_branch = g_strdup_printf (\"%s:%s\", remote, branch);\n  if (!ostree_repo_resolve_rev (self->repo, remote_and_branch, TRUE, &new_checksum, error))\n    return FALSE;\n\n  real_checkout_dir = g_file_get_child (arch_dir, new_checksum);\n  checkout_exists = g_file_query_exists (real_checkout_dir, NULL);\n\n  if (old_checksum != NULL && new_checksum != NULL &&\n      strcmp (old_checksum, new_checksum) == 0 &&\n      checkout_exists)\n    {\n      if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n        return FALSE;\n\n      if (out_changed)\n        *out_changed = FALSE;\n\n      return TRUE; /* No changes, don't checkout */\n    }\n\n  {\n    g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", new_checksum);\n    g_autoptr(GFile) tmp_dir_template = g_file_get_child (arch_dir, template);\n    checkout_dir_path = g_file_get_path (tmp_dir_template);\n    if (g_mkdtemp_full (checkout_dir_path, 0755) == NULL)\n      {\n        g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  checkout_dir = g_file_new_for_path (checkout_dir_path);\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n\n  if (!ostree_repo_checkout_at (self->repo, &options,\n                                AT_FDCWD, checkout_dir_path, new_checksum,\n                                cancellable, error))\n    return FALSE;\n\n  glnx_gen_temp_name (tmpname);\n  active_tmp_link = g_file_get_child (arch_dir, tmpname);\n\n  if (!g_file_make_symbolic_link (active_tmp_link, new_checksum, cancellable, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  /* By now the checkout to the temporary directory is on disk, as is the temporary\n     symlink pointing to the final target. */\n\n  if (!g_file_move (checkout_dir, real_checkout_dir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (active_tmp_link,\n                            active_link,\n                            cancellable, error))\n    return FALSE;\n\n  if (old_checksum != NULL &&\n      g_strcmp0 (old_checksum, new_checksum) != 0)\n    {\n      old_checkout_dir = g_file_get_child (arch_dir, old_checksum);\n      if (!flatpak_rm_rf (old_checkout_dir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old appstream checkout: %s\\n\", tmp_error->message);\n    }\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  /* If we added a new checkout, touch the toplevel dir to tell people that they need\n     to re-scan */\n  if (!checkout_exists)\n    {\n      g_autofree char *appstream_dir_path = g_file_get_path (appstream_dir);\n      utime (appstream_dir_path, NULL);\n    }\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}",
  "abstract_func": "gboolean\nflatpak_dir_deploy_appstream (FlatpakDir          *VAR_0,\n                              const char          *VAR_1,\n                              const char          *VAR_2,\n                              gboolean            *VAR_3,\n                              GCancellable        *VAR_4,\n                              GError             **VAR_5)\n{\n  VAR_6(GFile) VAR_7 = NULL;\n  VAR_6(GFile) VAR_8 = NULL;\n  VAR_6(GFile) VAR_9 = NULL;\n  VAR_6(GFile) VAR_10 = NULL;\n  VAR_6(GFile) VAR_11 = NULL;\n  VAR_6(GFile) VAR_12 = NULL;\n  g_autofree char *VAR_13 = NULL;\n  gboolean VAR_14;\n  g_autofree char *VAR_15 = NULL;\n  const char *VAR_16 = NULL;\n  g_autofree char *VAR_17 = NULL;\n  VAR_6(GFile) VAR_18 = NULL;\n  g_autofree char *VAR_19 = NULL;\n  VAR_6(GFile) VAR_20 = NULL;\n  VAR_6(GFile) VAR_21 = NULL;\n  VAR_6(GError) VAR_22 = NULL;\n  g_autofree char *VAR_23 = NULL;\n  OstreeRepoCheckoutAtOptions VAR_24 = { 0, };\n  glnx_fd_close VAR_25 VAR_26 = -1;\n  VAR_6(GFileInfo) VAR_27 = NULL;\n  g_autofree char *VAR_28 = g_strdup (\".active-XXXXXX\");\n\n  VAR_7 = g_file_get_child (flatpak_dir_get_path (VAR_0), \"appstream\");\n  VAR_8 = g_file_get_child (VAR_7, VAR_1);\n  VAR_9 = g_file_get_child (VAR_8, VAR_2);\n  VAR_18 = g_file_get_child (VAR_9, \"active\");\n  VAR_12 = g_file_get_child (VAR_9, \".timestamp\");\n\n  VAR_13 = g_file_get_path (VAR_9);\n  if (g_mkdir_with_parents (VAR_13, 0755) != 0)\n    {\n      glnx_set_error_from_errno (VAR_5);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (VAR_29, VAR_13, TRUE, &VAR_26, VAR_5))\n    return FALSE;\n\n  VAR_16 = NULL;\n  VAR_27 = g_file_query_info (VAR_18, VAR_30,\n                                 VAR_31,\n                                 VAR_4, NULL);\n  if (VAR_27 != NULL)\n    VAR_16 =  g_file_info_get_symlink_target (VAR_27);\n\n  VAR_19 = g_strdup_printf (\"appstream/%s\", VAR_2);\n  VAR_15 = g_strdup_printf (\"%s:%s\", VAR_1, VAR_19);\n  if (!ostree_repo_resolve_rev (VAR_0->repo, VAR_15, TRUE, &VAR_17, VAR_5))\n    return FALSE;\n\n  VAR_11 = g_file_get_child (VAR_9, VAR_17);\n  VAR_14 = g_file_query_exists (VAR_11, NULL);\n\n  if (VAR_16 != NULL && VAR_17 != NULL &&\n      strcmp (VAR_16, VAR_17) == 0 &&\n      VAR_14)\n    {\n      if (!g_file_replace_contents (VAR_12, \"\", 0, NULL, FALSE,\n                                    VAR_32, NULL, NULL, VAR_5))\n        return FALSE;\n\n      if (VAR_3)\n        *VAR_3 = FALSE;\n\n      return TRUE; /* COMMENT_0 */\n    }\n\n  {\n    g_autofree char *VAR_33 = g_strdup_printf (\".%s-XXXXXX\", VAR_17);\n    VAR_6(GFile) VAR_34 = g_file_get_child (VAR_9, VAR_33);\n    VAR_23 = g_file_get_path (VAR_34);\n    if (g_mkdtemp_full (VAR_23, 0755) == NULL)\n      {\n        g_set_error (VAR_5, VAR_35, VAR_36,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  VAR_10 = g_file_new_for_path (VAR_23);\n\n  VAR_24.mode = VAR_37;\n  VAR_24.overwrite_mode = VAR_38;\n  VAR_24.enable_fsync = FALSE; /* COMMENT_1 */\n  VAR_24.bareuseronly_dirs = TRUE; /* COMMENT_2 */\n\n  if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                VAR_29, VAR_23, VAR_17,\n                                VAR_4, VAR_5))\n    return FALSE;\n\n  glnx_gen_temp_name (VAR_28);\n  VAR_21 = g_file_get_child (VAR_9, VAR_28);\n\n  if (!g_file_make_symbolic_link (VAR_21, VAR_17, VAR_4, VAR_5))\n    return FALSE;\n\n  if (syncfs (VAR_26) != 0)\n    {\n      glnx_set_error_from_errno (VAR_5);\n      return FALSE;\n    }\n\n  /* COMMENT_3 */\n                                             \n\n  if (!g_file_move (VAR_10, VAR_11, VAR_39,\n                    VAR_4, NULL, NULL, VAR_5))\n    return FALSE;\n\n  if (syncfs (VAR_26) != 0)\n    {\n      glnx_set_error_from_errno (VAR_5);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (VAR_21,\n                            VAR_18,\n                            VAR_4, VAR_5))\n    return FALSE;\n\n  if (VAR_16 != NULL &&\n      g_strcmp0 (VAR_16, VAR_17) != 0)\n    {\n      VAR_20 = g_file_get_child (VAR_9, VAR_16);\n      if (!flatpak_rm_rf (VAR_20, VAR_4, &VAR_22))\n        g_warning (\"Unable to remove old appstream checkout: %s\\n\", VAR_22->message);\n    }\n\n  if (!g_file_replace_contents (VAR_12, \"\", 0, NULL, FALSE,\n                                VAR_32, NULL, NULL, VAR_5))\n    return FALSE;\n\n  /* COMMENT_5 */\n                  \n  if (!VAR_14)\n    {\n      g_autofree char *VAR_40 = g_file_get_path (VAR_7);\n      utime (VAR_40, NULL);\n    }\n\n  if (VAR_3)\n    *VAR_3 = TRUE;\n\n  return TRUE;\n}",
  "func_graph_path": "flatpak/aed5d0919830c02e490f669fc36bd9af42e632d6/flatpak-dir.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -89,6 +89,7 @@\n   options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n   options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n   options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n+  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n \n   if (!ostree_repo_checkout_at (self->repo, &options,\n                                 AT_FDCWD, checkout_dir_path, new_checksum,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/flatpak/flatpak/pull/848",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/flatpak/flatpak/pull/848: 403 Client Error: Forbidden for url: https://api.github.com/repos/flatpak/flatpak/pulls/848",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix\nConfidence: 0.9\n\nThe changes enforce file permission restrictions to prevent security risks, addressing a potential exploit."
}