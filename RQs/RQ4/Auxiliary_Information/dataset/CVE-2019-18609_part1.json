{
  "cve_id": "CVE-2019-18609",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "alanxz/rabbitmq-c",
  "commit_msg": "lib: check frame_size is >= INT32_MAX\n\nWhen parsing a frame header, validate that the frame_size is less than\nor equal to INT32_MAX. Given frame_max is limited between 0 and\nINT32_MAX in amqp_login and friends, this does not change the API.\n\nThis prevents a potential buffer overflow when a malicious client sends\na frame_size that is close to UINT32_MAX, in which causes an overflow\nwhen computing state->target_size resulting in a small value there. A\nbuffer is then allocated with the small amount, then memcopy copies the\nframe_size writing to memory beyond the end of the buffer.",
  "commit_hash": "fc85be7123050b91b054e45b91c78d3241a5047a",
  "git_url": "https://github.com/alanxz/rabbitmq-c/commit/fc85be7123050b91b054e45b91c78d3241a5047a",
  "file_path": "librabbitmq/amqp_connection.c",
  "func_name": "amqp_handle_input",
  "func_before": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      /* frame length is 3 bytes in */\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      state->target_size =\n          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;\n\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}",
  "abstract_func_before": "int amqp_handle_input(amqp_connection_state_t VAR_0, amqp_bytes_t VAR_1,\n                      amqp_frame_t *VAR_2) {\n  size_t VAR_3;\n  void *VAR_4;\n\n  /* COMMENT_0 */\n                                              \n  VAR_2->frame_type = 0;\n\n  if (VAR_1.len == 0) {\n    return VAR_5;\n  }\n\n  if (VAR_0->state == VAR_6) {\n    VAR_0->state = VAR_7;\n  }\n\n  VAR_3 = consume_data(VAR_0, &VAR_1);\n\n  /* COMMENT_2 */\n                                         \n  if (VAR_0->inbound_offset < VAR_0->target_size) {\n    return (int)VAR_3;\n  }\n\n  VAR_4 = VAR_0->inbound_buffer.bytes;\n\n  switch (VAR_0->state) {\n    case VAR_8:\n      /* COMMENT_4 */\n      if (memcmp(VAR_4, \"AMQP\", 4) == 0) {\n        VAR_2->frame_type = VAR_9;\n        VAR_2->channel = 0;\n\n        VAR_2->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(VAR_4, 4));\n        VAR_2->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(VAR_4, 5));\n        VAR_2->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(VAR_4, 6));\n        VAR_2->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(VAR_4, 7));\n\n        return_to_idle(VAR_0);\n        return (int)VAR_3;\n      }\n\n    /* COMMENT_5 */\n                              \n\n    case VAR_7: {\n      amqp_channel_t VAR_10;\n      amqp_pool_t *VAR_11;\n      /* COMMENT_7 */\n      VAR_10 = amqp_d16(amqp_offset(VAR_4, 1));\n\n      VAR_0->target_size =\n          amqp_d32(amqp_offset(VAR_4, 3)) + VAR_12 + VAR_13;\n\n      if ((size_t)VAR_0->frame_max < VAR_0->target_size) {\n        return VAR_14;\n      }\n\n      VAR_11 = amqp_get_or_create_channel_pool(VAR_0, VAR_10);\n      if (NULL == VAR_11) {\n        return VAR_15;\n      }\n\n      amqp_pool_alloc_bytes(VAR_11, VAR_0->target_size,\n                            &VAR_0->inbound_buffer);\n      if (NULL == VAR_0->inbound_buffer.bytes) {\n        return VAR_15;\n      }\n      memcpy(VAR_0->inbound_buffer.bytes, VAR_0->header_buffer, VAR_12);\n      VAR_4 = VAR_0->inbound_buffer.bytes;\n\n      VAR_0->state = VAR_16;\n\n      VAR_3 += consume_data(VAR_0, &VAR_1);\n\n      /* COMMENT_8 */\n                                             \n      if (VAR_0->inbound_offset < VAR_0->target_size) {\n        return (int)VAR_3;\n      }\n    }\n    /* COMMENT_10 */\n\n    case VAR_16: {\n      amqp_bytes_t VAR_17;\n      int VAR_18;\n      amqp_pool_t *VAR_11;\n\n      /* COMMENT_11 */\n      if (amqp_d8(amqp_offset(VAR_4, VAR_0->target_size - 1)) !=\n          VAR_19) {\n        return VAR_14;\n      }\n\n      VAR_2->frame_type = amqp_d8(amqp_offset(VAR_4, 0));\n      VAR_2->channel = amqp_d16(amqp_offset(VAR_4, 1));\n\n      VAR_11 =\n          amqp_get_or_create_channel_pool(VAR_0, VAR_2->channel);\n      if (NULL == VAR_11) {\n        return VAR_15;\n      }\n\n      switch (VAR_2->frame_type) {\n        case VAR_20:\n          VAR_2->payload.method.id =\n              amqp_d32(amqp_offset(VAR_4, VAR_12));\n          VAR_17.bytes = amqp_offset(VAR_4, VAR_12 + 4);\n          VAR_17.len = VAR_0->target_size - VAR_12 - 4 - VAR_13;\n\n          VAR_18 = amqp_decode_method(VAR_2->payload.method.id,\n                                   VAR_11, VAR_17,\n                                   &VAR_2->payload.method.decoded);\n          if (VAR_18 < 0) {\n            return VAR_18;\n          }\n\n          break;\n\n        case VAR_21:\n          VAR_2->payload.properties.class_id =\n              amqp_d16(amqp_offset(VAR_4, VAR_12));\n          /* COMMENT_12 */\n          VAR_2->payload.properties.body_size =\n              amqp_d64(amqp_offset(VAR_4, VAR_12 + 4));\n          VAR_17.bytes = amqp_offset(VAR_4, VAR_12 + 12);\n          VAR_17.len = VAR_0->target_size - VAR_12 - 12 - VAR_13;\n          VAR_2->payload.properties.raw = VAR_17;\n\n          VAR_18 = amqp_decode_properties(\n              VAR_2->payload.properties.class_id, VAR_11, VAR_17,\n              &VAR_2->payload.properties.decoded);\n          if (VAR_18 < 0) {\n            return VAR_18;\n          }\n\n          break;\n\n        case VAR_22:\n          VAR_2->payload.body_fragment.len =\n              VAR_0->target_size - VAR_12 - VAR_13;\n          VAR_2->payload.body_fragment.bytes =\n              amqp_offset(VAR_4, VAR_12);\n          break;\n\n        case VAR_23:\n          break;\n\n        default:\n          /* COMMENT_13 */\n          VAR_2->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(VAR_0);\n      return (int)VAR_3;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 VAR_0->state);\n  }\n}",
  "func_graph_path_before": "alanxz/rabbitmq-c/fc85be7123050b91b054e45b91c78d3241a5047a/amqp_connection.c/vul/before/0.json",
  "func": "int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,\n                      amqp_frame_t *decoded_frame) {\n  size_t bytes_consumed;\n  void *raw_frame;\n\n  /* Returning frame_type of zero indicates either insufficient input,\n     or a complete, ignored frame was read. */\n  decoded_frame->frame_type = 0;\n\n  if (received_data.len == 0) {\n    return AMQP_STATUS_OK;\n  }\n\n  if (state->state == CONNECTION_STATE_IDLE) {\n    state->state = CONNECTION_STATE_HEADER;\n  }\n\n  bytes_consumed = consume_data(state, &received_data);\n\n  /* do we have target_size data yet? if not, return with the\n     expectation that more will arrive */\n  if (state->inbound_offset < state->target_size) {\n    return (int)bytes_consumed;\n  }\n\n  raw_frame = state->inbound_buffer.bytes;\n\n  switch (state->state) {\n    case CONNECTION_STATE_INITIAL:\n      /* check for a protocol header from the server */\n      if (memcmp(raw_frame, \"AMQP\", 4) == 0) {\n        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;\n        decoded_frame->channel = 0;\n\n        decoded_frame->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(raw_frame, 4));\n        decoded_frame->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(raw_frame, 5));\n        decoded_frame->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(raw_frame, 6));\n        decoded_frame->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(raw_frame, 7));\n\n        return_to_idle(state);\n        return (int)bytes_consumed;\n      }\n\n    /* it's not a protocol header; fall through to process it as a\n       regular frame header */\n\n    case CONNECTION_STATE_HEADER: {\n      amqp_channel_t channel;\n      amqp_pool_t *channel_pool;\n      uint32_t frame_size;\n\n      channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      /* frame length is 3 bytes in */\n      frame_size = amqp_d32(amqp_offset(raw_frame, 3));\n      /* To prevent the target_size calculation below from overflowing, check\n       * that the stated frame_size is smaller than a signed 32-bit. Given\n       * the library only allows configuring frame_max as an int32_t, and\n       * frame_size is uint32_t, the math below is safe from overflow. */\n      if (frame_size >= INT32_MAX) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;\n      if ((size_t)state->frame_max < state->target_size) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      channel_pool = amqp_get_or_create_channel_pool(state, channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      amqp_pool_alloc_bytes(channel_pool, state->target_size,\n                            &state->inbound_buffer);\n      if (NULL == state->inbound_buffer.bytes) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);\n      raw_frame = state->inbound_buffer.bytes;\n\n      state->state = CONNECTION_STATE_BODY;\n\n      bytes_consumed += consume_data(state, &received_data);\n\n      /* do we have target_size data yet? if not, return with the\n         expectation that more will arrive */\n      if (state->inbound_offset < state->target_size) {\n        return (int)bytes_consumed;\n      }\n    }\n    /* fall through to process body */\n\n    case CONNECTION_STATE_BODY: {\n      amqp_bytes_t encoded;\n      int res;\n      amqp_pool_t *channel_pool;\n\n      /* Check frame end marker (footer) */\n      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=\n          AMQP_FRAME_END) {\n        return AMQP_STATUS_BAD_AMQP_DATA;\n      }\n\n      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));\n      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));\n\n      channel_pool =\n          amqp_get_or_create_channel_pool(state, decoded_frame->channel);\n      if (NULL == channel_pool) {\n        return AMQP_STATUS_NO_MEMORY;\n      }\n\n      switch (decoded_frame->frame_type) {\n        case AMQP_FRAME_METHOD:\n          decoded_frame->payload.method.id =\n              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);\n          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;\n\n          res = amqp_decode_method(decoded_frame->payload.method.id,\n                                   channel_pool, encoded,\n                                   &decoded_frame->payload.method.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_HEADER:\n          decoded_frame->payload.properties.class_id =\n              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));\n          /* unused 2-byte weight field goes here */\n          decoded_frame->payload.properties.body_size =\n              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));\n          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);\n          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;\n          decoded_frame->payload.properties.raw = encoded;\n\n          res = amqp_decode_properties(\n              decoded_frame->payload.properties.class_id, channel_pool, encoded,\n              &decoded_frame->payload.properties.decoded);\n          if (res < 0) {\n            return res;\n          }\n\n          break;\n\n        case AMQP_FRAME_BODY:\n          decoded_frame->payload.body_fragment.len =\n              state->target_size - HEADER_SIZE - FOOTER_SIZE;\n          decoded_frame->payload.body_fragment.bytes =\n              amqp_offset(raw_frame, HEADER_SIZE);\n          break;\n\n        case AMQP_FRAME_HEARTBEAT:\n          break;\n\n        default:\n          /* Ignore the frame */\n          decoded_frame->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(state);\n      return (int)bytes_consumed;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 state->state);\n  }\n}",
  "abstract_func": "int amqp_handle_input(amqp_connection_state_t VAR_0, amqp_bytes_t VAR_1,\n                      amqp_frame_t *VAR_2) {\n  size_t VAR_3;\n  void *VAR_4;\n\n  /* COMMENT_0 */\n                                              \n  VAR_2->frame_type = 0;\n\n  if (VAR_1.len == 0) {\n    return VAR_5;\n  }\n\n  if (VAR_0->state == VAR_6) {\n    VAR_0->state = VAR_7;\n  }\n\n  VAR_3 = consume_data(VAR_0, &VAR_1);\n\n  /* COMMENT_2 */\n                                         \n  if (VAR_0->inbound_offset < VAR_0->target_size) {\n    return (int)VAR_3;\n  }\n\n  VAR_4 = VAR_0->inbound_buffer.bytes;\n\n  switch (VAR_0->state) {\n    case VAR_8:\n      /* COMMENT_4 */\n      if (memcmp(VAR_4, \"AMQP\", 4) == 0) {\n        VAR_2->frame_type = VAR_9;\n        VAR_2->channel = 0;\n\n        VAR_2->payload.protocol_header.transport_high =\n            amqp_d8(amqp_offset(VAR_4, 4));\n        VAR_2->payload.protocol_header.transport_low =\n            amqp_d8(amqp_offset(VAR_4, 5));\n        VAR_2->payload.protocol_header.protocol_version_major =\n            amqp_d8(amqp_offset(VAR_4, 6));\n        VAR_2->payload.protocol_header.protocol_version_minor =\n            amqp_d8(amqp_offset(VAR_4, 7));\n\n        return_to_idle(VAR_0);\n        return (int)VAR_3;\n      }\n\n    /* COMMENT_5 */\n                              \n\n    case VAR_7: {\n      amqp_channel_t VAR_10;\n      amqp_pool_t *VAR_11;\n      uint32_t VAR_12;\n\n      VAR_10 = amqp_d16(amqp_offset(VAR_4, 1));\n\n      /* COMMENT_7 */\n      VAR_12 = amqp_d32(amqp_offset(VAR_4, 3));\n      /* COMMENT_8 */\n                                                                          \n                                                                         \n                                                                         \n      if (VAR_12 >= VAR_13) {\n        return VAR_14;\n      }\n\n      VAR_0->target_size = VAR_12 + VAR_15 + VAR_16;\n      if ((size_t)VAR_0->frame_max < VAR_0->target_size) {\n        return VAR_14;\n      }\n\n      VAR_11 = amqp_get_or_create_channel_pool(VAR_0, VAR_10);\n      if (NULL == VAR_11) {\n        return VAR_17;\n      }\n\n      amqp_pool_alloc_bytes(VAR_11, VAR_0->target_size,\n                            &VAR_0->inbound_buffer);\n      if (NULL == VAR_0->inbound_buffer.bytes) {\n        return VAR_17;\n      }\n      memcpy(VAR_0->inbound_buffer.bytes, VAR_0->header_buffer, VAR_15);\n      VAR_4 = VAR_0->inbound_buffer.bytes;\n\n      VAR_0->state = VAR_18;\n\n      VAR_3 += consume_data(VAR_0, &VAR_1);\n\n      /* COMMENT_12 */\n                                             \n      if (VAR_0->inbound_offset < VAR_0->target_size) {\n        return (int)VAR_3;\n      }\n    }\n    /* COMMENT_14 */\n\n    case VAR_18: {\n      amqp_bytes_t VAR_19;\n      int VAR_20;\n      amqp_pool_t *VAR_11;\n\n      /* COMMENT_15 */\n      if (amqp_d8(amqp_offset(VAR_4, VAR_0->target_size - 1)) !=\n          VAR_21) {\n        return VAR_14;\n      }\n\n      VAR_2->frame_type = amqp_d8(amqp_offset(VAR_4, 0));\n      VAR_2->channel = amqp_d16(amqp_offset(VAR_4, 1));\n\n      VAR_11 =\n          amqp_get_or_create_channel_pool(VAR_0, VAR_2->channel);\n      if (NULL == VAR_11) {\n        return VAR_17;\n      }\n\n      switch (VAR_2->frame_type) {\n        case VAR_22:\n          VAR_2->payload.method.id =\n              amqp_d32(amqp_offset(VAR_4, VAR_15));\n          VAR_19.bytes = amqp_offset(VAR_4, VAR_15 + 4);\n          VAR_19.len = VAR_0->target_size - VAR_15 - 4 - VAR_16;\n\n          VAR_20 = amqp_decode_method(VAR_2->payload.method.id,\n                                   VAR_11, VAR_19,\n                                   &VAR_2->payload.method.decoded);\n          if (VAR_20 < 0) {\n            return VAR_20;\n          }\n\n          break;\n\n        case VAR_23:\n          VAR_2->payload.properties.class_id =\n              amqp_d16(amqp_offset(VAR_4, VAR_15));\n          /* COMMENT_16 */\n          VAR_2->payload.properties.body_size =\n              amqp_d64(amqp_offset(VAR_4, VAR_15 + 4));\n          VAR_19.bytes = amqp_offset(VAR_4, VAR_15 + 12);\n          VAR_19.len = VAR_0->target_size - VAR_15 - 12 - VAR_16;\n          VAR_2->payload.properties.raw = VAR_19;\n\n          VAR_20 = amqp_decode_properties(\n              VAR_2->payload.properties.class_id, VAR_11, VAR_19,\n              &VAR_2->payload.properties.decoded);\n          if (VAR_20 < 0) {\n            return VAR_20;\n          }\n\n          break;\n\n        case VAR_24:\n          VAR_2->payload.body_fragment.len =\n              VAR_0->target_size - VAR_15 - VAR_16;\n          VAR_2->payload.body_fragment.bytes =\n              amqp_offset(VAR_4, VAR_15);\n          break;\n\n        case VAR_25:\n          break;\n\n        default:\n          /* COMMENT_17 */\n          VAR_2->frame_type = 0;\n          break;\n      }\n\n      return_to_idle(VAR_0);\n      return (int)VAR_3;\n    }\n\n    default:\n      amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\",\n                 VAR_0->state);\n  }\n}",
  "func_graph_path": "alanxz/rabbitmq-c/fc85be7123050b91b054e45b91c78d3241a5047a/amqp_connection.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -51,12 +51,21 @@\n     case CONNECTION_STATE_HEADER: {\n       amqp_channel_t channel;\n       amqp_pool_t *channel_pool;\n-      /* frame length is 3 bytes in */\n+      uint32_t frame_size;\n+\n       channel = amqp_d16(amqp_offset(raw_frame, 1));\n \n-      state->target_size =\n-          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;\n+      /* frame length is 3 bytes in */\n+      frame_size = amqp_d32(amqp_offset(raw_frame, 3));\n+      /* To prevent the target_size calculation below from overflowing, check\n+       * that the stated frame_size is smaller than a signed 32-bit. Given\n+       * the library only allows configuring frame_max as an int32_t, and\n+       * frame_size is uint32_t, the math below is safe from overflow. */\n+      if (frame_size >= INT32_MAX) {\n+        return AMQP_STATUS_BAD_AMQP_DATA;\n+      }\n \n+      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;\n       if ((size_t)state->frame_max < state->target_size) {\n         return AMQP_STATUS_BAD_AMQP_DATA;\n       }",
  "diff_line_info": {
    "deleted_lines": [
      "      /* frame length is 3 bytes in */",
      "      state->target_size =",
      "          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;"
    ],
    "added_lines": [
      "      uint32_t frame_size;",
      "",
      "      /* frame length is 3 bytes in */",
      "      frame_size = amqp_d32(amqp_offset(raw_frame, 3));",
      "      /* To prevent the target_size calculation below from overflowing, check",
      "       * that the stated frame_size is smaller than a signed 32-bit. Given",
      "       * the library only allows configuring frame_max as an int32_t, and",
      "       * frame_size is uint32_t, the math below is safe from overflow. */",
      "      if (frame_size >= INT32_MAX) {",
      "        return AMQP_STATUS_BAD_AMQP_DATA;",
      "      }",
      "      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/alanxz/rabbitmq-c/pull/579",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/alanxz/rabbitmq-c/pull/579: 403 Client Error: Forbidden for url: https://api.github.com/repos/alanxz/rabbitmq-c/pulls/579",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a buffer overflow vulnerability by validating the frame_size, preventing an overflow and subsequent data corruption. The commit message and code changes corroborate this fix.\n\n**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}