{
  "cve_id": "CVE-2021-3798",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "opencryptoki",
  "commit_msg": "SOFT: Check the EC Key on C_CreateObject and C_DeriveKey\n\nWhen constructing an OpenSSL EC public or private key from PKCS#11\nattributes or ECDH public data, check that the key is valid, i.e. that\nthe point is on the curve.\n\nThis prevents one from creating an EC key object via C_CreateObject with\ninvalid key data. It also prevents C_DeriveKey to derive a secret using\nECDH with an EC public key (public data) that uses a different curve\nor is invalid by other means.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
  "commit_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
  "git_url": "https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0",
  "file_path": "usr/lib/soft_stdll/soft_specific.c",
  "func_name": "fill_ec_key_from_pubkey",
  "func_before": "static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                     CK_ULONG data_len, CK_BBOOL allow_raw)\n{\n    CK_BYTE *ecpoint = NULL;\n    CK_ULONG ecpoint_len, privlen;\n    CK_BBOOL allocated = FALSE;\n    CK_RV rc;\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,\n                                   &allocated, &ecpoint, &ecpoint_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");\n        goto out;\n    }\n\n    if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {\n        TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\nout:\n    if (allocated && ecpoint != NULL)\n        free(ecpoint);\n\n    return rc;\n}",
  "abstract_func_before": "static CK_RV fill_ec_key_from_pubkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,\n                                     CK_ULONG VAR_2, CK_BBOOL VAR_3)\n{\n    CK_BYTE *VAR_4 = NULL;\n    CK_ULONG VAR_5, VAR_6;\n    CK_BBOOL VAR_7 = FALSE;\n    CK_RV VAR_8;\n\n    VAR_6 = (EC_GROUP_order_bits(EC_KEY_get0_group(VAR_0)) + 7) / 8;\n\n    VAR_8 = ec_point_from_public_data(VAR_1, VAR_2, VAR_6, VAR_3,\n                                   &VAR_7, &VAR_4, &VAR_5);\n    if (VAR_8 != VAR_9) {\n        TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");\n        goto out;\n    }\n\n    if (!EC_KEY_oct2key(VAR_0, VAR_4, VAR_5, NULL)) {\n        TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");\n        VAR_8 = VAR_10;\n        goto out;\n    }\n\nout:\n    if (VAR_7 && VAR_4 != NULL)\n        free(VAR_4);\n\n    return VAR_8;\n}",
  "func_graph_path_before": "opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/before/0.json",
  "func": "static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                     CK_ULONG data_len, CK_BBOOL allow_raw)\n{\n    CK_BYTE *ecpoint = NULL;\n    CK_ULONG ecpoint_len, privlen;\n    CK_BBOOL allocated = FALSE;\n    CK_RV rc;\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,\n                                   &allocated, &ecpoint, &ecpoint_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");\n        goto out;\n    }\n\n    if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {\n        TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_check_key(ec_key)) {\n        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n        rc = CKR_PUBLIC_KEY_INVALID;\n        goto out;\n    }\n\nout:\n    if (allocated && ecpoint != NULL)\n        free(ecpoint);\n\n    return rc;\n}",
  "abstract_func": "static CK_RV fill_ec_key_from_pubkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,\n                                     CK_ULONG VAR_2, CK_BBOOL VAR_3)\n{\n    CK_BYTE *VAR_4 = NULL;\n    CK_ULONG VAR_5, VAR_6;\n    CK_BBOOL VAR_7 = FALSE;\n    CK_RV VAR_8;\n\n    VAR_6 = (EC_GROUP_order_bits(EC_KEY_get0_group(VAR_0)) + 7) / 8;\n\n    VAR_8 = ec_point_from_public_data(VAR_1, VAR_2, VAR_6, VAR_3,\n                                   &VAR_7, &VAR_4, &VAR_5);\n    if (VAR_8 != VAR_9) {\n        TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");\n        goto out;\n    }\n\n    if (!EC_KEY_oct2key(VAR_0, VAR_4, VAR_5, NULL)) {\n        TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");\n        VAR_8 = VAR_10;\n        goto out;\n    }\n\n    if (!EC_KEY_check_key(VAR_0)) {\n        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n        VAR_8 = VAR_11;\n        goto out;\n    }\n\nout:\n    if (VAR_7 && VAR_4 != NULL)\n        free(VAR_4);\n\n    return VAR_8;\n}",
  "func_graph_path": "opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,12 @@\n         goto out;\n     }\n \n+    if (!EC_KEY_check_key(ec_key)) {\n+        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n+        rc = CKR_PUBLIC_KEY_INVALID;\n+        goto out;\n+    }\n+\n out:\n     if (allocated && ecpoint != NULL)\n         free(ecpoint);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (!EC_KEY_check_key(ec_key)) {",
      "        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "        rc = CKR_PUBLIC_KEY_INVALID;",
      "        goto out;",
      "    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencryptoki/opencryptoki/pull/402",
  "description": {
    "pr_info": {
      "title": "SOFT: Check the EC Key on C_CreateObject and C_DeriveKey",
      "number": 402
    },
    "comment": [
      "When constructing an OpenSSL EC public or private key from PKCS#11 attributes or ECDH public data, check that the key is valid, i.e. that the point is on the curve.\r\n\r\nThis prevents one from creating an EC key object via C_CreateObject with invalid key data. It also prevents C_DeriveKey to derive a secret using ECDH with an EC public key (public data) that uses a different curve\r\nor is invalid by other means.",
      "According to @p-steuer `EC_KEY_check_key()` is sufficient, and we should not do an additional `EC_POINT_is_on_curve()` check, since there is a cost associated with doing checking this twice.\r\n\r\nI have changed the code accordingly."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch is a security vulnerability fix because it addresses an issue where invalid EC keys could be created or used, which is a security risk. The code adds a validation check to prevent this.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}