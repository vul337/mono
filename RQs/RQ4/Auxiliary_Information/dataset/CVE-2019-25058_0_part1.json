{
  "cve_id": "CVE-2019-25058",
  "cwe_ids": [
    "CWE-863"
  ],
  "cvss_vector": "AV:L/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "USBGuard/usbguard",
  "commit_msg": "dbus: Add missing checks for authorization using Polkit",
  "commit_hash": "df5f01c6ed0c20d269f7239901d21883cc871bbb",
  "git_url": "https://github.com/USBGuard/usbguard/commit/df5f01c6ed0c20d269f7239901d21883cc871bbb",
  "file_path": "src/DBus/DBusBridge.cpp",
  "func_name": "DBusBridge::handleDevicesMethodCall",
  "func_before": "void DBusBridge::handleDevicesMethodCall(const std::string& method_name, GVariant* parameters,\n    GDBusMethodInvocation* invocation)\n  {\n    USBGUARD_LOG(Debug) << \"dbus devices method call: \" << method_name;\n\n    if (method_name == \"listDevices\") {\n      const char* query_cstr = nullptr;\n      g_variant_get(parameters, \"(&s)\", &query_cstr);\n      std::string query(query_cstr);\n      auto devices = listDevices(query);\n\n      if (devices.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto device_rule : devices) {\n            g_variant_builder_add(gvbuilder, \"(us)\",\n              device_rule.getRuleID(),\n              device_rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \"applyDevicePolicy\") {\n      uint32_t device_id = 0;\n      uint32_t target_integer = 0;\n      gboolean permanent = false;\n      g_variant_get(parameters, \"(uub)\", &device_id, &target_integer, &permanent);\n      USBGUARD_LOG(Debug) << \"DBus: applyDevicePolicy: Parsed device_id: \" << device_id << \" target_integer: \" << target_integer <<\n        \" and permanent: \" << permanent;\n      const Rule::Target target = Rule::targetFromInteger(target_integer);\n      const uint32_t rule_id = applyDevicePolicy(device_id, target, permanent);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(u)\", rule_id));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \"Unknown method \");\n  }",
  "abstract_func_before": "void DBusBridge::handleDevicesMethodCall(const std::string& VAR_0, GVariant* VAR_1,\n    GDBusMethodInvocation* VAR_2)\n  {\n    USBGUARD_LOG(VAR_3) << \"dbus devices method call: \" << VAR_0;\n\n    if (VAR_0 == \"listDevices\") {\n      const char* VAR_4 = nullptr;\n      g_variant_get(VAR_1, \"(&s)\", &VAR_4);\n      std::string query(query_cstr);\n      auto VAR_5 = listDevices(VAR_6);\n\n      if (VAR_5.size() > 0) {\n        auto VAR_7 = g_variant_builder_new(VAR_8);\n\n        try {\n          for (auto VAR_9 : VAR_5) {\n            g_variant_builder_add(VAR_7, \"(us)\",\n              VAR_9.getRuleID(),\n              VAR_9.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", VAR_7));\n        }\n        catch (...) {\n          g_variant_builder_unref(VAR_7);\n          throw;\n        }\n\n        g_variant_builder_unref(VAR_7);\n      }\n      else {\n        g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (VAR_0 == \"applyDevicePolicy\") {\n      uint32_t VAR_10 = 0;\n      uint32_t VAR_11 = 0;\n      gboolean VAR_12 = false;\n      g_variant_get(VAR_1, \"(uub)\", &VAR_10, &VAR_11, &VAR_12);\n      USBGUARD_LOG(VAR_3) << \"DBus: applyDevicePolicy: Parsed device_id: \" << VAR_10 << \" target_integer: \" << VAR_11 <<\n        \" and permanent: \" << VAR_12;\n      const Rule::Target VAR_13 = Rule::targetFromInteger(VAR_11);\n      const uint32_t VAR_14 = applyDevicePolicy(VAR_10, VAR_13, VAR_12);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(u)\", VAR_14));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(VAR_2, VAR_15,\n      VAR_16, \"Unknown method \");\n  }",
  "func_graph_path_before": null,
  "func": "void DBusBridge::handleDevicesMethodCall(const std::string& method_name, GVariant* parameters,\n    GDBusMethodInvocation* invocation)\n  {\n    USBGUARD_LOG(Debug) << \"dbus devices method call: \" << method_name;\n\n    if (method_name == \"listDevices\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* query_cstr = nullptr;\n      g_variant_get(parameters, \"(&s)\", &query_cstr);\n      std::string query(query_cstr);\n      auto devices = listDevices(query);\n\n      if (devices.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto device_rule : devices) {\n            g_variant_builder_add(gvbuilder, \"(us)\",\n              device_rule.getRuleID(),\n              device_rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \"applyDevicePolicy\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      uint32_t device_id = 0;\n      uint32_t target_integer = 0;\n      gboolean permanent = false;\n      g_variant_get(parameters, \"(uub)\", &device_id, &target_integer, &permanent);\n      USBGUARD_LOG(Debug) << \"DBus: applyDevicePolicy: Parsed device_id: \" << device_id << \" target_integer: \" << target_integer <<\n        \" and permanent: \" << permanent;\n      const Rule::Target target = Rule::targetFromInteger(target_integer);\n      const uint32_t rule_id = applyDevicePolicy(device_id, target, permanent);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(u)\", rule_id));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \"Unknown method \");\n  }",
  "abstract_func": "void DBusBridge::handleDevicesMethodCall(const std::string& VAR_0, GVariant* VAR_1,\n    GDBusMethodInvocation* VAR_2)\n  {\n    USBGUARD_LOG(VAR_3) << \"dbus devices method call: \" << VAR_0;\n\n    if (VAR_0 == \"listDevices\") {\n      if (! isAuthorizedByPolkit(VAR_2)) {\n        return;\n      }\n\n      const char* VAR_4 = nullptr;\n      g_variant_get(VAR_1, \"(&s)\", &VAR_4);\n      std::string query(query_cstr);\n      auto VAR_5 = listDevices(VAR_6);\n\n      if (VAR_5.size() > 0) {\n        auto VAR_7 = g_variant_builder_new(VAR_8);\n\n        try {\n          for (auto VAR_9 : VAR_5) {\n            g_variant_builder_add(VAR_7, \"(us)\",\n              VAR_9.getRuleID(),\n              VAR_9.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", VAR_7));\n        }\n        catch (...) {\n          g_variant_builder_unref(VAR_7);\n          throw;\n        }\n\n        g_variant_builder_unref(VAR_7);\n      }\n      else {\n        g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (VAR_0 == \"applyDevicePolicy\") {\n      if (! isAuthorizedByPolkit(VAR_2)) {\n        return;\n      }\n\n      uint32_t VAR_10 = 0;\n      uint32_t VAR_11 = 0;\n      gboolean VAR_12 = false;\n      g_variant_get(VAR_1, \"(uub)\", &VAR_10, &VAR_11, &VAR_12);\n      USBGUARD_LOG(VAR_3) << \"DBus: applyDevicePolicy: Parsed device_id: \" << VAR_10 << \" target_integer: \" << VAR_11 <<\n        \" and permanent: \" << VAR_12;\n      const Rule::Target VAR_13 = Rule::targetFromInteger(VAR_11);\n      const uint32_t VAR_14 = applyDevicePolicy(VAR_10, VAR_13, VAR_12);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(u)\", VAR_14));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(VAR_2, VAR_15,\n      VAR_16, \"Unknown method \");\n  }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n     USBGUARD_LOG(Debug) << \"dbus devices method call: \" << method_name;\n \n     if (method_name == \"listDevices\") {\n+      if (! isAuthorizedByPolkit(invocation)) {\n+        return;\n+      }\n+\n       const char* query_cstr = nullptr;\n       g_variant_get(parameters, \"(&s)\", &query_cstr);\n       std::string query(query_cstr);\n@@ -36,6 +40,10 @@\n     }\n \n     if (method_name == \"applyDevicePolicy\") {\n+      if (! isAuthorizedByPolkit(invocation)) {\n+        return;\n+      }\n+\n       uint32_t device_id = 0;\n       uint32_t target_integer = 0;\n       gboolean permanent = false;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      if (! isAuthorizedByPolkit(invocation)) {",
      "        return;",
      "      }",
      "",
      "      if (! isAuthorizedByPolkit(invocation)) {",
      "        return;",
      "      }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/USBGuard/usbguard/pull/531",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/USBGuard/usbguard/pull/531: 403 Client Error: Forbidden for url: https://api.github.com/repos/USBGuard/usbguard/pulls/531",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\nThe patch addresses authorization checks, modifies policy files, and enhances security by ensuring authorization is correctly handled. All elements align with a security fix."
}