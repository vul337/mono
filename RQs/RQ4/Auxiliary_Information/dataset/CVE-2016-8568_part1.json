{
  "cve_id": "CVE-2016-8568",
  "cwe_ids": [
    "CWE-476",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "tree: validate filename and OID length when parsing object\n\nWhen parsing tree entries from raw object data, we do not verify\nthat the tree entry actually has a filename as well as a valid\nobject ID. Fix this by asserting that the filename length is\nnon-zero as well as asserting that there are at least\n`GIT_OID_RAWSZ` bytes left when parsing the OID.",
  "commit_hash": "4974e3a59648095ffa6fce6c5b651a820c0c34b9",
  "git_url": "https://github.com/libgit2/libgit2/commit/4974e3a59648095ffa6fce6c5b651a820c0c34b9",
  "file_path": "src/tree.c",
  "func_name": "git_tree__parse",
  "func_before": "int git_tree__parse(void *_tree, git_odb_object *odb_obj)\n{\n\tgit_tree *tree = _tree;\n\tconst char *buffer;\n\tconst char *buffer_end;\n\n\tif (git_odb_object_dup(&tree->odb_obj, odb_obj) < 0)\n\t\treturn -1;\n\n\tbuffer = git_odb_object_data(tree->odb_obj);\n\tbuffer_end = buffer + git_odb_object_size(tree->odb_obj);\n\n\tgit_array_init_to_size(tree->entries, DEFAULT_TREE_SIZE);\n\tGITERR_CHECK_ARRAY(tree->entries);\n\n\twhile (buffer < buffer_end) {\n\t\tgit_tree_entry *entry;\n\t\tsize_t filename_len;\n\t\tconst char *nul;\n\t\tunsigned int attr;\n\n\t\tif (parse_mode(&attr, buffer, &buffer) < 0 || !buffer)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filemode\", NULL);\n\n\t\tif ((nul = memchr(buffer, 0, buffer_end - buffer)) == NULL)\n\t\t\treturn tree_error(\"Failed to parse tree. Object is corrupted\", NULL);\n\n\t\tfilename_len = nul - buffer;\n\t\t/* Allocate the entry */\n\t\t{\n\t\t\tentry = git_array_alloc(tree->entries);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->attr = attr;\n\t\t\tentry->filename_len = filename_len;\n\t\t\tentry->filename = buffer;\n\t\t\tentry->oid = (git_oid *) ((char *) buffer + filename_len + 1);\n\t\t}\n\n\t\tbuffer += filename_len + 1;\n\t\tbuffer += GIT_OID_RAWSZ;\n\t}\n\n\treturn 0;\n}",
  "abstract_func_before": "int git_tree__parse(void *VAR_0, git_odb_object *VAR_1)\n{\n\tgit_tree *VAR_2 = VAR_0;\n\tconst char *VAR_3;\n\tconst char *VAR_4;\n\n\tif (git_odb_object_dup(&VAR_2->odb_obj, VAR_1) < 0)\n\t\treturn -1;\n\n\tVAR_3 = git_odb_object_data(VAR_2->odb_obj);\n\tVAR_4 = VAR_3 + git_odb_object_size(VAR_2->odb_obj);\n\n\tgit_array_init_to_size(VAR_2->entries, VAR_5);\n\tGITERR_CHECK_ARRAY(VAR_2->entries);\n\n\twhile (VAR_3 < VAR_4) {\n\t\tgit_tree_entry *VAR_6;\n\t\tsize_t VAR_7;\n\t\tconst char *VAR_8;\n\t\tunsigned int VAR_9;\n\n\t\tif (parse_mode(&VAR_9, VAR_3, &VAR_3) < 0 || !VAR_3)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filemode\", NULL);\n\n\t\tif ((VAR_8 = memchr(VAR_3, 0, VAR_4 - VAR_3)) == NULL)\n\t\t\treturn tree_error(\"Failed to parse tree. Object is corrupted\", NULL);\n\n\t\tVAR_7 = VAR_8 - VAR_3;\n\t\t/* COMMENT_0 */\n\t\t{\n\t\t\tVAR_6 = git_array_alloc(VAR_2->entries);\n\t\t\tGITERR_CHECK_ALLOC(VAR_6);\n\n\t\t\tVAR_6->attr = VAR_9;\n\t\t\tVAR_6->filename_len = VAR_7;\n\t\t\tVAR_6->filename = VAR_3;\n\t\t\tVAR_6->oid = (git_oid *) ((char *) VAR_3 + VAR_7 + 1);\n\t\t}\n\n\t\tVAR_3 += VAR_7 + 1;\n\t\tVAR_3 += VAR_10;\n\t}\n\n\treturn 0;\n}",
  "func_graph_path_before": "libgit2/4974e3a59648095ffa6fce6c5b651a820c0c34b9/tree.c/vul/before/0.json",
  "func": "int git_tree__parse(void *_tree, git_odb_object *odb_obj)\n{\n\tgit_tree *tree = _tree;\n\tconst char *buffer;\n\tconst char *buffer_end;\n\n\tif (git_odb_object_dup(&tree->odb_obj, odb_obj) < 0)\n\t\treturn -1;\n\n\tbuffer = git_odb_object_data(tree->odb_obj);\n\tbuffer_end = buffer + git_odb_object_size(tree->odb_obj);\n\n\tgit_array_init_to_size(tree->entries, DEFAULT_TREE_SIZE);\n\tGITERR_CHECK_ARRAY(tree->entries);\n\n\twhile (buffer < buffer_end) {\n\t\tgit_tree_entry *entry;\n\t\tsize_t filename_len;\n\t\tconst char *nul;\n\t\tunsigned int attr;\n\n\t\tif (parse_mode(&attr, buffer, &buffer) < 0 || !buffer)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filemode\", NULL);\n\n\t\tif ((nul = memchr(buffer, 0, buffer_end - buffer)) == NULL)\n\t\t\treturn tree_error(\"Failed to parse tree. Object is corrupted\", NULL);\n\n\t\tif ((filename_len = nul - buffer) == 0)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filename\", NULL);\n\n\t\tif ((buffer_end - (nul + 1)) < GIT_OID_RAWSZ)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse OID\", NULL);\n\n\t\t/* Allocate the entry */\n\t\t{\n\t\t\tentry = git_array_alloc(tree->entries);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->attr = attr;\n\t\t\tentry->filename_len = filename_len;\n\t\t\tentry->filename = buffer;\n\t\t\tentry->oid = (git_oid *) ((char *) buffer + filename_len + 1);\n\t\t}\n\n\t\tbuffer += filename_len + 1;\n\t\tbuffer += GIT_OID_RAWSZ;\n\t}\n\n\treturn 0;\n}",
  "abstract_func": "int git_tree__parse(void *VAR_0, git_odb_object *VAR_1)\n{\n\tgit_tree *VAR_2 = VAR_0;\n\tconst char *VAR_3;\n\tconst char *VAR_4;\n\n\tif (git_odb_object_dup(&VAR_2->odb_obj, VAR_1) < 0)\n\t\treturn -1;\n\n\tVAR_3 = git_odb_object_data(VAR_2->odb_obj);\n\tVAR_4 = VAR_3 + git_odb_object_size(VAR_2->odb_obj);\n\n\tgit_array_init_to_size(VAR_2->entries, VAR_5);\n\tGITERR_CHECK_ARRAY(VAR_2->entries);\n\n\twhile (VAR_3 < VAR_4) {\n\t\tgit_tree_entry *VAR_6;\n\t\tsize_t VAR_7;\n\t\tconst char *VAR_8;\n\t\tunsigned int VAR_9;\n\n\t\tif (parse_mode(&VAR_9, VAR_3, &VAR_3) < 0 || !VAR_3)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filemode\", NULL);\n\n\t\tif ((VAR_8 = memchr(VAR_3, 0, VAR_4 - VAR_3)) == NULL)\n\t\t\treturn tree_error(\"Failed to parse tree. Object is corrupted\", NULL);\n\n\t\tif ((VAR_7 = VAR_8 - VAR_3) == 0)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filename\", NULL);\n\n\t\tif ((VAR_4 - (VAR_8 + 1)) < VAR_10)\n\t\t\treturn tree_error(\"Failed to parse tree. Can't parse OID\", NULL);\n\n\t\t/* COMMENT_0 */\n\t\t{\n\t\t\tVAR_6 = git_array_alloc(VAR_2->entries);\n\t\t\tGITERR_CHECK_ALLOC(VAR_6);\n\n\t\t\tVAR_6->attr = VAR_9;\n\t\t\tVAR_6->filename_len = VAR_7;\n\t\t\tVAR_6->filename = VAR_3;\n\t\t\tVAR_6->oid = (git_oid *) ((char *) VAR_3 + VAR_7 + 1);\n\t\t}\n\n\t\tVAR_3 += VAR_7 + 1;\n\t\tVAR_3 += VAR_10;\n\t}\n\n\treturn 0;\n}",
  "func_graph_path": "libgit2/4974e3a59648095ffa6fce6c5b651a820c0c34b9/tree.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,12 @@\n \t\tif ((nul = memchr(buffer, 0, buffer_end - buffer)) == NULL)\n \t\t\treturn tree_error(\"Failed to parse tree. Object is corrupted\", NULL);\n \n-\t\tfilename_len = nul - buffer;\n+\t\tif ((filename_len = nul - buffer) == 0)\n+\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filename\", NULL);\n+\n+\t\tif ((buffer_end - (nul + 1)) < GIT_OID_RAWSZ)\n+\t\t\treturn tree_error(\"Failed to parse tree. Can't parse OID\", NULL);\n+\n \t\t/* Allocate the entry */\n \t\t{\n \t\t\tentry = git_array_alloc(tree->entries);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tfilename_len = nul - buffer;"
    ],
    "added_lines": [
      "\t\tif ((filename_len = nul - buffer) == 0)",
      "\t\t\treturn tree_error(\"Failed to parse tree. Can't parse filename\", NULL);",
      "",
      "\t\tif ((buffer_end - (nul + 1)) < GIT_OID_RAWSZ)",
      "\t\t\treturn tree_error(\"Failed to parse tree. Can't parse OID\", NULL);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/3956",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libgit2/libgit2/pull/3956: 403 Client Error: Forbidden for url: https://api.github.com/repos/libgit2/libgit2/pulls/3956",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "The patch adds input validation checks for filenames and OIDs during tree object parsing, which helps prevent processing malformed data and mitigate potential security risks.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.85"
}