{
  "cve_id": "CVE-2022-32234",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#772)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "06eaec767e376bfdb883d912cb15e987ddf2bda1",
  "git_url": "https://github.com/facebook/hermes/commit/06eaec767e376bfdb883d912cb15e987ddf2bda1",
  "file_path": "external/llvh/lib/Support/SmallVector.cpp",
  "func_name": "SmallVectorBase::grow_pod",
  "func_before": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  // Ensure we can fit the new capacity in 32 bits.\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  size_t NewCapacity = 2 * capacity() + 1; // Always grow.\n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n\n    // Copy the elements over.  No need to run dtors on PODs.\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    // If this wasn't grown from the inline copy, grow the allocated space.\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);\n  }\n\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}",
  "abstract_func_before": "void SmallVectorBase::grow_pod(void *VAR_0, size_t VAR_1,\n                               size_t VAR_2) {\n  /* COMMENT_0 */\n  if (VAR_1 > VAR_3)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  size_t VAR_4 = 2 * capacity() + 1; /* COMMENT_1 */\n  VAR_4 =\n      std::min(std::max(VAR_4, VAR_1), size_t(VAR_3));\n\n  void *VAR_5;\n  if (VAR_6 == VAR_0) {\n    VAR_5 = safe_malloc(VAR_4 * VAR_2);\n\n    /* COMMENT_2 */\n    memcpy(VAR_5, this->BeginX, size() * VAR_2);\n  } else {\n    /* COMMENT_3 */\n    VAR_5 = safe_realloc(this->BeginX, VAR_4 * VAR_2);\n  }\n\n  this->BeginX = VAR_5;\n  this->Capacity = VAR_4;\n}",
  "func_graph_path_before": "facebook/hermes/06eaec767e376bfdb883d912cb15e987ddf2bda1/SmallVector.cpp/vul/before/0.json",
  "func": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  constexpr size_t MinGrowth = 1;\n  size_t NewCapacity = 2 * capacity() + MinGrowth; // Always grow.\n  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinCapacity));\n\n  // Ensure that NewCapacity did not overflow an unsigned int,\n  // and that the capacity in bytes will not overflow a size_t.\n  if (NewCapacity <= this->capacity() ||\n      NewCapacity < MinCapacity ||\n      NewCapacity > size_t(-1) / TSize)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n\n    // Copy the elements over.  No need to run dtors on PODs.\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    // If this wasn't grown from the inline copy, grow the allocated space.\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);\n  }\n\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}",
  "abstract_func": "void SmallVectorBase::grow_pod(void *VAR_0, size_t VAR_1,\n                               size_t VAR_2) {\n  constexpr size_t VAR_3 = 1;\n  size_t VAR_4 = 2 * capacity() + VAR_3; /* COMMENT_0 */\n  VAR_4 = VAR_5<unsigned>(std::max(VAR_4, VAR_1));\n\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (VAR_4 <= this->capacity() ||\n      VAR_4 < VAR_1 ||\n      VAR_4 > size_t(-1) / VAR_2)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  void *VAR_6;\n  if (VAR_7 == VAR_0) {\n    VAR_6 = safe_malloc(VAR_4 * VAR_2);\n\n    /* COMMENT_3 */\n    memcpy(VAR_6, this->BeginX, size() * VAR_2);\n  } else {\n    /* COMMENT_4 */\n    VAR_6 = safe_realloc(this->BeginX, VAR_4 * VAR_2);\n  }\n\n  this->BeginX = VAR_6;\n  this->Capacity = VAR_4;\n}",
  "func_graph_path": "facebook/hermes/06eaec767e376bfdb883d912cb15e987ddf2bda1/SmallVector.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,15 @@\n void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                                size_t TSize) {\n-  // Ensure we can fit the new capacity in 32 bits.\n-  if (MinCapacity > UINT32_MAX)\n+  constexpr size_t MinGrowth = 1;\n+  size_t NewCapacity = 2 * capacity() + MinGrowth; // Always grow.\n+  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinCapacity));\n+\n+  // Ensure that NewCapacity did not overflow an unsigned int,\n+  // and that the capacity in bytes will not overflow a size_t.\n+  if (NewCapacity <= this->capacity() ||\n+      NewCapacity < MinCapacity ||\n+      NewCapacity > size_t(-1) / TSize)\n     report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n-\n-  size_t NewCapacity = 2 * capacity() + 1; // Always grow.\n-  NewCapacity =\n-      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n \n   void *NewElts;\n   if (BeginX == FirstEl) {",
  "diff_line_info": {
    "deleted_lines": [
      "  // Ensure we can fit the new capacity in 32 bits.",
      "  if (MinCapacity > UINT32_MAX)",
      "",
      "  size_t NewCapacity = 2 * capacity() + 1; // Always grow.",
      "  NewCapacity =",
      "      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));"
    ],
    "added_lines": [
      "  constexpr size_t MinGrowth = 1;",
      "  size_t NewCapacity = 2 * capacity() + MinGrowth; // Always grow.",
      "  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinCapacity));",
      "",
      "  // Ensure that NewCapacity did not overflow an unsigned int,",
      "  // and that the capacity in bytes will not overflow a size_t.",
      "  if (NewCapacity <= this->capacity() ||",
      "      NewCapacity < MinCapacity ||",
      "      NewCapacity > size_t(-1) / TSize)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/772",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 772
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8"
}