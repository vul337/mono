{
  "cve_id": "CVE-2021-36369",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "mkj/dropbear",
  "commit_msg": "fixed trivial auth detection for pubkeys",
  "commit_hash": "318109125e747f0bc256a6d94d5756030ea2f5a0",
  "git_url": "https://github.com/mkj/dropbear/commit/318109125e747f0bc256a6d94d5756030ea2f5a0",
  "file_path": "cli-authpubkey.c",
  "func_name": "send_msg_userauth_pubkey",
  "func_before": "static void send_msg_userauth_pubkey(sign_key *key, enum signature_type sigtype, int realsign) {\n\n\tconst char *algoname = NULL;\n\tunsigned int algolen;\n\tbuffer* sigbuf = NULL;\n\tenum signkey_type keytype = signkey_type_from_signature(sigtype);\n\n\tTRACE((\"enter send_msg_userauth_pubkey sigtype %d\", sigtype))\n\tCHECKCLEARTOWRITE();\n\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);\n\n\tbuf_putstring(ses.writepayload, cli_opts.username,\n\t\t\tstrlen(cli_opts.username));\n\n\tbuf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,\n\t\t\tSSH_SERVICE_CONNECTION_LEN);\n\n\tbuf_putstring(ses.writepayload, AUTH_METHOD_PUBKEY,\n\t\t\tAUTH_METHOD_PUBKEY_LEN);\n\n\tbuf_putbyte(ses.writepayload, realsign);\n\n\talgoname = signature_name_from_type(sigtype, &algolen);\n\tbuf_putstring(ses.writepayload, algoname, algolen);\n\tbuf_put_pub_key(ses.writepayload, key, keytype);\n\n\tif (realsign) {\n\t\tTRACE((\"realsign\"))\n\t\t/* We put the signature as well - this contains string(session id), then\n\t\t * the contents of the write payload to this point */\n\t\tsigbuf = buf_new(4 + ses.session_id->len + ses.writepayload->len);\n\t\tbuf_putbufstring(sigbuf, ses.session_id);\n\t\tbuf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len);\n\t\tcli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf);\n\t\tbuf_free(sigbuf); /* Nothing confidential in the buffer */\n\t}\n\n\tencrypt_packet();\n\tTRACE((\"leave send_msg_userauth_pubkey\"))\n}",
  "abstract_func_before": "static void send_msg_userauth_pubkey(sign_key *VAR_0, enum signature_type VAR_1, int VAR_2) {\n\n\tconst char *VAR_3 = NULL;\n\tunsigned int VAR_4;\n\tbuffer* VAR_5 = NULL;\n\tenum signkey_type VAR_6 = signkey_type_from_signature(VAR_1);\n\n\tTRACE((\"enter send_msg_userauth_pubkey sigtype %d\", VAR_1))\n\tCHECKCLEARTOWRITE();\n\n\tbuf_putbyte(VAR_7.writepayload, VAR_8);\n\n\tbuf_putstring(VAR_7.writepayload, VAR_9.username,\n\t\t\tstrlen(VAR_9.username));\n\n\tbuf_putstring(VAR_7.writepayload, VAR_10,\n\t\t\tVAR_11);\n\n\tbuf_putstring(VAR_7.writepayload, VAR_12,\n\t\t\tVAR_13);\n\n\tbuf_putbyte(VAR_7.writepayload, VAR_2);\n\n\tVAR_3 = signature_name_from_type(VAR_1, &VAR_4);\n\tbuf_putstring(VAR_7.writepayload, VAR_3, VAR_4);\n\tbuf_put_pub_key(VAR_7.writepayload, VAR_0, VAR_6);\n\n\tif (VAR_2) {\n\t\tTRACE((\"realsign\"))\n\t\t/* COMMENT_0 */\n                                                       \n\t\tVAR_5 = buf_new(4 + VAR_7.session_id->len + VAR_7.writepayload->len);\n\t\tbuf_putbufstring(VAR_5, VAR_7.session_id);\n\t\tbuf_putbytes(VAR_5, VAR_7.writepayload->data, VAR_7.writepayload->len);\n\t\tcli_buf_put_sign(VAR_7.writepayload, VAR_0, VAR_1, VAR_5);\n\t\tbuf_free(VAR_5); /* COMMENT_2 */\n\t}\n\n\tencrypt_packet();\n\tTRACE((\"leave send_msg_userauth_pubkey\"))\n}",
  "func_graph_path_before": "mkj/dropbear/318109125e747f0bc256a6d94d5756030ea2f5a0/cli-authpubkey.c/vul/before/0.json",
  "func": "static void send_msg_userauth_pubkey(sign_key *key, enum signature_type sigtype, int realsign) {\n\n\tconst char *algoname = NULL;\n\tunsigned int algolen;\n\tbuffer* sigbuf = NULL;\n\tenum signkey_type keytype = signkey_type_from_signature(sigtype);\n\n\tTRACE((\"enter send_msg_userauth_pubkey sigtype %d\", sigtype))\n\tCHECKCLEARTOWRITE();\n\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);\n\n\tbuf_putstring(ses.writepayload, cli_opts.username,\n\t\t\tstrlen(cli_opts.username));\n\n\tbuf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,\n\t\t\tSSH_SERVICE_CONNECTION_LEN);\n\n\tbuf_putstring(ses.writepayload, AUTH_METHOD_PUBKEY,\n\t\t\tAUTH_METHOD_PUBKEY_LEN);\n\n\tbuf_putbyte(ses.writepayload, realsign);\n\n\talgoname = signature_name_from_type(sigtype, &algolen);\n\tbuf_putstring(ses.writepayload, algoname, algolen);\n\tbuf_put_pub_key(ses.writepayload, key, keytype);\n\n\tif (realsign) {\n\t\tTRACE((\"realsign\"))\n\t\t/* We put the signature as well - this contains string(session id), then\n\t\t * the contents of the write payload to this point */\n\t\tsigbuf = buf_new(4 + ses.session_id->len + ses.writepayload->len);\n\t\tbuf_putbufstring(sigbuf, ses.session_id);\n\t\tbuf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len);\n\t\tcli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf);\n\t\tbuf_free(sigbuf); /* Nothing confidential in the buffer */\n\t\tcli_ses.is_trivial_auth = 0;\n\t}\n\n\tencrypt_packet();\n\tTRACE((\"leave send_msg_userauth_pubkey\"))\n}",
  "abstract_func": "static void send_msg_userauth_pubkey(sign_key *VAR_0, enum signature_type VAR_1, int VAR_2) {\n\n\tconst char *VAR_3 = NULL;\n\tunsigned int VAR_4;\n\tbuffer* VAR_5 = NULL;\n\tenum signkey_type VAR_6 = signkey_type_from_signature(VAR_1);\n\n\tTRACE((\"enter send_msg_userauth_pubkey sigtype %d\", VAR_1))\n\tCHECKCLEARTOWRITE();\n\n\tbuf_putbyte(VAR_7.writepayload, VAR_8);\n\n\tbuf_putstring(VAR_7.writepayload, VAR_9.username,\n\t\t\tstrlen(VAR_9.username));\n\n\tbuf_putstring(VAR_7.writepayload, VAR_10,\n\t\t\tVAR_11);\n\n\tbuf_putstring(VAR_7.writepayload, VAR_12,\n\t\t\tVAR_13);\n\n\tbuf_putbyte(VAR_7.writepayload, VAR_2);\n\n\tVAR_3 = signature_name_from_type(VAR_1, &VAR_4);\n\tbuf_putstring(VAR_7.writepayload, VAR_3, VAR_4);\n\tbuf_put_pub_key(VAR_7.writepayload, VAR_0, VAR_6);\n\n\tif (VAR_2) {\n\t\tTRACE((\"realsign\"))\n\t\t/* COMMENT_0 */\n                                                       \n\t\tVAR_5 = buf_new(4 + VAR_7.session_id->len + VAR_7.writepayload->len);\n\t\tbuf_putbufstring(VAR_5, VAR_7.session_id);\n\t\tbuf_putbytes(VAR_5, VAR_7.writepayload->data, VAR_7.writepayload->len);\n\t\tcli_buf_put_sign(VAR_7.writepayload, VAR_0, VAR_1, VAR_5);\n\t\tbuf_free(VAR_5); /* COMMENT_2 */\n\t\tVAR_14.is_trivial_auth = 0;\n\t}\n\n\tencrypt_packet();\n\tTRACE((\"leave send_msg_userauth_pubkey\"))\n}",
  "func_graph_path": "mkj/dropbear/318109125e747f0bc256a6d94d5756030ea2f5a0/cli-authpubkey.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,7 @@\n \t\tbuf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len);\n \t\tcli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf);\n \t\tbuf_free(sigbuf); /* Nothing confidential in the buffer */\n+\t\tcli_ses.is_trivial_auth = 0;\n \t}\n \n \tencrypt_packet();",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\tcli_ses.is_trivial_auth = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mkj/dropbear/pull/128",
  "description": {
    "pr_info": {
      "title": "added option to disable trivial auth methods",
      "number": 128
    },
    "comment": [
      "I have added an option ``-o ExitOnTrivialAuth=yes`` to disable trivial authentications as discussed in our mails",
      "I have renamed to argument to ``-o DisableTrivialAuth=yes`` to match OpenSSH's parameter",
      "Would you merge this pull request, because we are planning to create a CVE and I think this should be mitigated before we publish a full disclosure. ",
      "Hello, we are planning to release information about trivial succes authentication. Do you need help with merging the pull requests and creating the new release?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}