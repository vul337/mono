{
  "cve_id": "CVE-2023-35790",
  "cwe_ids": [
    "CWE-191"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "libjxl",
  "commit_msg": "Fix an integer underflow bug in patch decoding.\n\nWhen reading patches, the code doesn't properly check that all patches\nare in bounds.\n\nIn particular, if the start of a patch becomes negative (due to the\ndelta coding of patch positions), but not negative *enough* to cause\n`start + size` to still be negative, the decoder happily accepted the\npatch. Such a patch would then lead the interval tree building code to\nrun into an infinite loop.",
  "commit_hash": "489b6b82a6ad27d563646d5d920d8d6bcadbc26b",
  "git_url": "https://github.com/libjxl/libjxl/commit/489b6b82a6ad27d563646d5d920d8d6bcadbc26b",
  "file_path": "lib/jxl/dec_patch_dictionary.cc",
  "func_name": "PatchDictionary::Decode",
  "func_before": "Status PatchDictionary::Decode(BitReader* br, size_t xsize, size_t ysize,\n                               bool* uses_extra_channels) {\n  positions_.clear();\n  std::vector<uint8_t> context_map;\n  ANSCode code;\n  JXL_RETURN_IF_ERROR(\n      DecodeHistograms(br, kNumPatchDictionaryContexts, &code, &context_map));\n  ANSSymbolReader decoder(&code, br);\n\n  auto read_num = [&](size_t context) {\n    size_t r = decoder.ReadHybridUint(context, br, context_map);\n    return r;\n  };\n\n  size_t num_ref_patch = read_num(kNumRefPatchContext);\n  // Limit max memory usage of patches to about 66 bytes per pixel (assuming 8\n  // bytes per size_t)\n  const size_t num_pixels = xsize * ysize;\n  const size_t max_ref_patches = 1024 + num_pixels / 4;\n  const size_t max_patches = max_ref_patches * 4;\n  const size_t max_blending_infos = max_patches * 4;\n  if (num_ref_patch > max_ref_patches) {\n    return JXL_FAILURE(\"Too many patches in dictionary\");\n  }\n  size_t num_ec = shared_->metadata->m.num_extra_channels;\n\n  size_t total_patches = 0;\n  size_t next_size = 1;\n\n  for (size_t id = 0; id < num_ref_patch; id++) {\n    PatchReferencePosition ref_pos;\n    ref_pos.ref = read_num(kReferenceFrameContext);\n    if (ref_pos.ref >= kMaxNumReferenceFrames ||\n        shared_->reference_frames[ref_pos.ref].frame.xsize() == 0) {\n      return JXL_FAILURE(\"Invalid reference frame ID\");\n    }\n    if (!shared_->reference_frames[ref_pos.ref].ib_is_in_xyb) {\n      return JXL_FAILURE(\n          \"Patches cannot use frames saved post color transforms\");\n    }\n    const ImageBundle& ib = shared_->reference_frames[ref_pos.ref].frame;\n    ref_pos.x0 = read_num(kPatchReferencePositionContext);\n    ref_pos.y0 = read_num(kPatchReferencePositionContext);\n    ref_pos.xsize = read_num(kPatchSizeContext) + 1;\n    ref_pos.ysize = read_num(kPatchSizeContext) + 1;\n    if (ref_pos.x0 + ref_pos.xsize > ib.xsize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    if (ref_pos.y0 + ref_pos.ysize > ib.ysize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    size_t id_count = read_num(kPatchCountContext) + 1;\n    total_patches += id_count;\n    if (total_patches > max_patches) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    if (next_size < total_patches) {\n      next_size *= 2;\n      next_size = std::min<size_t>(next_size, max_patches);\n    }\n    if (next_size * (num_ec + 1) > max_blending_infos) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    positions_.reserve(next_size);\n    blendings_.reserve(next_size * (num_ec + 1));\n    for (size_t i = 0; i < id_count; i++) {\n      PatchPosition pos;\n      pos.ref_pos_idx = ref_positions_.size();\n      if (i == 0) {\n        pos.x = read_num(kPatchPositionContext);\n        pos.y = read_num(kPatchPositionContext);\n      } else {\n        pos.x =\n            positions_.back().x + UnpackSigned(read_num(kPatchOffsetContext));\n        pos.y =\n            positions_.back().y + UnpackSigned(read_num(kPatchOffsetContext));\n      }\n      if (pos.x + ref_pos.xsize > xsize) {\n        return JXL_FAILURE(\"Invalid patch x: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.x, ref_pos.xsize, xsize);\n      }\n      if (pos.y + ref_pos.ysize > ysize) {\n        return JXL_FAILURE(\"Invalid patch y: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.y, ref_pos.ysize, ysize);\n      }\n      for (size_t j = 0; j < num_ec + 1; j++) {\n        uint32_t blend_mode = read_num(kPatchBlendModeContext);\n        if (blend_mode >= uint32_t(PatchBlendMode::kNumBlendModes)) {\n          return JXL_FAILURE(\"Invalid patch blend mode: %u\", blend_mode);\n        }\n        PatchBlending info;\n        info.mode = static_cast<PatchBlendMode>(blend_mode);\n        if (UsesAlpha(info.mode)) {\n          *uses_extra_channels = true;\n        }\n        if (info.mode != PatchBlendMode::kNone && j > 0) {\n          *uses_extra_channels = true;\n        }\n        if (UsesAlpha(info.mode) &&\n            shared_->metadata->m.extra_channel_info.size() > 1) {\n          info.alpha_channel = read_num(kPatchAlphaChannelContext);\n          if (info.alpha_channel >=\n              shared_->metadata->m.extra_channel_info.size()) {\n            return JXL_FAILURE(\n                \"Invalid alpha channel for blending: %u out of %u\\n\",\n                info.alpha_channel,\n                (uint32_t)shared_->metadata->m.extra_channel_info.size());\n          }\n        } else {\n          info.alpha_channel = 0;\n        }\n        if (UsesClamp(info.mode)) {\n          info.clamp = read_num(kPatchClampContext);\n        } else {\n          info.clamp = false;\n        }\n        blendings_.push_back(info);\n      }\n      positions_.push_back(std::move(pos));\n    }\n    ref_positions_.emplace_back(std::move(ref_pos));\n  }\n  positions_.shrink_to_fit();\n\n  if (!decoder.CheckANSFinalState()) {\n    return JXL_FAILURE(\"ANS checksum failure.\");\n  }\n\n  ComputePatchTree();\n  return true;\n}",
  "abstract_func_before": "Status PatchDictionary::Decode(BitReader* VAR_0, size_t VAR_1, size_t VAR_2,\n                               bool* VAR_3) {\n  VAR_4.clear();\n  std::vector<uint8_t> VAR_5;\n  ANSCode VAR_6;\n  JXL_RETURN_IF_ERROR(\n      DecodeHistograms(VAR_0, VAR_7, &VAR_6, &VAR_5));\n  ANSSymbolReader VAR_8(&VAR_6, VAR_0);\n\n  auto VAR_9 = [&](size_t VAR_10) {\n    size_t VAR_11 = VAR_8.ReadHybridUint(VAR_10, VAR_0, VAR_5);\n    return VAR_11;\n  };\n\n  size_t VAR_12 = VAR_9(VAR_13);\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  const size_t VAR_14 = VAR_1 * VAR_2;\n  const size_t VAR_15 = 1024 + VAR_14 / 4;\n  const size_t VAR_16 = VAR_15 * 4;\n  const size_t VAR_17 = VAR_16 * 4;\n  if (VAR_12 > VAR_15) {\n    return JXL_FAILURE(\"Too many patches in dictionary\");\n  }\n  size_t VAR_18 = VAR_19->metadata->m.num_extra_channels;\n\n  size_t VAR_20 = 0;\n  size_t VAR_21 = 1;\n\n  for (size_t VAR_22 = 0; VAR_22 < VAR_12; VAR_22++) {\n    PatchReferencePosition VAR_23;\n    VAR_23.ref = VAR_9(VAR_24);\n    if (VAR_23.ref >= VAR_25 ||\n        VAR_19->reference_frames[VAR_23.ref].frame.xsize() == 0) {\n      return JXL_FAILURE(\"Invalid reference frame ID\");\n    }\n    if (!VAR_19->reference_frames[VAR_23.ref].ib_is_in_xyb) {\n      return JXL_FAILURE(\n          \"Patches cannot use frames saved post color transforms\");\n    }\n    const ImageBundle& VAR_26 = VAR_19->reference_frames[VAR_23.ref].frame;\n    VAR_23.x0 = VAR_9(VAR_27);\n    VAR_23.y0 = VAR_9(VAR_27);\n    VAR_23.xsize = VAR_9(VAR_28) + 1;\n    VAR_23.ysize = VAR_9(VAR_28) + 1;\n    if (VAR_23.x0 + VAR_23.xsize > VAR_26.xsize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    if (VAR_23.y0 + VAR_23.ysize > VAR_26.ysize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    size_t VAR_29 = VAR_9(VAR_30) + 1;\n    VAR_20 += VAR_29;\n    if (VAR_20 > VAR_16) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    if (VAR_21 < VAR_20) {\n      VAR_21 *= 2;\n      VAR_21 = std::VAR_31<size_t>(VAR_21, VAR_16);\n    }\n    if (VAR_21 * (VAR_18 + 1) > VAR_17) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    VAR_4.reserve(VAR_21);\n    VAR_32.reserve(VAR_21 * (VAR_18 + 1));\n    for (size_t VAR_33 = 0; VAR_33 < VAR_29; VAR_33++) {\n      PatchPosition VAR_34;\n      VAR_34.ref_pos_idx = VAR_35.size();\n      if (VAR_33 == 0) {\n        VAR_34.x = VAR_9(VAR_36);\n        VAR_34.y = VAR_9(VAR_36);\n      } else {\n        VAR_34.x =\n            VAR_4.back().x + UnpackSigned(VAR_9(VAR_37));\n        VAR_34.y =\n            VAR_4.back().y + UnpackSigned(VAR_9(VAR_37));\n      }\n      if (VAR_34.x + VAR_23.xsize > VAR_1) {\n        return JXL_FAILURE(\"Invalid patch x: at %\" VAR_38 \" + %\" VAR_38\n                           \" > %\" VAR_38,\n                           VAR_34.x, VAR_23.xsize, VAR_1);\n      }\n      if (VAR_34.y + VAR_23.ysize > VAR_2) {\n        return JXL_FAILURE(\"Invalid patch y: at %\" VAR_38 \" + %\" VAR_38\n                           \" > %\" VAR_38,\n                           VAR_34.y, VAR_23.ysize, VAR_2);\n      }\n      for (size_t VAR_39 = 0; VAR_39 < VAR_18 + 1; VAR_39++) {\n        uint32_t VAR_40 = VAR_9(VAR_41);\n        if (VAR_40 >= uint32_t(PatchBlendMode::kNumBlendModes)) {\n          return JXL_FAILURE(\"Invalid patch blend mode: %u\", VAR_40);\n        }\n        PatchBlending VAR_42;\n        VAR_42.mode = VAR_43<PatchBlendMode>(VAR_40);\n        if (UsesAlpha(VAR_42.mode)) {\n          *VAR_3 = true;\n        }\n        if (VAR_42.mode != PatchBlendMode::kNone && VAR_39 > 0) {\n          *VAR_3 = true;\n        }\n        if (UsesAlpha(VAR_42.mode) &&\n            VAR_19->metadata->m.extra_channel_info.size() > 1) {\n          VAR_42.alpha_channel = VAR_9(VAR_44);\n          if (VAR_42.alpha_channel >=\n              VAR_19->metadata->m.extra_channel_info.size()) {\n            return JXL_FAILURE(\n                \"Invalid alpha channel for blending: %u out of %u\\n\",\n                VAR_42.alpha_channel,\n                (uint32_t)VAR_19->metadata->m.extra_channel_info.size());\n          }\n        } else {\n          VAR_42.alpha_channel = 0;\n        }\n        if (UsesClamp(VAR_42.mode)) {\n          VAR_42.clamp = VAR_9(VAR_45);\n        } else {\n          VAR_42.clamp = false;\n        }\n        VAR_32.push_back(VAR_42);\n      }\n      VAR_4.push_back(std::move(VAR_34));\n    }\n    VAR_35.emplace_back(std::move(VAR_23));\n  }\n  VAR_4.shrink_to_fit();\n\n  if (!VAR_8.CheckANSFinalState()) {\n    return JXL_FAILURE(\"ANS checksum failure.\");\n  }\n\n  ComputePatchTree();\n  return true;\n}",
  "func_graph_path_before": "libjxl/489b6b82a6ad27d563646d5d920d8d6bcadbc26b/dec_patch_dictionary.cc/vul/before/0.json",
  "func": "Status PatchDictionary::Decode(BitReader* br, size_t xsize, size_t ysize,\n                               bool* uses_extra_channels) {\n  positions_.clear();\n  std::vector<uint8_t> context_map;\n  ANSCode code;\n  JXL_RETURN_IF_ERROR(\n      DecodeHistograms(br, kNumPatchDictionaryContexts, &code, &context_map));\n  ANSSymbolReader decoder(&code, br);\n\n  auto read_num = [&](size_t context) {\n    size_t r = decoder.ReadHybridUint(context, br, context_map);\n    return r;\n  };\n\n  size_t num_ref_patch = read_num(kNumRefPatchContext);\n  // Limit max memory usage of patches to about 66 bytes per pixel (assuming 8\n  // bytes per size_t)\n  const size_t num_pixels = xsize * ysize;\n  const size_t max_ref_patches = 1024 + num_pixels / 4;\n  const size_t max_patches = max_ref_patches * 4;\n  const size_t max_blending_infos = max_patches * 4;\n  if (num_ref_patch > max_ref_patches) {\n    return JXL_FAILURE(\"Too many patches in dictionary\");\n  }\n  size_t num_ec = shared_->metadata->m.num_extra_channels;\n\n  size_t total_patches = 0;\n  size_t next_size = 1;\n\n  for (size_t id = 0; id < num_ref_patch; id++) {\n    PatchReferencePosition ref_pos;\n    ref_pos.ref = read_num(kReferenceFrameContext);\n    if (ref_pos.ref >= kMaxNumReferenceFrames ||\n        shared_->reference_frames[ref_pos.ref].frame.xsize() == 0) {\n      return JXL_FAILURE(\"Invalid reference frame ID\");\n    }\n    if (!shared_->reference_frames[ref_pos.ref].ib_is_in_xyb) {\n      return JXL_FAILURE(\n          \"Patches cannot use frames saved post color transforms\");\n    }\n    const ImageBundle& ib = shared_->reference_frames[ref_pos.ref].frame;\n    ref_pos.x0 = read_num(kPatchReferencePositionContext);\n    ref_pos.y0 = read_num(kPatchReferencePositionContext);\n    ref_pos.xsize = read_num(kPatchSizeContext) + 1;\n    ref_pos.ysize = read_num(kPatchSizeContext) + 1;\n    if (ref_pos.x0 + ref_pos.xsize > ib.xsize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    if (ref_pos.y0 + ref_pos.ysize > ib.ysize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    size_t id_count = read_num(kPatchCountContext) + 1;\n    total_patches += id_count;\n    if (total_patches > max_patches) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    if (next_size < total_patches) {\n      next_size *= 2;\n      next_size = std::min<size_t>(next_size, max_patches);\n    }\n    if (next_size * (num_ec + 1) > max_blending_infos) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    positions_.reserve(next_size);\n    blendings_.reserve(next_size * (num_ec + 1));\n    for (size_t i = 0; i < id_count; i++) {\n      PatchPosition pos;\n      pos.ref_pos_idx = ref_positions_.size();\n      if (i == 0) {\n        pos.x = read_num(kPatchPositionContext);\n        pos.y = read_num(kPatchPositionContext);\n      } else {\n        ssize_t deltax = UnpackSigned(read_num(kPatchOffsetContext));\n        if (deltax < 0 && static_cast<size_t>(-deltax) > positions_.back().x) {\n          return JXL_FAILURE(\"Invalid patch: negative x coordinate (%\" PRIuS\n                             \" base x %\" PRIdS \" delta x)\",\n                             positions_.back().x, deltax);\n        }\n        pos.x = positions_.back().x + deltax;\n        ssize_t deltay = UnpackSigned(read_num(kPatchOffsetContext));\n        if (deltay < 0 && static_cast<size_t>(-deltay) > positions_.back().y) {\n          return JXL_FAILURE(\"Invalid patch: negative y coordinate (%\" PRIuS\n                             \" base y %\" PRIdS \" delta y)\",\n                             positions_.back().y, deltay);\n        }\n        pos.y = positions_.back().y + deltay;\n      }\n      if (pos.x + ref_pos.xsize > xsize) {\n        return JXL_FAILURE(\"Invalid patch x: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.x, ref_pos.xsize, xsize);\n      }\n      if (pos.y + ref_pos.ysize > ysize) {\n        return JXL_FAILURE(\"Invalid patch y: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.y, ref_pos.ysize, ysize);\n      }\n      for (size_t j = 0; j < num_ec + 1; j++) {\n        uint32_t blend_mode = read_num(kPatchBlendModeContext);\n        if (blend_mode >= uint32_t(PatchBlendMode::kNumBlendModes)) {\n          return JXL_FAILURE(\"Invalid patch blend mode: %u\", blend_mode);\n        }\n        PatchBlending info;\n        info.mode = static_cast<PatchBlendMode>(blend_mode);\n        if (UsesAlpha(info.mode)) {\n          *uses_extra_channels = true;\n        }\n        if (info.mode != PatchBlendMode::kNone && j > 0) {\n          *uses_extra_channels = true;\n        }\n        if (UsesAlpha(info.mode) &&\n            shared_->metadata->m.extra_channel_info.size() > 1) {\n          info.alpha_channel = read_num(kPatchAlphaChannelContext);\n          if (info.alpha_channel >=\n              shared_->metadata->m.extra_channel_info.size()) {\n            return JXL_FAILURE(\n                \"Invalid alpha channel for blending: %u out of %u\\n\",\n                info.alpha_channel,\n                (uint32_t)shared_->metadata->m.extra_channel_info.size());\n          }\n        } else {\n          info.alpha_channel = 0;\n        }\n        if (UsesClamp(info.mode)) {\n          info.clamp = read_num(kPatchClampContext);\n        } else {\n          info.clamp = false;\n        }\n        blendings_.push_back(info);\n      }\n      positions_.push_back(std::move(pos));\n    }\n    ref_positions_.emplace_back(std::move(ref_pos));\n  }\n  positions_.shrink_to_fit();\n\n  if (!decoder.CheckANSFinalState()) {\n    return JXL_FAILURE(\"ANS checksum failure.\");\n  }\n\n  ComputePatchTree();\n  return true;\n}",
  "abstract_func": "Status PatchDictionary::Decode(BitReader* VAR_0, size_t VAR_1, size_t VAR_2,\n                               bool* VAR_3) {\n  VAR_4.clear();\n  std::vector<uint8_t> VAR_5;\n  ANSCode VAR_6;\n  JXL_RETURN_IF_ERROR(\n      DecodeHistograms(VAR_0, VAR_7, &VAR_6, &VAR_5));\n  ANSSymbolReader VAR_8(&VAR_6, VAR_0);\n\n  auto VAR_9 = [&](size_t VAR_10) {\n    size_t VAR_11 = VAR_8.ReadHybridUint(VAR_10, VAR_0, VAR_5);\n    return VAR_11;\n  };\n\n  size_t VAR_12 = VAR_9(VAR_13);\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  const size_t VAR_14 = VAR_1 * VAR_2;\n  const size_t VAR_15 = 1024 + VAR_14 / 4;\n  const size_t VAR_16 = VAR_15 * 4;\n  const size_t VAR_17 = VAR_16 * 4;\n  if (VAR_12 > VAR_15) {\n    return JXL_FAILURE(\"Too many patches in dictionary\");\n  }\n  size_t VAR_18 = VAR_19->metadata->m.num_extra_channels;\n\n  size_t VAR_20 = 0;\n  size_t VAR_21 = 1;\n\n  for (size_t VAR_22 = 0; VAR_22 < VAR_12; VAR_22++) {\n    PatchReferencePosition VAR_23;\n    VAR_23.ref = VAR_9(VAR_24);\n    if (VAR_23.ref >= VAR_25 ||\n        VAR_19->reference_frames[VAR_23.ref].frame.xsize() == 0) {\n      return JXL_FAILURE(\"Invalid reference frame ID\");\n    }\n    if (!VAR_19->reference_frames[VAR_23.ref].ib_is_in_xyb) {\n      return JXL_FAILURE(\n          \"Patches cannot use frames saved post color transforms\");\n    }\n    const ImageBundle& VAR_26 = VAR_19->reference_frames[VAR_23.ref].frame;\n    VAR_23.x0 = VAR_9(VAR_27);\n    VAR_23.y0 = VAR_9(VAR_27);\n    VAR_23.xsize = VAR_9(VAR_28) + 1;\n    VAR_23.ysize = VAR_9(VAR_28) + 1;\n    if (VAR_23.x0 + VAR_23.xsize > VAR_26.xsize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    if (VAR_23.y0 + VAR_23.ysize > VAR_26.ysize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    size_t VAR_29 = VAR_9(VAR_30) + 1;\n    VAR_20 += VAR_29;\n    if (VAR_20 > VAR_16) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    if (VAR_21 < VAR_20) {\n      VAR_21 *= 2;\n      VAR_21 = std::VAR_31<size_t>(VAR_21, VAR_16);\n    }\n    if (VAR_21 * (VAR_18 + 1) > VAR_17) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    VAR_4.reserve(VAR_21);\n    VAR_32.reserve(VAR_21 * (VAR_18 + 1));\n    for (size_t VAR_33 = 0; VAR_33 < VAR_29; VAR_33++) {\n      PatchPosition VAR_34;\n      VAR_34.ref_pos_idx = VAR_35.size();\n      if (VAR_33 == 0) {\n        VAR_34.x = VAR_9(VAR_36);\n        VAR_34.y = VAR_9(VAR_36);\n      } else {\n        ssize_t VAR_37 = UnpackSigned(VAR_9(VAR_38));\n        if (VAR_37 < 0 && VAR_39<size_t>(-VAR_37) > VAR_4.back().x) {\n          return JXL_FAILURE(\"Invalid patch: negative x coordinate (%\" VAR_40\n                             \" base x %\" VAR_41 \" delta x)\",\n                             VAR_4.back().x, VAR_37);\n        }\n        VAR_34.x = VAR_4.back().x + VAR_37;\n        ssize_t VAR_42 = UnpackSigned(VAR_9(VAR_38));\n        if (VAR_42 < 0 && VAR_39<size_t>(-VAR_42) > VAR_4.back().y) {\n          return JXL_FAILURE(\"Invalid patch: negative y coordinate (%\" VAR_40\n                             \" base y %\" VAR_41 \" delta y)\",\n                             VAR_4.back().y, VAR_42);\n        }\n        VAR_34.y = VAR_4.back().y + VAR_42;\n      }\n      if (VAR_34.x + VAR_23.xsize > VAR_1) {\n        return JXL_FAILURE(\"Invalid patch x: at %\" VAR_40 \" + %\" VAR_40\n                           \" > %\" VAR_40,\n                           VAR_34.x, VAR_23.xsize, VAR_1);\n      }\n      if (VAR_34.y + VAR_23.ysize > VAR_2) {\n        return JXL_FAILURE(\"Invalid patch y: at %\" VAR_40 \" + %\" VAR_40\n                           \" > %\" VAR_40,\n                           VAR_34.y, VAR_23.ysize, VAR_2);\n      }\n      for (size_t VAR_43 = 0; VAR_43 < VAR_18 + 1; VAR_43++) {\n        uint32_t VAR_44 = VAR_9(VAR_45);\n        if (VAR_44 >= uint32_t(PatchBlendMode::kNumBlendModes)) {\n          return JXL_FAILURE(\"Invalid patch blend mode: %u\", VAR_44);\n        }\n        PatchBlending VAR_46;\n        VAR_46.mode = VAR_39<PatchBlendMode>(VAR_44);\n        if (UsesAlpha(VAR_46.mode)) {\n          *VAR_3 = true;\n        }\n        if (VAR_46.mode != PatchBlendMode::kNone && VAR_43 > 0) {\n          *VAR_3 = true;\n        }\n        if (UsesAlpha(VAR_46.mode) &&\n            VAR_19->metadata->m.extra_channel_info.size() > 1) {\n          VAR_46.alpha_channel = VAR_9(VAR_47);\n          if (VAR_46.alpha_channel >=\n              VAR_19->metadata->m.extra_channel_info.size()) {\n            return JXL_FAILURE(\n                \"Invalid alpha channel for blending: %u out of %u\\n\",\n                VAR_46.alpha_channel,\n                (uint32_t)VAR_19->metadata->m.extra_channel_info.size());\n          }\n        } else {\n          VAR_46.alpha_channel = 0;\n        }\n        if (UsesClamp(VAR_46.mode)) {\n          VAR_46.clamp = VAR_9(VAR_48);\n        } else {\n          VAR_46.clamp = false;\n        }\n        VAR_32.push_back(VAR_46);\n      }\n      VAR_4.push_back(std::move(VAR_34));\n    }\n    VAR_35.emplace_back(std::move(VAR_23));\n  }\n  VAR_4.shrink_to_fit();\n\n  if (!VAR_8.CheckANSFinalState()) {\n    return JXL_FAILURE(\"ANS checksum failure.\");\n  }\n\n  ComputePatchTree();\n  return true;\n}",
  "func_graph_path": "libjxl/489b6b82a6ad27d563646d5d920d8d6bcadbc26b/dec_patch_dictionary.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -70,10 +70,20 @@\n         pos.x = read_num(kPatchPositionContext);\n         pos.y = read_num(kPatchPositionContext);\n       } else {\n-        pos.x =\n-            positions_.back().x + UnpackSigned(read_num(kPatchOffsetContext));\n-        pos.y =\n-            positions_.back().y + UnpackSigned(read_num(kPatchOffsetContext));\n+        ssize_t deltax = UnpackSigned(read_num(kPatchOffsetContext));\n+        if (deltax < 0 && static_cast<size_t>(-deltax) > positions_.back().x) {\n+          return JXL_FAILURE(\"Invalid patch: negative x coordinate (%\" PRIuS\n+                             \" base x %\" PRIdS \" delta x)\",\n+                             positions_.back().x, deltax);\n+        }\n+        pos.x = positions_.back().x + deltax;\n+        ssize_t deltay = UnpackSigned(read_num(kPatchOffsetContext));\n+        if (deltay < 0 && static_cast<size_t>(-deltay) > positions_.back().y) {\n+          return JXL_FAILURE(\"Invalid patch: negative y coordinate (%\" PRIuS\n+                             \" base y %\" PRIdS \" delta y)\",\n+                             positions_.back().y, deltay);\n+        }\n+        pos.y = positions_.back().y + deltay;\n       }\n       if (pos.x + ref_pos.xsize > xsize) {\n         return JXL_FAILURE(\"Invalid patch x: at %\" PRIuS \" + %\" PRIuS",
  "diff_line_info": {
    "deleted_lines": [
      "        pos.x =",
      "            positions_.back().x + UnpackSigned(read_num(kPatchOffsetContext));",
      "        pos.y =",
      "            positions_.back().y + UnpackSigned(read_num(kPatchOffsetContext));"
    ],
    "added_lines": [
      "        ssize_t deltax = UnpackSigned(read_num(kPatchOffsetContext));",
      "        if (deltax < 0 && static_cast<size_t>(-deltax) > positions_.back().x) {",
      "          return JXL_FAILURE(\"Invalid patch: negative x coordinate (%\" PRIuS",
      "                             \" base x %\" PRIdS \" delta x)\",",
      "                             positions_.back().x, deltax);",
      "        }",
      "        pos.x = positions_.back().x + deltax;",
      "        ssize_t deltay = UnpackSigned(read_num(kPatchOffsetContext));",
      "        if (deltay < 0 && static_cast<size_t>(-deltay) > positions_.back().y) {",
      "          return JXL_FAILURE(\"Invalid patch: negative y coordinate (%\" PRIuS",
      "                             \" base y %\" PRIdS \" delta y)\",",
      "                             positions_.back().y, deltay);",
      "        }",
      "        pos.y = positions_.back().y + deltay;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libjxl/libjxl/pull/2551",
  "description": {
    "pr_info": {
      "title": "Fix an integer underflow bug in patch decoding.",
      "number": 2551
    },
    "comment": [
      "When reading patches, the code doesn't properly check that all patches are in bounds.\r\n\r\nIn particular, if the start of a patch becomes negative (due to the delta coding of patch positions), but not negative *enough* to cause `start + size` to still be negative, the decoder happily accepted the patch. Such a patch would then lead the interval tree building code to run into an infinite loop.",
      "Can the infinite loop behavior be triggered in 0.8.1?",
      "> Can the infinite loop behavior be triggered in 0.8.1?\r\n\r\nYep, we should release a patch release and/or backport this soon.",
      "FTR: this issue got CVE-2023-35790 assigned"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}