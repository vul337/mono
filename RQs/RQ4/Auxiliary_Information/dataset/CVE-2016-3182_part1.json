{
  "cve_id": "CVE-2016-3182",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "Fix heap-buffer-overflow in color_esycc_to_rgb (#748)\n\nWhen all components do not have the same dx/dy, components buffer are\r\nread beyond their end.\r\nDo not convert in this case.\r\n\r\nUpdate uclouvain/openjpeg#725",
  "commit_hash": "ad593c9e0622e0d8d87228e67e4dbd36243ffd22",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/ad593c9e0622e0d8d87228e67e4dbd36243ffd22",
  "file_path": "src/bin/common/color.c",
  "func_name": "color_esycc_to_rgb",
  "func_before": "void color_esycc_to_rgb(opj_image_t *image)\n{\n\tint y, cb, cr, sign1, sign2, val;\n\tunsigned int w, h, max, i;\n\tint flip_value = (1 << (image->comps[0].prec-1));\n\tint max_value = (1 << image->comps[0].prec) - 1;\n\t\n\tif(image->numcomps < 3) return;\n\t\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\t\n\tsign1 = (int)image->comps[1].sgnd;\n\tsign2 = (int)image->comps[2].sgnd;\n\t\n\tmax = w * h;\n\t\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t\n\t\ty = image->comps[0].data[i]; cb = image->comps[1].data[i]; cr = image->comps[2].data[i];\n\t\t\n\t\tif( !sign1) cb -= flip_value;\n\t\tif( !sign2) cr -= flip_value;\n\t\t\n\t\tval = (int)\n\t\t((float)y - (float)0.0000368 * (float)cb\n\t\t + (float)1.40199 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[0].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)1.0003 * (float)y - (float)0.344125 * (float)cb\n\t\t - (float)0.7141128 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[1].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)0.999823 * (float)y + (float)1.77204 * (float)cb\n\t\t - (float)0.000008 *(float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[2].data[i] = val;\n\t}\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\n}",
  "abstract_func_before": "void color_esycc_to_rgb(opj_image_t *VAR_0)\n{\n\tint VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;\n\tunsigned int VAR_7, VAR_8, VAR_9, VAR_10;\n\tint VAR_11 = (1 << (VAR_0->comps[0].prec-1));\n\tint VAR_12 = (1 << VAR_0->comps[0].prec) - 1;\n\t\n\tif(VAR_0->numcomps < 3) return;\n\t\n\tVAR_7 = VAR_0->comps[0].w;\n\tVAR_8 = VAR_0->comps[0].h;\n\t\n\tVAR_4 = (int)VAR_0->comps[1].sgnd;\n\tVAR_5 = (int)VAR_0->comps[2].sgnd;\n\t\n\tVAR_9 = VAR_7 * VAR_8;\n\t\n\tfor(VAR_10 = 0; VAR_10 < VAR_9; ++VAR_10)\n\t{\n\t\t\n\t\tVAR_1 = VAR_0->comps[0].data[VAR_10]; VAR_2 = VAR_0->comps[1].data[VAR_10]; VAR_3 = VAR_0->comps[2].data[VAR_10];\n\t\t\n\t\tif( !VAR_4) VAR_2 -= VAR_11;\n\t\tif( !VAR_5) VAR_3 -= VAR_11;\n\t\t\n\t\tVAR_6 = (int)\n\t\t((float)VAR_1 - (float)0.0000368 * (float)VAR_2\n\t\t + (float)1.40199 * (float)VAR_3 + (float)0.5);\n\t\t\n\t\tif(VAR_6 > VAR_12) VAR_6 = VAR_12; else if(VAR_6 < 0) VAR_6 = 0;\n\t\tVAR_0->comps[0].data[VAR_10] = VAR_6;\n\t\t\n\t\tVAR_6 = (int)\n\t\t((float)1.0003 * (float)VAR_1 - (float)0.344125 * (float)VAR_2\n\t\t - (float)0.7141128 * (float)VAR_3 + (float)0.5);\n\t\t\n\t\tif(VAR_6 > VAR_12) VAR_6 = VAR_12; else if(VAR_6 < 0) VAR_6 = 0;\n\t\tVAR_0->comps[1].data[VAR_10] = VAR_6;\n\t\t\n\t\tVAR_6 = (int)\n\t\t((float)0.999823 * (float)VAR_1 + (float)1.77204 * (float)VAR_2\n\t\t - (float)0.000008 *(float)VAR_3 + (float)0.5);\n\t\t\n\t\tif(VAR_6 > VAR_12) VAR_6 = VAR_12; else if(VAR_6 < 0) VAR_6 = 0;\n\t\tVAR_0->comps[2].data[VAR_10] = VAR_6;\n\t}\n\tVAR_0->color_space = VAR_13;\n\n}",
  "func_graph_path_before": "uclouvain/openjpeg/ad593c9e0622e0d8d87228e67e4dbd36243ffd22/color.c/vul/before/0.json",
  "func": "void color_esycc_to_rgb(opj_image_t *image)\n{\n\tint y, cb, cr, sign1, sign2, val;\n\tunsigned int w, h, max, i;\n\tint flip_value = (1 << (image->comps[0].prec-1));\n\tint max_value = (1 << image->comps[0].prec) - 1;\n\t\n\tif (\n\t\t    (image->numcomps < 3)\n\t\t || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx)\n\t\t || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy)\n\t   ) {\n\t\tfprintf(stderr,\"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n\t}\n\t\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\t\n\tsign1 = (int)image->comps[1].sgnd;\n\tsign2 = (int)image->comps[2].sgnd;\n\t\n\tmax = w * h;\n\t\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t\n\t\ty = image->comps[0].data[i]; cb = image->comps[1].data[i]; cr = image->comps[2].data[i];\n\t\t\n\t\tif( !sign1) cb -= flip_value;\n\t\tif( !sign2) cr -= flip_value;\n\t\t\n\t\tval = (int)\n\t\t((float)y - (float)0.0000368 * (float)cb\n\t\t + (float)1.40199 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[0].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)1.0003 * (float)y - (float)0.344125 * (float)cb\n\t\t - (float)0.7141128 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[1].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)0.999823 * (float)y + (float)1.77204 * (float)cb\n\t\t - (float)0.000008 *(float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[2].data[i] = val;\n\t}\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\n}",
  "abstract_func": "void color_esycc_to_rgb(opj_image_t *VAR_0)\n{\n\tint VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;\n\tunsigned int VAR_7, VAR_8, VAR_9, VAR_10;\n\tint VAR_11 = (1 << (VAR_0->comps[0].prec-1));\n\tint VAR_12 = (1 << VAR_0->comps[0].prec) - 1;\n\t\n\tif (\n\t\t    (VAR_0->numcomps < 3)\n\t\t || (VAR_0->comps[0].dx != VAR_0->comps[1].dx) || (VAR_0->comps[0].dx != VAR_0->comps[2].dx)\n\t\t || (VAR_0->comps[0].dy != VAR_0->comps[1].dy) || (VAR_0->comps[0].dy != VAR_0->comps[2].dy)\n\t   ) {\n\t\tfprintf(VAR_13,\"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", VAR_14,VAR_15);\n\t\treturn;\n\t}\n\t\n\tVAR_7 = VAR_0->comps[0].w;\n\tVAR_8 = VAR_0->comps[0].h;\n\t\n\tVAR_4 = (int)VAR_0->comps[1].sgnd;\n\tVAR_5 = (int)VAR_0->comps[2].sgnd;\n\t\n\tVAR_9 = VAR_7 * VAR_8;\n\t\n\tfor(VAR_10 = 0; VAR_10 < VAR_9; ++VAR_10)\n\t{\n\t\t\n\t\tVAR_1 = VAR_0->comps[0].data[VAR_10]; VAR_2 = VAR_0->comps[1].data[VAR_10]; VAR_3 = VAR_0->comps[2].data[VAR_10];\n\t\t\n\t\tif( !VAR_4) VAR_2 -= VAR_11;\n\t\tif( !VAR_5) VAR_3 -= VAR_11;\n\t\t\n\t\tVAR_6 = (int)\n\t\t((float)VAR_1 - (float)0.0000368 * (float)VAR_2\n\t\t + (float)1.40199 * (float)VAR_3 + (float)0.5);\n\t\t\n\t\tif(VAR_6 > VAR_12) VAR_6 = VAR_12; else if(VAR_6 < 0) VAR_6 = 0;\n\t\tVAR_0->comps[0].data[VAR_10] = VAR_6;\n\t\t\n\t\tVAR_6 = (int)\n\t\t((float)1.0003 * (float)VAR_1 - (float)0.344125 * (float)VAR_2\n\t\t - (float)0.7141128 * (float)VAR_3 + (float)0.5);\n\t\t\n\t\tif(VAR_6 > VAR_12) VAR_6 = VAR_12; else if(VAR_6 < 0) VAR_6 = 0;\n\t\tVAR_0->comps[1].data[VAR_10] = VAR_6;\n\t\t\n\t\tVAR_6 = (int)\n\t\t((float)0.999823 * (float)VAR_1 + (float)1.77204 * (float)VAR_2\n\t\t - (float)0.000008 *(float)VAR_3 + (float)0.5);\n\t\t\n\t\tif(VAR_6 > VAR_12) VAR_6 = VAR_12; else if(VAR_6 < 0) VAR_6 = 0;\n\t\tVAR_0->comps[2].data[VAR_10] = VAR_6;\n\t}\n\tVAR_0->color_space = VAR_16;\n\n}",
  "func_graph_path": "uclouvain/openjpeg/ad593c9e0622e0d8d87228e67e4dbd36243ffd22/color.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,14 @@\n \tint flip_value = (1 << (image->comps[0].prec-1));\n \tint max_value = (1 << image->comps[0].prec) - 1;\n \t\n-\tif(image->numcomps < 3) return;\n+\tif (\n+\t\t    (image->numcomps < 3)\n+\t\t || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx)\n+\t\t || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy)\n+\t   ) {\n+\t\tfprintf(stderr,\"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n+\t\treturn;\n+\t}\n \t\n \tw = image->comps[0].w;\n \th = image->comps[0].h;",
  "diff_line_info": {
    "deleted_lines": [
      "\tif(image->numcomps < 3) return;"
    ],
    "added_lines": [
      "\tif (",
      "\t\t    (image->numcomps < 3)",
      "\t\t || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx)",
      "\t\t || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy)",
      "\t   ) {",
      "\t\tfprintf(stderr,\"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);",
      "\t\treturn;",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/748",
  "description": {
    "pr_info": {
      "title": "Fix heap-buffer-overflow in color_esycc_to_rgb",
      "number": 748
    },
    "comment": [
      "When all components do not have the same dx/dy, components buffer are\nread beyond their end.\nDo not convert in this case.\n\nUpdate #725\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}