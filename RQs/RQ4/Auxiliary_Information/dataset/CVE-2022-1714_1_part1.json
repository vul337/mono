{
  "cve_id": "CVE-2022-1714",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix 4 byte oobread in msp430 disassembler ##crash\n\n* Only crashes with asan builds\n* Add missing =SN register\n* Reported by cnitlrt via huntrdev\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0",
  "commit_hash": "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "git_url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "file_path": "libr/bin/format/elf/elf.c",
  "func_name": "init_shdr",
  "func_before": "static int init_shdr(ELFOBJ *bin) {\n\tut32 shdr_size;\n\tut8 shdr[sizeof (Elf_(Shdr))] = {0};\n\tsize_t i, j, len;\n\n\tr_return_val_if_fail (bin && !bin->shdr, false);\n\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size < 1) {\n\t\treturn false;\n\t}\n\tif (shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff + shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shdr = R_NEWS0 (Elf_(Shdr), bin->ehdr.e_shnum))) {\n\t\tr_sys_perror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"elf_shdr.offset\", bin->ehdr.e_shoff, 0);\n\tsdb_num_set (bin->kv, \"elf_shdr.size\", sizeof (Elf_(Shdr)), 0);\n\tsdb_set (bin->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n\t\t\tR_FREE (bin->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->shdr[i].sh_name = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_type = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_flags = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_addr = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_offset = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_size = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_addralign = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_entsize = R_BIN_ELF_READWORD (shdr, j);\n\t}\n\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_s_type.cparse`; td `k bin/cur/info/elf_s_flags_64.cparse`\n\t// > pf `k bin/cur/info/elf_shdr.format` @ `k bin/cur/info/elf_shdr.offset`\n}",
  "abstract_func_before": "static int init_shdr(ELFOBJ *VAR_0) {\n\tut32 VAR_1;\n\tut8 VAR_2[sizeof (Elf_(VAR_3))] = {0};\n\tsize_t VAR_4, VAR_5, VAR_6;\n\n\tr_return_val_if_fail (VAR_0 && !VAR_0->shdr, false);\n\n\tif (!UT32_MUL (&VAR_1, VAR_0->ehdr.e_shnum, sizeof (Elf_(VAR_3)))) {\n\t\treturn false;\n\t}\n\tif (VAR_1 < 1) {\n\t\treturn false;\n\t}\n\tif (VAR_1 > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (VAR_0->ehdr.e_shoff > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (VAR_0->ehdr.e_shoff + VAR_1 > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (!(VAR_0->shdr = R_NEWS0 (Elf_(VAR_3), VAR_0->ehdr.e_shnum))) {\n\t\tr_sys_perror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (VAR_0->kv, \"elf_shdr.offset\", VAR_0->ehdr.e_shoff, 0);\n\tsdb_num_set (VAR_0->kv, \"elf_shdr.size\", sizeof (Elf_(VAR_3)), 0);\n\tsdb_set (VAR_0->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (VAR_4 = 0; VAR_4 < VAR_0->ehdr.e_shnum; VAR_4++) {\n\t\tVAR_5 = 0;\n\t\tVAR_6 = r_buf_read_at (VAR_0->b, VAR_0->ehdr.e_shoff + VAR_4 * sizeof (Elf_(VAR_3)), VAR_2, sizeof (Elf_(VAR_3)));\n\t\tif (VAR_6 < 1) {\n\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" VAR_7, (ut64) VAR_0->ehdr.e_shoff);\n\t\t\tR_FREE (VAR_0->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tVAR_0->shdr[VAR_4].sh_name = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_type = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_flags = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_addr = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_offset = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_size = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_link = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_info = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_addralign = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_entsize = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t}\n\n#if VAR_8\n\tsdb_set (VAR_0->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (VAR_0->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n}",
  "func_graph_path_before": "radareorg/radare2/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e/elf.c/vul/before/0.json",
  "func": "static int init_shdr(ELFOBJ *bin) {\n\tut32 shdr_size;\n\tut8 shdr[sizeof (Elf_(Shdr))] = {0};\n\tsize_t i, j, len;\n\n\tr_return_val_if_fail (bin && !bin->shdr, false);\n\n\tif (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {\n\t\treturn false;\n\t}\n\tif (shdr_size < 1) {\n\t\treturn false;\n\t}\n\tif (shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->ehdr.e_shoff + shdr_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shdr = R_NEWS0 (Elf_(Shdr), bin->ehdr.e_shnum))) {\n\t\tr_sys_perror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"elf_shdr.offset\", bin->ehdr.e_shoff, 0);\n\tsdb_num_set (bin->kv, \"elf_shdr.size\", sizeof (Elf_(Shdr)), 0);\n\tsdb_set (bin->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (i = 0; i < bin->ehdr.e_shnum; i++) {\n\t\tj = 0;\n\t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_DEBUG (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n\t\t\tR_FREE (bin->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->shdr[i].sh_name = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_type = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_flags = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_addr = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_offset = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_size = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_link = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_info = READ32 (shdr, j);\n\t\tbin->shdr[i].sh_addralign = R_BIN_ELF_READWORD (shdr, j);\n\t\tbin->shdr[i].sh_entsize = R_BIN_ELF_READWORD (shdr, j);\n\t}\n\n#if R_BIN_ELF64\n\tsdb_set (bin->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (bin->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t// Usage example:\n\t// > td `k bin/cur/info/elf_s_type.cparse`; td `k bin/cur/info/elf_s_flags_64.cparse`\n\t// > pf `k bin/cur/info/elf_shdr.format` @ `k bin/cur/info/elf_shdr.offset`\n}",
  "abstract_func": "static int init_shdr(ELFOBJ *VAR_0) {\n\tut32 VAR_1;\n\tut8 VAR_2[sizeof (Elf_(VAR_3))] = {0};\n\tsize_t VAR_4, VAR_5, VAR_6;\n\n\tr_return_val_if_fail (VAR_0 && !VAR_0->shdr, false);\n\n\tif (!UT32_MUL (&VAR_1, VAR_0->ehdr.e_shnum, sizeof (Elf_(VAR_3)))) {\n\t\treturn false;\n\t}\n\tif (VAR_1 < 1) {\n\t\treturn false;\n\t}\n\tif (VAR_1 > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (VAR_0->ehdr.e_shoff > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (VAR_0->ehdr.e_shoff + VAR_1 > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (!(VAR_0->shdr = R_NEWS0 (Elf_(VAR_3), VAR_0->ehdr.e_shnum))) {\n\t\tr_sys_perror (\"malloc (shdr)\");\n\t\treturn false;\n\t}\n\tsdb_num_set (VAR_0->kv, \"elf_shdr.offset\", VAR_0->ehdr.e_shoff, 0);\n\tsdb_num_set (VAR_0->kv, \"elf_shdr.size\", sizeof (Elf_(VAR_3)), 0);\n\tsdb_set (VAR_0->kv, \"elf_s_type.cparse\", \"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,\"\n\t\t\t\"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,\"\n\t\t\t\"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,\"\n\t\t\t\"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};\", 0);\n\n\tfor (VAR_4 = 0; VAR_4 < VAR_0->ehdr.e_shnum; VAR_4++) {\n\t\tVAR_5 = 0;\n\t\tVAR_6 = r_buf_read_at (VAR_0->b, VAR_0->ehdr.e_shoff + VAR_4 * sizeof (Elf_(VAR_3)), VAR_2, sizeof (Elf_(VAR_3)));\n\t\tif (VAR_6 < 1) {\n\t\t\tR_LOG_DEBUG (\"read (shdr) at 0x%\" VAR_7, (ut64) VAR_0->ehdr.e_shoff);\n\t\t\tR_FREE (VAR_0->shdr);\n\t\t\treturn false;\n\t\t}\n\t\tVAR_0->shdr[VAR_4].sh_name = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_type = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_flags = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_addr = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_offset = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_size = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_link = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_info = READ32 (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_addralign = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t\tVAR_0->shdr[VAR_4].sh_entsize = R_BIN_ELF_READWORD (VAR_2, VAR_5);\n\t}\n\n#if VAR_8\n\tsdb_set (VAR_0->kv, \"elf_s_flags_64.cparse\", \"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,\"\n\t\t\t\"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,\"\n\t\t\t\"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_shdr.format\", \"x[4]E[8]Eqqqxxqq name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_64)flags addr offset size link info addralign entsize\", 0);\n#else\n\tsdb_set (VAR_0->kv, \"elf_s_flags_32.cparse\", \"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,\"\n\t\t\t\"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,\"\n\t\t\t\"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};\", 0);\n\tsdb_set (VAR_0->kv, \"elf_shdr.format\", \"x[4]E[4]Exxxxxxx name (elf_s_type)type\"\n\t\t\t\" (elf_s_flags_32)flags addr offset size link info addralign entsize\", 0);\n#endif\n\treturn true;\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n}",
  "func_graph_path": "radareorg/radare2/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e/elf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,7 @@\n \t\tj = 0;\n \t\tlen = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n \t\tif (len < 1) {\n-\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n+\t\t\tR_LOG_DEBUG (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);\n \t\t\tR_FREE (bin->shdr);\n \t\t\treturn false;\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);"
    ],
    "added_lines": [
      "\t\t\tR_LOG_DEBUG (\"read (shdr) at 0x%\" PFMT64x, (ut64) bin->ehdr.e_shoff);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/20097",
  "description": {
    "pr_info": {
      "title": "Fix 4 byte oobread in msp430 disassembler ##crash",
      "number": 20097
    },
    "comment": [
      "* Only crashes with asan builds\r\n* Add missing =SN register\r\n* Reported by cnitlrt via huntrdev\r\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}