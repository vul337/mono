{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_client.cpp",
  "func_name": "zmq::curve_client_t::produce_initiate",
  "func_before": "int zmq::curve_client_t::produce_initiate (msg_t *msg_)\n{\n    uint8_t vouch_nonce [crypto_box_NONCEBYTES];\n    uint8_t vouch_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t vouch_box [crypto_box_BOXZEROBYTES + 80];\n\n    //  Create vouch = Box [C',S](C->S')\n    memset (vouch_plaintext, 0, crypto_box_ZEROBYTES);\n    memcpy (vouch_plaintext + crypto_box_ZEROBYTES, cn_public, 32);\n    memcpy (vouch_plaintext + crypto_box_ZEROBYTES + 32, server_key, 32);\n\n    memcpy (vouch_nonce, \"VOUCH---\", 8);\n    randombytes (vouch_nonce + 8, 16);\n\n    int rc = crypto_box (vouch_box, vouch_plaintext,\n                         sizeof vouch_plaintext,\n                         vouch_nonce, cn_server, secret_key);\n    zmq_assert (rc == 0);\n\n    //  Assume here that metadata is limited to 256 bytes\n    uint8_t initiate_nonce [crypto_box_NONCEBYTES];\n    uint8_t initiate_plaintext [crypto_box_ZEROBYTES + 128 + 256];\n    uint8_t initiate_box [crypto_box_BOXZEROBYTES + 144 + 256];\n\n    //  Create Box [C + vouch + metadata](C'->S')\n    memset (initiate_plaintext, 0, crypto_box_ZEROBYTES);\n    memcpy (initiate_plaintext + crypto_box_ZEROBYTES,\n            public_key, 32);\n    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 32,\n            vouch_nonce + 8, 16);\n    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 48,\n            vouch_box + crypto_box_BOXZEROBYTES, 80);\n\n    //  Metadata starts after vouch\n    uint8_t *ptr = initiate_plaintext + crypto_box_ZEROBYTES + 128;\n\n    //  Add socket type property\n    const char *socket_type = socket_type_string (options.type);\n    ptr += add_property (ptr, \"Socket-Type\", socket_type, strlen (socket_type));\n\n    //  Add identity property\n    if (options.type == ZMQ_REQ\n    ||  options.type == ZMQ_DEALER\n    ||  options.type == ZMQ_ROUTER)\n        ptr += add_property (ptr, \"Identity\", options.identity, options.identity_size);\n\n    const size_t mlen = ptr - initiate_plaintext;\n\n    memcpy (initiate_nonce, \"CurveZMQINITIATE\", 16);\n    memcpy (initiate_nonce + 16, &cn_nonce, 8);\n\n    rc = crypto_box (initiate_box, initiate_plaintext,\n                     mlen, initiate_nonce, cn_server, cn_secret);\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (113 + mlen - crypto_box_BOXZEROBYTES);\n    errno_assert (rc == 0);\n\n    uint8_t *initiate = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (initiate, \"\\x08INITIATE\", 9);\n    //  Cookie provided by the server in the WELCOME command\n    memcpy (initiate + 9, cn_cookie, 96);\n    //  Short nonce, prefixed by \"CurveZMQINITIATE\"\n    memcpy (initiate + 105, &cn_nonce, 8);\n    //  Box [C + vouch + metadata](C'->S')\n    memcpy (initiate + 113, initiate_box + crypto_box_BOXZEROBYTES,\n            mlen - crypto_box_BOXZEROBYTES);\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func_before": "int zmq::curve_client_t::produce_initiate (msg_t *VAR_0)\n{\n    uint8_t VAR_1 [VAR_2];\n    uint8_t VAR_3 [VAR_4 + 64];\n    uint8_t VAR_5 [VAR_6 + 80];\n\n    /* COMMENT_0 */\n    memset (VAR_3, 0, VAR_4);\n    memcpy (VAR_3 + VAR_4, VAR_7, 32);\n    memcpy (VAR_3 + VAR_4 + 32, VAR_8, 32);\n\n    memcpy (VAR_1, \"VOUCH---\", 8);\n    randombytes (VAR_1 + 8, 16);\n\n    int VAR_9 = crypto_box (VAR_5, VAR_3,\n                         sizeof VAR_3,\n                         VAR_1, VAR_10, VAR_11);\n    zmq_assert (VAR_9 == 0);\n\n    /* COMMENT_1 */\n    uint8_t VAR_12 [VAR_2];\n    uint8_t VAR_13 [VAR_4 + 128 + 256];\n    uint8_t VAR_14 [VAR_6 + 144 + 256];\n\n    /* COMMENT_2 */\n    memset (VAR_13, 0, VAR_4);\n    memcpy (VAR_13 + VAR_4,\n            VAR_15, 32);\n    memcpy (VAR_13 + VAR_4 + 32,\n            VAR_1 + 8, 16);\n    memcpy (VAR_13 + VAR_4 + 48,\n            VAR_5 + VAR_6, 80);\n\n    /* COMMENT_3 */\n    uint8_t *VAR_16 = VAR_13 + VAR_4 + 128;\n\n    /* COMMENT_4 */\n    const char *VAR_17 = socket_type_string (VAR_18.type);\n    VAR_16 += add_property (VAR_16, \"Socket-Type\", VAR_17, strlen (VAR_17));\n\n    /* COMMENT_5 */\n    if (VAR_18.type == VAR_19\n    ||  VAR_18.type == VAR_20\n    ||  VAR_18.type == VAR_21)\n        VAR_16 += add_property (VAR_16, \"Identity\", VAR_18.identity, VAR_18.identity_size);\n\n    const size_t VAR_22 = VAR_16 - VAR_13;\n\n    memcpy (VAR_12, \"CurveZMQINITIATE\", 16);\n    memcpy (VAR_12 + 16, &VAR_23, 8);\n\n    VAR_9 = crypto_box (VAR_14, VAR_13,\n                     VAR_22, VAR_12, VAR_10, VAR_24);\n    zmq_assert (VAR_9 == 0);\n\n    VAR_9 = VAR_0->init_size (113 + VAR_22 - VAR_6);\n    errno_assert (VAR_9 == 0);\n\n    uint8_t *VAR_25 = VAR_26 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_25, \"\\x08INITIATE\", 9);\n    /* COMMENT_6 */\n    memcpy (VAR_25 + 9, VAR_27, 96);\n    /* COMMENT_7 */\n    memcpy (VAR_25 + 105, &VAR_23, 8);\n    /* COMMENT_8 */\n    memcpy (VAR_25 + 113, VAR_14 + VAR_6,\n            VAR_22 - VAR_6);\n    VAR_23++;\n\n    return 0;\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_client.cpp/vul/before/3.json",
  "func": "int zmq::curve_client_t::produce_initiate (msg_t *msg_)\n{\n    uint8_t vouch_nonce [crypto_box_NONCEBYTES];\n    uint8_t vouch_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t vouch_box [crypto_box_BOXZEROBYTES + 80];\n\n    //  Create vouch = Box [C',S](C->S')\n    memset (vouch_plaintext, 0, crypto_box_ZEROBYTES);\n    memcpy (vouch_plaintext + crypto_box_ZEROBYTES, cn_public, 32);\n    memcpy (vouch_plaintext + crypto_box_ZEROBYTES + 32, server_key, 32);\n\n    memcpy (vouch_nonce, \"VOUCH---\", 8);\n    randombytes (vouch_nonce + 8, 16);\n\n    int rc = crypto_box (vouch_box, vouch_plaintext,\n                         sizeof vouch_plaintext,\n                         vouch_nonce, cn_server, secret_key);\n    zmq_assert (rc == 0);\n\n    //  Assume here that metadata is limited to 256 bytes\n    uint8_t initiate_nonce [crypto_box_NONCEBYTES];\n    uint8_t initiate_plaintext [crypto_box_ZEROBYTES + 128 + 256];\n    uint8_t initiate_box [crypto_box_BOXZEROBYTES + 144 + 256];\n\n    //  Create Box [C + vouch + metadata](C'->S')\n    memset (initiate_plaintext, 0, crypto_box_ZEROBYTES);\n    memcpy (initiate_plaintext + crypto_box_ZEROBYTES,\n            public_key, 32);\n    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 32,\n            vouch_nonce + 8, 16);\n    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 48,\n            vouch_box + crypto_box_BOXZEROBYTES, 80);\n\n    //  Metadata starts after vouch\n    uint8_t *ptr = initiate_plaintext + crypto_box_ZEROBYTES + 128;\n\n    //  Add socket type property\n    const char *socket_type = socket_type_string (options.type);\n    ptr += add_property (ptr, \"Socket-Type\", socket_type, strlen (socket_type));\n\n    //  Add identity property\n    if (options.type == ZMQ_REQ\n    ||  options.type == ZMQ_DEALER\n    ||  options.type == ZMQ_ROUTER)\n        ptr += add_property (ptr, \"Identity\", options.identity, options.identity_size);\n\n    const size_t mlen = ptr - initiate_plaintext;\n\n    memcpy (initiate_nonce, \"CurveZMQINITIATE\", 16);\n    put_uint64 (initiate_nonce + 16, cn_nonce);\n\n    rc = crypto_box (initiate_box, initiate_plaintext,\n                     mlen, initiate_nonce, cn_server, cn_secret);\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (113 + mlen - crypto_box_BOXZEROBYTES);\n    errno_assert (rc == 0);\n\n    uint8_t *initiate = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (initiate, \"\\x08INITIATE\", 9);\n    //  Cookie provided by the server in the WELCOME command\n    memcpy (initiate + 9, cn_cookie, 96);\n    //  Short nonce, prefixed by \"CurveZMQINITIATE\"\n    memcpy (initiate + 105, initiate_nonce + 16, 8);\n    //  Box [C + vouch + metadata](C'->S')\n    memcpy (initiate + 113, initiate_box + crypto_box_BOXZEROBYTES,\n            mlen - crypto_box_BOXZEROBYTES);\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func": "int zmq::curve_client_t::produce_initiate (msg_t *VAR_0)\n{\n    uint8_t VAR_1 [VAR_2];\n    uint8_t VAR_3 [VAR_4 + 64];\n    uint8_t VAR_5 [VAR_6 + 80];\n\n    /* COMMENT_0 */\n    memset (VAR_3, 0, VAR_4);\n    memcpy (VAR_3 + VAR_4, VAR_7, 32);\n    memcpy (VAR_3 + VAR_4 + 32, VAR_8, 32);\n\n    memcpy (VAR_1, \"VOUCH---\", 8);\n    randombytes (VAR_1 + 8, 16);\n\n    int VAR_9 = crypto_box (VAR_5, VAR_3,\n                         sizeof VAR_3,\n                         VAR_1, VAR_10, VAR_11);\n    zmq_assert (VAR_9 == 0);\n\n    /* COMMENT_1 */\n    uint8_t VAR_12 [VAR_2];\n    uint8_t VAR_13 [VAR_4 + 128 + 256];\n    uint8_t VAR_14 [VAR_6 + 144 + 256];\n\n    /* COMMENT_2 */\n    memset (VAR_13, 0, VAR_4);\n    memcpy (VAR_13 + VAR_4,\n            VAR_15, 32);\n    memcpy (VAR_13 + VAR_4 + 32,\n            VAR_1 + 8, 16);\n    memcpy (VAR_13 + VAR_4 + 48,\n            VAR_5 + VAR_6, 80);\n\n    /* COMMENT_3 */\n    uint8_t *VAR_16 = VAR_13 + VAR_4 + 128;\n\n    /* COMMENT_4 */\n    const char *VAR_17 = socket_type_string (VAR_18.type);\n    VAR_16 += add_property (VAR_16, \"Socket-Type\", VAR_17, strlen (VAR_17));\n\n    /* COMMENT_5 */\n    if (VAR_18.type == VAR_19\n    ||  VAR_18.type == VAR_20\n    ||  VAR_18.type == VAR_21)\n        VAR_16 += add_property (VAR_16, \"Identity\", VAR_18.identity, VAR_18.identity_size);\n\n    const size_t VAR_22 = VAR_16 - VAR_13;\n\n    memcpy (VAR_12, \"CurveZMQINITIATE\", 16);\n    put_uint64 (VAR_12 + 16, VAR_23);\n\n    VAR_9 = crypto_box (VAR_14, VAR_13,\n                     VAR_22, VAR_12, VAR_10, VAR_24);\n    zmq_assert (VAR_9 == 0);\n\n    VAR_9 = VAR_0->init_size (113 + VAR_22 - VAR_6);\n    errno_assert (VAR_9 == 0);\n\n    uint8_t *VAR_25 = VAR_26 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_25, \"\\x08INITIATE\", 9);\n    /* COMMENT_6 */\n    memcpy (VAR_25 + 9, VAR_27, 96);\n    /* COMMENT_7 */\n    memcpy (VAR_25 + 105, VAR_12 + 16, 8);\n    /* COMMENT_8 */\n    memcpy (VAR_25 + 113, VAR_14 + VAR_6,\n            VAR_22 - VAR_6);\n    VAR_23++;\n\n    return 0;\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_client.cpp/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,7 @@\n     const size_t mlen = ptr - initiate_plaintext;\n \n     memcpy (initiate_nonce, \"CurveZMQINITIATE\", 16);\n-    memcpy (initiate_nonce + 16, &cn_nonce, 8);\n+    put_uint64 (initiate_nonce + 16, cn_nonce);\n \n     rc = crypto_box (initiate_box, initiate_plaintext,\n                      mlen, initiate_nonce, cn_server, cn_secret);\n@@ -62,7 +62,7 @@\n     //  Cookie provided by the server in the WELCOME command\n     memcpy (initiate + 9, cn_cookie, 96);\n     //  Short nonce, prefixed by \"CurveZMQINITIATE\"\n-    memcpy (initiate + 105, &cn_nonce, 8);\n+    memcpy (initiate + 105, initiate_nonce + 16, 8);\n     //  Box [C + vouch + metadata](C'->S')\n     memcpy (initiate + 113, initiate_box + crypto_box_BOXZEROBYTES,\n             mlen - crypto_box_BOXZEROBYTES);",
  "diff_line_info": {
    "deleted_lines": [
      "    memcpy (initiate_nonce + 16, &cn_nonce, 8);",
      "    memcpy (initiate + 105, &cn_nonce, 8);"
    ],
    "added_lines": [
      "    put_uint64 (initiate_nonce + 16, cn_nonce);",
      "    memcpy (initiate + 105, initiate_nonce + 16, 8);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": {
    "pr_info": {
      "title": "Problem: curve messages can be replayed",
      "number": 1189
    },
    "comment": [
      "Solution: ensure message short nonces are strictly increasing and validate them\n",
      "Fixes #1191.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}