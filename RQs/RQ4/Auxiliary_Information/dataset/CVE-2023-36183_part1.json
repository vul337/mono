{
  "cve_id": "CVE-2023-36183",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "AcademySoftwareFoundation/OpenImageIO",
  "commit_msg": "fix heap-buffer-overflow in function ICOInput::readimg in file src/ico.imageio/icoinput.cpp",
  "commit_hash": "03a368113a4c5abb45f9e896f0eff274a2571a00",
  "git_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/commit/03a368113a4c5abb45f9e896f0eff274a2571a00",
  "file_path": "src/ico.imageio/icoinput.cpp",
  "func_name": "ICOInput::readimg",
  "func_before": "bool\nICOInput::readimg()\n{\n    if (m_png) {\n        // subimage is a PNG\n        std::string s = PNG_pvt::read_into_buffer(m_png, m_info, m_spec, m_buf);\n\n        //std::cerr << \"[ico] PNG buffer size = \" << m_buf.size () << \"\\n\";\n\n        if (s.length()) {\n            errorf(\"%s\", s);\n            return false;\n        }\n\n        return true;\n    }\n\n    // otherwise we're dealing with a DIB\n    OIIO_DASSERT(m_spec.scanline_bytes() == ((size_t)m_spec.width * 4));\n    m_buf.resize(m_spec.image_bytes());\n\n    //std::cerr << \"[ico] DIB buffer size = \" << m_buf.size () << \"\\n\";\n\n    // icons < 16bpp are colour-indexed, so load the palette\n    // a palette consists of 4-byte BGR quads, with the last byte unused (reserved)\n    std::vector<ico_palette_entry> palette(m_palette_size);\n    if (m_bpp < 16) {  // >= 16-bit icons are unpaletted\n        for (int i = 0; i < m_palette_size; i++)\n            if (!fread(&palette[i], 1, sizeof(ico_palette_entry)))\n                return false;\n    }\n\n    // read the colour data (the 1-bit transparency is added later on)\n    // scanline length in bytes (aligned to a multiple of 32 bits)\n    int slb = (m_spec.width * m_bpp + 7) / 8  // real data bytes\n              + (4 - ((m_spec.width * m_bpp + 7) / 8) % 4) % 4;  // padding\n    std::vector<unsigned char> scanline(slb);\n    ico_palette_entry* pe;\n    int k;\n    for (int y = m_spec.height - 1; y >= 0; y--) {\n        if (!fread(&scanline[0], 1, slb))\n            return false;\n        for (int x = 0; x < m_spec.width; x++) {\n            k = y * m_spec.width * 4 + x * 4;\n            // fill the buffer\n            switch (m_bpp) {\n            case 1:\n                pe = &palette[(scanline[x / 8] & (1 << (7 - x % 8))) != 0];\n                m_buf[k + 0] = pe->r;\n                m_buf[k + 1] = pe->g;\n                m_buf[k + 2] = pe->b;\n                break;\n            case 4:\n                pe           = &palette[(scanline[x / 2] & 0xF0) >> 4];\n                m_buf[k + 0] = pe->r;\n                m_buf[k + 1] = pe->g;\n                m_buf[k + 2] = pe->b;\n                // 2 pixels per byte\n                pe = &palette[scanline[x / 2] & 0x0F];\n                if (x == m_spec.width - 1)\n                    break;  // avoid buffer overflows\n                x++;\n                m_buf[k + 4] = pe->r;\n                m_buf[k + 5] = pe->g;\n                m_buf[k + 6] = pe->b;\n                /*std::cerr << \"[ico] \" << y << \" 2*4bit pixel: \"\n                          << ((int)scanline[x / 2]) << \" -> \"\n                          << ((int)(scanline[x / 2] & 0xF0) >> 4)\n                          << \" & \" << ((int)(scanline[x / 2]) & 0x0F)\n                          << \"\\n\";*/\n                break;\n            case 8:\n                pe           = &palette[scanline[x]];\n                m_buf[k + 0] = pe->r;\n                m_buf[k + 1] = pe->g;\n                m_buf[k + 2] = pe->b;\n                break;\n                // bpp values > 8 mean non-indexed BGR(A) images\n#if 0\n            // doesn't seem like ICOs can really be 16-bit, where did I even get\n            // this notion from?\n            case 16:\n                // FIXME: find out exactly which channel gets the 1 extra\n                // bit; currently I assume it's green: 5B, 6G, 5R\n                // extract and shift the bits\n                m_buf[k + 0] = (scanline[x * 2 + 1] & 0x1F) << 3;\n                m_buf[k + 1] = ((scanline[x * 2 + 1] & 0xE0) >> 3)\n                               | ((scanline[x * 2 + 0] & 0x07) << 5);\n                m_buf[k + 2] = scanline[x * 2 + 0] & 0xF8;\n                break;\n#endif\n            case 24:\n                m_buf[k + 0] = scanline[x * 3 + 2];\n                m_buf[k + 1] = scanline[x * 3 + 1];\n                m_buf[k + 2] = scanline[x * 3 + 0];\n                break;\n            case 32:\n                m_buf[k + 0] = scanline[x * 4 + 2];\n                m_buf[k + 1] = scanline[x * 4 + 1];\n                m_buf[k + 2] = scanline[x * 4 + 0];\n                m_buf[k + 3] = scanline[x * 4 + 3];\n                break;\n            }\n        }\n    }\n\n    // read the 1-bit transparency for < 32-bit icons\n    if (m_bpp < 32) {\n        // also aligned to a multiple of 32 bits\n        slb = (m_spec.width + 7) / 8                     // real data bytes\n              + (4 - ((m_spec.width + 7) / 8) % 4) % 4;  // padding\n        scanline.resize(slb);\n        for (int y = m_spec.height - 1; y >= 0; y--) {\n            if (!fread(&scanline[0], 1, slb))\n                return false;\n            for (int x = 0; x < m_spec.width; x += 8) {\n                for (int b = 0; b < 8; b++) {  // bit\n                    k = y * m_spec.width * 4 + (x + 7 - b) * 4;\n                    if (scanline[x / 8] & (1 << b))\n                        m_buf[k + 3] = 0;\n                    else\n                        m_buf[k + 3] = 255;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "abstract_func_before": "bool\nICOInput::readimg()\n{\n    if (VAR_0) {\n        /* COMMENT_0 */\n        std::string VAR_1 = PNG_pvt::read_into_buffer(VAR_0, VAR_2, VAR_3, VAR_4);\n\n        /* COMMENT_1 */\n\n        if (VAR_1.length()) {\n            errorf(\"%s\", VAR_1);\n            return false;\n        }\n\n        return true;\n    }\n\n    /* COMMENT_2 */\n    OIIO_DASSERT(VAR_3.scanline_bytes() == ((size_t)VAR_3.width * 4));\n    VAR_4.resize(VAR_3.image_bytes());\n\n    /* COMMENT_3 */\n\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    std::vector<ico_palette_entry> palette(m_palette_size);\n    if (VAR_5 < 16) {  /* COMMENT_6 */\n        for (int VAR_6 = 0; VAR_6 < m_palette_size; VAR_6++)\n            if (!fread(&VAR_7[VAR_6], 1, sizeof(ico_palette_entry)))\n                return false;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    int VAR_8 = (VAR_3.width * VAR_5 + 7) / 8  /* COMMENT_9 */\n              + (4 - ((VAR_3.width * VAR_5 + 7) / 8) % 4) % 4;  /* COMMENT_10 */\n    std::vector<unsigned char> scanline(slb);\n    ico_palette_entry* VAR_9;\n    int VAR_10;\n    for (int VAR_11 = VAR_3.height - 1; VAR_11 >= 0; VAR_11--) {\n        if (!fread(&VAR_12[0], 1, slb))\n            return false;\n        for (int VAR_13 = 0; VAR_13 < VAR_3.width; VAR_13++) {\n            VAR_10 = VAR_11 * VAR_3.width * 4 + VAR_13 * 4;\n            /* COMMENT_11 */\n            switch (VAR_5) {\n            case 1:\n                VAR_9 = &VAR_7[(VAR_12[VAR_13 / 8] & (1 << (7 - VAR_13 % 8))) != 0];\n                VAR_4[VAR_10 + 0] = VAR_9->r;\n                VAR_4[VAR_10 + 1] = VAR_9->g;\n                VAR_4[VAR_10 + 2] = VAR_9->b;\n                break;\n            case 4:\n                VAR_9           = &VAR_7[(VAR_12[VAR_13 / 2] & 0xF0) >> 4];\n                VAR_4[VAR_10 + 0] = VAR_9->r;\n                VAR_4[VAR_10 + 1] = VAR_9->g;\n                VAR_4[VAR_10 + 2] = VAR_9->b;\n                /* COMMENT_12 */\n                VAR_9 = &VAR_7[VAR_12[VAR_13 / 2] & 0x0F];\n                if (VAR_13 == VAR_3.width - 1)\n                    break;  /* COMMENT_13 */\n                VAR_13++;\n                VAR_4[VAR_10 + 4] = VAR_9->r;\n                VAR_4[VAR_10 + 5] = VAR_9->g;\n                VAR_4[VAR_10 + 6] = VAR_9->b;\n                /* COMMENT_14 */\n                                                             \n                                                                 \n                                                                     \n                                    \n                break;\n            case 8:\n                VAR_9           = &VAR_7[VAR_12[VAR_13]];\n                VAR_4[VAR_10 + 0] = VAR_9->r;\n                VAR_4[VAR_10 + 1] = VAR_9->g;\n                VAR_4[VAR_10 + 2] = VAR_9->b;\n                break;\n                /* COMMENT_19 */\n#if 0\n            /* COMMENT_20 */\n            /* COMMENT_21 */\n            case 16:\n                /* COMMENT_22 */\n                /* COMMENT_23 */\n                /* COMMENT_24 */\n                VAR_4[VAR_10 + 0] = (VAR_12[VAR_13 * 2 + 1] & 0x1F) << 3;\n                VAR_4[VAR_10 + 1] = ((VAR_12[VAR_13 * 2 + 1] & 0xE0) >> 3)\n                               | ((VAR_12[VAR_13 * 2 + 0] & 0x07) << 5);\n                VAR_4[VAR_10 + 2] = VAR_12[VAR_13 * 2 + 0] & 0xF8;\n                break;\n#endif\n            case 24:\n                VAR_4[VAR_10 + 0] = VAR_12[VAR_13 * 3 + 2];\n                VAR_4[VAR_10 + 1] = VAR_12[VAR_13 * 3 + 1];\n                VAR_4[VAR_10 + 2] = VAR_12[VAR_13 * 3 + 0];\n                break;\n            case 32:\n                VAR_4[VAR_10 + 0] = VAR_12[VAR_13 * 4 + 2];\n                VAR_4[VAR_10 + 1] = VAR_12[VAR_13 * 4 + 1];\n                VAR_4[VAR_10 + 2] = VAR_12[VAR_13 * 4 + 0];\n                VAR_4[VAR_10 + 3] = VAR_12[VAR_13 * 4 + 3];\n                break;\n            }\n        }\n    }\n\n    /* COMMENT_25 */\n    if (VAR_5 < 32) {\n        /* COMMENT_26 */\n        slb = (VAR_3.width + 7) / 8                     /* COMMENT_9 */\n              + (4 - ((VAR_3.width + 7) / 8) % 4) % 4;  /* COMMENT_10 */\n        VAR_12.resize(slb);\n        for (int VAR_11 = VAR_3.height - 1; VAR_11 >= 0; VAR_11--) {\n            if (!fread(&VAR_12[0], 1, slb))\n                return false;\n            for (int VAR_13 = 0; VAR_13 < VAR_3.width; VAR_13 += 8) {\n                for (int VAR_14 = 0; VAR_14 < 8; VAR_14++) {  /* COMMENT_27 */\n                    VAR_10 = VAR_11 * VAR_3.width * 4 + (VAR_13 + 7 - VAR_14) * 4;\n                    if (VAR_12[VAR_13 / 8] & (1 << VAR_14))\n                        VAR_4[VAR_10 + 3] = 0;\n                    else\n                        VAR_4[VAR_10 + 3] = 255;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/OpenImageIO/03a368113a4c5abb45f9e896f0eff274a2571a00/icoinput.cpp/vul/before/0.json",
  "func": "bool\nICOInput::readimg()\n{\n    if (m_png) {\n        // subimage is a PNG\n        std::string s = PNG_pvt::read_into_buffer(m_png, m_info, m_spec, m_buf);\n\n        //std::cerr << \"[ico] PNG buffer size = \" << m_buf.size () << \"\\n\";\n\n        if (s.length()) {\n            errorf(\"%s\", s);\n            return false;\n        }\n\n        return true;\n    }\n\n    // otherwise we're dealing with a DIB\n    OIIO_DASSERT(m_spec.scanline_bytes() == ((size_t)m_spec.width * 4));\n    m_buf.resize(m_spec.image_bytes());\n\n    //std::cerr << \"[ico] DIB buffer size = \" << m_buf.size () << \"\\n\";\n\n    // icons < 16bpp are colour-indexed, so load the palette\n    // a palette consists of 4-byte BGR quads, with the last byte unused (reserved)\n    std::vector<ico_palette_entry> palette(m_palette_size);\n    if (m_bpp < 16) {  // >= 16-bit icons are unpaletted\n        for (int i = 0; i < m_palette_size; i++)\n            if (!fread(&palette[i], 1, sizeof(ico_palette_entry)))\n                return false;\n    }\n\n    // read the colour data (the 1-bit transparency is added later on)\n    // scanline length in bytes (aligned to a multiple of 32 bits)\n    int slb = (m_spec.width * m_bpp + 7) / 8  // real data bytes\n              + (4 - ((m_spec.width * m_bpp + 7) / 8) % 4) % 4;  // padding\n    std::vector<unsigned char> scanline(slb);\n    ico_palette_entry* pe;\n    int k;\n    int index;\n    for (int y = m_spec.height - 1; y >= 0; y--) {\n        if (!fread(&scanline[0], 1, slb))\n            return false;\n        for (int x = 0; x < m_spec.width; x++) {\n            k = y * m_spec.width * 4 + x * 4;\n            // fill the buffer\n            switch (m_bpp) {\n            case 1:\n                index = ((scanline[x / 8] & (1 << (7 - x % 8))) != 0);\n                if (index >= m_palette_size) {\n                    errorfmt(\"Possible corruption: index exceeds palette size\");\n                    return false;\n                }\n                pe           = &palette[index];\n                m_buf[k + 0] = pe->r;\n                m_buf[k + 1] = pe->g;\n                m_buf[k + 2] = pe->b;\n                break;\n            case 4:\n                index = ((scanline[x / 2] & 0xF0) >> 4);\n                if (index >= m_palette_size) {\n                    errorfmt(\"Possible corruption: index exceeds palette size\");\n                    return false;\n                }\n                pe           = &palette[index];\n                m_buf[k + 0] = pe->r;\n                m_buf[k + 1] = pe->g;\n                m_buf[k + 2] = pe->b;\n                // 2 pixels per byte\n                pe = &palette[scanline[x / 2] & 0x0F];\n                if (x == m_spec.width - 1)\n                    break;  // avoid buffer overflows\n                x++;\n                m_buf[k + 4] = pe->r;\n                m_buf[k + 5] = pe->g;\n                m_buf[k + 6] = pe->b;\n                /*std::cerr << \"[ico] \" << y << \" 2*4bit pixel: \"\n                          << ((int)scanline[x / 2]) << \" -> \"\n                          << ((int)(scanline[x / 2] & 0xF0) >> 4)\n                          << \" & \" << ((int)(scanline[x / 2]) & 0x0F)\n                          << \"\\n\";*/\n                break;\n            case 8:\n                index = scanline[x];\n                if (index >= m_palette_size) {\n                    errorfmt(\"Possible corruption: index exceeds palette size\");\n                    return false;\n                }\n                pe           = &palette[index];\n                m_buf[k + 0] = pe->r;\n                m_buf[k + 1] = pe->g;\n                m_buf[k + 2] = pe->b;\n                break;\n                // bpp values > 8 mean non-indexed BGR(A) images\n#if 0\n            // doesn't seem like ICOs can really be 16-bit, where did I even get\n            // this notion from?\n            case 16:\n                // FIXME: find out exactly which channel gets the 1 extra\n                // bit; currently I assume it's green: 5B, 6G, 5R\n                // extract and shift the bits\n                m_buf[k + 0] = (scanline[x * 2 + 1] & 0x1F) << 3;\n                m_buf[k + 1] = ((scanline[x * 2 + 1] & 0xE0) >> 3)\n                               | ((scanline[x * 2 + 0] & 0x07) << 5);\n                m_buf[k + 2] = scanline[x * 2 + 0] & 0xF8;\n                break;\n#endif\n            case 24:\n                m_buf[k + 0] = scanline[x * 3 + 2];\n                m_buf[k + 1] = scanline[x * 3 + 1];\n                m_buf[k + 2] = scanline[x * 3 + 0];\n                break;\n            case 32:\n                m_buf[k + 0] = scanline[x * 4 + 2];\n                m_buf[k + 1] = scanline[x * 4 + 1];\n                m_buf[k + 2] = scanline[x * 4 + 0];\n                m_buf[k + 3] = scanline[x * 4 + 3];\n                break;\n            }\n        }\n    }\n\n    // read the 1-bit transparency for < 32-bit icons\n    if (m_bpp < 32) {\n        // also aligned to a multiple of 32 bits\n        slb = (m_spec.width + 7) / 8                     // real data bytes\n              + (4 - ((m_spec.width + 7) / 8) % 4) % 4;  // padding\n        scanline.resize(slb);\n        for (int y = m_spec.height - 1; y >= 0; y--) {\n            if (!fread(&scanline[0], 1, slb))\n                return false;\n            for (int x = 0; x < m_spec.width; x += 8) {\n                for (int b = 0; b < 8; b++) {  // bit\n                    k = y * m_spec.width * 4 + (x + 7 - b) * 4;\n                    if (scanline[x / 8] & (1 << b))\n                        m_buf[k + 3] = 0;\n                    else\n                        m_buf[k + 3] = 255;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "abstract_func": "bool\nICOInput::readimg()\n{\n    if (VAR_0) {\n        /* COMMENT_0 */\n        std::string VAR_1 = PNG_pvt::read_into_buffer(VAR_0, VAR_2, VAR_3, VAR_4);\n\n        /* COMMENT_1 */\n\n        if (VAR_1.length()) {\n            errorf(\"%s\", VAR_1);\n            return false;\n        }\n\n        return true;\n    }\n\n    /* COMMENT_2 */\n    OIIO_DASSERT(VAR_3.scanline_bytes() == ((size_t)VAR_3.width * 4));\n    VAR_4.resize(VAR_3.image_bytes());\n\n    /* COMMENT_3 */\n\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    std::vector<ico_palette_entry> palette(m_palette_size);\n    if (VAR_5 < 16) {  /* COMMENT_6 */\n        for (int VAR_6 = 0; VAR_6 < m_palette_size; VAR_6++)\n            if (!fread(&VAR_7[VAR_6], 1, sizeof(ico_palette_entry)))\n                return false;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    int VAR_8 = (VAR_3.width * VAR_5 + 7) / 8  /* COMMENT_9 */\n              + (4 - ((VAR_3.width * VAR_5 + 7) / 8) % 4) % 4;  /* COMMENT_10 */\n    std::vector<unsigned char> scanline(slb);\n    ico_palette_entry* VAR_9;\n    int VAR_10;\n    int VAR_11;\n    for (int VAR_12 = VAR_3.height - 1; VAR_12 >= 0; VAR_12--) {\n        if (!fread(&VAR_13[0], 1, slb))\n            return false;\n        for (int VAR_14 = 0; VAR_14 < VAR_3.width; VAR_14++) {\n            VAR_10 = VAR_12 * VAR_3.width * 4 + VAR_14 * 4;\n            /* COMMENT_11 */\n            switch (VAR_5) {\n            case 1:\n                VAR_11 = ((VAR_13[VAR_14 / 8] & (1 << (7 - VAR_14 % 8))) != 0);\n                if (VAR_11 >= m_palette_size) {\n                    errorfmt(\"Possible corruption: index exceeds palette size\");\n                    return false;\n                }\n                VAR_9           = &VAR_7[VAR_11];\n                VAR_4[VAR_10 + 0] = VAR_9->r;\n                VAR_4[VAR_10 + 1] = VAR_9->g;\n                VAR_4[VAR_10 + 2] = VAR_9->b;\n                break;\n            case 4:\n                VAR_11 = ((VAR_13[VAR_14 / 2] & 0xF0) >> 4);\n                if (VAR_11 >= m_palette_size) {\n                    errorfmt(\"Possible corruption: index exceeds palette size\");\n                    return false;\n                }\n                VAR_9           = &VAR_7[VAR_11];\n                VAR_4[VAR_10 + 0] = VAR_9->r;\n                VAR_4[VAR_10 + 1] = VAR_9->g;\n                VAR_4[VAR_10 + 2] = VAR_9->b;\n                /* COMMENT_12 */\n                VAR_9 = &VAR_7[VAR_13[VAR_14 / 2] & 0x0F];\n                if (VAR_14 == VAR_3.width - 1)\n                    break;  /* COMMENT_13 */\n                VAR_14++;\n                VAR_4[VAR_10 + 4] = VAR_9->r;\n                VAR_4[VAR_10 + 5] = VAR_9->g;\n                VAR_4[VAR_10 + 6] = VAR_9->b;\n                /* COMMENT_14 */\n                                                             \n                                                                 \n                                                                     \n                                    \n                break;\n            case 8:\n                VAR_11 = VAR_13[VAR_14];\n                if (VAR_11 >= m_palette_size) {\n                    errorfmt(\"Possible corruption: index exceeds palette size\");\n                    return false;\n                }\n                VAR_9           = &VAR_7[VAR_11];\n                VAR_4[VAR_10 + 0] = VAR_9->r;\n                VAR_4[VAR_10 + 1] = VAR_9->g;\n                VAR_4[VAR_10 + 2] = VAR_9->b;\n                break;\n                /* COMMENT_19 */\n#if 0\n            /* COMMENT_20 */\n            /* COMMENT_21 */\n            case 16:\n                /* COMMENT_22 */\n                /* COMMENT_23 */\n                /* COMMENT_24 */\n                VAR_4[VAR_10 + 0] = (VAR_13[VAR_14 * 2 + 1] & 0x1F) << 3;\n                VAR_4[VAR_10 + 1] = ((VAR_13[VAR_14 * 2 + 1] & 0xE0) >> 3)\n                               | ((VAR_13[VAR_14 * 2 + 0] & 0x07) << 5);\n                VAR_4[VAR_10 + 2] = VAR_13[VAR_14 * 2 + 0] & 0xF8;\n                break;\n#endif\n            case 24:\n                VAR_4[VAR_10 + 0] = VAR_13[VAR_14 * 3 + 2];\n                VAR_4[VAR_10 + 1] = VAR_13[VAR_14 * 3 + 1];\n                VAR_4[VAR_10 + 2] = VAR_13[VAR_14 * 3 + 0];\n                break;\n            case 32:\n                VAR_4[VAR_10 + 0] = VAR_13[VAR_14 * 4 + 2];\n                VAR_4[VAR_10 + 1] = VAR_13[VAR_14 * 4 + 1];\n                VAR_4[VAR_10 + 2] = VAR_13[VAR_14 * 4 + 0];\n                VAR_4[VAR_10 + 3] = VAR_13[VAR_14 * 4 + 3];\n                break;\n            }\n        }\n    }\n\n    /* COMMENT_25 */\n    if (VAR_5 < 32) {\n        /* COMMENT_26 */\n        slb = (VAR_3.width + 7) / 8                     /* COMMENT_9 */\n              + (4 - ((VAR_3.width + 7) / 8) % 4) % 4;  /* COMMENT_10 */\n        VAR_13.resize(slb);\n        for (int VAR_12 = VAR_3.height - 1; VAR_12 >= 0; VAR_12--) {\n            if (!fread(&VAR_13[0], 1, slb))\n                return false;\n            for (int VAR_14 = 0; VAR_14 < VAR_3.width; VAR_14 += 8) {\n                for (int VAR_15 = 0; VAR_15 < 8; VAR_15++) {  /* COMMENT_27 */\n                    VAR_10 = VAR_12 * VAR_3.width * 4 + (VAR_14 + 7 - VAR_15) * 4;\n                    if (VAR_13[VAR_14 / 8] & (1 << VAR_15))\n                        VAR_4[VAR_10 + 3] = 0;\n                    else\n                        VAR_4[VAR_10 + 3] = 255;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "func_graph_path": "AcademySoftwareFoundation/OpenImageIO/03a368113a4c5abb45f9e896f0eff274a2571a00/icoinput.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,7 @@\n     std::vector<unsigned char> scanline(slb);\n     ico_palette_entry* pe;\n     int k;\n+    int index;\n     for (int y = m_spec.height - 1; y >= 0; y--) {\n         if (!fread(&scanline[0], 1, slb))\n             return false;\n@@ -45,13 +46,23 @@\n             // fill the buffer\n             switch (m_bpp) {\n             case 1:\n-                pe = &palette[(scanline[x / 8] & (1 << (7 - x % 8))) != 0];\n+                index = ((scanline[x / 8] & (1 << (7 - x % 8))) != 0);\n+                if (index >= m_palette_size) {\n+                    errorfmt(\"Possible corruption: index exceeds palette size\");\n+                    return false;\n+                }\n+                pe           = &palette[index];\n                 m_buf[k + 0] = pe->r;\n                 m_buf[k + 1] = pe->g;\n                 m_buf[k + 2] = pe->b;\n                 break;\n             case 4:\n-                pe           = &palette[(scanline[x / 2] & 0xF0) >> 4];\n+                index = ((scanline[x / 2] & 0xF0) >> 4);\n+                if (index >= m_palette_size) {\n+                    errorfmt(\"Possible corruption: index exceeds palette size\");\n+                    return false;\n+                }\n+                pe           = &palette[index];\n                 m_buf[k + 0] = pe->r;\n                 m_buf[k + 1] = pe->g;\n                 m_buf[k + 2] = pe->b;\n@@ -70,7 +81,12 @@\n                           << \"\\n\";*/\n                 break;\n             case 8:\n-                pe           = &palette[scanline[x]];\n+                index = scanline[x];\n+                if (index >= m_palette_size) {\n+                    errorfmt(\"Possible corruption: index exceeds palette size\");\n+                    return false;\n+                }\n+                pe           = &palette[index];\n                 m_buf[k + 0] = pe->r;\n                 m_buf[k + 1] = pe->g;\n                 m_buf[k + 2] = pe->b;",
  "diff_line_info": {
    "deleted_lines": [
      "                pe = &palette[(scanline[x / 8] & (1 << (7 - x % 8))) != 0];",
      "                pe           = &palette[(scanline[x / 2] & 0xF0) >> 4];",
      "                pe           = &palette[scanline[x]];"
    ],
    "added_lines": [
      "    int index;",
      "                index = ((scanline[x / 8] & (1 << (7 - x % 8))) != 0);",
      "                if (index >= m_palette_size) {",
      "                    errorfmt(\"Possible corruption: index exceeds palette size\");",
      "                    return false;",
      "                }",
      "                pe           = &palette[index];",
      "                index = ((scanline[x / 2] & 0xF0) >> 4);",
      "                if (index >= m_palette_size) {",
      "                    errorfmt(\"Possible corruption: index exceeds palette size\");",
      "                    return false;",
      "                }",
      "                pe           = &palette[index];",
      "                index = scanline[x];",
      "                if (index >= m_palette_size) {",
      "                    errorfmt(\"Possible corruption: index exceeds palette size\");",
      "                    return false;",
      "                }",
      "                pe           = &palette[index];"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/pull/3872",
  "description": {
    "pr_info": {
      "title": "fix heap-buffer-overflow in function ICOInput::readimg in file src/ic…",
      "number": 3872
    },
    "comment": [
      "## Description\r\n\r\nfix #3871: heap-buffer-overflow in function ICOInput::readimg in file src/ico.imageio/icoinput.cpp\r\n\r\n## Checklist:\r\n- [Y] I have read the [contribution guidelines](https://github.com/OpenImageIO/oiio/blob/master/CONTRIBUTING.md).\r\n- [Y] My code follows the prevailing code style of this project.\r\n\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}