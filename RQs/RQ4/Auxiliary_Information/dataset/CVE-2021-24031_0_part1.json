{
  "cve_id": "CVE-2021-24031",
  "cwe_ids": [
    "CWE-276"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "facebook/zstd",
  "commit_msg": "[programs] Don’t try to chmod a dst file if it can’t be opened\n\nRepairs an oversight in my last commit, thanks @Cyan4973",
  "commit_hash": "af80f6dfacafcc2c916ecd57731107221e1f9986",
  "git_url": "https://github.com/facebook/zstd/commit/af80f6dfacafcc2c916ecd57731107221e1f9986",
  "file_path": "programs/fileio.c",
  "func_name": "FIO_openDstFile",
  "func_before": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        chmod(dstFileName, 00600);\n        return f;\n    }\n}",
  "abstract_func_before": "static FILE* FIO_openDstFile(FIO_prefs_t* const VAR_0, const char* VAR_1, const char* VAR_2)\n{\n    assert(VAR_2 != NULL);\n    if (!strcmp (VAR_2, VAR_3)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(VAR_4);\n        if (VAR_0->sparseFileSupport == 1) {\n            VAR_0->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return VAR_4;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_1 != NULL && UTIL_isSameFile(VAR_1, VAR_2)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (VAR_0->sparseFileSupport == 1) {\n        VAR_0->sparseFileSupport = VAR_5;\n    }\n\n    if (UTIL_isRegularFile(VAR_2)) {\n        /* COMMENT_1 */\n        FILE* const VAR_6 = fopen( VAR_2, \"rb\" );\n        if (!strcmp(VAR_2, VAR_7)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        VAR_2);\n        }\n        if (VAR_6 != NULL) {  /* COMMENT_2 */\n            fclose(VAR_6);\n            if (!VAR_0->overwrite) {\n                if (VAR_8.displayLevel <= 1) {\n                    /* COMMENT_3 */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            VAR_2);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        VAR_2);\n                {   int VAR_9 = getchar();\n                    if ((VAR_9!='Y') && (VAR_9!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* COMMENT_4 */\n                    while ((VAR_9!=VAR_10) && (VAR_9!='\\n')) VAR_9 = getchar();\n            }   }\n            /* COMMENT_5 */\n            FIO_remove(VAR_2);\n    }   }\n\n    {   FILE* const VAR_11 = fopen( VAR_2, \"wb\" );\n        if (VAR_11 == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", VAR_2, strerror(VAR_12));\n        chmod(VAR_2, 00600);\n        return VAR_11;\n    }\n}",
  "func_graph_path_before": "facebook/zstd/af80f6dfacafcc2c916ecd57731107221e1f9986/fileio.c/vul/before/0.json",
  "func": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL) {\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        } else {\n            chmod(dstFileName, 00600);\n        }\n        return f;\n    }\n}",
  "abstract_func": "static FILE* FIO_openDstFile(FIO_prefs_t* const VAR_0, const char* VAR_1, const char* VAR_2)\n{\n    assert(VAR_2 != NULL);\n    if (!strcmp (VAR_2, VAR_3)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(VAR_4);\n        if (VAR_0->sparseFileSupport == 1) {\n            VAR_0->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return VAR_4;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_1 != NULL && UTIL_isSameFile(VAR_1, VAR_2)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (VAR_0->sparseFileSupport == 1) {\n        VAR_0->sparseFileSupport = VAR_5;\n    }\n\n    if (UTIL_isRegularFile(VAR_2)) {\n        /* COMMENT_1 */\n        FILE* const VAR_6 = fopen( VAR_2, \"rb\" );\n        if (!strcmp(VAR_2, VAR_7)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        VAR_2);\n        }\n        if (VAR_6 != NULL) {  /* COMMENT_2 */\n            fclose(VAR_6);\n            if (!VAR_0->overwrite) {\n                if (VAR_8.displayLevel <= 1) {\n                    /* COMMENT_3 */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            VAR_2);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        VAR_2);\n                {   int VAR_9 = getchar();\n                    if ((VAR_9!='Y') && (VAR_9!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* COMMENT_4 */\n                    while ((VAR_9!=VAR_10) && (VAR_9!='\\n')) VAR_9 = getchar();\n            }   }\n            /* COMMENT_5 */\n            FIO_remove(VAR_2);\n    }   }\n\n    {   FILE* const VAR_11 = fopen( VAR_2, \"wb\" );\n        if (VAR_11 == NULL) {\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", VAR_2, strerror(VAR_12));\n        } else {\n            chmod(VAR_2, 00600);\n        }\n        return VAR_11;\n    }\n}",
  "func_graph_path": "facebook/zstd/af80f6dfacafcc2c916ecd57731107221e1f9986/fileio.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -52,9 +52,11 @@\n     }   }\n \n     {   FILE* const f = fopen( dstFileName, \"wb\" );\n-        if (f == NULL)\n+        if (f == NULL) {\n             DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n-        chmod(dstFileName, 00600);\n+        } else {\n+            chmod(dstFileName, 00600);\n+        }\n         return f;\n     }\n }",
  "diff_line_info": {
    "deleted_lines": [
      "        if (f == NULL)",
      "        chmod(dstFileName, 00600);"
    ],
    "added_lines": [
      "        if (f == NULL) {",
      "        } else {",
      "            chmod(dstFileName, 00600);",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/zstd/pull/1644",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/zstd/pull/1644: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/zstd/pulls/1644",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Commit Analysis**: The commit aims to fix an issue where chmod was called even when the file couldn't be opened, addressing a potential security risk.\n\n2. **Vulnerability Description**: It details a race condition leading to unintended permission exposure, clearly a security issue.\n\n3. **Code Changes**: The diff shows proper conditional checks to ensure chmod is only called when necessary, fixing the security flaw.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}