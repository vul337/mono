{
  "cve_id": "CVE-2023-28997",
  "cwe_ids": [
    "CWE-323"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "nextcloud/desktop",
  "commit_msg": "Always generate random initialization vector when uploading encrypted file.\n\nSigned-off-by: alex-z <blackslayer4@gmail.com>",
  "commit_hash": "75fd1d21be5ae03834209bc1fcf9fb8221b97e7b",
  "git_url": "https://github.com/nextcloud/desktop/commit/75fd1d21be5ae03834209bc1fcf9fb8221b97e7b",
  "file_path": "src/libsync/propagateuploadencrypted.cpp",
  "func_name": "PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived",
  "func_before": "void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &json, int statusCode)\n{\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata Received, Preparing it for the new file.\" << json.toVariant();\n\n  // Encrypt File!\n  _metadata.reset(new FolderMetadata(_propagator->account(), json.toJson(QJsonDocument::Compact), statusCode));\n\n  if (!_metadata->isMetadataSetup()) {\n      if (_isFolderLocked) {\n          connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n          unlockFolder();\n      } else {\n          emit error();\n      }\n      return;\n  }\n\n  QFileInfo info(_propagator->fullLocalPath(_item->_file));\n  const QString fileName = info.fileName();\n\n  // Find existing metadata for this file\n  bool found = false;\n  EncryptedFile encryptedFile;\n  const QVector<EncryptedFile> files = _metadata->files();\n\n  for(const EncryptedFile &file : files) {\n    if (file.originalFilename == fileName) {\n      encryptedFile = file;\n      found = true;\n    }\n  }\n\n\n\n  // New encrypted file so set it all up!\n  if (!found) {\n      encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16);\n      encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename();\n      encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n      encryptedFile.fileVersion = 1;\n      encryptedFile.metadataKey = 1;\n      encryptedFile.originalFilename = fileName;\n\n      QMimeDatabase mdb;\n      encryptedFile.mimetype = mdb.mimeTypeForFile(info).name().toLocal8Bit();\n\n      // Other clients expect \"httpd/unix-directory\" instead of \"inode/directory\"\n      // Doesn't matter much for us since we don't do much about that mimetype anyway\n      if (encryptedFile.mimetype == QByteArrayLiteral(\"inode/directory\")) {\n          encryptedFile.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n      }\n  }\n\n  _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename;\n  _item->_isEncrypted = true;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the encrypted file.\";\n\n  if (info.isDir()) {\n      _completeFileName = encryptedFile.encryptedFilename;\n  } else {\n      QFile input(info.absoluteFilePath());\n      QFile output(QDir::tempPath() + QDir::separator() + encryptedFile.encryptedFilename);\n\n      QByteArray tag;\n      bool encryptionResult = EncryptionHelper::fileEncryption(\n        encryptedFile.encryptionKey,\n        encryptedFile.initializationVector,\n        &input, &output, tag);\n\n      if (!encryptionResult) {\n        qCDebug(lcPropagateUploadEncrypted()) << \"There was an error encrypting the file, aborting upload.\";\n        connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n        unlockFolder();\n        return;\n      }\n\n      encryptedFile.authenticationTag = tag;\n      _completeFileName = output.fileName();\n  }\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the metadata for the encrypted file.\";\n\n  _metadata->addEncryptedFile(encryptedFile);\n  _encryptedFile = encryptedFile;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata created, sending to the server.\";\n\n  if (statusCode == 404) {\n    auto job = new StoreMetaDataApiJob(_propagator->account(),\n                                       _folderId,\n                                       _metadata->encryptedMetadata());\n    connect(job, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  } else {\n    auto job = new UpdateMetadataApiJob(_propagator->account(),\n                                      _folderId,\n                                      _metadata->encryptedMetadata(),\n                                      _folderToken);\n\n    connect(job, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  }\n}",
  "abstract_func_before": "void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &VAR_0, int VAR_1)\n{\n  qCDebug(VAR_2) << \"Metadata Received, Preparing it for the new file.\" << VAR_0.toVariant();\n\n  /* COMMENT_0 */\n  VAR_3.reset(new FolderMetadata(VAR_4->account(), VAR_0.toJson(QJsonDocument::Compact), VAR_1));\n\n  if (!VAR_3->isMetadataSetup()) {\n      if (VAR_5) {\n          connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n          unlockFolder();\n      } else {\n          emit error();\n      }\n      return;\n  }\n\n  QFileInfo VAR_6(VAR_4->fullLocalPath(VAR_7->_file));\n  const QString VAR_8 = VAR_6.fileName();\n\n  /* COMMENT_1 */\n  bool VAR_9 = false;\n  EncryptedFile VAR_10;\n  const QVector<EncryptedFile> VAR_11 = VAR_3->files();\n\n  for(const EncryptedFile &VAR_12 : VAR_11) {\n    if (VAR_12.originalFilename == VAR_8) {\n      VAR_10 = VAR_12;\n      VAR_9 = true;\n    }\n  }\n\n\n\n  /* COMMENT_2 */\n  if (!VAR_9) {\n      VAR_10.encryptionKey = EncryptionHelper::generateRandom(16);\n      VAR_10.encryptedFilename = EncryptionHelper::generateRandomFilename();\n      VAR_10.initializationVector = EncryptionHelper::generateRandom(16);\n      VAR_10.fileVersion = 1;\n      VAR_10.metadataKey = 1;\n      VAR_10.originalFilename = VAR_8;\n\n      QMimeDatabase VAR_13;\n      VAR_10.mimetype = VAR_13.mimeTypeForFile(VAR_6).name().toLocal8Bit();\n\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      if (VAR_10.mimetype == QByteArrayLiteral(\"inode/directory\")) {\n          VAR_10.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n      }\n  }\n\n  VAR_7->_encryptedFileName = VAR_14 + QLatin1Char('/') + VAR_10.encryptedFilename;\n  VAR_7->_isEncrypted = true;\n\n  qCDebug(VAR_2) << \"Creating the encrypted file.\";\n\n  if (VAR_6.isDir()) {\n      VAR_15 = VAR_10.encryptedFilename;\n  } else {\n      QFile VAR_16(VAR_6.absoluteFilePath());\n      QFile VAR_17(QDir::tempPath() + QDir::separator() + VAR_10.encryptedFilename);\n\n      QByteArray VAR_18;\n      bool VAR_19 = EncryptionHelper::fileEncryption(\n        VAR_10.encryptionKey,\n        VAR_10.initializationVector,\n        &VAR_16, &VAR_17, VAR_18);\n\n      if (!VAR_19) {\n        qCDebug(VAR_2()) << \"There was an error encrypting the file, aborting upload.\";\n        connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n        unlockFolder();\n        return;\n      }\n\n      VAR_10.authenticationTag = VAR_18;\n      VAR_15 = VAR_17.fileName();\n  }\n\n  qCDebug(VAR_2) << \"Creating the metadata for the encrypted file.\";\n\n  VAR_3->addEncryptedFile(VAR_10);\n  VAR_20 = VAR_10;\n\n  qCDebug(VAR_2) << \"Metadata created, sending to the server.\";\n\n  if (VAR_1 == 404) {\n    auto VAR_21 = new StoreMetaDataApiJob(VAR_4->account(),\n                                       VAR_22,\n                                       VAR_3->encryptedMetadata());\n    connect(VAR_21, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(VAR_21, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    VAR_21->start();\n  } else {\n    auto VAR_21 = new UpdateMetadataApiJob(VAR_4->account(),\n                                      VAR_22,\n                                      VAR_3->encryptedMetadata(),\n                                      VAR_23);\n\n    connect(VAR_21, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(VAR_21, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    VAR_21->start();\n  }\n}",
  "func_graph_path_before": "nextcloud/desktop/75fd1d21be5ae03834209bc1fcf9fb8221b97e7b/propagateuploadencrypted.cpp/vul/before/0.json",
  "func": "void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &json, int statusCode)\n{\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata Received, Preparing it for the new file.\" << json.toVariant();\n\n  // Encrypt File!\n  _metadata.reset(new FolderMetadata(_propagator->account(), json.toJson(QJsonDocument::Compact), statusCode));\n\n  if (!_metadata->isMetadataSetup()) {\n      if (_isFolderLocked) {\n          connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n          unlockFolder();\n      } else {\n          emit error();\n      }\n      return;\n  }\n\n  QFileInfo info(_propagator->fullLocalPath(_item->_file));\n  const QString fileName = info.fileName();\n\n  // Find existing metadata for this file\n  bool found = false;\n  EncryptedFile encryptedFile;\n  const QVector<EncryptedFile> files = _metadata->files();\n\n  for(const EncryptedFile &file : files) {\n    if (file.originalFilename == fileName) {\n      encryptedFile = file;\n      found = true;\n    }\n  }\n\n\n\n  // New encrypted file so set it all up!\n  if (!found) {\n      encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16);\n      encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename();\n      encryptedFile.fileVersion = 1;\n      encryptedFile.metadataKey = 1;\n      encryptedFile.originalFilename = fileName;\n\n      QMimeDatabase mdb;\n      encryptedFile.mimetype = mdb.mimeTypeForFile(info).name().toLocal8Bit();\n\n      // Other clients expect \"httpd/unix-directory\" instead of \"inode/directory\"\n      // Doesn't matter much for us since we don't do much about that mimetype anyway\n      if (encryptedFile.mimetype == QByteArrayLiteral(\"inode/directory\")) {\n          encryptedFile.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n      }\n  }\n  \n  encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n\n  _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename;\n  _item->_isEncrypted = true;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the encrypted file.\";\n\n  if (info.isDir()) {\n      _completeFileName = encryptedFile.encryptedFilename;\n  } else {\n      QFile input(info.absoluteFilePath());\n      QFile output(QDir::tempPath() + QDir::separator() + encryptedFile.encryptedFilename);\n\n      QByteArray tag;\n      bool encryptionResult = EncryptionHelper::fileEncryption(\n        encryptedFile.encryptionKey,\n        encryptedFile.initializationVector,\n        &input, &output, tag);\n\n      if (!encryptionResult) {\n        qCDebug(lcPropagateUploadEncrypted()) << \"There was an error encrypting the file, aborting upload.\";\n        connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n        unlockFolder();\n        return;\n      }\n\n      encryptedFile.authenticationTag = tag;\n      _completeFileName = output.fileName();\n  }\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the metadata for the encrypted file.\";\n\n  _metadata->addEncryptedFile(encryptedFile);\n  _encryptedFile = encryptedFile;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata created, sending to the server.\";\n\n  if (statusCode == 404) {\n    auto job = new StoreMetaDataApiJob(_propagator->account(),\n                                       _folderId,\n                                       _metadata->encryptedMetadata());\n    connect(job, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  } else {\n    auto job = new UpdateMetadataApiJob(_propagator->account(),\n                                      _folderId,\n                                      _metadata->encryptedMetadata(),\n                                      _folderToken);\n\n    connect(job, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  }\n}",
  "abstract_func": "void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &VAR_0, int VAR_1)\n{\n  qCDebug(VAR_2) << \"Metadata Received, Preparing it for the new file.\" << VAR_0.toVariant();\n\n  /* COMMENT_0 */\n  VAR_3.reset(new FolderMetadata(VAR_4->account(), VAR_0.toJson(QJsonDocument::Compact), VAR_1));\n\n  if (!VAR_3->isMetadataSetup()) {\n      if (VAR_5) {\n          connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n          unlockFolder();\n      } else {\n          emit error();\n      }\n      return;\n  }\n\n  QFileInfo VAR_6(VAR_4->fullLocalPath(VAR_7->_file));\n  const QString VAR_8 = VAR_6.fileName();\n\n  /* COMMENT_1 */\n  bool VAR_9 = false;\n  EncryptedFile VAR_10;\n  const QVector<EncryptedFile> VAR_11 = VAR_3->files();\n\n  for(const EncryptedFile &VAR_12 : VAR_11) {\n    if (VAR_12.originalFilename == VAR_8) {\n      VAR_10 = VAR_12;\n      VAR_9 = true;\n    }\n  }\n\n\n\n  /* COMMENT_2 */\n  if (!VAR_9) {\n      VAR_10.encryptionKey = EncryptionHelper::generateRandom(16);\n      VAR_10.encryptedFilename = EncryptionHelper::generateRandomFilename();\n      VAR_10.fileVersion = 1;\n      VAR_10.metadataKey = 1;\n      VAR_10.originalFilename = VAR_8;\n\n      QMimeDatabase VAR_13;\n      VAR_10.mimetype = VAR_13.mimeTypeForFile(VAR_6).name().toLocal8Bit();\n\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      if (VAR_10.mimetype == QByteArrayLiteral(\"inode/directory\")) {\n          VAR_10.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n      }\n  }\n  \n  VAR_10.initializationVector = EncryptionHelper::generateRandom(16);\n\n  VAR_7->_encryptedFileName = VAR_14 + QLatin1Char('/') + VAR_10.encryptedFilename;\n  VAR_7->_isEncrypted = true;\n\n  qCDebug(VAR_2) << \"Creating the encrypted file.\";\n\n  if (VAR_6.isDir()) {\n      VAR_15 = VAR_10.encryptedFilename;\n  } else {\n      QFile VAR_16(VAR_6.absoluteFilePath());\n      QFile VAR_17(QDir::tempPath() + QDir::separator() + VAR_10.encryptedFilename);\n\n      QByteArray VAR_18;\n      bool VAR_19 = EncryptionHelper::fileEncryption(\n        VAR_10.encryptionKey,\n        VAR_10.initializationVector,\n        &VAR_16, &VAR_17, VAR_18);\n\n      if (!VAR_19) {\n        qCDebug(VAR_2()) << \"There was an error encrypting the file, aborting upload.\";\n        connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n        unlockFolder();\n        return;\n      }\n\n      VAR_10.authenticationTag = VAR_18;\n      VAR_15 = VAR_17.fileName();\n  }\n\n  qCDebug(VAR_2) << \"Creating the metadata for the encrypted file.\";\n\n  VAR_3->addEncryptedFile(VAR_10);\n  VAR_20 = VAR_10;\n\n  qCDebug(VAR_2) << \"Metadata created, sending to the server.\";\n\n  if (VAR_1 == 404) {\n    auto VAR_21 = new StoreMetaDataApiJob(VAR_4->account(),\n                                       VAR_22,\n                                       VAR_3->encryptedMetadata());\n    connect(VAR_21, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(VAR_21, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    VAR_21->start();\n  } else {\n    auto VAR_21 = new UpdateMetadataApiJob(VAR_4->account(),\n                                      VAR_22,\n                                      VAR_3->encryptedMetadata(),\n                                      VAR_23);\n\n    connect(VAR_21, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(VAR_21, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    VAR_21->start();\n  }\n}",
  "func_graph_path": "nextcloud/desktop/75fd1d21be5ae03834209bc1fcf9fb8221b97e7b/propagateuploadencrypted.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,6 @@\n   if (!found) {\n       encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16);\n       encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename();\n-      encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n       encryptedFile.fileVersion = 1;\n       encryptedFile.metadataKey = 1;\n       encryptedFile.originalFilename = fileName;\n@@ -50,6 +49,8 @@\n           encryptedFile.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n       }\n   }\n+  \n+  encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n \n   _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename;\n   _item->_isEncrypted = true;",
  "diff_line_info": {
    "deleted_lines": [
      "      encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);"
    ],
    "added_lines": [
      "  ",
      "  encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nextcloud/desktop/pull/5324",
  "description": {
    "pr_info": {
      "title": "Always generate random initialization vector when uploading encrypted file",
      "number": 5324
    },
    "comment": [
      "Signed-off-by: alex-z <blackslayer4@gmail.com>\r\n\r\n<!-- \r\nThanks for opening a pull request on the Nextcloud desktop client.\r\n\r\nInstead of a Contributor License Agreement (CLA) we use a Developer Certificate of Origin (DCO).\r\nhttps://en.wikipedia.org/wiki/Developer_Certificate_of_Origin\r\n\r\nTo accept that DCO, please make sure that you add a line like\r\nSigned-off-by: Random Developer <random@developer.example.org>\r\nat the end of each commit message.\r\n\r\nThis Signed-off-by trailer can be added automatically by git if you pass --signoff or -s to git commit.\r\nSee also:\r\nhttps://git-scm.com/docs/git-commit#Documentation/git-commit.txt---no-signoff\r\n-->\r\n",
      "Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=nextcloud_desktop&pullRequest=5324)\n\n[![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=BUG)  \n[![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=VULNERABILITY)  \n[![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=SECURITY_HOTSPOT)  \n[![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5324&resolved=false&types=CODE_SMELL)\n\n[![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5324&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5324&metric=new_coverage&view=list)  \n[![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5324&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5324&metric=new_duplicated_lines_density&view=list)\n\n",
      "AppImage file: [nextcloud-PR-5324-75fd1d21be5ae03834209bc1fcf9fb8221b97e7b-x86_64.AppImage](https://github.com/nextcloud-desktop-bot/ci-builds/releases/download/PR-5324/nextcloud-PR-5324-75fd1d21be5ae03834209bc1fcf9fb8221b97e7b-x86_64.AppImage) <br/><br/>To test this change/fix you can simply download above AppImage file and test it. <br/><br/>Please make sure to quit your existing Nextcloud app and backup your data. ",
      "/backport to stable-3.6"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8\n\nThe commit appears to address a security concern by ensuring a random initialization vector is generated, which is crucial for encryption."
}