{
  "cve_id": "CVE-2021-3139",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "open-iscsi/tcmu-runner",
  "commit_msg": "tcmur: fail cross-device XCOPY requests\n\ntcmu-runner can't determine whether the device(s) referred to in XCOPY\nCopy Source/Copy Destination (CSCD) descriptors should be accessible to\nthe initiator via transport settings, ACLs, etc. Consequently, fail\nXCOPY requests with CSCD descriptors which refer to any device other\nthan where the XCOPY request is processed.\n\nReferences: CVE-2020-28374\nFixes: 9c86bd0 (\"tcmur: Add emulate XCOPY command support\")\nSigned-off-by: David Disseldorp <ddiss@suse.de>\nReviewed-by: Lee Duncan <lduncan@suse.com>",
  "commit_hash": "2b16e96e6b63d0419d857f53e4cc67f0adb383fd",
  "git_url": "https://github.com/open-iscsi/tcmu-runner/commit/2b16e96e6b63d0419d857f53e4cc67f0adb383fd",
  "file_path": "tcmur_cmd_handler.c",
  "func_name": "xcopy_parse_parameter_list",
  "func_before": "static int xcopy_parse_parameter_list(struct tcmu_device *dev,\n\t\t\t\t      struct tcmulib_cmd *cmd,\n\t\t\t\t      struct xcopy *xcopy)\n{\n\tuint8_t *cdb = cmd->cdb;\n\tsize_t data_length = tcmu_cdb_get_xfer_length(cdb);\n\tstruct iovec *iovec = cmd->iovec;\n\tsize_t iov_cnt = cmd->iov_cnt;\n\tuint32_t inline_dl;\n\tuint8_t *seg_desc, *tgt_desc, *par;\n\tuint16_t sdll, tdll;\n\tuint64_t num_lbas;\n\tint ret;\n\n\t/*\n\t * The PARAMETER LIST LENGTH field specifies the length in bytes\n\t * of the parameter data that shall be contained in the Data-Out\n\t * Buffer.\n\t*/\n\tpar = calloc(1, data_length);\n\tif (!par) {\n\t\ttcmu_dev_err(dev, \"calloc parameter list buffer error\\n\");\n\t\treturn TCMU_STS_NO_RESOURCE;\n\t}\n\n\ttcmu_memcpy_from_iovec(par, data_length, iovec, iov_cnt);\n\n\t/*\n\t * From spc4r31, section 6.18.4 OPERATING PARAMETERS service action\n\t *\n\t * A supports no list identifier (SNLID) bit set to one indicates\n\t * the copy manager supports an EXTENDED COPY (see 6.3) command\n\t * parameter list in which the LIST ID USAGE field is set to 11b\n\t * and the LIST IDENTIFIER field is set to zero as described in\n\t * table 105 (see 6.3.1).\n\t *\n\t * From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * LIST ID USAGE == 11b, then the LIST IDENTIFIER field should be\n\t * as zero.\n\t */\n\ttcmu_dev_dbg(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t     (par[1] & 0x18) >> 3, par[0]);\n\tif ((par[1] & 0x18) != 0x18 || par[0]) {\n\t\ttcmu_dev_err(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t\t     (par[1] & 0x18) >> 3, par[0]);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.6.1 Target descriptors introduction\n\t *\n\t * All target descriptors (see table 108) are 32 bytes or 64 bytes\n\t * in length\n\t * From spc4r36q, section6.4.3.4\n\t * An EXTENDED COPY command may reference one or more CSCDs.\n\t */\n\ttdll = be16toh(*(uint16_t *)&par[2]);\n\tif (tdll < 32 || tdll % 32 != 0) {\n\t\ttcmu_dev_err(dev, \"Illegal target descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.7.1 Segment descriptors introduction\n\t *\n\t * Segment descriptors (see table 120) begin with an eight byte header.\n\t */\n\tsdll = be32toh(*(uint32_t *)&par[8]);\n\tif (sdll < 8) {\n\t\ttcmu_dev_err(dev, \"Illegal segment descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The maximum length of the target and segment descriptors permitted\n\t * within a parameter list is indicated by the MAXIMUM DESCRIPTOR LIST\n\t * LENGTH field in the copy managers operating parameters.\n\t */\n\tif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\n\t\ttcmu_dev_err(dev, \"descriptor list length %u exceeds maximum %u\\n\",\n\t\t\t     tdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The INLINE DATA LENGTH field contains the number of bytes of inline\n\t * data, after the last segment descriptor.\n\t * */\n\tinline_dl = be32toh(*(uint32_t *)&par[12]);\n\n\t/* From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * The EXTENDED COPY parameter list (see table 104) begins with a 16\n\t * byte header.\n\t *\n\t * The data length in CDB should be equal to tdll + sdll + inline_dl\n\t * + parameter list header length\n\t */\n\tif (data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\n\t\ttcmu_dev_err(dev, \"Illegal list length: length from CDB is %zu,\"\n\t\t\t     \" but here the length is %u\\n\",\n\t\t\t     data_length, tdll + sdll + inline_dl);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\ttcmu_dev_dbg(dev, \"Processing XCOPY with tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t     tdll, sdll, inline_dl);\n\n\t/*\n\t * Parse the segment descripters and for now we only support block\n\t * -> block type.\n\t *\n\t * The max seg_desc number support is 1(see RCR_OP_MAX_SG_DESC_COUNT)\n\t */\n\tseg_desc = par + XCOPY_HDR_LEN + tdll;\n\tret = xcopy_parse_segment_descs(seg_desc, xcopy, sdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\t/*\n\t * Parse the target descripter\n\t *\n\t * The max seg_desc number support is 2(see RCR_OP_MAX_TARGET_DESC_COUNT)\n\t */\n\ttgt_desc = par + XCOPY_HDR_LEN;\n\tret = xcopy_parse_target_descs(dev, xcopy, tgt_desc, tdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n\t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n\t\ttcmu_dev_err(dev, \"The block size of src dev %u != dst dev %u\\n\",\n\t\t\t     tcmu_dev_get_block_size(xcopy->src_dev),\n\t\t\t     tcmu_dev_get_block_size(xcopy->dst_dev));\n\t\tret = TCMU_STS_INVALID_CP_TGT_DEV_TYPE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->src_dev);\n\tif (xcopy->src_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->src_dev,\n\t\t\t     \"src target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u\\n\",\n\t\t\t     num_lbas, xcopy->src_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->dst_dev);\n\tif (xcopy->dst_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->dst_dev,\n\t\t\t     \"dst target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u)\\n\",\n\t\t\t     num_lbas, xcopy->dst_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tfree(par);\n\treturn TCMU_STS_OK;\n\nerr:\n\tfree(par);\n\n\treturn ret;\n}",
  "abstract_func_before": "static int xcopy_parse_parameter_list(struct tcmu_device *VAR_0,\n\t\t\t\t      struct tcmulib_cmd *VAR_1,\n\t\t\t\t      struct xcopy *xcopy)\n{\n\tuint8_t *VAR_2 = VAR_1->cdb;\n\tsize_t VAR_3 = tcmu_cdb_get_xfer_length(VAR_2);\n\tstruct iovec *iovec = VAR_1->iovec;\n\tsize_t VAR_4 = VAR_1->iov_cnt;\n\tuint32_t VAR_5;\n\tuint8_t *VAR_6, *VAR_7, *VAR_8;\n\tuint16_t VAR_9, VAR_10;\n\tuint64_t VAR_11;\n\tint VAR_12;\n\n\t/* COMMENT_0 */\n                                                                 \n                                                                 \n           \n   \n\tVAR_8 = calloc(1, VAR_3);\n\tif (!VAR_8) {\n\t\ttcmu_dev_err(VAR_0, \"calloc parameter list buffer error\\n\");\n\t\treturn VAR_13;\n\t}\n\n\ttcmu_memcpy_from_iovec(VAR_8, VAR_3, iovec, VAR_4);\n\n\t/* COMMENT_5 */\n                                                                    \n   \n                                                                  \n                                                                \n                                                                 \n                                                                \n                          \n   \n                                                                  \n   \n                                                                  \n            \n    \n\ttcmu_dev_dbg(VAR_0, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t     (VAR_8[1] & 0x18) >> 3, VAR_8[0]);\n\tif ((VAR_8[1] & 0x18) != 0x18 || VAR_8[0]) {\n\t\ttcmu_dev_err(VAR_0, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t\t     (VAR_8[1] & 0x18) >> 3, VAR_8[0]);\n\t\tVAR_12 = VAR_14;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_17 */\n                                                                 \n   \n                                                                   \n             \n                                 \n                                                             \n    \n\tVAR_10 = be16toh(*(uint16_t *)&VAR_8[2]);\n\tif (VAR_10 < 32 || VAR_10 % 32 != 0) {\n\t\ttcmu_dev_err(VAR_0, \"Illegal target descriptor length %u\\n\",\n\t\t\t     VAR_10);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_25 */\n                                                                  \n   \n                                                                        \n    \n\tVAR_9 = be32toh(*(uint32_t *)&VAR_8[8]);\n\tif (VAR_9 < 8) {\n\t\ttcmu_dev_err(VAR_0, \"Illegal segment descriptor length %u\\n\",\n\t\t\t     VAR_10);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_30 */\n                                                                      \n                                                                       \n                                                           \n    \n\tif (VAR_10 + VAR_9 > VAR_16) {\n\t\ttcmu_dev_err(VAR_0, \"descriptor list length %u exceeds maximum %u\\n\",\n\t\t\t     VAR_10 + VAR_9, VAR_16);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_35 */\n                                                                       \n                                            \n      \n\tVAR_5 = be32toh(*(uint32_t *)&VAR_8[12]);\n\n\t/* COMMENT_39 */\n   \n                                                                     \n                \n   \n                                                                     \n                                  \n    \n\tif (VAR_3 < (VAR_17 + VAR_10 + VAR_9 + VAR_5)) {\n\t\ttcmu_dev_err(VAR_0, \"Illegal list length: length from CDB is %zu,\"\n\t\t\t     \" but here the length is %u\\n\",\n\t\t\t     VAR_3, VAR_10 + VAR_9 + VAR_5);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\ttcmu_dev_dbg(VAR_0, \"Processing XCOPY with tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t     VAR_10, VAR_9, VAR_5);\n\n\t/* COMMENT_46 */\n                                                                   \n                  \n   \n                                                                      \n    \n\tVAR_6 = VAR_8 + VAR_17 + VAR_10;\n\tVAR_12 = xcopy_parse_segment_descs(VAR_6, xcopy, VAR_9);\n\tif (VAR_12 != VAR_18)\n\t\tgoto err;\n\n\t/* COMMENT_52 */\n                               \n   \n                                                                          \n    \n\tVAR_7 = VAR_8 + VAR_17;\n\tVAR_12 = xcopy_parse_target_descs(VAR_0, xcopy, VAR_7, VAR_10);\n\tif (VAR_12 != VAR_18)\n\t\tgoto err;\n\n\tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n\t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n\t\ttcmu_dev_err(VAR_0, \"The block size of src dev %u != dst dev %u\\n\",\n\t\t\t     tcmu_dev_get_block_size(xcopy->src_dev),\n\t\t\t     tcmu_dev_get_block_size(xcopy->dst_dev));\n\t\tVAR_12 = VAR_19;\n\t\tgoto err;\n\t}\n\n\tVAR_11 = tcmu_dev_get_num_lbas(xcopy->src_dev);\n\tif (xcopy->src_lba + xcopy->lba_cnt > VAR_11) {\n\t\ttcmu_dev_err(xcopy->src_dev,\n\t\t\t     \"src target exceeds last lba %\"VAR_20\" (lba %\"VAR_20\", copy len %u\\n\",\n\t\t\t     VAR_11, xcopy->src_lba, xcopy->lba_cnt);\n\t\tVAR_12 = VAR_21;\n\t\tgoto err;\n\t}\n\n\tVAR_11 = tcmu_dev_get_num_lbas(xcopy->dst_dev);\n\tif (xcopy->dst_lba + xcopy->lba_cnt > VAR_11) {\n\t\ttcmu_dev_err(xcopy->dst_dev,\n\t\t\t     \"dst target exceeds last lba %\"VAR_20\" (lba %\"VAR_20\", copy len %u)\\n\",\n\t\t\t     VAR_11, xcopy->dst_lba, xcopy->lba_cnt);\n\t\tVAR_12 = VAR_21;\n\t\tgoto err;\n\t}\n\n\tfree(VAR_8);\n\treturn VAR_18;\n\nerr:\n\tfree(VAR_8);\n\n\treturn VAR_12;\n}",
  "func_graph_path_before": "open-iscsi/tcmu-runner/2b16e96e6b63d0419d857f53e4cc67f0adb383fd/tcmur_cmd_handler.c/vul/before/0.json",
  "func": "static int xcopy_parse_parameter_list(struct tcmu_device *dev,\n\t\t\t\t      struct tcmulib_cmd *cmd,\n\t\t\t\t      struct xcopy *xcopy)\n{\n\tuint8_t *cdb = cmd->cdb;\n\tsize_t data_length = tcmu_cdb_get_xfer_length(cdb);\n\tstruct iovec *iovec = cmd->iovec;\n\tsize_t iov_cnt = cmd->iov_cnt;\n\tuint32_t inline_dl;\n\tuint8_t *seg_desc, *tgt_desc, *par;\n\tuint16_t sdll, tdll;\n\tuint64_t num_lbas;\n\tint ret;\n\n\t/*\n\t * The PARAMETER LIST LENGTH field specifies the length in bytes\n\t * of the parameter data that shall be contained in the Data-Out\n\t * Buffer.\n\t*/\n\tpar = calloc(1, data_length);\n\tif (!par) {\n\t\ttcmu_dev_err(dev, \"calloc parameter list buffer error\\n\");\n\t\treturn TCMU_STS_NO_RESOURCE;\n\t}\n\n\ttcmu_memcpy_from_iovec(par, data_length, iovec, iov_cnt);\n\n\t/*\n\t * From spc4r31, section 6.18.4 OPERATING PARAMETERS service action\n\t *\n\t * A supports no list identifier (SNLID) bit set to one indicates\n\t * the copy manager supports an EXTENDED COPY (see 6.3) command\n\t * parameter list in which the LIST ID USAGE field is set to 11b\n\t * and the LIST IDENTIFIER field is set to zero as described in\n\t * table 105 (see 6.3.1).\n\t *\n\t * From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * LIST ID USAGE == 11b, then the LIST IDENTIFIER field should be\n\t * as zero.\n\t */\n\ttcmu_dev_dbg(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t     (par[1] & 0x18) >> 3, par[0]);\n\tif ((par[1] & 0x18) != 0x18 || par[0]) {\n\t\ttcmu_dev_err(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t\t     (par[1] & 0x18) >> 3, par[0]);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.6.1 Target descriptors introduction\n\t *\n\t * All target descriptors (see table 108) are 32 bytes or 64 bytes\n\t * in length\n\t * From spc4r36q, section6.4.3.4\n\t * An EXTENDED COPY command may reference one or more CSCDs.\n\t */\n\ttdll = be16toh(*(uint16_t *)&par[2]);\n\tif (tdll < 32 || tdll % 32 != 0) {\n\t\ttcmu_dev_err(dev, \"Illegal target descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.7.1 Segment descriptors introduction\n\t *\n\t * Segment descriptors (see table 120) begin with an eight byte header.\n\t */\n\tsdll = be32toh(*(uint32_t *)&par[8]);\n\tif (sdll < 8) {\n\t\ttcmu_dev_err(dev, \"Illegal segment descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The maximum length of the target and segment descriptors permitted\n\t * within a parameter list is indicated by the MAXIMUM DESCRIPTOR LIST\n\t * LENGTH field in the copy managers operating parameters.\n\t */\n\tif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\n\t\ttcmu_dev_err(dev, \"descriptor list length %u exceeds maximum %u\\n\",\n\t\t\t     tdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The INLINE DATA LENGTH field contains the number of bytes of inline\n\t * data, after the last segment descriptor.\n\t * */\n\tinline_dl = be32toh(*(uint32_t *)&par[12]);\n\n\t/* From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * The EXTENDED COPY parameter list (see table 104) begins with a 16\n\t * byte header.\n\t *\n\t * The data length in CDB should be equal to tdll + sdll + inline_dl\n\t * + parameter list header length\n\t */\n\tif (data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\n\t\ttcmu_dev_err(dev, \"Illegal list length: length from CDB is %zu,\"\n\t\t\t     \" but here the length is %u\\n\",\n\t\t\t     data_length, tdll + sdll + inline_dl);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\ttcmu_dev_dbg(dev, \"Processing XCOPY with tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t     tdll, sdll, inline_dl);\n\n\t/*\n\t * Parse the segment descripters and for now we only support block\n\t * -> block type.\n\t *\n\t * The max seg_desc number support is 1(see RCR_OP_MAX_SG_DESC_COUNT)\n\t */\n\tseg_desc = par + XCOPY_HDR_LEN + tdll;\n\tret = xcopy_parse_segment_descs(seg_desc, xcopy, sdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\t/*\n\t * Parse the target descripter\n\t *\n\t * The max seg_desc number support is 2(see RCR_OP_MAX_TARGET_DESC_COUNT)\n\t */\n\ttgt_desc = par + XCOPY_HDR_LEN;\n\tret = xcopy_parse_target_descs(dev, xcopy, tgt_desc, tdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\t/*\n\t * tcmu-runner can't determine whether the device(s) referred to in an\n\t * XCOPY request should be accessible to the initiator via transport\n\t * settings, ACLs, etc. XXX Consequently, we need to fail any\n\t * cross-device requests for safety reasons.\n\t */\n\tif (dev != xcopy->src_dev || dev != xcopy->dst_dev) {\n\t\ttcmu_dev_err(dev, \"Cross-device XCOPY not supported\\n\");\n\t\tret = TCMU_STS_CP_TGT_DEV_NOTCONN;\n\t\tgoto err;\n\t}\n\n\tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n\t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n\t\ttcmu_dev_err(dev, \"The block size of src dev %u != dst dev %u\\n\",\n\t\t\t     tcmu_dev_get_block_size(xcopy->src_dev),\n\t\t\t     tcmu_dev_get_block_size(xcopy->dst_dev));\n\t\tret = TCMU_STS_INVALID_CP_TGT_DEV_TYPE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->src_dev);\n\tif (xcopy->src_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->src_dev,\n\t\t\t     \"src target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u\\n\",\n\t\t\t     num_lbas, xcopy->src_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->dst_dev);\n\tif (xcopy->dst_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->dst_dev,\n\t\t\t     \"dst target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u)\\n\",\n\t\t\t     num_lbas, xcopy->dst_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tfree(par);\n\treturn TCMU_STS_OK;\n\nerr:\n\tfree(par);\n\n\treturn ret;\n}",
  "abstract_func": "static int xcopy_parse_parameter_list(struct tcmu_device *VAR_0,\n\t\t\t\t      struct tcmulib_cmd *VAR_1,\n\t\t\t\t      struct xcopy *xcopy)\n{\n\tuint8_t *VAR_2 = VAR_1->cdb;\n\tsize_t VAR_3 = tcmu_cdb_get_xfer_length(VAR_2);\n\tstruct iovec *iovec = VAR_1->iovec;\n\tsize_t VAR_4 = VAR_1->iov_cnt;\n\tuint32_t VAR_5;\n\tuint8_t *VAR_6, *VAR_7, *VAR_8;\n\tuint16_t VAR_9, VAR_10;\n\tuint64_t VAR_11;\n\tint VAR_12;\n\n\t/* COMMENT_0 */\n                                                                 \n                                                                 \n           \n   \n\tVAR_8 = calloc(1, VAR_3);\n\tif (!VAR_8) {\n\t\ttcmu_dev_err(VAR_0, \"calloc parameter list buffer error\\n\");\n\t\treturn VAR_13;\n\t}\n\n\ttcmu_memcpy_from_iovec(VAR_8, VAR_3, iovec, VAR_4);\n\n\t/* COMMENT_5 */\n                                                                    \n   \n                                                                  \n                                                                \n                                                                 \n                                                                \n                          \n   \n                                                                  \n   \n                                                                  \n            \n    \n\ttcmu_dev_dbg(VAR_0, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t     (VAR_8[1] & 0x18) >> 3, VAR_8[0]);\n\tif ((VAR_8[1] & 0x18) != 0x18 || VAR_8[0]) {\n\t\ttcmu_dev_err(VAR_0, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t\t     (VAR_8[1] & 0x18) >> 3, VAR_8[0]);\n\t\tVAR_12 = VAR_14;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_17 */\n                                                                 \n   \n                                                                   \n             \n                                 \n                                                             \n    \n\tVAR_10 = be16toh(*(uint16_t *)&VAR_8[2]);\n\tif (VAR_10 < 32 || VAR_10 % 32 != 0) {\n\t\ttcmu_dev_err(VAR_0, \"Illegal target descriptor length %u\\n\",\n\t\t\t     VAR_10);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_25 */\n                                                                  \n   \n                                                                        \n    \n\tVAR_9 = be32toh(*(uint32_t *)&VAR_8[8]);\n\tif (VAR_9 < 8) {\n\t\ttcmu_dev_err(VAR_0, \"Illegal segment descriptor length %u\\n\",\n\t\t\t     VAR_10);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_30 */\n                                                                      \n                                                                       \n                                                           \n    \n\tif (VAR_10 + VAR_9 > VAR_16) {\n\t\ttcmu_dev_err(VAR_0, \"descriptor list length %u exceeds maximum %u\\n\",\n\t\t\t     VAR_10 + VAR_9, VAR_16);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\t/* COMMENT_35 */\n                                                                       \n                                            \n      \n\tVAR_5 = be32toh(*(uint32_t *)&VAR_8[12]);\n\n\t/* COMMENT_39 */\n   \n                                                                     \n                \n   \n                                                                     \n                                  \n    \n\tif (VAR_3 < (VAR_17 + VAR_10 + VAR_9 + VAR_5)) {\n\t\ttcmu_dev_err(VAR_0, \"Illegal list length: length from CDB is %zu,\"\n\t\t\t     \" but here the length is %u\\n\",\n\t\t\t     VAR_3, VAR_10 + VAR_9 + VAR_5);\n\t\tVAR_12 = VAR_15;\n\t\tgoto err;\n\t}\n\n\ttcmu_dev_dbg(VAR_0, \"Processing XCOPY with tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t     VAR_10, VAR_9, VAR_5);\n\n\t/* COMMENT_46 */\n                                                                   \n                  \n   \n                                                                      \n    \n\tVAR_6 = VAR_8 + VAR_17 + VAR_10;\n\tVAR_12 = xcopy_parse_segment_descs(VAR_6, xcopy, VAR_9);\n\tif (VAR_12 != VAR_18)\n\t\tgoto err;\n\n\t/* COMMENT_52 */\n                               \n   \n                                                                          \n    \n\tVAR_7 = VAR_8 + VAR_17;\n\tVAR_12 = xcopy_parse_target_descs(VAR_0, xcopy, VAR_7, VAR_10);\n\tif (VAR_12 != VAR_18)\n\t\tgoto err;\n\n\t/* COMMENT_57 */\n                                                                       \n                                                                     \n                                                              \n                                             \n    \n\tif (VAR_0 != xcopy->src_dev || VAR_0 != xcopy->dst_dev) {\n\t\ttcmu_dev_err(VAR_0, \"Cross-device XCOPY not supported\\n\");\n\t\tVAR_12 = VAR_19;\n\t\tgoto err;\n\t}\n\n\tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n\t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n\t\ttcmu_dev_err(VAR_0, \"The block size of src dev %u != dst dev %u\\n\",\n\t\t\t     tcmu_dev_get_block_size(xcopy->src_dev),\n\t\t\t     tcmu_dev_get_block_size(xcopy->dst_dev));\n\t\tVAR_12 = VAR_20;\n\t\tgoto err;\n\t}\n\n\tVAR_11 = tcmu_dev_get_num_lbas(xcopy->src_dev);\n\tif (xcopy->src_lba + xcopy->lba_cnt > VAR_11) {\n\t\ttcmu_dev_err(xcopy->src_dev,\n\t\t\t     \"src target exceeds last lba %\"VAR_21\" (lba %\"VAR_21\", copy len %u\\n\",\n\t\t\t     VAR_11, xcopy->src_lba, xcopy->lba_cnt);\n\t\tVAR_12 = VAR_22;\n\t\tgoto err;\n\t}\n\n\tVAR_11 = tcmu_dev_get_num_lbas(xcopy->dst_dev);\n\tif (xcopy->dst_lba + xcopy->lba_cnt > VAR_11) {\n\t\ttcmu_dev_err(xcopy->dst_dev,\n\t\t\t     \"dst target exceeds last lba %\"VAR_21\" (lba %\"VAR_21\", copy len %u)\\n\",\n\t\t\t     VAR_11, xcopy->dst_lba, xcopy->lba_cnt);\n\t\tVAR_12 = VAR_22;\n\t\tgoto err;\n\t}\n\n\tfree(VAR_8);\n\treturn VAR_18;\n\nerr:\n\tfree(VAR_8);\n\n\treturn VAR_12;\n}",
  "func_graph_path": "open-iscsi/tcmu-runner/2b16e96e6b63d0419d857f53e4cc67f0adb383fd/tcmur_cmd_handler.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -135,6 +135,18 @@\n \tif (ret != TCMU_STS_OK)\n \t\tgoto err;\n \n+\t/*\n+\t * tcmu-runner can't determine whether the device(s) referred to in an\n+\t * XCOPY request should be accessible to the initiator via transport\n+\t * settings, ACLs, etc. XXX Consequently, we need to fail any\n+\t * cross-device requests for safety reasons.\n+\t */\n+\tif (dev != xcopy->src_dev || dev != xcopy->dst_dev) {\n+\t\ttcmu_dev_err(dev, \"Cross-device XCOPY not supported\\n\");\n+\t\tret = TCMU_STS_CP_TGT_DEV_NOTCONN;\n+\t\tgoto err;\n+\t}\n+\n \tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n \t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n \t\ttcmu_dev_err(dev, \"The block size of src dev %u != dst dev %u\\n\",",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t/*",
      "\t * tcmu-runner can't determine whether the device(s) referred to in an",
      "\t * XCOPY request should be accessible to the initiator via transport",
      "\t * settings, ACLs, etc. XXX Consequently, we need to fail any",
      "\t * cross-device requests for safety reasons.",
      "\t */",
      "\tif (dev != xcopy->src_dev || dev != xcopy->dst_dev) {",
      "\t\ttcmu_dev_err(dev, \"Cross-device XCOPY not supported\\n\");",
      "\t\tret = TCMU_STS_CP_TGT_DEV_NOTCONN;",
      "\t\tgoto err;",
      "\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/open-iscsi/tcmu-runner/pull/644",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/open-iscsi/tcmu-runner/pull/644: 403 Client Error: Forbidden for url: https://api.github.com/repos/open-iscsi/tcmu-runner/pulls/644",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}