{
  "cve_id": "CVE-2018-8005",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "apache/trafficserver",
  "commit_msg": "Adds a new configuration proxy.config.http.allow_multi_range\n\nThis is needed to prevent potential abuse with well formed multi-\nrange requests.",
  "commit_hash": "6d248026b04d69e5c5049709c17ea671328ea4ea",
  "git_url": "https://github.com/apache/trafficserver/commit/6d248026b04d69e5c5049709c17ea671328ea4ea",
  "file_path": "proxy/http/HttpSM.cc",
  "func_name": "HttpSM::do_range_setup_if_necessary",
  "func_before": "void\nHttpSM::do_range_setup_if_necessary()\n{\n  MIMEField *field;\n  INKVConnInternal *range_trans;\n  int field_content_type_len = -1;\n  const char *content_type;\n\n  ink_assert(t_state.cache_info.object_read != nullptr);\n\n  field = t_state.hdr_info.client_request.field_find(MIME_FIELD_RANGE, MIME_LEN_RANGE);\n  ink_assert(field != nullptr);\n\n  t_state.range_setup = HttpTransact::RANGE_NONE;\n\n  if (t_state.method == HTTP_WKSIDX_GET && t_state.hdr_info.client_request.version_get() == HTTPVersion(1, 1)) {\n    do_range_parse(field);\n\n    if (t_state.range_setup == HttpTransact::RANGE_REQUESTED) {\n      if (!t_state.range_in_cache) {\n        Debug(\"http_range\", \"range can't be satisfied from cache, force origin request\");\n        t_state.cache_lookup_result = HttpTransact::CACHE_LOOKUP_MISS;\n        return;\n      }\n\n      // if only one range entry and pread is capable, no need transform range\n      if (t_state.num_range_fields == 1 && cache_sm.cache_read_vc->is_pread_capable()) {\n        t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;\n      } else if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) {\n        Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");\n        content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,\n                                                                                 &field_content_type_len);\n        // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)\n        range_trans = transformProcessor.range_transform(mutex.get(), t_state.ranges, t_state.num_range_fields,\n                                                         &t_state.hdr_info.transform_response, content_type, field_content_type_len,\n                                                         t_state.cache_info.object_read->object_size_get());\n        api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);\n      }\n    }\n  }\n}",
  "abstract_func_before": "void\nHttpSM::do_range_setup_if_necessary()\n{\n  MIMEField *VAR_0;\n  INKVConnInternal *VAR_1;\n  int VAR_2 = -1;\n  const char *VAR_3;\n\n  ink_assert(VAR_4.cache_info.object_read != nullptr);\n\n  VAR_0 = VAR_4.hdr_info.client_request.field_find(VAR_5, VAR_6);\n  ink_assert(VAR_0 != nullptr);\n\n  VAR_4.range_setup = HttpTransact::RANGE_NONE;\n\n  if (VAR_4.method == VAR_7 && VAR_4.hdr_info.client_request.version_get() == HTTPVersion(1, 1)) {\n    do_range_parse(VAR_0);\n\n    if (VAR_4.range_setup == HttpTransact::RANGE_REQUESTED) {\n      if (!VAR_4.range_in_cache) {\n        Debug(\"http_range\", \"range can't be satisfied from cache, force origin request\");\n        VAR_4.cache_lookup_result = HttpTransact::CACHE_LOOKUP_MISS;\n        return;\n      }\n\n      /* COMMENT_0 */\n      if (VAR_4.num_range_fields == 1 && VAR_8.cache_read_vc->is_pread_capable()) {\n        VAR_4.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;\n      } else if (VAR_9.get(VAR_10) == nullptr) {\n        Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");\n        VAR_3 = VAR_4.cache_info.object_read->response_get()->value_get(VAR_11, VAR_12,\n                                                                                 &VAR_2);\n        /* COMMENT_1 */\n        VAR_1 = VAR_13.range_transform(VAR_14.get(), VAR_4.ranges, VAR_4.num_range_fields,\n                                                         &VAR_4.hdr_info.transform_response, VAR_3, VAR_2,\n                                                         VAR_4.cache_info.object_read->object_size_get());\n        VAR_9.append(VAR_10, VAR_1);\n      }\n    }\n  }\n}",
  "func_graph_path_before": "apache/trafficserver/6d248026b04d69e5c5049709c17ea671328ea4ea/HttpSM.cc/vul/before/0.json",
  "func": "void\nHttpSM::do_range_setup_if_necessary()\n{\n  MIMEField *field;\n  INKVConnInternal *range_trans;\n  int field_content_type_len = -1;\n  const char *content_type;\n\n  ink_assert(t_state.cache_info.object_read != nullptr);\n\n  field = t_state.hdr_info.client_request.field_find(MIME_FIELD_RANGE, MIME_LEN_RANGE);\n  ink_assert(field != nullptr);\n\n  t_state.range_setup = HttpTransact::RANGE_NONE;\n\n  if (t_state.method == HTTP_WKSIDX_GET && t_state.hdr_info.client_request.version_get() == HTTPVersion(1, 1)) {\n    do_range_parse(field);\n\n    if (t_state.range_setup == HttpTransact::RANGE_REQUESTED) {\n      bool do_transform = false;\n\n      if (!t_state.range_in_cache) {\n        Debug(\"http_range\", \"range can't be satisfied from cache, force origin request\");\n        t_state.cache_lookup_result = HttpTransact::CACHE_LOOKUP_MISS;\n        return;\n      }\n\n      if (t_state.num_range_fields > 1) {\n        if (0 == t_state.txn_conf->allow_multi_range) {\n          t_state.range_setup = HttpTransact::RANGE_NONE;                                 // No Range required (not allowed)\n          t_state.hdr_info.client_request.field_delete(MIME_FIELD_RANGE, MIME_LEN_RANGE); // ... and nuke the Range header too\n          t_state.num_range_fields = 0;\n        } else if (1 == t_state.txn_conf->allow_multi_range) {\n          do_transform = true;\n        } else {\n          t_state.num_range_fields = 0;\n          t_state.range_setup      = HttpTransact::RANGE_NOT_SATISFIABLE;\n        }\n      } else {\n        if (cache_sm.cache_read_vc->is_pread_capable()) {\n          // If only one range entry and pread is capable, no need transform range\n          t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;\n        } else {\n          do_transform = true;\n        }\n      }\n\n      // We have to do the transform on (allowed) multi-range request, *or* if the VC is not pread capable\n      if (do_transform) {\n        if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) {\n          Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");\n          content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,\n                                                                                   &field_content_type_len);\n          // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)\n          range_trans = transformProcessor.range_transform(\n            mutex.get(), t_state.ranges, t_state.num_range_fields, &t_state.hdr_info.transform_response, content_type,\n            field_content_type_len, t_state.cache_info.object_read->object_size_get());\n          api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);\n        } else {\n          // ToDo: Do we do something here? The theory is that multiple transforms do not behave well with\n          // the range transform needed here.\n        }\n      }\n    }\n  }\n}",
  "abstract_func": "void\nHttpSM::do_range_setup_if_necessary()\n{\n  MIMEField *VAR_0;\n  INKVConnInternal *VAR_1;\n  int VAR_2 = -1;\n  const char *VAR_3;\n\n  ink_assert(VAR_4.cache_info.object_read != nullptr);\n\n  VAR_0 = VAR_4.hdr_info.client_request.field_find(VAR_5, VAR_6);\n  ink_assert(VAR_0 != nullptr);\n\n  VAR_4.range_setup = HttpTransact::RANGE_NONE;\n\n  if (VAR_4.method == VAR_7 && VAR_4.hdr_info.client_request.version_get() == HTTPVersion(1, 1)) {\n    do_range_parse(VAR_0);\n\n    if (VAR_4.range_setup == HttpTransact::RANGE_REQUESTED) {\n      bool VAR_8 = false;\n\n      if (!VAR_4.range_in_cache) {\n        Debug(\"http_range\", \"range can't be satisfied from cache, force origin request\");\n        VAR_4.cache_lookup_result = HttpTransact::CACHE_LOOKUP_MISS;\n        return;\n      }\n\n      if (VAR_4.num_range_fields > 1) {\n        if (0 == VAR_4.txn_conf->allow_multi_range) {\n          VAR_4.range_setup = HttpTransact::RANGE_NONE;                                 /* COMMENT_0 */\n          VAR_4.hdr_info.client_request.field_delete(VAR_5, VAR_6); /* COMMENT_1 */\n          VAR_4.num_range_fields = 0;\n        } else if (1 == VAR_4.txn_conf->allow_multi_range) {\n          VAR_8 = true;\n        } else {\n          VAR_4.num_range_fields = 0;\n          VAR_4.range_setup      = HttpTransact::RANGE_NOT_SATISFIABLE;\n        }\n      } else {\n        if (VAR_9.cache_read_vc->is_pread_capable()) {\n          /* COMMENT_2 */\n          VAR_4.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;\n        } else {\n          VAR_8 = true;\n        }\n      }\n\n      /* COMMENT_3 */\n      if (VAR_8) {\n        if (VAR_10.get(VAR_11) == nullptr) {\n          Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");\n          VAR_3 = VAR_4.cache_info.object_read->response_get()->value_get(VAR_12, VAR_13,\n                                                                                   &VAR_2);\n          /* COMMENT_4 */\n          VAR_1 = VAR_14.range_transform(\n            VAR_15.get(), VAR_4.ranges, VAR_4.num_range_fields, &VAR_4.hdr_info.transform_response, VAR_3,\n            VAR_2, VAR_4.cache_info.object_read->object_size_get());\n          VAR_10.append(VAR_11, VAR_1);\n        } else {\n          /* COMMENT_5 */\n          /* COMMENT_6 */\n        }\n      }\n    }\n  }\n}",
  "func_graph_path": "apache/trafficserver/6d248026b04d69e5c5049709c17ea671328ea4ea/HttpSM.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,24 +17,49 @@\n     do_range_parse(field);\n \n     if (t_state.range_setup == HttpTransact::RANGE_REQUESTED) {\n+      bool do_transform = false;\n+\n       if (!t_state.range_in_cache) {\n         Debug(\"http_range\", \"range can't be satisfied from cache, force origin request\");\n         t_state.cache_lookup_result = HttpTransact::CACHE_LOOKUP_MISS;\n         return;\n       }\n \n-      // if only one range entry and pread is capable, no need transform range\n-      if (t_state.num_range_fields == 1 && cache_sm.cache_read_vc->is_pread_capable()) {\n-        t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;\n-      } else if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) {\n-        Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");\n-        content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,\n-                                                                                 &field_content_type_len);\n-        // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)\n-        range_trans = transformProcessor.range_transform(mutex.get(), t_state.ranges, t_state.num_range_fields,\n-                                                         &t_state.hdr_info.transform_response, content_type, field_content_type_len,\n-                                                         t_state.cache_info.object_read->object_size_get());\n-        api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);\n+      if (t_state.num_range_fields > 1) {\n+        if (0 == t_state.txn_conf->allow_multi_range) {\n+          t_state.range_setup = HttpTransact::RANGE_NONE;                                 // No Range required (not allowed)\n+          t_state.hdr_info.client_request.field_delete(MIME_FIELD_RANGE, MIME_LEN_RANGE); // ... and nuke the Range header too\n+          t_state.num_range_fields = 0;\n+        } else if (1 == t_state.txn_conf->allow_multi_range) {\n+          do_transform = true;\n+        } else {\n+          t_state.num_range_fields = 0;\n+          t_state.range_setup      = HttpTransact::RANGE_NOT_SATISFIABLE;\n+        }\n+      } else {\n+        if (cache_sm.cache_read_vc->is_pread_capable()) {\n+          // If only one range entry and pread is capable, no need transform range\n+          t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;\n+        } else {\n+          do_transform = true;\n+        }\n+      }\n+\n+      // We have to do the transform on (allowed) multi-range request, *or* if the VC is not pread capable\n+      if (do_transform) {\n+        if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) {\n+          Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");\n+          content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,\n+                                                                                   &field_content_type_len);\n+          // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)\n+          range_trans = transformProcessor.range_transform(\n+            mutex.get(), t_state.ranges, t_state.num_range_fields, &t_state.hdr_info.transform_response, content_type,\n+            field_content_type_len, t_state.cache_info.object_read->object_size_get());\n+          api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);\n+        } else {\n+          // ToDo: Do we do something here? The theory is that multiple transforms do not behave well with\n+          // the range transform needed here.\n+        }\n       }\n     }\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "      // if only one range entry and pread is capable, no need transform range",
      "      if (t_state.num_range_fields == 1 && cache_sm.cache_read_vc->is_pread_capable()) {",
      "        t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;",
      "      } else if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) {",
      "        Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");",
      "        content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,",
      "                                                                                 &field_content_type_len);",
      "        // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)",
      "        range_trans = transformProcessor.range_transform(mutex.get(), t_state.ranges, t_state.num_range_fields,",
      "                                                         &t_state.hdr_info.transform_response, content_type, field_content_type_len,",
      "                                                         t_state.cache_info.object_read->object_size_get());",
      "        api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);"
    ],
    "added_lines": [
      "      bool do_transform = false;",
      "",
      "      if (t_state.num_range_fields > 1) {",
      "        if (0 == t_state.txn_conf->allow_multi_range) {",
      "          t_state.range_setup = HttpTransact::RANGE_NONE;                                 // No Range required (not allowed)",
      "          t_state.hdr_info.client_request.field_delete(MIME_FIELD_RANGE, MIME_LEN_RANGE); // ... and nuke the Range header too",
      "          t_state.num_range_fields = 0;",
      "        } else if (1 == t_state.txn_conf->allow_multi_range) {",
      "          do_transform = true;",
      "        } else {",
      "          t_state.num_range_fields = 0;",
      "          t_state.range_setup      = HttpTransact::RANGE_NOT_SATISFIABLE;",
      "        }",
      "      } else {",
      "        if (cache_sm.cache_read_vc->is_pread_capable()) {",
      "          // If only one range entry and pread is capable, no need transform range",
      "          t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED;",
      "        } else {",
      "          do_transform = true;",
      "        }",
      "      }",
      "",
      "      // We have to do the transform on (allowed) multi-range request, *or* if the VC is not pread capable",
      "      if (do_transform) {",
      "        if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) {",
      "          Debug(\"http_trans\", \"Unable to accelerate range request, fallback to transform\");",
      "          content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE,",
      "                                                                                   &field_content_type_len);",
      "          // create a Range: transform processor for requests of type Range: bytes=1-2,4-5,10-100 (eg. multiple ranges)",
      "          range_trans = transformProcessor.range_transform(",
      "            mutex.get(), t_state.ranges, t_state.num_range_fields, &t_state.hdr_info.transform_response, content_type,",
      "            field_content_type_len, t_state.cache_info.object_read->object_size_get());",
      "          api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans);",
      "        } else {",
      "          // ToDo: Do we do something here? The theory is that multiple transforms do not behave well with",
      "          // the range transform needed here.",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/apache/trafficserver/pull/3106",
  "description": {
    "pr_info": {
      "title": "Adds a new configuration proxy.config.http.allow_multi_range",
      "number": 3106
    },
    "comment": [
      "This is needed to prevent potential abuse with well formed multi-\r\nrange requests.",
      "This has many, but trivial, merge conflicts, primarily due to clang-formatting.",
      "Cheery-picked to 7.1.3"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}