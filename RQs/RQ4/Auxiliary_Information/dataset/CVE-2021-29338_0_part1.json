{
  "cve_id": "CVE-2021-29338",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "Fix integer overflow in num_images\n\nIncludes the fix for CVE-2021-29338\nCredit to @kaniini based on #1346\nFixes #1338",
  "commit_hash": "f0727df07c4d944d7d1c5002451cfbc9545d3288",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/f0727df07c4d944d7d1c5002451cfbc9545d3288",
  "file_path": "src/bin/jp2/opj_compress.c",
  "func_name": "main",
  "func_before": "int main(int argc, char **argv)\n{\n\n    opj_cparameters_t parameters;   /* compression parameters */\n\n    opj_stream_t *l_stream = 00;\n    opj_codec_t* l_codec = 00;\n    opj_image_t *image = NULL;\n    raw_cparameters_t raw_cp;\n    OPJ_SIZE_T num_compressed_files = 0;\n\n    char indexfilename[OPJ_PATH_LEN];   /* index file name */\n\n    unsigned int i, num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n\n    int ret = 0;\n\n    OPJ_BOOL bSuccess;\n    OPJ_BOOL bUseTiles = OPJ_FALSE; /* OPJ_TRUE */\n    OPJ_UINT32 l_nb_tiles = 4;\n    int framerate = 0;\n    OPJ_FLOAT64 t = opj_clock();\n\n    OPJ_BOOL PLT = OPJ_FALSE;\n    OPJ_BOOL TLM = OPJ_FALSE;\n    int num_threads = 0;\n\n    /** desired bitdepth from input file */\n    unsigned int target_bitdepth = 0;\n\n    /* set encoding parameters to default values */\n    opj_set_default_encoder_parameters(&parameters);\n\n    /* Initialize indexfilename and img_fol */\n    *indexfilename = 0;\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* raw_cp initialization */\n    raw_cp.rawBitDepth = 0;\n    raw_cp.rawComp = 0;\n    raw_cp.rawComps = 0;\n    raw_cp.rawHeight = 0;\n    raw_cp.rawSigned = 0;\n    raw_cp.rawWidth = 0;\n\n    /* parse input and get user encoding parameters */\n    parameters.tcp_mct = (char)\n                         255; /* This will be set later according to the input image or the provided option */\n    if (parse_cmdline_encoder(argc, argv, &parameters, &img_fol, &raw_cp,\n                              indexfilename, sizeof(indexfilename), &framerate, &PLT, &TLM,\n                              &num_threads, &target_bitdepth) == 1) {\n        ret = 1;\n        goto fin;\n    }\n\n    /* Read directory if necessary */\n    if (img_fol.set_imgdir == 1) {\n        num_images = get_num_images(img_fol.imgdirpath);\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (dirptr) {\n            dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(\n                    char)); /* Stores at max 10 image file names*/\n            dirptr->filename = (char**) malloc(num_images * sizeof(char*));\n            if (!dirptr->filename_buf) {\n                ret = 0;\n                goto fin;\n            }\n            for (i = 0; i < num_images; i++) {\n                dirptr->filename[i] = dirptr->filename_buf + i * OPJ_PATH_LEN;\n            }\n        }\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            ret = 0;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stdout, \"Folder is empty\\n\");\n            ret = 0;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n    /*Encoding image one by one*/\n    for (imageno = 0; imageno < num_images; imageno++) {\n        image = NULL;\n        fprintf(stderr, \"\\n\");\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file((int)imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        switch (parameters.decod_format) {\n        case PGX_DFMT:\n        case PXM_DFMT:\n        case BMP_DFMT:\n        case TIF_DFMT:\n        case RAW_DFMT:\n        case RAWL_DFMT:\n        case TGA_DFMT:\n        case PNG_DFMT:\n            break;\n        default:\n            fprintf(stderr, \"skipping file...\\n\");\n            continue;\n        }\n\n        /* decode the source image */\n        /* ----------------------- */\n\n        switch (parameters.decod_format) {\n        case PGX_DFMT:\n            image = pgxtoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load pgx file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case PXM_DFMT:\n            image = pnmtoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load pnm file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case BMP_DFMT:\n            image = bmptoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load bmp file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:\n            image = tiftoimage(parameters.infile, &parameters, target_bitdepth);\n            if (!image) {\n                fprintf(stderr, \"Unable to load tif(f) file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n\n        case RAW_DFMT:\n            image = rawtoimage(parameters.infile, &parameters, &raw_cp);\n            if (!image) {\n                fprintf(stderr, \"Unable to load raw or yuv file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case RAWL_DFMT:\n            image = rawltoimage(parameters.infile, &parameters, &raw_cp);\n            if (!image) {\n                fprintf(stderr, \"Unable to load raw file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case TGA_DFMT:\n            image = tgatoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load tga file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:\n            image = pngtoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load png file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        }\n\n        /* Can happen if input file is TIF(F) or PNG\n        * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        if (!image) {\n            fprintf(stderr, \"Unable to load file: got no image\\n\");\n            ret = 1;\n            goto fin;\n        }\n\n        /* Decide if MCT should be used */\n        if (parameters.tcp_mct == (char)\n                255) { /* mct mode has not been set in commandline */\n            parameters.tcp_mct = (image->numcomps >= 3) ? 1 : 0;\n        } else {            /* mct mode has been set in commandline */\n            if ((parameters.tcp_mct == 1) && (image->numcomps < 3)) {\n                fprintf(stderr, \"RGB->YCC conversion cannot be used:\\n\");\n                fprintf(stderr, \"Input image has less than 3 components\\n\");\n                ret = 1;\n                goto fin;\n            }\n            if ((parameters.tcp_mct == 2) && (!parameters.mct_data)) {\n                fprintf(stderr, \"Custom MCT has been set but no array-based MCT\\n\");\n                fprintf(stderr, \"has been provided. Aborting.\\n\");\n                ret = 1;\n                goto fin;\n            }\n        }\n\n        if (OPJ_IS_IMF(parameters.rsiz) && framerate > 0) {\n            const int mainlevel = OPJ_GET_IMF_MAINLEVEL(parameters.rsiz);\n            if (mainlevel > 0 && mainlevel <= OPJ_IMF_MAINLEVEL_MAX) {\n                const int limitMSamplesSec[] = {\n                    0,\n                    OPJ_IMF_MAINLEVEL_1_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_2_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_3_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_4_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_5_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_6_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_7_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_8_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_9_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_10_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_11_MSAMPLESEC\n                };\n                OPJ_UINT32 avgcomponents = image->numcomps;\n                double msamplespersec;\n                if (image->numcomps == 3 &&\n                        image->comps[1].dx == 2 &&\n                        image->comps[1].dy == 2) {\n                    avgcomponents = 2;\n                }\n                msamplespersec = (double)image->x1 * image->y1 * avgcomponents * framerate /\n                                 1e6;\n                if (msamplespersec > limitMSamplesSec[mainlevel]) {\n                    fprintf(stderr,\n                            \"Warning: MSamples/sec is %f, whereas limit is %d.\\n\",\n                            msamplespersec,\n                            limitMSamplesSec[mainlevel]);\n                }\n            }\n        }\n\n        /* encode the destination image */\n        /* ---------------------------- */\n\n        switch (parameters.cod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_compress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_compress(OPJ_CODEC_JP2);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        /* catch events using our callbacks and give a local context */\n        opj_set_info_handler(l_codec, info_callback, 00);\n        opj_set_warning_handler(l_codec, warning_callback, 00);\n        opj_set_error_handler(l_codec, error_callback, 00);\n\n        if (bUseTiles) {\n            parameters.cp_tx0 = 0;\n            parameters.cp_ty0 = 0;\n            parameters.tile_size_on = OPJ_TRUE;\n            parameters.cp_tdx = 512;\n            parameters.cp_tdy = 512;\n        }\n        if (! opj_setup_encoder(l_codec, &parameters, image)) {\n            fprintf(stderr, \"failed to encode image: opj_setup_encoder\\n\");\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            ret = 1;\n            goto fin;\n        }\n\n        if (PLT || TLM) {\n            const char* options[3] = { NULL, NULL, NULL };\n            int iOpt = 0;\n            if (PLT) {\n                options[iOpt++] = \"PLT=YES\";\n            }\n            if (TLM) {\n                options[iOpt++] = \"TLM=YES\";\n            }\n            (void)iOpt;\n            if (!opj_encoder_set_extra_options(l_codec, options)) {\n                fprintf(stderr, \"failed to encode image: opj_encoder_set_extra_options\\n\");\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                ret = 1;\n                goto fin;\n            }\n        }\n\n        if (num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, num_threads)) {\n            fprintf(stderr, \"failed to set number of threads\\n\");\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            ret = 1;\n            goto fin;\n        }\n\n        /* open a byte stream for writing and allocate memory for all tiles */\n        l_stream = opj_stream_create_default_file_stream(parameters.outfile, OPJ_FALSE);\n        if (! l_stream) {\n            ret = 1;\n            goto fin;\n        }\n\n        /* encode the image */\n        bSuccess = opj_start_compress(l_codec, image, l_stream);\n        if (!bSuccess)  {\n            fprintf(stderr, \"failed to encode image: opj_start_compress\\n\");\n        }\n        if (bSuccess && bUseTiles) {\n            OPJ_BYTE *l_data;\n            OPJ_UINT32 l_data_size = 512 * 512 * 3;\n            l_data = (OPJ_BYTE*) calloc(1, l_data_size);\n            if (l_data == NULL) {\n                ret = 1;\n                goto fin;\n            }\n            for (i = 0; i < l_nb_tiles; ++i) {\n                if (! opj_write_tile(l_codec, i, l_data, l_data_size, l_stream)) {\n                    fprintf(stderr, \"ERROR -> test_tile_encoder: failed to write the tile %d!\\n\",\n                            i);\n                    opj_stream_destroy(l_stream);\n                    opj_destroy_codec(l_codec);\n                    opj_image_destroy(image);\n                    ret = 1;\n                    goto fin;\n                }\n            }\n            free(l_data);\n        } else {\n            bSuccess = bSuccess && opj_encode(l_codec, l_stream);\n            if (!bSuccess)  {\n                fprintf(stderr, \"failed to encode image: opj_encode\\n\");\n            }\n        }\n        bSuccess = bSuccess && opj_end_compress(l_codec, l_stream);\n        if (!bSuccess)  {\n            fprintf(stderr, \"failed to encode image: opj_end_compress\\n\");\n        }\n\n        if (!bSuccess)  {\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            fprintf(stderr, \"failed to encode image\\n\");\n            remove(parameters.outfile);\n            ret = 1;\n            goto fin;\n        }\n\n        num_compressed_files++;\n        fprintf(stdout, \"[INFO] Generated outfile %s\\n\", parameters.outfile);\n        /* close and free the byte stream */\n        opj_stream_destroy(l_stream);\n\n        /* free remaining compression structures */\n        opj_destroy_codec(l_codec);\n\n        /* free image data */\n        opj_image_destroy(image);\n\n    }\n\n    t = opj_clock() - t;\n    if (num_compressed_files) {\n        fprintf(stdout, \"encode time: %d ms \\n\",\n                (int)((t * 1000.0) / (OPJ_FLOAT64)num_compressed_files));\n    }\n\n    ret = 0;\n\nfin:\n    if (parameters.cp_comment) {\n        free(parameters.cp_comment);\n    }\n    if (parameters.cp_matrice) {\n        free(parameters.cp_matrice);\n    }\n    if (raw_cp.rawComps) {\n        free(raw_cp.rawComps);\n    }\n    if (img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        free(dirptr);\n    }\n    return ret;\n}",
  "abstract_func_before": "int main(int VAR_0, char **VAR_1)\n{\n\n    opj_cparameters_t VAR_2;   /* COMMENT_0 */\n\n    opj_stream_t *VAR_3 = 00;\n    opj_codec_t* VAR_4 = 00;\n    opj_image_t *VAR_5 = NULL;\n    raw_cparameters_t VAR_6;\n    OPJ_SIZE_T VAR_7 = 0;\n\n    char VAR_8[VAR_9];   /* COMMENT_1 */\n\n    unsigned int VAR_10, VAR_11, VAR_12;\n    img_fol_t VAR_13;\n    dircnt_t *VAR_14 = NULL;\n\n    int VAR_15 = 0;\n\n    OPJ_BOOL VAR_16;\n    OPJ_BOOL VAR_17 = VAR_18; /* COMMENT_2 */\n    OPJ_UINT32 VAR_19 = 4;\n    int VAR_20 = 0;\n    OPJ_FLOAT64 VAR_21 = opj_clock();\n\n    OPJ_BOOL VAR_22 = VAR_18;\n    OPJ_BOOL VAR_23 = VAR_18;\n    int VAR_24 = 0;\n\n    /* COMMENT_3 */\n    unsigned int VAR_25 = 0;\n\n    /* COMMENT_4 */\n    opj_set_default_encoder_parameters(&VAR_2);\n\n    /* COMMENT_5 */\n    *VAR_8 = 0;\n    memset(&VAR_13, 0, sizeof(img_fol_t));\n\n    /* COMMENT_6 */\n    VAR_6.rawBitDepth = 0;\n    VAR_6.rawComp = 0;\n    VAR_6.rawComps = 0;\n    VAR_6.rawHeight = 0;\n    VAR_6.rawSigned = 0;\n    VAR_6.rawWidth = 0;\n\n    /* COMMENT_7 */\n    VAR_2.tcp_mct = (char)\n                         255; /* COMMENT_8 */\n    if (parse_cmdline_encoder(VAR_0, VAR_1, &VAR_2, &VAR_13, &VAR_6,\n                              VAR_8, sizeof(VAR_8), &VAR_20, &VAR_22, &VAR_23,\n                              &VAR_24, &VAR_25) == 1) {\n        VAR_15 = 1;\n        goto fin;\n    }\n\n    /* COMMENT_9 */\n    if (VAR_13.set_imgdir == 1) {\n        VAR_11 = get_num_images(VAR_13.imgdirpath);\n        VAR_14 = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (VAR_14) {\n            VAR_14->filename_buf = (char*)malloc(VAR_11 * VAR_9 * sizeof(\n                    char)); /* COMMENT_10 */\n            VAR_14->filename = (char**) malloc(VAR_11 * sizeof(char*));\n            if (!VAR_14->filename_buf) {\n                VAR_15 = 0;\n                goto fin;\n            }\n            for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {\n                VAR_14->filename[VAR_10] = VAR_14->filename_buf + VAR_10 * VAR_9;\n            }\n        }\n        if (load_images(VAR_14, VAR_13.imgdirpath) == 1) {\n            VAR_15 = 0;\n            goto fin;\n        }\n        if (VAR_11 == 0) {\n            fprintf(VAR_26, \"Folder is empty\\n\");\n            VAR_15 = 0;\n            goto fin;\n        }\n    } else {\n        VAR_11 = 1;\n    }\n    /* COMMENT_11 */\n    for (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {\n        VAR_5 = NULL;\n        fprintf(VAR_27, \"\\n\");\n\n        if (VAR_13.set_imgdir == 1) {\n            if (get_next_file((int)VAR_12, VAR_14, &VAR_13, &VAR_2)) {\n                fprintf(VAR_27, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        switch (VAR_2.decod_format) {\n        case VAR_28:\n        case VAR_29:\n        case VAR_30:\n        case VAR_31:\n        case VAR_32:\n        case VAR_33:\n        case VAR_34:\n        case VAR_35:\n            break;\n        default:\n            fprintf(VAR_27, \"skipping file...\\n\");\n            continue;\n        }\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n\n        switch (VAR_2.decod_format) {\n        case VAR_28:\n            VAR_5 = pgxtoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load pgx file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_29:\n            VAR_5 = pnmtoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load pnm file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_30:\n            VAR_5 = bmptoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load bmp file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef VAR_36\n        case VAR_31:\n            VAR_5 = tiftoimage(VAR_2.infile, &VAR_2, VAR_25);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load tif(f) file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n#endif /* COMMENT_14 */\n\n        case VAR_32:\n            VAR_5 = rawtoimage(VAR_2.infile, &VAR_2, &VAR_6);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load raw or yuv file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_33:\n            VAR_5 = rawltoimage(VAR_2.infile, &VAR_2, &VAR_6);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load raw file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_34:\n            VAR_5 = tgatoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load tga file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef VAR_37\n        case VAR_35:\n            VAR_5 = pngtoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load png file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n#endif /* COMMENT_15 */\n        }\n\n        /* COMMENT_16 */\n                                                             \n          \n        if (!VAR_5) {\n            fprintf(VAR_27, \"Unable to load file: got no image\\n\");\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_19 */\n        if (VAR_2.tcp_mct == (char)\n                255) { /* COMMENT_20 */\n            VAR_2.tcp_mct = (VAR_5->numcomps >= 3) ? 1 : 0;\n        } else {            /* COMMENT_21 */\n            if ((VAR_2.tcp_mct == 1) && (VAR_5->numcomps < 3)) {\n                fprintf(VAR_27, \"RGB->YCC conversion cannot be used:\\n\");\n                fprintf(VAR_27, \"Input image has less than 3 components\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            if ((VAR_2.tcp_mct == 2) && (!VAR_2.mct_data)) {\n                fprintf(VAR_27, \"Custom MCT has been set but no array-based MCT\\n\");\n                fprintf(VAR_27, \"has been provided. Aborting.\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n        }\n\n        if (OPJ_IS_IMF(VAR_2.rsiz) && VAR_20 > 0) {\n            const int VAR_38 = OPJ_GET_IMF_MAINLEVEL(VAR_2.rsiz);\n            if (VAR_38 > 0 && VAR_38 <= VAR_39) {\n                const int VAR_40[] = {\n                    0,\n                    VAR_41,\n                    VAR_42,\n                    VAR_43,\n                    VAR_44,\n                    VAR_45,\n                    VAR_46,\n                    VAR_47,\n                    VAR_48,\n                    VAR_49,\n                    VAR_50,\n                    VAR_51\n                };\n                OPJ_UINT32 VAR_52 = VAR_5->numcomps;\n                double VAR_53;\n                if (VAR_5->numcomps == 3 &&\n                        VAR_5->comps[1].dx == 2 &&\n                        VAR_5->comps[1].dy == 2) {\n                    VAR_52 = 2;\n                }\n                VAR_53 = (double)VAR_5->x1 * VAR_5->y1 * VAR_52 * VAR_20 /\n                                 1e6;\n                if (VAR_53 > VAR_40[VAR_38]) {\n                    fprintf(VAR_27,\n                            \"Warning: MSamples/sec is %f, whereas limit is %d.\\n\",\n                            VAR_53,\n                            VAR_40[VAR_38]);\n                }\n            }\n        }\n\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n\n        switch (VAR_2.cod_format) {\n        case VAR_54: { /* COMMENT_24 */\n            /* COMMENT_25 */\n            VAR_4 = opj_create_compress(VAR_55);\n            break;\n        }\n        case VAR_56: { /* COMMENT_26 */\n            /* COMMENT_25 */\n            VAR_4 = opj_create_compress(VAR_57);\n            break;\n        }\n        default:\n            fprintf(VAR_27, \"skipping file..\\n\");\n            opj_stream_destroy(VAR_3);\n            continue;\n        }\n\n        /* COMMENT_27 */\n        opj_set_info_handler(VAR_4, VAR_58, 00);\n        opj_set_warning_handler(VAR_4, VAR_59, 00);\n        opj_set_error_handler(VAR_4, VAR_60, 00);\n\n        if (VAR_17) {\n            VAR_2.cp_tx0 = 0;\n            VAR_2.cp_ty0 = 0;\n            VAR_2.tile_size_on = VAR_61;\n            VAR_2.cp_tdx = 512;\n            VAR_2.cp_tdy = 512;\n        }\n        if (! opj_setup_encoder(VAR_4, &VAR_2, VAR_5)) {\n            fprintf(VAR_27, \"failed to encode image: opj_setup_encoder\\n\");\n            opj_destroy_codec(VAR_4);\n            opj_image_destroy(VAR_5);\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        if (VAR_22 || VAR_23) {\n            const char* VAR_62[3] = { NULL, NULL, NULL };\n            int VAR_63 = 0;\n            if (VAR_22) {\n                VAR_62[VAR_63++] = \"PLT=YES\";\n            }\n            if (VAR_23) {\n                VAR_62[VAR_63++] = \"TLM=YES\";\n            }\n            (void)VAR_63;\n            if (!opj_encoder_set_extra_options(VAR_4, VAR_62)) {\n                fprintf(VAR_27, \"failed to encode image: opj_encoder_set_extra_options\\n\");\n                opj_destroy_codec(VAR_4);\n                opj_image_destroy(VAR_5);\n                VAR_15 = 1;\n                goto fin;\n            }\n        }\n\n        if (VAR_24 >= 1 &&\n                !opj_codec_set_threads(VAR_4, VAR_24)) {\n            fprintf(VAR_27, \"failed to set number of threads\\n\");\n            opj_destroy_codec(VAR_4);\n            opj_image_destroy(VAR_5);\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_28 */\n        VAR_3 = opj_stream_create_default_file_stream(VAR_2.outfile, VAR_18);\n        if (! VAR_3) {\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_29 */\n        VAR_16 = opj_start_compress(VAR_4, VAR_5, VAR_3);\n        if (!VAR_16)  {\n            fprintf(VAR_27, \"failed to encode image: opj_start_compress\\n\");\n        }\n        if (VAR_16 && VAR_17) {\n            OPJ_BYTE *VAR_64;\n            OPJ_UINT32 VAR_65 = 512 * 512 * 3;\n            VAR_64 = (OPJ_BYTE*) calloc(1, VAR_65);\n            if (VAR_64 == NULL) {\n                VAR_15 = 1;\n                goto fin;\n            }\n            for (VAR_10 = 0; VAR_10 < VAR_19; ++VAR_10) {\n                if (! opj_write_tile(VAR_4, VAR_10, VAR_64, VAR_65, VAR_3)) {\n                    fprintf(VAR_27, \"ERROR -> test_tile_encoder: failed to write the tile %d!\\n\",\n                            VAR_10);\n                    opj_stream_destroy(VAR_3);\n                    opj_destroy_codec(VAR_4);\n                    opj_image_destroy(VAR_5);\n                    VAR_15 = 1;\n                    goto fin;\n                }\n            }\n            free(VAR_64);\n        } else {\n            VAR_16 = VAR_16 && opj_encode(VAR_4, VAR_3);\n            if (!VAR_16)  {\n                fprintf(VAR_27, \"failed to encode image: opj_encode\\n\");\n            }\n        }\n        VAR_16 = VAR_16 && opj_end_compress(VAR_4, VAR_3);\n        if (!VAR_16)  {\n            fprintf(VAR_27, \"failed to encode image: opj_end_compress\\n\");\n        }\n\n        if (!VAR_16)  {\n            opj_stream_destroy(VAR_3);\n            opj_destroy_codec(VAR_4);\n            opj_image_destroy(VAR_5);\n            fprintf(VAR_27, \"failed to encode image\\n\");\n            remove(VAR_2.outfile);\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        VAR_7++;\n        fprintf(VAR_26, \"[INFO] Generated outfile %s\\n\", VAR_2.outfile);\n        /* COMMENT_30 */\n        opj_stream_destroy(VAR_3);\n\n        /* COMMENT_31 */\n        opj_destroy_codec(VAR_4);\n\n        /* COMMENT_32 */\n        opj_image_destroy(VAR_5);\n\n    }\n\n    VAR_21 = opj_clock() - VAR_21;\n    if (VAR_7) {\n        fprintf(VAR_26, \"encode time: %d ms \\n\",\n                (int)((VAR_21 * 1000.0) / (OPJ_FLOAT64)VAR_7));\n    }\n\n    VAR_15 = 0;\n\nfin:\n    if (VAR_2.cp_comment) {\n        free(VAR_2.cp_comment);\n    }\n    if (VAR_2.cp_matrice) {\n        free(VAR_2.cp_matrice);\n    }\n    if (VAR_6.rawComps) {\n        free(VAR_6.rawComps);\n    }\n    if (VAR_13.imgdirpath) {\n        free(VAR_13.imgdirpath);\n    }\n    if (VAR_14) {\n        if (VAR_14->filename_buf) {\n            free(VAR_14->filename_buf);\n        }\n        if (VAR_14->filename) {\n            free(VAR_14->filename);\n        }\n        free(VAR_14);\n    }\n    return VAR_15;\n}",
  "func_graph_path_before": "uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_compress.c/vul/before/0.json",
  "func": "int main(int argc, char **argv)\n{\n\n    opj_cparameters_t parameters;   /* compression parameters */\n\n    opj_stream_t *l_stream = 00;\n    opj_codec_t* l_codec = 00;\n    opj_image_t *image = NULL;\n    raw_cparameters_t raw_cp;\n    OPJ_SIZE_T num_compressed_files = 0;\n\n    char indexfilename[OPJ_PATH_LEN];   /* index file name */\n\n    unsigned int i, num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n\n    int ret = 0;\n\n    OPJ_BOOL bSuccess;\n    OPJ_BOOL bUseTiles = OPJ_FALSE; /* OPJ_TRUE */\n    OPJ_UINT32 l_nb_tiles = 4;\n    int framerate = 0;\n    OPJ_FLOAT64 t = opj_clock();\n\n    OPJ_BOOL PLT = OPJ_FALSE;\n    OPJ_BOOL TLM = OPJ_FALSE;\n    int num_threads = 0;\n\n    /** desired bitdepth from input file */\n    unsigned int target_bitdepth = 0;\n\n    /* set encoding parameters to default values */\n    opj_set_default_encoder_parameters(&parameters);\n\n    /* Initialize indexfilename and img_fol */\n    *indexfilename = 0;\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* raw_cp initialization */\n    raw_cp.rawBitDepth = 0;\n    raw_cp.rawComp = 0;\n    raw_cp.rawComps = 0;\n    raw_cp.rawHeight = 0;\n    raw_cp.rawSigned = 0;\n    raw_cp.rawWidth = 0;\n\n    /* parse input and get user encoding parameters */\n    parameters.tcp_mct = (char)\n                         255; /* This will be set later according to the input image or the provided option */\n    if (parse_cmdline_encoder(argc, argv, &parameters, &img_fol, &raw_cp,\n                              indexfilename, sizeof(indexfilename), &framerate, &PLT, &TLM,\n                              &num_threads, &target_bitdepth) == 1) {\n        ret = 1;\n        goto fin;\n    }\n\n    /* Read directory if necessary */\n    if (img_fol.set_imgdir == 1) {\n        num_images = get_num_images(img_fol.imgdirpath);\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (dirptr) {\n            dirptr->filename_buf = (char*)calloc(num_images, OPJ_PATH_LEN * sizeof(\n                    char)); /* Stores at max 10 image file names*/\n            dirptr->filename = (char**) calloc(num_images, sizeof(char*));\n            if (!dirptr->filename_buf) {\n                ret = 0;\n                goto fin;\n            }\n            for (i = 0; i < num_images; i++) {\n                dirptr->filename[i] = dirptr->filename_buf + i * OPJ_PATH_LEN;\n            }\n        }\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            ret = 0;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stdout, \"Folder is empty\\n\");\n            ret = 0;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n    /*Encoding image one by one*/\n    for (imageno = 0; imageno < num_images; imageno++) {\n        image = NULL;\n        fprintf(stderr, \"\\n\");\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file((int)imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        switch (parameters.decod_format) {\n        case PGX_DFMT:\n        case PXM_DFMT:\n        case BMP_DFMT:\n        case TIF_DFMT:\n        case RAW_DFMT:\n        case RAWL_DFMT:\n        case TGA_DFMT:\n        case PNG_DFMT:\n            break;\n        default:\n            fprintf(stderr, \"skipping file...\\n\");\n            continue;\n        }\n\n        /* decode the source image */\n        /* ----------------------- */\n\n        switch (parameters.decod_format) {\n        case PGX_DFMT:\n            image = pgxtoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load pgx file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case PXM_DFMT:\n            image = pnmtoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load pnm file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case BMP_DFMT:\n            image = bmptoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load bmp file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:\n            image = tiftoimage(parameters.infile, &parameters, target_bitdepth);\n            if (!image) {\n                fprintf(stderr, \"Unable to load tif(f) file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n\n        case RAW_DFMT:\n            image = rawtoimage(parameters.infile, &parameters, &raw_cp);\n            if (!image) {\n                fprintf(stderr, \"Unable to load raw or yuv file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case RAWL_DFMT:\n            image = rawltoimage(parameters.infile, &parameters, &raw_cp);\n            if (!image) {\n                fprintf(stderr, \"Unable to load raw file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n        case TGA_DFMT:\n            image = tgatoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load tga file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:\n            image = pngtoimage(parameters.infile, &parameters);\n            if (!image) {\n                fprintf(stderr, \"Unable to load png file\\n\");\n                ret = 1;\n                goto fin;\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        }\n\n        /* Can happen if input file is TIF(F) or PNG\n        * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        if (!image) {\n            fprintf(stderr, \"Unable to load file: got no image\\n\");\n            ret = 1;\n            goto fin;\n        }\n\n        /* Decide if MCT should be used */\n        if (parameters.tcp_mct == (char)\n                255) { /* mct mode has not been set in commandline */\n            parameters.tcp_mct = (image->numcomps >= 3) ? 1 : 0;\n        } else {            /* mct mode has been set in commandline */\n            if ((parameters.tcp_mct == 1) && (image->numcomps < 3)) {\n                fprintf(stderr, \"RGB->YCC conversion cannot be used:\\n\");\n                fprintf(stderr, \"Input image has less than 3 components\\n\");\n                ret = 1;\n                goto fin;\n            }\n            if ((parameters.tcp_mct == 2) && (!parameters.mct_data)) {\n                fprintf(stderr, \"Custom MCT has been set but no array-based MCT\\n\");\n                fprintf(stderr, \"has been provided. Aborting.\\n\");\n                ret = 1;\n                goto fin;\n            }\n        }\n\n        if (OPJ_IS_IMF(parameters.rsiz) && framerate > 0) {\n            const int mainlevel = OPJ_GET_IMF_MAINLEVEL(parameters.rsiz);\n            if (mainlevel > 0 && mainlevel <= OPJ_IMF_MAINLEVEL_MAX) {\n                const int limitMSamplesSec[] = {\n                    0,\n                    OPJ_IMF_MAINLEVEL_1_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_2_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_3_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_4_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_5_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_6_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_7_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_8_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_9_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_10_MSAMPLESEC,\n                    OPJ_IMF_MAINLEVEL_11_MSAMPLESEC\n                };\n                OPJ_UINT32 avgcomponents = image->numcomps;\n                double msamplespersec;\n                if (image->numcomps == 3 &&\n                        image->comps[1].dx == 2 &&\n                        image->comps[1].dy == 2) {\n                    avgcomponents = 2;\n                }\n                msamplespersec = (double)image->x1 * image->y1 * avgcomponents * framerate /\n                                 1e6;\n                if (msamplespersec > limitMSamplesSec[mainlevel]) {\n                    fprintf(stderr,\n                            \"Warning: MSamples/sec is %f, whereas limit is %d.\\n\",\n                            msamplespersec,\n                            limitMSamplesSec[mainlevel]);\n                }\n            }\n        }\n\n        /* encode the destination image */\n        /* ---------------------------- */\n\n        switch (parameters.cod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_compress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_compress(OPJ_CODEC_JP2);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        /* catch events using our callbacks and give a local context */\n        opj_set_info_handler(l_codec, info_callback, 00);\n        opj_set_warning_handler(l_codec, warning_callback, 00);\n        opj_set_error_handler(l_codec, error_callback, 00);\n\n        if (bUseTiles) {\n            parameters.cp_tx0 = 0;\n            parameters.cp_ty0 = 0;\n            parameters.tile_size_on = OPJ_TRUE;\n            parameters.cp_tdx = 512;\n            parameters.cp_tdy = 512;\n        }\n        if (! opj_setup_encoder(l_codec, &parameters, image)) {\n            fprintf(stderr, \"failed to encode image: opj_setup_encoder\\n\");\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            ret = 1;\n            goto fin;\n        }\n\n        if (PLT || TLM) {\n            const char* options[3] = { NULL, NULL, NULL };\n            int iOpt = 0;\n            if (PLT) {\n                options[iOpt++] = \"PLT=YES\";\n            }\n            if (TLM) {\n                options[iOpt++] = \"TLM=YES\";\n            }\n            (void)iOpt;\n            if (!opj_encoder_set_extra_options(l_codec, options)) {\n                fprintf(stderr, \"failed to encode image: opj_encoder_set_extra_options\\n\");\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                ret = 1;\n                goto fin;\n            }\n        }\n\n        if (num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, num_threads)) {\n            fprintf(stderr, \"failed to set number of threads\\n\");\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            ret = 1;\n            goto fin;\n        }\n\n        /* open a byte stream for writing and allocate memory for all tiles */\n        l_stream = opj_stream_create_default_file_stream(parameters.outfile, OPJ_FALSE);\n        if (! l_stream) {\n            ret = 1;\n            goto fin;\n        }\n\n        /* encode the image */\n        bSuccess = opj_start_compress(l_codec, image, l_stream);\n        if (!bSuccess)  {\n            fprintf(stderr, \"failed to encode image: opj_start_compress\\n\");\n        }\n        if (bSuccess && bUseTiles) {\n            OPJ_BYTE *l_data;\n            OPJ_UINT32 l_data_size = 512 * 512 * 3;\n            l_data = (OPJ_BYTE*) calloc(1, l_data_size);\n            if (l_data == NULL) {\n                ret = 1;\n                goto fin;\n            }\n            for (i = 0; i < l_nb_tiles; ++i) {\n                if (! opj_write_tile(l_codec, i, l_data, l_data_size, l_stream)) {\n                    fprintf(stderr, \"ERROR -> test_tile_encoder: failed to write the tile %d!\\n\",\n                            i);\n                    opj_stream_destroy(l_stream);\n                    opj_destroy_codec(l_codec);\n                    opj_image_destroy(image);\n                    ret = 1;\n                    goto fin;\n                }\n            }\n            free(l_data);\n        } else {\n            bSuccess = bSuccess && opj_encode(l_codec, l_stream);\n            if (!bSuccess)  {\n                fprintf(stderr, \"failed to encode image: opj_encode\\n\");\n            }\n        }\n        bSuccess = bSuccess && opj_end_compress(l_codec, l_stream);\n        if (!bSuccess)  {\n            fprintf(stderr, \"failed to encode image: opj_end_compress\\n\");\n        }\n\n        if (!bSuccess)  {\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            fprintf(stderr, \"failed to encode image\\n\");\n            remove(parameters.outfile);\n            ret = 1;\n            goto fin;\n        }\n\n        num_compressed_files++;\n        fprintf(stdout, \"[INFO] Generated outfile %s\\n\", parameters.outfile);\n        /* close and free the byte stream */\n        opj_stream_destroy(l_stream);\n\n        /* free remaining compression structures */\n        opj_destroy_codec(l_codec);\n\n        /* free image data */\n        opj_image_destroy(image);\n\n    }\n\n    t = opj_clock() - t;\n    if (num_compressed_files) {\n        fprintf(stdout, \"encode time: %d ms \\n\",\n                (int)((t * 1000.0) / (OPJ_FLOAT64)num_compressed_files));\n    }\n\n    ret = 0;\n\nfin:\n    if (parameters.cp_comment) {\n        free(parameters.cp_comment);\n    }\n    if (parameters.cp_matrice) {\n        free(parameters.cp_matrice);\n    }\n    if (raw_cp.rawComps) {\n        free(raw_cp.rawComps);\n    }\n    if (img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        free(dirptr);\n    }\n    return ret;\n}",
  "abstract_func": "int main(int VAR_0, char **VAR_1)\n{\n\n    opj_cparameters_t VAR_2;   /* COMMENT_0 */\n\n    opj_stream_t *VAR_3 = 00;\n    opj_codec_t* VAR_4 = 00;\n    opj_image_t *VAR_5 = NULL;\n    raw_cparameters_t VAR_6;\n    OPJ_SIZE_T VAR_7 = 0;\n\n    char VAR_8[VAR_9];   /* COMMENT_1 */\n\n    unsigned int VAR_10, VAR_11, VAR_12;\n    img_fol_t VAR_13;\n    dircnt_t *VAR_14 = NULL;\n\n    int VAR_15 = 0;\n\n    OPJ_BOOL VAR_16;\n    OPJ_BOOL VAR_17 = VAR_18; /* COMMENT_2 */\n    OPJ_UINT32 VAR_19 = 4;\n    int VAR_20 = 0;\n    OPJ_FLOAT64 VAR_21 = opj_clock();\n\n    OPJ_BOOL VAR_22 = VAR_18;\n    OPJ_BOOL VAR_23 = VAR_18;\n    int VAR_24 = 0;\n\n    /* COMMENT_3 */\n    unsigned int VAR_25 = 0;\n\n    /* COMMENT_4 */\n    opj_set_default_encoder_parameters(&VAR_2);\n\n    /* COMMENT_5 */\n    *VAR_8 = 0;\n    memset(&VAR_13, 0, sizeof(img_fol_t));\n\n    /* COMMENT_6 */\n    VAR_6.rawBitDepth = 0;\n    VAR_6.rawComp = 0;\n    VAR_6.rawComps = 0;\n    VAR_6.rawHeight = 0;\n    VAR_6.rawSigned = 0;\n    VAR_6.rawWidth = 0;\n\n    /* COMMENT_7 */\n    VAR_2.tcp_mct = (char)\n                         255; /* COMMENT_8 */\n    if (parse_cmdline_encoder(VAR_0, VAR_1, &VAR_2, &VAR_13, &VAR_6,\n                              VAR_8, sizeof(VAR_8), &VAR_20, &VAR_22, &VAR_23,\n                              &VAR_24, &VAR_25) == 1) {\n        VAR_15 = 1;\n        goto fin;\n    }\n\n    /* COMMENT_9 */\n    if (VAR_13.set_imgdir == 1) {\n        VAR_11 = get_num_images(VAR_13.imgdirpath);\n        VAR_14 = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (VAR_14) {\n            VAR_14->filename_buf = (char*)calloc(VAR_11, VAR_9 * sizeof(\n                    char)); /* COMMENT_10 */\n            VAR_14->filename = (char**) calloc(VAR_11, sizeof(char*));\n            if (!VAR_14->filename_buf) {\n                VAR_15 = 0;\n                goto fin;\n            }\n            for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {\n                VAR_14->filename[VAR_10] = VAR_14->filename_buf + VAR_10 * VAR_9;\n            }\n        }\n        if (load_images(VAR_14, VAR_13.imgdirpath) == 1) {\n            VAR_15 = 0;\n            goto fin;\n        }\n        if (VAR_11 == 0) {\n            fprintf(VAR_26, \"Folder is empty\\n\");\n            VAR_15 = 0;\n            goto fin;\n        }\n    } else {\n        VAR_11 = 1;\n    }\n    /* COMMENT_11 */\n    for (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {\n        VAR_5 = NULL;\n        fprintf(VAR_27, \"\\n\");\n\n        if (VAR_13.set_imgdir == 1) {\n            if (get_next_file((int)VAR_12, VAR_14, &VAR_13, &VAR_2)) {\n                fprintf(VAR_27, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        switch (VAR_2.decod_format) {\n        case VAR_28:\n        case VAR_29:\n        case VAR_30:\n        case VAR_31:\n        case VAR_32:\n        case VAR_33:\n        case VAR_34:\n        case VAR_35:\n            break;\n        default:\n            fprintf(VAR_27, \"skipping file...\\n\");\n            continue;\n        }\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n\n        switch (VAR_2.decod_format) {\n        case VAR_28:\n            VAR_5 = pgxtoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load pgx file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_29:\n            VAR_5 = pnmtoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load pnm file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_30:\n            VAR_5 = bmptoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load bmp file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef VAR_36\n        case VAR_31:\n            VAR_5 = tiftoimage(VAR_2.infile, &VAR_2, VAR_25);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load tif(f) file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n#endif /* COMMENT_14 */\n\n        case VAR_32:\n            VAR_5 = rawtoimage(VAR_2.infile, &VAR_2, &VAR_6);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load raw or yuv file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_33:\n            VAR_5 = rawltoimage(VAR_2.infile, &VAR_2, &VAR_6);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load raw file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n        case VAR_34:\n            VAR_5 = tgatoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load tga file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n\n#ifdef VAR_37\n        case VAR_35:\n            VAR_5 = pngtoimage(VAR_2.infile, &VAR_2);\n            if (!VAR_5) {\n                fprintf(VAR_27, \"Unable to load png file\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            break;\n#endif /* COMMENT_15 */\n        }\n\n        /* COMMENT_16 */\n                                                             \n          \n        if (!VAR_5) {\n            fprintf(VAR_27, \"Unable to load file: got no image\\n\");\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_19 */\n        if (VAR_2.tcp_mct == (char)\n                255) { /* COMMENT_20 */\n            VAR_2.tcp_mct = (VAR_5->numcomps >= 3) ? 1 : 0;\n        } else {            /* COMMENT_21 */\n            if ((VAR_2.tcp_mct == 1) && (VAR_5->numcomps < 3)) {\n                fprintf(VAR_27, \"RGB->YCC conversion cannot be used:\\n\");\n                fprintf(VAR_27, \"Input image has less than 3 components\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n            if ((VAR_2.tcp_mct == 2) && (!VAR_2.mct_data)) {\n                fprintf(VAR_27, \"Custom MCT has been set but no array-based MCT\\n\");\n                fprintf(VAR_27, \"has been provided. Aborting.\\n\");\n                VAR_15 = 1;\n                goto fin;\n            }\n        }\n\n        if (OPJ_IS_IMF(VAR_2.rsiz) && VAR_20 > 0) {\n            const int VAR_38 = OPJ_GET_IMF_MAINLEVEL(VAR_2.rsiz);\n            if (VAR_38 > 0 && VAR_38 <= VAR_39) {\n                const int VAR_40[] = {\n                    0,\n                    VAR_41,\n                    VAR_42,\n                    VAR_43,\n                    VAR_44,\n                    VAR_45,\n                    VAR_46,\n                    VAR_47,\n                    VAR_48,\n                    VAR_49,\n                    VAR_50,\n                    VAR_51\n                };\n                OPJ_UINT32 VAR_52 = VAR_5->numcomps;\n                double VAR_53;\n                if (VAR_5->numcomps == 3 &&\n                        VAR_5->comps[1].dx == 2 &&\n                        VAR_5->comps[1].dy == 2) {\n                    VAR_52 = 2;\n                }\n                VAR_53 = (double)VAR_5->x1 * VAR_5->y1 * VAR_52 * VAR_20 /\n                                 1e6;\n                if (VAR_53 > VAR_40[VAR_38]) {\n                    fprintf(VAR_27,\n                            \"Warning: MSamples/sec is %f, whereas limit is %d.\\n\",\n                            VAR_53,\n                            VAR_40[VAR_38]);\n                }\n            }\n        }\n\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n\n        switch (VAR_2.cod_format) {\n        case VAR_54: { /* COMMENT_24 */\n            /* COMMENT_25 */\n            VAR_4 = opj_create_compress(VAR_55);\n            break;\n        }\n        case VAR_56: { /* COMMENT_26 */\n            /* COMMENT_25 */\n            VAR_4 = opj_create_compress(VAR_57);\n            break;\n        }\n        default:\n            fprintf(VAR_27, \"skipping file..\\n\");\n            opj_stream_destroy(VAR_3);\n            continue;\n        }\n\n        /* COMMENT_27 */\n        opj_set_info_handler(VAR_4, VAR_58, 00);\n        opj_set_warning_handler(VAR_4, VAR_59, 00);\n        opj_set_error_handler(VAR_4, VAR_60, 00);\n\n        if (VAR_17) {\n            VAR_2.cp_tx0 = 0;\n            VAR_2.cp_ty0 = 0;\n            VAR_2.tile_size_on = VAR_61;\n            VAR_2.cp_tdx = 512;\n            VAR_2.cp_tdy = 512;\n        }\n        if (! opj_setup_encoder(VAR_4, &VAR_2, VAR_5)) {\n            fprintf(VAR_27, \"failed to encode image: opj_setup_encoder\\n\");\n            opj_destroy_codec(VAR_4);\n            opj_image_destroy(VAR_5);\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        if (VAR_22 || VAR_23) {\n            const char* VAR_62[3] = { NULL, NULL, NULL };\n            int VAR_63 = 0;\n            if (VAR_22) {\n                VAR_62[VAR_63++] = \"PLT=YES\";\n            }\n            if (VAR_23) {\n                VAR_62[VAR_63++] = \"TLM=YES\";\n            }\n            (void)VAR_63;\n            if (!opj_encoder_set_extra_options(VAR_4, VAR_62)) {\n                fprintf(VAR_27, \"failed to encode image: opj_encoder_set_extra_options\\n\");\n                opj_destroy_codec(VAR_4);\n                opj_image_destroy(VAR_5);\n                VAR_15 = 1;\n                goto fin;\n            }\n        }\n\n        if (VAR_24 >= 1 &&\n                !opj_codec_set_threads(VAR_4, VAR_24)) {\n            fprintf(VAR_27, \"failed to set number of threads\\n\");\n            opj_destroy_codec(VAR_4);\n            opj_image_destroy(VAR_5);\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_28 */\n        VAR_3 = opj_stream_create_default_file_stream(VAR_2.outfile, VAR_18);\n        if (! VAR_3) {\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_29 */\n        VAR_16 = opj_start_compress(VAR_4, VAR_5, VAR_3);\n        if (!VAR_16)  {\n            fprintf(VAR_27, \"failed to encode image: opj_start_compress\\n\");\n        }\n        if (VAR_16 && VAR_17) {\n            OPJ_BYTE *VAR_64;\n            OPJ_UINT32 VAR_65 = 512 * 512 * 3;\n            VAR_64 = (OPJ_BYTE*) calloc(1, VAR_65);\n            if (VAR_64 == NULL) {\n                VAR_15 = 1;\n                goto fin;\n            }\n            for (VAR_10 = 0; VAR_10 < VAR_19; ++VAR_10) {\n                if (! opj_write_tile(VAR_4, VAR_10, VAR_64, VAR_65, VAR_3)) {\n                    fprintf(VAR_27, \"ERROR -> test_tile_encoder: failed to write the tile %d!\\n\",\n                            VAR_10);\n                    opj_stream_destroy(VAR_3);\n                    opj_destroy_codec(VAR_4);\n                    opj_image_destroy(VAR_5);\n                    VAR_15 = 1;\n                    goto fin;\n                }\n            }\n            free(VAR_64);\n        } else {\n            VAR_16 = VAR_16 && opj_encode(VAR_4, VAR_3);\n            if (!VAR_16)  {\n                fprintf(VAR_27, \"failed to encode image: opj_encode\\n\");\n            }\n        }\n        VAR_16 = VAR_16 && opj_end_compress(VAR_4, VAR_3);\n        if (!VAR_16)  {\n            fprintf(VAR_27, \"failed to encode image: opj_end_compress\\n\");\n        }\n\n        if (!VAR_16)  {\n            opj_stream_destroy(VAR_3);\n            opj_destroy_codec(VAR_4);\n            opj_image_destroy(VAR_5);\n            fprintf(VAR_27, \"failed to encode image\\n\");\n            remove(VAR_2.outfile);\n            VAR_15 = 1;\n            goto fin;\n        }\n\n        VAR_7++;\n        fprintf(VAR_26, \"[INFO] Generated outfile %s\\n\", VAR_2.outfile);\n        /* COMMENT_30 */\n        opj_stream_destroy(VAR_3);\n\n        /* COMMENT_31 */\n        opj_destroy_codec(VAR_4);\n\n        /* COMMENT_32 */\n        opj_image_destroy(VAR_5);\n\n    }\n\n    VAR_21 = opj_clock() - VAR_21;\n    if (VAR_7) {\n        fprintf(VAR_26, \"encode time: %d ms \\n\",\n                (int)((VAR_21 * 1000.0) / (OPJ_FLOAT64)VAR_7));\n    }\n\n    VAR_15 = 0;\n\nfin:\n    if (VAR_2.cp_comment) {\n        free(VAR_2.cp_comment);\n    }\n    if (VAR_2.cp_matrice) {\n        free(VAR_2.cp_matrice);\n    }\n    if (VAR_6.rawComps) {\n        free(VAR_6.rawComps);\n    }\n    if (VAR_13.imgdirpath) {\n        free(VAR_13.imgdirpath);\n    }\n    if (VAR_14) {\n        if (VAR_14->filename_buf) {\n            free(VAR_14->filename_buf);\n        }\n        if (VAR_14->filename) {\n            free(VAR_14->filename);\n        }\n        free(VAR_14);\n    }\n    return VAR_15;\n}",
  "func_graph_path": "uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_compress.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -60,9 +60,9 @@\n         num_images = get_num_images(img_fol.imgdirpath);\n         dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n         if (dirptr) {\n-            dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(\n+            dirptr->filename_buf = (char*)calloc(num_images, OPJ_PATH_LEN * sizeof(\n                     char)); /* Stores at max 10 image file names*/\n-            dirptr->filename = (char**) malloc(num_images * sizeof(char*));\n+            dirptr->filename = (char**) calloc(num_images, sizeof(char*));\n             if (!dirptr->filename_buf) {\n                 ret = 0;\n                 goto fin;",
  "diff_line_info": {
    "deleted_lines": [
      "            dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(",
      "            dirptr->filename = (char**) malloc(num_images * sizeof(char*));"
    ],
    "added_lines": [
      "            dirptr->filename_buf = (char*)calloc(num_images, OPJ_PATH_LEN * sizeof(",
      "            dirptr->filename = (char**) calloc(num_images, sizeof(char*));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1395",
  "description": {
    "pr_info": {
      "title": "Fix integer overflow in num_images",
      "number": 1395
    },
    "comment": [
      "Includes the fix for CVE-2021-29338\r\nCredit to @kaniini based on #1346\r\nFixes #1338",
      "It's not clear to me if the `OPJ_PATH_LEN * 2` changes from #1346 are also necessary since f0629cb was merged into master. Can you help confirm @rouault ?",
      "> It's not clear to me if the `OPJ_PATH_LEN * 2` changes from #1346 are also necessary since [f0629cb](https://github.com/uclouvain/openjpeg/commit/f0629cb1c4c485d905936413556deb2872ac51e5) was merged into master. Can you help confirm @rouault ?\r\n\r\nI don't think they are necessary since we have other checks that should prevent buffer overflow",
      "Thanks for taking care of this @baparham!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}