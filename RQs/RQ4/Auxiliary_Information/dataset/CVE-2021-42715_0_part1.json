{
  "cve_id": "CVE-2021-42715",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "nothings/stb",
  "commit_msg": "Fixes two stb_image issues that could occur with specially constructed HDR and PGM files.\n\nSigned-off-by: Neil Bickford <nbickford@nvidia.com>",
  "commit_hash": "2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6",
  "git_url": "https://github.com/nothings/stb/commit/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6",
  "file_path": "stb_image.h",
  "func_name": "stbi__pnm_load",
  "func_before": "static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));\n\n   if (req_comp && req_comp != s->img_n) {\n      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}",
  "abstract_func_before": "static void *stbi__pnm_load(stbi__context *VAR_0, int *VAR_1, int *VAR_2, int *VAR_3, int VAR_4, stbi__result_info *VAR_5)\n{\n   stbi_uc *VAR_6;\n   STBI_NOTUSED(VAR_5);\n\n   VAR_5->bits_per_channel = stbi__pnm_info(VAR_0, (int *)&VAR_0->img_x, (int *)&VAR_0->img_y, (int *)&VAR_0->img_n);\n   if (VAR_5->bits_per_channel == 0)\n      return 0;\n\n   if (VAR_0->img_y > VAR_7) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (VAR_0->img_x > VAR_7) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *VAR_1 = VAR_0->img_x;\n   *VAR_2 = VAR_0->img_y;\n   if (VAR_3) *VAR_3 = VAR_0->img_n;\n\n   if (!stbi__mad4sizes_valid(VAR_0->img_n, VAR_0->img_x, VAR_0->img_y, VAR_5->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   VAR_6 = (stbi_uc *) stbi__malloc_mad4(VAR_0->img_n, VAR_0->img_x, VAR_0->img_y, VAR_5->bits_per_channel / 8, 0);\n   if (!VAR_6) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   stbi__getn(VAR_0, VAR_6, VAR_0->img_n * VAR_0->img_x * VAR_0->img_y * (VAR_5->bits_per_channel / 8));\n\n   if (VAR_4 && VAR_4 != VAR_0->img_n) {\n      VAR_6 = stbi__convert_format(VAR_6, VAR_0->img_n, VAR_4, VAR_0->img_x, VAR_0->img_y);\n      if (VAR_6 == NULL) return VAR_6; /* COMMENT_0 */\n   }\n   return VAR_6;\n}",
  "func_graph_path_before": "nothings/stb/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6/stb_image.h/vul/before/1.json",
  "func": "static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {\n      STBI_FREE(out);\n      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");\n   }\n\n   if (req_comp && req_comp != s->img_n) {\n      if (ri->bits_per_channel == 16) {\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);\n      } else {\n         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      }\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}",
  "abstract_func": "static void *stbi__pnm_load(stbi__context *VAR_0, int *VAR_1, int *VAR_2, int *VAR_3, int VAR_4, stbi__result_info *VAR_5)\n{\n   stbi_uc *VAR_6;\n   STBI_NOTUSED(VAR_5);\n\n   VAR_5->bits_per_channel = stbi__pnm_info(VAR_0, (int *)&VAR_0->img_x, (int *)&VAR_0->img_y, (int *)&VAR_0->img_n);\n   if (VAR_5->bits_per_channel == 0)\n      return 0;\n\n   if (VAR_0->img_y > VAR_7) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (VAR_0->img_x > VAR_7) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *VAR_1 = VAR_0->img_x;\n   *VAR_2 = VAR_0->img_y;\n   if (VAR_3) *VAR_3 = VAR_0->img_n;\n\n   if (!stbi__mad4sizes_valid(VAR_0->img_n, VAR_0->img_x, VAR_0->img_y, VAR_5->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   VAR_6 = (stbi_uc *) stbi__malloc_mad4(VAR_0->img_n, VAR_0->img_x, VAR_0->img_y, VAR_5->bits_per_channel / 8, 0);\n   if (!VAR_6) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (!stbi__getn(VAR_0, VAR_6, VAR_0->img_n * VAR_0->img_x * VAR_0->img_y * (VAR_5->bits_per_channel / 8))) {\n      STBI_FREE(VAR_6);\n      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");\n   }\n\n   if (VAR_4 && VAR_4 != VAR_0->img_n) {\n      if (VAR_5->bits_per_channel == 16) {\n         VAR_6 = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) VAR_6, VAR_0->img_n, VAR_4, VAR_0->img_x, VAR_0->img_y);\n      } else {\n         VAR_6 = stbi__convert_format(VAR_6, VAR_0->img_n, VAR_4, VAR_0->img_x, VAR_0->img_y);\n      }\n      if (VAR_6 == NULL) return VAR_6; /* COMMENT_0 */\n   }\n   return VAR_6;\n}",
  "func_graph_path": "nothings/stb/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6/stb_image.h/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,10 +19,17 @@\n \n    out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n    if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n-   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));\n+   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {\n+      STBI_FREE(out);\n+      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");\n+   }\n \n    if (req_comp && req_comp != s->img_n) {\n-      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n+      if (ri->bits_per_channel == 16) {\n+         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);\n+      } else {\n+         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n+      }\n       if (out == NULL) return out; // stbi__convert_format frees input on failure\n    }\n    return out;",
  "diff_line_info": {
    "deleted_lines": [
      "   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));",
      "      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);"
    ],
    "added_lines": [
      "   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {",
      "      STBI_FREE(out);",
      "      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");",
      "   }",
      "      if (ri->bits_per_channel == 16) {",
      "         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);",
      "      } else {",
      "         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);",
      "      }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nothings/stb/pull/1223",
  "description": {
    "pr_info": {
      "title": "Fixes a crash and an infinite loop in stb_image that could occur with specially constructed PGM and HDR files",
      "number": 1223
    },
    "comment": [
      "Fixes two availability issues in stb_image that could occur with specially\r\nconstructed HDR and PGM files. Please see issues #1224 and #1225 for full descriptions.\r\n\r\nHDR: In certain conditions, the RLE decoder can get stuck in the decoding loop\r\nat the end of a stream: `stbi__get8()` always returns 0 when at the end of a\r\nstream, which is interpreted as a count and results in an infinite loop.\r\nI believe the solution is to treat a run of 0 as invalid, following the\r\n`RGBE_ReadPixels_RLE()` function in Bruce Walter's\r\n[https://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c](https://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c).\r\n\r\nPGM: Loading large monochrome 16-bit PGM files would cause an access violation\r\ndue to reading out of bounds when comverting from 16-bit to 8-bit. In addition,\r\nwhen loading 16-bit PGM files, `stbi__pnm_load()` would call\r\n`stbi__convert_format()` instead of `stbi__convert_format16()` to convert from\r\nmonochrome to the required number of channels, so the buffer would be\r\ninterpreted as the wrong type. This pull request also adds an error nessage for\r\nwhen the `stbi__getn()` call fails.\r\n\r\nThanks!",
      "Following up on this - is there anything I can change to help merge this in? Thanks!",
      "stb repository is just slow for me to update",
      "Quick note from the survey of the first 10 ossfuzz issues I did: I think this pull request might resolve ossfuzz issues https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37628&q=proj%3Dstb&can=2 (this seems to be the infinite HDR reader error) and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=38394&q=proj%3Dstb&can=2 (I think this is due to the PGM issue). I'm unable to reproduce ossfuzz's crashes with these fixes on Windows with Address Sanitizer enabled.",
      "Merged into dev branch, will be in the next release.",
      "Thanks so much ryg!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.9"
}