{
  "cve_id": "CVE-2023-25933",
  "cwe_ids": [
    "CWE-416",
    "CWE-843"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#960)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "e6ed9c1a4b02dc219de1648f44cd808a56171b81",
  "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
  "file_path": "lib/Optimizer/Scalar/TypeInference.cpp",
  "func_name": "inferUnaryArith",
  "func_before": "static bool inferUnaryArith(UnaryOperatorInst *UOI, Type numberResultType) {\n  Value *op = UOI->getSingleOperand();\n\n  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt =\n      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
  "abstract_func_before": "static bool inferUnaryArith(UnaryOperatorInst *VAR_0, Type VAR_1) {\n  Value *VAR_2 = VAR_0->getSingleOperand();\n\n  if (VAR_2->getType().isNumberType()) {\n    VAR_0->setType(VAR_1);\n    return true;\n  }\n\n  if (VAR_2->getType().isBigIntType()) {\n    VAR_0->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type VAR_3 =\n      VAR_2->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n\n  /* COMMENT_0 */\n  VAR_0->setType(Type::unionTy(VAR_1, VAR_3));\n  return true;\n}",
  "func_graph_path_before": "facebook/hermes/e6ed9c1a4b02dc219de1648f44cd808a56171b81/TypeInference.cpp/vul/before/1.json",
  "func": "static bool inferUnaryArith(UnaryOperatorInst *UOI, Type numberResultType) {\n  Value *op = UOI->getSingleOperand();\n\n  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n                                                     : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n  // BigInt|Object.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
  "abstract_func": "static bool inferUnaryArith(UnaryOperatorInst *VAR_0, Type VAR_1) {\n  Value *VAR_2 = VAR_0->getSingleOperand();\n\n  if (VAR_2->getType().isNumberType()) {\n    VAR_0->setType(VAR_1);\n    return true;\n  }\n\n  if (VAR_2->getType().isBigIntType()) {\n    VAR_0->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type VAR_3 = isBigIntOrObject(VAR_2->getType()) ? Type::createBigInt()\n                                                     : Type::createNoType();\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_0->setType(Type::unionTy(VAR_1, VAR_3));\n  return true;\n}",
  "func_graph_path": "facebook/hermes/e6ed9c1a4b02dc219de1648f44cd808a56171b81/TypeInference.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,10 +11,11 @@\n     return true;\n   }\n \n-  Type mayBeBigInt =\n-      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n+  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n+                                                     : Type::createNoType();\n \n-  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt.\n+  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n+  // BigInt|Object.\n   UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n   return true;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  Type mayBeBigInt =",
      "      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();",
      "  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt."
    ],
    "added_lines": [
      "  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()",
      "                                                     : Type::createNoType();",
      "  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is",
      "  // BigInt|Object."
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/960",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/hermes/pull/960: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/hermes/pulls/960",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8  \nThe code change modifies type inference logic to handle BigInt correctly, which is a core functionality improvement. No security terms orCVE mentions suggest it's a security fix.\n\n**Final Output:**  \n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8"
}