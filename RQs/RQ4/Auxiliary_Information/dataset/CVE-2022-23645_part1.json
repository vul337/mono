{
  "cve_id": "CVE-2022-23645",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "stefanberger/swtpm",
  "commit_msg": "swtpm: Check header size indicator against expected size (CID 375869)\n\nThis fix addresses Coverity issue CID 375869.\n\nCheck the header size indicated in the header of the state against the\nexpected size and return an error code in case the header size indicator\nis different. There was only one header size so far since blobheader was\nintroduced, so we don't need to deal with different sizes.\n\nWithout this fix a specially craft header could have cause out-of-bounds\naccesses on the byte array containing the swtpm's state.\n\nSigned-off-by: Stefan Berger <stefanb@linux.ibm.com>",
  "commit_hash": "9f740868fc36761de27df3935513bdebf8852d19",
  "git_url": "https://github.com/stefanberger/swtpm/commit/9f740868fc36761de27df3935513bdebf8852d19",
  "file_path": "src/swtpm/swtpm_nvstore.c",
  "func_name": "SWTPM_NVRAM_CheckHeader",
  "func_before": "static TPM_RESULT\nSWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}",
  "abstract_func_before": "static TPM_RESULT\nSWTPM_NVRAM_CheckHeader(unsigned char *VAR_0, uint32_t VAR_1,\n                        uint32_t *VAR_2, uint16_t *VAR_3,\n                        uint8_t *VAR_4, bool VAR_5)\n{\n    blobheader *VAR_6 = (blobheader *)VAR_0;\n\n    if (VAR_1 < sizeof(VAR_6)) {\n        if (!VAR_5)\n            logprintf(VAR_7,\n                      \"not enough bytes for header: %u\\n\", VAR_1);\n        return VAR_8;\n    }\n\n    if (ntohl(VAR_6->totlen) != VAR_1) {\n        if (!VAR_5)\n            logprintf(VAR_7,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(VAR_6->totlen), VAR_1);\n        return VAR_8;\n    }\n\n    if (VAR_6->min_version > VAR_9) {\n        if (!VAR_5)\n            logprintf(VAR_7,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", VAR_6->min_version,\n                      VAR_9);\n        return VAR_10;\n    }\n\n    *VAR_4 = VAR_6->version;\n    *VAR_2 = ntohs(VAR_6->hdrsize);\n    *VAR_3 = ntohs(VAR_6->flags);\n\n    return VAR_11;\n}",
  "func_graph_path_before": "stefanberger/swtpm/9f740868fc36761de27df3935513bdebf8852d19/swtpm_nvstore.c/vul/before/0.json",
  "func": "static TPM_RESULT\nSWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    uint16_t hdrsize;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    hdrsize = ntohs(bh->hdrsize);\n    if (hdrsize != sizeof(blobheader)) {\n        logprintf(STDERR_FILENO,\n                  \"bad header size: %u != %zu\\n\",\n                  hdrsize, sizeof(blobheader));\n        return TPM_BAD_DATASIZE;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = hdrsize;\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}",
  "abstract_func": "static TPM_RESULT\nSWTPM_NVRAM_CheckHeader(unsigned char *VAR_0, uint32_t VAR_1,\n                        uint32_t *VAR_2, uint16_t *VAR_3,\n                        uint8_t *VAR_4, bool VAR_5)\n{\n    blobheader *VAR_6 = (blobheader *)VAR_0;\n    uint16_t VAR_7;\n\n    if (VAR_1 < sizeof(VAR_6)) {\n        if (!VAR_5)\n            logprintf(VAR_8,\n                      \"not enough bytes for header: %u\\n\", VAR_1);\n        return VAR_9;\n    }\n\n    if (ntohl(VAR_6->totlen) != VAR_1) {\n        if (!VAR_5)\n            logprintf(VAR_8,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(VAR_6->totlen), VAR_1);\n        return VAR_9;\n    }\n\n    if (VAR_6->min_version > VAR_10) {\n        if (!VAR_5)\n            logprintf(VAR_8,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", VAR_6->min_version,\n                      VAR_10);\n        return VAR_11;\n    }\n\n    VAR_7 = ntohs(VAR_6->hdrsize);\n    if (VAR_7 != sizeof(blobheader)) {\n        logprintf(VAR_8,\n                  \"bad header size: %u != %zu\\n\",\n                  VAR_7, sizeof(blobheader));\n        return VAR_12;\n    }\n\n    *VAR_4 = VAR_6->version;\n    *VAR_2 = VAR_7;\n    *VAR_3 = ntohs(VAR_6->flags);\n\n    return VAR_13;\n}",
  "func_graph_path": "stefanberger/swtpm/9f740868fc36761de27df3935513bdebf8852d19/swtpm_nvstore.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n                         uint8_t *hdrversion, bool quiet)\n {\n     blobheader *bh = (blobheader *)data;\n+    uint16_t hdrsize;\n \n     if (length < sizeof(bh)) {\n         if (!quiet)\n@@ -29,8 +30,16 @@\n         return TPM_BAD_VERSION;\n     }\n \n+    hdrsize = ntohs(bh->hdrsize);\n+    if (hdrsize != sizeof(blobheader)) {\n+        logprintf(STDERR_FILENO,\n+                  \"bad header size: %u != %zu\\n\",\n+                  hdrsize, sizeof(blobheader));\n+        return TPM_BAD_DATASIZE;\n+    }\n+\n     *hdrversion = bh->version;\n-    *dataoffset = ntohs(bh->hdrsize);\n+    *dataoffset = hdrsize;\n     *hdrflags = ntohs(bh->flags);\n \n     return TPM_SUCCESS;",
  "diff_line_info": {
    "deleted_lines": [
      "    *dataoffset = ntohs(bh->hdrsize);"
    ],
    "added_lines": [
      "    uint16_t hdrsize;",
      "    hdrsize = ntohs(bh->hdrsize);",
      "    if (hdrsize != sizeof(blobheader)) {",
      "        logprintf(STDERR_FILENO,",
      "                  \"bad header size: %u != %zu\\n\",",
      "                  hdrsize, sizeof(blobheader));",
      "        return TPM_BAD_DATASIZE;",
      "    }",
      "",
      "    *dataoffset = hdrsize;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/stefanberger/swtpm/pull/649",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/stefanberger/swtpm/pull/649: 403 Client Error: Forbidden for url: https://api.github.com/repos/stefanberger/swtpm/pulls/649",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}