{
  "cve_id": "CVE-2019-19624",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "opencv",
  "commit_msg": "video:fixed DISOpticalFlow segfault from small img",
  "commit_hash": "d1615ba11a93062b1429fce9f0f638d1572d3418",
  "git_url": "https://github.com/opencv/opencv/commit/d1615ba11a93062b1429fce9f0f638d1572d3418",
  "file_path": "modules/video/src/dis_flow.cpp",
  "func_name": "DISOpticalFlowImpl::calc",
  "func_before": "void DISOpticalFlowImpl::calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    CV_Assert(!I0.empty() && I0.depth() == CV_8U && I0.channels() == 1);\n    CV_Assert(!I1.empty() && I1.depth() == CV_8U && I1.channels() == 1);\n    CV_Assert(I0.sameSize(I1));\n    CV_Assert(I0.isContinuous());\n    CV_Assert(I1.isContinuous());\n\n    CV_OCL_RUN(flow.isUMat() &&\n               (patch_size == 8) && (use_spatial_propagation == true),\n               ocl_calc(I0, I1, flow));\n\n    Mat I0Mat = I0.getMat();\n    Mat I1Mat = I1.getMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    Mat flowMat = flow.getMat();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n                         (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n    int num_stripes = getNumThreads();\n\n    prepareBuffers(I0Mat, I1Mat, flowMat, use_input_flow);\n    Ux[coarsest_scale].setTo(0.0f);\n    Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i >= finest_scale; i--)\n    {\n        w = I0s[i].cols;\n        h = I0s[i].rows;\n        ws = 1 + (w - patch_size) / patch_stride;\n        hs = 1 + (h - patch_size) / patch_stride;\n\n        precomputeStructureTensor(I0xx_buf, I0yy_buf, I0xy_buf, I0x_buf, I0y_buf, I0xs[i], I0ys[i]);\n        if (use_spatial_propagation)\n        {\n            /* Use a fixed number of stripes regardless the number of threads to make inverse search\n             * with spatial propagation reproducible\n             */\n            parallel_for_(Range(0, 8), PatchInverseSearch_ParBody(*this, 8, hs, Sx, Sy, Ux[i], Uy[i], I0s[i],\n                                                                  I1s_ext[i], I0xs[i], I0ys[i], 2, i));\n        }\n        else\n        {\n            parallel_for_(Range(0, num_stripes),\n                          PatchInverseSearch_ParBody(*this, num_stripes, hs, Sx, Sy, Ux[i], Uy[i], I0s[i], I1s_ext[i],\n                                                     I0xs[i], I0ys[i], 1, i));\n        }\n\n        parallel_for_(Range(0, num_stripes),\n                      Densification_ParBody(*this, num_stripes, I0s[i].rows, Ux[i], Uy[i], Sx, Sy, I0s[i], I1s[i]));\n        if (variational_refinement_iter > 0)\n            variational_refinement_processors[i]->calcUV(I0s[i], I1s[i], Ux[i], Uy[i]);\n\n        if (i > finest_scale)\n        {\n            resize(Ux[i], Ux[i - 1], Ux[i - 1].size());\n            resize(Uy[i], Uy[i - 1], Uy[i - 1].size());\n            Ux[i - 1] *= 2;\n            Uy[i - 1] *= 2;\n        }\n    }\n    Mat uxy[] = {Ux[finest_scale], Uy[finest_scale]};\n    merge(uxy, 2, U);\n    resize(U, flowMat, flowMat.size());\n    flowMat *= 1 << finest_scale;\n}",
  "abstract_func_before": "void DISOpticalFlowImpl::calc(InputArray VAR_0, InputArray VAR_1, InputOutputArray VAR_2)\n{\n    CV_Assert(!VAR_0.empty() && VAR_0.depth() == VAR_3 && VAR_0.channels() == 1);\n    CV_Assert(!VAR_1.empty() && VAR_1.depth() == VAR_3 && VAR_1.channels() == 1);\n    CV_Assert(VAR_0.sameSize(VAR_1));\n    CV_Assert(VAR_0.isContinuous());\n    CV_Assert(VAR_1.isContinuous());\n\n    CV_OCL_RUN(VAR_2.isUMat() &&\n               (VAR_4 == 8) && (VAR_5 == true),\n               ocl_calc(VAR_0, VAR_1, VAR_2));\n\n    Mat VAR_6 = VAR_0.getMat();\n    Mat VAR_7 = VAR_1.getMat();\n    bool VAR_8 = false;\n    if (VAR_2.sameSize(VAR_0) && VAR_2.depth() == VAR_9 && VAR_2.channels() == 2)\n        VAR_8 = true;\n    else\n        VAR_2.create(VAR_7.size(), VAR_10);\n    Mat VAR_11 = VAR_2.getMat();\n    VAR_12 = min((int)(log(max(VAR_6.cols, VAR_6.rows) / (4.0 * VAR_4)) / log(2.0) + 0.5), /* COMMENT_0 */\n                         (int)(log(min(VAR_6.cols, VAR_6.rows) / VAR_4) / log(2.0)));              /* COMMENT_1 */\n    int VAR_13 = getNumThreads();\n\n    prepareBuffers(VAR_6, VAR_7, VAR_11, VAR_8);\n    VAR_14[VAR_12].setTo(0.0f);\n    VAR_15[VAR_12].setTo(0.0f);\n\n    for (int VAR_16 = VAR_12; VAR_16 >= VAR_17; VAR_16--)\n    {\n        VAR_18 = VAR_19[VAR_16].cols;\n        VAR_20 = VAR_19[VAR_16].rows;\n        VAR_21 = 1 + (VAR_18 - VAR_4) / VAR_22;\n        VAR_23 = 1 + (VAR_20 - VAR_4) / VAR_22;\n\n        precomputeStructureTensor(VAR_24, VAR_25, VAR_26, VAR_27, VAR_28, VAR_29[VAR_16], VAR_30[VAR_16]);\n        if (VAR_5)\n        {\n            /* COMMENT_2 */\n                                                    \n               \n            parallel_for_(Range(0, 8), PatchInverseSearch_ParBody(*this, 8, VAR_23, VAR_31, VAR_32, VAR_14[VAR_16], VAR_15[VAR_16], VAR_19[VAR_16],\n                                                                  VAR_33[VAR_16], VAR_29[VAR_16], VAR_30[VAR_16], 2, VAR_16));\n        }\n        else\n        {\n            parallel_for_(Range(0, VAR_13),\n                          PatchInverseSearch_ParBody(*this, VAR_13, VAR_23, VAR_31, VAR_32, VAR_14[VAR_16], VAR_15[VAR_16], VAR_19[VAR_16], VAR_33[VAR_16],\n                                                     VAR_29[VAR_16], VAR_30[VAR_16], 1, VAR_16));\n        }\n\n        parallel_for_(Range(0, VAR_13),\n                      Densification_ParBody(*this, VAR_13, VAR_19[VAR_16].rows, VAR_14[VAR_16], VAR_15[VAR_16], VAR_31, VAR_32, VAR_19[VAR_16], VAR_34[VAR_16]));\n        if (VAR_35 > 0)\n            VAR_36[VAR_16]->calcUV(VAR_19[VAR_16], VAR_34[VAR_16], VAR_14[VAR_16], VAR_15[VAR_16]);\n\n        if (VAR_16 > VAR_17)\n        {\n            resize(VAR_14[VAR_16], VAR_14[VAR_16 - 1], VAR_14[VAR_16 - 1].size());\n            resize(VAR_15[VAR_16], VAR_15[VAR_16 - 1], VAR_15[VAR_16 - 1].size());\n            VAR_14[VAR_16 - 1] *= 2;\n            VAR_15[VAR_16 - 1] *= 2;\n        }\n    }\n    Mat VAR_37[] = {VAR_14[VAR_17], VAR_15[VAR_17]};\n    merge(VAR_37, 2, VAR_38);\n    resize(VAR_38, VAR_11, VAR_11.size());\n    VAR_11 *= 1 << VAR_17;\n}",
  "func_graph_path_before": "opencv/d1615ba11a93062b1429fce9f0f638d1572d3418/dis_flow.cpp/vul/before/0.json",
  "func": "void DISOpticalFlowImpl::calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    CV_Assert(!I0.empty() && I0.depth() == CV_8U && I0.channels() == 1);\n    CV_Assert(!I1.empty() && I1.depth() == CV_8U && I1.channels() == 1);\n    CV_Assert(I0.sameSize(I1));\n    CV_Assert(I0.isContinuous());\n    CV_Assert(I1.isContinuous());\n\n    CV_OCL_RUN(flow.isUMat() &&\n               (patch_size == 8) && (use_spatial_propagation == true),\n               ocl_calc(I0, I1, flow));\n\n    Mat I0Mat = I0.getMat();\n    Mat I1Mat = I1.getMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    Mat flowMat = flow.getMat();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */\n                         (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n\n    if (coarsest_scale<0)\n        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n\n    if (coarsest_scale<finest_scale)\n    {\n        // choose the finest level based on coarsest level.\n        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239\n        int original_img_width = I0.size().width;\n        autoSelectPatchSizeAndScales(original_img_width);\n    }\n\n    int num_stripes = getNumThreads();\n\n    prepareBuffers(I0Mat, I1Mat, flowMat, use_input_flow);\n    Ux[coarsest_scale].setTo(0.0f);\n    Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i >= finest_scale; i--)\n    {\n        w = I0s[i].cols;\n        h = I0s[i].rows;\n        ws = 1 + (w - patch_size) / patch_stride;\n        hs = 1 + (h - patch_size) / patch_stride;\n\n        precomputeStructureTensor(I0xx_buf, I0yy_buf, I0xy_buf, I0x_buf, I0y_buf, I0xs[i], I0ys[i]);\n        if (use_spatial_propagation)\n        {\n            /* Use a fixed number of stripes regardless the number of threads to make inverse search\n             * with spatial propagation reproducible\n             */\n            parallel_for_(Range(0, 8), PatchInverseSearch_ParBody(*this, 8, hs, Sx, Sy, Ux[i], Uy[i], I0s[i],\n                                                                  I1s_ext[i], I0xs[i], I0ys[i], 2, i));\n        }\n        else\n        {\n            parallel_for_(Range(0, num_stripes),\n                          PatchInverseSearch_ParBody(*this, num_stripes, hs, Sx, Sy, Ux[i], Uy[i], I0s[i], I1s_ext[i],\n                                                     I0xs[i], I0ys[i], 1, i));\n        }\n\n        parallel_for_(Range(0, num_stripes),\n                      Densification_ParBody(*this, num_stripes, I0s[i].rows, Ux[i], Uy[i], Sx, Sy, I0s[i], I1s[i]));\n        if (variational_refinement_iter > 0)\n            variational_refinement_processors[i]->calcUV(I0s[i], I1s[i], Ux[i], Uy[i]);\n\n        if (i > finest_scale)\n        {\n            resize(Ux[i], Ux[i - 1], Ux[i - 1].size());\n            resize(Uy[i], Uy[i - 1], Uy[i - 1].size());\n            Ux[i - 1] *= 2;\n            Uy[i - 1] *= 2;\n        }\n    }\n    Mat uxy[] = {Ux[finest_scale], Uy[finest_scale]};\n    merge(uxy, 2, U);\n    resize(U, flowMat, flowMat.size());\n    flowMat *= 1 << finest_scale;\n}",
  "abstract_func": "void DISOpticalFlowImpl::calc(InputArray VAR_0, InputArray VAR_1, InputOutputArray VAR_2)\n{\n    CV_Assert(!VAR_0.empty() && VAR_0.depth() == VAR_3 && VAR_0.channels() == 1);\n    CV_Assert(!VAR_1.empty() && VAR_1.depth() == VAR_3 && VAR_1.channels() == 1);\n    CV_Assert(VAR_0.sameSize(VAR_1));\n    CV_Assert(VAR_0.isContinuous());\n    CV_Assert(VAR_1.isContinuous());\n\n    CV_OCL_RUN(VAR_2.isUMat() &&\n               (VAR_4 == 8) && (VAR_5 == true),\n               ocl_calc(VAR_0, VAR_1, VAR_2));\n\n    Mat VAR_6 = VAR_0.getMat();\n    Mat VAR_7 = VAR_1.getMat();\n    bool VAR_8 = false;\n    if (VAR_2.sameSize(VAR_0) && VAR_2.depth() == VAR_9 && VAR_2.channels() == 2)\n        VAR_8 = true;\n    else\n        VAR_2.create(VAR_7.size(), VAR_10);\n    Mat VAR_11 = VAR_2.getMat();\n    VAR_12 = min((int)(log(max(VAR_6.cols, VAR_6.rows) / (4.0 * VAR_4)) / log(2.0) + 0.5), /* COMMENT_0 */\n                         (int)(log(min(VAR_6.cols, VAR_6.rows) / VAR_4) / log(2.0)));              /* COMMENT_1 */\n\n    if (VAR_12<0)\n        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n\n    if (VAR_12<VAR_13)\n    {\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        int VAR_14 = VAR_0.size().width;\n        autoSelectPatchSizeAndScales(VAR_14);\n    }\n\n    int VAR_15 = getNumThreads();\n\n    prepareBuffers(VAR_6, VAR_7, VAR_11, VAR_8);\n    VAR_16[VAR_12].setTo(0.0f);\n    VAR_17[VAR_12].setTo(0.0f);\n\n    for (int VAR_18 = VAR_12; VAR_18 >= VAR_13; VAR_18--)\n    {\n        VAR_19 = VAR_20[VAR_18].cols;\n        VAR_21 = VAR_20[VAR_18].rows;\n        VAR_22 = 1 + (VAR_19 - VAR_4) / VAR_23;\n        VAR_24 = 1 + (VAR_21 - VAR_4) / VAR_23;\n\n        precomputeStructureTensor(VAR_25, VAR_26, VAR_27, VAR_28, VAR_29, VAR_30[VAR_18], VAR_31[VAR_18]);\n        if (VAR_5)\n        {\n            /* COMMENT_4 */\n                                                    \n               \n            parallel_for_(Range(0, 8), PatchInverseSearch_ParBody(*this, 8, VAR_24, VAR_32, VAR_33, VAR_16[VAR_18], VAR_17[VAR_18], VAR_20[VAR_18],\n                                                                  VAR_34[VAR_18], VAR_30[VAR_18], VAR_31[VAR_18], 2, VAR_18));\n        }\n        else\n        {\n            parallel_for_(Range(0, VAR_15),\n                          PatchInverseSearch_ParBody(*this, VAR_15, VAR_24, VAR_32, VAR_33, VAR_16[VAR_18], VAR_17[VAR_18], VAR_20[VAR_18], VAR_34[VAR_18],\n                                                     VAR_30[VAR_18], VAR_31[VAR_18], 1, VAR_18));\n        }\n\n        parallel_for_(Range(0, VAR_15),\n                      Densification_ParBody(*this, VAR_15, VAR_20[VAR_18].rows, VAR_16[VAR_18], VAR_17[VAR_18], VAR_32, VAR_33, VAR_20[VAR_18], VAR_35[VAR_18]));\n        if (VAR_36 > 0)\n            VAR_37[VAR_18]->calcUV(VAR_20[VAR_18], VAR_35[VAR_18], VAR_16[VAR_18], VAR_17[VAR_18]);\n\n        if (VAR_18 > VAR_13)\n        {\n            resize(VAR_16[VAR_18], VAR_16[VAR_18 - 1], VAR_16[VAR_18 - 1].size());\n            resize(VAR_17[VAR_18], VAR_17[VAR_18 - 1], VAR_17[VAR_18 - 1].size());\n            VAR_16[VAR_18 - 1] *= 2;\n            VAR_17[VAR_18 - 1] *= 2;\n        }\n    }\n    Mat VAR_38[] = {VAR_16[VAR_13], VAR_17[VAR_13]};\n    merge(VAR_38, 2, VAR_39);\n    resize(VAR_39, VAR_11, VAR_11.size());\n    VAR_11 *= 1 << VAR_13;\n}",
  "func_graph_path": "opencv/d1615ba11a93062b1429fce9f0f638d1572d3418/dis_flow.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,8 +18,20 @@\n     else\n         flow.create(I1Mat.size(), CV_32FC2);\n     Mat flowMat = flow.getMat();\n-    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n+    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */\n                          (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n+\n+    if (coarsest_scale<0)\n+        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n+\n+    if (coarsest_scale<finest_scale)\n+    {\n+        // choose the finest level based on coarsest level.\n+        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239\n+        int original_img_width = I0.size().width;\n+        autoSelectPatchSizeAndScales(original_img_width);\n+    }\n+\n     int num_stripes = getNumThreads();\n \n     prepareBuffers(I0Mat, I1Mat, flowMat, use_input_flow);",
  "diff_line_info": {
    "deleted_lines": [
      "    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */"
    ],
    "added_lines": [
      "    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */",
      "",
      "    if (coarsest_scale<0)",
      "        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");",
      "",
      "    if (coarsest_scale<finest_scale)",
      "    {",
      "        // choose the finest level based on coarsest level.",
      "        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239",
      "        int original_img_width = I0.size().width;",
      "        autoSelectPatchSizeAndScales(original_img_width);",
      "    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencv/opencv/pull/14641",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/opencv/opencv/pull/14641: 403 Client Error: Forbidden for url: https://api.github.com/repos/opencv/opencv/pulls/14641",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\n**Summary:**  \nThe commit addresses a segmentation fault in image processing with small inputs, indicating a potential security fix through added error handling."
}