{
  "cve_id": "CVE-2023-47625",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "PX4/PX4-Autopilot",
  "commit_msg": "fix crsf_rc: prevent potential buffer overflow for unknown packets\n\nThe length check for unknown packets did not include PACKET_SIZE_TYPE_SIZE\nand CRC_SIZE, and hence working_index could overflow CRSF_MAX_PACKET_LEN,\ntriggering invalid memory access further down in QueueBuffer_PeekBuffer.\n\nAlso the working_segment_size was wrong for unknown packets.\n\nCredits for finding this go to @Pwn9uin.",
  "commit_hash": "d1fcd39a44e6312582c6ab02b0d5ee2599fb55aa",
  "git_url": "https://github.com/PX4/PX4-Autopilot/commit/d1fcd39a44e6312582c6ab02b0d5ee2599fb55aa",
  "file_path": "src/drivers/rc/crsf_rc/CrsfParser.cpp",
  "func_name": "CrsfParser_TryParseCrsfPacket",
  "func_before": "bool CrsfParser_TryParseCrsfPacket(CrsfPacket_t *const new_packet, CrsfParserStatistics_t *const parser_statistics)\n{\n\tuint32_t buffer_count;\n\tuint8_t working_byte;\n\tuint8_t packet_size;\n\tuint8_t packet_type;\n\tbool valid_packet = false;\n\n\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\n\t// Iterate through the buffer to parse the message out\n\twhile ((working_index < buffer_count) && (buffer_count - working_index) >= working_segment_size) {\n\t\tswitch (parser_state) {\n\t\t// Header\n\t\tcase PARSER_STATE_HEADER:\n\t\t\tif (QueueBuffer_Get(&rx_queue, &working_byte)) {\n\t\t\t\tif (working_byte == CRSF_HEADER) {\n\t\t\t\t\tparser_state = PARSER_STATE_SIZE_TYPE;\n\t\t\t\t\tworking_segment_size = PACKET_SIZE_TYPE_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else {\n\t\t\t\t\tparser_statistics->disposed_bytes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tbreak;\n\n\t\t// Packet size type\n\t\tcase PARSER_STATE_SIZE_TYPE:\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_size);\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_type);\n\n\t\t\tworking_descriptor = FindCrsfDescriptor((enum CRSF_PACKET_TYPE)packet_type);\n\n\t\t\t// If we know what this packet is...\n\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t// Validate length\n\t\t\t\tif (packet_size != working_descriptor->packet_size + PACKET_SIZE_TYPE_SIZE) {\n\t\t\t\t\tparser_statistics->invalid_known_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size + PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_segment_size > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;\n\t\t\tbreak;\n\n\t\t// Full packet content\n\t\tcase PARSER_STATE_PAYLOAD:\n\t\t\tworking_index += working_segment_size;\n\t\t\tworking_segment_size = CRC_SIZE;\n\t\t\tparser_state = PARSER_STATE_CRC;\n\t\t\tbreak;\n\n\t\t// CRC\n\t\tcase PARSER_STATE_CRC:\n\t\t\t// Fetch the suspected packet as a contingous block of memory\n\t\t\tQueueBuffer_PeekBuffer(&rx_queue, 0, process_buffer, working_index + CRC_SIZE);\n\n\t\t\t// Verify checksum\n\t\t\tif (Crc8Calc(process_buffer + PACKET_SIZE_SIZE, working_index - PACKET_SIZE_SIZE) == process_buffer[working_index]) {\n\t\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t\tif (working_descriptor->processor != NULL) {\n\t\t\t\t\t\tif (working_descriptor->processor(process_buffer + PACKET_SIZE_TYPE_SIZE, working_index - PACKET_SIZE_TYPE_SIZE,\n\t\t\t\t\t\t\t\t\t\t  new_packet)) {\n\t\t\t\t\t\t\tparser_statistics->crcs_valid_known_packets++;\n\t\t\t\t\t\t\tvalid_packet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// No working_descriptor at this point means unknown packet\n\t\t\t\t\tparser_statistics->crcs_valid_unknown_packets++;\n\t\t\t\t}\n\n\t\t\t\t// Remove the sucessfully processed data from the queue\n\t\t\t\tQueueBuffer_Dequeue(&rx_queue, working_index + CRC_SIZE);\n\n\t\t\t} else {\n\t\t\t\tparser_statistics->crcs_invalid++;\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tparser_state = PARSER_STATE_HEADER;\n\n\t\t\tif (valid_packet) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t}\n\n\treturn false;\n}",
  "abstract_func_before": "bool CrsfParser_TryParseCrsfPacket(CrsfPacket_t *const VAR_0, CrsfParserStatistics_t *const VAR_1)\n{\n\tuint32_t VAR_2;\n\tuint8_t VAR_3;\n\tuint8_t VAR_4;\n\tuint8_t VAR_5;\n\tbool VAR_6 = false;\n\n\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\n\t/* COMMENT_0 */\n\twhile ((VAR_8 < VAR_2) && (VAR_2 - VAR_8) >= VAR_9) {\n\t\tswitch (VAR_10) {\n\t\t/* COMMENT_1 */\n\t\tcase VAR_11:\n\t\t\tif (QueueBuffer_Get(&VAR_7, &VAR_3)) {\n\t\t\t\tif (VAR_3 == VAR_12) {\n\t\t\t\t\tVAR_10 = VAR_13;\n\t\t\t\t\tVAR_9 = VAR_14;\n\t\t\t\t\tVAR_8 = 0;\n\t\t\t\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else {\n\t\t\t\t\tVAR_1->disposed_bytes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_8 = 0;\n\t\t\tVAR_9 = VAR_15;\n\t\t\tbreak;\n\n\t\t/* COMMENT_2 */\n\t\tcase VAR_13:\n\t\t\tQueueBuffer_Peek(&VAR_7, VAR_8++, &VAR_4);\n\t\t\tQueueBuffer_Peek(&VAR_7, VAR_8++, &VAR_5);\n\n\t\t\tVAR_16 = FindCrsfDescriptor((enum CRSF_PACKET_TYPE)VAR_5);\n\n\t\t\t/* COMMENT_3 */\n\t\t\tif (VAR_16 != NULL) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tif (VAR_4 != VAR_16->packet_size + VAR_14) {\n\t\t\t\t\tVAR_1->invalid_known_packet_sizes++;\n\t\t\t\t\tVAR_10 = VAR_11;\n\t\t\t\t\tVAR_9 = VAR_15;\n\t\t\t\t\tVAR_8 = 0;\n\t\t\t\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tVAR_9 = VAR_16->packet_size;\n\n\t\t\t} else {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tVAR_9 = VAR_4 + VAR_14;\n\n\t\t\t\tif (VAR_9 > VAR_17) {\n\t\t\t\t\tVAR_1->invalid_unknown_packet_sizes++;\n\t\t\t\t\tVAR_10 = VAR_11;\n\t\t\t\t\tVAR_9 = VAR_15;\n\t\t\t\t\tVAR_8 = 0;\n\t\t\t\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_10 = VAR_18;\n\t\t\tbreak;\n\n\t\t/* COMMENT_7 */\n\t\tcase VAR_18:\n\t\t\tVAR_8 += VAR_9;\n\t\t\tVAR_9 = VAR_19;\n\t\t\tVAR_10 = VAR_20;\n\t\t\tbreak;\n\n\t\t/* COMMENT_8 */\n\t\tcase VAR_20:\n\t\t\t/* COMMENT_9 */\n\t\t\tQueueBuffer_PeekBuffer(&VAR_7, 0, VAR_21, VAR_8 + VAR_19);\n\n\t\t\t/* COMMENT_10 */\n\t\t\tif (Crc8Calc(VAR_21 + VAR_22, VAR_8 - VAR_22) == VAR_21[VAR_8]) {\n\t\t\t\tif (VAR_16 != NULL) {\n\t\t\t\t\tif (VAR_16->processor != NULL) {\n\t\t\t\t\t\tif (VAR_16->processor(VAR_21 + VAR_14, VAR_8 - VAR_14,\n\t\t\t\t\t\t\t\t\t\t  VAR_0)) {\n\t\t\t\t\t\t\tVAR_1->crcs_valid_known_packets++;\n\t\t\t\t\t\t\tVAR_6 = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\tVAR_1->crcs_valid_unknown_packets++;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tQueueBuffer_Dequeue(&VAR_7, VAR_8 + VAR_19);\n\n\t\t\t} else {\n\t\t\t\tVAR_1->crcs_invalid++;\n\t\t\t}\n\n\t\t\tVAR_8 = 0;\n\t\t\tVAR_9 = VAR_15;\n\t\t\tVAR_10 = VAR_11;\n\n\t\t\tif (VAR_6) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t}\n\n\treturn false;\n}",
  "func_graph_path_before": "PX4/PX4-Autopilot/d1fcd39a44e6312582c6ab02b0d5ee2599fb55aa/CrsfParser.cpp/vul/before/0.json",
  "func": "bool CrsfParser_TryParseCrsfPacket(CrsfPacket_t *const new_packet, CrsfParserStatistics_t *const parser_statistics)\n{\n\tuint32_t buffer_count;\n\tuint8_t working_byte;\n\tuint8_t packet_size;\n\tuint8_t packet_type;\n\tbool valid_packet = false;\n\n\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\n\t// Iterate through the buffer to parse the message out\n\twhile ((working_index < buffer_count) && (buffer_count - working_index) >= working_segment_size) {\n\t\tswitch (parser_state) {\n\t\t// Header\n\t\tcase PARSER_STATE_HEADER:\n\t\t\tif (QueueBuffer_Get(&rx_queue, &working_byte)) {\n\t\t\t\tif (working_byte == CRSF_HEADER) {\n\t\t\t\t\tparser_state = PARSER_STATE_SIZE_TYPE;\n\t\t\t\t\tworking_segment_size = PACKET_SIZE_TYPE_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else {\n\t\t\t\t\tparser_statistics->disposed_bytes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tbreak;\n\n\t\t// Packet size type\n\t\tcase PARSER_STATE_SIZE_TYPE:\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_size);\n\t\t\tQueueBuffer_Peek(&rx_queue, working_index++, &packet_type);\n\n\t\t\tworking_descriptor = FindCrsfDescriptor((enum CRSF_PACKET_TYPE)packet_type);\n\n\t\t\t// If we know what this packet is...\n\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t// Validate length\n\t\t\t\tif (packet_size != working_descriptor->packet_size + PACKET_SIZE_TYPE_SIZE) {\n\t\t\t\t\tparser_statistics->invalid_known_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size - PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_index + working_segment_size + CRC_SIZE > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;\n\t\t\tbreak;\n\n\t\t// Full packet content\n\t\tcase PARSER_STATE_PAYLOAD:\n\t\t\tworking_index += working_segment_size;\n\t\t\tworking_segment_size = CRC_SIZE;\n\t\t\tparser_state = PARSER_STATE_CRC;\n\t\t\tbreak;\n\n\t\t// CRC\n\t\tcase PARSER_STATE_CRC:\n\t\t\t// Fetch the suspected packet as a contingous block of memory\n\t\t\tQueueBuffer_PeekBuffer(&rx_queue, 0, process_buffer, working_index + CRC_SIZE);\n\n\t\t\t// Verify checksum\n\t\t\tif (Crc8Calc(process_buffer + PACKET_SIZE_SIZE, working_index - PACKET_SIZE_SIZE) == process_buffer[working_index]) {\n\t\t\t\tif (working_descriptor != NULL) {\n\t\t\t\t\tif (working_descriptor->processor != NULL) {\n\t\t\t\t\t\tif (working_descriptor->processor(process_buffer + PACKET_SIZE_TYPE_SIZE, working_index - PACKET_SIZE_TYPE_SIZE,\n\t\t\t\t\t\t\t\t\t\t  new_packet)) {\n\t\t\t\t\t\t\tparser_statistics->crcs_valid_known_packets++;\n\t\t\t\t\t\t\tvalid_packet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// No working_descriptor at this point means unknown packet\n\t\t\t\t\tparser_statistics->crcs_valid_unknown_packets++;\n\t\t\t\t}\n\n\t\t\t\t// Remove the sucessfully processed data from the queue\n\t\t\t\tQueueBuffer_Dequeue(&rx_queue, working_index + CRC_SIZE);\n\n\t\t\t} else {\n\t\t\t\tparser_statistics->crcs_invalid++;\n\t\t\t}\n\n\t\t\tworking_index = 0;\n\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\tparser_state = PARSER_STATE_HEADER;\n\n\t\t\tif (valid_packet) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t}\n\n\treturn false;\n}",
  "abstract_func": "bool CrsfParser_TryParseCrsfPacket(CrsfPacket_t *const VAR_0, CrsfParserStatistics_t *const VAR_1)\n{\n\tuint32_t VAR_2;\n\tuint8_t VAR_3;\n\tuint8_t VAR_4;\n\tuint8_t VAR_5;\n\tbool VAR_6 = false;\n\n\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\n\t/* COMMENT_0 */\n\twhile ((VAR_8 < VAR_2) && (VAR_2 - VAR_8) >= VAR_9) {\n\t\tswitch (VAR_10) {\n\t\t/* COMMENT_1 */\n\t\tcase VAR_11:\n\t\t\tif (QueueBuffer_Get(&VAR_7, &VAR_3)) {\n\t\t\t\tif (VAR_3 == VAR_12) {\n\t\t\t\t\tVAR_10 = VAR_13;\n\t\t\t\t\tVAR_9 = VAR_14;\n\t\t\t\t\tVAR_8 = 0;\n\t\t\t\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else {\n\t\t\t\t\tVAR_1->disposed_bytes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_8 = 0;\n\t\t\tVAR_9 = VAR_15;\n\t\t\tbreak;\n\n\t\t/* COMMENT_2 */\n\t\tcase VAR_13:\n\t\t\tQueueBuffer_Peek(&VAR_7, VAR_8++, &VAR_4);\n\t\t\tQueueBuffer_Peek(&VAR_7, VAR_8++, &VAR_5);\n\n\t\t\tVAR_16 = FindCrsfDescriptor((enum CRSF_PACKET_TYPE)VAR_5);\n\n\t\t\t/* COMMENT_3 */\n\t\t\tif (VAR_16 != NULL) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tif (VAR_4 != VAR_16->packet_size + VAR_14) {\n\t\t\t\t\tVAR_1->invalid_known_packet_sizes++;\n\t\t\t\t\tVAR_10 = VAR_11;\n\t\t\t\t\tVAR_9 = VAR_15;\n\t\t\t\t\tVAR_8 = 0;\n\t\t\t\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tVAR_9 = VAR_16->packet_size;\n\n\t\t\t} else {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tVAR_9 = VAR_4 - VAR_14;\n\n\t\t\t\tif (VAR_8 + VAR_9 + VAR_17 > VAR_18) {\n\t\t\t\t\tVAR_1->invalid_unknown_packet_sizes++;\n\t\t\t\t\tVAR_10 = VAR_11;\n\t\t\t\t\tVAR_9 = VAR_15;\n\t\t\t\t\tVAR_8 = 0;\n\t\t\t\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_10 = VAR_19;\n\t\t\tbreak;\n\n\t\t/* COMMENT_7 */\n\t\tcase VAR_19:\n\t\t\tVAR_8 += VAR_9;\n\t\t\tVAR_9 = VAR_17;\n\t\t\tVAR_10 = VAR_20;\n\t\t\tbreak;\n\n\t\t/* COMMENT_8 */\n\t\tcase VAR_20:\n\t\t\t/* COMMENT_9 */\n\t\t\tQueueBuffer_PeekBuffer(&VAR_7, 0, VAR_21, VAR_8 + VAR_17);\n\n\t\t\t/* COMMENT_10 */\n\t\t\tif (Crc8Calc(VAR_21 + VAR_22, VAR_8 - VAR_22) == VAR_21[VAR_8]) {\n\t\t\t\tif (VAR_16 != NULL) {\n\t\t\t\t\tif (VAR_16->processor != NULL) {\n\t\t\t\t\t\tif (VAR_16->processor(VAR_21 + VAR_14, VAR_8 - VAR_14,\n\t\t\t\t\t\t\t\t\t\t  VAR_0)) {\n\t\t\t\t\t\t\tVAR_1->crcs_valid_known_packets++;\n\t\t\t\t\t\t\tVAR_6 = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\tVAR_1->crcs_valid_unknown_packets++;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tQueueBuffer_Dequeue(&VAR_7, VAR_8 + VAR_17);\n\n\t\t\t} else {\n\t\t\t\tVAR_1->crcs_invalid++;\n\t\t\t}\n\n\t\t\tVAR_8 = 0;\n\t\t\tVAR_9 = VAR_15;\n\t\t\tVAR_10 = VAR_11;\n\n\t\t\tif (VAR_6) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tVAR_2 = QueueBuffer_Count(&VAR_7);\n\t}\n\n\treturn false;\n}",
  "func_graph_path": "PX4/PX4-Autopilot/d1fcd39a44e6312582c6ab02b0d5ee2599fb55aa/CrsfParser.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -54,9 +54,9 @@\n \t\t\t} else {\n \t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n \t\t\t\t// just so that we can dequeue it in one shot\n-\t\t\t\tworking_segment_size = packet_size + PACKET_SIZE_TYPE_SIZE;\n+\t\t\t\tworking_segment_size = packet_size - PACKET_SIZE_TYPE_SIZE;\n \n-\t\t\t\tif (working_segment_size > CRSF_MAX_PACKET_LEN) {\n+\t\t\t\tif (working_index + working_segment_size + CRC_SIZE > CRSF_MAX_PACKET_LEN) {\n \t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n \t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n \t\t\t\t\tworking_segment_size = HEADER_SIZE;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tworking_segment_size = packet_size + PACKET_SIZE_TYPE_SIZE;",
      "\t\t\t\tif (working_segment_size > CRSF_MAX_PACKET_LEN) {"
    ],
    "added_lines": [
      "\t\t\t\tworking_segment_size = packet_size - PACKET_SIZE_TYPE_SIZE;",
      "\t\t\t\tif (working_index + working_segment_size + CRC_SIZE > CRSF_MAX_PACKET_LEN) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PX4/PX4-Autopilot/pull/22152",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/PX4/PX4-Autopilot/pull/22152: 403 Client Error: Forbidden for url: https://api.github.com/repos/PX4/PX4-Autopilot/pulls/22152",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}