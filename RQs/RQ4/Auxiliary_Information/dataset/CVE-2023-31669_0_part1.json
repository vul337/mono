{
  "cve_id": "CVE-2023-31669",
  "cwe_ids": [
    "CWE-116"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "WebAssembly/wabt",
  "commit_msg": "Improve lexing and parsing of invalid annotations (again)\n\nThis adds a bounds-check to WastLexer::GetText to handle the case when\nthe offset is earlier than token_start (e.g. because GetStringToken\nfound a newline in the string and reset token_start to point at it).\n\nAlso revises GetIdToken -> GetIdChars to stop skipping the initial char\nin an annotation delimiter, which is an idchar+ but not an id token.\n\nAlso fixes the WastParser to handle EOF when reading for the end of an\nannotation, both for code metadata annotations and other kinds.\nPreviously this produced an infinite loop (but only with\n--enable-annotations).\n\nFixes #2165",
  "commit_hash": "44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "file_path": "src/wast-parser.cc",
  "func_name": "WastParser::Peek",
  "func_before": "TokenType WastParser::Peek(size_t n) {\n  while (tokens_.size() <= n) {\n    Token cur = lexer_->GetToken();\n    if (cur.token_type() != TokenType::LparAnn) {\n      tokens_.push_back(cur);\n    } else {\n      // Custom annotation. For now, discard until matching Rpar, unless it is\n      // a code metadata annotation. In that case, we know how to parse it.\n      if (!options_->features.annotations_enabled()) {\n        Error(cur.loc, \"annotations not enabled: %s\", cur.to_string().c_str());\n        tokens_.push_back(Token(cur.loc, TokenType::Invalid));\n        continue;\n      }\n      if (options_->features.code_metadata_enabled() &&\n          cur.text().find(\"metadata.code.\") == 0) {\n        tokens_.push_back(cur);\n        continue;\n      }\n      int indent = 1;\n      while (indent > 0) {\n        cur = lexer_->GetToken();\n        switch (cur.token_type()) {\n          case TokenType::Lpar:\n          case TokenType::LparAnn:\n            indent++;\n            break;\n\n          case TokenType::Rpar:\n            indent--;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }\n  return tokens_.at(n).token_type();\n}",
  "abstract_func_before": "TokenType WastParser::Peek(size_t VAR_0) {\n  while (VAR_1.size() <= VAR_0) {\n    Token VAR_2 = VAR_3->GetToken();\n    if (VAR_2.token_type() != TokenType::LparAnn) {\n      VAR_1.push_back(VAR_2);\n    } else {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      if (!VAR_4->features.annotations_enabled()) {\n        Error(VAR_2.loc, \"annotations not enabled: %s\", VAR_2.to_string().c_str());\n        VAR_1.push_back(Token(VAR_2.loc, TokenType::Invalid));\n        continue;\n      }\n      if (VAR_4->features.code_metadata_enabled() &&\n          VAR_2.text().find(\"metadata.code.\") == 0) {\n        VAR_1.push_back(VAR_2);\n        continue;\n      }\n      int VAR_5 = 1;\n      while (VAR_5 > 0) {\n        VAR_2 = VAR_3->GetToken();\n        switch (VAR_2.token_type()) {\n          case TokenType::Lpar:\n          case TokenType::LparAnn:\n            VAR_5++;\n            break;\n\n          case TokenType::Rpar:\n            VAR_5--;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }\n  return VAR_1.at(VAR_0).token_type();\n}",
  "func_graph_path_before": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/before/1.json",
  "func": "TokenType WastParser::Peek(size_t n) {\n  while (tokens_.size() <= n) {\n    Token cur = lexer_->GetToken();\n    if (cur.token_type() != TokenType::LparAnn) {\n      tokens_.push_back(cur);\n    } else {\n      // Custom annotation. For now, discard until matching Rpar, unless it is\n      // a code metadata annotation. In that case, we know how to parse it.\n      if (!options_->features.annotations_enabled()) {\n        Error(cur.loc, \"annotations not enabled: %s\", cur.to_string().c_str());\n        tokens_.push_back(Token(cur.loc, TokenType::Invalid));\n        continue;\n      }\n      if (options_->features.code_metadata_enabled() &&\n          cur.text().find(\"metadata.code.\") == 0) {\n        tokens_.push_back(cur);\n        continue;\n      }\n      int indent = 1;\n      while (indent > 0) {\n        cur = lexer_->GetToken();\n        switch (cur.token_type()) {\n          case TokenType::Lpar:\n          case TokenType::LparAnn:\n            indent++;\n            break;\n\n          case TokenType::Rpar:\n            indent--;\n            break;\n\n          case TokenType::Eof:\n            indent = 0;\n            Error(cur.loc, \"unterminated annotation\");\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }\n  return tokens_.at(n).token_type();\n}",
  "abstract_func": "TokenType WastParser::Peek(size_t VAR_0) {\n  while (VAR_1.size() <= VAR_0) {\n    Token VAR_2 = VAR_3->GetToken();\n    if (VAR_2.token_type() != TokenType::LparAnn) {\n      VAR_1.push_back(VAR_2);\n    } else {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      if (!VAR_4->features.annotations_enabled()) {\n        Error(VAR_2.loc, \"annotations not enabled: %s\", VAR_2.to_string().c_str());\n        VAR_1.push_back(Token(VAR_2.loc, TokenType::Invalid));\n        continue;\n      }\n      if (VAR_4->features.code_metadata_enabled() &&\n          VAR_2.text().find(\"metadata.code.\") == 0) {\n        VAR_1.push_back(VAR_2);\n        continue;\n      }\n      int VAR_5 = 1;\n      while (VAR_5 > 0) {\n        VAR_2 = VAR_3->GetToken();\n        switch (VAR_2.token_type()) {\n          case TokenType::Lpar:\n          case TokenType::LparAnn:\n            VAR_5++;\n            break;\n\n          case TokenType::Rpar:\n            VAR_5--;\n            break;\n\n          case TokenType::Eof:\n            VAR_5 = 0;\n            Error(VAR_2.loc, \"unterminated annotation\");\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }\n  return VAR_1.at(VAR_0).token_type();\n}",
  "func_graph_path": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-parser.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,11 @@\n             indent--;\n             break;\n \n+          case TokenType::Eof:\n+            indent = 0;\n+            Error(cur.loc, \"unterminated annotation\");\n+            break;\n+\n           default:\n             break;\n         }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "          case TokenType::Eof:",
      "            indent = 0;",
      "            Error(cur.loc, \"unterminated annotation\");",
      "            break;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/wabt/pull/2166",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/WebAssembly/wabt/pull/2166: 403 Client Error: Forbidden for url: https://api.github.com/repos/WebAssembly/wabt/pulls/2166",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.85  \n\nThe patch addresses a bug causing an infinite loop in specific scenarios, which improves core functionality without fixing a security vulnerability."
}