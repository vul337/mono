{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/scanner.c",
  "func_name": "yr_scanner_scan_mem_blocks",
  "func_before": "YR_API int yr_scanner_scan_mem_blocks(\n    YR_SCANNER* scanner,\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_DEBUG_FPRINTF(2, stderr, \"+ %s() {\\n\", __FUNCTION__);\n\n  YR_RULES* rules;\n  YR_RULE* rule;\n  YR_MEMORY_BLOCK* block;\n\n  int i, result = ERROR_SUCCESS;\n\n  if (scanner->callback == NULL)\n  {\n    result = ERROR_CALLBACK_REQUIRED;\n    goto _exit;\n  }\n\n  scanner->iterator = iterator;\n  rules = scanner->rules;\n\n  if (iterator->last_error == ERROR_BLOCK_NOT_READY)\n  {\n    // The caller is invoking yr_scanner_scan_mem_blocks again because the\n    // previous call returned ERROR_BLOCK_NOT_READY.\n    block = iterator->next(iterator);\n  }\n  else\n  {\n    // Create the notebook that will hold the YR_MATCH structures representing\n    // each match found. This notebook will also contain snippets of the\n    // matching data (the \"data\" field in YR_MATCH points to the snippet\n    // corresponding to the match). Each notebook's page can store up to 1024\n    // matches.\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n\n    result = yr_notebook_create(\n        1024 * (sizeof(YR_MATCH) + max_match_data), &scanner->matches_notebook);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    yr_stopwatch_start(&scanner->stopwatch);\n\n    block = iterator->first(iterator);\n  }\n\n  while (block != NULL)\n  {\n    const uint8_t* data = block->fetch_data(block);\n\n    // fetch_data may fail and return NULL.\n    if (data == NULL)\n    {\n      block = iterator->next(iterator);\n      continue;\n    }\n\n    if (scanner->entry_point == YR_UNDEFINED)\n    {\n      YR_TRYCATCH(\n          !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),\n          {\n            if (scanner->flags & SCAN_FLAGS_PROCESS_MEMORY)\n              scanner->entry_point = yr_get_entry_point_address(\n                  data, block->size, block->base);\n            else\n              scanner->entry_point = yr_get_entry_point_offset(\n                  data, block->size);\n          },\n          {});\n    }\n\n    YR_TRYCATCH(\n        !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),\n        { result = _yr_scanner_scan_mem_block(scanner, data, block); }",
  "abstract_func_before": "YR_API VAR_0 yr_scanner_scan_mem_blocks(\n    YR_SCANNER* VAR_1,\n    YR_MEMORY_BLOCK_ITERATOR* VAR_2)\n{\n  YR_DEBUG_FPRINTF(2, VAR_3, \"+ %s() {\\n\", VAR_4);\n\n  YR_RULES* VAR_5;\n  YR_RULE* VAR_6;\n  YR_MEMORY_BLOCK* VAR_7;\n\n  int VAR_8, VAR_9 = VAR_10;\n\n  if (VAR_1->callback == NULL)\n  {\n    VAR_9 = VAR_11;\n    goto _exit;\n  }\n\n  VAR_1->iterator = VAR_2;\n  VAR_5 = VAR_1->rules;\n\n  if (VAR_2->last_error == VAR_12)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_7 = VAR_2->next(VAR_2);\n  }\n  else\n  {\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    uint32_t VAR_13;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration(VAR_14, &VAR_13));\n\n    VAR_9 = yr_notebook_create(\n        1024 * (sizeof(VAR_15) + VAR_13), &VAR_1->matches_notebook);\n\n    if (VAR_9 != VAR_10)\n      goto _exit;\n\n    yr_stopwatch_start(&VAR_1->stopwatch);\n\n    VAR_7 = VAR_2->first(VAR_2);\n  }\n\n  while (VAR_7 != NULL)\n  {\n    const uint8_t* VAR_16 = VAR_7->fetch_data(VAR_7);\n\n    /* COMMENT_7 */\n    if (VAR_16 == NULL)\n    {\n      VAR_7 = VAR_2->next(VAR_2);\n      continue;\n    }\n\n    if (VAR_1->entry_point == VAR_17)\n    {\n      YR_TRYCATCH(\n          !(VAR_1->flags & VAR_18),\n          {\n            if (VAR_1->flags & VAR_19)\n              VAR_1->entry_point = yr_get_entry_point_address(\n                  VAR_16, VAR_7->size, VAR_7->base);\n            else\n              VAR_1->VAR_20 = yr_get_entry_point_offset(\n                  VAR_16, VAR_7->size);\n          },\n          {});\n    }\n\n    YR_TRYCATCH(\n        !(VAR_1->flags & VAR_18),\n        { VAR_9 = _yr_scanner_scan_mem_block(VAR_1, VAR_16, VAR_7); }",
  "func_graph_path_before": null,
  "func": "YR_API int yr_scanner_scan_mem_blocks(\n    YR_SCANNER* scanner,\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_DEBUG_FPRINTF(2, stderr, \"+ %s() {\\n\", __FUNCTION__);\n\n  YR_RULES* rules;\n  YR_RULE* rule;\n  YR_MEMORY_BLOCK* block;\n\n  int i, result = ERROR_SUCCESS;\n\n  if (scanner->callback == NULL)\n  {\n    result = ERROR_CALLBACK_REQUIRED;\n    goto _exit;\n  }\n\n  scanner->iterator = iterator;\n  rules = scanner->rules;\n\n  if (iterator->last_error == ERROR_BLOCK_NOT_READY)\n  {\n    // The caller is invoking yr_scanner_scan_mem_blocks again because the\n    // previous call returned ERROR_BLOCK_NOT_READY.\n    block = iterator->next(iterator);\n  }\n  else\n  {\n    // Create the notebook that will hold the YR_MATCH structures representing\n    // each match found. This notebook will also contain snippets of the\n    // matching data (the \"data\" field in YR_MATCH points to the snippet\n    // corresponding to the match). Each notebook's page can store up to 1024\n    // matches.\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n\n    result = yr_notebook_create(\n        1024 * (sizeof(YR_MATCH) + max_match_data), &scanner->matches_notebook);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    yr_stopwatch_start(&scanner->stopwatch);\n\n    block = iterator->first(iterator);\n  }\n\n  while (block != NULL)\n  {\n    const uint8_t* data = block->fetch_data(block);\n\n    // fetch_data may fail and return NULL.\n    if (data == NULL)\n    {\n      block = iterator->next(iterator);\n      continue;\n    }\n\n    if (scanner->entry_point == YR_UNDEFINED)\n    {\n      YR_TRYCATCH(\n          !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),\n          {\n            if (scanner->flags & SCAN_FLAGS_PROCESS_MEMORY)\n              scanner->entry_point = yr_get_entry_point_address(\n                  data, block->size, block->base);\n            else\n              scanner->entry_point = yr_get_entry_point_offset(\n                  data, block->size);\n          },\n          {});\n    }\n\n    YR_TRYCATCH(\n        !(scanner->flags & SCAN_FLAGS_NO_TRYCATCH),\n        { result = _yr_scanner_scan_mem_block(scanner, data, block); }",
  "abstract_func": "YR_API VAR_0 yr_scanner_scan_mem_blocks(\n    YR_SCANNER* VAR_1,\n    YR_MEMORY_BLOCK_ITERATOR* VAR_2)\n{\n  YR_DEBUG_FPRINTF(2, VAR_3, \"+ %s() {\\n\", VAR_4);\n\n  YR_RULES* VAR_5;\n  YR_RULE* VAR_6;\n  YR_MEMORY_BLOCK* VAR_7;\n\n  int VAR_8, VAR_9 = VAR_10;\n\n  if (VAR_1->callback == NULL)\n  {\n    VAR_9 = VAR_11;\n    goto _exit;\n  }\n\n  VAR_1->iterator = VAR_2;\n  VAR_5 = VAR_1->rules;\n\n  if (VAR_2->last_error == VAR_12)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_7 = VAR_2->next(VAR_2);\n  }\n  else\n  {\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    uint32_t VAR_13;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration_uint32(VAR_14, &VAR_13));\n\n    VAR_9 = yr_notebook_create(\n        1024 * (sizeof(VAR_15) + VAR_13), &VAR_1->matches_notebook);\n\n    if (VAR_9 != VAR_10)\n      goto _exit;\n\n    yr_stopwatch_start(&VAR_1->stopwatch);\n\n    VAR_7 = VAR_2->first(VAR_2);\n  }\n\n  while (VAR_7 != NULL)\n  {\n    const uint8_t* VAR_16 = VAR_7->fetch_data(VAR_7);\n\n    /* COMMENT_7 */\n    if (VAR_16 == NULL)\n    {\n      VAR_7 = VAR_2->next(VAR_2);\n      continue;\n    }\n\n    if (VAR_1->entry_point == VAR_17)\n    {\n      YR_TRYCATCH(\n          !(VAR_1->flags & VAR_18),\n          {\n            if (VAR_1->flags & VAR_19)\n              VAR_1->entry_point = yr_get_entry_point_address(\n                  VAR_16, VAR_7->size, VAR_7->base);\n            else\n              VAR_1->VAR_20 = yr_get_entry_point_offset(\n                  VAR_16, VAR_7->size);\n          },\n          {});\n    }\n\n    YR_TRYCATCH(\n        !(VAR_1->flags & VAR_18),\n        { VAR_9 = _yr_scanner_scan_mem_block(VAR_1, VAR_16, VAR_7); }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,7 @@\n     uint32_t max_match_data;\n \n     FAIL_ON_ERROR(\n-        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n+        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n \n     result = yr_notebook_create(\n         1024 * (sizeof(YR_MATCH) + max_match_data), &scanner->matches_notebook);",
  "diff_line_info": {
    "deleted_lines": [
      "        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));"
    ],
    "added_lines": [
      "        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/VirusTotal/yara/pull/1621: 403 Client Error: Forbidden for url: https://api.github.com/repos/VirusTotal/yara/pulls/1621",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}