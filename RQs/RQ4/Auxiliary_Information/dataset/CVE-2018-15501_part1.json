{
  "cve_id": "CVE-2018-15501",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "smart_pkt: fix potential OOB-read when processing ng packet\n\nOSS-fuzz has reported a potential out-of-bounds read when processing a\n\"ng\" smart packet:\n\n==1==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6310000249c0 at pc 0x000000493a92 bp 0x7ffddc882cd0 sp 0x7ffddc882480\n\tREAD of size 65529 at 0x6310000249c0 thread T0\n\tSCARINESS: 26 (multi-byte-read-heap-buffer-overflow)\n\t#0 0x493a91 in __interceptor_strchr.part.35 /src/llvm/projects/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc:673\n\t#1 0x813960 in ng_pkt libgit2/src/transports/smart_pkt.c:320:14\n\t#2 0x810f79 in git_pkt_parse_line libgit2/src/transports/smart_pkt.c:478:9\n\t#3 0x82c3c9 in git_smart__store_refs libgit2/src/transports/smart_protocol.c:47:12\n\t#4 0x6373a2 in git_smart__connect libgit2/src/transports/smart.c:251:15\n\t#5 0x57688f in git_remote_connect libgit2/src/remote.c:708:15\n\t#6 0x52e59b in LLVMFuzzerTestOneInput /src/download_refs_fuzzer.cc:145:9\n\t#7 0x52ef3f in ExecuteFilesOnyByOne(int, char**) /src/libfuzzer/afl/afl_driver.cpp:301:5\n\t#8 0x52f4ee in main /src/libfuzzer/afl/afl_driver.cpp:339:12\n\t#9 0x7f6c910db82f in __libc_start_main /build/glibc-Cl5G7W/glibc-2.23/csu/libc-start.c:291\n\t#10 0x41d518 in _start\n\nWhen parsing an \"ng\" packet, we keep track of both the current position\nas well as the remaining length of the packet itself. But instead of\ntaking care not to exceed the length, we pass the current pointer's\nposition to `strchr`, which will search for a certain character until\nhitting NUL. It is thus possible to create a crafted packet which\ndoesn't contain a NUL byte to trigger an out-of-bounds read.\n\nFix the issue by instead using `memchr`, passing the remaining length as\nrestriction. Furthermore, verify that we actually have enough bytes left\nto produce a match at all.\n\nOSS-Fuzz-Issue: 9406",
  "commit_hash": "1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649",
  "git_url": "https://github.com/libgit2/libgit2/commit/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649",
  "file_path": "src/transports/smart_pkt.c",
  "func_name": "ng_pkt",
  "func_before": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tline += 3; /* skip \"ng \" */\n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}",
  "abstract_func_before": "static int ng_pkt(git_pkt **VAR_0, const char *VAR_1, size_t VAR_2)\n{\n\tgit_pkt_ng *VAR_3;\n\tconst char *VAR_4;\n\tsize_t VAR_5;\n\n\tVAR_3 = git__malloc(sizeof(*VAR_3));\n\tGITERR_CHECK_ALLOC(VAR_3);\n\n\tVAR_3->ref = NULL;\n\tVAR_3->type = VAR_6;\n\n\tVAR_1 += 3; /* COMMENT_0 */\n\tif (!(VAR_4 = strchr(VAR_1, ' ')))\n\t\tgoto out_err;\n\tVAR_2 = VAR_4 - VAR_1;\n\n\tGITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);\n\tVAR_3->ref = git__malloc(VAR_5);\n\tGITERR_CHECK_ALLOC(VAR_3->ref);\n\n\tmemcpy(VAR_3->ref, VAR_1, VAR_2);\n\tVAR_3->ref[VAR_2] = '\\0';\n\n\tVAR_1 = VAR_4 + 1;\n\tif (!(VAR_4 = strchr(VAR_1, '\\n')))\n\t\tgoto out_err;\n\tVAR_2 = VAR_4 - VAR_1;\n\n\tGITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);\n\tVAR_3->msg = git__malloc(VAR_5);\n\tGITERR_CHECK_ALLOC(VAR_3->msg);\n\n\tmemcpy(VAR_3->msg, VAR_1, VAR_2);\n\tVAR_3->msg[VAR_2] = '\\0';\n\n\t*VAR_0 = (git_pkt *)VAR_3;\n\treturn 0;\n\nout_err:\n\tgiterr_set(VAR_7, \"invalid packet line\");\n\tgit__free(VAR_3->ref);\n\tgit__free(VAR_3);\n\treturn -1;\n}",
  "func_graph_path_before": "libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649/smart_pkt.c/vul/before/0.json",
  "func": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tif (len < 3)\n\t\tgoto out_err;\n\tline += 3; /* skip \"ng \" */\n\tlen -= 3;\n\tif (!(ptr = memchr(line, ' ', len)))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tif (len < 1)\n\t\tgoto out_err;\n\tline = ptr + 1;\n\tlen -= 1;\n\tif (!(ptr = memchr(line, '\\n', len)))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}",
  "abstract_func": "static int ng_pkt(git_pkt **VAR_0, const char *VAR_1, size_t VAR_2)\n{\n\tgit_pkt_ng *VAR_3;\n\tconst char *VAR_4;\n\tsize_t VAR_5;\n\n\tVAR_3 = git__malloc(sizeof(*VAR_3));\n\tGITERR_CHECK_ALLOC(VAR_3);\n\n\tVAR_3->ref = NULL;\n\tVAR_3->type = VAR_6;\n\n\tif (VAR_2 < 3)\n\t\tgoto out_err;\n\tVAR_1 += 3; /* COMMENT_0 */\n\tVAR_2 -= 3;\n\tif (!(VAR_4 = memchr(VAR_1, ' ', VAR_2)))\n\t\tgoto out_err;\n\tVAR_2 = VAR_4 - VAR_1;\n\n\tGITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);\n\tVAR_3->ref = git__malloc(VAR_5);\n\tGITERR_CHECK_ALLOC(VAR_3->ref);\n\n\tmemcpy(VAR_3->ref, VAR_1, VAR_2);\n\tVAR_3->ref[VAR_2] = '\\0';\n\n\tif (VAR_2 < 1)\n\t\tgoto out_err;\n\tVAR_1 = VAR_4 + 1;\n\tVAR_2 -= 1;\n\tif (!(VAR_4 = memchr(VAR_1, '\\n', VAR_2)))\n\t\tgoto out_err;\n\tVAR_2 = VAR_4 - VAR_1;\n\n\tGITERR_CHECK_ALLOC_ADD(&VAR_5, VAR_2, 1);\n\tVAR_3->msg = git__malloc(VAR_5);\n\tGITERR_CHECK_ALLOC(VAR_3->msg);\n\n\tmemcpy(VAR_3->msg, VAR_1, VAR_2);\n\tVAR_3->msg[VAR_2] = '\\0';\n\n\t*VAR_0 = (git_pkt *)VAR_3;\n\treturn 0;\n\nout_err:\n\tgiterr_set(VAR_7, \"invalid packet line\");\n\tgit__free(VAR_3->ref);\n\tgit__free(VAR_3);\n\treturn -1;\n}",
  "func_graph_path": "libgit2/1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649/smart_pkt.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,11 @@\n \tpkt->ref = NULL;\n \tpkt->type = GIT_PKT_NG;\n \n+\tif (len < 3)\n+\t\tgoto out_err;\n \tline += 3; /* skip \"ng \" */\n-\tif (!(ptr = strchr(line, ' ')))\n+\tlen -= 3;\n+\tif (!(ptr = memchr(line, ' ', len)))\n \t\tgoto out_err;\n \tlen = ptr - line;\n \n@@ -22,8 +25,11 @@\n \tmemcpy(pkt->ref, line, len);\n \tpkt->ref[len] = '\\0';\n \n+\tif (len < 1)\n+\t\tgoto out_err;\n \tline = ptr + 1;\n-\tif (!(ptr = strchr(line, '\\n')))\n+\tlen -= 1;\n+\tif (!(ptr = memchr(line, '\\n', len)))\n \t\tgoto out_err;\n \tlen = ptr - line;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (!(ptr = strchr(line, ' ')))",
      "\tif (!(ptr = strchr(line, '\\n')))"
    ],
    "added_lines": [
      "\tif (len < 3)",
      "\t\tgoto out_err;",
      "\tlen -= 3;",
      "\tif (!(ptr = memchr(line, ' ', len)))",
      "\tif (len < 1)",
      "\t\tgoto out_err;",
      "\tlen -= 1;",
      "\tif (!(ptr = memchr(line, '\\n', len)))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4756",
  "description": {
    "pr_info": {
      "title": "Release v0.27.4",
      "number": 4756
    },
    "comment": [
      "This is a security release fixing out-of-bounds reads when\r\nprocessing smart-protocol \"ng\" packets.\r\n\r\nWhen parsing an \"ng\" packet, we keep track of both the current position\r\nas well as the remaining length of the packet itself. But instead of\r\ntaking care not to exceed the length, we pass the current pointer's\r\nposition to `strchr`, which will search for a certain character until\r\nhitting NUL. It is thus possible to create a crafted packet which\r\ndoesn't contain a NUL byte to trigger an out-of-bounds read.\r\n\r\nThe issue was discovered by the oss-fuzz project, issue 9406."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}