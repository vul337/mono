{
  "cve_id": "CVE-2023-50245",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "afichet/openexr-viewer",
  "commit_msg": "Early catch potential overflow issue #43\n\n`m_width` and `m_height` are of `int` type in the OpenEXR library. We\ncurrently keep the same types in our class but this may case issue\nwhen mapping 1D memory. In the most favorable case, they are\nmultiplied together (Y framebuffer). For RGB(A) case, the required\nmemory can also be 4 time larger. We check if resp. `m_width *\nm_height` and `4 * m_width * m_heigh` stay within the `int` higher\nlimit. Thanks to @GAP-dev for bringing this issue.\n\nThis commit also cleans a bit raw memory allocation in favor of\n`std::vector` container.",
  "commit_hash": "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
  "git_url": "https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
  "file_path": "src/model/framebuffer/YFramebufferModel.cpp",
  "func_name": "YFramebufferModel::load",
  "func_before": "void YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this, &file, partId]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            Imf::Slice graySlice;\n            // TODO: Check it that can be guess from the header\n            // also, check if this can be nested\n            if (m_layer == \"BY\" || m_layer == \"RY\") {\n                m_width /= 2;\n                m_height /= 2;\n\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow = QRect(\n                  dispW.min.x,\n                  dispW.min.y,\n                  dispW_width / 2,\n                  dispW_height / 2);\n\n                m_pixelBuffer = new float[m_width * m_height];\n\n                // Luminance Chroma channels\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer,\n                  datW,\n                  sizeof(float),\n                  m_width * sizeof(float),\n                  2,\n                  2);\n            } else {\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow\n                  = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n                m_pixelBuffer = new float[m_width * m_height];\n\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer,\n                  datW);\n            }\n\n            Imf::FrameBuffer framebuffer;\n\n            framebuffer.insert(m_layer, graySlice);\n\n            part.setFrameBuffer(framebuffer);\n            part.readPixels(datW.min.y, datW.max.y);\n\n            // Determine min and max of the dataset\n            m_datasetMin = std::numeric_limits<double>::infinity();\n            m_datasetMax = -std::numeric_limits<double>::infinity();\n\n            for (int i = 0; i < m_width * m_height; i++) {\n                m_datasetMin = std::min(m_datasetMin, (double)m_pixelBuffer[i]);\n                m_datasetMax = std::max(m_datasetMax, (double)m_pixelBuffer[i]);\n            }\n\n            m_image         = QImage(m_width, m_height, QImage::Format_RGB888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}",
  "abstract_func_before": "void YFramebufferModel::load(Imf::MultiPartInputFile& VAR_0, int VAR_1)\n{\n    QFuture<void> VAR_2 = QtConcurrent::run([this, &VAR_0, VAR_1]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i VAR_3 = VAR_4.header().dataWindow();\n            VAR_5           = VAR_3.max.x - VAR_3.min.x + 1;\n            VAR_6          = VAR_3.max.y - VAR_3.min.y + 1;\n\n            VAR_7 = VAR_4.header().pixelAspectRatio();\n\n            Imf::Slice VAR_8;\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            if (VAR_9 == \"BY\" || VAR_9 == \"RY\") {\n                VAR_5 /= 2;\n                VAR_6 /= 2;\n\n                VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);\n\n                Imath::Box2i VAR_11 = VAR_4.header().displayWindow();\n\n                int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;\n                int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;\n\n                VAR_14 = QRect(\n                  VAR_11.min.x,\n                  VAR_11.min.y,\n                  VAR_12 / 2,\n                  VAR_13 / 2);\n\n                VAR_15 = new float[VAR_5 * VAR_6];\n\n                /* COMMENT_2 */\n                VAR_8 = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  VAR_15,\n                  VAR_3,\n                  sizeof(float),\n                  VAR_5 * sizeof(float),\n                  2,\n                  2);\n            } else {\n                VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);\n\n                Imath::Box2i VAR_11 = VAR_4.header().displayWindow();\n\n                int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;\n                int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;\n\n                VAR_14\n                  = QRect(VAR_11.min.x, VAR_11.min.y, VAR_12, VAR_13);\n\n                VAR_15 = new float[VAR_5 * VAR_6];\n\n                VAR_8 = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  VAR_15,\n                  VAR_3);\n            }\n\n            Imf::FrameBuffer VAR_16;\n\n            VAR_16.insert(VAR_9, VAR_8);\n\n            VAR_4.setFrameBuffer(VAR_16);\n            VAR_4.readPixels(VAR_3.min.y, VAR_3.max.y);\n\n            /* COMMENT_3 */\n            VAR_17 = std::numeric_limits<double>::infinity();\n            VAR_18 = -std::numeric_limits<double>::infinity();\n\n            for (int VAR_19 = 0; VAR_19 < VAR_5 * VAR_6; VAR_19++) {\n                VAR_17 = std::min(VAR_17, (double)VAR_15[VAR_19]);\n                VAR_18 = std::max(VAR_18, (double)VAR_15[VAR_19]);\n            }\n\n            VAR_20         = QImage(VAR_5, VAR_6, QImage::Format_RGB888);\n            VAR_21 = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& VAR_22) {\n            emit VAR_23(VAR_22.what());\n            return;\n        }\n    });\n\n    VAR_24->setFuture(VAR_2);\n}",
  "func_graph_path_before": "afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/YFramebufferModel.cpp/vul/before/0.json",
  "func": "void YFramebufferModel::load(Imf::MultiPartInputFile& file, int partId)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this, &file, partId]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            Imf::Slice graySlice;\n            // TODO: Check it that can be guess from the header\n            // also, check if this can be nested\n            if (m_layer == \"BY\" || m_layer == \"RY\") {\n                m_width /= 2;\n                m_height /= 2;\n\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow = QRect(\n                  dispW.min.x,\n                  dispW.min.y,\n                  dispW_width / 2,\n                  dispW_height / 2);\n\n                // Check to avoid type overflow, width and height are 32bits int\n                // representing a 2 dimentional image. Can overflow the type when\n                // multiplied together\n                // TODO: Use larger type when manipulating framebuffer\n                const uint64_t partial_size\n                  = (uint64_t)m_width * (uint64_t)m_height;\n\n                if (partial_size > 0x7FFFFFFF) {\n                    throw std::runtime_error(\n                      \"The total image size is too large. May be supported in \"\n                      \"a future revision.\");\n                }\n\n                m_pixelBuffer.resize(m_width * m_height);\n\n                // Luminance Chroma channels\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer.data(),\n                  datW,\n                  sizeof(float),\n                  m_width * sizeof(float),\n                  2,\n                  2);\n            } else {\n                m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n                Imath::Box2i dispW = part.header().displayWindow();\n\n                int dispW_width  = dispW.max.x - dispW.min.x + 1;\n                int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n                m_displayWindow\n                  = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n                m_pixelBuffer.resize(m_width * m_height);\n\n                graySlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  m_pixelBuffer.data(),\n                  datW);\n            }\n\n            Imf::FrameBuffer framebuffer;\n\n            framebuffer.insert(m_layer, graySlice);\n\n            part.setFrameBuffer(framebuffer);\n            part.readPixels(datW.min.y, datW.max.y);\n\n            // Determine min and max of the dataset\n            m_datasetMin = std::numeric_limits<double>::infinity();\n            m_datasetMax = -std::numeric_limits<double>::infinity();\n\n            for (int i = 0; i < m_width * m_height; i++) {\n                m_datasetMin = std::min(m_datasetMin, (double)m_pixelBuffer[i]);\n                m_datasetMax = std::max(m_datasetMax, (double)m_pixelBuffer[i]);\n            }\n\n            m_image         = QImage(m_width, m_height, QImage::Format_RGB888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}",
  "abstract_func": "void YFramebufferModel::load(Imf::MultiPartInputFile& VAR_0, int VAR_1)\n{\n    QFuture<void> VAR_2 = QtConcurrent::run([this, &VAR_0, VAR_1]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i VAR_3 = VAR_4.header().dataWindow();\n            VAR_5           = VAR_3.max.x - VAR_3.min.x + 1;\n            VAR_6          = VAR_3.max.y - VAR_3.min.y + 1;\n\n            VAR_7 = VAR_4.header().pixelAspectRatio();\n\n            Imf::Slice VAR_8;\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            if (VAR_9 == \"BY\" || VAR_9 == \"RY\") {\n                VAR_5 /= 2;\n                VAR_6 /= 2;\n\n                VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);\n\n                Imath::Box2i VAR_11 = VAR_4.header().displayWindow();\n\n                int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;\n                int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;\n\n                VAR_14 = QRect(\n                  VAR_11.min.x,\n                  VAR_11.min.y,\n                  VAR_12 / 2,\n                  VAR_13 / 2);\n\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                const uint64_t VAR_15\n                  = (uint64_t)VAR_5 * (uint64_t)VAR_6;\n\n                if (VAR_15 > 0x7FFFFFFF) {\n                    throw std::runtime_error(\n                      \"The total image size is too large. May be supported in \"\n                      \"a future revision.\");\n                }\n\n                VAR_16.resize(VAR_5 * VAR_6);\n\n                /* COMMENT_6 */\n                VAR_8 = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  VAR_16.data(),\n                  VAR_3,\n                  sizeof(float),\n                  VAR_5 * sizeof(float),\n                  2,\n                  2);\n            } else {\n                VAR_10 = QRect(VAR_3.min.x, VAR_3.min.y, VAR_5, VAR_6);\n\n                Imath::Box2i VAR_11 = VAR_4.header().displayWindow();\n\n                int VAR_12  = VAR_11.max.x - VAR_11.min.x + 1;\n                int VAR_13 = VAR_11.max.y - VAR_11.min.y + 1;\n\n                VAR_14\n                  = QRect(VAR_11.min.x, VAR_11.min.y, VAR_12, VAR_13);\n\n                VAR_16.resize(VAR_5 * VAR_6);\n\n                VAR_8 = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  VAR_16.data(),\n                  VAR_3);\n            }\n\n            Imf::FrameBuffer VAR_17;\n\n            VAR_17.insert(VAR_9, VAR_8);\n\n            VAR_4.setFrameBuffer(VAR_17);\n            VAR_4.readPixels(VAR_3.min.y, VAR_3.max.y);\n\n            /* COMMENT_7 */\n            VAR_18 = std::numeric_limits<double>::infinity();\n            VAR_19 = -std::numeric_limits<double>::infinity();\n\n            for (int VAR_20 = 0; VAR_20 < VAR_5 * VAR_6; VAR_20++) {\n                VAR_18 = std::min(VAR_18, (double)VAR_16[VAR_20]);\n                VAR_19 = std::max(VAR_19, (double)VAR_16[VAR_20]);\n            }\n\n            VAR_21         = QImage(VAR_5, VAR_6, QImage::Format_RGB888);\n            VAR_22 = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& VAR_23) {\n            emit VAR_24(VAR_23.what());\n            return;\n        }\n    });\n\n    VAR_25->setFuture(VAR_2);\n}",
  "func_graph_path": "afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/YFramebufferModel.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,12 +30,25 @@\n                   dispW_width / 2,\n                   dispW_height / 2);\n \n-                m_pixelBuffer = new float[m_width * m_height];\n+                // Check to avoid type overflow, width and height are 32bits int\n+                // representing a 2 dimentional image. Can overflow the type when\n+                // multiplied together\n+                // TODO: Use larger type when manipulating framebuffer\n+                const uint64_t partial_size\n+                  = (uint64_t)m_width * (uint64_t)m_height;\n+\n+                if (partial_size > 0x7FFFFFFF) {\n+                    throw std::runtime_error(\n+                      \"The total image size is too large. May be supported in \"\n+                      \"a future revision.\");\n+                }\n+\n+                m_pixelBuffer.resize(m_width * m_height);\n \n                 // Luminance Chroma channels\n                 graySlice = Imf::Slice::Make(\n                   Imf::PixelType::FLOAT,\n-                  m_pixelBuffer,\n+                  m_pixelBuffer.data(),\n                   datW,\n                   sizeof(float),\n                   m_width * sizeof(float),\n@@ -52,11 +65,11 @@\n                 m_displayWindow\n                   = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n \n-                m_pixelBuffer = new float[m_width * m_height];\n+                m_pixelBuffer.resize(m_width * m_height);\n \n                 graySlice = Imf::Slice::Make(\n                   Imf::PixelType::FLOAT,\n-                  m_pixelBuffer,\n+                  m_pixelBuffer.data(),\n                   datW);\n             }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "                m_pixelBuffer = new float[m_width * m_height];",
      "                  m_pixelBuffer,",
      "                m_pixelBuffer = new float[m_width * m_height];",
      "                  m_pixelBuffer,"
    ],
    "added_lines": [
      "                // Check to avoid type overflow, width and height are 32bits int",
      "                // representing a 2 dimentional image. Can overflow the type when",
      "                // multiplied together",
      "                // TODO: Use larger type when manipulating framebuffer",
      "                const uint64_t partial_size",
      "                  = (uint64_t)m_width * (uint64_t)m_height;",
      "",
      "                if (partial_size > 0x7FFFFFFF) {",
      "                    throw std::runtime_error(",
      "                      \"The total image size is too large. May be supported in \"",
      "                      \"a future revision.\");",
      "                }",
      "",
      "                m_pixelBuffer.resize(m_width * m_height);",
      "                  m_pixelBuffer.data(),",
      "                m_pixelBuffer.resize(m_width * m_height);",
      "                  m_pixelBuffer.data(),"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/afichet/openexr-viewer/pull/44",
  "description": {
    "pr_info": {
      "title": "Fix segfault",
      "number": 44
    },
    "comment": [
      "When the total memory required to store the whole image exceeds the upper int limit, in many places, there is memory violation #43.\r\n\r\nThis PR prevent this issue by performing an early check on the required memory size prior to allocation and access. Future revision shall handle such files by using larger types."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}