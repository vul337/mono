{
  "cve_id": "CVE-2018-16391",
  "cwe_ids": [
    "CWE-415",
    "CWE-119"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
  "commit_hash": "360e95d45ac4123255a4c796db96337f332160ad",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
  "file_path": "src/libopensc/card-tcos.c",
  "func_name": "tcos_select_file",
  "func_before": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
  "abstract_func_before": "static int tcos_select_file(sc_card_t *VAR_0,\n\t\t\t    const sc_path_t *VAR_1,\n\t\t\t    sc_file_t **VAR_2)\n{\n\tsc_context_t *VAR_3;\n\tsc_apdu_t VAR_4;\n\tsc_file_t *VAR_5=NULL;\n\tu8 VAR_6[VAR_7], VAR_8[VAR_9], *VAR_10 = VAR_8;\n\tunsigned int VAR_11;\n\tint VAR_12, VAR_13;\n\n\tassert(VAR_0 != NULL && VAR_1 != NULL);\n\tVAR_3=VAR_0->ctx;\n\tmemcpy(VAR_10, VAR_1->value, VAR_1->len);\n\tVAR_13 = VAR_1->len;\n\n\tsc_format_apdu(VAR_0, &VAR_4, VAR_14, 0xA4, 0, 0x04);\n\t\n\tswitch (VAR_1->type) {\n\tcase VAR_15:\n\t\tif (VAR_13 != 2) return VAR_16;\n\t\t/* COMMENT_0 */\n\tcase VAR_17:\n\t\tVAR_4.p1 = 9;\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_4.p1 = 4;\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_4.p1 = 8;\n\t\tif (VAR_13 >= 2 && memcmp(VAR_10, \"\\x3F\\x00\", 2) == 0) VAR_10 += 2, VAR_13 -= 2;\n\t\tif (VAR_13 == 0) VAR_4.p1 = 0;\n\t\tbreak;\n\tcase VAR_20:\n\t\tVAR_4.p1 = 3;\n\t\tVAR_13 = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(VAR_3, VAR_21, VAR_16);\n\t}\n\tif( VAR_13 == 0 ) VAR_4.cse = VAR_22;\n\n\tVAR_4.lc = VAR_13;\n\tVAR_4.data = VAR_10;\n\tVAR_4.datalen = VAR_13;\n\n\tif (VAR_2 != NULL) {\n\t\tVAR_4.resp = VAR_6;\n\t\tVAR_4.resplen = sizeof(VAR_6);\n\t\tVAR_4.le = 256;\n\t} else {\n\t\tVAR_4.resplen = 0;\n\t\tVAR_4.le = 0; \n\t\tVAR_4.p2 = 0x0C; \n\t\tVAR_4.cse = (VAR_13 == 0) ? VAR_23 : VAR_24;\n\t}\n\n\tVAR_12 = sc_transmit_apdu(VAR_0, &VAR_4);\n\tSC_TEST_RET(VAR_3, VAR_25, VAR_12, \"APDU transmit failed\");\n\tVAR_12 = sc_check_sw(VAR_0, VAR_4.sw1, VAR_4.sw2);\n\tif (VAR_12 || VAR_2 == NULL) SC_FUNC_RETURN(VAR_3, VAR_21, VAR_12);\n\n\tif (VAR_4.resplen < 1 || VAR_4.resp[0] != 0x62){\n\t\tsc_debug(VAR_3, VAR_25, \"received invalid template %02X\\n\", VAR_4.resp[0]);\n\t\tSC_FUNC_RETURN(VAR_3, VAR_21, VAR_26);\n\t}\n\n\tVAR_5 = sc_file_new();\n\tif (VAR_5 == NULL) SC_FUNC_RETURN(VAR_3, VAR_25, VAR_27);\n\t*VAR_2 = VAR_5;\n\tVAR_5->path = *VAR_1;\n\n\tfor(VAR_11=2; VAR_11+1<VAR_4.resplen && VAR_11+1+VAR_4.resp[VAR_11+1]<VAR_4.resplen; VAR_11+=2+VAR_4.resp[VAR_11+1]){\n\t\tint VAR_28, VAR_29=VAR_4.resp[VAR_11+1];\n\t\tunsigned char VAR_30=VAR_4.resp[VAR_11], *VAR_31=VAR_4.resp+VAR_11+2;\n\n\t\tswitch (VAR_30) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tVAR_5->size=0;\n\t\t\tfor(VAR_28=0; VAR_28<VAR_29; ++VAR_28) VAR_5->size = (VAR_5->size<<8) | VAR_31[VAR_28];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tVAR_5->shareable = (VAR_31[0] & 0x40) ? 1 : 0;\n\t\t\tVAR_5->ef_structure = VAR_31[0] & 7;\n\t\t\tswitch ((VAR_31[0]>>3) & 7) {\n\t\t\tcase 0: VAR_5->type = VAR_32; break;\n\t\t\tcase 7: VAR_5->type = VAR_33; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(VAR_3, VAR_25, \"invalid file type %02X in file descriptor\\n\", VAR_31[0]);\n\t\t\t\tSC_FUNC_RETURN(VAR_3, VAR_21, VAR_26);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tVAR_5->id = (VAR_31[0]<<8) | VAR_31[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(VAR_5->name, VAR_31, VAR_29);\n\t\t\tVAR_5->namelen = VAR_29;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(VAR_5, VAR_31, VAR_29); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (VAR_29>0) sc_file_set_prop_attr(VAR_5, VAR_31, VAR_29); \n\t\t}\n\t}\n\tVAR_5->magic = VAR_34;\n\n\tparse_sec_attr(VAR_0, VAR_5, VAR_5->sec_attr, VAR_5->sec_attr_len);\n\n\treturn 0;\n}",
  "func_graph_path_before": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/card-tcos.c/vul/before/0.json",
  "func": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
  "abstract_func": "static int tcos_select_file(sc_card_t *VAR_0,\n\t\t\t    const sc_path_t *VAR_1,\n\t\t\t    sc_file_t **VAR_2)\n{\n\tsc_context_t *VAR_3;\n\tsc_apdu_t VAR_4;\n\tsc_file_t *VAR_5=NULL;\n\tu8 VAR_6[VAR_7], VAR_8[VAR_9], *VAR_10 = VAR_8;\n\tunsigned int VAR_11;\n\tint VAR_12, VAR_13;\n\n\tassert(VAR_0 != NULL && VAR_1 != NULL);\n\tVAR_3=VAR_0->ctx;\n\tmemcpy(VAR_10, VAR_1->value, VAR_1->len);\n\tVAR_13 = VAR_1->len;\n\n\tsc_format_apdu(VAR_0, &VAR_4, VAR_14, 0xA4, 0, 0x04);\n\t\n\tswitch (VAR_1->type) {\n\tcase VAR_15:\n\t\tif (VAR_13 != 2) return VAR_16;\n\t\t/* COMMENT_0 */\n\tcase VAR_17:\n\t\tVAR_4.p1 = 9;\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_4.p1 = 4;\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_4.p1 = 8;\n\t\tif (VAR_13 >= 2 && memcmp(VAR_10, \"\\x3F\\x00\", 2) == 0) VAR_10 += 2, VAR_13 -= 2;\n\t\tif (VAR_13 == 0) VAR_4.p1 = 0;\n\t\tbreak;\n\tcase VAR_20:\n\t\tVAR_4.p1 = 3;\n\t\tVAR_13 = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(VAR_3, VAR_21, VAR_16);\n\t}\n\tif( VAR_13 == 0 ) VAR_4.cse = VAR_22;\n\n\tVAR_4.lc = VAR_13;\n\tVAR_4.data = VAR_10;\n\tVAR_4.datalen = VAR_13;\n\n\tif (VAR_2 != NULL) {\n\t\tVAR_4.resp = VAR_6;\n\t\tVAR_4.resplen = sizeof(VAR_6);\n\t\tVAR_4.le = 256;\n\t} else {\n\t\tVAR_4.resplen = 0;\n\t\tVAR_4.le = 0; \n\t\tVAR_4.p2 = 0x0C; \n\t\tVAR_4.cse = (VAR_13 == 0) ? VAR_23 : VAR_24;\n\t}\n\n\tVAR_12 = sc_transmit_apdu(VAR_0, &VAR_4);\n\tSC_TEST_RET(VAR_3, VAR_25, VAR_12, \"APDU transmit failed\");\n\tVAR_12 = sc_check_sw(VAR_0, VAR_4.sw1, VAR_4.sw2);\n\tif (VAR_12 || VAR_2 == NULL) SC_FUNC_RETURN(VAR_3, VAR_21, VAR_12);\n\n\tif (VAR_4.resplen < 1 || VAR_4.resp[0] != 0x62){\n\t\tsc_debug(VAR_3, VAR_25, \"received invalid template %02X\\n\", VAR_4.resp[0]);\n\t\tSC_FUNC_RETURN(VAR_3, VAR_21, VAR_26);\n\t}\n\n\tVAR_5 = sc_file_new();\n\tif (VAR_5 == NULL) SC_FUNC_RETURN(VAR_3, VAR_25, VAR_27);\n\t*VAR_2 = VAR_5;\n\tVAR_5->path = *VAR_1;\n\n\tfor(VAR_11=2; VAR_11+1<VAR_4.resplen && VAR_11+1+VAR_4.resp[VAR_11+1]<VAR_4.resplen; VAR_11+=2+VAR_4.resp[VAR_11+1]){\n\t\tsize_t VAR_28, VAR_29=VAR_4.resp[VAR_11+1];\n\t\tunsigned char VAR_30=VAR_4.resp[VAR_11], *VAR_31=VAR_4.resp+VAR_11+2;\n\n\t\tswitch (VAR_30) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tVAR_5->size=0;\n\t\t\tfor(VAR_28=0; VAR_28<VAR_29; ++VAR_28) VAR_5->size = (VAR_5->size<<8) | VAR_31[VAR_28];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tVAR_5->shareable = (VAR_31[0] & 0x40) ? 1 : 0;\n\t\t\tVAR_5->ef_structure = VAR_31[0] & 7;\n\t\t\tswitch ((VAR_31[0]>>3) & 7) {\n\t\t\tcase 0: VAR_5->type = VAR_32; break;\n\t\t\tcase 7: VAR_5->type = VAR_33; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(VAR_3, VAR_25, \"invalid file type %02X in file descriptor\\n\", VAR_31[0]);\n\t\t\t\tSC_FUNC_RETURN(VAR_3, VAR_21, VAR_26);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tVAR_5->id = (VAR_31[0]<<8) | VAR_31[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tVAR_5->namelen = MIN(sizeof VAR_5->name, VAR_29);\n\t\t\tmemcpy(VAR_5->name, VAR_31, VAR_5->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(VAR_5, VAR_31, VAR_29); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (VAR_29>0) sc_file_set_prop_attr(VAR_5, VAR_31, VAR_29); \n\t\t}\n\t}\n\tVAR_5->magic = VAR_34;\n\n\tparse_sec_attr(VAR_0, VAR_5, VAR_5->sec_attr, VAR_5->sec_attr_len);\n\n\treturn 0;\n}",
  "func_graph_path": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/card-tcos.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -71,7 +71,7 @@\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -95,8 +95,8 @@\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tint j, len=apdu.resp[i+1];",
      "\t\t\tmemcpy(file->name, d, len);",
      "\t\t\tfile->namelen = len;"
    ],
    "added_lines": [
      "\t\tsize_t j, len=apdu.resp[i+1];",
      "\t\t\tfile->namelen = MIN(sizeof file->name, len);",
      "\t\t\tmemcpy(file->name, d, file->namelen);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "description": {
    "pr_info": {
      "title": "Security issues identified by fuzzing",
      "number": 1447
    },
    "comment": [
      "This PR merges changes addressing issues identified by fuzzing OpenSC driver by Eric Sesterhenn. The separate commits are authored mostly by @frankmorgner, @dengert, Eric and me.\r\n\r\nFor more information, see the blog post:\r\n\r\nhttps://www.x41-dsec.de/lab/blog/smartcards/\r\n\r\nThe changes were tested to ensure they still work for the cards we have, but testing with more cards would be always appreciated.\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [X] PKCS#11 module is tested\r\n- [ ] Windows minidriver is tested\r\n- [ ] macOS tokend is tested\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}