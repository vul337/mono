{
  "cve_id": "CVE-2021-20271",
  "cwe_ids": [
    "CWE-345"
  ],
  "cvss_vector": "AV:N/AC:H/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "rpm-software-management/rpm",
  "commit_msg": "Be much more careful about copying data from the signature header\n\nOnly look for known tags, and ensure correct type and size where known\nbefore copying over. Bump the old arbitrary 16k count limit to 16M limit\nthough, it's not inconceivable that a package could have that many files.\nWhile at it, ensure none of these tags exist in the main header,\nwhich would confuse us greatly.\n\nThis is optimized for backporting ease, upstream can remove redundancies\nand further improve checking later.\n\nReported and initial patches by Demi Marie Obenour.\n\nFixes: RhBug:1935049, RhBug:1933867, RhBug:1935035, RhBug:1934125, ...\n\nFixes: CVE-2021-3421, CVE-2021-20271",
  "commit_hash": "d6a86b5e69e46cc283b1e06c92343319beb42e21",
  "git_url": "https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21",
  "file_path": "lib/package.c",
  "func_name": "headerMergeLegacySigs",
  "func_before": "static\nvoid headerMergeLegacySigs(Header h, Header sigh)\n{\n    HeaderIterator hi;\n    struct rpmtd_s td;\n\n    hi = headerInitIterator(sigh);\n    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n    {\n\tswitch (td.tag) {\n\t/* XXX Translate legacy signature tag values. */\n\tcase RPMSIGTAG_SIZE:\n\t    td.tag = RPMTAG_SIGSIZE;\n\t    break;\n\tcase RPMSIGTAG_PGP:\n\t    td.tag = RPMTAG_SIGPGP;\n\t    break;\n\tcase RPMSIGTAG_MD5:\n\t    td.tag = RPMTAG_SIGMD5;\n\t    break;\n\tcase RPMSIGTAG_GPG:\n\t    td.tag = RPMTAG_SIGGPG;\n\t    break;\n\tcase RPMSIGTAG_PGP5:\n\t    td.tag = RPMTAG_SIGPGP5;\n\t    break;\n\tcase RPMSIGTAG_PAYLOADSIZE:\n\t    td.tag = RPMTAG_ARCHIVESIZE;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURES:\n\t    td.tag = RPMTAG_FILESIGNATURES;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n\t    break;\n\tcase RPMSIGTAG_VERITYSIGNATURES:\n\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n\tcase RPMSIGTAG_SHA1:\n\tcase RPMSIGTAG_SHA256:\n\tcase RPMSIGTAG_DSA:\n\tcase RPMSIGTAG_RSA:\n\tdefault:\n\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(h, td.tag)) {\n\t    switch (td.type) {\n\t    case RPM_NULL_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    case RPM_CHAR_TYPE:\n\t    case RPM_INT8_TYPE:\n\t    case RPM_INT16_TYPE:\n\t    case RPM_INT32_TYPE:\n\t    case RPM_INT64_TYPE:\n\t\tif (td.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_STRING_TYPE:\n\t    case RPM_STRING_ARRAY_TYPE:\n\t    case RPM_BIN_TYPE:\n\t\tif (td.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_I18NSTRING_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n\t}\n    }\n    headerFreeIterator(hi);\n}",
  "abstract_func_before": "static\nvoid headerMergeLegacySigs(Header VAR_0, Header VAR_1)\n{\n    HeaderIterator VAR_2;\n    struct rpmtd_s VAR_3;\n\n    VAR_2 = headerInitIterator(VAR_1);\n    for (; headerNext(VAR_2, &VAR_3); rpmtdFreeData(&VAR_3))\n    {\n\tswitch (VAR_3.tag) {\n\t/* COMMENT_0 */\n\tcase VAR_4:\n\t    VAR_3.tag = VAR_5;\n\t    break;\n\tcase VAR_6:\n\t    VAR_3.tag = VAR_7;\n\t    break;\n\tcase VAR_8:\n\t    VAR_3.tag = VAR_9;\n\t    break;\n\tcase VAR_10:\n\t    VAR_3.tag = VAR_11;\n\t    break;\n\tcase VAR_12:\n\t    VAR_3.tag = VAR_13;\n\t    break;\n\tcase VAR_14:\n\t    VAR_3.tag = VAR_15;\n\t    break;\n\tcase VAR_16:\n\t    VAR_3.tag = VAR_17;\n\t    break;\n\tcase VAR_18:\n\t    VAR_3.tag = VAR_19;\n\t    break;\n\tcase VAR_20:\n\tcase VAR_21:\n\tcase VAR_22:\n\tcase VAR_23:\n\tcase VAR_24:\n\tcase VAR_25:\n\tdefault:\n\t    if (!(VAR_3.tag >= VAR_26 && VAR_3.tag < VAR_27))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(VAR_0, VAR_3.tag)) {\n\t    switch (VAR_3.type) {\n\t    case VAR_28:\n\t\tcontinue;\n\t\tbreak;\n\t    case VAR_29:\n\t    case VAR_30:\n\t    case VAR_31:\n\t    case VAR_32:\n\t    case VAR_33:\n\t\tif (VAR_3.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case VAR_34:\n\t    case VAR_35:\n\t    case VAR_36:\n\t\tif (VAR_3.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case VAR_37:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(VAR_0, &VAR_3, VAR_38);\n\t}\n    }\n    headerFreeIterator(VAR_2);\n}",
  "func_graph_path_before": "rpm-software-management/rpm/d6a86b5e69e46cc283b1e06c92343319beb42e21/package.c/vul/before/0.json",
  "func": "static\nrpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)\n{\n    const struct taglate_s *xl;\n    struct rpmtd_s td;\n\n    rpmtdReset(&td);\n    for (xl = xlateTags; xl->stag; xl++) {\n\t/* There mustn't be one in the main header */\n\tif (headerIsEntry(h, xl->xtag))\n\t    break;\n\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {\n\t    /* Translate legacy tags */\n\t    if (xl->stag != xl->xtag)\n\t\ttd.tag = xl->xtag;\n\t    /* Ensure type and tag size match expectations */\n\t    if (td.type != rpmTagGetTagType(td.tag))\n\t\tbreak;\n\t    if (td.count < 1 || td.count > 16*1024*1024)\n\t\tbreak;\n\t    if (xl->count && td.count != xl->count)\n\t\tbreak;\n\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))\n\t\tbreak;\n\t    rpmtdFreeData(&td);\n\t}\n    }\n    rpmtdFreeData(&td);\n\n    if (xl->stag) {\n\trasprintf(msg, \"invalid signature tag %s (%d)\",\n\t\t\trpmTagGetName(xl->xtag), xl->xtag);\n    }\n\n    return xl->stag;\n}",
  "abstract_func": "static\nrpmTagVal headerMergeLegacySigs(Header VAR_0, Header VAR_1, char **VAR_2)\n{\n    const struct taglate_s *VAR_3;\n    struct rpmtd_s VAR_4;\n\n    rpmtdReset(&VAR_4);\n    for (VAR_3 = VAR_5; VAR_3->stag; VAR_3++) {\n\t/* COMMENT_0 */\n\tif (headerIsEntry(VAR_0, VAR_3->xtag))\n\t    break;\n\tif (headerGet(VAR_1, VAR_3->stag, &VAR_4, VAR_6|VAR_7)) {\n\t    /* COMMENT_1 */\n\t    if (VAR_3->stag != VAR_3->xtag)\n\t\tVAR_4.tag = VAR_3->xtag;\n\t    /* COMMENT_2 */\n\t    if (VAR_4.type != rpmTagGetTagType(VAR_4.tag))\n\t\tbreak;\n\t    if (VAR_4.count < 1 || VAR_4.count > 16*1024*1024)\n\t\tbreak;\n\t    if (VAR_3->count && VAR_4.count != VAR_3->count)\n\t\tbreak;\n\t    if (!headerPut(VAR_0, &VAR_4, VAR_8))\n\t\tbreak;\n\t    rpmtdFreeData(&VAR_4);\n\t}\n    }\n    rpmtdFreeData(&VAR_4);\n\n    if (VAR_3->stag) {\n\trasprintf(VAR_2, \"invalid signature tag %s (%d)\",\n\t\t\trpmTagGetName(VAR_3->xtag), VAR_3->xtag);\n    }\n\n    return VAR_3->stag;\n}",
  "func_graph_path": "rpm-software-management/rpm/d6a86b5e69e46cc283b1e06c92343319beb42e21/package.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,74 +1,36 @@\n static\n-void headerMergeLegacySigs(Header h, Header sigh)\n+rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)\n {\n-    HeaderIterator hi;\n+    const struct taglate_s *xl;\n     struct rpmtd_s td;\n \n-    hi = headerInitIterator(sigh);\n-    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n-    {\n-\tswitch (td.tag) {\n-\t/* XXX Translate legacy signature tag values. */\n-\tcase RPMSIGTAG_SIZE:\n-\t    td.tag = RPMTAG_SIGSIZE;\n+    rpmtdReset(&td);\n+    for (xl = xlateTags; xl->stag; xl++) {\n+\t/* There mustn't be one in the main header */\n+\tif (headerIsEntry(h, xl->xtag))\n \t    break;\n-\tcase RPMSIGTAG_PGP:\n-\t    td.tag = RPMTAG_SIGPGP;\n-\t    break;\n-\tcase RPMSIGTAG_MD5:\n-\t    td.tag = RPMTAG_SIGMD5;\n-\t    break;\n-\tcase RPMSIGTAG_GPG:\n-\t    td.tag = RPMTAG_SIGGPG;\n-\t    break;\n-\tcase RPMSIGTAG_PGP5:\n-\t    td.tag = RPMTAG_SIGPGP5;\n-\t    break;\n-\tcase RPMSIGTAG_PAYLOADSIZE:\n-\t    td.tag = RPMTAG_ARCHIVESIZE;\n-\t    break;\n-\tcase RPMSIGTAG_FILESIGNATURES:\n-\t    td.tag = RPMTAG_FILESIGNATURES;\n-\t    break;\n-\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n-\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n-\t    break;\n-\tcase RPMSIGTAG_VERITYSIGNATURES:\n-\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n-\tcase RPMSIGTAG_SHA1:\n-\tcase RPMSIGTAG_SHA256:\n-\tcase RPMSIGTAG_DSA:\n-\tcase RPMSIGTAG_RSA:\n-\tdefault:\n-\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n-\t\tcontinue;\n-\t    break;\n-\t}\n-\tif (!headerIsEntry(h, td.tag)) {\n-\t    switch (td.type) {\n-\t    case RPM_NULL_TYPE:\n-\t\tcontinue;\n+\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {\n+\t    /* Translate legacy tags */\n+\t    if (xl->stag != xl->xtag)\n+\t\ttd.tag = xl->xtag;\n+\t    /* Ensure type and tag size match expectations */\n+\t    if (td.type != rpmTagGetTagType(td.tag))\n \t\tbreak;\n-\t    case RPM_CHAR_TYPE:\n-\t    case RPM_INT8_TYPE:\n-\t    case RPM_INT16_TYPE:\n-\t    case RPM_INT32_TYPE:\n-\t    case RPM_INT64_TYPE:\n-\t\tif (td.count != 1)\n-\t\t    continue;\n+\t    if (td.count < 1 || td.count > 16*1024*1024)\n \t\tbreak;\n-\t    case RPM_STRING_TYPE:\n-\t    case RPM_STRING_ARRAY_TYPE:\n-\t    case RPM_BIN_TYPE:\n-\t\tif (td.count >= 16*1024)\n-\t\t    continue;\n+\t    if (xl->count && td.count != xl->count)\n \t\tbreak;\n-\t    case RPM_I18NSTRING_TYPE:\n-\t\tcontinue;\n+\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))\n \t\tbreak;\n-\t    }\n-\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n+\t    rpmtdFreeData(&td);\n \t}\n     }\n-    headerFreeIterator(hi);\n+    rpmtdFreeData(&td);\n+\n+    if (xl->stag) {\n+\trasprintf(msg, \"invalid signature tag %s (%d)\",\n+\t\t\trpmTagGetName(xl->xtag), xl->xtag);\n+    }\n+\n+    return xl->stag;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "void headerMergeLegacySigs(Header h, Header sigh)",
      "    HeaderIterator hi;",
      "    hi = headerInitIterator(sigh);",
      "    for (; headerNext(hi, &td); rpmtdFreeData(&td))",
      "    {",
      "\tswitch (td.tag) {",
      "\t/* XXX Translate legacy signature tag values. */",
      "\tcase RPMSIGTAG_SIZE:",
      "\t    td.tag = RPMTAG_SIGSIZE;",
      "\tcase RPMSIGTAG_PGP:",
      "\t    td.tag = RPMTAG_SIGPGP;",
      "\t    break;",
      "\tcase RPMSIGTAG_MD5:",
      "\t    td.tag = RPMTAG_SIGMD5;",
      "\t    break;",
      "\tcase RPMSIGTAG_GPG:",
      "\t    td.tag = RPMTAG_SIGGPG;",
      "\t    break;",
      "\tcase RPMSIGTAG_PGP5:",
      "\t    td.tag = RPMTAG_SIGPGP5;",
      "\t    break;",
      "\tcase RPMSIGTAG_PAYLOADSIZE:",
      "\t    td.tag = RPMTAG_ARCHIVESIZE;",
      "\t    break;",
      "\tcase RPMSIGTAG_FILESIGNATURES:",
      "\t    td.tag = RPMTAG_FILESIGNATURES;",
      "\t    break;",
      "\tcase RPMSIGTAG_FILESIGNATURELENGTH:",
      "\t    td.tag = RPMTAG_FILESIGNATURELENGTH;",
      "\t    break;",
      "\tcase RPMSIGTAG_VERITYSIGNATURES:",
      "\tcase RPMSIGTAG_VERITYSIGNATUREALGO:",
      "\tcase RPMSIGTAG_SHA1:",
      "\tcase RPMSIGTAG_SHA256:",
      "\tcase RPMSIGTAG_DSA:",
      "\tcase RPMSIGTAG_RSA:",
      "\tdefault:",
      "\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))",
      "\t\tcontinue;",
      "\t    break;",
      "\t}",
      "\tif (!headerIsEntry(h, td.tag)) {",
      "\t    switch (td.type) {",
      "\t    case RPM_NULL_TYPE:",
      "\t\tcontinue;",
      "\t    case RPM_CHAR_TYPE:",
      "\t    case RPM_INT8_TYPE:",
      "\t    case RPM_INT16_TYPE:",
      "\t    case RPM_INT32_TYPE:",
      "\t    case RPM_INT64_TYPE:",
      "\t\tif (td.count != 1)",
      "\t\t    continue;",
      "\t    case RPM_STRING_TYPE:",
      "\t    case RPM_STRING_ARRAY_TYPE:",
      "\t    case RPM_BIN_TYPE:",
      "\t\tif (td.count >= 16*1024)",
      "\t\t    continue;",
      "\t    case RPM_I18NSTRING_TYPE:",
      "\t\tcontinue;",
      "\t    }",
      "\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);",
      "    headerFreeIterator(hi);"
    ],
    "added_lines": [
      "rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)",
      "    const struct taglate_s *xl;",
      "    rpmtdReset(&td);",
      "    for (xl = xlateTags; xl->stag; xl++) {",
      "\t/* There mustn't be one in the main header */",
      "\tif (headerIsEntry(h, xl->xtag))",
      "\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {",
      "\t    /* Translate legacy tags */",
      "\t    if (xl->stag != xl->xtag)",
      "\t\ttd.tag = xl->xtag;",
      "\t    /* Ensure type and tag size match expectations */",
      "\t    if (td.type != rpmTagGetTagType(td.tag))",
      "\t    if (td.count < 1 || td.count > 16*1024*1024)",
      "\t    if (xl->count && td.count != xl->count)",
      "\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))",
      "\t    rpmtdFreeData(&td);",
      "    rpmtdFreeData(&td);",
      "",
      "    if (xl->stag) {",
      "\trasprintf(msg, \"invalid signature tag %s (%d)\",",
      "\t\t\trpmTagGetName(xl->xtag), xl->xtag);",
      "    }",
      "",
      "    return xl->stag;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/rpm/pull/1577",
  "description": {
    "pr_info": {
      "title": "Be much more careful about copying data from the signature header",
      "number": 1577
    },
    "comment": [
      "Only look for known tags, and ensure correct type and size where known\r\nbefore copying over. Bump the old arbitrary 16k count limit to 16M limit\r\nthough, it's not inconceivable that a package could have that many files.\r\nWhile at it, ensure none of these tags exist in the main header,\r\nwhich would confuse us greatly.\r\n\r\nThis is optimized for backporting ease, upstream can remove redundancies\r\nand further improve checking later.\r\n\r\nFixes: RhBug:1935049, RhBug:1933867, RhBug:1935035, RhBug:1934125, ...\r\n\r\nFixes: CVE-2021-3421, CVE-2021-20271",
      "(reporter credits added to commit message)",
      "> I included a couple of minor performance suggestions, but those should not delay merging.\r\n\r\nBut that's exactly what such things tend to do, as I'm now wondering could there be some quirks code, especially very old versions, that cause it to actually rely on the put-sort cycle. It's extremely unlikely, but there have been stranger things (see commit da3a3a14e757ccd517e2eb2a3f0293ff48b3ff7f)",
      "Split the optimization part to a separate commit so the first one can be safely picked for old versions.\r\nI merged the MINMEM part to the first commit though - I had some kind of reason to not put it there in the first place (probably just that MINMEM is a bit iffy in the first place), but thinking it again, MINMEM is what the header iteration does so in a way this is closer to the original behavior.",
      "Mind you, the suggested optimization to avoid multiple sorts totally makes sense and never occurred to me at all (too much staring at how it always did it), so thanks for that! Just that with critical fixes needing backports and all, other enhancements such as performance are best kept apart - I planned to do a PR for that separately sooner or later."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}