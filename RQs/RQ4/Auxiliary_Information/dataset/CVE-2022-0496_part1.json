{
  "cve_id": "CVE-2022-0496",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "openscad",
  "commit_msg": "add safety to line lookups in DXF import, fixes #4037\n\nAdd safety (test for, and continue past, bad indices).\nReport warnings about bad indices\nAdd variables just to make the array indices easier to read and debug.",
  "commit_hash": "770e3234cbfe66edbc0333f796b46d36a74aa652",
  "git_url": "https://github.com/openscad/openscad/commit/770e3234cbfe66edbc0333f796b46d36a74aa652",
  "file_path": "src/dxfdata.cc",
  "func_name": "DxfData::DxfData",
  "func_before": "DxfData::DxfData(double fn, double fs, double fa, \n\t\t\t\t\t\t\t\t const std::string &filename, const std::string &layername, \n\t\t\t\t\t\t\t\t double xorigin, double yorigin, double scale)\n{\n\tstd::ifstream stream(filename.c_str());\n\tif (!stream.good()) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Can't open DXF file '%1$s'.\",filename);\n\t\treturn;\n\t}\n\n\tGrid2d<std::vector<int>> grid(GRID_COARSE);\n\tstd::vector<Line> lines;                       // Global lines\n\tstd::unordered_map<std::string, std::vector<Line>> blockdata; // Lines in blocks\n\n\tauto in_entities_section = false;\n\tauto in_blocks_section = false;\n\tstd::string current_block;\n\n#define ADD_LINE(_x1, _y1, _x2, _y2) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tdouble _p1x = _x1, _p1y = _y1, _p2x = _x2, _p2y = _y2;  \\\n\t\tif (!in_entities_section && !in_blocks_section)         \\\n\t\t\tbreak;                                                \\\n\t\tif (in_entities_section &&                              \\\n\t\t\t\t!(layername.empty() || layername == layer))         \\\n\t\t\tbreak;                                                \\\n\t\tgrid.align(_p1x, _p1y);                                 \\\n\t\tgrid.align(_p2x, _p2y);                                 \\\n\t\tgrid.data(_p1x, _p1y).push_back(lines.size());          \\\n\t\tgrid.data(_p2x, _p2y).push_back(lines.size());          \\\n\t\tif (in_entities_section)                                \\\n\t\t\tlines.emplace_back(                                   \\\n\t\t\t  addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \\\n\t\tif (in_blocks_section && !current_block.empty())        \\\n\t\t\tblockdata[current_block].emplace_back(\t              \\\n\t\t\t\taddPoint(_p1x, _p1y), addPoint(_p2x, _p2y));      \t\\\n\t} while (0)\n\n\tstd::string mode, layer, name, iddata;\n\tint dimtype = 0;\n\tdouble coords[7][2]; // Used by DIMENSION entities\n\tstd::vector<double> xverts;\n\tstd::vector<double> yverts;\n\tdouble radius = 0;\n\tdouble arc_start_angle = 0, arc_stop_angle = 0;\n\tdouble ellipse_start_angle = 0, ellipse_stop_angle = 0;\n\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tcoords[i][j] = 0;\n\t\t}\n\t}\n\n\ttypedef std::unordered_map<std::string, int> EntityList;\n\tEntityList unsupported_entities_list;\n\n\t//\n\t// Parse DXF file. Will populate this->points, this->dims, lines and blockdata\n\t//\n\twhile (!stream.eof())\t{\n\t\tstd::string id_str, data;\n\t\tstd::getline(stream, id_str);\n\t\tboost::trim(id_str);\n\t\tstd::getline(stream, data);\n\t\tboost::trim(data);\n\n\t\tint id;\n    try {\n\t\t  id = boost::lexical_cast<int>(id_str);\n    }\n    catch (const boost::bad_lexical_cast &blc) {\n\t\t\tif (!stream.eof()) {\n\t\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal ID '%1$s' in `%2$s'\",id_str,filename);\n\t\t\t}\n\t\t\tbreak;\n  \t}\n    try {\n\t\tif (id >= 10 && id <= 16) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 11 || id == 12 || id == 16) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-10][0] = (boost::lexical_cast<double>(data) - xorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tif (id >= 20 && id <= 26) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 21 || id == 22 || id == 26) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-20][1] = (boost::lexical_cast<double>(data) - yorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase 0:\n\t\t\tif (mode == \"SECTION\") {\n\t\t\t\tin_entities_section = iddata == \"ENTITIES\";\n\t\t\t\tin_blocks_section = iddata == \"BLOCKS\";\n\t\t\t}\n\t\t\telse if (mode == \"LINE\") {\n\t\t\t\tADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));\n\t\t\t}\n\t\t\telse if (mode == \"LWPOLYLINE\") {\n\t\t\t\t// assert(xverts.size() == yverts.size());\n\t\t\t\t// Get maximum to enforce managed exception if xverts.size() != yverts.size()\n\t\t\t\tint numverts = std::max(xverts.size(), yverts.size());\n\t\t\t\tfor (int i=1; i<numverts; ++i) {\n\t\t\t\t\tADD_LINE(xverts.at(i-1), yverts.at(i-1), xverts.at(i%numverts), yverts.at(i%numverts));\n\t\t\t\t}\n\t\t\t\t// polyline flag is stored in 'dimtype'\n\t\t\t\tif (dimtype & 0x01) { // closed polyline\n\t\t\t\t\tADD_LINE(xverts.at(numverts-1), yverts.at(numverts-1), xverts.at(0), yverts.at(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"CIRCLE\") {\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = (360.0 * i) / n;\n\t\t\t\t\tdouble a2 = (360.0 *(i + 1)) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ARC\") {\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\twhile (arc_start_angle > arc_stop_angle) {\n\t\t\t\t\tarc_stop_angle += 360.0;\n\t\t\t\t}\n\t\t\t\tdouble arc_angle = arc_stop_angle - arc_start_angle;\n\t\t\t\tn = static_cast<int>(ceil(n * arc_angle / 360));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = arc_start_angle + arc_angle * i / n;\n\t\t\t\t\tdouble a2 = arc_start_angle + arc_angle * (i + 1) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ELLIPSE\") {\n\t\t\t\t// Commented code is meant as documentation of vector math\n\t\t\t\twhile (ellipse_start_angle > ellipse_stop_angle) ellipse_stop_angle += 2 * M_PI;\n//\t\t\t\tVector2d center(xverts[0], yverts[0]);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n//\t\t\t\tVector2d ce(xverts[1], yverts[1]);\n\t\t\t\tVector2d ce(xverts.at(1), yverts.at(1));\n//\t\t\t\tdouble r_major = ce.length();\n\t\t\t\tdouble r_major = sqrt(ce[0]*ce[0] + ce[1]*ce[1]);\n//\t\t\t\tdouble rot_angle = ce.angle();\n\t\t\t\tdouble rot_angle;\n\t\t\t\t{\n//\t\t\t\t\tdouble dot = ce.dot(Vector2d(1.0, 0.0));\n\t\t\t\t\tdouble dot = ce[0];\n\t\t\t\t\tdouble cosval = dot / r_major;\n\t\t\t\t\tif (cosval > 1.0) cosval = 1.0;\n\t\t\t\t\tif (cosval < -1.0) cosval = -1.0;\n\t\t\t\t\trot_angle = acos(cosval);\n\t\t\t\t\tif (ce[1] < 0.0) rot_angle = 2 * M_PI - rot_angle;\n\t\t\t\t}\n\n\t\t\t\t// the ratio stored in 'radius; due to the parser code not checking entity type\n\t\t\t\tdouble r_minor = r_major * radius;\n\t\t\t\tdouble sweep_angle = ellipse_stop_angle-ellipse_start_angle;\n\t\t\t\tint n = Calc::get_fragments_from_r(r_major, fn, fs, fa);\n\t\t\t\tn = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));\n//\t\t\t\tVector2d p1;\n\t\t\t\tVector2d p1{0.0, 0.0};\n\t\t\t\tfor (int i=0; i<=n; ++i) {\n\t\t\t\t\tdouble a = (ellipse_start_angle + sweep_angle*i/n);\n//\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n//\t\t\t\t\tp2.rotate(rot_angle);\n\t\t\t\t\tVector2d p2_rot(cos(rot_angle)*p2[0] - sin(rot_angle)*p2[1],\n\t\t\t\t\t                sin(rot_angle)*p2[0] + cos(rot_angle)*p2[1]);\n//\t\t\t\t\tp2 += center;\n\t\t\t\t\tp2_rot[0] += center[0];\n\t\t\t\t\tp2_rot[1] += center[1];\n\t\t\t\t\tif (i > 0) {\n// \t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2[0], p2[1]);\n\t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);\n\t\t\t\t\t}\n//\t\t\t\t\tp1 = p2;\n\t\t\t\t\tp1[0] = p2_rot[0];\n\t\t\t\t\tp1[1] = p2_rot[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"INSERT\") {\n\t\t\t\t// scale is stored in ellipse_start|stop_angle, rotation in arc_start_angle;\n\t\t\t\t// due to the parser code not checking entity type\n\t\t\t\tint n = blockdata[iddata].size();\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a = arc_start_angle;\n\t\t\t\t\tdouble lx1 = this->points[blockdata[iddata][i].idx[0]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly1 = this->points[blockdata[iddata][i].idx[0]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble lx2 = this->points[blockdata[iddata][i].idx[1]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly2 = this->points[blockdata[iddata][i].idx[1]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble px1 = (cos_degrees(a)*lx1 - sin_degrees(a)*ly1) * scale + xverts.at(0);\n\t\t\t\t\tdouble py1 = (sin_degrees(a)*lx1 + cos_degrees(a)*ly1) * scale + yverts.at(0);\n\t\t\t\t\tdouble px2 = (cos_degrees(a)*lx2 - sin_degrees(a)*ly2) * scale + xverts.at(0);\n\t\t\t\t\tdouble py2 = (sin_degrees(a)*lx2 + cos_degrees(a)*ly2) * scale + yverts.at(0);\n\t\t\t\t\tADD_LINE(px1, py1, px2, py2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"DIMENSION\" &&\n\t\t\t\t\t\t\t (layername.empty() || layername == layer)) {\n\t\t\t\tthis->dims.push_back(Dim());\n\t\t\t\tthis->dims.back().type = dimtype;\n\t\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\tthis->dims.back().coords[i][j] = coords[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis->dims.back().angle = arc_start_angle;\n\t\t\t\tthis->dims.back().length = radius;\n\t\t\t\tthis->dims.back().name = name;\n\t\t\t}\n\t\t\telse if (mode == \"BLOCK\") {\n\t\t\t\tcurrent_block = iddata;\n\t\t\t}\n\t\t\telse if (mode == \"ENDBLK\") {\n\t\t\t\tcurrent_block.erase();\n\t\t\t}\n\t\t\telse if (mode == \"ENDSEC\") {\n\t\t\t}\n\t\t\telse if (in_blocks_section || (in_entities_section &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (layername.empty() || layername == layer))) {\n\t\t\t\tunsupported_entities_list[mode]++;\n\t\t\t}\n\t\t\tmode = data;\n\t\t\tlayer.erase();\n\t\t\tname.erase();\n\t\t\tiddata.erase();\n\t\t\tdimtype = 0;\n\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\tcoords[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\txverts.clear();\n\t\t\tyverts.clear();\n\t\t\tradius = arc_start_angle = arc_stop_angle = 0;\n\t\t\tellipse_start_angle = ellipse_stop_angle = 0;\n\t\t\tif (mode == \"INSERT\") {\n\t\t\t\tellipse_start_angle = ellipse_stop_angle = 1.0; // scale\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tname = data;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tiddata = data;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tlayer = data;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\t// CIRCLE, ARC: radius\n\t\t\t// ELLIPSE: minor to major ratio\n\t\t\t// DIMENSION (radial, diameter): Leader length\n\t\t\tradius = boost::lexical_cast<double>(data);\n\t\t\tif (!in_blocks_section) radius *= scale;\n\t\t\tbreak;\n\t\tcase 41:\n\t\t\t// ELLIPSE: start_angle\n\t\t\t// INSERT: X scale\n\t\t\tellipse_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\t// ARC: start_angle\n\t\t\t// INSERT: rot angle\n      // DIMENSION: linear and rotated: angle\n\t\t\tarc_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\t// ELLIPSE: stop_angle\n\t\t\t// INSERT: Y scale\n\t\t\tellipse_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 51: // ARC\n\t\t\tarc_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 70:\n\t\t\t// LWPOLYLINE: polyline flag\n\t\t\t// DIMENSION: dimension type\n\t\t\tdimtype = boost::lexical_cast<int>(data);\n\t\t\tbreak;\n\t\t}\n    }\n    catch (boost::bad_lexical_cast &blc) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal value '%1$s'in `%2$s'\",data,filename);\n  \t}\n    catch (const std::out_of_range& oor) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Not enough input values for %1$s. in '%2$s'\",data,filename);\n  \t}\n\t}\n\n\tfor (const auto &i : unsupported_entities_list) {\n\t\tif (layername.empty()) {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in %3$s.\",i.first,i.second,QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n\t\t} else {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s\",i.first,i.second,layername,boostfs_uncomplete(filename, fs::current_path()).generic_string());\n\t\t}\n\t}\n\n\t// Extract paths from parsed data\n\n\ttypedef std::map<int, int> LineMap;\n\tLineMap enabled_lines;\n\tfor (size_t i = 0; i < lines.size(); ++i) {\n\t\tenabled_lines[i] = i;\n\t}\n\n\t// extract all open paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line, current_point;\n\n\t\tfor (const auto &l : enabled_lines) {\n\t\t\tint idx = l.second;\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tauto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);\n\t\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\t\tint k = lv.at(ki);\n\t\t\t\t\tif (k == idx || lines[k].disabled) continue;\n\t\t\t\t\tgoto next_open_path_j;\n\t\t\t\t}\n\t\t\t\tcurrent_line = idx;\n\t\t\t\tcurrent_point = j;\n\t\t\t\tgoto create_open_path;\n\t\t\tnext_open_path_j:;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcreate_open_path:\n\t\tthis->paths.push_back(Path());\n\t\tPath *this_path = &this->paths.back();\n\n\t\tthis_path->indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path->indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n\t\t\t\tif (lines[k].disabled) continue;\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_open_path:;\n\t\t}\n\t}\n\n\t// extract all closed paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line = enabled_lines.begin()->second;\n\t\tint current_point = 0;\n\n\t\tthis->paths.push_back(Path());\n\t\tauto& this_path = this->paths.back();\n\t\tthis_path.is_closed = true;\n\t\t\n\t\tthis_path.indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path.indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n\t\t\t\tif (lines[k].disabled) continue;\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_closed_path:;\n\t\t}\n\t}\n\n\tfixup_path_direction();\n\n#if 0\n\tprintf(\"----- DXF Data -----\\n\");\n\tfor (int i = 0; i < this->paths.size(); ++i) {\n\t\tprintf(\"Path %d (%s):\\n\", i, this->paths[i].is_closed ? \"closed\" : \"open\");\n\t\tfor (int j = 0; j < this->paths[i].points.size(); ++j)\n\t\t\tprintf(\"  %f %f\\n\", (*this->paths[i].points[j])[0], (*this->paths[i].points[j])[1]);\n\t}\n\tprintf(\"--------------------\\n\");\n\tfflush(stdout);\n#endif\n}",
  "abstract_func_before": "DxfData::DxfData(double VAR_0, double VAR_1, double VAR_2, \n\t\t\t\t\t\t\t\t const std::string &VAR_3, const std::string &VAR_4, \n\t\t\t\t\t\t\t\t double VAR_5, double VAR_6, double VAR_7)\n{\n\tstd::ifstream VAR_8(VAR_3.c_str());\n\tif (!VAR_8.good()) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Can't open DXF file '%1$s'.\",VAR_3);\n\t\treturn;\n\t}\n\n\tGrid2d<std::vector<int>> grid(GRID_COARSE);\n\tstd::vector<Line> VAR_9;                       /* COMMENT_0 */\n\tstd::unordered_map<std::string, std::vector<Line>> VAR_10; /* COMMENT_1 */\n\n\tauto VAR_11 = false;\n\tauto VAR_12 = false;\n\tstd::string VAR_13;\n\n#define ADD_LINE(VAR_14, VAR_15, VAR_16, VAR_17) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tdouble _p1x = _x1, _p1y = _y1, _p2x = _x2, _p2y = _y2;  \\\n\t\tif (!in_entities_section && !in_blocks_section)         \\\n\t\t\tbreak;                                                \\\n\t\tif (in_entities_section &&                              \\\n\t\t\t\t!(layername.empty() || layername == layer))         \\\n\t\t\tbreak;                                                \\\n\t\tgrid.align(_p1x, _p1y);                                 \\\n\t\tgrid.align(_p2x, _p2y);                                 \\\n\t\tgrid.data(_p1x, _p1y).push_back(lines.size());          \\\n\t\tgrid.data(_p2x, _p2y).push_back(lines.size());          \\\n\t\tif (in_entities_section)                                \\\n\t\t\tlines.emplace_back(                                   \\\n\t\t\t  addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \\\n\t\tif (in_blocks_section && !current_block.empty())        \\\n\t\t\tblockdata[current_block].emplace_back(\t              \\\n\t\t\t\taddPoint(_p1x, _p1y), addPoint(_p2x, _p2y));      \t\\\n\t} while (0)\n\n\tstd::string VAR_18, VAR_19, VAR_20, VAR_21;\n\tint VAR_22 = 0;\n\tdouble VAR_23[7][2]; /* COMMENT_2 */\n\tstd::vector<double> VAR_24;\n\tstd::vector<double> VAR_25;\n\tdouble VAR_26 = 0;\n\tdouble VAR_27 = 0, VAR_28 = 0;\n\tdouble VAR_29 = 0, VAR_30 = 0;\n\n\tfor (int VAR_31 = 0; VAR_31 < 7; ++VAR_31) {\n\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\tVAR_23[VAR_31][VAR_32] = 0;\n\t\t}\n\t}\n\n\ttypedef std::unordered_map<std::string, int> EntityList;\n\tEntityList VAR_33;\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_3 */\n\twhile (!VAR_8.eof())\t{\n\t\tstd::string VAR_34, VAR_35;\n\t\tstd::getline(VAR_8, VAR_34);\n\t\tboost::trim(VAR_34);\n\t\tstd::getline(VAR_8, VAR_35);\n\t\tboost::trim(VAR_35);\n\n\t\tint VAR_36;\n    try {\n\t\t  VAR_36 = boost::VAR_37<int>(VAR_34);\n    }\n    catch (const boost::bad_lexical_cast &VAR_38) {\n\t\t\tif (!VAR_8.eof()) {\n\t\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal ID '%1$s' in `%2$s'\",VAR_34,VAR_3);\n\t\t\t}\n\t\t\tbreak;\n  \t}\n    try {\n\t\tif (VAR_36 >= 10 && VAR_36 <= 16) {\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_23[VAR_36-10][0] = boost::VAR_37<double>(VAR_35);\n\t\t\t}\n\t\t\telse if (VAR_36 == 11 || VAR_36 == 12 || VAR_36 == 16) {\n\t\t\t\tVAR_23[VAR_36-10][0] = boost::VAR_37<double>(VAR_35) * VAR_7;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_23[VAR_36-10][0] = (boost::VAR_37<double>(VAR_35) - VAR_5) * VAR_7;\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_36 >= 20 && VAR_36 <= 26) {\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_23[VAR_36-20][1] = boost::VAR_37<double>(VAR_35);\n\t\t\t}\n\t\t\telse if (VAR_36 == 21 || VAR_36 == 22 || VAR_36 == 26) {\n\t\t\t\tVAR_23[VAR_36-20][1] = boost::VAR_37<double>(VAR_35) * VAR_7;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_23[VAR_36-20][1] = (boost::VAR_37<double>(VAR_35) - VAR_6) * VAR_7;\n\t\t\t}\n\t\t}\n\n\t\tswitch (VAR_36) {\n\t\tcase 0:\n\t\t\tif (VAR_18 == \"SECTION\") {\n\t\t\t\tVAR_11 = VAR_21 == \"ENTITIES\";\n\t\t\t\tVAR_12 = VAR_21 == \"BLOCKS\";\n\t\t\t}\n\t\t\telse if (VAR_18 == \"LINE\") {\n\t\t\t\tADD_LINE(VAR_24.at(0), VAR_25.at(0), VAR_24.at(1), VAR_25.at(1));\n\t\t\t}\n\t\t\telse if (VAR_18 == \"LWPOLYLINE\") {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tint VAR_39 = std::max(VAR_24.size(), VAR_25.size());\n\t\t\t\tfor (int VAR_31=1; VAR_31<VAR_39; ++VAR_31) {\n\t\t\t\t\tADD_LINE(VAR_24.at(VAR_31-1), VAR_25.at(VAR_31-1), VAR_24.at(VAR_31%VAR_39), VAR_25.at(VAR_31%VAR_39));\n\t\t\t\t}\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tif (VAR_22 & 0x01) { /* COMMENT_8 */\n\t\t\t\t\tADD_LINE(VAR_24.at(VAR_39-1), VAR_25.at(VAR_39-1), VAR_24.at(0), VAR_25.at(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"CIRCLE\") {\n\t\t\t\tint VAR_40 = Calc::get_fragments_from_r(VAR_26, VAR_0, VAR_1, VAR_2);\n\t\t\t\tVector2d VAR_41(VAR_24.at(0), VAR_25.at(0));\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_42 = (360.0 * VAR_31) / VAR_40;\n\t\t\t\t\tdouble VAR_43 = (360.0 *(VAR_31 + 1)) / VAR_40;\n\t\t\t\t\tADD_LINE(cos_degrees(VAR_42)*VAR_26 + VAR_41[0], sin_degrees(VAR_42)*VAR_26 + VAR_41[1],\n\t\t\t\t\t         cos_degrees(VAR_43)*VAR_26 + VAR_41[0], sin_degrees(VAR_43)*VAR_26 + VAR_41[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ARC\") {\n\t\t\t\tVector2d VAR_41(VAR_24.at(0), VAR_25.at(0));\n\t\t\t\tint VAR_40 = Calc::get_fragments_from_r(VAR_26, VAR_0, VAR_1, VAR_2);\n\t\t\t\twhile (VAR_27 > VAR_28) {\n\t\t\t\t\tVAR_28 += 360.0;\n\t\t\t\t}\n\t\t\t\tdouble VAR_44 = VAR_28 - VAR_27;\n\t\t\t\tVAR_40 = VAR_45<int>(ceil(VAR_40 * VAR_44 / 360));\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_42 = VAR_27 + VAR_44 * VAR_31 / VAR_40;\n\t\t\t\t\tdouble VAR_43 = VAR_27 + VAR_44 * (VAR_31 + 1) / VAR_40;\n\t\t\t\t\tADD_LINE(cos_degrees(VAR_42)*VAR_26 + VAR_41[0], sin_degrees(VAR_42)*VAR_26 + VAR_41[1],\n\t\t\t\t\t         cos_degrees(VAR_43)*VAR_26 + VAR_41[0], sin_degrees(VAR_43)*VAR_26 + VAR_41[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ELLIPSE\") {\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\twhile (VAR_29 > VAR_30) VAR_30 += 2 * VAR_46;\n/* COMMENT_10 */\n\t\t\t\tVector2d VAR_41(VAR_24.at(0), VAR_25.at(0));\n/* COMMENT_11 */\n\t\t\t\tVector2d VAR_47(VAR_24.at(1), VAR_25.at(1));\n/* COMMENT_12 */\n\t\t\t\tdouble VAR_48 = sqrt(VAR_47[0]*VAR_47[0] + VAR_47[1]*VAR_47[1]);\n/* COMMENT_13 */\n\t\t\t\tdouble VAR_49;\n\t\t\t\t{\n/* COMMENT_14 */\n\t\t\t\t\tdouble VAR_50 = VAR_47[0];\n\t\t\t\t\tdouble VAR_51 = VAR_50 / VAR_48;\n\t\t\t\t\tif (VAR_51 > 1.0) VAR_51 = 1.0;\n\t\t\t\t\tif (VAR_51 < -1.0) VAR_51 = -1.0;\n\t\t\t\t\tVAR_49 = acos(VAR_51);\n\t\t\t\t\tif (VAR_47[1] < 0.0) VAR_49 = 2 * VAR_46 - VAR_49;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tdouble VAR_52 = VAR_48 * VAR_26;\n\t\t\t\tdouble VAR_53 = VAR_30-VAR_29;\n\t\t\t\tint VAR_40 = Calc::get_fragments_from_r(VAR_48, VAR_0, VAR_1, VAR_2);\n\t\t\t\tVAR_40 = VAR_45<int>(ceil(VAR_40 * VAR_53 / (2 * VAR_46)));\n/* COMMENT_16 */\n\t\t\t\tVector2d VAR_54{0.0, 0.0};\n\t\t\t\tfor (int VAR_31=0; VAR_31<=VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_55 = (VAR_29 + VAR_53*VAR_31/VAR_40);\n/* COMMENT_17 */\n\t\t\t\t\tVector2d VAR_56(cos(VAR_55)*VAR_48, sin(VAR_55)*VAR_52);\n/* COMMENT_18 */\n\t\t\t\t\tVector2d VAR_57(cos(VAR_49)*VAR_56[0] - sin(VAR_49)*VAR_56[1],\n\t\t\t\t\t                sin(VAR_49)*VAR_56[0] + cos(VAR_49)*VAR_56[1]);\n/* COMMENT_19 */\n\t\t\t\t\tVAR_57[0] += VAR_41[0];\n\t\t\t\t\tVAR_57[1] += VAR_41[1];\n\t\t\t\t\tif (VAR_31 > 0) {\n/* COMMENT_20 */\n\t\t\t\t\t\tADD_LINE(VAR_54[0], VAR_54[1], VAR_57[0], VAR_57[1]);\n\t\t\t\t\t}\n/* COMMENT_21 */\n\t\t\t\t\tVAR_54[0] = VAR_57[0];\n\t\t\t\t\tVAR_54[1] = VAR_57[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"INSERT\") {\n\t\t\t\t/* COMMENT_22 */\n\t\t\t\t/* COMMENT_23 */\n\t\t\t\tint VAR_40 = VAR_10[VAR_21].size();\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_55 = VAR_27;\n\t\t\t\t\tdouble VAR_58 = this->points[VAR_10[VAR_21][VAR_31].idx[0]][0] * VAR_29;\n\t\t\t\t\tdouble VAR_59 = this->points[VAR_10[VAR_21][VAR_31].idx[0]][1] * VAR_30;\n\t\t\t\t\tdouble VAR_60 = this->points[VAR_10[VAR_21][VAR_31].idx[1]][0] * VAR_29;\n\t\t\t\t\tdouble VAR_61 = this->points[VAR_10[VAR_21][VAR_31].idx[1]][1] * VAR_30;\n\t\t\t\t\tdouble VAR_62 = (cos_degrees(VAR_55)*VAR_58 - sin_degrees(VAR_55)*VAR_59) * VAR_7 + VAR_24.at(0);\n\t\t\t\t\tdouble VAR_63 = (sin_degrees(VAR_55)*VAR_58 + cos_degrees(VAR_55)*VAR_59) * VAR_7 + VAR_25.at(0);\n\t\t\t\t\tdouble VAR_64 = (cos_degrees(VAR_55)*VAR_60 - sin_degrees(VAR_55)*VAR_61) * VAR_7 + VAR_24.at(0);\n\t\t\t\t\tdouble VAR_65 = (sin_degrees(VAR_55)*VAR_60 + cos_degrees(VAR_55)*VAR_61) * VAR_7 + VAR_25.at(0);\n\t\t\t\t\tADD_LINE(VAR_62, VAR_63, VAR_64, VAR_65);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"DIMENSION\" &&\n\t\t\t\t\t\t\t (VAR_4.empty() || VAR_4 == VAR_19)) {\n\t\t\t\tthis->dims.push_back(Dim());\n\t\t\t\tthis->dims.back().type = VAR_22;\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < 7; ++VAR_31) {\n\t\t\t\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\t\t\t\tthis->dims.back().coords[VAR_31][VAR_32] = VAR_23[VAR_31][VAR_32];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis->dims.back().angle = VAR_27;\n\t\t\t\tthis->dims.back().length = VAR_26;\n\t\t\t\tthis->dims.back().name = VAR_20;\n\t\t\t}\n\t\t\telse if (VAR_18 == \"BLOCK\") {\n\t\t\t\tVAR_13 = VAR_21;\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ENDBLK\") {\n\t\t\t\tVAR_13.erase();\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ENDSEC\") {\n\t\t\t}\n\t\t\telse if (VAR_12 || (VAR_11 &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (VAR_4.empty() || VAR_4 == VAR_19))) {\n\t\t\t\tVAR_33[VAR_18]++;\n\t\t\t}\n\t\t\tVAR_18 = VAR_35;\n\t\t\tVAR_19.erase();\n\t\t\tVAR_20.erase();\n\t\t\tVAR_21.erase();\n\t\t\tVAR_22 = 0;\n\t\t\tfor (int VAR_31 = 0; VAR_31 < 7; ++VAR_31) {\n\t\t\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\t\t\tVAR_23[VAR_31][VAR_32] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_24.clear();\n\t\t\tVAR_25.clear();\n\t\t\tVAR_26 = VAR_27 = VAR_28 = 0;\n\t\t\tVAR_29 = VAR_30 = 0;\n\t\t\tif (VAR_18 == \"INSERT\") {\n\t\t\t\tVAR_29 = VAR_30 = 1.0; /* COMMENT_24 */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tVAR_20 = VAR_35;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_21 = VAR_35;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tVAR_19 = VAR_35;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35) - VAR_5) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35) - VAR_5) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35) - VAR_6) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35) - VAR_6) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\t/* COMMENT_25 */\n\t\t\t/* COMMENT_26 */\n\t\t\t/* COMMENT_27 */\n\t\t\tVAR_26 = boost::VAR_37<double>(VAR_35);\n\t\t\tif (!VAR_12) VAR_26 *= VAR_7;\n\t\t\tbreak;\n\t\tcase 41:\n\t\t\t/* COMMENT_28 */\n\t\t\t/* COMMENT_29 */\n\t\t\tVAR_29 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\t/* COMMENT_30 */\n\t\t\t/* COMMENT_31 */\n      /* COMMENT_32 */\n\t\t\tVAR_27 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\t/* COMMENT_33 */\n\t\t\t/* COMMENT_34 */\n\t\t\tVAR_30 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 51: /* COMMENT_35 */\n\t\t\tVAR_28 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 70:\n\t\t\t/* COMMENT_36 */\n\t\t\t/* COMMENT_37 */\n\t\t\tVAR_22 = boost::VAR_37<int>(VAR_35);\n\t\t\tbreak;\n\t\t}\n    }\n    catch (boost::bad_lexical_cast &VAR_38) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal value '%1$s'in `%2$s'\",VAR_35,VAR_3);\n  \t}\n    catch (const std::out_of_range& VAR_66) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Not enough input values for %1$s. in '%2$s'\",VAR_35,VAR_3);\n  \t}\n\t}\n\n\tfor (const auto &VAR_31 : VAR_33) {\n\t\tif (VAR_4.empty()) {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in %3$s.\",VAR_31.first,VAR_31.second,QuotedString(boostfs_uncomplete(VAR_3, fs::current_path()).generic_string()));\n\t\t} else {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s\",VAR_31.first,VAR_31.second,VAR_4,boostfs_uncomplete(VAR_3, fs::current_path()).generic_string());\n\t\t}\n\t}\n\n\t/* COMMENT_38 */\n\n\ttypedef std::map<int, int> LineMap;\n\tLineMap VAR_67;\n\tfor (size_t VAR_31 = 0; VAR_31 < VAR_9.size(); ++VAR_31) {\n\t\tVAR_67[VAR_31] = VAR_31;\n\t}\n\n\t/* COMMENT_39 */\n\twhile (VAR_67.size() > 0) {\n\t\tint VAR_68, VAR_69;\n\n\t\tfor (const auto &VAR_70 : VAR_67) {\n\t\t\tint VAR_71 = VAR_70.second;\n\t\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\t\tauto VAR_72 = VAR_73.data(this->points[VAR_9[VAR_71].idx[VAR_32]][0], this->points[VAR_9[VAR_71].idx[VAR_32]][1]);\n\t\t\t\tfor (size_t VAR_74 = 0; VAR_74 < VAR_72.size(); ++VAR_74) {\n\t\t\t\t\tint VAR_75 = VAR_72.at(VAR_74);\n\t\t\t\t\tif (VAR_75 == VAR_71 || VAR_9[VAR_75].disabled) continue;\n\t\t\t\t\tgoto next_open_path_j;\n\t\t\t\t}\n\t\t\t\tVAR_68 = VAR_71;\n\t\t\t\tVAR_69 = VAR_32;\n\t\t\t\tgoto create_open_path;\n\t\t\tnext_open_path_j:;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcreate_open_path:\n\t\tthis->paths.push_back(Path());\n\t\tPath *VAR_76 = &this->paths.back();\n\n\t\tVAR_76->indices.push_back(VAR_9[VAR_68].idx[VAR_69]);\n\t\twhile (1) {\n\t\t\tVAR_76->indices.push_back(VAR_9[VAR_68].idx[!VAR_69]);\n\t\t\tconst auto &VAR_77 = this->points[VAR_9[VAR_68].idx[!VAR_69]];\n\t\t\tVAR_9[VAR_68].disabled = true;\n\t\t\tVAR_67.erase(VAR_68);\n\t\t\tauto VAR_72 = VAR_73.data(VAR_77[0], VAR_77[1]);\n\t\t\tfor (size_t VAR_74 = 0; VAR_74 < VAR_72.size(); ++VAR_74) {\n\t\t\t\tint VAR_75 = VAR_72.at(VAR_74);\n\t\t\t\tif (VAR_9[VAR_75].disabled) continue;\n\t\t\t\tif (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_9[VAR_75].idx[0]][0], this->points[VAR_9[VAR_75].idx[0]][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 0;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t\tif (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_9[VAR_75].idx[1]][0], this->points[VAR_9[VAR_75].idx[1]][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 1;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_open_path:;\n\t\t}\n\t}\n\n\t/* COMMENT_40 */\n\twhile (VAR_67.size() > 0) {\n\t\tint VAR_68 = VAR_67.begin()->second;\n\t\tint VAR_69 = 0;\n\n\t\tthis->paths.push_back(Path());\n\t\tauto& VAR_76 = this->paths.back();\n\t\tVAR_76.is_closed = true;\n\t\t\n\t\tVAR_76.indices.push_back(VAR_9[VAR_68].idx[VAR_69]);\n\t\twhile (1) {\n\t\t\tVAR_76.indices.push_back(VAR_9[VAR_68].idx[!VAR_69]);\n\t\t\tconst auto &VAR_77 = this->points[VAR_9[VAR_68].idx[!VAR_69]];\n\t\t\tVAR_9[VAR_68].disabled = true;\n\t\t\tVAR_67.erase(VAR_68);\n\t\t\tauto VAR_72 = VAR_73.data(VAR_77[0], VAR_77[1]);\n\t\t\tfor (size_t VAR_74 = 0; VAR_74 < VAR_72.size(); ++VAR_74) {\n\t\t\t\tint VAR_75 = VAR_72.at(VAR_74);\n\t\t\t\tif (VAR_9[VAR_75].disabled) continue;\n\t\t\t\tif (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_9[VAR_75].idx[0]][0], this->points[VAR_9[VAR_75].idx[0]][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 0;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t\t\tif (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_9[VAR_75].idx[1]][0], this->points[VAR_9[VAR_75].idx[1]][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 1;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_closed_path:;\n\t\t}\n\t}\n\n\tfixup_path_direction();\n\n#if 0\n\tprintf(\"----- DXF Data -----\\n\");\n\tfor (int VAR_31 = 0; VAR_31 < this->paths.size(); ++VAR_31) {\n\t\tprintf(\"Path %d (%s):\\n\", VAR_31, this->paths[VAR_31].is_closed ? \"closed\" : \"open\");\n\t\tfor (int VAR_32 = 0; VAR_32 < this->paths[VAR_31].points.size(); ++VAR_32)\n\t\t\tprintf(\"  %f %f\\n\", (*this->paths[VAR_31].points[VAR_32])[0], (*this->paths[VAR_31].points[VAR_32])[1]);\n\t}\n\tprintf(\"--------------------\\n\");\n\tfflush(VAR_78);\n#endif\n}",
  "func_graph_path_before": "openscad/770e3234cbfe66edbc0333f796b46d36a74aa652/dxfdata.cc/vul/before/0.json",
  "func": "DxfData::DxfData(double fn, double fs, double fa, \n\t\t\t\t\t\t\t\t const std::string &filename, const std::string &layername, \n\t\t\t\t\t\t\t\t double xorigin, double yorigin, double scale)\n{\n\tstd::ifstream stream(filename.c_str());\n\tif (!stream.good()) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Can't open DXF file '%1$s'.\",filename);\n\t\treturn;\n\t}\n\n\tGrid2d<std::vector<int>> grid(GRID_COARSE);\n\tstd::vector<Line> lines;                       // Global lines\n\tstd::unordered_map<std::string, std::vector<Line>> blockdata; // Lines in blocks\n\n\tauto in_entities_section = false;\n\tauto in_blocks_section = false;\n\tstd::string current_block;\n\n#define ADD_LINE(_x1, _y1, _x2, _y2) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tdouble _p1x = _x1, _p1y = _y1, _p2x = _x2, _p2y = _y2;  \\\n\t\tif (!in_entities_section && !in_blocks_section)         \\\n\t\t\tbreak;                                                \\\n\t\tif (in_entities_section &&                              \\\n\t\t\t\t!(layername.empty() || layername == layer))         \\\n\t\t\tbreak;                                                \\\n\t\tgrid.align(_p1x, _p1y);                                 \\\n\t\tgrid.align(_p2x, _p2y);                                 \\\n\t\tgrid.data(_p1x, _p1y).push_back(lines.size());          \\\n\t\tgrid.data(_p2x, _p2y).push_back(lines.size());          \\\n\t\tif (in_entities_section)                                \\\n\t\t\tlines.emplace_back(                                   \\\n\t\t\t  addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \\\n\t\tif (in_blocks_section && !current_block.empty())        \\\n\t\t\tblockdata[current_block].emplace_back(\t              \\\n\t\t\t\taddPoint(_p1x, _p1y), addPoint(_p2x, _p2y));      \t\\\n\t} while (0)\n\n\tstd::string mode, layer, name, iddata;\n\tint dimtype = 0;\n\tdouble coords[7][2]; // Used by DIMENSION entities\n\tstd::vector<double> xverts;\n\tstd::vector<double> yverts;\n\tdouble radius = 0;\n\tdouble arc_start_angle = 0, arc_stop_angle = 0;\n\tdouble ellipse_start_angle = 0, ellipse_stop_angle = 0;\n\n\tfor (int i = 0; i < 7; ++i) {\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tcoords[i][j] = 0;\n\t\t}\n\t}\n\n\ttypedef std::unordered_map<std::string, int> EntityList;\n\tEntityList unsupported_entities_list;\n\n\t//\n\t// Parse DXF file. Will populate this->points, this->dims, lines and blockdata\n\t//\n\twhile (!stream.eof())\t{\n\t\tstd::string id_str, data;\n\t\tstd::getline(stream, id_str);\n\t\tboost::trim(id_str);\n\t\tstd::getline(stream, data);\n\t\tboost::trim(data);\n\n\t\tint id;\n    try {\n\t\t  id = boost::lexical_cast<int>(id_str);\n    }\n    catch (const boost::bad_lexical_cast &blc) {\n\t\t\tif (!stream.eof()) {\n\t\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal ID '%1$s' in `%2$s'\",id_str,filename);\n\t\t\t}\n\t\t\tbreak;\n  \t}\n    try {\n\t\tif (id >= 10 && id <= 16) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 11 || id == 12 || id == 16) {\n\t\t\t\tcoords[id-10][0] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-10][0] = (boost::lexical_cast<double>(data) - xorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tif (id >= 20 && id <= 26) {\n\t\t\tif (in_blocks_section) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data);\n\t\t\t}\n\t\t\telse if (id == 21 || id == 22 || id == 26) {\n\t\t\t\tcoords[id-20][1] = boost::lexical_cast<double>(data) * scale;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoords[id-20][1] = (boost::lexical_cast<double>(data) - yorigin) * scale;\n\t\t\t}\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase 0:\n\t\t\tif (mode == \"SECTION\") {\n\t\t\t\tin_entities_section = iddata == \"ENTITIES\";\n\t\t\t\tin_blocks_section = iddata == \"BLOCKS\";\n\t\t\t}\n\t\t\telse if (mode == \"LINE\") {\n\t\t\t\tADD_LINE(xverts.at(0), yverts.at(0), xverts.at(1), yverts.at(1));\n\t\t\t}\n\t\t\telse if (mode == \"LWPOLYLINE\") {\n\t\t\t\t// assert(xverts.size() == yverts.size());\n\t\t\t\t// Get maximum to enforce managed exception if xverts.size() != yverts.size()\n\t\t\t\tint numverts = std::max(xverts.size(), yverts.size());\n\t\t\t\tfor (int i=1; i<numverts; ++i) {\n\t\t\t\t\tADD_LINE(xverts.at(i-1), yverts.at(i-1), xverts.at(i%numverts), yverts.at(i%numverts));\n\t\t\t\t}\n\t\t\t\t// polyline flag is stored in 'dimtype'\n\t\t\t\tif (dimtype & 0x01) { // closed polyline\n\t\t\t\t\tADD_LINE(xverts.at(numverts-1), yverts.at(numverts-1), xverts.at(0), yverts.at(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"CIRCLE\") {\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = (360.0 * i) / n;\n\t\t\t\t\tdouble a2 = (360.0 *(i + 1)) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ARC\") {\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n\t\t\t\tint n = Calc::get_fragments_from_r(radius, fn, fs, fa);\n\t\t\t\twhile (arc_start_angle > arc_stop_angle) {\n\t\t\t\t\tarc_stop_angle += 360.0;\n\t\t\t\t}\n\t\t\t\tdouble arc_angle = arc_stop_angle - arc_start_angle;\n\t\t\t\tn = static_cast<int>(ceil(n * arc_angle / 360));\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a1 = arc_start_angle + arc_angle * i / n;\n\t\t\t\t\tdouble a2 = arc_start_angle + arc_angle * (i + 1) / n;\n\t\t\t\t\tADD_LINE(cos_degrees(a1)*radius + center[0], sin_degrees(a1)*radius + center[1],\n\t\t\t\t\t         cos_degrees(a2)*radius + center[0], sin_degrees(a2)*radius + center[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"ELLIPSE\") {\n\t\t\t\t// Commented code is meant as documentation of vector math\n\t\t\t\twhile (ellipse_start_angle > ellipse_stop_angle) ellipse_stop_angle += 2 * M_PI;\n//\t\t\t\tVector2d center(xverts[0], yverts[0]);\n\t\t\t\tVector2d center(xverts.at(0), yverts.at(0));\n//\t\t\t\tVector2d ce(xverts[1], yverts[1]);\n\t\t\t\tVector2d ce(xverts.at(1), yverts.at(1));\n//\t\t\t\tdouble r_major = ce.length();\n\t\t\t\tdouble r_major = sqrt(ce[0]*ce[0] + ce[1]*ce[1]);\n//\t\t\t\tdouble rot_angle = ce.angle();\n\t\t\t\tdouble rot_angle;\n\t\t\t\t{\n//\t\t\t\t\tdouble dot = ce.dot(Vector2d(1.0, 0.0));\n\t\t\t\t\tdouble dot = ce[0];\n\t\t\t\t\tdouble cosval = dot / r_major;\n\t\t\t\t\tif (cosval > 1.0) cosval = 1.0;\n\t\t\t\t\tif (cosval < -1.0) cosval = -1.0;\n\t\t\t\t\trot_angle = acos(cosval);\n\t\t\t\t\tif (ce[1] < 0.0) rot_angle = 2 * M_PI - rot_angle;\n\t\t\t\t}\n\n\t\t\t\t// the ratio stored in 'radius; due to the parser code not checking entity type\n\t\t\t\tdouble r_minor = r_major * radius;\n\t\t\t\tdouble sweep_angle = ellipse_stop_angle-ellipse_start_angle;\n\t\t\t\tint n = Calc::get_fragments_from_r(r_major, fn, fs, fa);\n\t\t\t\tn = static_cast<int>(ceil(n * sweep_angle / (2 * M_PI)));\n//\t\t\t\tVector2d p1;\n\t\t\t\tVector2d p1{0.0, 0.0};\n\t\t\t\tfor (int i=0; i<=n; ++i) {\n\t\t\t\t\tdouble a = (ellipse_start_angle + sweep_angle*i/n);\n//\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n\t\t\t\t\tVector2d p2(cos(a)*r_major, sin(a)*r_minor);\n//\t\t\t\t\tp2.rotate(rot_angle);\n\t\t\t\t\tVector2d p2_rot(cos(rot_angle)*p2[0] - sin(rot_angle)*p2[1],\n\t\t\t\t\t                sin(rot_angle)*p2[0] + cos(rot_angle)*p2[1]);\n//\t\t\t\t\tp2 += center;\n\t\t\t\t\tp2_rot[0] += center[0];\n\t\t\t\t\tp2_rot[1] += center[1];\n\t\t\t\t\tif (i > 0) {\n// \t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2[0], p2[1]);\n\t\t\t\t\t\tADD_LINE(p1[0], p1[1], p2_rot[0], p2_rot[1]);\n\t\t\t\t\t}\n//\t\t\t\t\tp1 = p2;\n\t\t\t\t\tp1[0] = p2_rot[0];\n\t\t\t\t\tp1[1] = p2_rot[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"INSERT\") {\n\t\t\t\t// scale is stored in ellipse_start|stop_angle, rotation in arc_start_angle;\n\t\t\t\t// due to the parser code not checking entity type\n\t\t\t\tint n = blockdata[iddata].size();\n\t\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\t\tdouble a = arc_start_angle;\n\t\t\t\t\tdouble lx1 = this->points[blockdata[iddata][i].idx[0]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly1 = this->points[blockdata[iddata][i].idx[0]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble lx2 = this->points[blockdata[iddata][i].idx[1]][0] * ellipse_start_angle;\n\t\t\t\t\tdouble ly2 = this->points[blockdata[iddata][i].idx[1]][1] * ellipse_stop_angle;\n\t\t\t\t\tdouble px1 = (cos_degrees(a)*lx1 - sin_degrees(a)*ly1) * scale + xverts.at(0);\n\t\t\t\t\tdouble py1 = (sin_degrees(a)*lx1 + cos_degrees(a)*ly1) * scale + yverts.at(0);\n\t\t\t\t\tdouble px2 = (cos_degrees(a)*lx2 - sin_degrees(a)*ly2) * scale + xverts.at(0);\n\t\t\t\t\tdouble py2 = (sin_degrees(a)*lx2 + cos_degrees(a)*ly2) * scale + yverts.at(0);\n\t\t\t\t\tADD_LINE(px1, py1, px2, py2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (mode == \"DIMENSION\" &&\n\t\t\t\t\t\t\t (layername.empty() || layername == layer)) {\n\t\t\t\tthis->dims.push_back(Dim());\n\t\t\t\tthis->dims.back().type = dimtype;\n\t\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\tthis->dims.back().coords[i][j] = coords[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis->dims.back().angle = arc_start_angle;\n\t\t\t\tthis->dims.back().length = radius;\n\t\t\t\tthis->dims.back().name = name;\n\t\t\t}\n\t\t\telse if (mode == \"BLOCK\") {\n\t\t\t\tcurrent_block = iddata;\n\t\t\t}\n\t\t\telse if (mode == \"ENDBLK\") {\n\t\t\t\tcurrent_block.erase();\n\t\t\t}\n\t\t\telse if (mode == \"ENDSEC\") {\n\t\t\t}\n\t\t\telse if (in_blocks_section || (in_entities_section &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (layername.empty() || layername == layer))) {\n\t\t\t\tunsupported_entities_list[mode]++;\n\t\t\t}\n\t\t\tmode = data;\n\t\t\tlayer.erase();\n\t\t\tname.erase();\n\t\t\tiddata.erase();\n\t\t\tdimtype = 0;\n\t\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\tcoords[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\txverts.clear();\n\t\t\tyverts.clear();\n\t\t\tradius = arc_start_angle = arc_stop_angle = 0;\n\t\t\tellipse_start_angle = ellipse_stop_angle = 0;\n\t\t\tif (mode == \"INSERT\") {\n\t\t\t\tellipse_start_angle = ellipse_stop_angle = 1.0; // scale\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tname = data;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tiddata = data;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tlayer = data;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif (in_blocks_section) {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\txverts.push_back((boost::lexical_cast<double>(data) - xorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tif (in_blocks_section) {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tyverts.push_back((boost::lexical_cast<double>(data) - yorigin) * scale);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\t// CIRCLE, ARC: radius\n\t\t\t// ELLIPSE: minor to major ratio\n\t\t\t// DIMENSION (radial, diameter): Leader length\n\t\t\tradius = boost::lexical_cast<double>(data);\n\t\t\tif (!in_blocks_section) radius *= scale;\n\t\t\tbreak;\n\t\tcase 41:\n\t\t\t// ELLIPSE: start_angle\n\t\t\t// INSERT: X scale\n\t\t\tellipse_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\t// ARC: start_angle\n\t\t\t// INSERT: rot angle\n      // DIMENSION: linear and rotated: angle\n\t\t\tarc_start_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\t// ELLIPSE: stop_angle\n\t\t\t// INSERT: Y scale\n\t\t\tellipse_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 51: // ARC\n\t\t\tarc_stop_angle = boost::lexical_cast<double>(data);\n\t\t\tbreak;\n\t\tcase 70:\n\t\t\t// LWPOLYLINE: polyline flag\n\t\t\t// DIMENSION: dimension type\n\t\t\tdimtype = boost::lexical_cast<int>(data);\n\t\t\tbreak;\n\t\t}\n    }\n    catch (boost::bad_lexical_cast &blc) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal value '%1$s'in `%2$s'\",data,filename);\n  \t}\n    catch (const std::out_of_range& oor) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Not enough input values for %1$s. in '%2$s'\",data,filename);\n  \t}\n\t}\n\n\tfor (const auto &i : unsupported_entities_list) {\n\t\tif (layername.empty()) {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in %3$s.\",i.first,i.second,QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n\t\t} else {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s\",i.first,i.second,layername,boostfs_uncomplete(filename, fs::current_path()).generic_string());\n\t\t}\n\t}\n\n\t// Extract paths from parsed data\n\n\ttypedef std::map<int, int> LineMap;\n\tLineMap enabled_lines;\n\tfor (size_t i = 0; i < lines.size(); ++i) {\n\t\tenabled_lines[i] = i;\n\t}\n\n\t// extract all open paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line, current_point;\n\n\t\tfor (const auto &l : enabled_lines) {\n\t\t\tint idx = l.second;\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tauto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);\n\t\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\t\tint k = lv.at(ki);\n                    if (k < 0 || k >= lines.size()) {\n                        LOG(message_group::Warning,Location::NONE,\"\",\n                            \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n                        continue;\n                    }\n\t\t\t\t\tif (k == idx || lines[k].disabled) continue;\n\t\t\t\t\tgoto next_open_path_j;\n\t\t\t\t}\n\t\t\t\tcurrent_line = idx;\n\t\t\t\tcurrent_point = j;\n\t\t\t\tgoto create_open_path;\n\t\t\tnext_open_path_j:;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcreate_open_path:\n\t\tthis->paths.push_back(Path());\n\t\tPath *this_path = &this->paths.back();\n\n\t\tthis_path->indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path->indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n                if (k < 0 || k >= lines.size()) {\n                    LOG(message_group::Warning,Location::NONE,\"\",\n                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n                    continue;\n                }\n\t\t\t\tif (lines[k].disabled) continue;\n                auto idk0 = lines[k].idx[0];    // make it easier to read and debug\n                auto idk1 = lines[k].idx[1];\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_open_path:;\n\t\t}\n\t}\n\n\t// extract all closed paths\n\twhile (enabled_lines.size() > 0) {\n\t\tint current_line = enabled_lines.begin()->second;\n\t\tint current_point = 0;\n\n\t\tthis->paths.push_back(Path());\n\t\tauto& this_path = this->paths.back();\n\t\tthis_path.is_closed = true;\n\t\t\n\t\tthis_path.indices.push_back(lines[current_line].idx[current_point]);\n\t\twhile (1) {\n\t\t\tthis_path.indices.push_back(lines[current_line].idx[!current_point]);\n\t\t\tconst auto &ref_point = this->points[lines[current_line].idx[!current_point]];\n\t\t\tlines[current_line].disabled = true;\n\t\t\tenabled_lines.erase(current_line);\n\t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n\t\t\t\tint k = lv.at(ki);\n                if (k < 0 || k >= lines.size()) {\n                    LOG(message_group::Warning,Location::NONE,\"\",\n                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n                    continue;\n                }\n\t\t\t\tif (lines[k].disabled) continue;\n                auto idk0 = lines[k].idx[0];    // make it easier to read and debug\n                auto idk1 = lines[k].idx[1];\n\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 0;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n                if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {\n\t\t\t\t\tcurrent_line = k;\n\t\t\t\t\tcurrent_point = 1;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_closed_path:;\n\t\t}\n\t}\n\n\tfixup_path_direction();\n\n#if 0\n\tprintf(\"----- DXF Data -----\\n\");\n\tfor (int i = 0; i < this->paths.size(); ++i) {\n\t\tprintf(\"Path %d (%s):\\n\", i, this->paths[i].is_closed ? \"closed\" : \"open\");\n\t\tfor (int j = 0; j < this->paths[i].points.size(); ++j)\n\t\t\tprintf(\"  %f %f\\n\", (*this->paths[i].points[j])[0], (*this->paths[i].points[j])[1]);\n\t}\n\tprintf(\"--------------------\\n\");\n\tfflush(stdout);\n#endif\n}",
  "abstract_func": "DxfData::DxfData(double VAR_0, double VAR_1, double VAR_2, \n\t\t\t\t\t\t\t\t const std::string &VAR_3, const std::string &VAR_4, \n\t\t\t\t\t\t\t\t double VAR_5, double VAR_6, double VAR_7)\n{\n\tstd::ifstream VAR_8(VAR_3.c_str());\n\tif (!VAR_8.good()) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Can't open DXF file '%1$s'.\",VAR_3);\n\t\treturn;\n\t}\n\n\tGrid2d<std::vector<int>> grid(GRID_COARSE);\n\tstd::vector<Line> VAR_9;                       /* COMMENT_0 */\n\tstd::unordered_map<std::string, std::vector<Line>> VAR_10; /* COMMENT_1 */\n\n\tauto VAR_11 = false;\n\tauto VAR_12 = false;\n\tstd::string VAR_13;\n\n#define ADD_LINE(VAR_14, VAR_15, VAR_16, VAR_17) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tdouble _p1x = _x1, _p1y = _y1, _p2x = _x2, _p2y = _y2;  \\\n\t\tif (!in_entities_section && !in_blocks_section)         \\\n\t\t\tbreak;                                                \\\n\t\tif (in_entities_section &&                              \\\n\t\t\t\t!(layername.empty() || layername == layer))         \\\n\t\t\tbreak;                                                \\\n\t\tgrid.align(_p1x, _p1y);                                 \\\n\t\tgrid.align(_p2x, _p2y);                                 \\\n\t\tgrid.data(_p1x, _p1y).push_back(lines.size());          \\\n\t\tgrid.data(_p2x, _p2y).push_back(lines.size());          \\\n\t\tif (in_entities_section)                                \\\n\t\t\tlines.emplace_back(                                   \\\n\t\t\t  addPoint(_p1x, _p1y), addPoint(_p2x, _p2y));        \\\n\t\tif (in_blocks_section && !current_block.empty())        \\\n\t\t\tblockdata[current_block].emplace_back(\t              \\\n\t\t\t\taddPoint(_p1x, _p1y), addPoint(_p2x, _p2y));      \t\\\n\t} while (0)\n\n\tstd::string VAR_18, VAR_19, VAR_20, VAR_21;\n\tint VAR_22 = 0;\n\tdouble VAR_23[7][2]; /* COMMENT_2 */\n\tstd::vector<double> VAR_24;\n\tstd::vector<double> VAR_25;\n\tdouble VAR_26 = 0;\n\tdouble VAR_27 = 0, VAR_28 = 0;\n\tdouble VAR_29 = 0, VAR_30 = 0;\n\n\tfor (int VAR_31 = 0; VAR_31 < 7; ++VAR_31) {\n\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\tVAR_23[VAR_31][VAR_32] = 0;\n\t\t}\n\t}\n\n\ttypedef std::unordered_map<std::string, int> EntityList;\n\tEntityList VAR_33;\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_3 */\n\twhile (!VAR_8.eof())\t{\n\t\tstd::string VAR_34, VAR_35;\n\t\tstd::getline(VAR_8, VAR_34);\n\t\tboost::trim(VAR_34);\n\t\tstd::getline(VAR_8, VAR_35);\n\t\tboost::trim(VAR_35);\n\n\t\tint VAR_36;\n    try {\n\t\t  VAR_36 = boost::VAR_37<int>(VAR_34);\n    }\n    catch (const boost::bad_lexical_cast &VAR_38) {\n\t\t\tif (!VAR_8.eof()) {\n\t\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal ID '%1$s' in `%2$s'\",VAR_34,VAR_3);\n\t\t\t}\n\t\t\tbreak;\n  \t}\n    try {\n\t\tif (VAR_36 >= 10 && VAR_36 <= 16) {\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_23[VAR_36-10][0] = boost::VAR_37<double>(VAR_35);\n\t\t\t}\n\t\t\telse if (VAR_36 == 11 || VAR_36 == 12 || VAR_36 == 16) {\n\t\t\t\tVAR_23[VAR_36-10][0] = boost::VAR_37<double>(VAR_35) * VAR_7;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_23[VAR_36-10][0] = (boost::VAR_37<double>(VAR_35) - VAR_5) * VAR_7;\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_36 >= 20 && VAR_36 <= 26) {\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_23[VAR_36-20][1] = boost::VAR_37<double>(VAR_35);\n\t\t\t}\n\t\t\telse if (VAR_36 == 21 || VAR_36 == 22 || VAR_36 == 26) {\n\t\t\t\tVAR_23[VAR_36-20][1] = boost::VAR_37<double>(VAR_35) * VAR_7;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_23[VAR_36-20][1] = (boost::VAR_37<double>(VAR_35) - VAR_6) * VAR_7;\n\t\t\t}\n\t\t}\n\n\t\tswitch (VAR_36) {\n\t\tcase 0:\n\t\t\tif (VAR_18 == \"SECTION\") {\n\t\t\t\tVAR_11 = VAR_21 == \"ENTITIES\";\n\t\t\t\tVAR_12 = VAR_21 == \"BLOCKS\";\n\t\t\t}\n\t\t\telse if (VAR_18 == \"LINE\") {\n\t\t\t\tADD_LINE(VAR_24.at(0), VAR_25.at(0), VAR_24.at(1), VAR_25.at(1));\n\t\t\t}\n\t\t\telse if (VAR_18 == \"LWPOLYLINE\") {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tint VAR_39 = std::max(VAR_24.size(), VAR_25.size());\n\t\t\t\tfor (int VAR_31=1; VAR_31<VAR_39; ++VAR_31) {\n\t\t\t\t\tADD_LINE(VAR_24.at(VAR_31-1), VAR_25.at(VAR_31-1), VAR_24.at(VAR_31%VAR_39), VAR_25.at(VAR_31%VAR_39));\n\t\t\t\t}\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tif (VAR_22 & 0x01) { /* COMMENT_8 */\n\t\t\t\t\tADD_LINE(VAR_24.at(VAR_39-1), VAR_25.at(VAR_39-1), VAR_24.at(0), VAR_25.at(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"CIRCLE\") {\n\t\t\t\tint VAR_40 = Calc::get_fragments_from_r(VAR_26, VAR_0, VAR_1, VAR_2);\n\t\t\t\tVector2d VAR_41(VAR_24.at(0), VAR_25.at(0));\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_42 = (360.0 * VAR_31) / VAR_40;\n\t\t\t\t\tdouble VAR_43 = (360.0 *(VAR_31 + 1)) / VAR_40;\n\t\t\t\t\tADD_LINE(cos_degrees(VAR_42)*VAR_26 + VAR_41[0], sin_degrees(VAR_42)*VAR_26 + VAR_41[1],\n\t\t\t\t\t         cos_degrees(VAR_43)*VAR_26 + VAR_41[0], sin_degrees(VAR_43)*VAR_26 + VAR_41[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ARC\") {\n\t\t\t\tVector2d VAR_41(VAR_24.at(0), VAR_25.at(0));\n\t\t\t\tint VAR_40 = Calc::get_fragments_from_r(VAR_26, VAR_0, VAR_1, VAR_2);\n\t\t\t\twhile (VAR_27 > VAR_28) {\n\t\t\t\t\tVAR_28 += 360.0;\n\t\t\t\t}\n\t\t\t\tdouble VAR_44 = VAR_28 - VAR_27;\n\t\t\t\tVAR_40 = VAR_45<int>(ceil(VAR_40 * VAR_44 / 360));\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_42 = VAR_27 + VAR_44 * VAR_31 / VAR_40;\n\t\t\t\t\tdouble VAR_43 = VAR_27 + VAR_44 * (VAR_31 + 1) / VAR_40;\n\t\t\t\t\tADD_LINE(cos_degrees(VAR_42)*VAR_26 + VAR_41[0], sin_degrees(VAR_42)*VAR_26 + VAR_41[1],\n\t\t\t\t\t         cos_degrees(VAR_43)*VAR_26 + VAR_41[0], sin_degrees(VAR_43)*VAR_26 + VAR_41[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ELLIPSE\") {\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\twhile (VAR_29 > VAR_30) VAR_30 += 2 * VAR_46;\n/* COMMENT_10 */\n\t\t\t\tVector2d VAR_41(VAR_24.at(0), VAR_25.at(0));\n/* COMMENT_11 */\n\t\t\t\tVector2d VAR_47(VAR_24.at(1), VAR_25.at(1));\n/* COMMENT_12 */\n\t\t\t\tdouble VAR_48 = sqrt(VAR_47[0]*VAR_47[0] + VAR_47[1]*VAR_47[1]);\n/* COMMENT_13 */\n\t\t\t\tdouble VAR_49;\n\t\t\t\t{\n/* COMMENT_14 */\n\t\t\t\t\tdouble VAR_50 = VAR_47[0];\n\t\t\t\t\tdouble VAR_51 = VAR_50 / VAR_48;\n\t\t\t\t\tif (VAR_51 > 1.0) VAR_51 = 1.0;\n\t\t\t\t\tif (VAR_51 < -1.0) VAR_51 = -1.0;\n\t\t\t\t\tVAR_49 = acos(VAR_51);\n\t\t\t\t\tif (VAR_47[1] < 0.0) VAR_49 = 2 * VAR_46 - VAR_49;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tdouble VAR_52 = VAR_48 * VAR_26;\n\t\t\t\tdouble VAR_53 = VAR_30-VAR_29;\n\t\t\t\tint VAR_40 = Calc::get_fragments_from_r(VAR_48, VAR_0, VAR_1, VAR_2);\n\t\t\t\tVAR_40 = VAR_45<int>(ceil(VAR_40 * VAR_53 / (2 * VAR_46)));\n/* COMMENT_16 */\n\t\t\t\tVector2d VAR_54{0.0, 0.0};\n\t\t\t\tfor (int VAR_31=0; VAR_31<=VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_55 = (VAR_29 + VAR_53*VAR_31/VAR_40);\n/* COMMENT_17 */\n\t\t\t\t\tVector2d VAR_56(cos(VAR_55)*VAR_48, sin(VAR_55)*VAR_52);\n/* COMMENT_18 */\n\t\t\t\t\tVector2d VAR_57(cos(VAR_49)*VAR_56[0] - sin(VAR_49)*VAR_56[1],\n\t\t\t\t\t                sin(VAR_49)*VAR_56[0] + cos(VAR_49)*VAR_56[1]);\n/* COMMENT_19 */\n\t\t\t\t\tVAR_57[0] += VAR_41[0];\n\t\t\t\t\tVAR_57[1] += VAR_41[1];\n\t\t\t\t\tif (VAR_31 > 0) {\n/* COMMENT_20 */\n\t\t\t\t\t\tADD_LINE(VAR_54[0], VAR_54[1], VAR_57[0], VAR_57[1]);\n\t\t\t\t\t}\n/* COMMENT_21 */\n\t\t\t\t\tVAR_54[0] = VAR_57[0];\n\t\t\t\t\tVAR_54[1] = VAR_57[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"INSERT\") {\n\t\t\t\t/* COMMENT_22 */\n\t\t\t\t/* COMMENT_23 */\n\t\t\t\tint VAR_40 = VAR_10[VAR_21].size();\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < VAR_40; ++VAR_31) {\n\t\t\t\t\tdouble VAR_55 = VAR_27;\n\t\t\t\t\tdouble VAR_58 = this->points[VAR_10[VAR_21][VAR_31].idx[0]][0] * VAR_29;\n\t\t\t\t\tdouble VAR_59 = this->points[VAR_10[VAR_21][VAR_31].idx[0]][1] * VAR_30;\n\t\t\t\t\tdouble VAR_60 = this->points[VAR_10[VAR_21][VAR_31].idx[1]][0] * VAR_29;\n\t\t\t\t\tdouble VAR_61 = this->points[VAR_10[VAR_21][VAR_31].idx[1]][1] * VAR_30;\n\t\t\t\t\tdouble VAR_62 = (cos_degrees(VAR_55)*VAR_58 - sin_degrees(VAR_55)*VAR_59) * VAR_7 + VAR_24.at(0);\n\t\t\t\t\tdouble VAR_63 = (sin_degrees(VAR_55)*VAR_58 + cos_degrees(VAR_55)*VAR_59) * VAR_7 + VAR_25.at(0);\n\t\t\t\t\tdouble VAR_64 = (cos_degrees(VAR_55)*VAR_60 - sin_degrees(VAR_55)*VAR_61) * VAR_7 + VAR_24.at(0);\n\t\t\t\t\tdouble VAR_65 = (sin_degrees(VAR_55)*VAR_60 + cos_degrees(VAR_55)*VAR_61) * VAR_7 + VAR_25.at(0);\n\t\t\t\t\tADD_LINE(VAR_62, VAR_63, VAR_64, VAR_65);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (VAR_18 == \"DIMENSION\" &&\n\t\t\t\t\t\t\t (VAR_4.empty() || VAR_4 == VAR_19)) {\n\t\t\t\tthis->dims.push_back(Dim());\n\t\t\t\tthis->dims.back().type = VAR_22;\n\t\t\t\tfor (int VAR_31 = 0; VAR_31 < 7; ++VAR_31) {\n\t\t\t\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\t\t\t\tthis->dims.back().coords[VAR_31][VAR_32] = VAR_23[VAR_31][VAR_32];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis->dims.back().angle = VAR_27;\n\t\t\t\tthis->dims.back().length = VAR_26;\n\t\t\t\tthis->dims.back().name = VAR_20;\n\t\t\t}\n\t\t\telse if (VAR_18 == \"BLOCK\") {\n\t\t\t\tVAR_13 = VAR_21;\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ENDBLK\") {\n\t\t\t\tVAR_13.erase();\n\t\t\t}\n\t\t\telse if (VAR_18 == \"ENDSEC\") {\n\t\t\t}\n\t\t\telse if (VAR_12 || (VAR_11 &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (VAR_4.empty() || VAR_4 == VAR_19))) {\n\t\t\t\tVAR_33[VAR_18]++;\n\t\t\t}\n\t\t\tVAR_18 = VAR_35;\n\t\t\tVAR_19.erase();\n\t\t\tVAR_20.erase();\n\t\t\tVAR_21.erase();\n\t\t\tVAR_22 = 0;\n\t\t\tfor (int VAR_31 = 0; VAR_31 < 7; ++VAR_31) {\n\t\t\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\t\t\tVAR_23[VAR_31][VAR_32] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_24.clear();\n\t\t\tVAR_25.clear();\n\t\t\tVAR_26 = VAR_27 = VAR_28 = 0;\n\t\t\tVAR_29 = VAR_30 = 0;\n\t\t\tif (VAR_18 == \"INSERT\") {\n\t\t\t\tVAR_29 = VAR_30 = 1.0; /* COMMENT_24 */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tVAR_20 = VAR_35;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_21 = VAR_35;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tVAR_19 = VAR_35;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35) - VAR_5) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_24.push_back((boost::VAR_37<double>(VAR_35) - VAR_5) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35) - VAR_6) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tif (VAR_12) {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_25.push_back((boost::VAR_37<double>(VAR_35) - VAR_6) * VAR_7);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\t/* COMMENT_25 */\n\t\t\t/* COMMENT_26 */\n\t\t\t/* COMMENT_27 */\n\t\t\tVAR_26 = boost::VAR_37<double>(VAR_35);\n\t\t\tif (!VAR_12) VAR_26 *= VAR_7;\n\t\t\tbreak;\n\t\tcase 41:\n\t\t\t/* COMMENT_28 */\n\t\t\t/* COMMENT_29 */\n\t\t\tVAR_29 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\t/* COMMENT_30 */\n\t\t\t/* COMMENT_31 */\n      /* COMMENT_32 */\n\t\t\tVAR_27 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\t/* COMMENT_33 */\n\t\t\t/* COMMENT_34 */\n\t\t\tVAR_30 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 51: /* COMMENT_35 */\n\t\t\tVAR_28 = boost::VAR_37<double>(VAR_35);\n\t\t\tbreak;\n\t\tcase 70:\n\t\t\t/* COMMENT_36 */\n\t\t\t/* COMMENT_37 */\n\t\t\tVAR_22 = boost::VAR_37<int>(VAR_35);\n\t\t\tbreak;\n\t\t}\n    }\n    catch (boost::bad_lexical_cast &VAR_38) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Illegal value '%1$s'in `%2$s'\",VAR_35,VAR_3);\n  \t}\n    catch (const std::out_of_range& VAR_66) {\n\t\tLOG(message_group::Warning,Location::NONE,\"\",\"Not enough input values for %1$s. in '%2$s'\",VAR_35,VAR_3);\n  \t}\n\t}\n\n\tfor (const auto &VAR_31 : VAR_33) {\n\t\tif (VAR_4.empty()) {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in %3$s.\",VAR_31.first,VAR_31.second,QuotedString(boostfs_uncomplete(VAR_3, fs::current_path()).generic_string()));\n\t\t} else {\n\t\t\tLOG(message_group::Warning,Location::NONE,\"\",\n\t\t\t\t\"Unsupported DXF Entity '%1$s' (%2$x) in layer '%3$s' of %4$s\",VAR_31.first,VAR_31.second,VAR_4,boostfs_uncomplete(VAR_3, fs::current_path()).generic_string());\n\t\t}\n\t}\n\n\t/* COMMENT_38 */\n\n\ttypedef std::map<int, int> LineMap;\n\tLineMap VAR_67;\n\tfor (size_t VAR_31 = 0; VAR_31 < VAR_9.size(); ++VAR_31) {\n\t\tVAR_67[VAR_31] = VAR_31;\n\t}\n\n\t/* COMMENT_39 */\n\twhile (VAR_67.size() > 0) {\n\t\tint VAR_68, VAR_69;\n\n\t\tfor (const auto &VAR_70 : VAR_67) {\n\t\t\tint VAR_71 = VAR_70.second;\n\t\t\tfor (int VAR_32 = 0; VAR_32 < 2; ++VAR_32) {\n\t\t\t\tauto VAR_72 = VAR_73.data(this->points[VAR_9[VAR_71].idx[VAR_32]][0], this->points[VAR_9[VAR_71].idx[VAR_32]][1]);\n\t\t\t\tfor (size_t VAR_74 = 0; VAR_74 < VAR_72.size(); ++VAR_74) {\n\t\t\t\t\tint VAR_75 = VAR_72.at(VAR_74);\n                    if (VAR_75 < 0 || VAR_75 >= VAR_9.size()) {\n                        LOG(message_group::Warning,Location::NONE,\"\",\n                            \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(VAR_3, fs::current_path()).generic_string()));\n                        continue;\n                    }\n\t\t\t\t\tif (VAR_75 == VAR_71 || VAR_9[VAR_75].disabled) continue;\n\t\t\t\t\tgoto next_open_path_j;\n\t\t\t\t}\n\t\t\t\tVAR_68 = VAR_71;\n\t\t\t\tVAR_69 = VAR_32;\n\t\t\t\tgoto create_open_path;\n\t\t\tnext_open_path_j:;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcreate_open_path:\n\t\tthis->paths.push_back(Path());\n\t\tPath *VAR_76 = &this->paths.back();\n\n\t\tVAR_76->indices.push_back(VAR_9[VAR_68].idx[VAR_69]);\n\t\twhile (1) {\n\t\t\tVAR_76->indices.push_back(VAR_9[VAR_68].idx[!VAR_69]);\n\t\t\tconst auto &VAR_77 = this->points[VAR_9[VAR_68].idx[!VAR_69]];\n\t\t\tVAR_9[VAR_68].disabled = true;\n\t\t\tVAR_67.erase(VAR_68);\n\t\t\tauto VAR_72 = VAR_73.data(VAR_77[0], VAR_77[1]);\n\t\t\tfor (size_t VAR_74 = 0; VAR_74 < VAR_72.size(); ++VAR_74) {\n\t\t\t\tint VAR_75 = VAR_72.at(VAR_74);\n                if (VAR_75 < 0 || VAR_75 >= VAR_9.size()) {\n                    LOG(message_group::Warning,Location::NONE,\"\",\n                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(VAR_3, fs::current_path()).generic_string()));\n                    continue;\n                }\n\t\t\t\tif (VAR_9[VAR_75].disabled) continue;\n                auto VAR_78 = VAR_9[VAR_75].idx[0];    /* COMMENT_40 */\n                auto VAR_79 = VAR_9[VAR_75].idx[1];\n\t\t\t\tif (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_78][0], this->points[VAR_78][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 0;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t\tif (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_79][0], this->points[VAR_79][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 1;\n\t\t\t\t\tgoto found_next_line_in_open_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_open_path:;\n\t\t}\n\t}\n\n\t/* COMMENT_41 */\n\twhile (VAR_67.size() > 0) {\n\t\tint VAR_68 = VAR_67.begin()->second;\n\t\tint VAR_69 = 0;\n\n\t\tthis->paths.push_back(Path());\n\t\tauto& VAR_76 = this->paths.back();\n\t\tVAR_76.is_closed = true;\n\t\t\n\t\tVAR_76.indices.push_back(VAR_9[VAR_68].idx[VAR_69]);\n\t\twhile (1) {\n\t\t\tVAR_76.indices.push_back(VAR_9[VAR_68].idx[!VAR_69]);\n\t\t\tconst auto &VAR_77 = this->points[VAR_9[VAR_68].idx[!VAR_69]];\n\t\t\tVAR_9[VAR_68].disabled = true;\n\t\t\tVAR_67.erase(VAR_68);\n\t\t\tauto VAR_72 = VAR_73.data(VAR_77[0], VAR_77[1]);\n\t\t\tfor (size_t VAR_74 = 0; VAR_74 < VAR_72.size(); ++VAR_74) {\n\t\t\t\tint VAR_75 = VAR_72.at(VAR_74);\n                if (VAR_75 < 0 || VAR_75 >= VAR_9.size()) {\n                    LOG(message_group::Warning,Location::NONE,\"\",\n                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(VAR_3, fs::current_path()).generic_string()));\n                    continue;\n                }\n\t\t\t\tif (VAR_9[VAR_75].disabled) continue;\n                auto VAR_78 = VAR_9[VAR_75].idx[0];    /* COMMENT_40 */\n                auto VAR_79 = VAR_9[VAR_75].idx[1];\n\t\t\t\tif (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_78][0], this->points[VAR_78][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 0;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n                if (VAR_73.eq(VAR_77[0], VAR_77[1], this->points[VAR_79][0], this->points[VAR_79][1])) {\n\t\t\t\t\tVAR_68 = VAR_75;\n\t\t\t\t\tVAR_69 = 1;\n\t\t\t\t\tgoto found_next_line_in_closed_path;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tfound_next_line_in_closed_path:;\n\t\t}\n\t}\n\n\tfixup_path_direction();\n\n#if 0\n\tprintf(\"----- DXF Data -----\\n\");\n\tfor (int VAR_31 = 0; VAR_31 < this->paths.size(); ++VAR_31) {\n\t\tprintf(\"Path %d (%s):\\n\", VAR_31, this->paths[VAR_31].is_closed ? \"closed\" : \"open\");\n\t\tfor (int VAR_32 = 0; VAR_32 < this->paths[VAR_31].points.size(); ++VAR_32)\n\t\t\tprintf(\"  %f %f\\n\", (*this->paths[VAR_31].points[VAR_32])[0], (*this->paths[VAR_31].points[VAR_32])[1]);\n\t}\n\tprintf(\"--------------------\\n\");\n\tfflush(VAR_80);\n#endif\n}",
  "func_graph_path": "openscad/770e3234cbfe66edbc0333f796b46d36a74aa652/dxfdata.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -361,6 +361,11 @@\n \t\t\t\tauto lv = grid.data(this->points[lines[idx].idx[j]][0], this->points[lines[idx].idx[j]][1]);\n \t\t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n \t\t\t\t\tint k = lv.at(ki);\n+                    if (k < 0 || k >= lines.size()) {\n+                        LOG(message_group::Warning,Location::NONE,\"\",\n+                            \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n+                        continue;\n+                    }\n \t\t\t\t\tif (k == idx || lines[k].disabled) continue;\n \t\t\t\t\tgoto next_open_path_j;\n \t\t\t\t}\n@@ -386,13 +391,20 @@\n \t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n \t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n \t\t\t\tint k = lv.at(ki);\n+                if (k < 0 || k >= lines.size()) {\n+                    LOG(message_group::Warning,Location::NONE,\"\",\n+                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n+                    continue;\n+                }\n \t\t\t\tif (lines[k].disabled) continue;\n-\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {\n+                auto idk0 = lines[k].idx[0];    // make it easier to read and debug\n+                auto idk1 = lines[k].idx[1];\n+\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {\n \t\t\t\t\tcurrent_line = k;\n \t\t\t\t\tcurrent_point = 0;\n \t\t\t\t\tgoto found_next_line_in_open_path;\n \t\t\t\t}\n-\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {\n+\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {\n \t\t\t\t\tcurrent_line = k;\n \t\t\t\t\tcurrent_point = 1;\n \t\t\t\t\tgoto found_next_line_in_open_path;\n@@ -421,13 +433,20 @@\n \t\t\tauto lv = grid.data(ref_point[0], ref_point[1]);\n \t\t\tfor (size_t ki = 0; ki < lv.size(); ++ki) {\n \t\t\t\tint k = lv.at(ki);\n+                if (k < 0 || k >= lines.size()) {\n+                    LOG(message_group::Warning,Location::NONE,\"\",\n+                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));\n+                    continue;\n+                }\n \t\t\t\tif (lines[k].disabled) continue;\n-\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {\n+                auto idk0 = lines[k].idx[0];    // make it easier to read and debug\n+                auto idk1 = lines[k].idx[1];\n+\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {\n \t\t\t\t\tcurrent_line = k;\n \t\t\t\t\tcurrent_point = 0;\n \t\t\t\t\tgoto found_next_line_in_closed_path;\n \t\t\t\t}\n-\t\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {\n+                if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {\n \t\t\t\t\tcurrent_line = k;\n \t\t\t\t\tcurrent_point = 1;\n \t\t\t\t\tgoto found_next_line_in_closed_path;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {",
      "\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {",
      "\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[0]][0], this->points[lines[k].idx[0]][1])) {",
      "\t\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[lines[k].idx[1]][0], this->points[lines[k].idx[1]][1])) {"
    ],
    "added_lines": [
      "                    if (k < 0 || k >= lines.size()) {",
      "                        LOG(message_group::Warning,Location::NONE,\"\",",
      "                            \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));",
      "                        continue;",
      "                    }",
      "                if (k < 0 || k >= lines.size()) {",
      "                    LOG(message_group::Warning,Location::NONE,\"\",",
      "                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));",
      "                    continue;",
      "                }",
      "                auto idk0 = lines[k].idx[0];    // make it easier to read and debug",
      "                auto idk1 = lines[k].idx[1];",
      "\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {",
      "\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {",
      "                if (k < 0 || k >= lines.size()) {",
      "                    LOG(message_group::Warning,Location::NONE,\"\",",
      "                        \"Bad DXF line index in %1$s.\",QuotedString(boostfs_uncomplete(filename, fs::current_path()).generic_string()));",
      "                    continue;",
      "                }",
      "                auto idk0 = lines[k].idx[0];    // make it easier to read and debug",
      "                auto idk1 = lines[k].idx[1];",
      "\t\t\t\tif (grid.eq(ref_point[0], ref_point[1], this->points[idk0][0], this->points[idk0][1])) {",
      "                if (grid.eq(ref_point[0], ref_point[1], this->points[idk1][0], this->points[idk1][1])) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openscad/openscad/pull/4090",
  "description": {
    "pr_info": {
      "title": "Add safety to line lookups in DXF import (fixes #4037)",
      "number": 4090
    },
    "comment": [
      "* Add safety (test for, and continue past, bad indices)\r\n* Report warnings about bad indices\r\n* Add variables just to make the array indices easier to read and debug"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9\n\n**Explanation:**\nThe patch addresses handling of indices to prevent out-of-bounds access, improving robustness but not directly fixing a security flaw. The changes are related to bug fixing, not security."
}