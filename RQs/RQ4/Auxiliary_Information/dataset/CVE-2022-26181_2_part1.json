{
  "cve_id": "CVE-2022-26181",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "dropbox/lepton",
  "commit_msg": "Fix wild free.\n\n`huffdata` is initially allocated using `aligned_dealloc` but can be\nreplaced with `data2` which is allocated using `custom_calloc`.\nThis can cause a wild free when `aligned_dealloc(huffdata)` is called.\nFix by replacing allocation sites with aligned_alloc.\n\nNoticed and fixed a similar problem with `hdrdata`.",
  "commit_hash": "4e591ffd0127ac064c4749e523458a923b29cc75",
  "git_url": "https://github.com/dropbox/lepton/commit/4e591ffd0127ac064c4749e523458a923b29cc75",
  "file_path": "src/lepton/jpgcoder.cc",
  "func_name": "rebuild_header_jpg",
  "func_before": "bool rebuild_header_jpg( void )\n{\n    abytewriter* hdrw; // new header writer\n\n    unsigned char  type = 0x00; // type of current marker segment\n    uint32_t   len  = 0; // length of current marker segment\n    uint32_t   hpos = 0; // position in header\n\n\n    // start headerwriter\n    hdrw = new abytewriter( 4096 );\n\n    // header parser loop\n    while ( hpos < hdrs && (uint64_t)hpos + 3 < (uint64_t)hdrs ) {\n        type = hpos + 1 < hdrs ?  hdrdata[ hpos + 1 ] : 0;\n        len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0);\n        // discard any unneeded meta info\n        if ( ( type == 0xDA ) || ( type == 0xC4 ) || ( type == 0xDB ) ||\n             ( type == 0xC0 ) || ( type == 0xC1 ) || ( type == 0xC2 ) ||\n             ( type == 0xDD ) ) {\n            uint32_t to_copy = hpos + len < hdrs ? len : hdrs - hpos;\n            hdrw->write_n( &(hdrdata[ hpos ]), to_copy);\n            if (to_copy <  len) {\n                for (uint32_t i = 0;i <to_copy -len;++i) {\n                    uint8_t zero = 0;\n                    hdrw->write_n(&zero, 1);\n                }\n            }\n        }\n        hpos += len;\n    }\n\n    // replace current header with the new one\n    custom_free( hdrdata );\n    hdrdata = hdrw->getptr_aligned();\n    hdrs    = hdrw->getpos();\n    delete( hdrw );\n\n\n    return true;\n}",
  "abstract_func_before": "bool rebuild_header_jpg( void )\n{\n    abytewriter* VAR_0; /* COMMENT_0 */\n\n    unsigned char  VAR_1 = 0x00; /* COMMENT_1 */\n    uint32_t   VAR_2  = 0; /* COMMENT_2 */\n    uint32_t   VAR_3 = 0; /* COMMENT_3 */\n\n\n    /* COMMENT_4 */\n    VAR_0 = new abytewriter( 4096 );\n\n    /* COMMENT_5 */\n    while ( VAR_3 < VAR_4 && (uint64_t)VAR_3 + 3 < (uint64_t)VAR_4 ) {\n        VAR_1 = VAR_3 + 1 < VAR_4 ?  VAR_5[ VAR_3 + 1 ] : 0;\n        VAR_2 = 2 + B_SHORT( VAR_3 + 2 < VAR_4 ? VAR_5[ VAR_3 + 2 ]:0, VAR_3 + 3 < VAR_4 ? VAR_5[ VAR_3 + 3 ] :0);\n        /* COMMENT_6 */\n        if ( ( VAR_1 == 0xDA ) || ( VAR_1 == 0xC4 ) || ( VAR_1 == 0xDB ) ||\n             ( VAR_1 == 0xC0 ) || ( VAR_1 == 0xC1 ) || ( VAR_1 == 0xC2 ) ||\n             ( VAR_1 == 0xDD ) ) {\n            uint32_t VAR_6 = VAR_3 + VAR_2 < VAR_4 ? VAR_2 : VAR_4 - VAR_3;\n            VAR_0->write_n( &(VAR_5[ VAR_3 ]), VAR_6);\n            if (VAR_6 <  VAR_2) {\n                for (uint32_t VAR_7 = 0;VAR_7 <VAR_6 -VAR_2;++VAR_7) {\n                    uint8_t VAR_8 = 0;\n                    VAR_0->write_n(&VAR_8, 1);\n                }\n            }\n        }\n        VAR_3 += VAR_2;\n    }\n\n    /* COMMENT_7 */\n    custom_free( VAR_5 );\n    VAR_5 = VAR_0->getptr_aligned();\n    VAR_4    = VAR_0->getpos();\n    delete( VAR_0 );\n\n\n    return true;\n}",
  "func_graph_path_before": "dropbox/lepton/4e591ffd0127ac064c4749e523458a923b29cc75/jpgcoder.cc/vul/before/0.json",
  "func": "bool rebuild_header_jpg( void )\n{\n    abytewriter* hdrw; // new header writer\n\n    unsigned char  type = 0x00; // type of current marker segment\n    uint32_t   len  = 0; // length of current marker segment\n    uint32_t   hpos = 0; // position in header\n\n\n    // start headerwriter\n    hdrw = new abytewriter( 4096 );\n\n    // header parser loop\n    while ( hpos < hdrs && (uint64_t)hpos + 3 < (uint64_t)hdrs ) {\n        type = hpos + 1 < hdrs ?  hdrdata[ hpos + 1 ] : 0;\n        len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0);\n        // discard any unneeded meta info\n        if ( ( type == 0xDA ) || ( type == 0xC4 ) || ( type == 0xDB ) ||\n             ( type == 0xC0 ) || ( type == 0xC1 ) || ( type == 0xC2 ) ||\n             ( type == 0xDD ) ) {\n            uint32_t to_copy = hpos + len < hdrs ? len : hdrs - hpos;\n            hdrw->write_n( &(hdrdata[ hpos ]), to_copy);\n            if (to_copy <  len) {\n                for (uint32_t i = 0;i <to_copy -len;++i) {\n                    uint8_t zero = 0;\n                    hdrw->write_n(&zero, 1);\n                }\n            }\n        }\n        hpos += len;\n    }\n\n    // replace current header with the new one\n    aligned_dealloc( hdrdata );\n    hdrdata = hdrw->getptr_aligned();\n    hdrs    = hdrw->getpos();\n    delete( hdrw );\n\n\n    return true;\n}",
  "abstract_func": "bool rebuild_header_jpg( void )\n{\n    abytewriter* VAR_0; /* COMMENT_0 */\n\n    unsigned char  VAR_1 = 0x00; /* COMMENT_1 */\n    uint32_t   VAR_2  = 0; /* COMMENT_2 */\n    uint32_t   VAR_3 = 0; /* COMMENT_3 */\n\n\n    /* COMMENT_4 */\n    VAR_0 = new abytewriter( 4096 );\n\n    /* COMMENT_5 */\n    while ( VAR_3 < VAR_4 && (uint64_t)VAR_3 + 3 < (uint64_t)VAR_4 ) {\n        VAR_1 = VAR_3 + 1 < VAR_4 ?  VAR_5[ VAR_3 + 1 ] : 0;\n        VAR_2 = 2 + B_SHORT( VAR_3 + 2 < VAR_4 ? VAR_5[ VAR_3 + 2 ]:0, VAR_3 + 3 < VAR_4 ? VAR_5[ VAR_3 + 3 ] :0);\n        /* COMMENT_6 */\n        if ( ( VAR_1 == 0xDA ) || ( VAR_1 == 0xC4 ) || ( VAR_1 == 0xDB ) ||\n             ( VAR_1 == 0xC0 ) || ( VAR_1 == 0xC1 ) || ( VAR_1 == 0xC2 ) ||\n             ( VAR_1 == 0xDD ) ) {\n            uint32_t VAR_6 = VAR_3 + VAR_2 < VAR_4 ? VAR_2 : VAR_4 - VAR_3;\n            VAR_0->write_n( &(VAR_5[ VAR_3 ]), VAR_6);\n            if (VAR_6 <  VAR_2) {\n                for (uint32_t VAR_7 = 0;VAR_7 <VAR_6 -VAR_2;++VAR_7) {\n                    uint8_t VAR_8 = 0;\n                    VAR_0->write_n(&VAR_8, 1);\n                }\n            }\n        }\n        VAR_3 += VAR_2;\n    }\n\n    /* COMMENT_7 */\n    aligned_dealloc( VAR_5 );\n    VAR_5 = VAR_0->getptr_aligned();\n    VAR_4    = VAR_0->getpos();\n    delete( VAR_0 );\n\n\n    return true;\n}",
  "func_graph_path": "dropbox/lepton/4e591ffd0127ac064c4749e523458a923b29cc75/jpgcoder.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n     }\n \n     // replace current header with the new one\n-    custom_free( hdrdata );\n+    aligned_dealloc( hdrdata );\n     hdrdata = hdrw->getptr_aligned();\n     hdrs    = hdrw->getpos();\n     delete( hdrw );",
  "diff_line_info": {
    "deleted_lines": [
      "    custom_free( hdrdata );"
    ],
    "added_lines": [
      "    aligned_dealloc( hdrdata );"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/dropbox/lepton/pull/155",
  "description": {
    "pr_info": {
      "title": "Fix wild free.",
      "number": 155
    },
    "comment": [
      "`huffdata` is initially allocated using `aligned_dealloc` but can be\r\nreplaced with `data2` which is allocated using `custom_calloc`.\r\nThis can cause a wild free when `aligned_dealloc(huffdata)` is called.\r\nFix by replacing allocation sites with aligned_alloc.\r\n\r\nNoticed and fixed a similar problem with `hdrdata`.\r\n\r\nFixes #154."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch fixes a memory management issue causing a wild free, which is a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}