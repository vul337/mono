{
  "cve_id": "CVE-2018-25021",
  "cwe_ids": [
    "CWE-404"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "TokTok/c-toxcore",
  "commit_msg": "Fix memleak in tcp server by wiping priority queues on deletion",
  "commit_hash": "5beb00c93d3adb5c23149535624d27c67bc146ea",
  "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
  "file_path": "toxcore/TCP_server.c",
  "func_name": "do_incoming",
  "func_before": "static int do_incoming(TCP_Server *tcp_server, uint32_t i)\n{\n    if (tcp_server->incoming_connection_queue[i].status != TCP_STATUS_CONNECTED) {\n        return -1;\n    }\n\n    int ret = read_connection_handshake(&tcp_server->incoming_connection_queue[i], tcp_server->secret_key);\n\n    if (ret == -1) {\n        kill_TCP_secure_connection(&tcp_server->incoming_connection_queue[i]);\n    } else if (ret == 1) {\n        int index_new = tcp_server->unconfirmed_connection_queue_index % MAX_INCOMING_CONNECTIONS;\n        TCP_Secure_Connection *conn_old = &tcp_server->incoming_connection_queue[i];\n        TCP_Secure_Connection *conn_new = &tcp_server->unconfirmed_connection_queue[index_new];\n\n        if (conn_new->status != TCP_STATUS_NO_STATUS) {\n            kill_TCP_secure_connection(conn_new);\n        }\n\n        memcpy(conn_new, conn_old, sizeof(TCP_Secure_Connection));\n        crypto_memzero(conn_old, sizeof(TCP_Secure_Connection));\n        ++tcp_server->unconfirmed_connection_queue_index;\n\n        return index_new;\n    }\n\n    return -1;\n}",
  "abstract_func_before": "static int do_incoming(TCP_Server *VAR_0, uint32_t VAR_1)\n{\n    if (VAR_0->incoming_connection_queue[VAR_1].status != VAR_2) {\n        return -1;\n    }\n\n    int VAR_3 = read_connection_handshake(&VAR_0->incoming_connection_queue[VAR_1], VAR_0->secret_key);\n\n    if (VAR_3 == -1) {\n        kill_TCP_secure_connection(&VAR_0->incoming_connection_queue[VAR_1]);\n    } else if (VAR_3 == 1) {\n        int VAR_4 = VAR_0->unconfirmed_connection_queue_index % VAR_5;\n        TCP_Secure_Connection *VAR_6 = &VAR_0->incoming_connection_queue[VAR_1];\n        TCP_Secure_Connection *VAR_7 = &VAR_0->unconfirmed_connection_queue[VAR_4];\n\n        if (VAR_7->status != VAR_8) {\n            kill_TCP_secure_connection(VAR_7);\n        }\n\n        memcpy(VAR_7, VAR_6, sizeof(TCP_Secure_Connection));\n        crypto_memzero(VAR_6, sizeof(TCP_Secure_Connection));\n        ++VAR_0->unconfirmed_connection_queue_index;\n\n        return VAR_4;\n    }\n\n    return -1;\n}",
  "func_graph_path_before": "TokTok/c-toxcore/5beb00c93d3adb5c23149535624d27c67bc146ea/TCP_server.c/vul/before/4.json",
  "func": "static int do_incoming(TCP_Server *tcp_server, uint32_t i)\n{\n    if (tcp_server->incoming_connection_queue[i].status != TCP_STATUS_CONNECTED) {\n        return -1;\n    }\n\n    int ret = read_connection_handshake(&tcp_server->incoming_connection_queue[i], tcp_server->secret_key);\n\n    if (ret == -1) {\n        kill_TCP_secure_connection(&tcp_server->incoming_connection_queue[i]);\n    } else if (ret == 1) {\n        int index_new = tcp_server->unconfirmed_connection_queue_index % MAX_INCOMING_CONNECTIONS;\n        TCP_Secure_Connection *conn_old = &tcp_server->incoming_connection_queue[i];\n        TCP_Secure_Connection *conn_new = &tcp_server->unconfirmed_connection_queue[index_new];\n\n        if (conn_new->status != TCP_STATUS_NO_STATUS) {\n            kill_TCP_secure_connection(conn_new);\n        }\n\n        move_secure_connection(conn_new, conn_old);\n        ++tcp_server->unconfirmed_connection_queue_index;\n\n        return index_new;\n    }\n\n    return -1;\n}",
  "abstract_func": "static int do_incoming(TCP_Server *VAR_0, uint32_t VAR_1)\n{\n    if (VAR_0->incoming_connection_queue[VAR_1].status != VAR_2) {\n        return -1;\n    }\n\n    int VAR_3 = read_connection_handshake(&VAR_0->incoming_connection_queue[VAR_1], VAR_0->secret_key);\n\n    if (VAR_3 == -1) {\n        kill_TCP_secure_connection(&VAR_0->incoming_connection_queue[VAR_1]);\n    } else if (VAR_3 == 1) {\n        int VAR_4 = VAR_0->unconfirmed_connection_queue_index % VAR_5;\n        TCP_Secure_Connection *VAR_6 = &VAR_0->incoming_connection_queue[VAR_1];\n        TCP_Secure_Connection *VAR_7 = &VAR_0->unconfirmed_connection_queue[VAR_4];\n\n        if (VAR_7->status != VAR_8) {\n            kill_TCP_secure_connection(VAR_7);\n        }\n\n        move_secure_connection(VAR_7, VAR_6);\n        ++VAR_0->unconfirmed_connection_queue_index;\n\n        return VAR_4;\n    }\n\n    return -1;\n}",
  "func_graph_path": "TokTok/c-toxcore/5beb00c93d3adb5c23149535624d27c67bc146ea/TCP_server.c/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,7 @@\n             kill_TCP_secure_connection(conn_new);\n         }\n \n-        memcpy(conn_new, conn_old, sizeof(TCP_Secure_Connection));\n-        crypto_memzero(conn_old, sizeof(TCP_Secure_Connection));\n+        move_secure_connection(conn_new, conn_old);\n         ++tcp_server->unconfirmed_connection_queue_index;\n \n         return index_new;",
  "diff_line_info": {
    "deleted_lines": [
      "        memcpy(conn_new, conn_old, sizeof(TCP_Secure_Connection));",
      "        crypto_memzero(conn_old, sizeof(TCP_Secure_Connection));"
    ],
    "added_lines": [
      "        move_secure_connection(conn_new, conn_old);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/TokTok/c-toxcore/pull/1216",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/TokTok/c-toxcore/pull/1216: 403 Client Error: Forbidden for url: https://api.github.com/repos/TokTok/c-toxcore/pulls/1216",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The commit addresses a memory leak in the TCP server by improving how secure connections are moved and cleaned up, which is a security concern. The changes prevent resource exhaustion and data exposure, thus qualifying as a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}