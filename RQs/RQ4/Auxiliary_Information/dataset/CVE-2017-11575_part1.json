{
  "cve_id": "CVE-2017-11575",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fontforge",
  "commit_msg": "Fix out of bounds read condition and buffer overflow condition\n\n* parsettf.c: Reading past the end of the fontnames array\n* psread.c: Reading more data than is available in type1\n* tottf.c: Use snprintf instead of sprintf\n\nCloses #3096",
  "commit_hash": "4de0c58a01e5e30610c200e9aea98bc7db12c7ac",
  "git_url": "https://github.com/fontforge/fontforge/commit/4de0c58a01e5e30610c200e9aea98bc7db12c7ac",
  "file_path": "fontforge/parsettf.c",
  "func_name": "readcfftopdicts",
  "func_before": "static struct topdicts **readcfftopdicts(FILE *ttf, char **fontnames, int32 cff_start,\n\tstruct ttfinfo *info, struct topdicts *parent_dict) {\n    uint16 count = getushort(ttf);\n    int offsize;\n    uint32 *offsets;\n    struct topdicts **dicts;\n    int i;\n\n    if ( count==0 )\nreturn( NULL );\n    offsets = malloc((count+1)*sizeof(uint32));\n    offsize = getc(ttf);\n    for ( i=0; i<=count; ++i )\n\toffsets[i] = getoffset(ttf,offsize);\n    dicts = malloc((count+1)*sizeof(struct topdicts *));\n    for ( i=0; i<count; ++i ) {\n\tdicts[i] = readcfftopdict(ttf,fontnames!=NULL?fontnames[i]:NULL,\n\t\toffsets[i+1]-offsets[i], info);\n\tif ( parent_dict!=NULL && parent_dict->fontmatrix_set ) {\n\t    MatMultiply(parent_dict->fontmatrix,dicts[i]->fontmatrix,dicts[i]->fontmatrix);\n\t}\n\tdicts[i]->cff_start = cff_start;\n    }\n    dicts[i] = NULL;\n    free(offsets);\nreturn( dicts );\n}",
  "abstract_func_before": "static struct topdicts **readcfftopdicts(FILE *VAR_0, char **VAR_1, int32 VAR_2,\n\tstruct ttfinfo *VAR_3, struct topdicts *VAR_4) {\n    uint16 VAR_5 = getushort(VAR_0);\n    int VAR_6;\n    uint32 *VAR_7;\n    struct topdicts **VAR_8;\n    int VAR_9;\n\n    if ( VAR_5==0 )\nreturn( NULL );\n    VAR_7 = malloc((VAR_5+1)*sizeof(uint32));\n    VAR_6 = getc(VAR_0);\n    for ( VAR_9=0; VAR_9<=VAR_5; ++VAR_9 )\n\tVAR_7[VAR_9] = getoffset(VAR_0,VAR_6);\n    VAR_8 = malloc((VAR_5+1)*sizeof(struct topdicts *));\n    for ( VAR_9=0; VAR_9<VAR_5; ++VAR_9 ) {\n\tVAR_8[VAR_9] = readcfftopdict(VAR_0,VAR_1!=NULL?VAR_1[VAR_9]:NULL,\n\t\tVAR_7[VAR_9+1]-VAR_7[VAR_9], VAR_3);\n\tif ( VAR_4!=NULL && VAR_4->fontmatrix_set ) {\n\t    MatMultiply(VAR_4->fontmatrix,VAR_8[VAR_9]->fontmatrix,VAR_8[VAR_9]->fontmatrix);\n\t}\n\tVAR_8[VAR_9]->cff_start = VAR_2;\n    }\n    VAR_8[VAR_9] = NULL;\n    free(VAR_7);\nreturn( VAR_8 );\n}",
  "func_graph_path_before": "fontforge/4de0c58a01e5e30610c200e9aea98bc7db12c7ac/parsettf.c/vul/before/0.json",
  "func": "static struct topdicts **readcfftopdicts(FILE *ttf, char **fontnames, int32 cff_start,\n\tstruct ttfinfo *info, struct topdicts *parent_dict) {\n    uint16 count = getushort(ttf);\n    int offsize;\n    uint32 *offsets;\n    struct topdicts **dicts;\n    int i;\n\n    if ( count==0 )\nreturn( NULL );\n    offsets = malloc((count+1)*sizeof(uint32));\n    offsize = getc(ttf);\n    for ( i=0; i<=count; ++i )\n\toffsets[i] = getoffset(ttf,offsize);\n    dicts = malloc((count+1)*sizeof(struct topdicts *));\n    for ( i=0; i<count; ++i ) {\n\tif (fontnames != NULL && fontnames[i] == NULL) {\n\t\tLogError(_(\"Number of CFF font names is less than dict size: %d < %d\"), i, count);\n\t\tbreak;\n\t}\n\tdicts[i] = readcfftopdict(ttf,fontnames!=NULL?fontnames[i]:NULL,\n\t\toffsets[i+1]-offsets[i], info);\n\tif ( parent_dict!=NULL && parent_dict->fontmatrix_set ) {\n\t    MatMultiply(parent_dict->fontmatrix,dicts[i]->fontmatrix,dicts[i]->fontmatrix);\n\t}\n\tdicts[i]->cff_start = cff_start;\n    }\n    dicts[i] = NULL;\n    free(offsets);\nreturn( dicts );\n}",
  "abstract_func": "static struct topdicts **readcfftopdicts(FILE *VAR_0, char **VAR_1, int32 VAR_2,\n\tstruct ttfinfo *VAR_3, struct topdicts *VAR_4) {\n    uint16 VAR_5 = getushort(VAR_0);\n    int VAR_6;\n    uint32 *VAR_7;\n    struct topdicts **VAR_8;\n    int VAR_9;\n\n    if ( VAR_5==0 )\nreturn( NULL );\n    VAR_7 = malloc((VAR_5+1)*sizeof(uint32));\n    VAR_6 = getc(VAR_0);\n    for ( VAR_9=0; VAR_9<=VAR_5; ++VAR_9 )\n\tVAR_7[VAR_9] = getoffset(VAR_0,VAR_6);\n    VAR_8 = malloc((VAR_5+1)*sizeof(struct topdicts *));\n    for ( VAR_9=0; VAR_9<VAR_5; ++VAR_9 ) {\n\tif (VAR_1 != NULL && VAR_1[VAR_9] == NULL) {\n\t\tLogError(_(\"Number of CFF font names is less than dict size: %d < %d\"), VAR_9, VAR_5);\n\t\tbreak;\n\t}\n\tVAR_8[VAR_9] = readcfftopdict(VAR_0,VAR_1!=NULL?VAR_1[VAR_9]:NULL,\n\t\tVAR_7[VAR_9+1]-VAR_7[VAR_9], VAR_3);\n\tif ( VAR_4!=NULL && VAR_4->fontmatrix_set ) {\n\t    MatMultiply(VAR_4->fontmatrix,VAR_8[VAR_9]->fontmatrix,VAR_8[VAR_9]->fontmatrix);\n\t}\n\tVAR_8[VAR_9]->cff_start = VAR_2;\n    }\n    VAR_8[VAR_9] = NULL;\n    free(VAR_7);\nreturn( VAR_8 );\n}",
  "func_graph_path": "fontforge/4de0c58a01e5e30610c200e9aea98bc7db12c7ac/parsettf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,10 @@\n \toffsets[i] = getoffset(ttf,offsize);\n     dicts = malloc((count+1)*sizeof(struct topdicts *));\n     for ( i=0; i<count; ++i ) {\n+\tif (fontnames != NULL && fontnames[i] == NULL) {\n+\t\tLogError(_(\"Number of CFF font names is less than dict size: %d < %d\"), i, count);\n+\t\tbreak;\n+\t}\n \tdicts[i] = readcfftopdict(ttf,fontnames!=NULL?fontnames[i]:NULL,\n \t\toffsets[i+1]-offsets[i], info);\n \tif ( parent_dict!=NULL && parent_dict->fontmatrix_set ) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tif (fontnames != NULL && fontnames[i] == NULL) {",
      "\t\tLogError(_(\"Number of CFF font names is less than dict size: %d < %d\"), i, count);",
      "\t\tbreak;",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fontforge/fontforge/pull/3124",
  "description": {
    "pr_info": {
      "title": "Fix a few cves",
      "number": 3124
    },
    "comment": [
      "So the long and the short of it is that FontForge was not designed with security in mind. I would not be surprised at all if a simple permutation on the test cases resulted in another buffer overflow/out of bounds read/etc. There's just too many cases to cover.\r\n\r\nAnyway, this fixes most of the *specific* test cases as listed in #3123. I've avoided #3097 and #3098 which involves changing the codegen around the unicode library. For any other issue in that list where there isn't a specific commit, it's probably been fixed as a side effect of one of the other commits.",
      "Just in time. I'm cutting a release tomorrow. I'll review as soon as I get a chance.\r\n",
      "I made one inline comment/query. It otherwise looks fine.\r\n",
      "All good.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Step1: Input Analysis**\n   - The commit message explicitly mentions fixing \"out of bounds read condition\" and \"buffer overflow condition,\" which are classic security issues.\n   - The vulnerability description confirms that the patch addresses buffer overflow and out-of-bounds read vulnerabilities in specific test cases.\n\n2. **Step2: Consistency Check**\n   - The code diff shows modifications in `parsettf.c`, `psread.c`, and `tottf.c`, aligning with the commit message's focus on these areas.\n\n3. **Step3: Purpose Evaluation**\n   - The changes involve adding boundary checks and using safer functions (like `snprintf`), directly addressing core logic vulnerabilities.\n\n4. **Step4: Security Vulnerability Assessment**\n   - Fixes buffer overflow and out-of-bounds reads, which are known security risks leading to potential exploits.\n\n5. **Step5: Non-Security Classification (Not Applicable)**\n   - Since it's a security fix, no further non-security categorization is needed.\n\n6. **Step6: Confidence Scoring**\n   - High confidence due to clear commit message, code changes, and vulnerability description alignment.\n\n**Conclusion:**\nThe patch is a clear security fix addressing critical vulnerabilities, with high confidence in this classification."
}