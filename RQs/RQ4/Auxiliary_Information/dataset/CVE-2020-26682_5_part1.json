{
  "cve_id": "CVE-2020-26682",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "outline: fix overflows in outline processing\n\nThis commit enforces strict invariant on ASS_Outline\nto contain point coordinates into predetermined range.\n\nFixes https://github.com/libass/libass/issues/431.",
  "commit_hash": "676f9dc5b52ef406c5527bdadbcb947f11392929",
  "git_url": "https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929",
  "file_path": "libass/ass_rasterizer.c",
  "func_name": "rasterizer_set_outline",
  "func_before": "bool rasterizer_set_outline(RasterizerData *rst,\n                            const ASS_Outline *path, bool extra)\n{\n    if (!extra) {\n        rectangle_reset(&rst->bbox);\n        rst->n_first = 0;\n    }\n    rst->size[0] = rst->n_first;\n\n    for (size_t i = 0; i < path->n_points; i++) {\n        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)\n            return false;\n        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)\n            return false;\n    }\n\n    ASS_Vector *start = path->points, *cur = start;\n    for (size_t i = 0; i < path->n_segments; i++) {\n        int n = path->segments[i] & OUTLINE_COUNT_MASK;\n        cur += n;\n\n        ASS_Vector *end = cur, p[4];\n        if (path->segments[i] & OUTLINE_CONTOUR_END) {\n            end = start;\n            start = cur;\n        }\n\n        switch (n) {\n        case OUTLINE_LINE_SEGMENT:\n            if (!add_line(rst, cur[-1], *end))\n                return false;\n            break;\n\n        case OUTLINE_QUADRATIC_SPLINE:\n            p[0] = cur[-2];\n            p[1] = cur[-1];\n            p[2] = *end;\n            if (!add_quadratic(rst, p))\n                return false;\n            break;\n\n        case OUTLINE_CUBIC_SPLINE:\n            p[0] = cur[-3];\n            p[1] = cur[-2];\n            p[2] = cur[-1];\n            p[3] = *end;\n            if (!add_cubic(rst, p))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n    }\n    assert(start == cur && cur == path->points + path->n_points);\n\n    for (size_t k = rst->n_first; k < rst->size[0]; k++) {\n        struct segment *line = &rst->linebuf[0][k];\n        rectangle_update(&rst->bbox,\n                         line->x_min, line->y_min,\n                         line->x_max, line->y_max);\n    }\n    if (!extra)\n        rst->n_first = rst->size[0];\n    return true;\n}",
  "abstract_func_before": "bool rasterizer_set_outline(RasterizerData *VAR_0,\n                            const ASS_Outline *VAR_1, bool VAR_2)\n{\n    if (!VAR_2) {\n        rectangle_reset(&VAR_0->bbox);\n        VAR_0->n_first = 0;\n    }\n    VAR_0->size[0] = VAR_0->n_first;\n\n    for (size_t VAR_3 = 0; VAR_3 < VAR_1->n_points; VAR_3++) {\n        if (VAR_1->points[VAR_3].x < VAR_4 || VAR_1->points[VAR_3].x > VAR_5)\n            return false;\n        if (VAR_1->points[VAR_3].y < VAR_4 || VAR_1->points[VAR_3].y > VAR_5)\n            return false;\n    }\n\n    ASS_Vector *VAR_6 = VAR_1->points, *VAR_7 = VAR_6;\n    for (size_t VAR_3 = 0; VAR_3 < VAR_1->n_segments; VAR_3++) {\n        int VAR_8 = VAR_1->segments[VAR_3] & VAR_9;\n        VAR_7 += VAR_8;\n\n        ASS_Vector *VAR_10 = VAR_7, VAR_11[4];\n        if (VAR_1->segments[VAR_3] & VAR_12) {\n            VAR_10 = VAR_6;\n            VAR_6 = VAR_7;\n        }\n\n        switch (VAR_8) {\n        case VAR_13:\n            if (!add_line(VAR_0, VAR_7[-1], *VAR_10))\n                return false;\n            break;\n\n        case VAR_14:\n            VAR_11[0] = VAR_7[-2];\n            VAR_11[1] = VAR_7[-1];\n            VAR_11[2] = *VAR_10;\n            if (!add_quadratic(VAR_0, VAR_11))\n                return false;\n            break;\n\n        case VAR_15:\n            VAR_11[0] = VAR_7[-3];\n            VAR_11[1] = VAR_7[-2];\n            VAR_11[2] = VAR_7[-1];\n            VAR_11[3] = *VAR_10;\n            if (!add_cubic(VAR_0, VAR_11))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n    }\n    assert(VAR_6 == VAR_7 && VAR_7 == VAR_1->points + VAR_1->n_points);\n\n    for (size_t VAR_16 = VAR_0->n_first; VAR_16 < VAR_0->size[0]; VAR_16++) {\n        struct segment *VAR_17 = &VAR_0->linebuf[0][VAR_16];\n        rectangle_update(&VAR_0->bbox,\n                         VAR_17->x_min, VAR_17->y_min,\n                         VAR_17->x_max, VAR_17->y_max);\n    }\n    if (!VAR_2)\n        VAR_0->n_first = VAR_0->size[0];\n    return true;\n}",
  "func_graph_path_before": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_rasterizer.c/vul/before/0.json",
  "func": "bool rasterizer_set_outline(RasterizerData *rst,\n                            const ASS_Outline *path, bool extra)\n{\n    if (!extra) {\n        rectangle_reset(&rst->bbox);\n        rst->n_first = 0;\n    }\n    rst->size[0] = rst->n_first;\n\n#ifndef NDEBUG\n    for (size_t i = 0; i < path->n_points; i++)\n        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);\n#endif\n\n    ASS_Vector *start = path->points, *cur = start;\n    for (size_t i = 0; i < path->n_segments; i++) {\n        int n = path->segments[i] & OUTLINE_COUNT_MASK;\n        cur += n;\n\n        ASS_Vector *end = cur, p[4];\n        if (path->segments[i] & OUTLINE_CONTOUR_END) {\n            end = start;\n            start = cur;\n        }\n\n        switch (n) {\n        case OUTLINE_LINE_SEGMENT:\n            if (!add_line(rst, cur[-1], *end))\n                return false;\n            break;\n\n        case OUTLINE_QUADRATIC_SPLINE:\n            p[0] = cur[-2];\n            p[1] = cur[-1];\n            p[2] = *end;\n            if (!add_quadratic(rst, p))\n                return false;\n            break;\n\n        case OUTLINE_CUBIC_SPLINE:\n            p[0] = cur[-3];\n            p[1] = cur[-2];\n            p[2] = cur[-1];\n            p[3] = *end;\n            if (!add_cubic(rst, p))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n    }\n    assert(start == cur && cur == path->points + path->n_points);\n\n    for (size_t k = rst->n_first; k < rst->size[0]; k++) {\n        struct segment *line = &rst->linebuf[0][k];\n        rectangle_update(&rst->bbox,\n                         line->x_min, line->y_min,\n                         line->x_max, line->y_max);\n    }\n    if (!extra)\n        rst->n_first = rst->size[0];\n    return true;\n}",
  "abstract_func": "bool rasterizer_set_outline(RasterizerData *VAR_0,\n                            const ASS_Outline *VAR_1, bool VAR_2)\n{\n    if (!VAR_2) {\n        rectangle_reset(&VAR_0->bbox);\n        VAR_0->n_first = 0;\n    }\n    VAR_0->size[0] = VAR_0->n_first;\n\n#ifndef VAR_3\n    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++)\n        assert(abs(VAR_1->points[VAR_4].x) <= VAR_5 && abs(VAR_1->points[VAR_4].y) <= VAR_5);\n#endif\n\n    ASS_Vector *VAR_6 = VAR_1->points, *VAR_7 = VAR_6;\n    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_segments; VAR_4++) {\n        int VAR_8 = VAR_1->segments[VAR_4] & VAR_9;\n        VAR_7 += VAR_8;\n\n        ASS_Vector *VAR_10 = VAR_7, VAR_11[4];\n        if (VAR_1->segments[VAR_4] & VAR_12) {\n            VAR_10 = VAR_6;\n            VAR_6 = VAR_7;\n        }\n\n        switch (VAR_8) {\n        case VAR_13:\n            if (!add_line(VAR_0, VAR_7[-1], *VAR_10))\n                return false;\n            break;\n\n        case VAR_14:\n            VAR_11[0] = VAR_7[-2];\n            VAR_11[1] = VAR_7[-1];\n            VAR_11[2] = *VAR_10;\n            if (!add_quadratic(VAR_0, VAR_11))\n                return false;\n            break;\n\n        case VAR_15:\n            VAR_11[0] = VAR_7[-3];\n            VAR_11[1] = VAR_7[-2];\n            VAR_11[2] = VAR_7[-1];\n            VAR_11[3] = *VAR_10;\n            if (!add_cubic(VAR_0, VAR_11))\n                return false;\n            break;\n\n        default:\n            return false;\n        }\n    }\n    assert(VAR_6 == VAR_7 && VAR_7 == VAR_1->points + VAR_1->n_points);\n\n    for (size_t VAR_16 = VAR_0->n_first; VAR_16 < VAR_0->size[0]; VAR_16++) {\n        struct segment *VAR_17 = &VAR_0->linebuf[0][VAR_16];\n        rectangle_update(&VAR_0->bbox,\n                         VAR_17->x_min, VAR_17->y_min,\n                         VAR_17->x_max, VAR_17->y_max);\n    }\n    if (!VAR_2)\n        VAR_0->n_first = VAR_0->size[0];\n    return true;\n}",
  "func_graph_path": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_rasterizer.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,12 +7,10 @@\n     }\n     rst->size[0] = rst->n_first;\n \n-    for (size_t i = 0; i < path->n_points; i++) {\n-        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)\n-            return false;\n-        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)\n-            return false;\n-    }\n+#ifndef NDEBUG\n+    for (size_t i = 0; i < path->n_points; i++)\n+        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);\n+#endif\n \n     ASS_Vector *start = path->points, *cur = start;\n     for (size_t i = 0; i < path->n_segments; i++) {",
  "diff_line_info": {
    "deleted_lines": [
      "    for (size_t i = 0; i < path->n_points; i++) {",
      "        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)",
      "            return false;",
      "        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)",
      "            return false;",
      "    }"
    ],
    "added_lines": [
      "#ifndef NDEBUG",
      "    for (size_t i = 0; i < path->n_points; i++)",
      "        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);",
      "#endif"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/432",
  "description": {
    "pr_info": {
      "title": "Fix overflows in outline processing",
      "number": 432
    },
    "comment": [
      "I've added a couple of checks for overflows in outline pipeline. Should fix #431, but I'm not familiar with that fuzzing business so I can't ascertain it for now.",
      "Can confirm that this fixes #431. \r\n\r\nOverflow checks seem fine to me. *(Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess)*",
      "> Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess\r\n\r\nMaybe it's even better to get rid of `OUTLINE_MIN` altogether and use `-OUTLINE_MAX` instead.",
      "New, more strict version. `max(abs(x), abs(y)) <= OUTLINE_MAX` is now enforced invariant of `ASS_Outline` instead of some ad hoc check. Also I've got rid of `OUTLINE_MIN`.",
      "@MrSmile \r\n\r\n```\r\nass_outline.c:53:12: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^\r\nass_outline.c:53:12: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^~~\r\n           labs\r\nass_outline.c:53:41: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^\r\nass_outline.c:53:41: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^~~\r\n                                        labs\r\n```",
      "FT docs specify that `FT_Pos` is 16.16 or 26.6 fixed-point representation, so I'm not sure what's better, to cast into `int32_t` or use `labs` here.",
      "Just use `labs`. In a way, this will also serve as a sanity check to ensure the FT docs aren’t lying."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.85"
}