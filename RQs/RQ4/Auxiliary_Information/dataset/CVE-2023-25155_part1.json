{
  "cve_id": "CVE-2023-25155",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Integer Overflow in RAND commands can lead to assertion (CVE-2023-25155)\n\nIssue happens when passing a negative long value that greater than\nthe max positive value that the long can store.",
  "commit_hash": "2a2a582e7cd99ba3b531336b8bd41df2b566e619",
  "git_url": "https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619",
  "file_path": "src/t_set.c",
  "func_name": "srandmemberWithCountCommand",
  "func_before": "void srandmemberWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    int uniq = 1;\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    dict *d;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        /* A negative count means: return the same elements multiple times\n         * (i.e. don't remove the extracted element after every extraction). */\n        count = -l;\n        uniq = 0;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n    size = setTypeSize(set);\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        addReplyArrayLen(c,count);\n        while(count--) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            if (c->flags & CLIENT_CLOSE_ASAP)\n                break;\n        }\n        return;\n    }\n\n    /* CASE 2:\n     * The number of requested elements is greater than the number of\n     * elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        setTypeIterator *si;\n        addReplyArrayLen(c,size);\n        si = setTypeInitIterator(set);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            size--;\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(size==0);\n        return;\n    }\n\n    /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */\n    d = dictCreate(&sdsReplyDictType);\n\n    /* CASE 3:\n     * The number of elements inside the set is not greater than\n     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a set from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        setTypeIterator *si;\n\n        /* Add all the elements into the temporary dictionary. */\n        si = setTypeInitIterator(set);\n        dictExpand(d, size);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            int retval = DICT_ERR;\n\n            if (encoding == OBJ_ENCODING_INTSET) {\n                retval = dictAdd(d,sdsfromlonglong(llele),NULL);\n            } else {\n                retval = dictAdd(d,sdsdup(ele),NULL);\n            }\n            serverAssert(retval == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n    }\n\n    /* CASE 4: We have a big set compared to the requested number of elements.\n     * In this case we can simply get random elements from the set and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        unsigned long added = 0;\n        sds sdsele;\n\n        dictExpand(d, count);\n        while (added < count) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(ele);\n            }\n            /* Try to add the object to the dictionary. If it already exists\n             * free it, otherwise increment the number of objects we have\n             * in the result dictionary. */\n            if (dictAdd(d,sdsele,NULL) == DICT_OK)\n                added++;\n            else\n                sdsfree(sdsele);\n        }\n    }\n\n    /* CASE 3 & 4: send the result to the user. */\n    {\n        dictIterator *di;\n        dictEntry *de;\n\n        addReplyArrayLen(c,count);\n        di = dictGetIterator(d);\n        while((de = dictNext(di)) != NULL)\n            addReplyBulkSds(c,dictGetKey(de));\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n}",
  "abstract_func_before": "void srandmemberWithCountCommand(client *VAR_0) {\n    long VAR_1;\n    unsigned long VAR_2, VAR_3;\n    int VAR_4 = 1;\n    robj *VAR_5;\n    sds VAR_6;\n    int64_t VAR_7;\n    int VAR_8;\n\n    dict *VAR_9;\n\n    if (getLongFromObjectOrReply(VAR_0,VAR_0->argv[2],&VAR_1,NULL) != VAR_10) return;\n    if (VAR_1 >= 0) {\n        VAR_2 = (unsigned long) VAR_1;\n    } else {\n        /* COMMENT_0 */\n                                                                               \n        VAR_2 = -VAR_1;\n        VAR_4 = 0;\n    }\n\n    if ((VAR_5 = lookupKeyReadOrReply(VAR_0,VAR_0->argv[1],VAR_11.emptyarray))\n        == NULL || checkType(VAR_0,VAR_5,VAR_12)) return;\n    VAR_3 = setTypeSize(VAR_5);\n\n    /* COMMENT_2 */\n    if (VAR_2 == 0) {\n        addReply(VAR_0,VAR_11.emptyarray);\n        return;\n    }\n\n    /* COMMENT_3 */\n                                                                    \n                                                                    \n                                                                          \n                                   \n    if (!VAR_4 || VAR_2 == 1) {\n        addReplyArrayLen(VAR_0,VAR_2);\n        while(VAR_2--) {\n            VAR_8 = setTypeRandomElement(VAR_5,&VAR_6,&VAR_7);\n            if (VAR_8 == VAR_13) {\n                addReplyBulkLongLong(VAR_0,VAR_7);\n            } else {\n                addReplyBulkCBuffer(VAR_0,VAR_6,sdslen(VAR_6));\n            }\n            if (VAR_0->flags & VAR_14)\n                break;\n        }\n        return;\n    }\n\n    /* COMMENT_8 */\n                                                                     \n                                                               \n    if (VAR_2 >= VAR_3) {\n        setTypeIterator *VAR_15;\n        addReplyArrayLen(VAR_0,VAR_3);\n        VAR_15 = setTypeInitIterator(VAR_5);\n        while ((VAR_8 = setTypeNext(VAR_15,&VAR_6,&VAR_7)) != -1) {\n            if (VAR_8 == VAR_13) {\n                addReplyBulkLongLong(VAR_0,VAR_7);\n            } else {\n                addReplyBulkCBuffer(VAR_0,VAR_6,sdslen(VAR_6));\n            }\n            VAR_3--;\n        }\n        setTypeReleaseIterator(VAR_15);\n        serverAssert(VAR_3==0);\n        return;\n    }\n\n    /* COMMENT_11 */\n    VAR_9 = dictCreate(&VAR_16);\n\n    /* COMMENT_12 */\n                                                                \n                                                                           \n                                                                           \n                                                                          \n      \n                                                                       \n                                                                              \n                                                 \n    if (VAR_2*VAR_17 > VAR_3) {\n        setTypeIterator *VAR_15;\n\n        /* COMMENT_21 */\n        VAR_15 = setTypeInitIterator(VAR_5);\n        dictExpand(VAR_9, VAR_3);\n        while ((VAR_8 = setTypeNext(VAR_15,&VAR_6,&VAR_7)) != -1) {\n            int VAR_18 = VAR_19;\n\n            if (VAR_8 == VAR_13) {\n                VAR_18 = dictAdd(VAR_9,sdsfromlonglong(VAR_7),NULL);\n            } else {\n                VAR_18 = dictAdd(VAR_9,sdsdup(VAR_6),NULL);\n            }\n            serverAssert(VAR_18 == VAR_20);\n        }\n        setTypeReleaseIterator(VAR_15);\n        serverAssert(dictSize(VAR_9) == VAR_3);\n\n        /* COMMENT_22 */\n        while (VAR_3 > VAR_2) {\n            dictEntry *VAR_21;\n            VAR_21 = dictGetFairRandomKey(VAR_9);\n            dictUnlink(VAR_9,dictGetKey(VAR_21));\n            sdsfree(dictGetKey(VAR_21));\n            dictFreeUnlinkedEntry(VAR_9,VAR_21);\n            VAR_3--;\n        }\n    }\n\n    /* COMMENT_23 */\n                                                                          \n                                                                            \n                                       \n    else {\n        unsigned long VAR_22 = 0;\n        sds VAR_23;\n\n        dictExpand(VAR_9, VAR_2);\n        while (VAR_22 < VAR_2) {\n            VAR_8 = setTypeRandomElement(VAR_5,&VAR_6,&VAR_7);\n            if (VAR_8 == VAR_13) {\n                VAR_23 = sdsfromlonglong(VAR_7);\n            } else {\n                VAR_23 = sdsdup(VAR_6);\n            }\n            /* COMMENT_27 */\n                                                                         \n                                           \n            if (dictAdd(VAR_9,VAR_23,NULL) == VAR_20)\n                VAR_22++;\n            else\n                sdsfree(VAR_23);\n        }\n    }\n\n    /* COMMENT_30 */\n    {\n        dictIterator *VAR_24;\n        dictEntry *VAR_21;\n\n        addReplyArrayLen(VAR_0,VAR_2);\n        VAR_24 = dictGetIterator(VAR_9);\n        while((VAR_21 = dictNext(VAR_24)) != NULL)\n            addReplyBulkSds(VAR_0,dictGetKey(VAR_21));\n        dictReleaseIterator(VAR_24);\n        dictRelease(VAR_9);\n    }\n}",
  "func_graph_path_before": "redis/2a2a582e7cd99ba3b531336b8bd41df2b566e619/t_set.c/vul/before/0.json",
  "func": "void srandmemberWithCountCommand(client *c) {\n    long l;\n    unsigned long count, size;\n    int uniq = 1;\n    robj *set;\n    sds ele;\n    int64_t llele;\n    int encoding;\n\n    dict *d;\n\n    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n    if (l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        /* A negative count means: return the same elements multiple times\n         * (i.e. don't remove the extracted element after every extraction). */\n        count = -l;\n        uniq = 0;\n    }\n\n    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,set,OBJ_SET)) return;\n    size = setTypeSize(set);\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        addReplyArrayLen(c,count);\n        while(count--) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            if (c->flags & CLIENT_CLOSE_ASAP)\n                break;\n        }\n        return;\n    }\n\n    /* CASE 2:\n     * The number of requested elements is greater than the number of\n     * elements inside the set: simply return the whole set. */\n    if (count >= size) {\n        setTypeIterator *si;\n        addReplyArrayLen(c,size);\n        si = setTypeInitIterator(set);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            if (encoding == OBJ_ENCODING_INTSET) {\n                addReplyBulkLongLong(c,llele);\n            } else {\n                addReplyBulkCBuffer(c,ele,sdslen(ele));\n            }\n            size--;\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(size==0);\n        return;\n    }\n\n    /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */\n    d = dictCreate(&sdsReplyDictType);\n\n    /* CASE 3:\n     * The number of elements inside the set is not greater than\n     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a set from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the set, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {\n        setTypeIterator *si;\n\n        /* Add all the elements into the temporary dictionary. */\n        si = setTypeInitIterator(set);\n        dictExpand(d, size);\n        while ((encoding = setTypeNext(si,&ele,&llele)) != -1) {\n            int retval = DICT_ERR;\n\n            if (encoding == OBJ_ENCODING_INTSET) {\n                retval = dictAdd(d,sdsfromlonglong(llele),NULL);\n            } else {\n                retval = dictAdd(d,sdsdup(ele),NULL);\n            }\n            serverAssert(retval == DICT_OK);\n        }\n        setTypeReleaseIterator(si);\n        serverAssert(dictSize(d) == size);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n    }\n\n    /* CASE 4: We have a big set compared to the requested number of elements.\n     * In this case we can simply get random elements from the set and add\n     * to the temporary set, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        unsigned long added = 0;\n        sds sdsele;\n\n        dictExpand(d, count);\n        while (added < count) {\n            encoding = setTypeRandomElement(set,&ele,&llele);\n            if (encoding == OBJ_ENCODING_INTSET) {\n                sdsele = sdsfromlonglong(llele);\n            } else {\n                sdsele = sdsdup(ele);\n            }\n            /* Try to add the object to the dictionary. If it already exists\n             * free it, otherwise increment the number of objects we have\n             * in the result dictionary. */\n            if (dictAdd(d,sdsele,NULL) == DICT_OK)\n                added++;\n            else\n                sdsfree(sdsele);\n        }\n    }\n\n    /* CASE 3 & 4: send the result to the user. */\n    {\n        dictIterator *di;\n        dictEntry *de;\n\n        addReplyArrayLen(c,count);\n        di = dictGetIterator(d);\n        while((de = dictNext(di)) != NULL)\n            addReplyBulkSds(c,dictGetKey(de));\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n}",
  "abstract_func": "void srandmemberWithCountCommand(client *VAR_0) {\n    long VAR_1;\n    unsigned long VAR_2, VAR_3;\n    int VAR_4 = 1;\n    robj *VAR_5;\n    sds VAR_6;\n    int64_t VAR_7;\n    int VAR_8;\n\n    dict *VAR_9;\n\n    if (getRangeLongFromObjectOrReply(VAR_0,VAR_0->argv[2],-VAR_10,VAR_10,&VAR_1,NULL) != VAR_11) return;\n    if (VAR_1 >= 0) {\n        VAR_2 = (unsigned long) VAR_1;\n    } else {\n        /* COMMENT_0 */\n                                                                               \n        VAR_2 = -VAR_1;\n        VAR_4 = 0;\n    }\n\n    if ((VAR_5 = lookupKeyReadOrReply(VAR_0,VAR_0->argv[1],VAR_12.emptyarray))\n        == NULL || checkType(VAR_0,VAR_5,VAR_13)) return;\n    VAR_3 = setTypeSize(VAR_5);\n\n    /* COMMENT_2 */\n    if (VAR_2 == 0) {\n        addReply(VAR_0,VAR_12.emptyarray);\n        return;\n    }\n\n    /* COMMENT_3 */\n                                                                    \n                                                                    \n                                                                          \n                                   \n    if (!VAR_4 || VAR_2 == 1) {\n        addReplyArrayLen(VAR_0,VAR_2);\n        while(VAR_2--) {\n            VAR_8 = setTypeRandomElement(VAR_5,&VAR_6,&VAR_7);\n            if (VAR_8 == VAR_14) {\n                addReplyBulkLongLong(VAR_0,VAR_7);\n            } else {\n                addReplyBulkCBuffer(VAR_0,VAR_6,sdslen(VAR_6));\n            }\n            if (VAR_0->flags & VAR_15)\n                break;\n        }\n        return;\n    }\n\n    /* COMMENT_8 */\n                                                                     \n                                                               \n    if (VAR_2 >= VAR_3) {\n        setTypeIterator *VAR_16;\n        addReplyArrayLen(VAR_0,VAR_3);\n        VAR_16 = setTypeInitIterator(VAR_5);\n        while ((VAR_8 = setTypeNext(VAR_16,&VAR_6,&VAR_7)) != -1) {\n            if (VAR_8 == VAR_14) {\n                addReplyBulkLongLong(VAR_0,VAR_7);\n            } else {\n                addReplyBulkCBuffer(VAR_0,VAR_6,sdslen(VAR_6));\n            }\n            VAR_3--;\n        }\n        setTypeReleaseIterator(VAR_16);\n        serverAssert(VAR_3==0);\n        return;\n    }\n\n    /* COMMENT_11 */\n    VAR_9 = dictCreate(&VAR_17);\n\n    /* COMMENT_12 */\n                                                                \n                                                                           \n                                                                           \n                                                                          \n      \n                                                                       \n                                                                              \n                                                 \n    if (VAR_2*VAR_18 > VAR_3) {\n        setTypeIterator *VAR_16;\n\n        /* COMMENT_21 */\n        VAR_16 = setTypeInitIterator(VAR_5);\n        dictExpand(VAR_9, VAR_3);\n        while ((VAR_8 = setTypeNext(VAR_16,&VAR_6,&VAR_7)) != -1) {\n            int VAR_19 = VAR_20;\n\n            if (VAR_8 == VAR_14) {\n                VAR_19 = dictAdd(VAR_9,sdsfromlonglong(VAR_7),NULL);\n            } else {\n                VAR_19 = dictAdd(VAR_9,sdsdup(VAR_6),NULL);\n            }\n            serverAssert(VAR_19 == VAR_21);\n        }\n        setTypeReleaseIterator(VAR_16);\n        serverAssert(dictSize(VAR_9) == VAR_3);\n\n        /* COMMENT_22 */\n        while (VAR_3 > VAR_2) {\n            dictEntry *VAR_22;\n            VAR_22 = dictGetFairRandomKey(VAR_9);\n            dictUnlink(VAR_9,dictGetKey(VAR_22));\n            sdsfree(dictGetKey(VAR_22));\n            dictFreeUnlinkedEntry(VAR_9,VAR_22);\n            VAR_3--;\n        }\n    }\n\n    /* COMMENT_23 */\n                                                                          \n                                                                            \n                                       \n    else {\n        unsigned long VAR_23 = 0;\n        sds VAR_24;\n\n        dictExpand(VAR_9, VAR_2);\n        while (VAR_23 < VAR_2) {\n            VAR_8 = setTypeRandomElement(VAR_5,&VAR_6,&VAR_7);\n            if (VAR_8 == VAR_14) {\n                VAR_24 = sdsfromlonglong(VAR_7);\n            } else {\n                VAR_24 = sdsdup(VAR_6);\n            }\n            /* COMMENT_27 */\n                                                                         \n                                           \n            if (dictAdd(VAR_9,VAR_24,NULL) == VAR_21)\n                VAR_23++;\n            else\n                sdsfree(VAR_24);\n        }\n    }\n\n    /* COMMENT_30 */\n    {\n        dictIterator *VAR_25;\n        dictEntry *VAR_22;\n\n        addReplyArrayLen(VAR_0,VAR_2);\n        VAR_25 = dictGetIterator(VAR_9);\n        while((VAR_22 = dictNext(VAR_25)) != NULL)\n            addReplyBulkSds(VAR_0,dictGetKey(VAR_22));\n        dictReleaseIterator(VAR_25);\n        dictRelease(VAR_9);\n    }\n}",
  "func_graph_path": "redis/2a2a582e7cd99ba3b531336b8bd41df2b566e619/t_set.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \n     dict *d;\n \n-    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n+    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n     if (l >= 0) {\n         count = (unsigned long) l;\n     } else {",
  "diff_line_info": {
    "deleted_lines": [
      "    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;"
    ],
    "added_lines": [
      "    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/11848",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/redis/redis/pull/11848: 403 Client Error: Forbidden for url: https://api.github.com/repos/redis/redis/pulls/11848",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}