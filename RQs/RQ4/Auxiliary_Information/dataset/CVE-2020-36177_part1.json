{
  "cve_id": "CVE-2020-36177",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssl",
  "commit_msg": "RSA-PSS: Handle edge case with encoding message to hash\n\nWhen the key is small relative to the digest (1024-bit key, 64-byte\nhash, 61-byte salt length), the internal message to hash is larger than\nthe output size.\nAllocate a buffer for the message when this happens.",
  "commit_hash": "fb2288c46dd4c864b78f00a47a364b96a09a5c0f",
  "git_url": "https://github.com/wolfSSL/wolfssl/commit/fb2288c46dd4c864b78f00a47a364b96a09a5c0f",
  "file_path": "wolfcrypt/src/rsa.c",
  "func_name": "RsaPad_PSS",
  "func_before": "static int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,\n        word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,\n        int saltLen, int bits, void* heap)\n{\n    int   ret = 0;\n    int   hLen, i, o, maskLen, hiBits;\n    byte* m;\n    byte* s;\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n        byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n    #else\n        byte* salt = NULL;\n    #endif\n#else\n    byte salt[WC_MAX_DIGEST_SIZE];\n#endif\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    if (pkcsBlockLen > RSA_MAX_SIZE/8) {\n        return MEMORY_E;\n    }\n#endif\n\n    hLen = wc_HashGetDigestSize(hType);\n    if (hLen < 0)\n        return hLen;\n    if ((int)inputLen != hLen) {\n        return BAD_FUNC_ARG;\n    }\n\n    hiBits = (bits - 1) & 0x7;\n    if (hiBits == 0) {\n        /* Per RFC8017, set the leftmost 8emLen - emBits bits of the\n           leftmost octet in DB to zero.\n        */\n        *(pkcsBlock++) = 0;\n        pkcsBlockLen--;\n    }\n\n    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {\n        saltLen = hLen;\n        #ifdef WOLFSSL_SHA512\n            /* See FIPS 186-4 section 5.5 item (e). */\n            if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {\n                saltLen = RSA_PSS_SALT_MAX_SZ;\n            }\n        #endif\n    }\n#ifndef WOLFSSL_PSS_LONG_SALT\n    else if (saltLen > hLen) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER\n    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {\n        return PSS_SALTLEN_E;\n    }\n#else\n    else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {\n        saltLen = (int)pkcsBlockLen - hLen - 2;\n        if (saltLen < 0) {\n            return PSS_SALTLEN_E;\n        }\n    }\n    else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n    if ((int)pkcsBlockLen - hLen < saltLen + 2) {\n        return PSS_SALTLEN_E;\n    }\n    maskLen = pkcsBlockLen - 1 - hLen;\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (salt == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n    s = m = salt;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = (int)(m - s);\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, m, saltLen);\n        if (ret == 0) {\n            m += saltLen;\n        }\n    }\n#else\n    s = m = pkcsBlock;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = 0;\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, salt, saltLen);\n        if (ret == 0) {\n            XMEMCPY(m, salt, saltLen);\n            m += saltLen;\n        }\n    }\n#endif\n    if (ret == 0) {\n        /* Put Hash at end of pkcsBlock - 1 */\n        ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);\n    }\n    if (ret == 0) {\n       /* Set the last eight bits or trailer field to the octet 0xbc */\n        pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;\n\n        ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);\n    }\n    if (ret == 0) {\n        /* Clear the first high bit when \"8emLen - emBits\" is non-zero.\n           where emBits = n modBits - 1 */\n        if (hiBits)\n            pkcsBlock[0] &= (1 << hiBits) - 1;\n\n        m = pkcsBlock + maskLen - saltLen - 1;\n        *(m++) ^= 0x01;\n        for (i = 0; i < saltLen; i++) {\n            m[i] ^= salt[o + i];\n        }\n    }\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        if (salt != NULL) {\n            XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);\n        }\n    #endif\n#endif\n    return ret;\n}",
  "abstract_func_before": "static int RsaPad_PSS(const byte* VAR_0, word32 VAR_1, byte* VAR_2,\n        word32 VAR_3, WC_RNG* VAR_4, enum wc_HashType VAR_5, int VAR_6,\n        int VAR_7, int VAR_8, void* VAR_9)\n{\n    int   VAR_10 = 0;\n    int   VAR_11, VAR_12, VAR_13, VAR_14, VAR_15;\n    byte* VAR_16;\n    byte* VAR_17;\n#if defined(VAR_18) || defined(VAR_19)\n    #if defined(VAR_20) && !defined(VAR_21)\n        byte VAR_22[VAR_23/8 + VAR_24];\n    #else\n        byte* VAR_22 = NULL;\n    #endif\n#else\n    byte VAR_22[VAR_25];\n#endif\n\n#if defined(VAR_18) || defined(VAR_19)\n    if (VAR_3 > VAR_23/8) {\n        return VAR_26;\n    }\n#endif\n\n    VAR_11 = wc_HashGetDigestSize(VAR_5);\n    if (VAR_11 < 0)\n        return VAR_11;\n    if ((int)VAR_1 != VAR_11) {\n        return VAR_27;\n    }\n\n    VAR_15 = (VAR_8 - 1) & 0x7;\n    if (VAR_15 == 0) {\n        /* COMMENT_0 */\n                                        \n          \n        *(VAR_2++) = 0;\n        VAR_3--;\n    }\n\n    if (VAR_7 == VAR_28) {\n        VAR_7 = VAR_11;\n        #ifdef VAR_29\n            /* COMMENT_3 */\n            if (VAR_8 == 1024 && VAR_11 == VAR_30) {\n                VAR_7 = VAR_31;\n            }\n        #endif\n    }\n#ifndef VAR_18\n    else if (saltLen > VAR_11) {\n        return VAR_32;\n    }\n#endif\n#ifndef VAR_19\n    else if (saltLen < VAR_28) {\n        return VAR_32;\n    }\n#else\n    else if (saltLen == VAR_33) {\n        saltLen = (int)VAR_3 - VAR_11 - 2;\n        if (saltLen < 0) {\n            return VAR_32;\n        }\n    }\n    else if (saltLen < VAR_33) {\n        return VAR_32;\n    }\n#endif\n    if ((int)VAR_3 - VAR_11 < saltLen + 2) {\n        return VAR_32;\n    }\n    VAR_14 = VAR_3 - 1 - VAR_11;\n\n#if defined(VAR_18) || defined(VAR_19)\n    #if !defined(VAR_20) || defined(VAR_21)\n        VAR_22 = (byte*)XMALLOC(VAR_24 + VAR_1 + saltLen, VAR_9,\n                                                       VAR_34);\n        if (VAR_22 == NULL) {\n            return VAR_26;\n        }\n    #endif\n    VAR_17 = VAR_16 = VAR_22;\n    XMEMSET(VAR_16, 0, VAR_24);\n    VAR_16 += VAR_24;\n    XMEMCPY(VAR_16, VAR_0, VAR_1);\n    VAR_16 += VAR_1;\n    VAR_13 = (int)(VAR_16 - VAR_17);\n    if (saltLen > 0) {\n        VAR_10 = wc_RNG_GenerateBlock(VAR_4, VAR_16, saltLen);\n        if (VAR_10 == 0) {\n            VAR_16 += saltLen;\n        }\n    }\n#else\n    VAR_17 = VAR_16 = VAR_2;\n    XMEMSET(VAR_16, 0, VAR_24);\n    VAR_16 += VAR_24;\n    XMEMCPY(VAR_16, VAR_0, VAR_1);\n    VAR_16 += VAR_1;\n    VAR_13 = 0;\n    if (saltLen > 0) {\n        VAR_10 = wc_RNG_GenerateBlock(VAR_4, VAR_22, saltLen);\n        if (VAR_10 == 0) {\n            XMEMCPY(VAR_16, VAR_22, saltLen);\n            VAR_16 += saltLen;\n        }\n    }\n#endif\n    if (VAR_10 == 0) {\n        /* COMMENT_4 */\n        VAR_10 = wc_Hash(VAR_5, VAR_17, (word32)(VAR_16 - VAR_17), VAR_2 + VAR_14, VAR_11);\n    }\n    if (VAR_10 == 0) {\n       /* COMMENT_5 */\n        VAR_2[VAR_3 - 1] = VAR_35;\n\n        VAR_10 = RsaMGF(VAR_6, VAR_2 + VAR_14, VAR_11, VAR_2, VAR_14, VAR_9);\n    }\n    if (VAR_10 == 0) {\n        /* COMMENT_6 */\n                                          \n        if (VAR_15)\n            VAR_2[0] &= (1 << VAR_15) - 1;\n\n        VAR_16 = VAR_2 + VAR_14 - saltLen - 1;\n        *(VAR_16++) ^= 0x01;\n        for (VAR_12 = 0; VAR_12 < saltLen; VAR_12++) {\n            VAR_16[VAR_12] ^= VAR_22[VAR_13 + VAR_12];\n        }\n    }\n\n#if defined(VAR_18) || defined(VAR_19)\n    #if !defined(VAR_20) || defined(VAR_21)\n        if (VAR_22 != NULL) {\n            XFREE(VAR_22, VAR_9, VAR_34);\n        }\n    #endif\n#endif\n    return VAR_10;\n}",
  "func_graph_path_before": "wolfSSL/wolfssl/fb2288c46dd4c864b78f00a47a364b96a09a5c0f/rsa.c/vul/before/0.json",
  "func": "static int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,\n        word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,\n        int saltLen, int bits, void* heap)\n{\n    int   ret = 0;\n    int   hLen, i, o, maskLen, hiBits;\n    byte* m;\n    byte* s;\n#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n    byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n#else\n    byte* msg = NULL;\n#endif\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    byte* salt;\n#else\n    byte salt[WC_MAX_DIGEST_SIZE];\n#endif\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    if (pkcsBlockLen > RSA_MAX_SIZE/8) {\n        return MEMORY_E;\n    }\n#endif\n\n    hLen = wc_HashGetDigestSize(hType);\n    if (hLen < 0)\n        return hLen;\n    if ((int)inputLen != hLen) {\n        return BAD_FUNC_ARG;\n    }\n\n    hiBits = (bits - 1) & 0x7;\n    if (hiBits == 0) {\n        /* Per RFC8017, set the leftmost 8emLen - emBits bits of the\n           leftmost octet in DB to zero.\n        */\n        *(pkcsBlock++) = 0;\n        pkcsBlockLen--;\n    }\n\n    if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {\n        saltLen = hLen;\n        #ifdef WOLFSSL_SHA512\n            /* See FIPS 186-4 section 5.5 item (e). */\n            if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {\n                saltLen = RSA_PSS_SALT_MAX_SZ;\n            }\n        #endif\n    }\n#ifndef WOLFSSL_PSS_LONG_SALT\n    else if (saltLen > hLen) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER\n    else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {\n        return PSS_SALTLEN_E;\n    }\n#else\n    else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {\n        saltLen = (int)pkcsBlockLen - hLen - 2;\n        if (saltLen < 0) {\n            return PSS_SALTLEN_E;\n        }\n    }\n    else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {\n        return PSS_SALTLEN_E;\n    }\n#endif\n    if ((int)pkcsBlockLen - hLen < saltLen + 2) {\n        return PSS_SALTLEN_E;\n    }\n    maskLen = pkcsBlockLen - 1 - hLen;\n\n#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (msg == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n    salt = s = m = msg;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = (int)(m - s);\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, m, saltLen);\n        if (ret == 0) {\n            m += saltLen;\n        }\n    }\n#else\n    if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                       DYNAMIC_TYPE_RSA_BUFFER);\n        if (msg == NULL) {\n            return MEMORY_E;\n        }\n    #endif\n        m = msg;\n    }\n    else {\n        m = pkcsBlock;\n    }\n    s = m;\n    XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n    m += RSA_PSS_PAD_SZ;\n    XMEMCPY(m, input, inputLen);\n    m += inputLen;\n    o = 0;\n    if (saltLen > 0) {\n        ret = wc_RNG_GenerateBlock(rng, salt, saltLen);\n        if (ret == 0) {\n            XMEMCPY(m, salt, saltLen);\n            m += saltLen;\n        }\n    }\n#endif\n    if (ret == 0) {\n        /* Put Hash at end of pkcsBlock - 1 */\n        ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);\n    }\n    if (ret == 0) {\n       /* Set the last eight bits or trailer field to the octet 0xbc */\n        pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;\n\n        ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);\n    }\n    if (ret == 0) {\n        /* Clear the first high bit when \"8emLen - emBits\" is non-zero.\n           where emBits = n modBits - 1 */\n        if (hiBits)\n            pkcsBlock[0] &= (1 << hiBits) - 1;\n\n        m = pkcsBlock + maskLen - saltLen - 1;\n        *(m++) ^= 0x01;\n        for (i = 0; i < saltLen; i++) {\n            m[i] ^= salt[o + i];\n        }\n    }\n\n    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n        if (msg != NULL) {\n            XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);\n        }\n    #endif\n    return ret;\n}",
  "abstract_func": "static int RsaPad_PSS(const byte* VAR_0, word32 VAR_1, byte* VAR_2,\n        word32 VAR_3, WC_RNG* VAR_4, enum wc_HashType VAR_5, int VAR_6,\n        int VAR_7, int VAR_8, void* VAR_9)\n{\n    int   VAR_10 = 0;\n    int   VAR_11, VAR_12, VAR_13, VAR_14, VAR_15;\n    byte* VAR_16;\n    byte* VAR_17;\n#if defined(VAR_18) && !defined(VAR_19)\n    byte VAR_20[VAR_21/8 + VAR_22];\n#else\n    byte* VAR_20 = NULL;\n#endif\n#if defined(VAR_23) || defined(VAR_24)\n    byte* VAR_25;\n#else\n    byte VAR_25[VAR_26];\n#endif\n\n#if defined(VAR_23) || defined(VAR_24)\n    if (VAR_3 > VAR_21/8) {\n        return VAR_27;\n    }\n#endif\n\n    VAR_11 = wc_HashGetDigestSize(VAR_5);\n    if (VAR_11 < 0)\n        return VAR_11;\n    if ((int)VAR_1 != VAR_11) {\n        return VAR_28;\n    }\n\n    VAR_15 = (VAR_8 - 1) & 0x7;\n    if (VAR_15 == 0) {\n        /* COMMENT_0 */\n                                        \n          \n        *(VAR_2++) = 0;\n        VAR_3--;\n    }\n\n    if (VAR_7 == VAR_29) {\n        VAR_7 = VAR_11;\n        #ifdef VAR_30\n            /* COMMENT_3 */\n            if (VAR_8 == 1024 && VAR_11 == VAR_31) {\n                VAR_7 = VAR_32;\n            }\n        #endif\n    }\n#ifndef VAR_23\n    else if (saltLen > VAR_11) {\n        return VAR_33;\n    }\n#endif\n#ifndef VAR_24\n    else if (saltLen < VAR_29) {\n        return VAR_33;\n    }\n#else\n    else if (saltLen == VAR_34) {\n        saltLen = (int)VAR_3 - VAR_11 - 2;\n        if (saltLen < 0) {\n            return VAR_33;\n        }\n    }\n    else if (saltLen < VAR_34) {\n        return VAR_33;\n    }\n#endif\n    if ((int)VAR_3 - VAR_11 < saltLen + 2) {\n        return VAR_33;\n    }\n    VAR_14 = VAR_3 - 1 - VAR_11;\n\n#if defined(VAR_23) || defined(VAR_24)\n    #if !defined(VAR_18) || defined(VAR_19)\n        VAR_20 = (byte*)XMALLOC(VAR_22 + VAR_1 + saltLen, VAR_9,\n                                                       VAR_35);\n        if (VAR_20 == NULL) {\n            return VAR_27;\n        }\n    #endif\n    VAR_25 = VAR_17 = VAR_16 = VAR_20;\n    XMEMSET(VAR_16, 0, VAR_22);\n    VAR_16 += VAR_22;\n    XMEMCPY(VAR_16, VAR_0, VAR_1);\n    VAR_16 += VAR_1;\n    VAR_13 = (int)(VAR_16 - VAR_17);\n    if (saltLen > 0) {\n        VAR_10 = wc_RNG_GenerateBlock(VAR_4, VAR_16, saltLen);\n        if (VAR_10 == 0) {\n            VAR_16 += saltLen;\n        }\n    }\n#else\n    if (VAR_3 < VAR_22 + VAR_1 + saltLen) {\n    #if !defined(VAR_18) || defined(VAR_19)\n        VAR_20 = (byte*)XMALLOC(VAR_22 + VAR_1 + saltLen, VAR_9,\n                                                       VAR_35);\n        if (VAR_20 == NULL) {\n            return VAR_27;\n        }\n    #endif\n        VAR_16 = VAR_20;\n    }\n    else {\n        VAR_16 = VAR_2;\n    }\n    VAR_17 = VAR_16;\n    XMEMSET(VAR_16, 0, VAR_22);\n    VAR_16 += VAR_22;\n    XMEMCPY(VAR_16, VAR_0, VAR_1);\n    VAR_16 += VAR_1;\n    VAR_13 = 0;\n    if (saltLen > 0) {\n        VAR_10 = wc_RNG_GenerateBlock(VAR_4, VAR_25, saltLen);\n        if (VAR_10 == 0) {\n            XMEMCPY(VAR_16, VAR_25, saltLen);\n            VAR_16 += saltLen;\n        }\n    }\n#endif\n    if (VAR_10 == 0) {\n        /* COMMENT_4 */\n        VAR_10 = wc_Hash(VAR_5, VAR_17, (word32)(VAR_16 - VAR_17), VAR_2 + VAR_14, VAR_11);\n    }\n    if (VAR_10 == 0) {\n       /* COMMENT_5 */\n        VAR_2[VAR_3 - 1] = VAR_36;\n\n        VAR_10 = RsaMGF(VAR_6, VAR_2 + VAR_14, VAR_11, VAR_2, VAR_14, VAR_9);\n    }\n    if (VAR_10 == 0) {\n        /* COMMENT_6 */\n                                          \n        if (VAR_15)\n            VAR_2[0] &= (1 << VAR_15) - 1;\n\n        VAR_16 = VAR_2 + VAR_14 - saltLen - 1;\n        *(VAR_16++) ^= 0x01;\n        for (VAR_12 = 0; VAR_12 < saltLen; VAR_12++) {\n            VAR_16[VAR_12] ^= VAR_25[VAR_13 + VAR_12];\n        }\n    }\n\n    #if !defined(VAR_18) || defined(VAR_19)\n        if (VAR_20 != NULL) {\n            XFREE(VAR_20, VAR_9, VAR_35);\n        }\n    #endif\n    return VAR_10;\n}",
  "func_graph_path": "wolfSSL/wolfssl/fb2288c46dd4c864b78f00a47a364b96a09a5c0f/rsa.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,13 @@\n     int   hLen, i, o, maskLen, hiBits;\n     byte* m;\n     byte* s;\n+#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n+    byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n+#else\n+    byte* msg = NULL;\n+#endif\n #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n-    #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)\n-        byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];\n-    #else\n-        byte* salt = NULL;\n-    #endif\n+    byte* salt;\n #else\n     byte salt[WC_MAX_DIGEST_SIZE];\n #endif\n@@ -74,13 +75,13 @@\n \n #if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n-        salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n+        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n                                                        DYNAMIC_TYPE_RSA_BUFFER);\n-        if (salt == NULL) {\n+        if (msg == NULL) {\n             return MEMORY_E;\n         }\n     #endif\n-    s = m = salt;\n+    salt = s = m = msg;\n     XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n     m += RSA_PSS_PAD_SZ;\n     XMEMCPY(m, input, inputLen);\n@@ -93,7 +94,20 @@\n         }\n     }\n #else\n-    s = m = pkcsBlock;\n+    if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {\n+    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n+        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,\n+                                                       DYNAMIC_TYPE_RSA_BUFFER);\n+        if (msg == NULL) {\n+            return MEMORY_E;\n+        }\n+    #endif\n+        m = msg;\n+    }\n+    else {\n+        m = pkcsBlock;\n+    }\n+    s = m;\n     XMEMSET(m, 0, RSA_PSS_PAD_SZ);\n     m += RSA_PSS_PAD_SZ;\n     XMEMCPY(m, input, inputLen);\n@@ -130,12 +144,10 @@\n         }\n     }\n \n-#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)\n     #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)\n-        if (salt != NULL) {\n-            XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);\n+        if (msg != NULL) {\n+            XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);\n         }\n     #endif\n-#endif\n     return ret;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    #if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)",
      "        byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];",
      "    #else",
      "        byte* salt = NULL;",
      "    #endif",
      "        salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,",
      "        if (salt == NULL) {",
      "    s = m = salt;",
      "    s = m = pkcsBlock;",
      "#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)",
      "        if (salt != NULL) {",
      "            XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);",
      "#endif"
    ],
    "added_lines": [
      "#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)",
      "    byte msg[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];",
      "#else",
      "    byte* msg = NULL;",
      "#endif",
      "    byte* salt;",
      "        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,",
      "        if (msg == NULL) {",
      "    salt = s = m = msg;",
      "    if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {",
      "    #if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)",
      "        msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,",
      "                                                       DYNAMIC_TYPE_RSA_BUFFER);",
      "        if (msg == NULL) {",
      "            return MEMORY_E;",
      "        }",
      "    #endif",
      "        m = msg;",
      "    }",
      "    else {",
      "        m = pkcsBlock;",
      "    }",
      "    s = m;",
      "        if (msg != NULL) {",
      "            XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssl/pull/3426",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/wolfSSL/wolfssl/pull/3426: 403 Client Error: Forbidden for url: https://api.github.com/repos/wolfSSL/wolfssl/pulls/3426",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses a buffer overflow scenario in RSA-PSS padding, preventing potential security exploits by ensuring proper memory allocation.\n\n**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 0.95"
}