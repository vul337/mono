{
  "cve_id": "CVE-2021-21282",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Validate the segments_left field in the SRH.",
  "commit_hash": "f0bb7f314c424630837d2ed08ec0bc90e1ccb15e",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/f0bb7f314c424630837d2ed08ec0bc90e1ccb15e",
  "file_path": "os/net/routing/rpl-classic/rpl-ext-header.c",
  "func_name": "rpl_ext_header_srh_update",
  "func_before": "int\nrpl_ext_header_srh_update(void)\n{\n#if RPL_WITH_NON_STORING\n  struct uip_routing_hdr *rh_header;\n  struct uip_rpl_srh_hdr *srh_header;\n\n  /* Look for routing ext header */\n  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);\n\n  if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {\n    /* SRH found, now look for next hop */\n    uint8_t cmpri, cmpre;\n    uint8_t ext_len;\n    uint8_t padding;\n    uint8_t path_len;\n    uint8_t segments_left;\n    uip_ipaddr_t current_dest_addr;\n\n    srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);\n    segments_left = rh_header->seg_left;\n    ext_len = rh_header->len * 8 + 8;\n    cmpri = srh_header->cmpr >> 4;\n    cmpre = srh_header->cmpr & 0x0f;\n    padding = srh_header->pad >> 4;\n    path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;\n    (void)path_len;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        path_len, segments_left, cmpri, cmpre, ext_len, padding);\n\n    if(segments_left == 0) {\n      /* We are the final destination, do nothing */\n    } else {\n      uint8_t i = path_len - segments_left; /* The index of the next address to be visited */\n      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n      uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;\n\n      /* As per RFC6554: swap the IPv6 destination address and address[i] */\n\n      /* First, copy the current IPv6 destination address */\n      uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);\n      /* Second, update the IPv6 destination address with addresses[i] */\n      memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);\n      /* Third, write current_dest_addr to addresses[i] */\n      memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);\n\n      /* Update segments left field */\n      rh_header->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* RPL_WITH_NON_STORING */\n  return 0; /* SRH not found */\n#endif /* RPL_WITH_NON_STORING */\n}",
  "abstract_func_before": "int\nrpl_ext_header_srh_update(void)\n{\n#if VAR_0\n  struct uip_routing_hdr *VAR_1;\n  struct uip_rpl_srh_hdr *VAR_2;\n\n  /* COMMENT_0 */\n  VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);\n\n  if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {\n    /* COMMENT_1 */\n    uint8_t VAR_7, VAR_8;\n    uint8_t VAR_9;\n    uint8_t VAR_10;\n    uint8_t VAR_11;\n    uint8_t VAR_12;\n    uip_ipaddr_t VAR_13;\n\n    VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);\n    VAR_12 = VAR_1->seg_left;\n    VAR_9 = VAR_1->len * 8 + 8;\n    VAR_7 = VAR_2->cmpr >> 4;\n    VAR_8 = VAR_2->cmpr & 0x0f;\n    VAR_10 = VAR_2->pad >> 4;\n    VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;\n    (void)VAR_11;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);\n\n    if(VAR_12 == 0) {\n      /* COMMENT_2 */\n    } else {\n      uint8_t VAR_16 = VAR_11 - VAR_12; /* COMMENT_3 */\n      uint8_t *VAR_17 = ((uint8_t *)VAR_1) + VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));\n      uint8_t VAR_18 = VAR_12 == 1 ? VAR_8 : VAR_7;\n\n      /* COMMENT_4 */\n\n      /* COMMENT_5 */\n      uip_ipaddr_copy(&VAR_13, &VAR_19->destipaddr);\n      /* COMMENT_6 */\n      memcpy(((uint8_t *)&VAR_19->destipaddr) + VAR_18, VAR_17, 16 - VAR_18);\n      /* COMMENT_7 */\n      memcpy(VAR_17, ((uint8_t *)&VAR_13) + VAR_18, 16 - VAR_18);\n\n      /* COMMENT_8 */\n      VAR_1->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&VAR_19->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* COMMENT_9 */\n  return 0; /* COMMENT_10 */\n#endif /* COMMENT_9 */\n}",
  "func_graph_path_before": "contiki-ng/f0bb7f314c424630837d2ed08ec0bc90e1ccb15e/rpl-ext-header.c/vul/before/0.json",
  "func": "int\nrpl_ext_header_srh_update(void)\n{\n#if RPL_WITH_NON_STORING\n  struct uip_routing_hdr *rh_header;\n  struct uip_rpl_srh_hdr *srh_header;\n\n  /* Look for routing ext header */\n  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);\n\n  if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {\n    /* SRH found, now look for next hop */\n    uint8_t cmpri, cmpre;\n    uint8_t ext_len;\n    uint8_t padding;\n    uint8_t path_len;\n    uint8_t segments_left;\n    uip_ipaddr_t current_dest_addr;\n\n    srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);\n    segments_left = rh_header->seg_left;\n    ext_len = rh_header->len * 8 + 8;\n    cmpri = srh_header->cmpr >> 4;\n    cmpre = srh_header->cmpr & 0x0f;\n    padding = srh_header->pad >> 4;\n    path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;\n    (void)path_len;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        path_len, segments_left, cmpri, cmpre, ext_len, padding);\n\n    if(segments_left == 0) {\n      /* We are the final destination, do nothing */\n    } else if(segments_left > path_len) {\n      /* Discard the packet because of a parameter problem. */\n      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",\n              segments_left, path_len);\n      return 0;\n    } else {\n      uint8_t i = path_len - segments_left; /* The index of the next address to be visited */\n      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n      uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;\n\n      /* As per RFC6554: swap the IPv6 destination address and address[i] */\n\n      /* First, copy the current IPv6 destination address */\n      uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);\n      /* Second, update the IPv6 destination address with addresses[i] */\n      memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);\n      /* Third, write current_dest_addr to addresses[i] */\n      memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);\n\n      /* Update segments left field */\n      rh_header->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* RPL_WITH_NON_STORING */\n  return 0; /* SRH not found */\n#endif /* RPL_WITH_NON_STORING */\n}",
  "abstract_func": "int\nrpl_ext_header_srh_update(void)\n{\n#if VAR_0\n  struct uip_routing_hdr *VAR_1;\n  struct uip_rpl_srh_hdr *VAR_2;\n\n  /* COMMENT_0 */\n  VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);\n\n  if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {\n    /* COMMENT_1 */\n    uint8_t VAR_7, VAR_8;\n    uint8_t VAR_9;\n    uint8_t VAR_10;\n    uint8_t VAR_11;\n    uint8_t VAR_12;\n    uip_ipaddr_t VAR_13;\n\n    VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);\n    VAR_12 = VAR_1->seg_left;\n    VAR_9 = VAR_1->len * 8 + 8;\n    VAR_7 = VAR_2->cmpr >> 4;\n    VAR_8 = VAR_2->cmpr & 0x0f;\n    VAR_10 = VAR_2->pad >> 4;\n    VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;\n    (void)VAR_11;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);\n\n    if(VAR_12 == 0) {\n      /* COMMENT_2 */\n    } else if(VAR_12 > VAR_11) {\n      /* COMMENT_3 */\n      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",\n              VAR_12, VAR_11);\n      return 0;\n    } else {\n      uint8_t VAR_16 = VAR_11 - VAR_12; /* COMMENT_4 */\n      uint8_t *VAR_17 = ((uint8_t *)VAR_1) + VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));\n      uint8_t VAR_18 = VAR_12 == 1 ? VAR_8 : VAR_7;\n\n      /* COMMENT_5 */\n\n      /* COMMENT_6 */\n      uip_ipaddr_copy(&VAR_13, &VAR_19->destipaddr);\n      /* COMMENT_7 */\n      memcpy(((uint8_t *)&VAR_19->destipaddr) + VAR_18, VAR_17, 16 - VAR_18);\n      /* COMMENT_8 */\n      memcpy(VAR_17, ((uint8_t *)&VAR_13) + VAR_18, 16 - VAR_18);\n\n      /* COMMENT_9 */\n      VAR_1->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&VAR_19->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* COMMENT_10 */\n  return 0; /* COMMENT_11 */\n#endif /* COMMENT_10 */\n}",
  "func_graph_path": "contiki-ng/f0bb7f314c424630837d2ed08ec0bc90e1ccb15e/rpl-ext-header.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,11 @@\n \n     if(segments_left == 0) {\n       /* We are the final destination, do nothing */\n+    } else if(segments_left > path_len) {\n+      /* Discard the packet because of a parameter problem. */\n+      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",\n+              segments_left, path_len);\n+      return 0;\n     } else {\n       uint8_t i = path_len - segments_left; /* The index of the next address to be visited */\n       uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    } else if(segments_left > path_len) {",
      "      /* Discard the packet because of a parameter problem. */",
      "      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",",
      "              segments_left, path_len);",
      "      return 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1183",
  "description": {
    "pr_info": {
      "title": "Validate Source Routing Header (SRH) parameter",
      "number": 1183
    },
    "comment": [
      "As recommended on page 9 in RFC 6554, the <code>segments_left</code> field should be checked before continuing the packet processing. Otherwise, the index of the next address to be visited, which is calculated on line 242, can be used to make <code>addr_ptr</code> point outside the packet data."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}