{
  "cve_id": "CVE-2021-32675",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
  "commit_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
  "git_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
  "file_path": "src/networking.c",
  "func_name": "processMultibulkBuffer",
  "func_before": "int processMultibulkBuffer(client *c) {\n    char *newline = NULL;\n    int ok;\n    long long ll;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        serverAssertWithInfo(c,NULL,c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strchr(c->querybuf+c->qb_pos,'\\r');\n        if (newline == NULL) {\n            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                addReplyError(c,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",c);\n            }\n            return C_ERR;\n        }\n\n        /* Buffer should also contain \\n */\n        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n            return C_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');\n        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);\n        if (!ok || ll > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",c);\n            return C_ERR;\n        }\n\n        c->qb_pos = (newline-c->querybuf)+2;\n\n        if (ll <= 0) return C_OK;\n\n        c->multibulklen = ll;\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n        c->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(c,NULL,c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strchr(c->querybuf+c->qb_pos,'\\r');\n            if (newline == NULL) {\n                if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                    addReplyError(c,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",c);\n                    return C_ERR;\n                }\n                break;\n            }\n\n            /* Buffer should also contain \\n */\n            if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n                break;\n\n            if (c->querybuf[c->qb_pos] != '$') {\n                addReplyErrorFormat(c,\n                    \"Protocol error: expected '$', got '%c'\",\n                    c->querybuf[c->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",c);\n                return C_ERR;\n            }\n\n            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);\n            if (!ok || ll < 0 ||\n                (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                addReplyError(c,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",c);\n                return C_ERR;\n            }\n\n            c->qb_pos = newline-c->querybuf+2;\n            if (ll >= PROTO_MBULK_BIG_ARG) {\n                /* If we are going to read a large object from network\n                 * try to make it likely that it will start at c->querybuf\n                 * boundary so that we can optimize object creation\n                 * avoiding a large copy of data.\n                 *\n                 * But only when the data we have not parsed is less than\n                 * or equal to ll+2. If the data length is greater than\n                 * ll+2, trimming querybuf is just a waste of time, because\n                 * at this time the querybuf contains not only our bulk. */\n                if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {\n                    sdsrange(c->querybuf,c->qb_pos,-1);\n                    c->qb_pos = 0;\n                    /* Hint the sds library about the amount of bytes this string is\n                     * going to contain. */\n                    c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-sdslen(c->querybuf));\n                }\n            }\n            c->bulklen = ll;\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            /* Optimization: if the buffer contains JUST our bulk element\n             * instead of creating a new object by *copying* the sds we\n             * just use the current sds string. */\n            if (c->qb_pos == 0 &&\n                c->bulklen >= PROTO_MBULK_BIG_ARG &&\n                sdslen(c->querybuf) == (size_t)(c->bulklen+2))\n            {\n                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);\n                c->argv_len_sum += c->bulklen;\n                sdsIncrLen(c->querybuf,-2); /* remove CRLF */\n                /* Assume that if we saw a fat argument we'll see another one\n                 * likely... */\n                c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);\n                sdsclear(c->querybuf);\n            } else {\n                c->argv[c->argc++] =\n                    createStringObject(c->querybuf+c->qb_pos,c->bulklen);\n                c->argv_len_sum += c->bulklen;\n                c->qb_pos += c->bulklen+2;\n            }\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) return C_OK;\n\n    /* Still not ready to process the command */\n    return C_ERR;\n}",
  "abstract_func_before": "int processMultibulkBuffer(client *VAR_0) {\n    char *VAR_1 = NULL;\n    int VAR_2;\n    long long VAR_3;\n\n    if (VAR_0->multibulklen == 0) {\n        /* COMMENT_0 */\n        serverAssertWithInfo(VAR_0,NULL,VAR_0->argc == 0);\n\n        /* COMMENT_1 */\n        VAR_1 = strchr(VAR_0->querybuf+VAR_0->qb_pos,'\\r');\n        if (VAR_1 == NULL) {\n            if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos > VAR_4) {\n                addReplyError(VAR_0,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",VAR_0);\n            }\n            return VAR_5;\n        }\n\n        /* COMMENT_2 */\n        if (VAR_1-(VAR_0->querybuf+VAR_0->qb_pos) > (ssize_t)(sdslen(VAR_0->querybuf)-VAR_0->qb_pos-2))\n            return VAR_5;\n\n        /* COMMENT_3 */\n                                                             \n        serverAssertWithInfo(VAR_0,NULL,VAR_0->querybuf[VAR_0->qb_pos] == '*');\n        VAR_2 = string2ll(VAR_0->querybuf+1+VAR_0->qb_pos,VAR_1-(VAR_0->querybuf+1+VAR_0->qb_pos),&VAR_3);\n        if (!VAR_2 || VAR_3 > 1024*1024) {\n            addReplyError(VAR_0,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",VAR_0);\n            return VAR_5;\n        }\n\n        VAR_0->qb_pos = (VAR_1-VAR_0->querybuf)+2;\n\n        if (VAR_3 <= 0) return VAR_6;\n\n        VAR_0->multibulklen = VAR_3;\n\n        /* COMMENT_5 */\n        if (VAR_0->argv) zfree(VAR_0->argv);\n        VAR_0->argv = zmalloc(sizeof(robj*)*VAR_0->multibulklen);\n        VAR_0->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(VAR_0,NULL,VAR_0->multibulklen > 0);\n    while(VAR_0->multibulklen) {\n        /* COMMENT_6 */\n        if (VAR_0->bulklen == -1) {\n            VAR_1 = strchr(VAR_0->querybuf+VAR_0->qb_pos,'\\r');\n            if (VAR_1 == NULL) {\n                if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos > VAR_4) {\n                    addReplyError(VAR_0,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",VAR_0);\n                    return VAR_5;\n                }\n                break;\n            }\n\n            /* COMMENT_2 */\n            if (VAR_1-(VAR_0->querybuf+VAR_0->qb_pos) > (ssize_t)(sdslen(VAR_0->querybuf)-VAR_0->qb_pos-2))\n                break;\n\n            if (VAR_0->querybuf[VAR_0->qb_pos] != '$') {\n                addReplyErrorFormat(VAR_0,\n                    \"Protocol error: expected '$', got '%c'\",\n                    VAR_0->querybuf[VAR_0->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",VAR_0);\n                return VAR_5;\n            }\n\n            VAR_2 = string2ll(VAR_0->querybuf+VAR_0->qb_pos+1,VAR_1-(VAR_0->querybuf+VAR_0->qb_pos+1),&VAR_3);\n            if (!VAR_2 || VAR_3 < 0 ||\n                (!(VAR_0->flags & VAR_7) && VAR_3 > VAR_8.proto_max_bulk_len)) {\n                addReplyError(VAR_0,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",VAR_0);\n                return VAR_5;\n            }\n\n            VAR_0->qb_pos = VAR_1-VAR_0->querybuf+2;\n            if (VAR_3 >= VAR_9) {\n                /* COMMENT_7 */\n                                                                          \n                                                                   \n                                                 \n                  \n                                                                         \n                                                                       \n                                                                           \n                                                                           \n                if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos <= (size_t)VAR_3+2) {\n                    sdsrange(VAR_0->querybuf,VAR_0->qb_pos,-1);\n                    VAR_0->qb_pos = 0;\n                    /* COMMENT_16 */\n                                           \n                    VAR_0->querybuf = sdsMakeRoomFor(VAR_0->querybuf,VAR_3+2-sdslen(VAR_0->querybuf));\n                }\n            }\n            VAR_0->bulklen = VAR_3;\n        }\n\n        /* COMMENT_18 */\n        if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos < (size_t)(VAR_0->bulklen+2)) {\n            /* COMMENT_19 */\n            break;\n        } else {\n            /* COMMENT_20 */\n                                                                       \n                                                  \n            if (VAR_0->qb_pos == 0 &&\n                VAR_0->bulklen >= VAR_9 &&\n                sdslen(VAR_0->querybuf) == (size_t)(VAR_0->bulklen+2))\n            {\n                VAR_0->argv[VAR_0->argc++] = createObject(VAR_10,VAR_0->querybuf);\n                VAR_0->argv_len_sum += VAR_0->bulklen;\n                sdsIncrLen(VAR_0->querybuf,-2); /* COMMENT_23 */\n                /* COMMENT_24 */\n                               \n                VAR_0->querybuf = sdsnewlen(VAR_11,VAR_0->bulklen+2);\n                sdsclear(VAR_0->querybuf);\n            } else {\n                VAR_0->argv[VAR_0->argc++] =\n                    createStringObject(VAR_0->querybuf+VAR_0->qb_pos,VAR_0->bulklen);\n                VAR_0->argv_len_sum += VAR_0->bulklen;\n                VAR_0->qb_pos += VAR_0->bulklen+2;\n            }\n            VAR_0->bulklen = -1;\n            VAR_0->multibulklen--;\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_0->multibulklen == 0) return VAR_6;\n\n    /* COMMENT_27 */\n    return VAR_5;\n}",
  "func_graph_path_before": "redis/5674b0057ff2903d43eaff802017eddf37c360f8/networking.c/vul/before/0.json",
  "func": "int processMultibulkBuffer(client *c) {\n    char *newline = NULL;\n    int ok;\n    long long ll;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        serverAssertWithInfo(c,NULL,c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strchr(c->querybuf+c->qb_pos,'\\r');\n        if (newline == NULL) {\n            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                addReplyError(c,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",c);\n            }\n            return C_ERR;\n        }\n\n        /* Buffer should also contain \\n */\n        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n            return C_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');\n        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);\n        if (!ok || ll > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",c);\n            return C_ERR;\n        } else if (ll > 10 && authRequired(c)) {\n            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");\n            setProtocolError(\"unauth mbulk count\", c);\n            return C_ERR;\n        }\n\n        c->qb_pos = (newline-c->querybuf)+2;\n\n        if (ll <= 0) return C_OK;\n\n        c->multibulklen = ll;\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n        c->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(c,NULL,c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strchr(c->querybuf+c->qb_pos,'\\r');\n            if (newline == NULL) {\n                if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                    addReplyError(c,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",c);\n                    return C_ERR;\n                }\n                break;\n            }\n\n            /* Buffer should also contain \\n */\n            if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n                break;\n\n            if (c->querybuf[c->qb_pos] != '$') {\n                addReplyErrorFormat(c,\n                    \"Protocol error: expected '$', got '%c'\",\n                    c->querybuf[c->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",c);\n                return C_ERR;\n            }\n\n            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);\n            if (!ok || ll < 0 ||\n                (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                addReplyError(c,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",c);\n                return C_ERR;\n            } else if (ll > 16384 && authRequired(c)) {\n                addReplyError(c, \"Protocol error: unauthenticated bulk length\");\n                setProtocolError(\"unauth bulk length\", c);\n                return C_ERR;\n            }\n\n            c->qb_pos = newline-c->querybuf+2;\n            if (ll >= PROTO_MBULK_BIG_ARG) {\n                /* If we are going to read a large object from network\n                 * try to make it likely that it will start at c->querybuf\n                 * boundary so that we can optimize object creation\n                 * avoiding a large copy of data.\n                 *\n                 * But only when the data we have not parsed is less than\n                 * or equal to ll+2. If the data length is greater than\n                 * ll+2, trimming querybuf is just a waste of time, because\n                 * at this time the querybuf contains not only our bulk. */\n                if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {\n                    sdsrange(c->querybuf,c->qb_pos,-1);\n                    c->qb_pos = 0;\n                    /* Hint the sds library about the amount of bytes this string is\n                     * going to contain. */\n                    c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-sdslen(c->querybuf));\n                }\n            }\n            c->bulklen = ll;\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            /* Optimization: if the buffer contains JUST our bulk element\n             * instead of creating a new object by *copying* the sds we\n             * just use the current sds string. */\n            if (c->qb_pos == 0 &&\n                c->bulklen >= PROTO_MBULK_BIG_ARG &&\n                sdslen(c->querybuf) == (size_t)(c->bulklen+2))\n            {\n                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);\n                c->argv_len_sum += c->bulklen;\n                sdsIncrLen(c->querybuf,-2); /* remove CRLF */\n                /* Assume that if we saw a fat argument we'll see another one\n                 * likely... */\n                c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);\n                sdsclear(c->querybuf);\n            } else {\n                c->argv[c->argc++] =\n                    createStringObject(c->querybuf+c->qb_pos,c->bulklen);\n                c->argv_len_sum += c->bulklen;\n                c->qb_pos += c->bulklen+2;\n            }\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) return C_OK;\n\n    /* Still not ready to process the command */\n    return C_ERR;\n}",
  "abstract_func": "int processMultibulkBuffer(client *VAR_0) {\n    char *VAR_1 = NULL;\n    int VAR_2;\n    long long VAR_3;\n\n    if (VAR_0->multibulklen == 0) {\n        /* COMMENT_0 */\n        serverAssertWithInfo(VAR_0,NULL,VAR_0->argc == 0);\n\n        /* COMMENT_1 */\n        VAR_1 = strchr(VAR_0->querybuf+VAR_0->qb_pos,'\\r');\n        if (VAR_1 == NULL) {\n            if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos > VAR_4) {\n                addReplyError(VAR_0,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",VAR_0);\n            }\n            return VAR_5;\n        }\n\n        /* COMMENT_2 */\n        if (VAR_1-(VAR_0->querybuf+VAR_0->qb_pos) > (ssize_t)(sdslen(VAR_0->querybuf)-VAR_0->qb_pos-2))\n            return VAR_5;\n\n        /* COMMENT_3 */\n                                                             \n        serverAssertWithInfo(VAR_0,NULL,VAR_0->querybuf[VAR_0->qb_pos] == '*');\n        VAR_2 = string2ll(VAR_0->querybuf+1+VAR_0->qb_pos,VAR_1-(VAR_0->querybuf+1+VAR_0->qb_pos),&VAR_3);\n        if (!VAR_2 || VAR_3 > 1024*1024) {\n            addReplyError(VAR_0,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",VAR_0);\n            return VAR_5;\n        } else if (VAR_3 > 10 && authRequired(VAR_0)) {\n            addReplyError(VAR_0, \"Protocol error: unauthenticated multibulk length\");\n            setProtocolError(\"unauth mbulk count\", VAR_0);\n            return VAR_5;\n        }\n\n        VAR_0->qb_pos = (VAR_1-VAR_0->querybuf)+2;\n\n        if (VAR_3 <= 0) return VAR_6;\n\n        VAR_0->multibulklen = VAR_3;\n\n        /* COMMENT_5 */\n        if (VAR_0->argv) zfree(VAR_0->argv);\n        VAR_0->argv = zmalloc(sizeof(robj*)*VAR_0->multibulklen);\n        VAR_0->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(VAR_0,NULL,VAR_0->multibulklen > 0);\n    while(VAR_0->multibulklen) {\n        /* COMMENT_6 */\n        if (VAR_0->bulklen == -1) {\n            VAR_1 = strchr(VAR_0->querybuf+VAR_0->qb_pos,'\\r');\n            if (VAR_1 == NULL) {\n                if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos > VAR_4) {\n                    addReplyError(VAR_0,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",VAR_0);\n                    return VAR_5;\n                }\n                break;\n            }\n\n            /* COMMENT_2 */\n            if (VAR_1-(VAR_0->querybuf+VAR_0->qb_pos) > (ssize_t)(sdslen(VAR_0->querybuf)-VAR_0->qb_pos-2))\n                break;\n\n            if (VAR_0->querybuf[VAR_0->qb_pos] != '$') {\n                addReplyErrorFormat(VAR_0,\n                    \"Protocol error: expected '$', got '%c'\",\n                    VAR_0->querybuf[VAR_0->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",VAR_0);\n                return VAR_5;\n            }\n\n            VAR_2 = string2ll(VAR_0->querybuf+VAR_0->qb_pos+1,VAR_1-(VAR_0->querybuf+VAR_0->qb_pos+1),&VAR_3);\n            if (!VAR_2 || VAR_3 < 0 ||\n                (!(VAR_0->flags & VAR_7) && VAR_3 > VAR_8.proto_max_bulk_len)) {\n                addReplyError(VAR_0,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",VAR_0);\n                return VAR_5;\n            } else if (VAR_3 > 16384 && authRequired(VAR_0)) {\n                addReplyError(VAR_0, \"Protocol error: unauthenticated bulk length\");\n                setProtocolError(\"unauth bulk length\", VAR_0);\n                return VAR_5;\n            }\n\n            VAR_0->qb_pos = VAR_1-VAR_0->querybuf+2;\n            if (VAR_3 >= VAR_9) {\n                /* COMMENT_7 */\n                                                                          \n                                                                   \n                                                 \n                  \n                                                                         \n                                                                       \n                                                                           \n                                                                           \n                if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos <= (size_t)VAR_3+2) {\n                    sdsrange(VAR_0->querybuf,VAR_0->qb_pos,-1);\n                    VAR_0->qb_pos = 0;\n                    /* COMMENT_16 */\n                                           \n                    VAR_0->querybuf = sdsMakeRoomFor(VAR_0->querybuf,VAR_3+2-sdslen(VAR_0->querybuf));\n                }\n            }\n            VAR_0->bulklen = VAR_3;\n        }\n\n        /* COMMENT_18 */\n        if (sdslen(VAR_0->querybuf)-VAR_0->qb_pos < (size_t)(VAR_0->bulklen+2)) {\n            /* COMMENT_19 */\n            break;\n        } else {\n            /* COMMENT_20 */\n                                                                       \n                                                  \n            if (VAR_0->qb_pos == 0 &&\n                VAR_0->bulklen >= VAR_9 &&\n                sdslen(VAR_0->querybuf) == (size_t)(VAR_0->bulklen+2))\n            {\n                VAR_0->argv[VAR_0->argc++] = createObject(VAR_10,VAR_0->querybuf);\n                VAR_0->argv_len_sum += VAR_0->bulklen;\n                sdsIncrLen(VAR_0->querybuf,-2); /* COMMENT_23 */\n                /* COMMENT_24 */\n                               \n                VAR_0->querybuf = sdsnewlen(VAR_11,VAR_0->bulklen+2);\n                sdsclear(VAR_0->querybuf);\n            } else {\n                VAR_0->argv[VAR_0->argc++] =\n                    createStringObject(VAR_0->querybuf+VAR_0->qb_pos,VAR_0->bulklen);\n                VAR_0->argv_len_sum += VAR_0->bulklen;\n                VAR_0->qb_pos += VAR_0->bulklen+2;\n            }\n            VAR_0->bulklen = -1;\n            VAR_0->multibulklen--;\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_0->multibulklen == 0) return VAR_6;\n\n    /* COMMENT_27 */\n    return VAR_5;\n}",
  "func_graph_path": "redis/5674b0057ff2903d43eaff802017eddf37c360f8/networking.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,10 @@\n         if (!ok || ll > 1024*1024) {\n             addReplyError(c,\"Protocol error: invalid multibulk length\");\n             setProtocolError(\"invalid mbulk count\",c);\n+            return C_ERR;\n+        } else if (ll > 10 && authRequired(c)) {\n+            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");\n+            setProtocolError(\"unauth mbulk count\", c);\n             return C_ERR;\n         }\n \n@@ -75,6 +79,10 @@\n                 (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                 addReplyError(c,\"Protocol error: invalid bulk length\");\n                 setProtocolError(\"invalid bulk length\",c);\n+                return C_ERR;\n+            } else if (ll > 16384 && authRequired(c)) {\n+                addReplyError(c, \"Protocol error: unauthenticated bulk length\");\n+                setProtocolError(\"unauth bulk length\", c);\n                 return C_ERR;\n             }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            return C_ERR;",
      "        } else if (ll > 10 && authRequired(c)) {",
      "            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
      "            setProtocolError(\"unauth mbulk count\", c);",
      "                return C_ERR;",
      "            } else if (ll > 16384 && authRequired(c)) {",
      "                addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
      "                setProtocolError(\"unauth bulk length\", c);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9933333333333333,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9933333333333333"
}