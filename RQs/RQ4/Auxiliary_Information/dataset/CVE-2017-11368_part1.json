{
  "cve_id": "CVE-2017-11368",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Prevent KDC unset status assertion failures\n\nAssign status values if S4U2Self padata fails to decode, if an\nS4U2Proxy request uses invalid KDC options, or if an S4U2Proxy request\nuses an evidence ticket which does not match the canonicalized request\nserver principal name.  Reported by Samuel Cabrero.\n\nIf a status value is not assigned during KDC processing, default to\n\"UNKNOWN_REASON\" rather than failing an assertion.  This change will\nprevent future denial of service bugs due to similar mistakes, and\nwill allow us to omit assigning status values for unlikely errors such\nas small memory allocation failures.\n\nCVE-2017-11368:\n\nIn MIT krb5 1.7 and later, an authenticated attacker can cause an\nassertion failure in krb5kdc by sending an invalid S4U2Self or\nS4U2Proxy request.\n\n  CVSSv3 Vector: AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H/E:H/RL:O/RC:C\n\nticket: 8599 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup",
  "commit_hash": "ffb35baac6981f9e8914f8f3bffd37f284b85970",
  "git_url": "https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970",
  "file_path": "src/kdc/do_tgs_req.c",
  "func_name": "process_tgs_req",
  "func_before": "krb5_error_code\nprocess_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL) {\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        if (is_referral) {\n            /* The requesting server appears to no longer exist, and we found\n             * a referral instead.  Treat this as a server lookup failure. */\n            errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            status = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* Deal with user-to-user and constrained delegation */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, request->second_ticket[st_idx],\n                                  &au_state->evid_tkt_id);\n        if (retval) {\n            status = \"GENERATE_TICKET_ID\";\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract auth indicators from the subject ticket, except for S4U2Proxy\n     * requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    errcode = check_indicators(kdc_context, server, auth_indicators);\n    if (errcode) {\n        status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = OPTS2FLAGS(request->kdc_options);\n    enc_tkt_reply.flags |= COPY_TKT_FLAGS(header_enc_tkt->flags);\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /* Indicate support for encrypted padata (RFC 6806). */\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones, so just ignore the option. */\n    if (isflagset(request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS) &&\n        !isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        clear(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, header_server);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              header_server, local_tgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              header_key,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              auth_indicators,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            au_state->status = status;\n            kau_u2u(kdc_context, FALSE, au_state);\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"MAKE_S4U2SELF_PADATA\";\n            au_state->status = status;\n        }\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n\n    return retval;\n}",
  "abstract_func_before": "krb5_error_code\nprocess_tgs_req(struct server_handle *VAR_0, krb5_data *VAR_1,\n                const krb5_fulladdr *VAR_2, krb5_data **VAR_3)\n{\n    krb5_keyblock * VAR_4 = 0;\n    krb5_keyblock *VAR_5 = NULL;\n    krb5_kdc_req *VAR_6 = 0;\n    krb5_db_entry *VAR_7 = NULL;\n    krb5_db_entry *VAR_8 = NULL;\n    krb5_kdc_rep VAR_9;\n    krb5_enc_kdc_rep_part VAR_10;\n    krb5_ticket VAR_11, *VAR_12 = 0;\n    int VAR_13 = 0;\n    krb5_enc_tkt_part VAR_14;\n    int VAR_15 = 0;\n    krb5_error_code VAR_16 = 0;\n    krb5_keyblock VAR_17;\n    krb5_timestamp VAR_18, VAR_19 = 0;\n    krb5_keyblock VAR_20;\n    krb5_keyblock *VAR_21 = NULL;\n    krb5_key_data  *VAR_22;\n    krb5_principal VAR_23 = NULL, VAR_24 = NULL, VAR_25 = NULL;\n    krb5_last_req_entry *VAR_26[2], VAR_27;\n    int VAR_28;\n    const char        *VAR_29 = 0;\n    krb5_enc_tkt_part *VAR_30 = NULL; /* COMMENT_0 */\n    krb5_enc_tkt_part *VAR_31 = NULL; /* COMMENT_1 */\n    krb5_db_entry *VAR_32 = NULL, *VAR_33 = NULL;\n    krb5_db_entry *VAR_34, *VAR_35 = NULL;\n    krb5_pa_s4u_x509_user *VAR_36 = NULL; /* COMMENT_2 */\n    krb5_authdata **VAR_37 = NULL; /* COMMENT_3 */\n    unsigned int VAR_38 = 0, VAR_39 = 0;       /* COMMENT_4 */\n    krb5_boolean VAR_40;\n    const char *VAR_41 = NULL;\n    krb5_kvno VAR_42 = 0;\n    struct kdc_request_state *VAR_43 = NULL;\n    krb5_pa_data *VAR_44; /* COMMENT_5 */\n    krb5_data VAR_45;\n    krb5_pa_data **VAR_46 = NULL;\n    kdc_realm_t *VAR_47 = NULL;\n    krb5_audit_state *VAR_48 = NULL;\n    krb5_data **VAR_49 = NULL;\n\n    memset(&VAR_9, 0, sizeof(VAR_9));\n    memset(&VAR_10, 0, sizeof(VAR_10));\n    memset(&VAR_11, 0, sizeof(VAR_11));\n    memset(&VAR_14, 0, sizeof(VAR_14));\n    VAR_20.contents = NULL;\n\n    VAR_16 = decode_krb5_tgs_req(VAR_1, &VAR_6);\n    if (VAR_16)\n        return VAR_16;\n    /* COMMENT_6 */\n                                                             \n    VAR_24 = VAR_6->server;\n\n    if (VAR_6->msg_type != VAR_50) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_51;\n    }\n\n    /* COMMENT_8 */\n                                                                           \n       \n    VAR_47 = setup_server_realm(VAR_0, VAR_6->server);\n    if (VAR_47 == NULL) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_52;\n    }\n    VAR_28 = kdc_make_rstate(VAR_47, &VAR_43);\n    if (VAR_28 !=0) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_28;\n    }\n\n    /* COMMENT_11 */\n    VAR_28 = kau_init_kdc_req(VAR_53, VAR_6, VAR_2, &VAR_48);\n    if (VAR_28) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_28;\n    }\n    /* COMMENT_12 */\n    kau_tgs_req(VAR_53, TRUE, VAR_48);\n\n    VAR_28 = kdc_process_tgs_req(VAR_47,\n                                  VAR_6, VAR_2, VAR_1, &VAR_12,\n                                  &VAR_33, &VAR_5, &VAR_4,\n                                  &VAR_44);\n    if (VAR_12 && VAR_12->enc_part2)\n        VAR_23 = VAR_12->enc_part2->client;\n\n    if (VAR_28) {\n        VAR_29 = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!VAR_12) {\n        VAR_28 = VAR_54;        /* COMMENT_13 */\n        VAR_29=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    VAR_28 = kau_make_tkt_id(VAR_53, VAR_12,\n                              &VAR_48->tkt_in_id);\n    if (VAR_28) {\n        VAR_29 = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    VAR_45.length = VAR_44->length;\n    VAR_45.data = (char *) VAR_44->contents;\n    VAR_28 = kdc_find_fast(&VAR_6, &VAR_45, VAR_4,\n                            VAR_12->enc_part2->session, VAR_43, NULL);\n    /* COMMENT_14 */\n    VAR_24 = VAR_6->server;\n    if (VAR_28 !=0) {\n        VAR_29 = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    VAR_28 = get_local_tgt(VAR_53, &VAR_24->realm, VAR_33,\n                            &VAR_34, &VAR_35);\n    if (VAR_28) {\n        VAR_29 = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* COMMENT_15 */\n    VAR_48->request = VAR_6;\n\n    /* COMMENT_16 */\n                                                                       \n                                                                     \n                                                                       \n                                                \n       \n    VAR_30 = VAR_12->enc_part2;\n\n    /* COMMENT_22 */\n                                                                    \n                                                                      \n                                      \n       \n\n    VAR_48->stage = VAR_55;\n\n    /* COMMENT_27 */\n                 \n\n    setflag(VAR_39, VAR_56);\n    if (isflagset(VAR_6->kdc_options, VAR_57)) {\n        setflag(VAR_38, VAR_58);\n        setflag(VAR_39, VAR_58);\n    }\n\n    VAR_28 = search_sprinc(VAR_47, VAR_6, VAR_39, &VAR_7,\n                            &VAR_29);\n    if (VAR_28 != 0)\n        goto cleanup;\n    VAR_24 = VAR_7->princ;\n\n    /* COMMENT_29 */\n                                                                          \n    VAR_40 = is_cross_tgs_principal(VAR_7->princ) &&\n        !krb5_principal_compare(VAR_53, VAR_6->server, VAR_7->princ);\n\n    VAR_48->stage = VAR_59;\n\n    if ((VAR_28 = krb5_timeofday(VAR_53, &VAR_18))) {\n        VAR_29 = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((VAR_16 = validate_tgs_request(VAR_47,\n                                       VAR_6, *VAR_7, VAR_12,\n                                       VAR_18, &VAR_29, &VAR_46))) {\n        if (!VAR_29)\n            VAR_29 = \"UNKNOWN_REASON\";\n        if (VAR_16 == VAR_60 || VAR_16 == VAR_61)\n            VAR_48->violation = VAR_62;\n        VAR_28 = VAR_16 + VAR_63;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(VAR_47, VAR_30->client))\n        setflag(VAR_38, VAR_64);\n\n    /* COMMENT_31 */\n    VAR_28 = kdc_process_s4u2self_req(VAR_47,\n                                       VAR_6,\n                                       VAR_30->client,\n                                       VAR_7,\n                                       VAR_4,\n                                       VAR_30->session,\n                                       VAR_18,\n                                       &VAR_36,\n                                       &VAR_32,\n                                       &VAR_29);\n    if (VAR_36 != NULL || VAR_28 != 0) {\n        if (VAR_36 != NULL)\n            VAR_48->s4u2self_user = VAR_36->user_id.user;\n        if (VAR_28 == VAR_60 || VAR_28 == VAR_61)\n            VAR_48->violation = VAR_62;\n        VAR_48->status = VAR_29;\n        kau_s4u2self(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n        VAR_48->s4u2self_user = NULL;\n    }\n\n    if (VAR_28)\n        goto cleanup;\n    if (VAR_36 != NULL) {\n        setflag(VAR_38, VAR_65);\n        if (VAR_40) {\n            /* COMMENT_32 */\n                                                                             \n            VAR_28 = VAR_66;\n            VAR_29 = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* COMMENT_34 */\n    VAR_28 = decrypt_2ndtkt(VAR_47, VAR_6, VAR_38,\n                             &VAR_8, &VAR_29);\n    if (VAR_28)\n        goto cleanup;\n\n    if (isflagset(VAR_6->kdc_options, VAR_67)) {\n        /* COMMENT_35 */\n        VAR_28 = kdc_process_s4u2proxy_req(VAR_47,\n                                            VAR_6,\n                                            VAR_6->second_ticket[VAR_13]->enc_part2,\n                                            VAR_8,\n                                            VAR_12->enc_part2->client,\n                                            VAR_6->server,\n                                            &VAR_29);\n        if (VAR_28 == VAR_60 || VAR_28 == VAR_61)\n            VAR_48->violation = VAR_62;\n        else if (VAR_28)\n            VAR_48->violation = VAR_68;\n        VAR_48->status = VAR_29;\n        VAR_16 = kau_make_tkt_id(VAR_53, VAR_6->second_ticket[VAR_13],\n                                  &VAR_48->evid_tkt_id);\n        if (VAR_16) {\n            VAR_29 = \"GENERATE_TICKET_ID\";\n            VAR_28 = VAR_16;\n            goto cleanup;\n        }\n        kau_s4u2proxy(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n        if (VAR_28)\n            goto cleanup;\n\n        setflag(VAR_38, VAR_69);\n\n        assert(krb5_is_tgs_principal(VAR_12->server));\n\n        assert(VAR_32 == NULL); /* COMMENT_36 */\n        VAR_32 = VAR_8;\n        VAR_8 = NULL;\n    } else if (VAR_6->kdc_options & VAR_70) {\n        krb5_db_free_principal(VAR_53, VAR_8);\n        VAR_8 = NULL;\n    } else\n        assert(VAR_8 == NULL);\n\n    VAR_48->stage = VAR_71;\n\n    VAR_28 = gen_session_key(VAR_47, VAR_6, VAR_7, &VAR_20,\n                              &VAR_29);\n    if (VAR_28)\n        goto cleanup;\n\n    /* COMMENT_37 */\n                                                                     \n                                                                     \n                                                                     \n                                                        \n       \n\n    if (isflagset(VAR_38, VAR_69))\n        VAR_31 = VAR_6->second_ticket[VAR_13]->enc_part2;\n    else\n        VAR_31 = VAR_30;\n    VAR_19 = VAR_31->times.authtime;\n\n    /* COMMENT_43 */\n                                                          \n    if (VAR_36 == NULL) {\n        VAR_28 = get_auth_indicators(VAR_53, VAR_31, VAR_34,\n                                      &VAR_49);\n        if (VAR_28) {\n            VAR_29 = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    VAR_28 = check_indicators(VAR_53, VAR_7, VAR_49);\n    if (VAR_28) {\n        VAR_29 = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (VAR_40)\n        VAR_11.server = VAR_7->princ;\n    else\n        VAR_11.server = VAR_6->server; /* COMMENT_45 */\n\n    VAR_14.flags = OPTS2FLAGS(VAR_6->kdc_options);\n    VAR_14.flags |= COPY_TKT_FLAGS(VAR_30->flags);\n    VAR_14.times.starttime = 0;\n\n    if (isflagset(VAR_7->attributes, VAR_72))\n        setflag(VAR_14.flags, VAR_73);\n\n    /* COMMENT_46 */\n    setflag(VAR_14.flags, VAR_74);\n\n    /* COMMENT_47 */\n\n    VAR_14.caddrs = VAR_30->caddrs;\n    /* COMMENT_48 */\n    VAR_10.caddrs = 0;/* COMMENT_49 */\n    VAR_10.enc_padata = NULL;\n\n    /* COMMENT_50 */\n                                                          \n                                                           \n                                                   \n       \n\n    if (isflagset(VAR_6->kdc_options, VAR_75)) {\n\n        if (isflagset(VAR_38, VAR_65)) {\n            /* COMMENT_55 */\n                                                                            \n                                                                       \n                                                                       \n                                                                        \n              \n                                                             \n                                      \n               \n            if (VAR_32 != NULL &&\n                isflagset(VAR_32->attributes, VAR_76))\n                clear(VAR_14.flags, VAR_77);\n            /* COMMENT_64 */\n                                                                  \n               \n            else if (!isflagset(VAR_30->flags, VAR_77))\n                clear(VAR_14.flags, VAR_77);\n            /* COMMENT_67 */\n                                                                           \n                                                                        \n               \n            else if (!VAR_40 &&\n                     !isflagset(VAR_7->attributes,\n                                VAR_78))\n                clear(VAR_14.flags, VAR_77);\n        }\n    }\n\n    if (isflagset(VAR_6->kdc_options, VAR_79) ||\n        isflagset(VAR_6->kdc_options, VAR_80)) {\n\n        /* COMMENT_71 */\n\n        VAR_14.caddrs = VAR_6->addresses;\n        VAR_10.caddrs = VAR_6->addresses;\n    }\n    /* COMMENT_72 */\n                                                        \n    if (isflagset(VAR_6->kdc_options, VAR_81) &&\n        !isflagset(VAR_30->flags, VAR_82))\n        clear(VAR_14.flags, VAR_82);\n\n    if (isflagset(VAR_6->kdc_options, VAR_83)) {\n        setflag(VAR_14.flags, VAR_84);\n        VAR_14.times.starttime = VAR_6->from;\n    } else\n        VAR_14.times.starttime = VAR_18;\n\n    if (isflagset(VAR_6->kdc_options, VAR_85)) {\n        assert(isflagset(VAR_38, VAR_86) == 0);\n        /* COMMENT_74 */\n                           \n        VAR_11 = *(VAR_12);\n        VAR_14 = *(VAR_12->enc_part2);\n        VAR_14.authorization_data = NULL;\n        clear(VAR_14.flags, VAR_84);\n    }\n\n    if (isflagset(VAR_6->kdc_options, VAR_87)) {\n        krb5_timestamp VAR_88;\n        krb5_deltat VAR_89;\n\n        assert(isflagset(VAR_38, VAR_86) == 0);\n        /* COMMENT_76 */\n                           \n        VAR_11 = *(VAR_12);\n        VAR_14 = *(VAR_12->enc_part2);\n        VAR_14.authorization_data = NULL;\n\n        VAR_88 = VAR_14.times.starttime ?\n            VAR_14.times.starttime : VAR_14.times.authtime;\n        VAR_89 = ts_delta(VAR_14.times.endtime, VAR_88);\n\n        VAR_14.times.starttime = VAR_18;\n        VAR_14.times.endtime =\n            ts_min(VAR_12->enc_part2->times.renew_till,\n                   ts_incr(VAR_18, VAR_89));\n    } else {\n        /* COMMENT_78 */\n        VAR_14.times.starttime = VAR_18;\n\n        kdc_get_ticket_endtime(VAR_47, VAR_14.times.starttime,\n                               VAR_30->times.endtime, VAR_6->till,\n                               VAR_32, VAR_7, &VAR_14.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(VAR_47, VAR_6, VAR_30, VAR_32,\n                             VAR_7, &VAR_14);\n\n    /* COMMENT_79 */\n                                                                 \n       \n    VAR_14.times.authtime = VAR_19;\n\n    /* COMMENT_82 */\n                                         \n    if (VAR_14.times.starttime == VAR_14.times.authtime)\n        VAR_14.times.starttime = 0;\n\n    if (isflagset(VAR_38, VAR_65)) {\n        VAR_25 = VAR_36->user_id.user;\n    } else if (isflagset(VAR_38, VAR_69)) {\n        VAR_25 = VAR_31->client;\n    } else {\n        VAR_25 = NULL;\n    }\n    if (isflagset(VAR_6->kdc_options, VAR_70)) {\n        krb5_enc_tkt_part *VAR_90 = VAR_6->second_ticket[VAR_13]->enc_part2;\n        VAR_17 = *(VAR_90->session);\n    } else {\n        /* COMMENT_84 */\n                              \n           \n        if ((VAR_28 = krb5_dbe_find_enctype(VAR_53, VAR_7,\n                                             -1, /* COMMENT_87 */\n                                             -1, /* COMMENT_88 */\n                                             0,  /* COMMENT_89 */\n                                             &VAR_22))) {\n            VAR_29 = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /* COMMENT_90 */\n                                             \n                                                \n           \n        if ((VAR_28 = krb5_dbe_decrypt_key_data(VAR_53, NULL,\n                                                 VAR_22, &VAR_17,\n                                                 NULL))) {\n            VAR_29 = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(VAR_38, VAR_69)) {\n        /* COMMENT_94 */\n                                                                       \n                                                                    \n                                                            \n           \n        clear(VAR_7->attributes, VAR_91);\n    }\n    if (isflagset(VAR_7->attributes, VAR_91) == 0) {\n        /* COMMENT_99 */\n                                                                         \n                                                                           \n                                     \n          \n                                                                        \n                                                       \n           \n        if (!isflagset(VAR_38, VAR_86)) {\n            /* COMMENT_107 */\n            setflag(VAR_38, VAR_92);\n            /* COMMENT_108 */\n            setflag(VAR_38, VAR_93);\n\n            assert(VAR_32 == NULL); /* COMMENT_109 */\n\n            VAR_28 = krb5_db_get_principal(VAR_53, VAR_31->client,\n                                            VAR_38, &VAR_32);\n        }\n    }\n\n    if (isflagset(VAR_38, VAR_65) &&\n        !isflagset(VAR_38, VAR_64))\n        VAR_14.client = VAR_36->user_id.user;\n    else\n        VAR_14.client = VAR_31->client;\n\n    VAR_14.session = &VAR_20;\n    VAR_14.transited.tr_type = VAR_94;\n    VAR_14.transited.tr_contents = VAR_95; /* COMMENT_110 */\n\n    /* COMMENT_111 */\n                                                                       \n                                                                             \n                                                                             \n                                                                         \n               \n       \n    /* COMMENT_118 */\n    if (krb5_realm_compare(VAR_53, VAR_12->server, VAR_96) ||\n        krb5_realm_compare(VAR_53, VAR_12->server,\n                           VAR_14.client)) {\n        /* COMMENT_119 */\n        VAR_14.transited = VAR_30->transited;\n    } else {\n        /* COMMENT_120 */\n        /* COMMENT_121 */\n        if (VAR_30->transited.tr_type !=\n            VAR_94) {\n            VAR_29 = \"VALIDATE_TRANSIT_TYPE\";\n            VAR_28 = VAR_97;\n            goto cleanup;\n        }\n        memset(&VAR_14.transited, 0, sizeof(VAR_14.transited));\n        VAR_14.transited.tr_type = VAR_94;\n        if ((VAR_28 =\n             add_to_transited(&VAR_30->transited.tr_contents,\n                              &VAR_14.transited.tr_contents,\n                              VAR_12->server,\n                              VAR_14.client,\n                              VAR_6->server))) {\n            VAR_29 = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        VAR_15 = 1;\n    }\n    if (isflagset(VAR_38, VAR_64)) {\n        VAR_28 = validate_transit_path(VAR_53, VAR_30->client,\n                                        VAR_7, VAR_33);\n        if (VAR_28) {\n            VAR_29 = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (VAR_6->kdc_options, VAR_98)) {\n        VAR_28 = kdc_check_transited_list (VAR_47,\n                                            &VAR_14.transited.tr_contents,\n                                            krb5_princ_realm (VAR_53, VAR_30->client),\n                                            krb5_princ_realm (VAR_53, VAR_6->server));\n        if (VAR_28 == 0) {\n            setflag (VAR_14.flags, VAR_99);\n        } else {\n            log_tgs_badtrans(VAR_53, VAR_23, VAR_24,\n                             &VAR_14.transited.tr_contents, VAR_28);\n        }\n    } else\n        krb5_klog_syslog(VAR_100, _(\"not checking transit path\"));\n    if (VAR_47->realm_reject_bad_transit &&\n        !isflagset(VAR_14.flags, VAR_99)) {\n        VAR_28 = VAR_101;\n        VAR_29 = \"BAD_TRANSIT\";\n        VAR_48->violation = VAR_68;\n        goto cleanup;\n    }\n\n    VAR_28 = handle_authdata(VAR_53, VAR_38, VAR_32, VAR_7,\n                              VAR_33, VAR_34,\n                              VAR_4 != NULL ? VAR_4 :\n                              VAR_12->enc_part2->session,\n                              &VAR_17, /* COMMENT_122 */\n                              VAR_5,\n                              VAR_1,\n                              VAR_6,\n                              VAR_36 ?\n                              VAR_36->user_id.user : NULL,\n                              VAR_31,\n                              VAR_49,\n                              &VAR_14);\n    if (VAR_28) {\n        krb5_klog_syslog(VAR_100, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         VAR_28);\n        VAR_29 = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    VAR_11.enc_part2 = &VAR_14;\n\n    /* COMMENT_123 */\n                                                                  \n                                                                \n                                                                   \n                         \n       \n    if (isflagset(VAR_6->kdc_options, VAR_70)) {\n        /* COMMENT_129 */\n                                                             \n                            \n           \n        krb5_enc_tkt_part *VAR_90 = VAR_6->second_ticket[VAR_13]->enc_part2;\n        krb5_principal VAR_102 = VAR_90->client;\n        if (!krb5_principal_compare(VAR_53, VAR_6->server, VAR_102)) {\n            VAR_25 = VAR_102;\n            VAR_28 = VAR_103;\n            VAR_29 = \"2ND_TKT_MISMATCH\";\n            VAR_48->status = VAR_29;\n            kau_u2u(VAR_53, FALSE, VAR_48);\n            goto cleanup;\n        }\n\n        VAR_42 = 0;\n        VAR_11.enc_part.enctype = VAR_90->session->enctype;\n        kau_u2u(VAR_53, TRUE, VAR_48);\n        VAR_13++;\n    } else {\n        VAR_42 = VAR_22->key_data_kvno;\n    }\n\n    VAR_28 = krb5_encrypt_tkt_part(VAR_53, &VAR_17,\n                                    &VAR_11);\n    if (!isflagset(VAR_6->kdc_options, VAR_70))\n        krb5_free_keyblock_contents(VAR_53, &VAR_17);\n    if (VAR_28) {\n        VAR_29 = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    VAR_11.enc_part.kvno = VAR_42;\n    /* COMMENT_133 */\n    VAR_48->stage = VAR_104;\n    VAR_9.msg_type = VAR_105;\n    if (isflagset(VAR_38, VAR_65) &&\n        krb5int_find_pa_data(VAR_53, VAR_6->padata,\n                             VAR_106) != NULL) {\n        VAR_28 = kdc_make_s4u2self_rep(VAR_53,\n                                        VAR_4,\n                                        VAR_12->enc_part2->session,\n                                        VAR_36,\n                                        &VAR_9,\n                                        &VAR_10);\n        if (VAR_28) {\n            VAR_29 = \"MAKE_S4U2SELF_PADATA\";\n            VAR_48->status = VAR_29;\n        }\n        kau_s4u2self(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n        if (VAR_28)\n            goto cleanup;\n    }\n\n    VAR_9.client = VAR_14.client;\n    VAR_9.enc_part.kvno = 0;/* COMMENT_134 */\n    VAR_9.ticket = &VAR_11;\n\n    VAR_10.session = &VAR_20;\n    VAR_10.nonce = VAR_6->nonce;\n\n    /* COMMENT_135 */\n    VAR_10.times = VAR_14.times;\n\n    VAR_27.lr_type = VAR_107;\n    VAR_27.value = 0;\n    VAR_27.magic = 0;\n    VAR_26[0] = &VAR_27;\n    VAR_26[1] = 0;\n    VAR_10.last_req = VAR_26;        /* COMMENT_136 */\n    VAR_10.key_exp = 0;/* COMMENT_137 */\n    VAR_10.flags = VAR_14.flags;\n    VAR_10.server = VAR_11.server;\n\n    /* COMMENT_138 */\n                       \n    VAR_9.enc_part.enctype = VAR_4 ? VAR_4->enctype :\n        VAR_12->enc_part2->session->enctype;\n    VAR_28  = kdc_fast_response_handle_padata(VAR_43, VAR_6, &VAR_9,\n                                               VAR_4 ? VAR_4->enctype : VAR_12->enc_part2->session->enctype);\n    if (VAR_28 !=0 ) {\n        VAR_29 = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    VAR_28 =kdc_fast_handle_reply_key(VAR_43,\n                                       VAR_4?VAR_4:VAR_12->enc_part2->session, &VAR_21);\n    if (VAR_28) {\n        VAR_29  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    VAR_28 = return_enc_padata(VAR_53, VAR_1, VAR_6,\n                                VAR_21, VAR_7, &VAR_10,\n                                VAR_40 &&\n                                isflagset(VAR_39,\n                                          VAR_58));\n    if (VAR_28) {\n        VAR_29 = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    VAR_28 = kau_make_tkt_id(VAR_53, &VAR_11, &VAR_48->tkt_out_id);\n    if (VAR_28) {\n        VAR_29 = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(VAR_43))\n        VAR_9.client = (krb5_principal)krb5_anonymous_principal();\n    VAR_28 = krb5_encode_kdc_rep(VAR_53, VAR_105, &VAR_10,\n                                  VAR_4 ? 1 : 0,\n                                  VAR_21,\n                                  &VAR_9, VAR_3);\n    if (VAR_28) {\n        VAR_29 = \"ENCODE_KDC_REP\";\n    } else {\n        VAR_29 = \"ISSUE\";\n    }\n\n    memset(VAR_11.enc_part.ciphertext.data, 0,\n           VAR_11.enc_part.ciphertext.length);\n    free(VAR_11.enc_part.ciphertext.data);\n    /* COMMENT_140 */\n                                                               \n    memset(VAR_9.enc_part.ciphertext.data, 0,\n           VAR_9.enc_part.ciphertext.length);\n    free(VAR_9.enc_part.ciphertext.data);\n\ncleanup:\n    assert(VAR_29 != NULL);\n    if (VAR_21)\n        krb5_free_keyblock(VAR_53, VAR_21);\n    if (VAR_28)\n        VAR_41 = krb5_get_error_message (VAR_53, VAR_28);\n\n    VAR_48->status = VAR_29;\n    if (!VAR_28)\n        VAR_48->reply = &VAR_9;\n    kau_tgs_req(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n    kau_free_kdc_req(VAR_48);\n\n    log_tgs_req(VAR_53, VAR_2, VAR_6, &VAR_9, VAR_23,\n                VAR_24, VAR_25, VAR_19,\n                VAR_38, VAR_29, VAR_28, VAR_41);\n    if (VAR_28) {\n        krb5_free_error_message (VAR_53, VAR_41);\n        VAR_41 = NULL;\n    }\n\n    if (VAR_28) {\n        int VAR_108 = 0;\n        if (VAR_29 == 0) {\n            VAR_29 = krb5_get_error_message (VAR_53, VAR_28);\n            VAR_108 = 1;\n        }\n        VAR_28 -= VAR_63;\n        if (VAR_28 < 0 || VAR_28 > VAR_109)\n            VAR_28 = VAR_110;\n\n        VAR_16 = prepare_error_tgs(VAR_43, VAR_6, VAR_12, VAR_28,\n                                   (VAR_7 != NULL) ? VAR_7->princ : NULL,\n                                   VAR_3, VAR_29, VAR_46);\n        if (VAR_108) {\n            krb5_free_error_message (VAR_53, VAR_29);\n            VAR_29 = 0;\n        }\n    }\n\n    if (VAR_12 != NULL)\n        krb5_free_ticket(VAR_53, VAR_12);\n    if (VAR_6 != NULL)\n        krb5_free_kdc_req(VAR_53, VAR_6);\n    if (VAR_43)\n        kdc_free_rstate(VAR_43);\n    krb5_db_free_principal(VAR_53, VAR_7);\n    krb5_db_free_principal(VAR_53, VAR_8);\n    krb5_db_free_principal(VAR_53, VAR_33);\n    krb5_db_free_principal(VAR_53, VAR_32);\n    krb5_db_free_principal(VAR_53, VAR_35);\n    if (VAR_20.contents != NULL)\n        krb5_free_keyblock_contents(VAR_53, &VAR_20);\n    if (VAR_15)\n        free(VAR_14.transited.tr_contents.data);\n    if (VAR_36 != NULL)\n        krb5_free_pa_s4u_x509_user(VAR_53, VAR_36);\n    if (VAR_37 != NULL)\n        krb5_free_authdata(VAR_53, VAR_37);\n    if (VAR_4 != NULL)\n        krb5_free_keyblock(VAR_53, VAR_4);\n    if (VAR_5 != NULL)\n        krb5_free_keyblock(VAR_53, VAR_5);\n    if (VAR_9.padata)\n        krb5_free_pa_data(VAR_53, VAR_9.padata);\n    if (VAR_10.enc_padata)\n        krb5_free_pa_data(VAR_53, VAR_10.enc_padata);\n    if (VAR_14.authorization_data != NULL)\n        krb5_free_authdata(VAR_53, VAR_14.authorization_data);\n    krb5_free_pa_data(VAR_53, VAR_46);\n    k5_free_data_ptr_list(VAR_49);\n\n    return VAR_16;\n}",
  "func_graph_path_before": "krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970/do_tgs_req.c/vul/before/0.json",
  "func": "krb5_error_code\nprocess_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL) {\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        if (is_referral) {\n            /* The requesting server appears to no longer exist, and we found\n             * a referral instead.  Treat this as a server lookup failure. */\n            errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            status = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* Deal with user-to-user and constrained delegation */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, request->second_ticket[st_idx],\n                                  &au_state->evid_tkt_id);\n        if (retval) {\n            status = \"GENERATE_TICKET_ID\";\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract auth indicators from the subject ticket, except for S4U2Proxy\n     * requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    errcode = check_indicators(kdc_context, server, auth_indicators);\n    if (errcode) {\n        status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = OPTS2FLAGS(request->kdc_options);\n    enc_tkt_reply.flags |= COPY_TKT_FLAGS(header_enc_tkt->flags);\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /* Indicate support for encrypted padata (RFC 6806). */\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones, so just ignore the option. */\n    if (isflagset(request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS) &&\n        !isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        clear(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, header_server);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              header_server, local_tgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              header_key,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              auth_indicators,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            au_state->status = status;\n            kau_u2u(kdc_context, FALSE, au_state);\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"MAKE_S4U2SELF_PADATA\";\n            au_state->status = status;\n        }\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n\n    return retval;\n}",
  "abstract_func": "krb5_error_code\nprocess_tgs_req(struct server_handle *VAR_0, krb5_data *VAR_1,\n                const krb5_fulladdr *VAR_2, krb5_data **VAR_3)\n{\n    krb5_keyblock * VAR_4 = 0;\n    krb5_keyblock *VAR_5 = NULL;\n    krb5_kdc_req *VAR_6 = 0;\n    krb5_db_entry *VAR_7 = NULL;\n    krb5_db_entry *VAR_8 = NULL;\n    krb5_kdc_rep VAR_9;\n    krb5_enc_kdc_rep_part VAR_10;\n    krb5_ticket VAR_11, *VAR_12 = 0;\n    int VAR_13 = 0;\n    krb5_enc_tkt_part VAR_14;\n    int VAR_15 = 0;\n    krb5_error_code VAR_16 = 0;\n    krb5_keyblock VAR_17;\n    krb5_timestamp VAR_18, VAR_19 = 0;\n    krb5_keyblock VAR_20;\n    krb5_keyblock *VAR_21 = NULL;\n    krb5_key_data  *VAR_22;\n    krb5_principal VAR_23 = NULL, VAR_24 = NULL, VAR_25 = NULL;\n    krb5_last_req_entry *VAR_26[2], VAR_27;\n    int VAR_28;\n    const char        *VAR_29 = 0;\n    krb5_enc_tkt_part *VAR_30 = NULL; /* COMMENT_0 */\n    krb5_enc_tkt_part *VAR_31 = NULL; /* COMMENT_1 */\n    krb5_db_entry *VAR_32 = NULL, *VAR_33 = NULL;\n    krb5_db_entry *VAR_34, *VAR_35 = NULL;\n    krb5_pa_s4u_x509_user *VAR_36 = NULL; /* COMMENT_2 */\n    krb5_authdata **VAR_37 = NULL; /* COMMENT_3 */\n    unsigned int VAR_38 = 0, VAR_39 = 0;       /* COMMENT_4 */\n    krb5_boolean VAR_40;\n    const char *VAR_41 = NULL;\n    krb5_kvno VAR_42 = 0;\n    struct kdc_request_state *VAR_43 = NULL;\n    krb5_pa_data *VAR_44; /* COMMENT_5 */\n    krb5_data VAR_45;\n    krb5_pa_data **VAR_46 = NULL;\n    kdc_realm_t *VAR_47 = NULL;\n    krb5_audit_state *VAR_48 = NULL;\n    krb5_data **VAR_49 = NULL;\n\n    memset(&VAR_9, 0, sizeof(VAR_9));\n    memset(&VAR_10, 0, sizeof(VAR_10));\n    memset(&VAR_11, 0, sizeof(VAR_11));\n    memset(&VAR_14, 0, sizeof(VAR_14));\n    VAR_20.contents = NULL;\n\n    VAR_16 = decode_krb5_tgs_req(VAR_1, &VAR_6);\n    if (VAR_16)\n        return VAR_16;\n    /* COMMENT_6 */\n                                                             \n    VAR_24 = VAR_6->server;\n\n    if (VAR_6->msg_type != VAR_50) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_51;\n    }\n\n    /* COMMENT_8 */\n                                                                           \n       \n    VAR_47 = setup_server_realm(VAR_0, VAR_6->server);\n    if (VAR_47 == NULL) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_52;\n    }\n    VAR_28 = kdc_make_rstate(VAR_47, &VAR_43);\n    if (VAR_28 !=0) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_28;\n    }\n\n    /* COMMENT_11 */\n    VAR_28 = kau_init_kdc_req(VAR_53, VAR_6, VAR_2, &VAR_48);\n    if (VAR_28) {\n        krb5_free_kdc_req(VAR_0->kdc_err_context, VAR_6);\n        return VAR_28;\n    }\n    /* COMMENT_12 */\n    kau_tgs_req(VAR_53, TRUE, VAR_48);\n\n    VAR_28 = kdc_process_tgs_req(VAR_47,\n                                  VAR_6, VAR_2, VAR_1, &VAR_12,\n                                  &VAR_33, &VAR_5, &VAR_4,\n                                  &VAR_44);\n    if (VAR_12 && VAR_12->enc_part2)\n        VAR_23 = VAR_12->enc_part2->client;\n\n    if (VAR_28) {\n        VAR_29 = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!VAR_12) {\n        VAR_28 = VAR_54;        /* COMMENT_13 */\n        VAR_29=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    VAR_28 = kau_make_tkt_id(VAR_53, VAR_12,\n                              &VAR_48->tkt_in_id);\n    if (VAR_28) {\n        VAR_29 = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    VAR_45.length = VAR_44->length;\n    VAR_45.data = (char *) VAR_44->contents;\n    VAR_28 = kdc_find_fast(&VAR_6, &VAR_45, VAR_4,\n                            VAR_12->enc_part2->session, VAR_43, NULL);\n    /* COMMENT_14 */\n    VAR_24 = VAR_6->server;\n    if (VAR_28 !=0) {\n        VAR_29 = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    VAR_28 = get_local_tgt(VAR_53, &VAR_24->realm, VAR_33,\n                            &VAR_34, &VAR_35);\n    if (VAR_28) {\n        VAR_29 = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* COMMENT_15 */\n    VAR_48->request = VAR_6;\n\n    /* COMMENT_16 */\n                                                                       \n                                                                     \n                                                                       \n                                                \n       \n    VAR_30 = VAR_12->enc_part2;\n\n    /* COMMENT_22 */\n                                                                    \n                                                                      \n                                      \n       \n\n    VAR_48->stage = VAR_55;\n\n    /* COMMENT_27 */\n                 \n\n    setflag(VAR_39, VAR_56);\n    if (isflagset(VAR_6->kdc_options, VAR_57)) {\n        setflag(VAR_38, VAR_58);\n        setflag(VAR_39, VAR_58);\n    }\n\n    VAR_28 = search_sprinc(VAR_47, VAR_6, VAR_39, &VAR_7,\n                            &VAR_29);\n    if (VAR_28 != 0)\n        goto cleanup;\n    VAR_24 = VAR_7->princ;\n\n    /* COMMENT_29 */\n                                                                          \n    VAR_40 = is_cross_tgs_principal(VAR_7->princ) &&\n        !krb5_principal_compare(VAR_53, VAR_6->server, VAR_7->princ);\n\n    VAR_48->stage = VAR_59;\n\n    if ((VAR_28 = krb5_timeofday(VAR_53, &VAR_18))) {\n        VAR_29 = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((VAR_16 = validate_tgs_request(VAR_47,\n                                       VAR_6, *VAR_7, VAR_12,\n                                       VAR_18, &VAR_29, &VAR_46))) {\n        if (!VAR_29)\n            VAR_29 = \"UNKNOWN_REASON\";\n        if (VAR_16 == VAR_60 || VAR_16 == VAR_61)\n            VAR_48->violation = VAR_62;\n        VAR_28 = VAR_16 + VAR_63;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(VAR_47, VAR_30->client))\n        setflag(VAR_38, VAR_64);\n\n    /* COMMENT_31 */\n    VAR_28 = kdc_process_s4u2self_req(VAR_47,\n                                       VAR_6,\n                                       VAR_30->client,\n                                       VAR_7,\n                                       VAR_4,\n                                       VAR_30->session,\n                                       VAR_18,\n                                       &VAR_36,\n                                       &VAR_32,\n                                       &VAR_29);\n    if (VAR_36 != NULL || VAR_28 != 0) {\n        if (VAR_36 != NULL)\n            VAR_48->s4u2self_user = VAR_36->user_id.user;\n        if (VAR_28 == VAR_60 || VAR_28 == VAR_61)\n            VAR_48->violation = VAR_62;\n        VAR_48->status = VAR_29;\n        kau_s4u2self(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n        VAR_48->s4u2self_user = NULL;\n    }\n\n    if (VAR_28)\n        goto cleanup;\n    if (VAR_36 != NULL) {\n        setflag(VAR_38, VAR_65);\n        if (VAR_40) {\n            /* COMMENT_32 */\n                                                                             \n            VAR_28 = VAR_66;\n            VAR_29 = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* COMMENT_34 */\n    VAR_28 = decrypt_2ndtkt(VAR_47, VAR_6, VAR_38,\n                             &VAR_8, &VAR_29);\n    if (VAR_28)\n        goto cleanup;\n\n    if (isflagset(VAR_6->kdc_options, VAR_67)) {\n        /* COMMENT_35 */\n        VAR_28 = kdc_process_s4u2proxy_req(VAR_47,\n                                            VAR_6,\n                                            VAR_6->second_ticket[VAR_13]->enc_part2,\n                                            VAR_8,\n                                            VAR_12->enc_part2->client,\n                                            VAR_6->server,\n                                            &VAR_29);\n        if (VAR_28 == VAR_60 || VAR_28 == VAR_61)\n            VAR_48->violation = VAR_62;\n        else if (VAR_28)\n            VAR_48->violation = VAR_68;\n        VAR_48->status = VAR_29;\n        VAR_16 = kau_make_tkt_id(VAR_53, VAR_6->second_ticket[VAR_13],\n                                  &VAR_48->evid_tkt_id);\n        if (VAR_16) {\n            VAR_29 = \"GENERATE_TICKET_ID\";\n            VAR_28 = VAR_16;\n            goto cleanup;\n        }\n        kau_s4u2proxy(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n        if (VAR_28)\n            goto cleanup;\n\n        setflag(VAR_38, VAR_69);\n\n        assert(krb5_is_tgs_principal(VAR_12->server));\n\n        assert(VAR_32 == NULL); /* COMMENT_36 */\n        VAR_32 = VAR_8;\n        VAR_8 = NULL;\n    } else if (VAR_6->kdc_options & VAR_70) {\n        krb5_db_free_principal(VAR_53, VAR_8);\n        VAR_8 = NULL;\n    } else\n        assert(VAR_8 == NULL);\n\n    VAR_48->stage = VAR_71;\n\n    VAR_28 = gen_session_key(VAR_47, VAR_6, VAR_7, &VAR_20,\n                              &VAR_29);\n    if (VAR_28)\n        goto cleanup;\n\n    /* COMMENT_37 */\n                                                                     \n                                                                     \n                                                                     \n                                                        \n       \n\n    if (isflagset(VAR_38, VAR_69))\n        VAR_31 = VAR_6->second_ticket[VAR_13]->enc_part2;\n    else\n        VAR_31 = VAR_30;\n    VAR_19 = VAR_31->times.authtime;\n\n    /* COMMENT_43 */\n                                                          \n    if (VAR_36 == NULL) {\n        VAR_28 = get_auth_indicators(VAR_53, VAR_31, VAR_34,\n                                      &VAR_49);\n        if (VAR_28) {\n            VAR_29 = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    VAR_28 = check_indicators(VAR_53, VAR_7, VAR_49);\n    if (VAR_28) {\n        VAR_29 = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (VAR_40)\n        VAR_11.server = VAR_7->princ;\n    else\n        VAR_11.server = VAR_6->server; /* COMMENT_45 */\n\n    VAR_14.flags = OPTS2FLAGS(VAR_6->kdc_options);\n    VAR_14.flags |= COPY_TKT_FLAGS(VAR_30->flags);\n    VAR_14.times.starttime = 0;\n\n    if (isflagset(VAR_7->attributes, VAR_72))\n        setflag(VAR_14.flags, VAR_73);\n\n    /* COMMENT_46 */\n    setflag(VAR_14.flags, VAR_74);\n\n    /* COMMENT_47 */\n\n    VAR_14.caddrs = VAR_30->caddrs;\n    /* COMMENT_48 */\n    VAR_10.caddrs = 0;/* COMMENT_49 */\n    VAR_10.enc_padata = NULL;\n\n    /* COMMENT_50 */\n                                                          \n                                                           \n                                                   \n       \n\n    if (isflagset(VAR_6->kdc_options, VAR_75)) {\n\n        if (isflagset(VAR_38, VAR_65)) {\n            /* COMMENT_55 */\n                                                                            \n                                                                       \n                                                                       \n                                                                        \n              \n                                                             \n                                      \n               \n            if (VAR_32 != NULL &&\n                isflagset(VAR_32->attributes, VAR_76))\n                clear(VAR_14.flags, VAR_77);\n            /* COMMENT_64 */\n                                                                  \n               \n            else if (!isflagset(VAR_30->flags, VAR_77))\n                clear(VAR_14.flags, VAR_77);\n            /* COMMENT_67 */\n                                                                           \n                                                                        \n               \n            else if (!VAR_40 &&\n                     !isflagset(VAR_7->attributes,\n                                VAR_78))\n                clear(VAR_14.flags, VAR_77);\n        }\n    }\n\n    if (isflagset(VAR_6->kdc_options, VAR_79) ||\n        isflagset(VAR_6->kdc_options, VAR_80)) {\n\n        /* COMMENT_71 */\n\n        VAR_14.caddrs = VAR_6->addresses;\n        VAR_10.caddrs = VAR_6->addresses;\n    }\n    /* COMMENT_72 */\n                                                        \n    if (isflagset(VAR_6->kdc_options, VAR_81) &&\n        !isflagset(VAR_30->flags, VAR_82))\n        clear(VAR_14.flags, VAR_82);\n\n    if (isflagset(VAR_6->kdc_options, VAR_83)) {\n        setflag(VAR_14.flags, VAR_84);\n        VAR_14.times.starttime = VAR_6->from;\n    } else\n        VAR_14.times.starttime = VAR_18;\n\n    if (isflagset(VAR_6->kdc_options, VAR_85)) {\n        assert(isflagset(VAR_38, VAR_86) == 0);\n        /* COMMENT_74 */\n                           \n        VAR_11 = *(VAR_12);\n        VAR_14 = *(VAR_12->enc_part2);\n        VAR_14.authorization_data = NULL;\n        clear(VAR_14.flags, VAR_84);\n    }\n\n    if (isflagset(VAR_6->kdc_options, VAR_87)) {\n        krb5_timestamp VAR_88;\n        krb5_deltat VAR_89;\n\n        assert(isflagset(VAR_38, VAR_86) == 0);\n        /* COMMENT_76 */\n                           \n        VAR_11 = *(VAR_12);\n        VAR_14 = *(VAR_12->enc_part2);\n        VAR_14.authorization_data = NULL;\n\n        VAR_88 = VAR_14.times.starttime ?\n            VAR_14.times.starttime : VAR_14.times.authtime;\n        VAR_89 = ts_delta(VAR_14.times.endtime, VAR_88);\n\n        VAR_14.times.starttime = VAR_18;\n        VAR_14.times.endtime =\n            ts_min(VAR_12->enc_part2->times.renew_till,\n                   ts_incr(VAR_18, VAR_89));\n    } else {\n        /* COMMENT_78 */\n        VAR_14.times.starttime = VAR_18;\n\n        kdc_get_ticket_endtime(VAR_47, VAR_14.times.starttime,\n                               VAR_30->times.endtime, VAR_6->till,\n                               VAR_32, VAR_7, &VAR_14.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(VAR_47, VAR_6, VAR_30, VAR_32,\n                             VAR_7, &VAR_14);\n\n    /* COMMENT_79 */\n                                                                 \n       \n    VAR_14.times.authtime = VAR_19;\n\n    /* COMMENT_82 */\n                                         \n    if (VAR_14.times.starttime == VAR_14.times.authtime)\n        VAR_14.times.starttime = 0;\n\n    if (isflagset(VAR_38, VAR_65)) {\n        VAR_25 = VAR_36->user_id.user;\n    } else if (isflagset(VAR_38, VAR_69)) {\n        VAR_25 = VAR_31->client;\n    } else {\n        VAR_25 = NULL;\n    }\n    if (isflagset(VAR_6->kdc_options, VAR_70)) {\n        krb5_enc_tkt_part *VAR_90 = VAR_6->second_ticket[VAR_13]->enc_part2;\n        VAR_17 = *(VAR_90->session);\n    } else {\n        /* COMMENT_84 */\n                              \n           \n        if ((VAR_28 = krb5_dbe_find_enctype(VAR_53, VAR_7,\n                                             -1, /* COMMENT_87 */\n                                             -1, /* COMMENT_88 */\n                                             0,  /* COMMENT_89 */\n                                             &VAR_22))) {\n            VAR_29 = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /* COMMENT_90 */\n                                             \n                                                \n           \n        if ((VAR_28 = krb5_dbe_decrypt_key_data(VAR_53, NULL,\n                                                 VAR_22, &VAR_17,\n                                                 NULL))) {\n            VAR_29 = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(VAR_38, VAR_69)) {\n        /* COMMENT_94 */\n                                                                       \n                                                                    \n                                                            \n           \n        clear(VAR_7->attributes, VAR_91);\n    }\n    if (isflagset(VAR_7->attributes, VAR_91) == 0) {\n        /* COMMENT_99 */\n                                                                         \n                                                                           \n                                     \n          \n                                                                        \n                                                       \n           \n        if (!isflagset(VAR_38, VAR_86)) {\n            /* COMMENT_107 */\n            setflag(VAR_38, VAR_92);\n            /* COMMENT_108 */\n            setflag(VAR_38, VAR_93);\n\n            assert(VAR_32 == NULL); /* COMMENT_109 */\n\n            VAR_28 = krb5_db_get_principal(VAR_53, VAR_31->client,\n                                            VAR_38, &VAR_32);\n        }\n    }\n\n    if (isflagset(VAR_38, VAR_65) &&\n        !isflagset(VAR_38, VAR_64))\n        VAR_14.client = VAR_36->user_id.user;\n    else\n        VAR_14.client = VAR_31->client;\n\n    VAR_14.session = &VAR_20;\n    VAR_14.transited.tr_type = VAR_94;\n    VAR_14.transited.tr_contents = VAR_95; /* COMMENT_110 */\n\n    /* COMMENT_111 */\n                                                                       \n                                                                             \n                                                                             \n                                                                         \n               \n       \n    /* COMMENT_118 */\n    if (krb5_realm_compare(VAR_53, VAR_12->server, VAR_96) ||\n        krb5_realm_compare(VAR_53, VAR_12->server,\n                           VAR_14.client)) {\n        /* COMMENT_119 */\n        VAR_14.transited = VAR_30->transited;\n    } else {\n        /* COMMENT_120 */\n        /* COMMENT_121 */\n        if (VAR_30->transited.tr_type !=\n            VAR_94) {\n            VAR_29 = \"VALIDATE_TRANSIT_TYPE\";\n            VAR_28 = VAR_97;\n            goto cleanup;\n        }\n        memset(&VAR_14.transited, 0, sizeof(VAR_14.transited));\n        VAR_14.transited.tr_type = VAR_94;\n        if ((VAR_28 =\n             add_to_transited(&VAR_30->transited.tr_contents,\n                              &VAR_14.transited.tr_contents,\n                              VAR_12->server,\n                              VAR_14.client,\n                              VAR_6->server))) {\n            VAR_29 = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        VAR_15 = 1;\n    }\n    if (isflagset(VAR_38, VAR_64)) {\n        VAR_28 = validate_transit_path(VAR_53, VAR_30->client,\n                                        VAR_7, VAR_33);\n        if (VAR_28) {\n            VAR_29 = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (VAR_6->kdc_options, VAR_98)) {\n        VAR_28 = kdc_check_transited_list (VAR_47,\n                                            &VAR_14.transited.tr_contents,\n                                            krb5_princ_realm (VAR_53, VAR_30->client),\n                                            krb5_princ_realm (VAR_53, VAR_6->server));\n        if (VAR_28 == 0) {\n            setflag (VAR_14.flags, VAR_99);\n        } else {\n            log_tgs_badtrans(VAR_53, VAR_23, VAR_24,\n                             &VAR_14.transited.tr_contents, VAR_28);\n        }\n    } else\n        krb5_klog_syslog(VAR_100, _(\"not checking transit path\"));\n    if (VAR_47->realm_reject_bad_transit &&\n        !isflagset(VAR_14.flags, VAR_99)) {\n        VAR_28 = VAR_101;\n        VAR_29 = \"BAD_TRANSIT\";\n        VAR_48->violation = VAR_68;\n        goto cleanup;\n    }\n\n    VAR_28 = handle_authdata(VAR_53, VAR_38, VAR_32, VAR_7,\n                              VAR_33, VAR_34,\n                              VAR_4 != NULL ? VAR_4 :\n                              VAR_12->enc_part2->session,\n                              &VAR_17, /* COMMENT_122 */\n                              VAR_5,\n                              VAR_1,\n                              VAR_6,\n                              VAR_36 ?\n                              VAR_36->user_id.user : NULL,\n                              VAR_31,\n                              VAR_49,\n                              &VAR_14);\n    if (VAR_28) {\n        krb5_klog_syslog(VAR_100, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         VAR_28);\n        VAR_29 = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    VAR_11.enc_part2 = &VAR_14;\n\n    /* COMMENT_123 */\n                                                                  \n                                                                \n                                                                   \n                         \n       \n    if (isflagset(VAR_6->kdc_options, VAR_70)) {\n        /* COMMENT_129 */\n                                                             \n                            \n           \n        krb5_enc_tkt_part *VAR_90 = VAR_6->second_ticket[VAR_13]->enc_part2;\n        krb5_principal VAR_102 = VAR_90->client;\n        if (!krb5_principal_compare(VAR_53, VAR_6->server, VAR_102)) {\n            VAR_25 = VAR_102;\n            VAR_28 = VAR_103;\n            VAR_29 = \"2ND_TKT_MISMATCH\";\n            VAR_48->status = VAR_29;\n            kau_u2u(VAR_53, FALSE, VAR_48);\n            goto cleanup;\n        }\n\n        VAR_42 = 0;\n        VAR_11.enc_part.enctype = VAR_90->session->enctype;\n        kau_u2u(VAR_53, TRUE, VAR_48);\n        VAR_13++;\n    } else {\n        VAR_42 = VAR_22->key_data_kvno;\n    }\n\n    VAR_28 = krb5_encrypt_tkt_part(VAR_53, &VAR_17,\n                                    &VAR_11);\n    if (!isflagset(VAR_6->kdc_options, VAR_70))\n        krb5_free_keyblock_contents(VAR_53, &VAR_17);\n    if (VAR_28) {\n        VAR_29 = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    VAR_11.enc_part.kvno = VAR_42;\n    /* COMMENT_133 */\n    VAR_48->stage = VAR_104;\n    VAR_9.msg_type = VAR_105;\n    if (isflagset(VAR_38, VAR_65) &&\n        krb5int_find_pa_data(VAR_53, VAR_6->padata,\n                             VAR_106) != NULL) {\n        VAR_28 = kdc_make_s4u2self_rep(VAR_53,\n                                        VAR_4,\n                                        VAR_12->enc_part2->session,\n                                        VAR_36,\n                                        &VAR_9,\n                                        &VAR_10);\n        if (VAR_28) {\n            VAR_29 = \"MAKE_S4U2SELF_PADATA\";\n            VAR_48->status = VAR_29;\n        }\n        kau_s4u2self(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n        if (VAR_28)\n            goto cleanup;\n    }\n\n    VAR_9.client = VAR_14.client;\n    VAR_9.enc_part.kvno = 0;/* COMMENT_134 */\n    VAR_9.ticket = &VAR_11;\n\n    VAR_10.session = &VAR_20;\n    VAR_10.nonce = VAR_6->nonce;\n\n    /* COMMENT_135 */\n    VAR_10.times = VAR_14.times;\n\n    VAR_27.lr_type = VAR_107;\n    VAR_27.value = 0;\n    VAR_27.magic = 0;\n    VAR_26[0] = &VAR_27;\n    VAR_26[1] = 0;\n    VAR_10.last_req = VAR_26;        /* COMMENT_136 */\n    VAR_10.key_exp = 0;/* COMMENT_137 */\n    VAR_10.flags = VAR_14.flags;\n    VAR_10.server = VAR_11.server;\n\n    /* COMMENT_138 */\n                       \n    VAR_9.enc_part.enctype = VAR_4 ? VAR_4->enctype :\n        VAR_12->enc_part2->session->enctype;\n    VAR_28  = kdc_fast_response_handle_padata(VAR_43, VAR_6, &VAR_9,\n                                               VAR_4 ? VAR_4->enctype : VAR_12->enc_part2->session->enctype);\n    if (VAR_28 !=0 ) {\n        VAR_29 = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    VAR_28 =kdc_fast_handle_reply_key(VAR_43,\n                                       VAR_4?VAR_4:VAR_12->enc_part2->session, &VAR_21);\n    if (VAR_28) {\n        VAR_29  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    VAR_28 = return_enc_padata(VAR_53, VAR_1, VAR_6,\n                                VAR_21, VAR_7, &VAR_10,\n                                VAR_40 &&\n                                isflagset(VAR_39,\n                                          VAR_58));\n    if (VAR_28) {\n        VAR_29 = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    VAR_28 = kau_make_tkt_id(VAR_53, &VAR_11, &VAR_48->tkt_out_id);\n    if (VAR_28) {\n        VAR_29 = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(VAR_43))\n        VAR_9.client = (krb5_principal)krb5_anonymous_principal();\n    VAR_28 = krb5_encode_kdc_rep(VAR_53, VAR_105, &VAR_10,\n                                  VAR_4 ? 1 : 0,\n                                  VAR_21,\n                                  &VAR_9, VAR_3);\n    if (VAR_28) {\n        VAR_29 = \"ENCODE_KDC_REP\";\n    } else {\n        VAR_29 = \"ISSUE\";\n    }\n\n    memset(VAR_11.enc_part.ciphertext.data, 0,\n           VAR_11.enc_part.ciphertext.length);\n    free(VAR_11.enc_part.ciphertext.data);\n    /* COMMENT_140 */\n                                                               \n    memset(VAR_9.enc_part.ciphertext.data, 0,\n           VAR_9.enc_part.ciphertext.length);\n    free(VAR_9.enc_part.ciphertext.data);\n\ncleanup:\n    if (VAR_29 == NULL)\n        VAR_29 = \"UNKNOWN_REASON\";\n    if (VAR_21)\n        krb5_free_keyblock(VAR_53, VAR_21);\n    if (VAR_28)\n        VAR_41 = krb5_get_error_message (VAR_53, VAR_28);\n\n    VAR_48->status = VAR_29;\n    if (!VAR_28)\n        VAR_48->reply = &VAR_9;\n    kau_tgs_req(VAR_53, VAR_28 ? FALSE : TRUE, VAR_48);\n    kau_free_kdc_req(VAR_48);\n\n    log_tgs_req(VAR_53, VAR_2, VAR_6, &VAR_9, VAR_23,\n                VAR_24, VAR_25, VAR_19,\n                VAR_38, VAR_29, VAR_28, VAR_41);\n    if (VAR_28) {\n        krb5_free_error_message (VAR_53, VAR_41);\n        VAR_41 = NULL;\n    }\n\n    if (VAR_28) {\n        int VAR_108 = 0;\n        if (VAR_29 == 0) {\n            VAR_29 = krb5_get_error_message (VAR_53, VAR_28);\n            VAR_108 = 1;\n        }\n        VAR_28 -= VAR_63;\n        if (VAR_28 < 0 || VAR_28 > VAR_109)\n            VAR_28 = VAR_110;\n\n        VAR_16 = prepare_error_tgs(VAR_43, VAR_6, VAR_12, VAR_28,\n                                   (VAR_7 != NULL) ? VAR_7->princ : NULL,\n                                   VAR_3, VAR_29, VAR_46);\n        if (VAR_108) {\n            krb5_free_error_message (VAR_53, VAR_29);\n            VAR_29 = 0;\n        }\n    }\n\n    if (VAR_12 != NULL)\n        krb5_free_ticket(VAR_53, VAR_12);\n    if (VAR_6 != NULL)\n        krb5_free_kdc_req(VAR_53, VAR_6);\n    if (VAR_43)\n        kdc_free_rstate(VAR_43);\n    krb5_db_free_principal(VAR_53, VAR_7);\n    krb5_db_free_principal(VAR_53, VAR_8);\n    krb5_db_free_principal(VAR_53, VAR_33);\n    krb5_db_free_principal(VAR_53, VAR_32);\n    krb5_db_free_principal(VAR_53, VAR_35);\n    if (VAR_20.contents != NULL)\n        krb5_free_keyblock_contents(VAR_53, &VAR_20);\n    if (VAR_15)\n        free(VAR_14.transited.tr_contents.data);\n    if (VAR_36 != NULL)\n        krb5_free_pa_s4u_x509_user(VAR_53, VAR_36);\n    if (VAR_37 != NULL)\n        krb5_free_authdata(VAR_53, VAR_37);\n    if (VAR_4 != NULL)\n        krb5_free_keyblock(VAR_53, VAR_4);\n    if (VAR_5 != NULL)\n        krb5_free_keyblock(VAR_53, VAR_5);\n    if (VAR_9.padata)\n        krb5_free_pa_data(VAR_53, VAR_9.padata);\n    if (VAR_10.enc_padata)\n        krb5_free_pa_data(VAR_53, VAR_10.enc_padata);\n    if (VAR_14.authorization_data != NULL)\n        krb5_free_authdata(VAR_53, VAR_14.authorization_data);\n    krb5_free_pa_data(VAR_53, VAR_46);\n    k5_free_data_ptr_list(VAR_49);\n\n    return VAR_16;\n}",
  "func_graph_path": "krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970/do_tgs_req.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -724,7 +724,8 @@\n     free(reply.enc_part.ciphertext.data);\n \n cleanup:\n-    assert(status != NULL);\n+    if (status == NULL)\n+        status = \"UNKNOWN_REASON\";\n     if (reply_key)\n         krb5_free_keyblock(kdc_context, reply_key);\n     if (errcode)",
  "diff_line_info": {
    "deleted_lines": [
      "    assert(status != NULL);"
    ],
    "added_lines": [
      "    if (status == NULL)",
      "        status = \"UNKNOWN_REASON\";"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/678",
  "description": {
    "pr_info": {
      "title": "Prevent KDC unset status assertion failures",
      "number": 678
    },
    "comment": [
      "Assign status values if S4U2Self padata fails to decode, if an\r\nS4U2Proxy request uses invalid KDC options, or if an S4U2Proxy request\r\nuses an evidence ticket which does not match the canonicalized request\r\nserver principal name.  Reported by Samuel Cabrero.\r\n    \r\nIf a status value is not assigned during KDC processing, default to\r\n\"UNKNOWN_REASON\" rather than failing an assertion.  This change will\r\nprevent future denial of service bugs due to similar mistakes, and\r\nwill allow us to omit assigning status values for unlikely errors such\r\nas small memory allocation failures.\r\n\r\n[There is a second non-backport commit to remove status assignments for error conditions which don't look practically reachable to me.]"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}