{
  "cve_id": "CVE-2021-3798",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "opencryptoki",
  "commit_msg": "SOFT: Check the EC Key on C_CreateObject and C_DeriveKey\n\nWhen constructing an OpenSSL EC public or private key from PKCS#11\nattributes or ECDH public data, check that the key is valid, i.e. that\nthe point is on the curve.\n\nThis prevents one from creating an EC key object via C_CreateObject with\ninvalid key data. It also prevents C_DeriveKey to derive a secret using\nECDH with an EC public key (public data) that uses a different curve\nor is invalid by other means.\n\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",
  "commit_hash": "4e3b43c3d8844402c04a66b55c6c940f965109f0",
  "git_url": "https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0",
  "file_path": "usr/lib/soft_stdll/soft_specific.c",
  "func_name": "fill_ec_key_from_privkey",
  "func_before": "static CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                      CK_ULONG data_len)\n{\n    EC_POINT *point = NULL;\n    CK_RV rc = CKR_OK;\n\n    if (!EC_KEY_oct2priv(ec_key, data, data_len)) {\n        TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    point = EC_POINT_new(EC_KEY_get0_group(ec_key));\n    if (point == NULL) {\n        TRACE_ERROR(\"EC_POINT_new failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,\n                      EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {\n        TRACE_ERROR(\"EC_POINT_mul failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_set_public_key(ec_key, point)) {\n        TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\nout:\n    if (point != NULL)\n        EC_POINT_free(point);\n\n    return rc;\n}",
  "abstract_func_before": "static CK_RV fill_ec_key_from_privkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,\n                                      CK_ULONG VAR_2)\n{\n    EC_POINT *VAR_3 = NULL;\n    CK_RV VAR_4 = VAR_5;\n\n    if (!EC_KEY_oct2priv(VAR_0, VAR_1, VAR_2)) {\n        TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\n    VAR_3 = EC_POINT_new(EC_KEY_get0_group(VAR_0));\n    if (VAR_3 == NULL) {\n        TRACE_ERROR(\"EC_POINT_new failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\n    if (!EC_POINT_mul(EC_KEY_get0_group(VAR_0), VAR_3,\n                      EC_KEY_get0_private_key(VAR_0), NULL, NULL, NULL)) {\n        TRACE_ERROR(\"EC_POINT_mul failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\n    if (!EC_KEY_set_public_key(VAR_0, VAR_3)) {\n        TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\nout:\n    if (VAR_3 != NULL)\n        EC_POINT_free(VAR_3);\n\n    return VAR_4;\n}",
  "func_graph_path_before": "opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/before/1.json",
  "func": "static CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                      CK_ULONG data_len)\n{\n    EC_POINT *point = NULL;\n    CK_RV rc = CKR_OK;\n\n    if (!EC_KEY_oct2priv(ec_key, data, data_len)) {\n        TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    point = EC_POINT_new(EC_KEY_get0_group(ec_key));\n    if (point == NULL) {\n        TRACE_ERROR(\"EC_POINT_new failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,\n                      EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {\n        TRACE_ERROR(\"EC_POINT_mul failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_set_public_key(ec_key, point)) {\n        TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_check_key(ec_key)) {\n        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\nout:\n    if (point != NULL)\n        EC_POINT_free(point);\n\n    return rc;\n}",
  "abstract_func": "static CK_RV fill_ec_key_from_privkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,\n                                      CK_ULONG VAR_2)\n{\n    EC_POINT *VAR_3 = NULL;\n    CK_RV VAR_4 = VAR_5;\n\n    if (!EC_KEY_oct2priv(VAR_0, VAR_1, VAR_2)) {\n        TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\n    VAR_3 = EC_POINT_new(EC_KEY_get0_group(VAR_0));\n    if (VAR_3 == NULL) {\n        TRACE_ERROR(\"EC_POINT_new failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\n    if (!EC_POINT_mul(EC_KEY_get0_group(VAR_0), VAR_3,\n                      EC_KEY_get0_private_key(VAR_0), NULL, NULL, NULL)) {\n        TRACE_ERROR(\"EC_POINT_mul failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\n    if (!EC_KEY_set_public_key(VAR_0, VAR_3)) {\n        TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\n    if (!EC_KEY_check_key(VAR_0)) {\n        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n        VAR_4 = VAR_6;\n        goto out;\n    }\n\nout:\n    if (VAR_3 != NULL)\n        EC_POINT_free(VAR_3);\n\n    return VAR_4;\n}",
  "func_graph_path": "opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,12 @@\n         goto out;\n     }\n \n+    if (!EC_KEY_check_key(ec_key)) {\n+        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n+        goto out;\n+    }\n+\n out:\n     if (point != NULL)\n         EC_POINT_free(point);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (!EC_KEY_check_key(ec_key)) {",
      "        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");",
      "        rc = CKR_FUNCTION_FAILED;",
      "        goto out;",
      "    }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencryptoki/opencryptoki/pull/402",
  "description": {
    "pr_info": {
      "title": "SOFT: Check the EC Key on C_CreateObject and C_DeriveKey",
      "number": 402
    },
    "comment": [
      "When constructing an OpenSSL EC public or private key from PKCS#11 attributes or ECDH public data, check that the key is valid, i.e. that the point is on the curve.\r\n\r\nThis prevents one from creating an EC key object via C_CreateObject with invalid key data. It also prevents C_DeriveKey to derive a secret using ECDH with an EC public key (public data) that uses a different curve\r\nor is invalid by other means.",
      "According to @p-steuer `EC_KEY_check_key()` is sufficient, and we should not do an additional `EC_POINT_is_on_curve()` check, since there is a cost associated with doing checking this twice.\r\n\r\nI have changed the code accordingly."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}