{
  "cve_id": "CVE-2020-15166",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "problem: zeromq connects peer before handshake is completed\n\nSolution: delay connecting the peer pipe until the handshake is completed",
  "commit_hash": "e7f0090b161ce6344f6bd35009816a925c070b09",
  "git_url": "https://github.com/zeromq/libzmq/commit/e7f0090b161ce6344f6bd35009816a925c070b09",
  "file_path": "src/stream_engine_base.cpp",
  "func_name": "zmq::stream_engine_base_t::mechanism_ready",
  "func_before": "void zmq::stream_engine_base_t::mechanism_ready ()\n{\n    if (_options.heartbeat_interval > 0 && !_has_heartbeat_timer) {\n        add_timer (_options.heartbeat_interval, heartbeat_ivl_timer_id);\n        _has_heartbeat_timer = true;\n    }\n\n    bool flush_session = false;\n\n    if (_options.recv_routing_id) {\n        msg_t routing_id;\n        _mechanism->peer_routing_id (&routing_id);\n        const int rc = _session->push_msg (&routing_id);\n        if (rc == -1 && errno == EAGAIN) {\n            // If the write is failing at this stage with\n            // an EAGAIN the pipe must be being shut down,\n            // so we can just bail out of the routing id set.\n            return;\n        }\n        errno_assert (rc == 0);\n        flush_session = true;\n    }\n\n    if (_options.router_notify & ZMQ_NOTIFY_CONNECT) {\n        msg_t connect_notification;\n        connect_notification.init ();\n        const int rc = _session->push_msg (&connect_notification);\n        if (rc == -1 && errno == EAGAIN) {\n            // If the write is failing at this stage with\n            // an EAGAIN the pipe must be being shut down,\n            // so we can just bail out of the notification.\n            return;\n        }\n        errno_assert (rc == 0);\n        flush_session = true;\n    }\n\n    if (flush_session)\n        _session->flush ();\n\n    _next_msg = &stream_engine_base_t::pull_and_encode;\n    _process_msg = &stream_engine_base_t::write_credential;\n\n    //  Compile metadata.\n    properties_t properties;\n    init_properties (properties);\n\n    //  Add ZAP properties.\n    const properties_t &zap_properties = _mechanism->get_zap_properties ();\n    properties.insert (zap_properties.begin (), zap_properties.end ());\n\n    //  Add ZMTP properties.\n    const properties_t &zmtp_properties = _mechanism->get_zmtp_properties ();\n    properties.insert (zmtp_properties.begin (), zmtp_properties.end ());\n\n    zmq_assert (_metadata == NULL);\n    if (!properties.empty ()) {\n        _metadata = new (std::nothrow) metadata_t (properties);\n        alloc_assert (_metadata);\n    }\n\n    _socket->event_handshake_succeeded (_endpoint_uri_pair, 0);\n}",
  "abstract_func_before": "void zmq::stream_engine_base_t::mechanism_ready ()\n{\n    if (VAR_0.heartbeat_interval > 0 && !VAR_1) {\n        add_timer (VAR_0.heartbeat_interval, VAR_2);\n        VAR_1 = true;\n    }\n\n    bool VAR_3 = false;\n\n    if (VAR_0.recv_routing_id) {\n        msg_t VAR_4;\n        VAR_5->peer_routing_id (&VAR_4);\n        const int VAR_6 = VAR_7->push_msg (&VAR_4);\n        if (VAR_6 == -1 && VAR_8 == VAR_9) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            return;\n        }\n        errno_assert (VAR_6 == 0);\n        VAR_3 = true;\n    }\n\n    if (VAR_0.router_notify & VAR_10) {\n        msg_t VAR_11;\n        VAR_11.init ();\n        const int VAR_6 = VAR_7->push_msg (&VAR_11);\n        if (VAR_6 == -1 && VAR_8 == VAR_9) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_3 */\n            return;\n        }\n        errno_assert (VAR_6 == 0);\n        VAR_3 = true;\n    }\n\n    if (VAR_3)\n        VAR_7->flush ();\n\n    VAR_12 = &stream_engine_base_t::pull_and_encode;\n    VAR_13 = &stream_engine_base_t::write_credential;\n\n    /* COMMENT_4 */\n    properties_t VAR_14;\n    init_properties (VAR_14);\n\n    /* COMMENT_5 */\n    const properties_t &VAR_15 = VAR_5->get_zap_properties ();\n    VAR_14.insert (VAR_15.begin (), VAR_15.end ());\n\n    /* COMMENT_6 */\n    const properties_t &VAR_16 = VAR_5->get_zmtp_properties ();\n    VAR_14.insert (VAR_16.begin (), VAR_16.end ());\n\n    zmq_assert (VAR_17 == NULL);\n    if (!VAR_14.empty ()) {\n        VAR_17 = new (std::nothrow) metadata_t (VAR_14);\n        alloc_assert (VAR_17);\n    }\n\n    VAR_18->event_handshake_succeeded (VAR_19, 0);\n}",
  "func_graph_path_before": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/stream_engine_base.cpp/vul/before/2.json",
  "func": "void zmq::stream_engine_base_t::mechanism_ready ()\n{\n    if (_options.heartbeat_interval > 0 && !_has_heartbeat_timer) {\n        add_timer (_options.heartbeat_interval, heartbeat_ivl_timer_id);\n        _has_heartbeat_timer = true;\n    }\n\n    if (_has_handshake_stage)\n        _session->engine_ready ();\n\n    bool flush_session = false;\n\n    if (_options.recv_routing_id) {\n        msg_t routing_id;\n        _mechanism->peer_routing_id (&routing_id);\n        const int rc = _session->push_msg (&routing_id);\n        if (rc == -1 && errno == EAGAIN) {\n            // If the write is failing at this stage with\n            // an EAGAIN the pipe must be being shut down,\n            // so we can just bail out of the routing id set.\n            return;\n        }\n        errno_assert (rc == 0);\n        flush_session = true;\n    }\n\n    if (_options.router_notify & ZMQ_NOTIFY_CONNECT) {\n        msg_t connect_notification;\n        connect_notification.init ();\n        const int rc = _session->push_msg (&connect_notification);\n        if (rc == -1 && errno == EAGAIN) {\n            // If the write is failing at this stage with\n            // an EAGAIN the pipe must be being shut down,\n            // so we can just bail out of the notification.\n            return;\n        }\n        errno_assert (rc == 0);\n        flush_session = true;\n    }\n\n    if (flush_session)\n        _session->flush ();\n\n    _next_msg = &stream_engine_base_t::pull_and_encode;\n    _process_msg = &stream_engine_base_t::write_credential;\n\n    //  Compile metadata.\n    properties_t properties;\n    init_properties (properties);\n\n    //  Add ZAP properties.\n    const properties_t &zap_properties = _mechanism->get_zap_properties ();\n    properties.insert (zap_properties.begin (), zap_properties.end ());\n\n    //  Add ZMTP properties.\n    const properties_t &zmtp_properties = _mechanism->get_zmtp_properties ();\n    properties.insert (zmtp_properties.begin (), zmtp_properties.end ());\n\n    zmq_assert (_metadata == NULL);\n    if (!properties.empty ()) {\n        _metadata = new (std::nothrow) metadata_t (properties);\n        alloc_assert (_metadata);\n    }\n\n    _socket->event_handshake_succeeded (_endpoint_uri_pair, 0);\n}",
  "abstract_func": "void zmq::stream_engine_base_t::mechanism_ready ()\n{\n    if (VAR_0.heartbeat_interval > 0 && !VAR_1) {\n        add_timer (VAR_0.heartbeat_interval, VAR_2);\n        VAR_1 = true;\n    }\n\n    if (VAR_3)\n        VAR_4->engine_ready ();\n\n    bool VAR_5 = false;\n\n    if (VAR_0.recv_routing_id) {\n        msg_t VAR_6;\n        VAR_7->peer_routing_id (&VAR_6);\n        const int VAR_8 = VAR_4->push_msg (&VAR_6);\n        if (VAR_8 == -1 && VAR_9 == VAR_10) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            return;\n        }\n        errno_assert (VAR_8 == 0);\n        VAR_5 = true;\n    }\n\n    if (VAR_0.router_notify & VAR_11) {\n        msg_t VAR_12;\n        VAR_12.init ();\n        const int VAR_8 = VAR_4->push_msg (&VAR_12);\n        if (VAR_8 == -1 && VAR_9 == VAR_10) {\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_3 */\n            return;\n        }\n        errno_assert (VAR_8 == 0);\n        VAR_5 = true;\n    }\n\n    if (VAR_5)\n        VAR_4->flush ();\n\n    VAR_13 = &stream_engine_base_t::pull_and_encode;\n    VAR_14 = &stream_engine_base_t::write_credential;\n\n    /* COMMENT_4 */\n    properties_t VAR_15;\n    init_properties (VAR_15);\n\n    /* COMMENT_5 */\n    const properties_t &VAR_16 = VAR_7->get_zap_properties ();\n    VAR_15.insert (VAR_16.begin (), VAR_16.end ());\n\n    /* COMMENT_6 */\n    const properties_t &VAR_17 = VAR_7->get_zmtp_properties ();\n    VAR_15.insert (VAR_17.begin (), VAR_17.end ());\n\n    zmq_assert (VAR_18 == NULL);\n    if (!VAR_15.empty ()) {\n        VAR_18 = new (std::nothrow) metadata_t (VAR_15);\n        alloc_assert (VAR_18);\n    }\n\n    VAR_19->event_handshake_succeeded (VAR_20, 0);\n}",
  "func_graph_path": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/stream_engine_base.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n         add_timer (_options.heartbeat_interval, heartbeat_ivl_timer_id);\n         _has_heartbeat_timer = true;\n     }\n+\n+    if (_has_handshake_stage)\n+        _session->engine_ready ();\n \n     bool flush_session = false;\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if (_has_handshake_stage)",
      "        _session->engine_ready ();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/3913",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zeromq/libzmq/pull/3913: 403 Client Error: Forbidden for url: https://api.github.com/repos/zeromq/libzmq/pulls/3913",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}