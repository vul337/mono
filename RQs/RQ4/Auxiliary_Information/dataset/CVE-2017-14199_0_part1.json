{
  "cve_id": "CVE-2017-14199",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "zephyrproject-rtos/zephyr",
  "commit_msg": "net: sockets: getaddrinfo() buffer overflow, etc. fixes\n\nThe existing implementation assumed DNS resolv callback will be\ncalled just once, but that's not always the case (apparently,\nfor multi-homes hosts or something). So, apply array bounds\nchecking (and do pointer arithmetic only after it, as the C\nstandard otherwise warns of \"undefined behavior\"). In such a case,\nthe port number wasn't set in each entry too, so rework how it's\ndone.\n\nThe issues discovered while resolving archive.ubuntu.com.\n\nSigned-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>",
  "commit_hash": "3953714a9b8508aca72ab93991e8468ba508aa4b",
  "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/3953714a9b8508aca72ab93991e8468ba508aa4b",
  "file_path": "subsys/net/lib/sockets/getaddrinfo.c",
  "func_name": "zsock_getaddrinfo",
  "func_before": "int zsock_getaddrinfo(const char *host, const char *service,\n\t\t      const struct zsock_addrinfo *hints,\n\t\t      struct zsock_addrinfo **res)\n{\n\tint family = AF_UNSPEC;\n\tlong int port;\n\tint st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;\n\n\tif (hints) {\n\t\tfamily = hints->ai_family;\n\t}\n\n\tport = strtol(service, NULL, 10);\n\tif (port < 1 || port > 65535) {\n\t\treturn DNS_EAI_NONAME;\n\t}\n\n\tai_state.hints = hints;\n\tai_state.idx = 0;\n\tk_sem_init(&ai_state.sem, 0, UINT_MAX);\n\n\t/* Link entries in advance */\n\tai_arr[0].ai_next = &ai_arr[1];\n\n\t/* Execute if AF_UNSPEC or AF_INET4 */\n\tif (family != AF_INET6) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_A, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin(&ai_arr[ai_state.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst1 = ai_state.status;\n\t}\n\n\t/* Execute if AF_UNSPEC or AF_INET6 */\n\tif (family != AF_INET) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_AAAA, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin6(&ai_arr[ai_state.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst2 = ai_state.status;\n\t}\n\n\t/* If both attempts failed, it's error */\n\tif (st1 && st2) {\n\t\tif (st1 != DNS_EAI_ADDRFAMILY) {\n\t\t\treturn st1;\n\t\t}\n\t\treturn st2;\n\t}\n\n\t/* Mark entry as last */\n\tai_arr[ai_state.idx - 1].ai_next = NULL;\n\n\t*res = ai_arr;\n\n\treturn 0;\n}",
  "abstract_func_before": "int zsock_getaddrinfo(const char *VAR_0, const char *VAR_1,\n\t\t      const struct zsock_addrinfo *VAR_2,\n\t\t      struct zsock_addrinfo **VAR_3)\n{\n\tint VAR_4 = VAR_5;\n\tlong int VAR_6;\n\tint VAR_7 = VAR_8, VAR_9 = VAR_8;\n\n\tif (VAR_2) {\n\t\tVAR_4 = VAR_2->ai_family;\n\t}\n\n\tVAR_6 = strtol(VAR_1, NULL, 10);\n\tif (VAR_6 < 1 || VAR_6 > 65535) {\n\t\treturn VAR_10;\n\t}\n\n\tVAR_11.hints = VAR_2;\n\tVAR_11.idx = 0;\n\tk_sem_init(&VAR_11.sem, 0, VAR_12);\n\n\t/* COMMENT_0 */\n\tVAR_13[0].ai_next = &VAR_13[1];\n\n\t/* COMMENT_1 */\n\tif (VAR_4 != VAR_14) {\n\t\tdns_get_addr_info(VAR_0, VAR_15, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_7 = VAR_11.status;\n\t}\n\n\t/* COMMENT_2 */\n\tif (VAR_4 != VAR_18) {\n\t\tdns_get_addr_info(VAR_0, VAR_19, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin6(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_9 = VAR_11.status;\n\t}\n\n\t/* COMMENT_3 */\n\tif (VAR_7 && VAR_9) {\n\t\tif (VAR_7 != VAR_8) {\n\t\t\treturn VAR_7;\n\t\t}\n\t\treturn VAR_9;\n\t}\n\n\t/* COMMENT_4 */\n\tVAR_13[VAR_11.idx - 1].ai_next = NULL;\n\n\t*VAR_3 = VAR_13;\n\n\treturn 0;\n}",
  "func_graph_path_before": "zephyrproject-rtos/zephyr/3953714a9b8508aca72ab93991e8468ba508aa4b/getaddrinfo.c/vul/before/1.json",
  "func": "int zsock_getaddrinfo(const char *host, const char *service,\n\t\t      const struct zsock_addrinfo *hints,\n\t\t      struct zsock_addrinfo **res)\n{\n\tint family = AF_UNSPEC;\n\tlong int port;\n\tint st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;\n\n\tif (hints) {\n\t\tfamily = hints->ai_family;\n\t}\n\n\tport = strtol(service, NULL, 10);\n\tif (port < 1 || port > 65535) {\n\t\treturn DNS_EAI_NONAME;\n\t}\n\n\tai_state.hints = hints;\n\tai_state.idx = 0;\n\tai_state.port = htons(port);\n\tk_sem_init(&ai_state.sem, 0, UINT_MAX);\n\n\t/* Link entries in advance */\n\tai_arr[0].ai_next = &ai_arr[1];\n\n\t/* Execute if AF_UNSPEC or AF_INET4 */\n\tif (family != AF_INET6) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_A, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin(&ai_arr[ai_state.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst1 = ai_state.status;\n\t}\n\n\t/* Execute if AF_UNSPEC or AF_INET6 */\n\tif (family != AF_INET) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_AAAA, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin6(&ai_arr[ai_state.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst2 = ai_state.status;\n\t}\n\n\t/* If both attempts failed, it's error */\n\tif (st1 && st2) {\n\t\tif (st1 != DNS_EAI_ADDRFAMILY) {\n\t\t\treturn st1;\n\t\t}\n\t\treturn st2;\n\t}\n\n\t/* Mark entry as last */\n\tai_arr[ai_state.idx - 1].ai_next = NULL;\n\n\t*res = ai_arr;\n\n\treturn 0;\n}",
  "abstract_func": "int zsock_getaddrinfo(const char *VAR_0, const char *VAR_1,\n\t\t      const struct zsock_addrinfo *VAR_2,\n\t\t      struct zsock_addrinfo **VAR_3)\n{\n\tint VAR_4 = VAR_5;\n\tlong int VAR_6;\n\tint VAR_7 = VAR_8, VAR_9 = VAR_8;\n\n\tif (VAR_2) {\n\t\tVAR_4 = VAR_2->ai_family;\n\t}\n\n\tVAR_6 = strtol(VAR_1, NULL, 10);\n\tif (VAR_6 < 1 || VAR_6 > 65535) {\n\t\treturn VAR_10;\n\t}\n\n\tVAR_11.hints = VAR_2;\n\tVAR_11.idx = 0;\n\tVAR_11.port = htons(VAR_6);\n\tk_sem_init(&VAR_11.sem, 0, VAR_12);\n\n\t/* COMMENT_0 */\n\tVAR_13[0].ai_next = &VAR_13[1];\n\n\t/* COMMENT_1 */\n\tif (VAR_4 != VAR_14) {\n\t\tdns_get_addr_info(VAR_0, VAR_15, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_7 = VAR_11.status;\n\t}\n\n\t/* COMMENT_2 */\n\tif (VAR_4 != VAR_18) {\n\t\tdns_get_addr_info(VAR_0, VAR_19, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin6(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_9 = VAR_11.status;\n\t}\n\n\t/* COMMENT_3 */\n\tif (VAR_7 && VAR_9) {\n\t\tif (VAR_7 != VAR_8) {\n\t\t\treturn VAR_7;\n\t\t}\n\t\treturn VAR_9;\n\t}\n\n\t/* COMMENT_4 */\n\tVAR_13[VAR_11.idx - 1].ai_next = NULL;\n\n\t*VAR_3 = VAR_13;\n\n\treturn 0;\n}",
  "func_graph_path": "zephyrproject-rtos/zephyr/3953714a9b8508aca72ab93991e8468ba508aa4b/getaddrinfo.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \n \tai_state.hints = hints;\n \tai_state.idx = 0;\n+\tai_state.port = htons(port);\n \tk_sem_init(&ai_state.sem, 0, UINT_MAX);\n \n \t/* Link entries in advance */",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tai_state.port = htons(port);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zephyrproject-rtos/zephyr/pull/6158",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zephyrproject-rtos/zephyr/pull/6158: 403 Client Error: Forbidden for url: https://api.github.com/repos/zephyrproject-rtos/zephyr/pulls/6158",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}