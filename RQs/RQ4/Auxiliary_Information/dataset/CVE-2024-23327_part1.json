{
  "cve_id": "CVE-2024-23327",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Fix crash from AWS NLB healthchecks when proxy protocol is enabled\n\nFix: [CVE-2024-23327](https://github.com/envoyproxy/envoy/security/advisories/GHSA-4h5x-x9vh-m29j)\n\nSigned-off-by: Jacob Neil Taylor <me@jacobtaylor.id.au>\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "63895ea8e3cca9c5d3ab4c5c128ed1369969d54a",
  "git_url": "https://github.com/envoyproxy/envoy/commit/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a",
  "file_path": "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc",
  "func_name": "Filter::parseBuffer",
  "func_before": "ReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    if (!proxy_protocol_header_.value().local_command_) {\n      auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, length: {}, buffer: {}, TLV length: {}, TLV buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n    }\n\n    cb_->filterState().setData(\n        Network::ProxyProtocolFilterState::key(),\n        std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n            proxy_protocol_header_.value().remote_address_,\n            proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n        StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}",
  "abstract_func_before": "ReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& VAR_0) {\n  Network::ConnectionSocket& VAR_1 = VAR_2->socket();\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  if (!VAR_3.has_value()) {\n    const ReadOrParseState VAR_4 = readProxyHeader(VAR_0);\n    if (VAR_4 != ReadOrParseState::Done) {\n      return VAR_4;\n    }\n  }\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  if (VAR_3.value().wholeHeaderLength() > VAR_5) {\n    VAR_5 = VAR_3.value().wholeHeaderLength();\n    /* COMMENT_4 */\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (VAR_3.has_value()) {\n    const ReadOrParseState VAR_6 = readExtensions(VAR_0);\n    if (VAR_6 != ReadOrParseState::Done) {\n      return VAR_6;\n    }\n  }\n\n  if (VAR_3.has_value() &&\n      !VAR_2->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    if (!VAR_3.value().local_command_) {\n      auto VAR_7 = VAR_8<const uint8_t*>(VAR_0.rawSlice().mem_);\n      ENVOY_LOG(\n          VAR_9,\n          \"Parsed proxy protocol header, length: {}, buffer: {}, TLV length: {}, TLV buffer: {}\",\n          VAR_3.value().wholeHeaderLength(),\n          Envoy::Hex::encode(VAR_7, VAR_3.value().wholeHeaderLength()),\n          VAR_3.value().extensions_length_,\n          Envoy::Hex::encode(VAR_7 + VAR_3.value().headerLengthWithoutExtension(),\n                             VAR_3.value().extensions_length_));\n    }\n\n    VAR_2->filterState().setData(\n        Network::ProxyProtocolFilterState::key(),\n        std::VAR_10<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n            VAR_3.value().remote_address_,\n            VAR_3.value().local_address_, VAR_11}),\n        StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);\n  }\n\n  if (VAR_3.has_value() && !VAR_3.value().local_command_) {\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    const auto VAR_12 = VAR_3.value().remote_address_->ip()->version();\n    const auto VAR_13 = VAR_3.value().local_address_->ip()->version();\n    if (VAR_12 != VAR_3.value().protocol_version_ ||\n        VAR_13 != VAR_3.value().protocol_version_) {\n      ENVOY_LOG(VAR_14, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    /* COMMENT_10 */\n    if (!VAR_3.value().remote_address_->ip()->isUnicastAddress() ||\n        !VAR_3.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(VAR_14, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    /* COMMENT_11 */\n    if (*VAR_3.value().local_address_ !=\n        *VAR_1.connectionInfoProvider().localAddress()) {\n      VAR_1.connectionInfoProvider().restoreLocalAddress(\n          VAR_3.value().local_address_);\n    }\n    VAR_1.connectionInfoProvider().setRemoteAddress(\n        VAR_3.value().remote_address_);\n  }\n\n  if (!VAR_0.drain(VAR_3.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}",
  "func_graph_path_before": "envoyproxy/envoy/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a/proxy_protocol.cc/vul/before/0.json",
  "func": "ReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n    if (proxy_protocol_header_.value().local_command_) {\n      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                proxy_protocol_header_.value().wholeHeaderLength(),\n                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              socket.connectionInfoProvider().remoteAddress(),\n              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              proxy_protocol_header_.value().remote_address_,\n              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}",
  "abstract_func": "ReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& VAR_0) {\n  Network::ConnectionSocket& VAR_1 = VAR_2->socket();\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  if (!VAR_3.has_value()) {\n    const ReadOrParseState VAR_4 = readProxyHeader(VAR_0);\n    if (VAR_4 != ReadOrParseState::Done) {\n      return VAR_4;\n    }\n  }\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  if (VAR_3.value().wholeHeaderLength() > VAR_5) {\n    VAR_5 = VAR_3.value().wholeHeaderLength();\n    /* COMMENT_4 */\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (VAR_3.has_value()) {\n    const ReadOrParseState VAR_6 = readExtensions(VAR_0);\n    if (VAR_6 != ReadOrParseState::Done) {\n      return VAR_6;\n    }\n  }\n\n  if (VAR_3.has_value() &&\n      !VAR_2->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto VAR_7 = VAR_8<const uint8_t*>(VAR_0.rawSlice().mem_);\n    if (VAR_3.value().local_command_) {\n      ENVOY_LOG(VAR_9, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                VAR_3.value().wholeHeaderLength(),\n                Envoy::Hex::encode(VAR_7, VAR_3.value().wholeHeaderLength()));\n\n      VAR_2->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::VAR_10<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              VAR_1.connectionInfoProvider().remoteAddress(),\n              VAR_1.connectionInfoProvider().localAddress(), VAR_11}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          VAR_9,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          VAR_3.value().wholeHeaderLength(),\n          Envoy::Hex::encode(VAR_7, VAR_3.value().wholeHeaderLength()),\n          VAR_3.value().extensions_length_,\n          Envoy::Hex::encode(VAR_7 + VAR_3.value().headerLengthWithoutExtension(),\n                             VAR_3.value().extensions_length_));\n      VAR_2->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::VAR_10<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              VAR_3.value().remote_address_,\n              VAR_3.value().local_address_, VAR_11}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (VAR_3.has_value() && !VAR_3.value().local_command_) {\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    const auto VAR_12 = VAR_3.value().remote_address_->ip()->version();\n    const auto VAR_13 = VAR_3.value().local_address_->ip()->version();\n    if (VAR_12 != VAR_3.value().protocol_version_ ||\n        VAR_13 != VAR_3.value().protocol_version_) {\n      ENVOY_LOG(VAR_14, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    /* COMMENT_10 */\n    if (!VAR_3.value().remote_address_->ip()->isUnicastAddress() ||\n        !VAR_3.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(VAR_14, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    /* COMMENT_11 */\n    if (*VAR_3.value().local_address_ !=\n        *VAR_1.connectionInfoProvider().localAddress()) {\n      VAR_1.connectionInfoProvider().restoreLocalAddress(\n          VAR_3.value().local_address_);\n    }\n    VAR_1.connectionInfoProvider().setRemoteAddress(\n        VAR_3.value().remote_address_);\n  }\n\n  if (!VAR_0.drain(VAR_3.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}",
  "func_graph_path": "envoyproxy/envoy/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a/proxy_protocol.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,24 +28,37 @@\n   if (proxy_protocol_header_.has_value() &&\n       !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n           Network::ProxyProtocolFilterState::key())) {\n-    if (!proxy_protocol_header_.value().local_command_) {\n-      auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n+    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n+    if (proxy_protocol_header_.value().local_command_) {\n+      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n+                proxy_protocol_header_.value().wholeHeaderLength(),\n+                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n+\n+      cb_->filterState().setData(\n+          Network::ProxyProtocolFilterState::key(),\n+          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n+              socket.connectionInfoProvider().remoteAddress(),\n+              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n+          StreamInfo::FilterState::StateType::Mutable,\n+          StreamInfo::FilterState::LifeSpan::Connection);\n+    } else {\n       ENVOY_LOG(\n           trace,\n-          \"Parsed proxy protocol header, length: {}, buffer: {}, TLV length: {}, TLV buffer: {}\",\n+          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n+          \"buffer: {}\",\n           proxy_protocol_header_.value().wholeHeaderLength(),\n           Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n           proxy_protocol_header_.value().extensions_length_,\n           Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                              proxy_protocol_header_.value().extensions_length_));\n+      cb_->filterState().setData(\n+          Network::ProxyProtocolFilterState::key(),\n+          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n+              proxy_protocol_header_.value().remote_address_,\n+              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n+          StreamInfo::FilterState::StateType::Mutable,\n+          StreamInfo::FilterState::LifeSpan::Connection);\n     }\n-\n-    cb_->filterState().setData(\n-        Network::ProxyProtocolFilterState::key(),\n-        std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n-            proxy_protocol_header_.value().remote_address_,\n-            proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n-        StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);\n   }\n \n   if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {",
  "diff_line_info": {
    "deleted_lines": [
      "    if (!proxy_protocol_header_.value().local_command_) {",
      "      auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);",
      "          \"Parsed proxy protocol header, length: {}, buffer: {}, TLV length: {}, TLV buffer: {}\",",
      "",
      "    cb_->filterState().setData(",
      "        Network::ProxyProtocolFilterState::key(),",
      "        std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{",
      "            proxy_protocol_header_.value().remote_address_,",
      "            proxy_protocol_header_.value().local_address_, parsed_tlvs_}),",
      "        StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);"
    ],
    "added_lines": [
      "    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);",
      "    if (proxy_protocol_header_.value().local_command_) {",
      "      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",",
      "                proxy_protocol_header_.value().wholeHeaderLength(),",
      "                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));",
      "",
      "      cb_->filterState().setData(",
      "          Network::ProxyProtocolFilterState::key(),",
      "          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{",
      "              socket.connectionInfoProvider().remoteAddress(),",
      "              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),",
      "          StreamInfo::FilterState::StateType::Mutable,",
      "          StreamInfo::FilterState::LifeSpan::Connection);",
      "    } else {",
      "          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"",
      "          \"buffer: {}\",",
      "      cb_->filterState().setData(",
      "          Network::ProxyProtocolFilterState::key(),",
      "          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{",
      "              proxy_protocol_header_.value().remote_address_,",
      "              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),",
      "          StreamInfo::FilterState::StateType::Mutable,",
      "          StreamInfo::FilterState::LifeSpan::Connection);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/32300",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/envoyproxy/envoy/pull/32300: 403 Client Error: Forbidden for url: https://api.github.com/repos/envoyproxy/envoy/pulls/32300",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe commit addresses a crash related to AWS NLB healthchecks and references a CVE, indicating a security fix. The code changes correctly handle proxy protocol headers to prevent crashes, which are security-related issues. The presence of multiple CVEs and the nature of the code modifications confirm it's a security patch."
}