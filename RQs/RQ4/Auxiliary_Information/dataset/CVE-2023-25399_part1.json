{
  "cve_id": "CVE-2023-25399",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "scipy",
  "commit_msg": "BUG: fix a minor refcounting issue in `Py_FindObjects`\n\nCloses gh-16235\n\nNote: also change `Py_XDECREF`s for start/end variables to `Py_DECREF`,\nbecause it's already checked higher up that those variables are not\nNULL.",
  "commit_hash": "9b6521198c4f31d3f9cb525e581bea8e3e77f0a2",
  "git_url": "https://github.com/scipy/scipy/commit/9b6521198c4f31d3f9cb525e581bea8e3e77f0a2",
  "file_path": "scipy/ndimage/src/nd_image.c",
  "func_name": "Py_FindObjects",
  "func_before": "static PyObject *Py_FindObjects(PyObject *obj, PyObject *args)\n{\n    PyArrayObject *input = NULL;\n    PyObject *result = NULL, *tuple = NULL, *start = NULL, *end = NULL;\n    PyObject *slc = NULL;\n    int jj;\n    npy_intp max_label;\n    npy_intp ii, *regions = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O&n\",\n                          NI_ObjectToInputArray, &input, &max_label))\n        goto exit;\n\n    if (max_label < 0)\n        max_label = 0;\n    if (max_label > 0) {\n        if (PyArray_NDIM(input) > 0) {\n            regions = (npy_intp*)malloc(2 * max_label * PyArray_NDIM(input) *\n                                        sizeof(npy_intp));\n        } else {\n            regions = (npy_intp*)malloc(max_label * sizeof(npy_intp));\n        }\n        if (!regions) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(input, max_label, regions))\n        goto exit;\n\n    result = PyList_New(max_label);\n    if (!result) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(ii = 0; ii < max_label; ii++) {\n        npy_intp idx =\n                PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;\n        if (regions[idx] >= 0) {\n            PyObject *tuple = PyTuple_New(PyArray_NDIM(input));\n            if (!tuple) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(jj = 0; jj < PyArray_NDIM(input); jj++) {\n                start = PyLong_FromSsize_t(regions[idx + jj]);\n                end = PyLong_FromSsize_t(regions[idx + jj +\n                                             PyArray_NDIM(input)]);\n                if (!start || !end) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                slc = PySlice_New(start, end, NULL);\n                if (!slc) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_XDECREF(start);\n                Py_XDECREF(end);\n                start = end = NULL;\n                PyTuple_SetItem(tuple, jj, slc);\n                slc = NULL;\n            }\n            PyList_SetItem(result, ii, tuple);\n            tuple = NULL;\n        } else {\n            Py_INCREF(Py_None);\n            PyList_SetItem(result, ii, Py_None);\n        }\n    }\n\n    Py_INCREF(result);\n\n exit:\n    Py_XDECREF(input);\n    Py_XDECREF(result);\n    Py_XDECREF(tuple);\n    Py_XDECREF(start);\n    Py_XDECREF(end);\n    Py_XDECREF(slc);\n    free(regions);\n    if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        return result;\n    }\n}",
  "abstract_func_before": "static PyObject *Py_FindObjects(PyObject *VAR_0, PyObject *VAR_1)\n{\n    PyArrayObject *VAR_2 = NULL;\n    PyObject *VAR_3 = NULL, *VAR_4 = NULL, *VAR_5 = NULL, *VAR_6 = NULL;\n    PyObject *VAR_7 = NULL;\n    int VAR_8;\n    npy_intp VAR_9;\n    npy_intp VAR_10, *VAR_11 = NULL;\n\n    if (!PyArg_ParseTuple(VAR_1, \"O&n\",\n                          VAR_12, &VAR_2, &VAR_9))\n        goto exit;\n\n    if (VAR_9 < 0)\n        VAR_9 = 0;\n    if (VAR_9 > 0) {\n        if (PyArray_NDIM(VAR_2) > 0) {\n            VAR_11 = (npy_intp*)malloc(2 * VAR_9 * PyArray_NDIM(VAR_2) *\n                                        sizeof(npy_intp));\n        } else {\n            VAR_11 = (npy_intp*)malloc(VAR_9 * sizeof(npy_intp));\n        }\n        if (!VAR_11) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(VAR_2, VAR_9, VAR_11))\n        goto exit;\n\n    VAR_3 = PyList_New(VAR_9);\n    if (!VAR_3) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(VAR_10 = 0; VAR_10 < VAR_9; VAR_10++) {\n        npy_intp VAR_13 =\n                PyArray_NDIM(VAR_2) > 0 ? 2 * PyArray_NDIM(VAR_2) * VAR_10 : VAR_10;\n        if (VAR_11[VAR_13] >= 0) {\n            PyObject *VAR_4 = PyTuple_New(PyArray_NDIM(VAR_2));\n            if (!VAR_4) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(VAR_8 = 0; VAR_8 < PyArray_NDIM(VAR_2); VAR_8++) {\n                VAR_5 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8]);\n                VAR_6 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8 +\n                                             PyArray_NDIM(VAR_2)]);\n                if (!VAR_5 || !VAR_6) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                VAR_7 = PySlice_New(VAR_5, VAR_6, NULL);\n                if (!VAR_7) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_XDECREF(VAR_5);\n                Py_XDECREF(VAR_6);\n                VAR_5 = VAR_6 = NULL;\n                PyTuple_SetItem(VAR_4, VAR_8, VAR_7);\n                VAR_7 = NULL;\n            }\n            PyList_SetItem(VAR_3, VAR_10, VAR_4);\n            VAR_4 = NULL;\n        } else {\n            Py_INCREF(VAR_14);\n            PyList_SetItem(VAR_3, VAR_10, VAR_14);\n        }\n    }\n\n    Py_INCREF(VAR_3);\n\n exit:\n    Py_XDECREF(VAR_2);\n    Py_XDECREF(VAR_3);\n    Py_XDECREF(VAR_4);\n    Py_XDECREF(VAR_5);\n    Py_XDECREF(VAR_6);\n    Py_XDECREF(VAR_7);\n    free(VAR_11);\n    if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        return VAR_3;\n    }\n}",
  "func_graph_path_before": "scipy/9b6521198c4f31d3f9cb525e581bea8e3e77f0a2/nd_image.c/vul/before/0.json",
  "func": "static PyObject *Py_FindObjects(PyObject *obj, PyObject *args)\n{\n    PyArrayObject *input = NULL;\n    PyObject *result = NULL, *tuple = NULL, *start = NULL, *end = NULL;\n    PyObject *slc = NULL;\n    int jj;\n    npy_intp max_label;\n    npy_intp ii, *regions = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O&n\",\n                          NI_ObjectToInputArray, &input, &max_label))\n        goto exit;\n\n    if (max_label < 0)\n        max_label = 0;\n    if (max_label > 0) {\n        if (PyArray_NDIM(input) > 0) {\n            regions = (npy_intp*)malloc(2 * max_label * PyArray_NDIM(input) *\n                                        sizeof(npy_intp));\n        } else {\n            regions = (npy_intp*)malloc(max_label * sizeof(npy_intp));\n        }\n        if (!regions) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(input, max_label, regions))\n        goto exit;\n\n    result = PyList_New(max_label);\n    if (!result) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(ii = 0; ii < max_label; ii++) {\n        npy_intp idx =\n                PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;\n        if (regions[idx] >= 0) {\n            tuple = PyTuple_New(PyArray_NDIM(input));\n            if (!tuple) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(jj = 0; jj < PyArray_NDIM(input); jj++) {\n                start = PyLong_FromSsize_t(regions[idx + jj]);\n                end = PyLong_FromSsize_t(regions[idx + jj +\n                                             PyArray_NDIM(input)]);\n                if (!start || !end) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                slc = PySlice_New(start, end, NULL);\n                if (!slc) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_DECREF(start);\n                Py_DECREF(end);\n                start = end = NULL;\n                PyTuple_SetItem(tuple, jj, slc);\n                slc = NULL;\n            }\n            PyList_SetItem(result, ii, tuple);\n            tuple = NULL;\n        } else {\n            Py_INCREF(Py_None);\n            PyList_SetItem(result, ii, Py_None);\n        }\n    }\n\n    Py_INCREF(result);\n\n exit:\n    Py_XDECREF(input);\n    Py_XDECREF(result);\n    Py_XDECREF(tuple);\n    Py_XDECREF(start);\n    Py_XDECREF(end);\n    Py_XDECREF(slc);\n    free(regions);\n    if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        return result;\n    }\n}",
  "abstract_func": "static PyObject *Py_FindObjects(PyObject *VAR_0, PyObject *VAR_1)\n{\n    PyArrayObject *VAR_2 = NULL;\n    PyObject *VAR_3 = NULL, *VAR_4 = NULL, *VAR_5 = NULL, *VAR_6 = NULL;\n    PyObject *VAR_7 = NULL;\n    int VAR_8;\n    npy_intp VAR_9;\n    npy_intp VAR_10, *VAR_11 = NULL;\n\n    if (!PyArg_ParseTuple(VAR_1, \"O&n\",\n                          VAR_12, &VAR_2, &VAR_9))\n        goto exit;\n\n    if (VAR_9 < 0)\n        VAR_9 = 0;\n    if (VAR_9 > 0) {\n        if (PyArray_NDIM(VAR_2) > 0) {\n            VAR_11 = (npy_intp*)malloc(2 * VAR_9 * PyArray_NDIM(VAR_2) *\n                                        sizeof(npy_intp));\n        } else {\n            VAR_11 = (npy_intp*)malloc(VAR_9 * sizeof(npy_intp));\n        }\n        if (!VAR_11) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(VAR_2, VAR_9, VAR_11))\n        goto exit;\n\n    VAR_3 = PyList_New(VAR_9);\n    if (!VAR_3) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(VAR_10 = 0; VAR_10 < VAR_9; VAR_10++) {\n        npy_intp VAR_13 =\n                PyArray_NDIM(VAR_2) > 0 ? 2 * PyArray_NDIM(VAR_2) * VAR_10 : VAR_10;\n        if (VAR_11[VAR_13] >= 0) {\n            VAR_4 = PyTuple_New(PyArray_NDIM(VAR_2));\n            if (!VAR_4) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(VAR_8 = 0; VAR_8 < PyArray_NDIM(VAR_2); VAR_8++) {\n                VAR_5 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8]);\n                VAR_6 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8 +\n                                             PyArray_NDIM(VAR_2)]);\n                if (!VAR_5 || !VAR_6) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                VAR_7 = PySlice_New(VAR_5, VAR_6, NULL);\n                if (!VAR_7) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_DECREF(VAR_5);\n                Py_DECREF(VAR_6);\n                VAR_5 = VAR_6 = NULL;\n                PyTuple_SetItem(VAR_4, VAR_8, VAR_7);\n                VAR_7 = NULL;\n            }\n            PyList_SetItem(VAR_3, VAR_10, VAR_4);\n            VAR_4 = NULL;\n        } else {\n            Py_INCREF(VAR_14);\n            PyList_SetItem(VAR_3, VAR_10, VAR_14);\n        }\n    }\n\n    Py_INCREF(VAR_3);\n\n exit:\n    Py_XDECREF(VAR_2);\n    Py_XDECREF(VAR_3);\n    Py_XDECREF(VAR_4);\n    Py_XDECREF(VAR_5);\n    Py_XDECREF(VAR_6);\n    Py_XDECREF(VAR_7);\n    free(VAR_11);\n    if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        return VAR_3;\n    }\n}",
  "func_graph_path": "scipy/9b6521198c4f31d3f9cb525e581bea8e3e77f0a2/nd_image.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n         npy_intp idx =\n                 PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;\n         if (regions[idx] >= 0) {\n-            PyObject *tuple = PyTuple_New(PyArray_NDIM(input));\n+            tuple = PyTuple_New(PyArray_NDIM(input));\n             if (!tuple) {\n                 PyErr_NoMemory();\n                 goto exit;\n@@ -57,8 +57,8 @@\n                     PyErr_NoMemory();\n                     goto exit;\n                 }\n-                Py_XDECREF(start);\n-                Py_XDECREF(end);\n+                Py_DECREF(start);\n+                Py_DECREF(end);\n                 start = end = NULL;\n                 PyTuple_SetItem(tuple, jj, slc);\n                 slc = NULL;",
  "diff_line_info": {
    "deleted_lines": [
      "            PyObject *tuple = PyTuple_New(PyArray_NDIM(input));",
      "                Py_XDECREF(start);",
      "                Py_XDECREF(end);"
    ],
    "added_lines": [
      "            tuple = PyTuple_New(PyArray_NDIM(input));",
      "                Py_DECREF(start);",
      "                Py_DECREF(end);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/scipy/scipy/pull/16397",
  "description": {
    "pr_info": {
      "title": "MAINT: fix two refcounting issues in `ndimage`",
      "number": 16397
    },
    "comment": [
      "Closes gh-16235\r\nCloses gh-16236\r\n\r\nIndividual commit messages contain a few more notes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.85"
}