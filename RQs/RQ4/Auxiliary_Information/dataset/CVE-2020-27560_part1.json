{
  "cve_id": "CVE-2020-27560",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "ImageMagick",
  "commit_msg": "There is a Division by Zero in function OptimizeLayerFrames (#2743)\n\nin file MagickCore/layer.c. cur->ticks_per_seconds can be zero\r\nwith a crafted input argument *image. This is similar to\r\nCVE-2019-13454.",
  "commit_hash": "ef59bd764f88d893f1219fee8ba696a5d3f8c1c4",
  "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ef59bd764f88d893f1219fee8ba696a5d3f8c1c4",
  "file_path": "MagickCore/layer.c",
  "func_name": "OptimizeLayerFrames",
  "func_before": "static Image *OptimizeLayerFrames(const Image *image,const LayerMethod method,\n  ExceptionInfo *exception)\n{\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *prev_image,\n    *dup_image,\n    *bgnd_image,\n    *optimized_image;\n\n  RectangleInfo\n    try_bounds,\n    bgnd_bounds,\n    dup_bounds,\n    *bounds;\n\n  MagickBooleanType\n    add_frames,\n    try_cleared,\n    cleared;\n\n  DisposeType\n    *disposals;\n\n  register const Image\n    *curr;\n\n  register ssize_t\n    i;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(method == OptimizeLayer ||\n         method == OptimizeImageLayer ||\n         method == OptimizePlusLayer);\n  /*\n    Are we allowed to add/remove frames from animation?\n  */\n  add_frames=method == OptimizePlusLayer ? MagickTrue : MagickFalse;\n  /*\n    Ensure  all the images are the same size.\n  */\n  curr=GetFirstImageInList(image);\n  for (; curr != (Image *) NULL; curr=GetNextImageInList(curr))\n  {\n    if ((curr->columns != image->columns) || (curr->rows != image->rows))\n      ThrowImageException(OptionError,\"ImagesAreNotTheSameSize\");\n\n    if ((curr->page.x != 0) || (curr->page.y != 0) ||\n        (curr->page.width != image->page.width) ||\n        (curr->page.height != image->page.height))\n      ThrowImageException(OptionError,\"ImagePagesAreNotCoalesced\");\n  }\n  /*\n    Allocate memory (times 2 if we allow the use of frame duplications)\n  */\n  curr=GetFirstImageInList(image);\n  bounds=(RectangleInfo *) AcquireQuantumMemory((size_t)\n    GetImageListLength(curr),(add_frames != MagickFalse ? 2UL : 1UL)*\n    sizeof(*bounds));\n  if (bounds == (RectangleInfo *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  disposals=(DisposeType *) AcquireQuantumMemory((size_t)\n    GetImageListLength(image),(add_frames != MagickFalse ? 2UL : 1UL)*\n    sizeof(*disposals));\n  if (disposals == (DisposeType *) NULL)\n    {\n      bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Initialise Previous Image as fully transparent\n  */\n  prev_image=CloneImage(curr,curr->columns,curr->rows,MagickTrue,exception);\n  if (prev_image == (Image *) NULL)\n    {\n      bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n      disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n      return((Image *) NULL);\n    }\n  prev_image->page=curr->page;  /* ERROR: <-- should not be need, but is! */\n  prev_image->page.x=0;\n  prev_image->page.y=0;\n  prev_image->dispose=NoneDispose;\n  prev_image->background_color.alpha_trait=BlendPixelTrait;\n  prev_image->background_color.alpha=(MagickRealType) TransparentAlpha;\n  (void) SetImageBackgroundColor(prev_image,exception);\n  /*\n    Figure out the area of overlay of the first frame\n    No pixel could be cleared as all pixels are already cleared.\n  */\n#if DEBUG_OPT_FRAME\n  i=0;\n  (void) FormatLocaleFile(stderr,\"frame %.20g :-\\n\",(double) i);\n#endif\n  disposals[0]=NoneDispose;\n  bounds[0]=CompareImagesBounds(prev_image,curr,CompareAnyLayer,exception);\n#if DEBUG_OPT_FRAME\n  (void) FormatLocaleFile(stderr, \"overlay: %.20gx%.20g%+.20g%+.20g\\n\\n\",\n    (double) bounds[i].width,(double) bounds[i].height,\n    (double) bounds[i].x,(double) bounds[i].y );\n#endif\n  /*\n    Compute the bounding box of changes for each pair of images.\n  */\n  i=1;\n  bgnd_image=(Image *) NULL;\n  dup_image=(Image *) NULL;\n  dup_bounds.width=0;\n  dup_bounds.height=0;\n  dup_bounds.x=0;\n  dup_bounds.y=0;\n  curr=GetNextImageInList(curr);\n  for ( ; curr != (const Image *) NULL; curr=GetNextImageInList(curr))\n  {\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr,\"frame %.20g :-\\n\",(double) i);\n#endif\n    /*\n      Assume none disposal is the best\n    */\n    bounds[i]=CompareImagesBounds(curr->previous,curr,CompareAnyLayer,exception);\n    cleared=IsBoundsCleared(curr->previous,curr,&bounds[i],exception);\n    disposals[i-1]=NoneDispose;\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"overlay: %.20gx%.20g%+.20g%+.20g%s%s\\n\",\n         (double) bounds[i].width,(double) bounds[i].height,\n         (double) bounds[i].x,(double) bounds[i].y,\n         bounds[i].x < 0?\"  (unchanged)\":\"\",\n         cleared?\"  (pixels cleared)\":\"\");\n#endif\n    if ( bounds[i].x < 0 ) {\n      /*\n        Image frame is exactly the same as the previous frame!\n        If not adding frames leave it to be cropped down to a null image.\n        Otherwise mark previous image for deleted, transfering its crop bounds\n        to the current image.\n      */\n      if ( add_frames && i>=2 ) {\n        disposals[i-1]=DelDispose;\n        disposals[i]=NoneDispose;\n        bounds[i]=bounds[i-1];\n        i++;\n        continue;\n      }\n    }\n    else\n      {\n        /*\n          Compare a none disposal against a previous disposal\n        */\n        try_bounds=CompareImagesBounds(prev_image,curr,CompareAnyLayer,exception);\n        try_cleared=IsBoundsCleared(prev_image,curr,&try_bounds,exception);\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"test_prev: %.20gx%.20g%+.20g%+.20g%s\\n\",\n         (double) try_bounds.width,(double) try_bounds.height,\n         (double) try_bounds.x,(double) try_bounds.y,\n         try_cleared?\"  (pixels were cleared)\":\"\");\n#endif\n        if ( (!try_cleared && cleared ) ||\n                try_bounds.width * try_bounds.height\n                    <  bounds[i].width * bounds[i].height )\n          {\n            cleared=try_cleared;\n            bounds[i]=try_bounds;\n            disposals[i-1]=PreviousDispose;\n#if DEBUG_OPT_FRAME\n            (void) FormatLocaleFile(stderr,\"previous: accepted\\n\");\n          } else {\n            (void) FormatLocaleFile(stderr,\"previous: rejected\\n\");\n#endif\n          }\n\n        /*\n          If we are allowed lets try a complex frame duplication.\n          It is useless if the previous image already clears pixels correctly.\n          This method will always clear all the pixels that need to be cleared.\n        */\n        dup_bounds.width=dup_bounds.height=0; /* no dup, no pixel added */\n        if ( add_frames )\n          {\n            dup_image=CloneImage(curr->previous,0,0,MagickTrue,exception);\n            if (dup_image == (Image *) NULL)\n              {\n                bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n                disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n                prev_image=DestroyImage(prev_image);\n                return((Image *) NULL);\n              }\n            dup_image->background_color.alpha_trait=BlendPixelTrait;\n            dup_bounds=CompareImagesBounds(dup_image,curr,CompareClearLayer,exception);\n            ClearBounds(dup_image,&dup_bounds,exception);\n            try_bounds=CompareImagesBounds(dup_image,curr,CompareAnyLayer,exception);\n            if ( cleared ||\n                   dup_bounds.width*dup_bounds.height\n                      +try_bounds.width*try_bounds.height\n                   < bounds[i].width * bounds[i].height )\n              {\n                cleared=MagickFalse;\n                bounds[i]=try_bounds;\n                disposals[i-1]=DupDispose;\n                /* to be finalised later, if found to be optimial */\n              }\n            else\n              dup_bounds.width=dup_bounds.height=0;\n          }\n        /*\n          Now compare against a simple background disposal\n        */\n        bgnd_image=CloneImage(curr->previous,0,0,MagickTrue,exception);\n        if (bgnd_image == (Image *) NULL)\n          {\n            bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n            disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n            prev_image=DestroyImage(prev_image);\n            if ( dup_image != (Image *) NULL)\n              dup_image=DestroyImage(dup_image);\n            return((Image *) NULL);\n          }\n        bgnd_image->background_color.alpha_trait=BlendPixelTrait;\n        bgnd_bounds=bounds[i-1]; /* interum bounds of the previous image */\n        ClearBounds(bgnd_image,&bgnd_bounds,exception);\n        try_bounds=CompareImagesBounds(bgnd_image,curr,CompareAnyLayer,exception);\n        try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"background: %s\\n\",\n         try_cleared?\"(pixels cleared)\":\"\");\n#endif\n        if ( try_cleared )\n          {\n            /*\n              Straight background disposal failed to clear pixels needed!\n              Lets try expanding the disposal area of the previous frame, to\n              include the pixels that are cleared.  This guaranteed\n              to work, though may not be the most optimized solution.\n            */\n            try_bounds=CompareImagesBounds(curr->previous,curr,CompareClearLayer,exception);\n#if DEBUG_OPT_FRAME\n            (void) FormatLocaleFile(stderr, \"expand_clear: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y,\n                try_bounds.x<0?\"  (no expand nessary)\":\"\");\n#endif\n            if ( bgnd_bounds.x < 0 )\n              bgnd_bounds = try_bounds;\n            else\n              {\n#if DEBUG_OPT_FRAME\n                (void) FormatLocaleFile(stderr, \"expand_bgnd: %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) bgnd_bounds.width,(double) bgnd_bounds.height,\n                    (double) bgnd_bounds.x,(double) bgnd_bounds.y );\n#endif\n                if ( try_bounds.x < bgnd_bounds.x )\n                  {\n                     bgnd_bounds.width+= bgnd_bounds.x-try_bounds.x;\n                     if ( bgnd_bounds.width < try_bounds.width )\n                       bgnd_bounds.width = try_bounds.width;\n                     bgnd_bounds.x = try_bounds.x;\n                  }\n                else\n                  {\n                     try_bounds.width += try_bounds.x - bgnd_bounds.x;\n                     if ( bgnd_bounds.width < try_bounds.width )\n                       bgnd_bounds.width = try_bounds.width;\n                  }\n                if ( try_bounds.y < bgnd_bounds.y )\n                  {\n                     bgnd_bounds.height += bgnd_bounds.y - try_bounds.y;\n                     if ( bgnd_bounds.height < try_bounds.height )\n                       bgnd_bounds.height = try_bounds.height;\n                     bgnd_bounds.y = try_bounds.y;\n                  }\n                else\n                  {\n                    try_bounds.height += try_bounds.y - bgnd_bounds.y;\n                     if ( bgnd_bounds.height < try_bounds.height )\n                       bgnd_bounds.height = try_bounds.height;\n                  }\n#if DEBUG_OPT_FRAME\n                (void) FormatLocaleFile(stderr, \"        to : %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) bgnd_bounds.width,(double) bgnd_bounds.height,\n                    (double) bgnd_bounds.x,(double) bgnd_bounds.y );\n#endif\n              }\n            ClearBounds(bgnd_image,&bgnd_bounds,exception);\n#if DEBUG_OPT_FRAME\n/* Something strange is happening with a specific animation\n * CompareAnyLayers (normal method) and CompareClearLayers returns the whole\n * image, which is not posibly correct!  As verified by previous tests.\n * Something changed beyond the bgnd_bounds clearing.  But without being able\n * to see, or writet he image at this point it is hard to tell what is wrong!\n * Only CompareOverlay seemed to return something sensible.\n */\n            try_bounds=CompareImagesBounds(bgnd_image,curr,CompareClearLayer,exception);\n            (void) FormatLocaleFile(stderr, \"expand_ctst: %.20gx%.20g%+.20g%+.20g\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y );\n            try_bounds=CompareImagesBounds(bgnd_image,curr,CompareAnyLayer,exception);\n            try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n            (void) FormatLocaleFile(stderr, \"expand_any : %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y,\n                try_cleared?\"   (pixels cleared)\":\"\");\n#endif\n            try_bounds=CompareImagesBounds(bgnd_image,curr,CompareOverlayLayer,exception);\n#if DEBUG_OPT_FRAME\n            try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n            (void) FormatLocaleFile(stderr, \"expand_test: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y,\n                try_cleared?\"   (pixels cleared)\":\"\");\n#endif\n          }\n        /*\n          Test if this background dispose is smaller than any of the\n          other methods we tryed before this (including duplicated frame)\n        */\n        if ( cleared ||\n              bgnd_bounds.width*bgnd_bounds.height\n                +try_bounds.width*try_bounds.height\n              < bounds[i-1].width*bounds[i-1].height\n                  +dup_bounds.width*dup_bounds.height\n                  +bounds[i].width*bounds[i].height )\n          {\n            cleared=MagickFalse;\n            bounds[i-1]=bgnd_bounds;\n            bounds[i]=try_bounds;\n            if ( disposals[i-1] == DupDispose )\n              dup_image=DestroyImage(dup_image);\n            disposals[i-1]=BackgroundDispose;\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr,\"expand_bgnd: accepted\\n\");\n          } else {\n    (void) FormatLocaleFile(stderr,\"expand_bgnd: reject\\n\");\n#endif\n          }\n      }\n    /*\n       Finalise choice of dispose, set new prev_image,\n       and junk any extra images as appropriate,\n    */\n    if ( disposals[i-1] == DupDispose )\n      {\n         if (bgnd_image != (Image *) NULL)\n           bgnd_image=DestroyImage(bgnd_image);\n         prev_image=DestroyImage(prev_image);\n         prev_image=dup_image, dup_image=(Image *) NULL;\n         bounds[i+1]=bounds[i];\n         bounds[i]=dup_bounds;\n         disposals[i-1]=DupDispose;\n         disposals[i]=BackgroundDispose;\n         i++;\n      }\n    else\n      {\n        if ( dup_image != (Image *) NULL)\n          dup_image=DestroyImage(dup_image);\n        if ( disposals[i-1] != PreviousDispose )\n          prev_image=DestroyImage(prev_image);\n        if ( disposals[i-1] == BackgroundDispose )\n          prev_image=bgnd_image, bgnd_image=(Image *) NULL;\n        if (bgnd_image != (Image *) NULL)\n          bgnd_image=DestroyImage(bgnd_image);\n        if ( disposals[i-1] == NoneDispose )\n          {\n            prev_image=ReferenceImage(curr->previous);\n            if (prev_image == (Image *) NULL)\n              {\n                bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n                disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n                return((Image *) NULL);\n              }\n          }\n\n      }\n    assert(prev_image != (Image *) NULL);\n    disposals[i]=disposals[i-1];\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"final   %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) i-1,\n         CommandOptionToMnemonic(MagickDisposeOptions,disposals[i-1]),\n         (double) bounds[i-1].width,(double) bounds[i-1].height,\n         (double) bounds[i-1].x,(double) bounds[i-1].y );\n#endif\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"interum %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) i,\n         CommandOptionToMnemonic(MagickDisposeOptions,disposals[i]),\n         (double) bounds[i].width,(double) bounds[i].height,\n         (double) bounds[i].x,(double) bounds[i].y );\n    (void) FormatLocaleFile(stderr,\"\\n\");\n#endif\n    i++;\n  }\n  prev_image=DestroyImage(prev_image);\n  /*\n    Optimize all images in sequence.\n  */\n  sans_exception=AcquireExceptionInfo();\n  i=0;\n  curr=GetFirstImageInList(image);\n  optimized_image=NewImageList();\n  while ( curr != (const Image *) NULL )\n  {\n    prev_image=CloneImage(curr,0,0,MagickTrue,exception);\n    if (prev_image == (Image *) NULL)\n      break;\n    prev_image->background_color.alpha_trait=BlendPixelTrait;\n    if ( disposals[i] == DelDispose ) {\n      size_t time = 0;\n      while ( disposals[i] == DelDispose ) {\n        time += curr->delay*1000/curr->ticks_per_second;\n        curr=GetNextImageInList(curr);\n        i++;\n      }\n      time += curr->delay*1000/curr->ticks_per_second;\n      prev_image->ticks_per_second = 100L;\n      prev_image->delay = time*prev_image->ticks_per_second/1000;\n    }\n    bgnd_image=CropImage(prev_image,&bounds[i],sans_exception);\n    prev_image=DestroyImage(prev_image);\n    if (bgnd_image == (Image *) NULL)\n      break;\n    bgnd_image->dispose=disposals[i];\n    if ( disposals[i] == DupDispose ) {\n      bgnd_image->delay=0;\n      bgnd_image->dispose=NoneDispose;\n    }\n    else\n      curr=GetNextImageInList(curr);\n    AppendImageToList(&optimized_image,bgnd_image);\n    i++;\n  }\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n  disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n  if (curr != (Image *) NULL)\n    {\n      optimized_image=DestroyImageList(optimized_image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(optimized_image));\n}",
  "abstract_func_before": "static Image *OptimizeLayerFrames(const Image *VAR_0,const LayerMethod VAR_1,\n  ExceptionInfo *VAR_2)\n{\n  ExceptionInfo\n    *VAR_3;\n\n  Image\n    *VAR_4,\n    *VAR_5,\n    *VAR_6,\n    *VAR_7;\n\n  RectangleInfo\n    VAR_8,\n    VAR_9,\n    VAR_10,\n    *VAR_11;\n\n  MagickBooleanType\n    VAR_12,\n    VAR_13,\n    VAR_14;\n\n  DisposeType\n    *VAR_15;\n\n  register const Image\n    *VAR_16;\n\n  register ssize_t\n    VAR_17;\n\n  assert(VAR_0 != (const Image *) NULL);\n  assert(VAR_0->signature == VAR_18);\n  if (VAR_0->debug != VAR_19)\n    (void) LogMagickEvent(VAR_20,GetMagickModule(),\"%s\",VAR_0->filename);\n  assert(VAR_2 != (ExceptionInfo *) NULL);\n  assert(VAR_2->signature == VAR_18);\n  assert(VAR_1 == VAR_21 ||\n         VAR_1 == VAR_22 ||\n         VAR_1 == VAR_23);\n  /* COMMENT_0 */\n                                                       \n    \n  VAR_12=VAR_1 == VAR_23 ? VAR_24 : VAR_19;\n  /* COMMENT_3 */\n                                             \n    \n  VAR_16=GetFirstImageInList(VAR_0);\n  for (; VAR_16 != (Image *) NULL; VAR_16=GetNextImageInList(VAR_16))\n  {\n    if ((VAR_16->columns != VAR_0->columns) || (VAR_16->rows != VAR_0->rows))\n      ThrowImageException(VAR_25,\"ImagesAreNotTheSameSize\");\n\n    if ((VAR_16->page.x != 0) || (VAR_16->page.y != 0) ||\n        (VAR_16->page.width != VAR_0->page.width) ||\n        (VAR_16->page.height != VAR_0->page.height))\n      ThrowImageException(VAR_25,\"ImagePagesAreNotCoalesced\");\n  }\n  /* COMMENT_6 */\n                                                                       \n    \n  VAR_16=GetFirstImageInList(VAR_0);\n  VAR_11=(RectangleInfo *) AcquireQuantumMemory((size_t)\n    GetImageListLength(VAR_16),(VAR_12 != VAR_19 ? 2UL : 1UL)*\n    sizeof(*VAR_11));\n  if (VAR_11 == (RectangleInfo *) NULL)\n    ThrowImageException(VAR_26,\"MemoryAllocationFailed\");\n  VAR_15=(DisposeType *) AcquireQuantumMemory((size_t)\n    GetImageListLength(VAR_0),(VAR_12 != VAR_19 ? 2UL : 1UL)*\n    sizeof(*VAR_15));\n  if (VAR_15 == (DisposeType *) NULL)\n    {\n      VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n      ThrowImageException(VAR_26,\"MemoryAllocationFailed\");\n    }\n  /* COMMENT_9 */\n                                                  \n    \n  VAR_4=CloneImage(VAR_16,VAR_16->columns,VAR_16->rows,VAR_24,VAR_2);\n  if (VAR_4 == (Image *) NULL)\n    {\n      VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n      VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n      return((Image *) NULL);\n    }\n  VAR_4->page=VAR_16->page;  /* COMMENT_12 */\n  VAR_4->page.x=0;\n  VAR_4->page.y=0;\n  VAR_4->dispose=VAR_27;\n  VAR_4->background_color.alpha_trait=VAR_28;\n  VAR_4->background_color.alpha=(MagickRealType) VAR_29;\n  (void) SetImageBackgroundColor(VAR_4,VAR_2);\n  /* COMMENT_13 */\n                                                     \n                                                                \n    \n#if VAR_30\n  VAR_17=0;\n  (void) FormatLocaleFile(VAR_31,\"frame %.20g :-\\n\",(double) VAR_17);\n#endif\n  VAR_15[0]=VAR_27;\n  VAR_11[0]=CompareImagesBounds(VAR_4,VAR_16,VAR_32,VAR_2);\n#if VAR_30\n  (void) FormatLocaleFile(VAR_31, \"overlay: %.20gx%.20g%+.20g%+.20g\\n\\n\",\n    (double) VAR_11[VAR_17].width,(double) VAR_11[VAR_17].height,\n    (double) VAR_11[VAR_17].x,(double) VAR_11[VAR_17].y );\n#endif\n  /* COMMENT_17 */\n                                                                \n    \n  VAR_17=1;\n  VAR_6=(Image *) NULL;\n  VAR_5=(Image *) NULL;\n  VAR_10.width=0;\n  VAR_10.height=0;\n  VAR_10.x=0;\n  VAR_10.y=0;\n  VAR_16=GetNextImageInList(VAR_16);\n  for ( ; VAR_16 != (const Image *) NULL; VAR_16=GetNextImageInList(VAR_16))\n  {\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31,\"frame %.20g :-\\n\",(double) VAR_17);\n#endif\n    /* COMMENT_20 */\n                                      \n      \n    VAR_11[VAR_17]=CompareImagesBounds(VAR_16->previous,VAR_16,VAR_32,VAR_2);\n    VAR_14=IsBoundsCleared(VAR_16->previous,VAR_16,&VAR_11[VAR_17],VAR_2);\n    VAR_15[VAR_17-1]=VAR_27;\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"overlay: %.20gx%.20g%+.20g%+.20g%s%s\\n\",\n         (double) VAR_11[VAR_17].width,(double) VAR_11[VAR_17].height,\n         (double) VAR_11[VAR_17].x,(double) VAR_11[VAR_17].y,\n         VAR_11[VAR_17].x < 0?\"  (unchanged)\":\"\",\n         VAR_14?\"  (pixels cleared)\":\"\");\n#endif\n    if ( VAR_11[VAR_17].x < 0 ) {\n      /* COMMENT_23 */\n                                                              \n                                                                         \n                                                                              \n                             \n        \n      if ( VAR_12 && VAR_17>=2 ) {\n        VAR_15[VAR_17-1]=VAR_33;\n        VAR_15[VAR_17]=VAR_27;\n        VAR_11[VAR_17]=VAR_11[VAR_17-1];\n        VAR_17++;\n        continue;\n      }\n    }\n    else\n      {\n        /* COMMENT_29 */\n                                                             \n          \n        VAR_8=CompareImagesBounds(VAR_4,VAR_16,VAR_32,VAR_2);\n        VAR_13=IsBoundsCleared(VAR_4,VAR_16,&VAR_8,VAR_2);\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"test_prev: %.20gx%.20g%+.20g%+.20g%s\\n\",\n         (double) VAR_8.width,(double) VAR_8.height,\n         (double) VAR_8.x,(double) VAR_8.y,\n         VAR_13?\"  (pixels were cleared)\":\"\");\n#endif\n        if ( (!VAR_13 && VAR_14 ) ||\n                VAR_8.width * VAR_8.height\n                    <  VAR_11[VAR_17].width * VAR_11[VAR_17].height )\n          {\n            VAR_14=VAR_13;\n            VAR_11[VAR_17]=VAR_8;\n            VAR_15[VAR_17-1]=VAR_34;\n#if VAR_30\n            (void) FormatLocaleFile(VAR_31,\"previous: accepted\\n\");\n          } else {\n            (void) FormatLocaleFile(VAR_31,\"previous: rejected\\n\");\n#endif\n          }\n\n        /* COMMENT_32 */\n                                                                 \n                                                                              \n                                                                               \n          \n        VAR_10.width=VAR_10.height=0; /* COMMENT_37 */\n        if ( VAR_12 )\n          {\n            VAR_5=CloneImage(VAR_16->previous,0,0,VAR_24,VAR_2);\n            if (VAR_5 == (Image *) NULL)\n              {\n                VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n                VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n                VAR_4=DestroyImage(VAR_4);\n                return((Image *) NULL);\n              }\n            VAR_5->background_color.alpha_trait=VAR_28;\n            VAR_10=CompareImagesBounds(VAR_5,VAR_16,VAR_35,VAR_2);\n            ClearBounds(VAR_5,&VAR_10,VAR_2);\n            VAR_8=CompareImagesBounds(VAR_5,VAR_16,VAR_32,VAR_2);\n            if ( VAR_14 ||\n                   VAR_10.width*VAR_10.height\n                      +VAR_8.width*VAR_8.height\n                   < VAR_11[VAR_17].width * VAR_11[VAR_17].height )\n              {\n                VAR_14=VAR_19;\n                VAR_11[VAR_17]=VAR_8;\n                VAR_15[VAR_17-1]=VAR_36;\n                /* COMMENT_38 */\n              }\n            else\n              VAR_10.width=VAR_10.height=0;\n          }\n        /* COMMENT_39 */\n                                                          \n          \n        VAR_6=CloneImage(VAR_16->previous,0,0,VAR_24,VAR_2);\n        if (VAR_6 == (Image *) NULL)\n          {\n            VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n            VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n            VAR_4=DestroyImage(VAR_4);\n            if ( VAR_5 != (Image *) NULL)\n              VAR_5=DestroyImage(VAR_5);\n            return((Image *) NULL);\n          }\n        VAR_6->background_color.alpha_trait=VAR_28;\n        VAR_9=VAR_11[VAR_17-1]; /* COMMENT_42 */\n        ClearBounds(VAR_6,&VAR_9,VAR_2);\n        VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_32,VAR_2);\n        VAR_13=IsBoundsCleared(VAR_6,VAR_16,&VAR_8,VAR_2);\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"background: %s\\n\",\n         VAR_13?\"(pixels cleared)\":\"\");\n#endif\n        if ( VAR_13 )\n          {\n            /* COMMENT_43 */\n                                                                         \n                                                                            \n                                                                   \n                                                                     \n              \n            VAR_8=CompareImagesBounds(VAR_16->previous,VAR_16,VAR_35,VAR_2);\n#if VAR_30\n            (void) FormatLocaleFile(VAR_31, \"expand_clear: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y,\n                VAR_8.x<0?\"  (no expand nessary)\":\"\");\n#endif\n            if ( VAR_9.x < 0 )\n              VAR_9 = VAR_8;\n            else\n              {\n#if VAR_30\n                (void) FormatLocaleFile(VAR_31, \"expand_bgnd: %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) VAR_9.width,(double) VAR_9.height,\n                    (double) VAR_9.x,(double) VAR_9.y );\n#endif\n                if ( VAR_8.x < VAR_9.x )\n                  {\n                     VAR_9.width+= VAR_9.x-VAR_8.x;\n                     if ( VAR_9.width < VAR_8.width )\n                       VAR_9.width = VAR_8.width;\n                     VAR_9.x = VAR_8.x;\n                  }\n                else\n                  {\n                     VAR_8.width += VAR_8.x - VAR_9.x;\n                     if ( VAR_9.width < VAR_8.width )\n                       VAR_9.width = VAR_8.width;\n                  }\n                if ( VAR_8.y < VAR_9.y )\n                  {\n                     VAR_9.height += VAR_9.y - VAR_8.y;\n                     if ( VAR_9.height < VAR_8.height )\n                       VAR_9.height = VAR_8.height;\n                     VAR_9.y = VAR_8.y;\n                  }\n                else\n                  {\n                    VAR_8.height += VAR_8.y - VAR_9.y;\n                     if ( VAR_9.height < VAR_8.height )\n                       VAR_9.height = VAR_8.height;\n                  }\n#if VAR_30\n                (void) FormatLocaleFile(VAR_31, \"        to : %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) VAR_9.width,(double) VAR_9.height,\n                    (double) VAR_9.x,(double) VAR_9.y );\n#endif\n              }\n            ClearBounds(VAR_6,&VAR_9,VAR_2);\n#if VAR_30\n/* COMMENT_49 */\n                                                                            \n                                                                       \n                                                                             \n                                                                             \n                                                           \n   \n            VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_35,VAR_2);\n            (void) FormatLocaleFile(VAR_31, \"expand_ctst: %.20gx%.20g%+.20g%+.20g\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y );\n            VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_32,VAR_2);\n            VAR_13=IsBoundsCleared(VAR_6,VAR_16,&VAR_8,VAR_2);\n            (void) FormatLocaleFile(VAR_31, \"expand_any : %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y,\n                VAR_13?\"   (pixels cleared)\":\"\");\n#endif\n            VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_37,VAR_2);\n#if VAR_30\n            VAR_13=IsBoundsCleared(VAR_6,VAR_16,&VAR_8,VAR_2);\n            (void) FormatLocaleFile(VAR_31, \"expand_test: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y,\n                VAR_13?\"   (pixels cleared)\":\"\");\n#endif\n          }\n        /* COMMENT_56 */\n                                                                    \n                                                                         \n          \n        if ( VAR_14 ||\n              VAR_9.width*VAR_9.height\n                +VAR_8.width*VAR_8.height\n              < VAR_11[VAR_17-1].width*VAR_11[VAR_17-1].height\n                  +VAR_10.width*VAR_10.height\n                  +VAR_11[VAR_17].width*VAR_11[VAR_17].height )\n          {\n            VAR_14=VAR_19;\n            VAR_11[VAR_17-1]=VAR_9;\n            VAR_11[VAR_17]=VAR_8;\n            if ( VAR_15[VAR_17-1] == VAR_36 )\n              VAR_5=DestroyImage(VAR_5);\n            VAR_15[VAR_17-1]=VAR_38;\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31,\"expand_bgnd: accepted\\n\");\n          } else {\n    (void) FormatLocaleFile(VAR_31,\"expand_bgnd: reject\\n\");\n#endif\n          }\n      }\n    /* COMMENT_60 */\n                                                      \n                                                \n      \n    if ( VAR_15[VAR_17-1] == VAR_36 )\n      {\n         if (VAR_6 != (Image *) NULL)\n           VAR_6=DestroyImage(VAR_6);\n         VAR_4=DestroyImage(VAR_4);\n         VAR_4=VAR_5, VAR_5=(Image *) NULL;\n         VAR_11[VAR_17+1]=VAR_11[VAR_17];\n         VAR_11[VAR_17]=VAR_10;\n         VAR_15[VAR_17-1]=VAR_36;\n         VAR_15[VAR_17]=VAR_38;\n         VAR_17++;\n      }\n    else\n      {\n        if ( VAR_5 != (Image *) NULL)\n          VAR_5=DestroyImage(VAR_5);\n        if ( VAR_15[VAR_17-1] != VAR_34 )\n          VAR_4=DestroyImage(VAR_4);\n        if ( VAR_15[VAR_17-1] == VAR_38 )\n          VAR_4=VAR_6, VAR_6=(Image *) NULL;\n        if (VAR_6 != (Image *) NULL)\n          VAR_6=DestroyImage(VAR_6);\n        if ( VAR_15[VAR_17-1] == VAR_27 )\n          {\n            VAR_4=ReferenceImage(VAR_16->previous);\n            if (VAR_4 == (Image *) NULL)\n              {\n                VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n                VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n                return((Image *) NULL);\n              }\n          }\n\n      }\n    assert(VAR_4 != (Image *) NULL);\n    VAR_15[VAR_17]=VAR_15[VAR_17-1];\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"final   %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) VAR_17-1,\n         CommandOptionToMnemonic(VAR_39,VAR_15[VAR_17-1]),\n         (double) VAR_11[VAR_17-1].width,(double) VAR_11[VAR_17-1].height,\n         (double) VAR_11[VAR_17-1].x,(double) VAR_11[VAR_17-1].y );\n#endif\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"interum %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) VAR_17,\n         CommandOptionToMnemonic(VAR_39,VAR_15[VAR_17]),\n         (double) VAR_11[VAR_17].width,(double) VAR_11[VAR_17].height,\n         (double) VAR_11[VAR_17].x,(double) VAR_11[VAR_17].y );\n    (void) FormatLocaleFile(VAR_31,\"\\n\");\n#endif\n    VAR_17++;\n  }\n  VAR_4=DestroyImage(VAR_4);\n  /* COMMENT_64 */\n                                    \n    \n  VAR_3=AcquireExceptionInfo();\n  VAR_17=0;\n  VAR_16=GetFirstImageInList(VAR_0);\n  VAR_7=NewImageList();\n  while ( VAR_16 != (const Image *) NULL )\n  {\n    VAR_4=CloneImage(VAR_16,0,0,VAR_24,VAR_2);\n    if (VAR_4 == (Image *) NULL)\n      break;\n    VAR_4->background_color.alpha_trait=VAR_28;\n    if ( VAR_15[VAR_17] == VAR_33 ) {\n      size_t VAR_40 = 0;\n      while ( VAR_15[VAR_17] == VAR_33 ) {\n        VAR_40 += VAR_16->delay*1000/VAR_16->ticks_per_second;\n        VAR_16=GetNextImageInList(VAR_16);\n        VAR_17++;\n      }\n      VAR_40 += VAR_16->delay*1000/VAR_16->ticks_per_second;\n      VAR_4->ticks_per_second = 100L;\n      VAR_4->delay = VAR_40*VAR_4->ticks_per_second/1000;\n    }\n    VAR_6=CropImage(VAR_4,&VAR_11[VAR_17],VAR_3);\n    VAR_4=DestroyImage(VAR_4);\n    if (VAR_6 == (Image *) NULL)\n      break;\n    VAR_6->dispose=VAR_15[VAR_17];\n    if ( VAR_15[VAR_17] == VAR_36 ) {\n      VAR_6->delay=0;\n      VAR_6->dispose=VAR_27;\n    }\n    else\n      VAR_16=GetNextImageInList(VAR_16);\n    AppendImageToList(&VAR_7,VAR_6);\n    VAR_17++;\n  }\n  VAR_3=DestroyExceptionInfo(VAR_3);\n  VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n  VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n  if (VAR_16 != (Image *) NULL)\n    {\n      VAR_7=DestroyImageList(VAR_7);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(VAR_7));\n}",
  "func_graph_path_before": "ImageMagick/ef59bd764f88d893f1219fee8ba696a5d3f8c1c4/layer.c/vul/before/0.json",
  "func": "static Image *OptimizeLayerFrames(const Image *image,const LayerMethod method,\n  ExceptionInfo *exception)\n{\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *prev_image,\n    *dup_image,\n    *bgnd_image,\n    *optimized_image;\n\n  RectangleInfo\n    try_bounds,\n    bgnd_bounds,\n    dup_bounds,\n    *bounds;\n\n  MagickBooleanType\n    add_frames,\n    try_cleared,\n    cleared;\n\n  DisposeType\n    *disposals;\n\n  register const Image\n    *curr;\n\n  register ssize_t\n    i;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(method == OptimizeLayer ||\n         method == OptimizeImageLayer ||\n         method == OptimizePlusLayer);\n  /*\n    Are we allowed to add/remove frames from animation?\n  */\n  add_frames=method == OptimizePlusLayer ? MagickTrue : MagickFalse;\n  /*\n    Ensure  all the images are the same size.\n  */\n  curr=GetFirstImageInList(image);\n  for (; curr != (Image *) NULL; curr=GetNextImageInList(curr))\n  {\n    if ((curr->columns != image->columns) || (curr->rows != image->rows))\n      ThrowImageException(OptionError,\"ImagesAreNotTheSameSize\");\n\n    if ((curr->page.x != 0) || (curr->page.y != 0) ||\n        (curr->page.width != image->page.width) ||\n        (curr->page.height != image->page.height))\n      ThrowImageException(OptionError,\"ImagePagesAreNotCoalesced\");\n  }\n  /*\n    Allocate memory (times 2 if we allow the use of frame duplications)\n  */\n  curr=GetFirstImageInList(image);\n  bounds=(RectangleInfo *) AcquireQuantumMemory((size_t)\n    GetImageListLength(curr),(add_frames != MagickFalse ? 2UL : 1UL)*\n    sizeof(*bounds));\n  if (bounds == (RectangleInfo *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  disposals=(DisposeType *) AcquireQuantumMemory((size_t)\n    GetImageListLength(image),(add_frames != MagickFalse ? 2UL : 1UL)*\n    sizeof(*disposals));\n  if (disposals == (DisposeType *) NULL)\n    {\n      bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Initialise Previous Image as fully transparent\n  */\n  prev_image=CloneImage(curr,curr->columns,curr->rows,MagickTrue,exception);\n  if (prev_image == (Image *) NULL)\n    {\n      bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n      disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n      return((Image *) NULL);\n    }\n  prev_image->page=curr->page;  /* ERROR: <-- should not be need, but is! */\n  prev_image->page.x=0;\n  prev_image->page.y=0;\n  prev_image->dispose=NoneDispose;\n  prev_image->background_color.alpha_trait=BlendPixelTrait;\n  prev_image->background_color.alpha=(MagickRealType) TransparentAlpha;\n  (void) SetImageBackgroundColor(prev_image,exception);\n  /*\n    Figure out the area of overlay of the first frame\n    No pixel could be cleared as all pixels are already cleared.\n  */\n#if DEBUG_OPT_FRAME\n  i=0;\n  (void) FormatLocaleFile(stderr,\"frame %.20g :-\\n\",(double) i);\n#endif\n  disposals[0]=NoneDispose;\n  bounds[0]=CompareImagesBounds(prev_image,curr,CompareAnyLayer,exception);\n#if DEBUG_OPT_FRAME\n  (void) FormatLocaleFile(stderr, \"overlay: %.20gx%.20g%+.20g%+.20g\\n\\n\",\n    (double) bounds[i].width,(double) bounds[i].height,\n    (double) bounds[i].x,(double) bounds[i].y );\n#endif\n  /*\n    Compute the bounding box of changes for each pair of images.\n  */\n  i=1;\n  bgnd_image=(Image *) NULL;\n  dup_image=(Image *) NULL;\n  dup_bounds.width=0;\n  dup_bounds.height=0;\n  dup_bounds.x=0;\n  dup_bounds.y=0;\n  curr=GetNextImageInList(curr);\n  for ( ; curr != (const Image *) NULL; curr=GetNextImageInList(curr))\n  {\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr,\"frame %.20g :-\\n\",(double) i);\n#endif\n    /*\n      Assume none disposal is the best\n    */\n    bounds[i]=CompareImagesBounds(curr->previous,curr,CompareAnyLayer,exception);\n    cleared=IsBoundsCleared(curr->previous,curr,&bounds[i],exception);\n    disposals[i-1]=NoneDispose;\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"overlay: %.20gx%.20g%+.20g%+.20g%s%s\\n\",\n         (double) bounds[i].width,(double) bounds[i].height,\n         (double) bounds[i].x,(double) bounds[i].y,\n         bounds[i].x < 0?\"  (unchanged)\":\"\",\n         cleared?\"  (pixels cleared)\":\"\");\n#endif\n    if ( bounds[i].x < 0 ) {\n      /*\n        Image frame is exactly the same as the previous frame!\n        If not adding frames leave it to be cropped down to a null image.\n        Otherwise mark previous image for deleted, transfering its crop bounds\n        to the current image.\n      */\n      if ( add_frames && i>=2 ) {\n        disposals[i-1]=DelDispose;\n        disposals[i]=NoneDispose;\n        bounds[i]=bounds[i-1];\n        i++;\n        continue;\n      }\n    }\n    else\n      {\n        /*\n          Compare a none disposal against a previous disposal\n        */\n        try_bounds=CompareImagesBounds(prev_image,curr,CompareAnyLayer,exception);\n        try_cleared=IsBoundsCleared(prev_image,curr,&try_bounds,exception);\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"test_prev: %.20gx%.20g%+.20g%+.20g%s\\n\",\n         (double) try_bounds.width,(double) try_bounds.height,\n         (double) try_bounds.x,(double) try_bounds.y,\n         try_cleared?\"  (pixels were cleared)\":\"\");\n#endif\n        if ( (!try_cleared && cleared ) ||\n                try_bounds.width * try_bounds.height\n                    <  bounds[i].width * bounds[i].height )\n          {\n            cleared=try_cleared;\n            bounds[i]=try_bounds;\n            disposals[i-1]=PreviousDispose;\n#if DEBUG_OPT_FRAME\n            (void) FormatLocaleFile(stderr,\"previous: accepted\\n\");\n          } else {\n            (void) FormatLocaleFile(stderr,\"previous: rejected\\n\");\n#endif\n          }\n\n        /*\n          If we are allowed lets try a complex frame duplication.\n          It is useless if the previous image already clears pixels correctly.\n          This method will always clear all the pixels that need to be cleared.\n        */\n        dup_bounds.width=dup_bounds.height=0; /* no dup, no pixel added */\n        if ( add_frames )\n          {\n            dup_image=CloneImage(curr->previous,0,0,MagickTrue,exception);\n            if (dup_image == (Image *) NULL)\n              {\n                bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n                disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n                prev_image=DestroyImage(prev_image);\n                return((Image *) NULL);\n              }\n            dup_image->background_color.alpha_trait=BlendPixelTrait;\n            dup_bounds=CompareImagesBounds(dup_image,curr,CompareClearLayer,exception);\n            ClearBounds(dup_image,&dup_bounds,exception);\n            try_bounds=CompareImagesBounds(dup_image,curr,CompareAnyLayer,exception);\n            if ( cleared ||\n                   dup_bounds.width*dup_bounds.height\n                      +try_bounds.width*try_bounds.height\n                   < bounds[i].width * bounds[i].height )\n              {\n                cleared=MagickFalse;\n                bounds[i]=try_bounds;\n                disposals[i-1]=DupDispose;\n                /* to be finalised later, if found to be optimial */\n              }\n            else\n              dup_bounds.width=dup_bounds.height=0;\n          }\n        /*\n          Now compare against a simple background disposal\n        */\n        bgnd_image=CloneImage(curr->previous,0,0,MagickTrue,exception);\n        if (bgnd_image == (Image *) NULL)\n          {\n            bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n            disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n            prev_image=DestroyImage(prev_image);\n            if ( dup_image != (Image *) NULL)\n              dup_image=DestroyImage(dup_image);\n            return((Image *) NULL);\n          }\n        bgnd_image->background_color.alpha_trait=BlendPixelTrait;\n        bgnd_bounds=bounds[i-1]; /* interum bounds of the previous image */\n        ClearBounds(bgnd_image,&bgnd_bounds,exception);\n        try_bounds=CompareImagesBounds(bgnd_image,curr,CompareAnyLayer,exception);\n        try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"background: %s\\n\",\n         try_cleared?\"(pixels cleared)\":\"\");\n#endif\n        if ( try_cleared )\n          {\n            /*\n              Straight background disposal failed to clear pixels needed!\n              Lets try expanding the disposal area of the previous frame, to\n              include the pixels that are cleared.  This guaranteed\n              to work, though may not be the most optimized solution.\n            */\n            try_bounds=CompareImagesBounds(curr->previous,curr,CompareClearLayer,exception);\n#if DEBUG_OPT_FRAME\n            (void) FormatLocaleFile(stderr, \"expand_clear: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y,\n                try_bounds.x<0?\"  (no expand nessary)\":\"\");\n#endif\n            if ( bgnd_bounds.x < 0 )\n              bgnd_bounds = try_bounds;\n            else\n              {\n#if DEBUG_OPT_FRAME\n                (void) FormatLocaleFile(stderr, \"expand_bgnd: %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) bgnd_bounds.width,(double) bgnd_bounds.height,\n                    (double) bgnd_bounds.x,(double) bgnd_bounds.y );\n#endif\n                if ( try_bounds.x < bgnd_bounds.x )\n                  {\n                     bgnd_bounds.width+= bgnd_bounds.x-try_bounds.x;\n                     if ( bgnd_bounds.width < try_bounds.width )\n                       bgnd_bounds.width = try_bounds.width;\n                     bgnd_bounds.x = try_bounds.x;\n                  }\n                else\n                  {\n                     try_bounds.width += try_bounds.x - bgnd_bounds.x;\n                     if ( bgnd_bounds.width < try_bounds.width )\n                       bgnd_bounds.width = try_bounds.width;\n                  }\n                if ( try_bounds.y < bgnd_bounds.y )\n                  {\n                     bgnd_bounds.height += bgnd_bounds.y - try_bounds.y;\n                     if ( bgnd_bounds.height < try_bounds.height )\n                       bgnd_bounds.height = try_bounds.height;\n                     bgnd_bounds.y = try_bounds.y;\n                  }\n                else\n                  {\n                    try_bounds.height += try_bounds.y - bgnd_bounds.y;\n                     if ( bgnd_bounds.height < try_bounds.height )\n                       bgnd_bounds.height = try_bounds.height;\n                  }\n#if DEBUG_OPT_FRAME\n                (void) FormatLocaleFile(stderr, \"        to : %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) bgnd_bounds.width,(double) bgnd_bounds.height,\n                    (double) bgnd_bounds.x,(double) bgnd_bounds.y );\n#endif\n              }\n            ClearBounds(bgnd_image,&bgnd_bounds,exception);\n#if DEBUG_OPT_FRAME\n/* Something strange is happening with a specific animation\n * CompareAnyLayers (normal method) and CompareClearLayers returns the whole\n * image, which is not posibly correct!  As verified by previous tests.\n * Something changed beyond the bgnd_bounds clearing.  But without being able\n * to see, or writet he image at this point it is hard to tell what is wrong!\n * Only CompareOverlay seemed to return something sensible.\n */\n            try_bounds=CompareImagesBounds(bgnd_image,curr,CompareClearLayer,exception);\n            (void) FormatLocaleFile(stderr, \"expand_ctst: %.20gx%.20g%+.20g%+.20g\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y );\n            try_bounds=CompareImagesBounds(bgnd_image,curr,CompareAnyLayer,exception);\n            try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n            (void) FormatLocaleFile(stderr, \"expand_any : %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y,\n                try_cleared?\"   (pixels cleared)\":\"\");\n#endif\n            try_bounds=CompareImagesBounds(bgnd_image,curr,CompareOverlayLayer,exception);\n#if DEBUG_OPT_FRAME\n            try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n            (void) FormatLocaleFile(stderr, \"expand_test: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) try_bounds.width,(double) try_bounds.height,\n                (double) try_bounds.x,(double) try_bounds.y,\n                try_cleared?\"   (pixels cleared)\":\"\");\n#endif\n          }\n        /*\n          Test if this background dispose is smaller than any of the\n          other methods we tryed before this (including duplicated frame)\n        */\n        if ( cleared ||\n              bgnd_bounds.width*bgnd_bounds.height\n                +try_bounds.width*try_bounds.height\n              < bounds[i-1].width*bounds[i-1].height\n                  +dup_bounds.width*dup_bounds.height\n                  +bounds[i].width*bounds[i].height )\n          {\n            cleared=MagickFalse;\n            bounds[i-1]=bgnd_bounds;\n            bounds[i]=try_bounds;\n            if ( disposals[i-1] == DupDispose )\n              dup_image=DestroyImage(dup_image);\n            disposals[i-1]=BackgroundDispose;\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr,\"expand_bgnd: accepted\\n\");\n          } else {\n    (void) FormatLocaleFile(stderr,\"expand_bgnd: reject\\n\");\n#endif\n          }\n      }\n    /*\n       Finalise choice of dispose, set new prev_image,\n       and junk any extra images as appropriate,\n    */\n    if ( disposals[i-1] == DupDispose )\n      {\n         if (bgnd_image != (Image *) NULL)\n           bgnd_image=DestroyImage(bgnd_image);\n         prev_image=DestroyImage(prev_image);\n         prev_image=dup_image, dup_image=(Image *) NULL;\n         bounds[i+1]=bounds[i];\n         bounds[i]=dup_bounds;\n         disposals[i-1]=DupDispose;\n         disposals[i]=BackgroundDispose;\n         i++;\n      }\n    else\n      {\n        if ( dup_image != (Image *) NULL)\n          dup_image=DestroyImage(dup_image);\n        if ( disposals[i-1] != PreviousDispose )\n          prev_image=DestroyImage(prev_image);\n        if ( disposals[i-1] == BackgroundDispose )\n          prev_image=bgnd_image, bgnd_image=(Image *) NULL;\n        if (bgnd_image != (Image *) NULL)\n          bgnd_image=DestroyImage(bgnd_image);\n        if ( disposals[i-1] == NoneDispose )\n          {\n            prev_image=ReferenceImage(curr->previous);\n            if (prev_image == (Image *) NULL)\n              {\n                bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n                disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n                return((Image *) NULL);\n              }\n          }\n\n      }\n    assert(prev_image != (Image *) NULL);\n    disposals[i]=disposals[i-1];\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"final   %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) i-1,\n         CommandOptionToMnemonic(MagickDisposeOptions,disposals[i-1]),\n         (double) bounds[i-1].width,(double) bounds[i-1].height,\n         (double) bounds[i-1].x,(double) bounds[i-1].y );\n#endif\n#if DEBUG_OPT_FRAME\n    (void) FormatLocaleFile(stderr, \"interum %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) i,\n         CommandOptionToMnemonic(MagickDisposeOptions,disposals[i]),\n         (double) bounds[i].width,(double) bounds[i].height,\n         (double) bounds[i].x,(double) bounds[i].y );\n    (void) FormatLocaleFile(stderr,\"\\n\");\n#endif\n    i++;\n  }\n  prev_image=DestroyImage(prev_image);\n  /*\n    Optimize all images in sequence.\n  */\n  sans_exception=AcquireExceptionInfo();\n  i=0;\n  curr=GetFirstImageInList(image);\n  optimized_image=NewImageList();\n  while ( curr != (const Image *) NULL )\n  {\n    prev_image=CloneImage(curr,0,0,MagickTrue,exception);\n    if (prev_image == (Image *) NULL)\n      break;\n    prev_image->background_color.alpha_trait=BlendPixelTrait;\n    if ( disposals[i] == DelDispose ) {\n      size_t time = 0;\n      while ( disposals[i] == DelDispose ) {\n        time +=(size_t) (curr->delay*1000*\n          PerceptibleReciprocal((double) curr->ticks_per_second));\n        curr=GetNextImageInList(curr);\n        i++;\n      }\n      time += (size_t)(curr->delay*1000*\n        PerceptibleReciprocal((double) curr->ticks_per_second));\n      prev_image->ticks_per_second = 100L;\n      prev_image->delay = time*prev_image->ticks_per_second/1000;\n    }\n    bgnd_image=CropImage(prev_image,&bounds[i],sans_exception);\n    prev_image=DestroyImage(prev_image);\n    if (bgnd_image == (Image *) NULL)\n      break;\n    bgnd_image->dispose=disposals[i];\n    if ( disposals[i] == DupDispose ) {\n      bgnd_image->delay=0;\n      bgnd_image->dispose=NoneDispose;\n    }\n    else\n      curr=GetNextImageInList(curr);\n    AppendImageToList(&optimized_image,bgnd_image);\n    i++;\n  }\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n  disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n  if (curr != (Image *) NULL)\n    {\n      optimized_image=DestroyImageList(optimized_image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(optimized_image));\n}",
  "abstract_func": "static Image *OptimizeLayerFrames(const Image *VAR_0,const LayerMethod VAR_1,\n  ExceptionInfo *VAR_2)\n{\n  ExceptionInfo\n    *VAR_3;\n\n  Image\n    *VAR_4,\n    *VAR_5,\n    *VAR_6,\n    *VAR_7;\n\n  RectangleInfo\n    VAR_8,\n    VAR_9,\n    VAR_10,\n    *VAR_11;\n\n  MagickBooleanType\n    VAR_12,\n    VAR_13,\n    VAR_14;\n\n  DisposeType\n    *VAR_15;\n\n  register const Image\n    *VAR_16;\n\n  register ssize_t\n    VAR_17;\n\n  assert(VAR_0 != (const Image *) NULL);\n  assert(VAR_0->signature == VAR_18);\n  if (VAR_0->debug != VAR_19)\n    (void) LogMagickEvent(VAR_20,GetMagickModule(),\"%s\",VAR_0->filename);\n  assert(VAR_2 != (ExceptionInfo *) NULL);\n  assert(VAR_2->signature == VAR_18);\n  assert(VAR_1 == VAR_21 ||\n         VAR_1 == VAR_22 ||\n         VAR_1 == VAR_23);\n  /* COMMENT_0 */\n                                                       \n    \n  VAR_12=VAR_1 == VAR_23 ? VAR_24 : VAR_19;\n  /* COMMENT_3 */\n                                             \n    \n  VAR_16=GetFirstImageInList(VAR_0);\n  for (; VAR_16 != (Image *) NULL; VAR_16=GetNextImageInList(VAR_16))\n  {\n    if ((VAR_16->columns != VAR_0->columns) || (VAR_16->rows != VAR_0->rows))\n      ThrowImageException(VAR_25,\"ImagesAreNotTheSameSize\");\n\n    if ((VAR_16->page.x != 0) || (VAR_16->page.y != 0) ||\n        (VAR_16->page.width != VAR_0->page.width) ||\n        (VAR_16->page.height != VAR_0->page.height))\n      ThrowImageException(VAR_25,\"ImagePagesAreNotCoalesced\");\n  }\n  /* COMMENT_6 */\n                                                                       \n    \n  VAR_16=GetFirstImageInList(VAR_0);\n  VAR_11=(RectangleInfo *) AcquireQuantumMemory((size_t)\n    GetImageListLength(VAR_16),(VAR_12 != VAR_19 ? 2UL : 1UL)*\n    sizeof(*VAR_11));\n  if (VAR_11 == (RectangleInfo *) NULL)\n    ThrowImageException(VAR_26,\"MemoryAllocationFailed\");\n  VAR_15=(DisposeType *) AcquireQuantumMemory((size_t)\n    GetImageListLength(VAR_0),(VAR_12 != VAR_19 ? 2UL : 1UL)*\n    sizeof(*VAR_15));\n  if (VAR_15 == (DisposeType *) NULL)\n    {\n      VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n      ThrowImageException(VAR_26,\"MemoryAllocationFailed\");\n    }\n  /* COMMENT_9 */\n                                                  \n    \n  VAR_4=CloneImage(VAR_16,VAR_16->columns,VAR_16->rows,VAR_24,VAR_2);\n  if (VAR_4 == (Image *) NULL)\n    {\n      VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n      VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n      return((Image *) NULL);\n    }\n  VAR_4->page=VAR_16->page;  /* COMMENT_12 */\n  VAR_4->page.x=0;\n  VAR_4->page.y=0;\n  VAR_4->dispose=VAR_27;\n  VAR_4->background_color.alpha_trait=VAR_28;\n  VAR_4->background_color.alpha=(MagickRealType) VAR_29;\n  (void) SetImageBackgroundColor(VAR_4,VAR_2);\n  /* COMMENT_13 */\n                                                     \n                                                                \n    \n#if VAR_30\n  VAR_17=0;\n  (void) FormatLocaleFile(VAR_31,\"frame %.20g :-\\n\",(double) VAR_17);\n#endif\n  VAR_15[0]=VAR_27;\n  VAR_11[0]=CompareImagesBounds(VAR_4,VAR_16,VAR_32,VAR_2);\n#if VAR_30\n  (void) FormatLocaleFile(VAR_31, \"overlay: %.20gx%.20g%+.20g%+.20g\\n\\n\",\n    (double) VAR_11[VAR_17].width,(double) VAR_11[VAR_17].height,\n    (double) VAR_11[VAR_17].x,(double) VAR_11[VAR_17].y );\n#endif\n  /* COMMENT_17 */\n                                                                \n    \n  VAR_17=1;\n  VAR_6=(Image *) NULL;\n  VAR_5=(Image *) NULL;\n  VAR_10.width=0;\n  VAR_10.height=0;\n  VAR_10.x=0;\n  VAR_10.y=0;\n  VAR_16=GetNextImageInList(VAR_16);\n  for ( ; VAR_16 != (const Image *) NULL; VAR_16=GetNextImageInList(VAR_16))\n  {\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31,\"frame %.20g :-\\n\",(double) VAR_17);\n#endif\n    /* COMMENT_20 */\n                                      \n      \n    VAR_11[VAR_17]=CompareImagesBounds(VAR_16->previous,VAR_16,VAR_32,VAR_2);\n    VAR_14=IsBoundsCleared(VAR_16->previous,VAR_16,&VAR_11[VAR_17],VAR_2);\n    VAR_15[VAR_17-1]=VAR_27;\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"overlay: %.20gx%.20g%+.20g%+.20g%s%s\\n\",\n         (double) VAR_11[VAR_17].width,(double) VAR_11[VAR_17].height,\n         (double) VAR_11[VAR_17].x,(double) VAR_11[VAR_17].y,\n         VAR_11[VAR_17].x < 0?\"  (unchanged)\":\"\",\n         VAR_14?\"  (pixels cleared)\":\"\");\n#endif\n    if ( VAR_11[VAR_17].x < 0 ) {\n      /* COMMENT_23 */\n                                                              \n                                                                         \n                                                                              \n                             \n        \n      if ( VAR_12 && VAR_17>=2 ) {\n        VAR_15[VAR_17-1]=VAR_33;\n        VAR_15[VAR_17]=VAR_27;\n        VAR_11[VAR_17]=VAR_11[VAR_17-1];\n        VAR_17++;\n        continue;\n      }\n    }\n    else\n      {\n        /* COMMENT_29 */\n                                                             \n          \n        VAR_8=CompareImagesBounds(VAR_4,VAR_16,VAR_32,VAR_2);\n        VAR_13=IsBoundsCleared(VAR_4,VAR_16,&VAR_8,VAR_2);\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"test_prev: %.20gx%.20g%+.20g%+.20g%s\\n\",\n         (double) VAR_8.width,(double) VAR_8.height,\n         (double) VAR_8.x,(double) VAR_8.y,\n         VAR_13?\"  (pixels were cleared)\":\"\");\n#endif\n        if ( (!VAR_13 && VAR_14 ) ||\n                VAR_8.width * VAR_8.height\n                    <  VAR_11[VAR_17].width * VAR_11[VAR_17].height )\n          {\n            VAR_14=VAR_13;\n            VAR_11[VAR_17]=VAR_8;\n            VAR_15[VAR_17-1]=VAR_34;\n#if VAR_30\n            (void) FormatLocaleFile(VAR_31,\"previous: accepted\\n\");\n          } else {\n            (void) FormatLocaleFile(VAR_31,\"previous: rejected\\n\");\n#endif\n          }\n\n        /* COMMENT_32 */\n                                                                 \n                                                                              \n                                                                               \n          \n        VAR_10.width=VAR_10.height=0; /* COMMENT_37 */\n        if ( VAR_12 )\n          {\n            VAR_5=CloneImage(VAR_16->previous,0,0,VAR_24,VAR_2);\n            if (VAR_5 == (Image *) NULL)\n              {\n                VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n                VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n                VAR_4=DestroyImage(VAR_4);\n                return((Image *) NULL);\n              }\n            VAR_5->background_color.alpha_trait=VAR_28;\n            VAR_10=CompareImagesBounds(VAR_5,VAR_16,VAR_35,VAR_2);\n            ClearBounds(VAR_5,&VAR_10,VAR_2);\n            VAR_8=CompareImagesBounds(VAR_5,VAR_16,VAR_32,VAR_2);\n            if ( VAR_14 ||\n                   VAR_10.width*VAR_10.height\n                      +VAR_8.width*VAR_8.height\n                   < VAR_11[VAR_17].width * VAR_11[VAR_17].height )\n              {\n                VAR_14=VAR_19;\n                VAR_11[VAR_17]=VAR_8;\n                VAR_15[VAR_17-1]=VAR_36;\n                /* COMMENT_38 */\n              }\n            else\n              VAR_10.width=VAR_10.height=0;\n          }\n        /* COMMENT_39 */\n                                                          \n          \n        VAR_6=CloneImage(VAR_16->previous,0,0,VAR_24,VAR_2);\n        if (VAR_6 == (Image *) NULL)\n          {\n            VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n            VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n            VAR_4=DestroyImage(VAR_4);\n            if ( VAR_5 != (Image *) NULL)\n              VAR_5=DestroyImage(VAR_5);\n            return((Image *) NULL);\n          }\n        VAR_6->background_color.alpha_trait=VAR_28;\n        VAR_9=VAR_11[VAR_17-1]; /* COMMENT_42 */\n        ClearBounds(VAR_6,&VAR_9,VAR_2);\n        VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_32,VAR_2);\n        VAR_13=IsBoundsCleared(VAR_6,VAR_16,&VAR_8,VAR_2);\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"background: %s\\n\",\n         VAR_13?\"(pixels cleared)\":\"\");\n#endif\n        if ( VAR_13 )\n          {\n            /* COMMENT_43 */\n                                                                         \n                                                                            \n                                                                   \n                                                                     \n              \n            VAR_8=CompareImagesBounds(VAR_16->previous,VAR_16,VAR_35,VAR_2);\n#if VAR_30\n            (void) FormatLocaleFile(VAR_31, \"expand_clear: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y,\n                VAR_8.x<0?\"  (no expand nessary)\":\"\");\n#endif\n            if ( VAR_9.x < 0 )\n              VAR_9 = VAR_8;\n            else\n              {\n#if VAR_30\n                (void) FormatLocaleFile(VAR_31, \"expand_bgnd: %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) VAR_9.width,(double) VAR_9.height,\n                    (double) VAR_9.x,(double) VAR_9.y );\n#endif\n                if ( VAR_8.x < VAR_9.x )\n                  {\n                     VAR_9.width+= VAR_9.x-VAR_8.x;\n                     if ( VAR_9.width < VAR_8.width )\n                       VAR_9.width = VAR_8.width;\n                     VAR_9.x = VAR_8.x;\n                  }\n                else\n                  {\n                     VAR_8.width += VAR_8.x - VAR_9.x;\n                     if ( VAR_9.width < VAR_8.width )\n                       VAR_9.width = VAR_8.width;\n                  }\n                if ( VAR_8.y < VAR_9.y )\n                  {\n                     VAR_9.height += VAR_9.y - VAR_8.y;\n                     if ( VAR_9.height < VAR_8.height )\n                       VAR_9.height = VAR_8.height;\n                     VAR_9.y = VAR_8.y;\n                  }\n                else\n                  {\n                    VAR_8.height += VAR_8.y - VAR_9.y;\n                     if ( VAR_9.height < VAR_8.height )\n                       VAR_9.height = VAR_8.height;\n                  }\n#if VAR_30\n                (void) FormatLocaleFile(VAR_31, \"        to : %.20gx%.20g%+.20g%+.20g\\n\",\n                    (double) VAR_9.width,(double) VAR_9.height,\n                    (double) VAR_9.x,(double) VAR_9.y );\n#endif\n              }\n            ClearBounds(VAR_6,&VAR_9,VAR_2);\n#if VAR_30\n/* COMMENT_49 */\n                                                                            \n                                                                       \n                                                                             \n                                                                             \n                                                           \n   \n            VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_35,VAR_2);\n            (void) FormatLocaleFile(VAR_31, \"expand_ctst: %.20gx%.20g%+.20g%+.20g\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y );\n            VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_32,VAR_2);\n            VAR_13=IsBoundsCleared(VAR_6,VAR_16,&VAR_8,VAR_2);\n            (void) FormatLocaleFile(VAR_31, \"expand_any : %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y,\n                VAR_13?\"   (pixels cleared)\":\"\");\n#endif\n            VAR_8=CompareImagesBounds(VAR_6,VAR_16,VAR_37,VAR_2);\n#if VAR_30\n            VAR_13=IsBoundsCleared(VAR_6,VAR_16,&VAR_8,VAR_2);\n            (void) FormatLocaleFile(VAR_31, \"expand_test: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                (double) VAR_8.width,(double) VAR_8.height,\n                (double) VAR_8.x,(double) VAR_8.y,\n                VAR_13?\"   (pixels cleared)\":\"\");\n#endif\n          }\n        /* COMMENT_56 */\n                                                                    \n                                                                         \n          \n        if ( VAR_14 ||\n              VAR_9.width*VAR_9.height\n                +VAR_8.width*VAR_8.height\n              < VAR_11[VAR_17-1].width*VAR_11[VAR_17-1].height\n                  +VAR_10.width*VAR_10.height\n                  +VAR_11[VAR_17].width*VAR_11[VAR_17].height )\n          {\n            VAR_14=VAR_19;\n            VAR_11[VAR_17-1]=VAR_9;\n            VAR_11[VAR_17]=VAR_8;\n            if ( VAR_15[VAR_17-1] == VAR_36 )\n              VAR_5=DestroyImage(VAR_5);\n            VAR_15[VAR_17-1]=VAR_38;\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31,\"expand_bgnd: accepted\\n\");\n          } else {\n    (void) FormatLocaleFile(VAR_31,\"expand_bgnd: reject\\n\");\n#endif\n          }\n      }\n    /* COMMENT_60 */\n                                                      \n                                                \n      \n    if ( VAR_15[VAR_17-1] == VAR_36 )\n      {\n         if (VAR_6 != (Image *) NULL)\n           VAR_6=DestroyImage(VAR_6);\n         VAR_4=DestroyImage(VAR_4);\n         VAR_4=VAR_5, VAR_5=(Image *) NULL;\n         VAR_11[VAR_17+1]=VAR_11[VAR_17];\n         VAR_11[VAR_17]=VAR_10;\n         VAR_15[VAR_17-1]=VAR_36;\n         VAR_15[VAR_17]=VAR_38;\n         VAR_17++;\n      }\n    else\n      {\n        if ( VAR_5 != (Image *) NULL)\n          VAR_5=DestroyImage(VAR_5);\n        if ( VAR_15[VAR_17-1] != VAR_34 )\n          VAR_4=DestroyImage(VAR_4);\n        if ( VAR_15[VAR_17-1] == VAR_38 )\n          VAR_4=VAR_6, VAR_6=(Image *) NULL;\n        if (VAR_6 != (Image *) NULL)\n          VAR_6=DestroyImage(VAR_6);\n        if ( VAR_15[VAR_17-1] == VAR_27 )\n          {\n            VAR_4=ReferenceImage(VAR_16->previous);\n            if (VAR_4 == (Image *) NULL)\n              {\n                VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n                VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n                return((Image *) NULL);\n              }\n          }\n\n      }\n    assert(VAR_4 != (Image *) NULL);\n    VAR_15[VAR_17]=VAR_15[VAR_17-1];\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"final   %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) VAR_17-1,\n         CommandOptionToMnemonic(VAR_39,VAR_15[VAR_17-1]),\n         (double) VAR_11[VAR_17-1].width,(double) VAR_11[VAR_17-1].height,\n         (double) VAR_11[VAR_17-1].x,(double) VAR_11[VAR_17-1].y );\n#endif\n#if VAR_30\n    (void) FormatLocaleFile(VAR_31, \"interum %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n         (double) VAR_17,\n         CommandOptionToMnemonic(VAR_39,VAR_15[VAR_17]),\n         (double) VAR_11[VAR_17].width,(double) VAR_11[VAR_17].height,\n         (double) VAR_11[VAR_17].x,(double) VAR_11[VAR_17].y );\n    (void) FormatLocaleFile(VAR_31,\"\\n\");\n#endif\n    VAR_17++;\n  }\n  VAR_4=DestroyImage(VAR_4);\n  /* COMMENT_64 */\n                                    \n    \n  VAR_3=AcquireExceptionInfo();\n  VAR_17=0;\n  VAR_16=GetFirstImageInList(VAR_0);\n  VAR_7=NewImageList();\n  while ( VAR_16 != (const Image *) NULL )\n  {\n    VAR_4=CloneImage(VAR_16,0,0,VAR_24,VAR_2);\n    if (VAR_4 == (Image *) NULL)\n      break;\n    VAR_4->background_color.alpha_trait=VAR_28;\n    if ( VAR_15[VAR_17] == VAR_33 ) {\n      size_t VAR_40 = 0;\n      while ( VAR_15[VAR_17] == VAR_33 ) {\n        VAR_40 +=(size_t) (VAR_16->delay*1000*\n          PerceptibleReciprocal((double) VAR_16->ticks_per_second));\n        VAR_16=GetNextImageInList(VAR_16);\n        VAR_17++;\n      }\n      VAR_40 += (size_t)(VAR_16->delay*1000*\n        PerceptibleReciprocal((double) VAR_16->ticks_per_second));\n      VAR_4->ticks_per_second = 100L;\n      VAR_4->delay = VAR_40*VAR_4->ticks_per_second/1000;\n    }\n    VAR_6=CropImage(VAR_4,&VAR_11[VAR_17],VAR_3);\n    VAR_4=DestroyImage(VAR_4);\n    if (VAR_6 == (Image *) NULL)\n      break;\n    VAR_6->dispose=VAR_15[VAR_17];\n    if ( VAR_15[VAR_17] == VAR_36 ) {\n      VAR_6->delay=0;\n      VAR_6->dispose=VAR_27;\n    }\n    else\n      VAR_16=GetNextImageInList(VAR_16);\n    AppendImageToList(&VAR_7,VAR_6);\n    VAR_17++;\n  }\n  VAR_3=DestroyExceptionInfo(VAR_3);\n  VAR_11=(RectangleInfo *) RelinquishMagickMemory(VAR_11);\n  VAR_15=(DisposeType *) RelinquishMagickMemory(VAR_15);\n  if (VAR_16 != (Image *) NULL)\n    {\n      VAR_7=DestroyImageList(VAR_7);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(VAR_7));\n}",
  "func_graph_path": "ImageMagick/ef59bd764f88d893f1219fee8ba696a5d3f8c1c4/layer.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -415,11 +415,13 @@\n     if ( disposals[i] == DelDispose ) {\n       size_t time = 0;\n       while ( disposals[i] == DelDispose ) {\n-        time += curr->delay*1000/curr->ticks_per_second;\n+        time +=(size_t) (curr->delay*1000*\n+          PerceptibleReciprocal((double) curr->ticks_per_second));\n         curr=GetNextImageInList(curr);\n         i++;\n       }\n-      time += curr->delay*1000/curr->ticks_per_second;\n+      time += (size_t)(curr->delay*1000*\n+        PerceptibleReciprocal((double) curr->ticks_per_second));\n       prev_image->ticks_per_second = 100L;\n       prev_image->delay = time*prev_image->ticks_per_second/1000;\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "        time += curr->delay*1000/curr->ticks_per_second;",
      "      time += curr->delay*1000/curr->ticks_per_second;"
    ],
    "added_lines": [
      "        time +=(size_t) (curr->delay*1000*",
      "          PerceptibleReciprocal((double) curr->ticks_per_second));",
      "      time += (size_t)(curr->delay*1000*",
      "        PerceptibleReciprocal((double) curr->ticks_per_second));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ImageMagick/ImageMagick/pull/2743",
  "description": {
    "pr_info": {
      "title": "There is a Division by Zero in function OptimizeLayerFrames",
      "number": 2743
    },
    "comment": [
      "There is a Division by Zero in function OptimizeLayerFrames\r\nin file MagickCore/layer.c. cur->ticks_per_seconds can be zero\r\nwith a crafted input argument *image. This is similar to\r\nCVE-2019-13454.\r\n\r\n### Prerequisites\r\n\r\n- [ ] I have written a descriptive pull-request title\r\n- [ ] I have verified that there are no overlapping [pull-requests](https://github.com/ImageMagick/ImageMagick/pulls) open\r\n- [ ] I have verified that I am following the existing coding patterns and practices as demonstrated in the repository.\r\n\r\n### Description\r\n<!-- A description of the changes proposed in the pull-request\r\n     If you want to change something in the 'www' or 'ImageMagick' folder please\r\n     open an issue here instead: https://github.com/ImageMagick/Website -->\r\n\r\n<!-- Thanks for contributing to ImageMagick! -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a division by zero vulnerability, referenced by CVE-2019-13454. The code changes use PerceptibleReciprocal to safely handle division, confirming it's a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}