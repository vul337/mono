{
  "cve_id": "CVE-2023-49464",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "strukturag/libheif",
  "commit_msg": "uncompressed: protect against broken uncC box component references",
  "commit_hash": "2bf226a300951e6897ee7267d0dd379ba5ad7287",
  "git_url": "https://github.com/strukturag/libheif/commit/2bf226a300951e6897ee7267d0dd379ba5ad7287",
  "file_path": "libheif/uncompressed_image.cc",
  "func_name": "UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci",
  "func_before": "int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(const HeifFile& heif_file, heif_item_id imageID)\n{\n  auto ipco = heif_file.get_ipco_box();\n  auto ipma = heif_file.get_ipma_box();\n\n  auto box1 = ipco->get_property_for_item_ID(imageID, ipma, fourcc(\"uncC\"));\n  std::shared_ptr<Box_uncC> uncC_box = std::dynamic_pointer_cast<Box_uncC>(box1);\n  auto box2 = ipco->get_property_for_item_ID(imageID, ipma, fourcc(\"cmpd\"));\n  std::shared_ptr<Box_cmpd> cmpd_box = std::dynamic_pointer_cast<Box_cmpd>(box2);\n  if (!uncC_box || !cmpd_box) {\n    return -1;\n  }\n\n  int luma_bits = 0;\n  int alternate_channel_bits = 0;\n  for (Box_uncC::Component component : uncC_box->get_components()) {\n    uint16_t component_index = component.component_index;\n    auto component_type = cmpd_box->get_components()[component_index].component_type;\n    switch (component_type) {\n      case component_type_monochrome:\n      case component_type_red:\n      case component_type_green:\n      case component_type_blue:\n        alternate_channel_bits = std::max(alternate_channel_bits, (int)component.component_bit_depth);\n        break;\n      case component_type_Y:\n        luma_bits = std::max(luma_bits, (int)component.component_bit_depth);\n        break;\n        // TODO: there are other things we'll need to handle eventually, like palette.\n    }\n  }\n  if (luma_bits > 0) {\n    return luma_bits;\n  }\n  else if (alternate_channel_bits > 0) {\n    return alternate_channel_bits;\n  }\n  else {\n    return 8;\n  }\n}",
  "abstract_func_before": "int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(const HeifFile& VAR_0, heif_item_id VAR_1)\n{\n  auto VAR_2 = VAR_0.get_ipco_box();\n  auto VAR_3 = VAR_0.get_ipma_box();\n\n  auto VAR_4 = VAR_2->get_property_for_item_ID(VAR_1, VAR_3, fourcc(\"uncC\"));\n  std::shared_ptr<Box_uncC> VAR_5 = std::VAR_6<Box_uncC>(VAR_4);\n  auto VAR_7 = VAR_2->get_property_for_item_ID(VAR_1, VAR_3, fourcc(\"cmpd\"));\n  std::shared_ptr<Box_cmpd> VAR_8 = std::VAR_6<Box_cmpd>(VAR_7);\n  if (!VAR_5 || !VAR_8) {\n    return -1;\n  }\n\n  int VAR_9 = 0;\n  int VAR_10 = 0;\n  for (Box_uncC::Component VAR_11 : VAR_5->get_components()) {\n    uint16_t VAR_12 = VAR_11.component_index;\n    auto VAR_13 = VAR_8->get_components()[VAR_12].component_type;\n    switch (VAR_13) {\n      case VAR_14:\n      case VAR_15:\n      case VAR_16:\n      case VAR_17:\n        VAR_10 = std::max(VAR_10, (int)VAR_11.component_bit_depth);\n        break;\n      case VAR_18:\n        VAR_9 = std::max(VAR_9, (int)VAR_11.component_bit_depth);\n        break;\n        /* COMMENT_0 */\n    }\n  }\n  if (VAR_9 > 0) {\n    return VAR_9;\n  }\n  else if (VAR_10 > 0) {\n    return VAR_10;\n  }\n  else {\n    return 8;\n  }\n}",
  "func_graph_path_before": "strukturag/libheif/2bf226a300951e6897ee7267d0dd379ba5ad7287/uncompressed_image.cc/vul/before/0.json",
  "func": "int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(const HeifFile& heif_file, heif_item_id imageID)\n{\n  auto ipco = heif_file.get_ipco_box();\n  auto ipma = heif_file.get_ipma_box();\n\n  auto box1 = ipco->get_property_for_item_ID(imageID, ipma, fourcc(\"uncC\"));\n  std::shared_ptr<Box_uncC> uncC_box = std::dynamic_pointer_cast<Box_uncC>(box1);\n  auto box2 = ipco->get_property_for_item_ID(imageID, ipma, fourcc(\"cmpd\"));\n  std::shared_ptr<Box_cmpd> cmpd_box = std::dynamic_pointer_cast<Box_cmpd>(box2);\n  if (!uncC_box || !cmpd_box) {\n    return -1;\n  }\n\n  int luma_bits = 0;\n  int alternate_channel_bits = 0;\n  for (Box_uncC::Component component : uncC_box->get_components()) {\n    uint16_t component_index = component.component_index;\n    if (component_index >= cmpd_box->get_components().size()) {\n      return -1;\n    }\n    auto component_type = cmpd_box->get_components()[component_index].component_type;\n    switch (component_type) {\n      case component_type_monochrome:\n      case component_type_red:\n      case component_type_green:\n      case component_type_blue:\n        alternate_channel_bits = std::max(alternate_channel_bits, (int)component.component_bit_depth);\n        break;\n      case component_type_Y:\n        luma_bits = std::max(luma_bits, (int)component.component_bit_depth);\n        break;\n        // TODO: there are other things we'll need to handle eventually, like palette.\n    }\n  }\n  if (luma_bits > 0) {\n    return luma_bits;\n  }\n  else if (alternate_channel_bits > 0) {\n    return alternate_channel_bits;\n  }\n  else {\n    return 8;\n  }\n}",
  "abstract_func": "int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(const HeifFile& VAR_0, heif_item_id VAR_1)\n{\n  auto VAR_2 = VAR_0.get_ipco_box();\n  auto VAR_3 = VAR_0.get_ipma_box();\n\n  auto VAR_4 = VAR_2->get_property_for_item_ID(VAR_1, VAR_3, fourcc(\"uncC\"));\n  std::shared_ptr<Box_uncC> VAR_5 = std::VAR_6<Box_uncC>(VAR_4);\n  auto VAR_7 = VAR_2->get_property_for_item_ID(VAR_1, VAR_3, fourcc(\"cmpd\"));\n  std::shared_ptr<Box_cmpd> VAR_8 = std::VAR_6<Box_cmpd>(VAR_7);\n  if (!VAR_5 || !VAR_8) {\n    return -1;\n  }\n\n  int VAR_9 = 0;\n  int VAR_10 = 0;\n  for (Box_uncC::Component VAR_11 : VAR_5->get_components()) {\n    uint16_t VAR_12 = VAR_11.component_index;\n    if (VAR_12 >= VAR_8->get_components().size()) {\n      return -1;\n    }\n    auto VAR_13 = VAR_8->get_components()[VAR_12].component_type;\n    switch (VAR_13) {\n      case VAR_14:\n      case VAR_15:\n      case VAR_16:\n      case VAR_17:\n        VAR_10 = std::max(VAR_10, (int)VAR_11.component_bit_depth);\n        break;\n      case VAR_18:\n        VAR_9 = std::max(VAR_9, (int)VAR_11.component_bit_depth);\n        break;\n        /* COMMENT_0 */\n    }\n  }\n  if (VAR_9 > 0) {\n    return VAR_9;\n  }\n  else if (VAR_10 > 0) {\n    return VAR_10;\n  }\n  else {\n    return 8;\n  }\n}",
  "func_graph_path": "strukturag/libheif/2bf226a300951e6897ee7267d0dd379ba5ad7287/uncompressed_image.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,9 @@\n   int alternate_channel_bits = 0;\n   for (Box_uncC::Component component : uncC_box->get_components()) {\n     uint16_t component_index = component.component_index;\n+    if (component_index >= cmpd_box->get_components().size()) {\n+      return -1;\n+    }\n     auto component_type = cmpd_box->get_components()[component_index].component_type;\n     switch (component_type) {\n       case component_type_monochrome:",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (component_index >= cmpd_box->get_components().size()) {",
      "      return -1;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/strukturag/libheif/pull/1049",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/strukturag/libheif/pull/1049: 403 Client Error: Forbidden for url: https://api.github.com/repos/strukturag/libheif/pulls/1049",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix  \nConfidence: 0.9"
}