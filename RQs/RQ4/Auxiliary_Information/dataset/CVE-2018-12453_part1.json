{
  "cve_id": "CVE-2018-12453",
  "cwe_ids": [
    "CWE-704"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Abort in XGROUP if the key is not a stream",
  "commit_hash": "c04082cf138f1f51cedf05ee9ad36fb6763cafc6",
  "git_url": "https://github.com/redis/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6",
  "file_path": "src/t_stream.c",
  "func_name": "xgroupCommand",
  "func_before": "void xgroupCommand(client *c) {\n    const char *help[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    if (c->argc >= 4) {\n        robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n        if (o == NULL) return;\n        s = o->ptr;\n        grpname = c->argv[3]->ptr;\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CREATE\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n        } else {\n            addReplySds(c,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        /* Delete the consumer and returns the number of pending messages\n         * that were yet associated with such a consumer. */\n        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);\n        addReplyLongLong(c,pending);\n        server.dirty++;\n    } else if (!strcasecmp(opt,\"HELP\")) {\n        addReplyHelp(c, help);\n    } else {\n        addReply(c,shared.syntaxerr);\n    }\n}",
  "abstract_func_before": "void xgroupCommand(client *VAR_0) {\n    const char *VAR_1[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *VAR_2 = NULL;\n    sds VAR_3 = NULL;\n    streamCG *VAR_4 = NULL;\n    char *VAR_5 = VAR_0->argv[1]->ptr; /* COMMENT_0 */\n\n    /* COMMENT_1 */\n    if (VAR_0->argc >= 4) {\n        robj *VAR_6 = lookupKeyWriteOrReply(VAR_0,VAR_0->argv[2],VAR_7.nokeyerr);\n        if (VAR_6 == NULL) return;\n        VAR_2 = VAR_6->ptr;\n        VAR_3 = VAR_0->argv[3]->ptr;\n\n        /* COMMENT_2 */\n        if ((VAR_4 = streamLookupCG(VAR_2,VAR_3)) == NULL &&\n            (!strcasecmp(VAR_5,\"SETID\") ||\n             !strcasecmp(VAR_5,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(VAR_0, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)VAR_3, (char*)VAR_0->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* COMMENT_3 */\n    if (!strcasecmp(VAR_5,\"CREATE\") && VAR_0->argc == 5) {\n        streamID VAR_8;\n        if (!strcmp(VAR_0->argv[4]->ptr,\"$\")) {\n            VAR_8 = VAR_2->last_id;\n        } else if (streamParseIDOrReply(VAR_0,VAR_0->argv[4],&VAR_8,0) != VAR_9) {\n            return;\n        }\n        streamCG *VAR_4 = streamCreateCG(VAR_2,VAR_3,sdslen(VAR_3),&VAR_8);\n        if (VAR_4) {\n            addReply(VAR_0,VAR_7.ok);\n            VAR_10.dirty++;\n        } else {\n            addReplySds(VAR_0,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(VAR_5,\"SETID\") && VAR_0->argc == 5) {\n        streamID VAR_8;\n        if (!strcmp(VAR_0->argv[4]->ptr,\"$\")) {\n            VAR_8 = VAR_2->last_id;\n        } else if (streamParseIDOrReply(VAR_0,VAR_0->argv[4],&VAR_8,0) != VAR_9) {\n            return;\n        }\n        VAR_4->last_id = VAR_8;\n        addReply(VAR_0,VAR_7.ok);\n    } else if (!strcasecmp(VAR_5,\"DESTROY\") && VAR_0->argc == 4) {\n        if (VAR_4) {\n            raxRemove(VAR_2->cgroups,(unsigned char*)VAR_3,sdslen(VAR_3),NULL);\n            streamFreeCG(VAR_4);\n            addReply(VAR_0,VAR_7.cone);\n        } else {\n            addReply(VAR_0,VAR_7.czero);\n        }\n    } else if (!strcasecmp(VAR_5,\"DELCONSUMER\") && VAR_0->argc == 5) {\n        /* COMMENT_4 */\n                                                            \n        long long VAR_11 = streamDelConsumer(VAR_4,VAR_0->argv[4]->ptr);\n        addReplyLongLong(VAR_0,VAR_11);\n        VAR_10.dirty++;\n    } else if (!strcasecmp(VAR_5,\"HELP\")) {\n        addReplyHelp(VAR_0, VAR_1);\n    } else {\n        addReply(VAR_0,VAR_7.syntaxerr);\n    }\n}",
  "func_graph_path_before": "redis/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/t_stream.c/vul/before/0.json",
  "func": "void xgroupCommand(client *c) {\n    const char *help[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    if (c->argc >= 4) {\n        robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n        s = o->ptr;\n        grpname = c->argv[3]->ptr;\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CREATE\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n        } else {\n            addReplySds(c,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        /* Delete the consumer and returns the number of pending messages\n         * that were yet associated with such a consumer. */\n        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);\n        addReplyLongLong(c,pending);\n        server.dirty++;\n    } else if (!strcasecmp(opt,\"HELP\")) {\n        addReplyHelp(c, help);\n    } else {\n        addReply(c,shared.syntaxerr);\n    }\n}",
  "abstract_func": "void xgroupCommand(client *VAR_0) {\n    const char *VAR_1[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *VAR_2 = NULL;\n    sds VAR_3 = NULL;\n    streamCG *VAR_4 = NULL;\n    char *VAR_5 = VAR_0->argv[1]->ptr; /* COMMENT_0 */\n\n    /* COMMENT_1 */\n    if (VAR_0->argc >= 4) {\n        robj *VAR_6 = lookupKeyWriteOrReply(VAR_0,VAR_0->argv[2],VAR_7.nokeyerr);\n        if (VAR_6 == NULL || checkType(VAR_0,VAR_6,VAR_8)) return;\n        VAR_2 = VAR_6->ptr;\n        VAR_3 = VAR_0->argv[3]->ptr;\n\n        /* COMMENT_2 */\n        if ((VAR_4 = streamLookupCG(VAR_2,VAR_3)) == NULL &&\n            (!strcasecmp(VAR_5,\"SETID\") ||\n             !strcasecmp(VAR_5,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(VAR_0, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)VAR_3, (char*)VAR_0->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* COMMENT_3 */\n    if (!strcasecmp(VAR_5,\"CREATE\") && VAR_0->argc == 5) {\n        streamID VAR_9;\n        if (!strcmp(VAR_0->argv[4]->ptr,\"$\")) {\n            VAR_9 = VAR_2->last_id;\n        } else if (streamParseIDOrReply(VAR_0,VAR_0->argv[4],&VAR_9,0) != VAR_10) {\n            return;\n        }\n        streamCG *VAR_4 = streamCreateCG(VAR_2,VAR_3,sdslen(VAR_3),&VAR_9);\n        if (VAR_4) {\n            addReply(VAR_0,VAR_7.ok);\n            VAR_11.dirty++;\n        } else {\n            addReplySds(VAR_0,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(VAR_5,\"SETID\") && VAR_0->argc == 5) {\n        streamID VAR_9;\n        if (!strcmp(VAR_0->argv[4]->ptr,\"$\")) {\n            VAR_9 = VAR_2->last_id;\n        } else if (streamParseIDOrReply(VAR_0,VAR_0->argv[4],&VAR_9,0) != VAR_10) {\n            return;\n        }\n        VAR_4->last_id = VAR_9;\n        addReply(VAR_0,VAR_7.ok);\n    } else if (!strcasecmp(VAR_5,\"DESTROY\") && VAR_0->argc == 4) {\n        if (VAR_4) {\n            raxRemove(VAR_2->cgroups,(unsigned char*)VAR_3,sdslen(VAR_3),NULL);\n            streamFreeCG(VAR_4);\n            addReply(VAR_0,VAR_7.cone);\n        } else {\n            addReply(VAR_0,VAR_7.czero);\n        }\n    } else if (!strcasecmp(VAR_5,\"DELCONSUMER\") && VAR_0->argc == 5) {\n        /* COMMENT_4 */\n                                                            \n        long long VAR_12 = streamDelConsumer(VAR_4,VAR_0->argv[4]->ptr);\n        addReplyLongLong(VAR_0,VAR_12);\n        VAR_11.dirty++;\n    } else if (!strcasecmp(VAR_5,\"HELP\")) {\n        addReplyHelp(VAR_0, VAR_1);\n    } else {\n        addReply(VAR_0,VAR_7.syntaxerr);\n    }\n}",
  "func_graph_path": "redis/c04082cf138f1f51cedf05ee9ad36fb6763cafc6/t_stream.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     /* Lookup the key now, this is common for all the subcommands but HELP. */\n     if (c->argc >= 4) {\n         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n-        if (o == NULL) return;\n+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n         s = o->ptr;\n         grpname = c->argv[3]->ptr;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        if (o == NULL) return;"
    ],
    "added_lines": [
      "        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/5001",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/redis/redis/pull/5001: 403 Client Error: Forbidden for url: https://api.github.com/repos/redis/redis/pulls/5001",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8\n\nThe patch addresses a segmentation fault in XGROUP when used on a non-stream key, which could lead to a crash. While the vulnerability description doesn't explicitly mention security, preventing such crashes can mitigate potential Denial of Service attacks, making this a security fix. The confidence score is 0.8 because while it's a crash fix, the description doesn't explicitly highlight security implications beyond the crash."
}