{
  "cve_id": "CVE-2020-36434",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "FillZpp/sys-info-rs",
  "commit_msg": "Make Disk Info Thread-Safe on Linux",
  "commit_hash": "4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7",
  "git_url": "https://github.com/FillZpp/sys-info-rs/commit/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7",
  "file_path": "c/linux.c",
  "func_name": "get_disk_info",
  "func_before": "DiskInfo get_disk_info(void) {\n\tFILE *mounts;\n\tchar procline[1024];\n\tchar *mount, *device, *type, *mode, *other;\n\tfloat thispct, max=0.0;\n\tdouble dtotal=0.0, dfree=0.0;\n\tDiskInfo di;\n\t\n\tdi.total = 0;\n\tdi.free = 0;\n\n\tmounts = fopen(MOUNTS,\"r\");\n\tif (!mounts) {\n\t\treturn di;\n\t}\n\twhile ( fgets(procline, sizeof(procline), mounts) ) {\n\t\tdevice = procline;\n\t\tmount = index(procline, ' ');\n\t\tif (mount == NULL) continue;\n\t\t*mount++ = '\\0';\n\t\ttype = index(mount, ' ');\n\t\tif (type == NULL) continue;\n\t\t*type++ = '\\0';\n\t\tmode = index(type, ' ');\n\t\tif (mode == NULL) continue;\n\t\t*mode++ = '\\0';\n\t\tother = index(mode, ' ');\n\t\tif (other != NULL) *other = '\\0';\n\t\tif (!strncmp(mode, \"ro\", 2)) continue;\n\t\tif (remote_mount(device, type)) continue;\n\t\tif (strncmp(device, \"/dev/\", 5) != 0 &&\n\t\t    strncmp(device, \"/dev2/\", 6) != 0) continue;\n\t\tthispct = device_space(mount, device, &dtotal, &dfree);\n\t\tif (!max || max<thispct)\n\t\t\tmax = thispct;\n\t}\n\tfclose(mounts);\n\n\tDFcleanup();\n\tdi.total = dtotal / 1000;\n\tdi.free = dfree / 1000;\n\t\n\treturn di;\n}",
  "abstract_func_before": "DiskInfo get_disk_info(void) {\n\tFILE *VAR_0;\n\tchar VAR_1[1024];\n\tchar *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6;\n\tfloat VAR_7, VAR_8=0.0;\n\tdouble VAR_9=0.0, VAR_10=0.0;\n\tDiskInfo VAR_11;\n\t\n\tVAR_11.total = 0;\n\tVAR_11.free = 0;\n\n\tVAR_0 = fopen(VAR_12,\"r\");\n\tif (!VAR_0) {\n\t\treturn VAR_11;\n\t}\n\twhile ( fgets(VAR_1, sizeof(VAR_1), VAR_0) ) {\n\t\tVAR_3 = VAR_1;\n\t\tVAR_2 = index(VAR_1, ' ');\n\t\tif (VAR_2 == NULL) continue;\n\t\t*VAR_2++ = '\\0';\n\t\tVAR_4 = index(VAR_2, ' ');\n\t\tif (VAR_4 == NULL) continue;\n\t\t*VAR_4++ = '\\0';\n\t\tVAR_5 = index(VAR_4, ' ');\n\t\tif (VAR_5 == NULL) continue;\n\t\t*VAR_5++ = '\\0';\n\t\tVAR_6 = index(VAR_5, ' ');\n\t\tif (VAR_6 != NULL) *VAR_6 = '\\0';\n\t\tif (!strncmp(VAR_5, \"ro\", 2)) continue;\n\t\tif (remote_mount(VAR_3, VAR_4)) continue;\n\t\tif (strncmp(VAR_3, \"/dev/\", 5) != 0 &&\n\t\t    strncmp(VAR_3, \"/dev2/\", 6) != 0) continue;\n\t\tVAR_7 = device_space(VAR_2, VAR_3, &VAR_9, &VAR_10);\n\t\tif (!VAR_8 || VAR_8<VAR_7)\n\t\t\tVAR_8 = VAR_7;\n\t}\n\tfclose(VAR_0);\n\n\tDFcleanup();\n\tVAR_11.total = VAR_9 / 1000;\n\tVAR_11.free = VAR_10 / 1000;\n\t\n\treturn VAR_11;\n}",
  "func_graph_path_before": "FillZpp/sys-info-rs/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7/linux.c/vul/before/0.json",
  "func": "DiskInfo get_disk_info(void) {\n\tFILE *mounts;\n\tchar procline[1024];\n\tstruct nlist *DFhashvector[DFHASHSIZE] = {0};\n\tchar *mount, *device, *type, *mode, *other;\n\tfloat thispct, max=0.0;\n\tdouble dtotal=0.0, dfree=0.0;\n\tDiskInfo di;\n\t\n\tdi.total = 0;\n\tdi.free = 0;\n\n\tmounts = fopen(MOUNTS,\"r\");\n\tif (!mounts) {\n\t\treturn di;\n\t}\n\twhile ( fgets(procline, sizeof(procline), mounts) ) {\n\t\tdevice = procline;\n\t\tmount = index(procline, ' ');\n\t\tif (mount == NULL) continue;\n\t\t*mount++ = '\\0';\n\t\ttype = index(mount, ' ');\n\t\tif (type == NULL) continue;\n\t\t*type++ = '\\0';\n\t\tmode = index(type, ' ');\n\t\tif (mode == NULL) continue;\n\t\t*mode++ = '\\0';\n\t\tother = index(mode, ' ');\n\t\tif (other != NULL) *other = '\\0';\n\t\tif (!strncmp(mode, \"ro\", 2)) continue;\n\t\tif (remote_mount(device, type)) continue;\n\t\tif (strncmp(device, \"/dev/\", 5) != 0 &&\n\t\t    strncmp(device, \"/dev2/\", 6) != 0) continue;\n\t\tthispct = device_space(DFhashvector, mount, device, &dtotal, &dfree);\n\t\tif (!max || max<thispct)\n\t\t\tmax = thispct;\n\t}\n\tfclose(mounts);\n\n\tDFcleanup(DFhashvector);\n\tdi.total = dtotal / 1000;\n\tdi.free = dfree / 1000;\n\t\n\treturn di;\n}",
  "abstract_func": "DiskInfo get_disk_info(void) {\n\tFILE *VAR_0;\n\tchar VAR_1[1024];\n\tstruct nlist *VAR_2[VAR_3] = {0};\n\tchar *VAR_4, *VAR_5, *VAR_6, *VAR_7, *VAR_8;\n\tfloat VAR_9, VAR_10=0.0;\n\tdouble VAR_11=0.0, VAR_12=0.0;\n\tDiskInfo VAR_13;\n\t\n\tVAR_13.total = 0;\n\tVAR_13.free = 0;\n\n\tVAR_0 = fopen(VAR_14,\"r\");\n\tif (!VAR_0) {\n\t\treturn VAR_13;\n\t}\n\twhile ( fgets(VAR_1, sizeof(VAR_1), VAR_0) ) {\n\t\tVAR_5 = VAR_1;\n\t\tVAR_4 = index(VAR_1, ' ');\n\t\tif (VAR_4 == NULL) continue;\n\t\t*VAR_4++ = '\\0';\n\t\tVAR_6 = index(VAR_4, ' ');\n\t\tif (VAR_6 == NULL) continue;\n\t\t*VAR_6++ = '\\0';\n\t\tVAR_7 = index(VAR_6, ' ');\n\t\tif (VAR_7 == NULL) continue;\n\t\t*VAR_7++ = '\\0';\n\t\tVAR_8 = index(VAR_7, ' ');\n\t\tif (VAR_8 != NULL) *VAR_8 = '\\0';\n\t\tif (!strncmp(VAR_7, \"ro\", 2)) continue;\n\t\tif (remote_mount(VAR_5, VAR_6)) continue;\n\t\tif (strncmp(VAR_5, \"/dev/\", 5) != 0 &&\n\t\t    strncmp(VAR_5, \"/dev2/\", 6) != 0) continue;\n\t\tVAR_9 = device_space(VAR_2, VAR_4, VAR_5, &VAR_11, &VAR_12);\n\t\tif (!VAR_10 || VAR_10<VAR_9)\n\t\t\tVAR_10 = VAR_9;\n\t}\n\tfclose(VAR_0);\n\n\tDFcleanup(VAR_2);\n\tVAR_13.total = VAR_11 / 1000;\n\tVAR_13.free = VAR_12 / 1000;\n\t\n\treturn VAR_13;\n}",
  "func_graph_path": "FillZpp/sys-info-rs/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7/linux.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n DiskInfo get_disk_info(void) {\n \tFILE *mounts;\n \tchar procline[1024];\n+\tstruct nlist *DFhashvector[DFHASHSIZE] = {0};\n \tchar *mount, *device, *type, *mode, *other;\n \tfloat thispct, max=0.0;\n \tdouble dtotal=0.0, dfree=0.0;\n@@ -30,13 +31,13 @@\n \t\tif (remote_mount(device, type)) continue;\n \t\tif (strncmp(device, \"/dev/\", 5) != 0 &&\n \t\t    strncmp(device, \"/dev2/\", 6) != 0) continue;\n-\t\tthispct = device_space(mount, device, &dtotal, &dfree);\n+\t\tthispct = device_space(DFhashvector, mount, device, &dtotal, &dfree);\n \t\tif (!max || max<thispct)\n \t\t\tmax = thispct;\n \t}\n \tfclose(mounts);\n \n-\tDFcleanup();\n+\tDFcleanup(DFhashvector);\n \tdi.total = dtotal / 1000;\n \tdi.free = dfree / 1000;\n \t",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tthispct = device_space(mount, device, &dtotal, &dfree);",
      "\tDFcleanup();"
    ],
    "added_lines": [
      "\tstruct nlist *DFhashvector[DFHASHSIZE] = {0};",
      "\t\tthispct = device_space(DFhashvector, mount, device, &dtotal, &dfree);",
      "\tDFcleanup(DFhashvector);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FillZpp/sys-info-rs/pull/84",
  "description": {
    "pr_info": {
      "title": "Make Disk Info Thread-Safe on Linux",
      "number": 84
    },
    "comment": [
      "Closes #63\r\n\r\nPass the `DFhashvector` around as an argument instead of using a global variable.\r\n\r\npossible alternatives: a lock"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}