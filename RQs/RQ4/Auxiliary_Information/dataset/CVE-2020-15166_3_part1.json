{
  "cve_id": "CVE-2020-15166",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "problem: zeromq connects peer before handshake is completed\n\nSolution: delay connecting the peer pipe until the handshake is completed",
  "commit_hash": "e7f0090b161ce6344f6bd35009816a925c070b09",
  "git_url": "https://github.com/zeromq/libzmq/commit/e7f0090b161ce6344f6bd35009816a925c070b09",
  "file_path": "src/stream_engine_base.cpp",
  "func_name": "zmq::stream_engine_base_t::in_event_internal",
  "func_before": "bool zmq::stream_engine_base_t::in_event_internal ()\n{\n    zmq_assert (!_io_error);\n\n    //  If still handshaking, receive and process the greeting message.\n    if (unlikely (_handshaking)) {\n        if (handshake ()) {\n            //  Handshaking was successful.\n            //  Switch into the normal message flow.\n            _handshaking = false;\n        } else\n            return false;\n    }\n\n\n    zmq_assert (_decoder);\n\n    //  If there has been an I/O error, stop polling.\n    if (_input_stopped) {\n        rm_fd (_handle);\n        _io_error = true;\n        return true; // TODO or return false in this case too?\n    }\n\n    //  If there's no data to process in the buffer...\n    if (!_insize) {\n        //  Retrieve the buffer and read as much data as possible.\n        //  Note that buffer can be arbitrarily large. However, we assume\n        //  the underlying TCP layer has fixed buffer size and thus the\n        //  number of bytes read will be always limited.\n        size_t bufsize = 0;\n        _decoder->get_buffer (&_inpos, &bufsize);\n\n        const int rc = read (_inpos, bufsize);\n\n        if (rc == -1) {\n            if (errno != EAGAIN) {\n                error (connection_error);\n                return false;\n            }\n            return true;\n        }\n\n        //  Adjust input size\n        _insize = static_cast<size_t> (rc);\n        // Adjust buffer size to received bytes\n        _decoder->resize_buffer (_insize);\n    }\n\n    int rc = 0;\n    size_t processed = 0;\n\n    while (_insize > 0) {\n        rc = _decoder->decode (_inpos, _insize, processed);\n        zmq_assert (processed <= _insize);\n        _inpos += processed;\n        _insize -= processed;\n        if (rc == 0 || rc == -1)\n            break;\n        rc = (this->*_process_msg) (_decoder->msg ());\n        if (rc == -1)\n            break;\n    }\n\n    //  Tear down the connection if we have failed to decode input data\n    //  or the session has rejected the message.\n    if (rc == -1) {\n        if (errno != EAGAIN) {\n            error (protocol_error);\n            return false;\n        }\n        _input_stopped = true;\n        reset_pollin (_handle);\n    }\n\n    _session->flush ();\n    return true;\n}",
  "abstract_func_before": "bool zmq::stream_engine_base_t::in_event_internal ()\n{\n    zmq_assert (!VAR_0);\n\n    /* COMMENT_0 */\n    if (unlikely (VAR_1)) {\n        if (handshake ()) {\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            VAR_1 = false;\n        } else\n            return false;\n    }\n\n\n    zmq_assert (VAR_2);\n\n    /* COMMENT_3 */\n    if (VAR_3) {\n        rm_fd (VAR_4);\n        VAR_0 = true;\n        return true; /* COMMENT_4 */\n    }\n\n    /* COMMENT_5 */\n    if (!VAR_5) {\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        size_t VAR_6 = 0;\n        VAR_2->get_buffer (&VAR_7, &VAR_6);\n\n        const int VAR_8 = read (VAR_7, VAR_6);\n\n        if (VAR_8 == -1) {\n            if (VAR_9 != VAR_10) {\n                error (VAR_11);\n                return false;\n            }\n            return true;\n        }\n\n        /* COMMENT_10 */\n        VAR_5 = VAR_12<size_t> (VAR_8);\n        /* COMMENT_11 */\n        VAR_2->resize_buffer (VAR_5);\n    }\n\n    int VAR_8 = 0;\n    size_t VAR_13 = 0;\n\n    while (VAR_5 > 0) {\n        VAR_8 = VAR_2->decode (VAR_7, VAR_5, VAR_13);\n        zmq_assert (VAR_13 <= VAR_5);\n        VAR_7 += VAR_13;\n        VAR_5 -= VAR_13;\n        if (VAR_8 == 0 || VAR_8 == -1)\n            break;\n        VAR_8 = (this->*VAR_14) (VAR_2->msg ());\n        if (VAR_8 == -1)\n            break;\n    }\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    if (VAR_8 == -1) {\n        if (VAR_9 != VAR_10) {\n            error (VAR_15);\n            return false;\n        }\n        VAR_3 = true;\n        reset_pollin (VAR_4);\n    }\n\n    VAR_16->flush ();\n    return true;\n}",
  "func_graph_path_before": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/stream_engine_base.cpp/vul/before/0.json",
  "func": "bool zmq::stream_engine_base_t::in_event_internal ()\n{\n    zmq_assert (!_io_error);\n\n    //  If still handshaking, receive and process the greeting message.\n    if (unlikely (_handshaking)) {\n        if (handshake ()) {\n            //  Handshaking was successful.\n            //  Switch into the normal message flow.\n            _handshaking = false;\n\n            if (_mechanism == NULL && _has_handshake_stage)\n                _session->engine_ready ();\n        } else\n            return false;\n    }\n\n\n    zmq_assert (_decoder);\n\n    //  If there has been an I/O error, stop polling.\n    if (_input_stopped) {\n        rm_fd (_handle);\n        _io_error = true;\n        return true; // TODO or return false in this case too?\n    }\n\n    //  If there's no data to process in the buffer...\n    if (!_insize) {\n        //  Retrieve the buffer and read as much data as possible.\n        //  Note that buffer can be arbitrarily large. However, we assume\n        //  the underlying TCP layer has fixed buffer size and thus the\n        //  number of bytes read will be always limited.\n        size_t bufsize = 0;\n        _decoder->get_buffer (&_inpos, &bufsize);\n\n        const int rc = read (_inpos, bufsize);\n\n        if (rc == -1) {\n            if (errno != EAGAIN) {\n                error (connection_error);\n                return false;\n            }\n            return true;\n        }\n\n        //  Adjust input size\n        _insize = static_cast<size_t> (rc);\n        // Adjust buffer size to received bytes\n        _decoder->resize_buffer (_insize);\n    }\n\n    int rc = 0;\n    size_t processed = 0;\n\n    while (_insize > 0) {\n        rc = _decoder->decode (_inpos, _insize, processed);\n        zmq_assert (processed <= _insize);\n        _inpos += processed;\n        _insize -= processed;\n        if (rc == 0 || rc == -1)\n            break;\n        rc = (this->*_process_msg) (_decoder->msg ());\n        if (rc == -1)\n            break;\n    }\n\n    //  Tear down the connection if we have failed to decode input data\n    //  or the session has rejected the message.\n    if (rc == -1) {\n        if (errno != EAGAIN) {\n            error (protocol_error);\n            return false;\n        }\n        _input_stopped = true;\n        reset_pollin (_handle);\n    }\n\n    _session->flush ();\n    return true;\n}",
  "abstract_func": "bool zmq::stream_engine_base_t::in_event_internal ()\n{\n    zmq_assert (!VAR_0);\n\n    /* COMMENT_0 */\n    if (unlikely (VAR_1)) {\n        if (handshake ()) {\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            VAR_1 = false;\n\n            if (VAR_2 == NULL && VAR_3)\n                VAR_4->engine_ready ();\n        } else\n            return false;\n    }\n\n\n    zmq_assert (VAR_5);\n\n    /* COMMENT_3 */\n    if (VAR_6) {\n        rm_fd (VAR_7);\n        VAR_0 = true;\n        return true; /* COMMENT_4 */\n    }\n\n    /* COMMENT_5 */\n    if (!VAR_8) {\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        size_t VAR_9 = 0;\n        VAR_5->get_buffer (&VAR_10, &VAR_9);\n\n        const int VAR_11 = read (VAR_10, VAR_9);\n\n        if (VAR_11 == -1) {\n            if (VAR_12 != VAR_13) {\n                error (VAR_14);\n                return false;\n            }\n            return true;\n        }\n\n        /* COMMENT_10 */\n        VAR_8 = VAR_15<size_t> (VAR_11);\n        /* COMMENT_11 */\n        VAR_5->resize_buffer (VAR_8);\n    }\n\n    int VAR_11 = 0;\n    size_t VAR_16 = 0;\n\n    while (VAR_8 > 0) {\n        VAR_11 = VAR_5->decode (VAR_10, VAR_8, VAR_16);\n        zmq_assert (VAR_16 <= VAR_8);\n        VAR_10 += VAR_16;\n        VAR_8 -= VAR_16;\n        if (VAR_11 == 0 || VAR_11 == -1)\n            break;\n        VAR_11 = (this->*VAR_17) (VAR_5->msg ());\n        if (VAR_11 == -1)\n            break;\n    }\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    if (VAR_11 == -1) {\n        if (VAR_12 != VAR_13) {\n            error (VAR_18);\n            return false;\n        }\n        VAR_6 = true;\n        reset_pollin (VAR_7);\n    }\n\n    VAR_4->flush ();\n    return true;\n}",
  "func_graph_path": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/stream_engine_base.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,9 @@\n             //  Handshaking was successful.\n             //  Switch into the normal message flow.\n             _handshaking = false;\n+\n+            if (_mechanism == NULL && _has_handshake_stage)\n+                _session->engine_ready ();\n         } else\n             return false;\n     }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "            if (_mechanism == NULL && _has_handshake_stage)",
      "                _session->engine_ready ();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/3913",
  "description": {
    "pr_info": {
      "title": "problem: zeromq connects peer before handshake is complete",
      "number": 3913
    },
    "comment": [
      "Solution: delay connecting the peer pipe until the handshake is complete",
      "@bluca PR is ready ",
      "Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8\n\nThe patch addresses a potential security concern where connecting before a handshake could expose vulnerabilities. While the commit message doesn't explicitly mention security, the fix involves deferring connection until the handshake completes, a common security measure. The confidence is high but not absolute due to the lack of explicit security terms."
}