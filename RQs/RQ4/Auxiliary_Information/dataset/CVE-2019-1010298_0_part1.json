{
  "cve_id": "CVE-2019-1010298",
  "cwe_ids": [
    "CWE-190",
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "svc: check for allocation overflow in crypto calls part 2\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0011: \"Integer overflow in crypto system calls (x2)\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
  "commit_hash": "70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8",
  "file_path": "core/tee/tee_svc_cryp.c",
  "func_name": "syscall_asymm_operate",
  "func_before": "TEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tuint64_t dlen64;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdlen = dlen64;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tparams = malloc(sizeof(TEE_Attribute) * num_params);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tdlen64 = dlen;\n\t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
  "abstract_func_before": "TEE_Result syscall_asymm_operate(unsigned long VAR_0,\n\t\t\tconst struct utee_attribute *VAR_1,\n\t\t\tsize_t VAR_2, const void *VAR_3, size_t VAR_4,\n\t\t\tvoid *VAR_5, uint64_t *VAR_6)\n{\n\tTEE_Result VAR_7;\n\tstruct tee_cryp_state *VAR_8;\n\tstruct tee_ta_session *VAR_9;\n\tuint64_t VAR_10;\n\tsize_t VAR_11;\n\tstruct tee_obj *VAR_12;\n\tvoid *VAR_13 = NULL;\n\tsize_t VAR_14 = 0;\n\tsize_t VAR_15;\n\tint VAR_16;\n\tTEE_Attribute *VAR_17 = NULL;\n\tstruct user_ta_ctx *VAR_18;\n\n\tVAR_7 = tee_ta_get_current_session(&VAR_9);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\tVAR_18 = to_user_ta_ctx(VAR_9->ctx);\n\n\tVAR_7 = tee_svc_cryp_get_state(VAR_9, tee_svc_uref_to_vaddr(VAR_0), &VAR_8);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\n\tVAR_7 = tee_mmu_check_access_rights(\n\t\tVAR_18,\n\t\tVAR_20 | VAR_21,\n\t\t(uaddr_t) VAR_3, VAR_4);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\n\tVAR_7 = tee_svc_copy_from_user(&VAR_10, VAR_6, sizeof(VAR_10));\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\tVAR_11 = VAR_10;\n\n\tVAR_7 = tee_mmu_check_access_rights(\n\t\tVAR_18,\n\t\tVAR_20 | VAR_22 |\n\t\t\tVAR_21,\n\t\t(uaddr_t) VAR_5, VAR_11);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\n\tVAR_17 = malloc(sizeof(TEE_Attribute) * VAR_2);\n\tif (!VAR_17)\n\t\treturn VAR_23;\n\tVAR_7 = copy_in_attrs(VAR_18, VAR_1, VAR_2, VAR_17);\n\tif (VAR_7 != VAR_19)\n\t\tgoto out;\n\n\tVAR_7 = tee_obj_get(VAR_18, VAR_8->key1, &VAR_12);\n\tif (VAR_7 != VAR_19)\n\t\tgoto out;\n\tif ((VAR_12->info.handleFlags & VAR_24) == 0) {\n\t\tVAR_7 = VAR_25;\n\t\tgoto out;\n\t}\n\n\tswitch (VAR_8->algo) {\n\tcase VAR_26:\n\t\tif (VAR_8->mode == VAR_27) {\n\t\t\tVAR_7 = crypto_acipher_rsanopad_encrypt(VAR_12->attr, VAR_3,\n\t\t\t\t\t\t\t      VAR_4, VAR_5,\n\t\t\t\t\t\t\t      &VAR_11);\n\t\t} else if (VAR_8->mode == VAR_28) {\n\t\t\tVAR_7 = crypto_acipher_rsanopad_decrypt(VAR_12->attr, VAR_3,\n\t\t\t\t\t\t\t      VAR_4, VAR_5,\n\t\t\t\t\t\t\t      &VAR_11);\n\t\t} else {\n\t\t\t/* COMMENT_0 */\n                                                       \n                        \n      \n\t\t\tVAR_7 = VAR_25;\n\t\t}\n\t\tbreak;\n\n\tcase VAR_29:\n\tcase VAR_30:\n\tcase VAR_31:\n\tcase VAR_32:\n\tcase VAR_33:\n\tcase VAR_34:\n\t\tfor (VAR_15 = 0; VAR_15 < VAR_2; VAR_15++) {\n\t\t\tif (VAR_17[VAR_15].attributeID == VAR_35) {\n\t\t\t\tVAR_13 = VAR_17[VAR_15].content.ref.buffer;\n\t\t\t\tVAR_14 = VAR_17[VAR_15].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_8->mode == VAR_27) {\n\t\t\tVAR_7 = crypto_acipher_rsaes_encrypt(VAR_8->algo, VAR_12->attr,\n\t\t\t\t\t\t\t   VAR_13, VAR_14,\n\t\t\t\t\t\t\t   VAR_3, VAR_4,\n\t\t\t\t\t\t\t   VAR_5, &VAR_11);\n\t\t} else if (VAR_8->mode == VAR_28) {\n\t\t\tVAR_7 = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tVAR_8->algo, VAR_12->attr, VAR_13, VAR_14,\n\t\t\t\t\tVAR_3, VAR_4, VAR_5, &VAR_11);\n\t\t} else {\n\t\t\tVAR_7 = VAR_36;\n\t\t}\n\t\tbreak;\n\n#if defined(VAR_37)\n\tcase VAR_38:\n#endif\n\tcase VAR_39:\n\tcase VAR_40:\n\tcase VAR_41:\n\tcase VAR_42:\n\tcase VAR_43:\n\tcase VAR_44:\n\tcase VAR_45:\n\tcase VAR_46:\n\tcase VAR_47:\n\tcase VAR_48:\n\tcase VAR_49:\n\t\tif (VAR_8->mode != VAR_50) {\n\t\t\tVAR_7 = VAR_36;\n\t\t\tbreak;\n\t\t}\n\t\tVAR_16 = pkcs1_get_salt_len(VAR_17, VAR_2, VAR_4);\n\t\tVAR_7 = crypto_acipher_rsassa_sign(VAR_8->algo, VAR_12->attr, VAR_16,\n\t\t\t\t\t\t VAR_3, VAR_4, VAR_5,\n\t\t\t\t\t\t &VAR_11);\n\t\tbreak;\n\n\tcase VAR_51:\n\tcase VAR_52:\n\tcase VAR_53:\n\t\tVAR_7 = crypto_acipher_dsa_sign(VAR_8->algo, VAR_12->attr, VAR_3,\n\t\t\t\t\t      VAR_4, VAR_5, &VAR_11);\n\t\tbreak;\n\tcase VAR_54:\n\tcase VAR_55:\n\tcase VAR_56:\n\tcase VAR_57:\n\tcase VAR_58:\n\t\tVAR_7 = crypto_acipher_ecc_sign(VAR_8->algo, VAR_12->attr, VAR_3,\n\t\t\t\t\t      VAR_4, VAR_5, &VAR_11);\n\t\tbreak;\n\n\tdefault:\n\t\tVAR_7 = VAR_36;\n\t\tbreak;\n\t}\n\nout:\n\tfree(VAR_17);\n\n\tif (VAR_7 == VAR_19 || VAR_7 == VAR_59) {\n\t\tTEE_Result VAR_60;\n\n\t\tVAR_10 = VAR_11;\n\t\tVAR_60 = tee_svc_copy_to_user(VAR_6, &VAR_10, sizeof(*VAR_6));\n\t\tif (VAR_60 != VAR_19)\n\t\t\treturn VAR_60;\n\t}\n\n\treturn VAR_7;\n}",
  "func_graph_path_before": "OP-TEE/optee_os/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8/tee_svc_cryp.c/vul/before/1.json",
  "func": "TEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tuint64_t dlen64;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdlen = dlen64;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tdlen64 = dlen;\n\t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
  "abstract_func": "TEE_Result syscall_asymm_operate(unsigned long VAR_0,\n\t\t\tconst struct utee_attribute *VAR_1,\n\t\t\tsize_t VAR_2, const void *VAR_3, size_t VAR_4,\n\t\t\tvoid *VAR_5, uint64_t *VAR_6)\n{\n\tTEE_Result VAR_7;\n\tstruct tee_cryp_state *VAR_8;\n\tstruct tee_ta_session *VAR_9;\n\tuint64_t VAR_10;\n\tsize_t VAR_11;\n\tstruct tee_obj *VAR_12;\n\tvoid *VAR_13 = NULL;\n\tsize_t VAR_14 = 0;\n\tsize_t VAR_15;\n\tint VAR_16;\n\tTEE_Attribute *VAR_17 = NULL;\n\tstruct user_ta_ctx *VAR_18;\n\n\tVAR_7 = tee_ta_get_current_session(&VAR_9);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\tVAR_18 = to_user_ta_ctx(VAR_9->ctx);\n\n\tVAR_7 = tee_svc_cryp_get_state(VAR_9, tee_svc_uref_to_vaddr(VAR_0), &VAR_8);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\n\tVAR_7 = tee_mmu_check_access_rights(\n\t\tVAR_18,\n\t\tVAR_20 | VAR_21,\n\t\t(uaddr_t) VAR_3, VAR_4);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\n\tVAR_7 = tee_svc_copy_from_user(&VAR_10, VAR_6, sizeof(VAR_10));\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\tVAR_11 = VAR_10;\n\n\tVAR_7 = tee_mmu_check_access_rights(\n\t\tVAR_18,\n\t\tVAR_20 | VAR_22 |\n\t\t\tVAR_21,\n\t\t(uaddr_t) VAR_5, VAR_11);\n\tif (VAR_7 != VAR_19)\n\t\treturn VAR_7;\n\n\tsize_t VAR_23 = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), VAR_2, &VAR_23))\n\t\treturn VAR_24;\n\n\tVAR_17 = malloc(VAR_23);\n\tif (!VAR_17)\n\t\treturn VAR_25;\n\tVAR_7 = copy_in_attrs(VAR_18, VAR_1, VAR_2, VAR_17);\n\tif (VAR_7 != VAR_19)\n\t\tgoto out;\n\n\tVAR_7 = tee_obj_get(VAR_18, VAR_8->key1, &VAR_12);\n\tif (VAR_7 != VAR_19)\n\t\tgoto out;\n\tif ((VAR_12->info.handleFlags & VAR_26) == 0) {\n\t\tVAR_7 = VAR_27;\n\t\tgoto out;\n\t}\n\n\tswitch (VAR_8->algo) {\n\tcase VAR_28:\n\t\tif (VAR_8->mode == VAR_29) {\n\t\t\tVAR_7 = crypto_acipher_rsanopad_encrypt(VAR_12->attr, VAR_3,\n\t\t\t\t\t\t\t      VAR_4, VAR_5,\n\t\t\t\t\t\t\t      &VAR_11);\n\t\t} else if (VAR_8->mode == VAR_30) {\n\t\t\tVAR_7 = crypto_acipher_rsanopad_decrypt(VAR_12->attr, VAR_3,\n\t\t\t\t\t\t\t      VAR_4, VAR_5,\n\t\t\t\t\t\t\t      &VAR_11);\n\t\t} else {\n\t\t\t/* COMMENT_0 */\n                                                       \n                        \n      \n\t\t\tVAR_7 = VAR_27;\n\t\t}\n\t\tbreak;\n\n\tcase VAR_31:\n\tcase VAR_32:\n\tcase VAR_33:\n\tcase VAR_34:\n\tcase VAR_35:\n\tcase VAR_36:\n\t\tfor (VAR_15 = 0; VAR_15 < VAR_2; VAR_15++) {\n\t\t\tif (VAR_17[VAR_15].attributeID == VAR_37) {\n\t\t\t\tVAR_13 = VAR_17[VAR_15].content.ref.buffer;\n\t\t\t\tVAR_14 = VAR_17[VAR_15].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_8->mode == VAR_29) {\n\t\t\tVAR_7 = crypto_acipher_rsaes_encrypt(VAR_8->algo, VAR_12->attr,\n\t\t\t\t\t\t\t   VAR_13, VAR_14,\n\t\t\t\t\t\t\t   VAR_3, VAR_4,\n\t\t\t\t\t\t\t   VAR_5, &VAR_11);\n\t\t} else if (VAR_8->mode == VAR_30) {\n\t\t\tVAR_7 = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tVAR_8->algo, VAR_12->attr, VAR_13, VAR_14,\n\t\t\t\t\tVAR_3, VAR_4, VAR_5, &VAR_11);\n\t\t} else {\n\t\t\tVAR_7 = VAR_38;\n\t\t}\n\t\tbreak;\n\n#if defined(VAR_39)\n\tcase VAR_40:\n#endif\n\tcase VAR_41:\n\tcase VAR_42:\n\tcase VAR_43:\n\tcase VAR_44:\n\tcase VAR_45:\n\tcase VAR_46:\n\tcase VAR_47:\n\tcase VAR_48:\n\tcase VAR_49:\n\tcase VAR_50:\n\tcase VAR_51:\n\t\tif (VAR_8->mode != VAR_52) {\n\t\t\tVAR_7 = VAR_38;\n\t\t\tbreak;\n\t\t}\n\t\tVAR_16 = pkcs1_get_salt_len(VAR_17, VAR_2, VAR_4);\n\t\tVAR_7 = crypto_acipher_rsassa_sign(VAR_8->algo, VAR_12->attr, VAR_16,\n\t\t\t\t\t\t VAR_3, VAR_4, VAR_5,\n\t\t\t\t\t\t &VAR_11);\n\t\tbreak;\n\n\tcase VAR_53:\n\tcase VAR_54:\n\tcase VAR_55:\n\t\tVAR_7 = crypto_acipher_dsa_sign(VAR_8->algo, VAR_12->attr, VAR_3,\n\t\t\t\t\t      VAR_4, VAR_5, &VAR_11);\n\t\tbreak;\n\tcase VAR_56:\n\tcase VAR_57:\n\tcase VAR_58:\n\tcase VAR_59:\n\tcase VAR_60:\n\t\tVAR_7 = crypto_acipher_ecc_sign(VAR_8->algo, VAR_12->attr, VAR_3,\n\t\t\t\t\t      VAR_4, VAR_5, &VAR_11);\n\t\tbreak;\n\n\tdefault:\n\t\tVAR_7 = VAR_38;\n\t\tbreak;\n\t}\n\nout:\n\tfree(VAR_17);\n\n\tif (VAR_7 == VAR_19 || VAR_7 == VAR_61) {\n\t\tTEE_Result VAR_62;\n\n\t\tVAR_10 = VAR_11;\n\t\tVAR_62 = tee_svc_copy_to_user(VAR_6, &VAR_10, sizeof(*VAR_6));\n\t\tif (VAR_62 != VAR_19)\n\t\t\treturn VAR_62;\n\t}\n\n\treturn VAR_7;\n}",
  "func_graph_path": "OP-TEE/optee_os/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8/tee_svc_cryp.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,12 @@\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n-\tparams = malloc(sizeof(TEE_Attribute) * num_params);\n+\tsize_t alloc_size = 0;\n+\n+\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n+\t\treturn TEE_ERROR_OVERFLOW;\n+\n+\tparams = malloc(alloc_size);\n \tif (!params)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(utc, usr_params, num_params, params);",
  "diff_line_info": {
    "deleted_lines": [
      "\tparams = malloc(sizeof(TEE_Attribute) * num_params);"
    ],
    "added_lines": [
      "\tsize_t alloc_size = 0;",
      "",
      "\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))",
      "\t\treturn TEE_ERROR_OVERFLOW;",
      "",
      "\tparams = malloc(alloc_size);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/2745",
  "description": {
    "pr_info": {
      "title": "Fixes for security potential issues reported by Riscure",
      "number": 2745
    },
    "comment": [
      "This patch series address a list of potential security issues and (lack of) hardening as identified by [Riscure](https://www.riscure.com/). More details about the issues themselves will be submitted to https://www.op-tee.org/security-advisories in the coming weeks. \r\n\r\nNote that patches here are already \"pre-reviewed\" (internally at Linaro) and the reason for that is that all patches have already been circulated to trustworthy stakeholders according to our disclosure plan (see the draft [here](https://optee.readthedocs.io/general/disclousure.html)). Having that said, we encourage OP-TEE maintainers and other users to chime in and do a final review here on GitHub.\r\n\r\nI've just rebased it on top of master and all tests in xtest passes. ",
      "I've seen the Shippable error, I'll have a look at it.",
      "> I've seen the Shippable error, I'll have a look at it.\r\n\r\nI've changed the macro to only consider SMALL_PAGE_SIZE, since that is what we check against. Will push a fix soon.",
      "Pushed fixes for all (fixable) comments so far. I've saved the ones that has to be done at rebase/force push time.",
      "LGTM, you may add my:\r\n\r\n`Acked-by: Jerome Forissier <jerome.forissier@linaro.org>`\r\n\r\n...to all the commits that deal with CFG_ flags.",
      "`Acked-by: Etienne Carriere <etienne.carriere@linaro.org>` for the whole with some minor comments.",
      "> `Acked-by: Etienne Carriere <etienne.carriere@linaro.org>` for the whole with some minor comments.\r\n\r\n@etienne-lms , I'm confused. I cannot see any comments from you. Is GitHub playing me a trick here?",
      "Pushed a few more fixes.\r\n\r\nWaiting for:\r\n- Etienne's follow up answers on my replies to his findings.\r\n\r\nTo-do at rebase/force/squash:\r\n- Add Acked-by tags.\r\n- Fix wrong author vs Signed-Off-By.\r\n",
      "- Fixed SoB / Author inconsistency.\r\n- Fixed all outstanding review comments.\r\n- Fixed spelling error found by checkpatch / Shippable.\r\n- Added A-B and T-B tags.\r\n\r\nSo, if IBART and friends are happy .... then ...\r\nSquashed, rebased and tag(s) applied (should be) ready for merge! Thanks!",
      "Sorry, I still have comments on the last 6 commits.\r\n\r\n- \"plat-all: Enable CFG_CORE_STACK_PROTECTOR_STRONG=y by default\" removes `CFG_WITH_STACK_CANARIES ?= y` from `rpi3`. It also enables`CFG_TA_STACK_PROTECTOR_STRONG ?= y` which is introduced in a later commit. Overall I think this commit had better be folded into the parent commit \"core: introduce CFG_CORE_STACK_PROTECTOR_STRONG flag\" (which will also avoid a Travis warning about missing commit description).\r\n- \"ta-dev-kit: enable _FORTIFY_SOURCE=2 on optimized builds\": you say \"shall only be enabled...\", so why isn't it part of commit \"ta-dev-kit: Introduce CFG_TA_FORTIFY_SOURCE\"?\r\n\r\nAlso I think the Travis warnings (missing commit descriptions) should be fixed. When introducing a new flag, we should explain what it does, why we add it, and what is its default value. Things I expect to understand when reading the description are: what is a stack protector? What happens when the \"protection\" detects that something is wrong? Does the TA panic? Does the TEE core panic? Same for the \"fortify\" option.\r\n\r\nIn the end I'd like to have 4 commits:\r\n```\r\n    ta: introduce CFG_TA_STACK_PROTECTOR_STRONG\r\n    ta: introduce CFG_TA_FORTIFY_SOURCE\r\n    core: introduce CFG_CORE_STACK_PROTECTOR_STRONG\r\n    core: introduce CFG_CORE_FORTIFY_SOURCE\r\n```\r\n",
      "@jforissier , makes sense. I'll do another clean-up / clarification round, stay tuned.",
      "Easier said that done trying to trigger the protectors, since I get data abort when trying to put together examples that should trigger the stack-protector for example. I'd expect some output like \"`*** stack smashing detected ***` at least before the data-abort.",
      "@jbech-linaro hard to find documentation, but it looks like the compiler will just call `__stack_chk_fail()`, which we happen to define here: https://github.com/OP-TEE/optee_os/blob/3.3.0/lib/libutils/isoc/stack_check.c\r\nAt least, that's what I can see in the disassembly (`tee.dmp` or `objdump -ldx ta.elf`).\r\n\r\nSo, if I understand correctly, the TA or the TEE core thread would just hang when stack smashing is detected (instead of proceeding with corrupt data).",
      "I think I can trigger it successfully now, since without using the flags I get data-aborts, with the flags enabled I get stuck. I've tried to figure out where I am by checking GDB, but so far I haven't been able to make sense out of the address. I'll try to see whether it ends up in `stack_check.c` or not.",
      "@jbech-linaro sounds good. Perhaps `__stack_chk_fail()` should `EMSG()` and call `panic()` (`ifdef __KERNEL__`) or `abort()`/`utee_panic()` (user mode TA). Or is there any reason we could not do that in this context?",
      "I've tried setting a breakpoint at `__stack_chk_fail`, but it doesn't seem to hang there. But I can see my data (`foo(AAAA...)`) in the `r2` when breaking, so I suspect it is stuck somewhere in strcpy, and/or \"panic\" while(1) as a consequence of this.\r\n```bash\r\nfoo(\"AAAAAAA.....\");\r\n\r\nvoid foo(char *bar) {\r\nchar buffer[16];\r\nstrcpy(buffer, bar)\r\n}\r\n```\r\n\r\n```\r\nr2 = 0x00414141\r\n...\r\n```\r\nI think I will skip the CFG_-patches and submit them as a separate PR if/when I have some time to spare. They weren't really part of the Riscure report, I just added it, since I thought it'd be useful to catch things.",
      "> I think I will skip the CFG_-patches [...]\r\n\r\nSure. They are definitely useful IMO, but certainly not required for 3.4.0. Thanks!",
      "Two things ....\r\n1. I've removed the CFG patches from this PR and pushed that.\r\n2. I've rebuilt QEMU with SMP=1 and now!!! Lo and behold! I'm stuck in .... drum roll ... `__stack_chk_fail() { while (1) }`.\r\n\r\nSo it seems to work as expected.\r\n\r\nAnyhow, as before, if IBART and friends are happy:\r\nSquashed, rebased and tag(s) applied (should be) ready for merge! Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses an integer overflow issue in the crypto system calls, a security risk. The code introduces an overflow check before memory allocation, mitigating the buffer overflow. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}