{
  "cve_id": "CVE-2023-33973",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "gnrc_sixlowpan_iphc: fix NULL pointer dereference",
  "commit_hash": "c9d7863e5664a169035038628029bb07e090c5ff",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/c9d7863e5664a169035038628029bb07e090c5ff",
  "file_path": "sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c",
  "func_name": "_iphc_ipv6_encode",
  "func_before": "static size_t _iphc_ipv6_encode(gnrc_pktsnip_t *pkt,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface,\n                                uint8_t *iphc_hdr)\n{\n    gnrc_sixlowpan_ctx_t *src_ctx = NULL, *dst_ctx = NULL;\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    bool addr_comp = false;\n    uint16_t inline_pos = SIXLOWPAN_IPHC_HDR_LEN;\n\n    assert(iface != NULL);\n\n    /* set initial dispatch value*/\n    iphc_hdr[IPHC1_IDX] = SIXLOWPAN_IPHC1_DISP;\n    iphc_hdr[IPHC2_IDX] = 0;\n\n    /* check for available contexts */\n    if (!ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        src_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->src));\n        /* do not use source context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (src_ctx && !(src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            src_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (src_ctx &&\n            ipv6_addr_match_prefix(&src_ctx->prefix, &ipv6_hdr->src) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            src_ctx = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&ipv6_hdr->dst)) {\n        dst_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->dst));\n        /* do not use destination context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (dst_ctx && !(dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            dst_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (dst_ctx &&\n            ipv6_addr_match_prefix(&dst_ctx->prefix, &ipv6_hdr->dst) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            dst_ctx = NULL;\n        }\n    }\n\n    /* if contexts available and both != 0 */\n    /* since this moves inline_pos we have to do this ahead*/\n    if (((src_ctx != NULL) &&\n            ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) ||\n        ((dst_ctx != NULL) &&\n            ((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0))) {\n        /* add context identifier extension */\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_CID_EXT;\n        iphc_hdr[CID_EXT_IDX] = 0;\n\n        /* move position to behind CID extension */\n        inline_pos += SIXLOWPAN_IPHC_CID_EXT_LEN;\n    }\n\n    /* compress flow label and traffic class */\n    if (ipv6_hdr_get_fl(ipv6_hdr) == 0) {\n        if (ipv6_hdr_get_tc(ipv6_hdr) == 0) {\n            /* elide both traffic class and flow label */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_ELIDE;\n        }\n        else {\n            /* elide flow label, traffic class (ECN + DSCP) inline (1 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(ipv6_hdr) == 0) {\n            /* elide DSCP, ECN + 2-bit pad + flow label inline (3 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_FL;\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_tc_ecn(ipv6_hdr) << 6) |\n                                               ((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16));\n        }\n        else {\n            /* ECN + DSCP + 4-bit pad + flow label (4 bytes) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP_FL;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16);\n        }\n\n        /* copy remaining bytes of flow label */\n        iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x0000ff00) >> 8);\n        iphc_hdr[inline_pos++] = (uint8_t)(ipv6_hdr_get_fl(ipv6_hdr) & 0x000000ff);\n    }\n\n    /* check for compressible next header */\n    if (_compressible_nh(ipv6_hdr->nh)) {\n        iphc_hdr[IPHC1_IDX] |= SIXLOWPAN_IPHC1_NH;\n    }\n    else {\n        iphc_hdr[inline_pos++] = ipv6_hdr->nh;\n    }\n\n    /* compress hop limit */\n    switch (ipv6_hdr->hl) {\n        case 1:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_1;\n            break;\n\n        case 64:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_64;\n            break;\n\n        case 255:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_255;\n            break;\n\n        default:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_INLINE;\n            iphc_hdr[inline_pos++] = ipv6_hdr->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_UNSPEC;\n    }\n    else {\n        if (src_ctx != NULL) {\n            /* stateful source address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_SAC;\n\n            if (((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) << 4);\n            }\n        }\n\n        if ((src_ctx != NULL) || ipv6_addr_is_link_local(&(ipv6_hdr->src))) {\n            eui64_t iid;\n            iid.uint64.u64 = 0;\n\n            gnrc_netif_acquire(iface);\n            if (gnrc_netif_ipv6_get_iid(iface, &iid) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(iface);\n                return 0;\n            }\n            gnrc_netif_release(iface);\n\n            if ((ipv6_hdr->src.u64[1].u64 == iid.uint64.u64) ||\n                _context_overlaps_iid(src_ctx, &ipv6_hdr->src, &iid)) {\n                /* 0 bits. The address is derived from link-layer address */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_L2;\n                addr_comp = true;\n            }\n            else if ((byteorder_ntohl(ipv6_hdr->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(ipv6_hdr->src.u16[6]) == 0xfe00)) {\n                /* 16 bits. The address is derived using 16 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_16;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u16 + 7, 2);\n                inline_pos += 2;\n                addr_comp = true;\n            }\n            else {\n                /* 64 bits. The address is derived using 64 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_64;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u64 + 1, 8);\n                inline_pos += 8;\n                addr_comp = true;\n            }\n        }\n\n        if (!addr_comp) {\n            /* full address is carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n            memcpy(iphc_hdr + inline_pos, &ipv6_hdr->src, 16);\n            inline_pos += 16;\n        }\n    }\n\n    addr_comp = false;\n\n    /* M: Multicast compression */\n    if (ipv6_addr_is_multicast(&(ipv6_hdr->dst))) {\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_M;\n\n        /* if multicast address is of format ffXX::XXXX:XXXX:XXXX */\n        if ((ipv6_hdr->dst.u16[1].u16 == 0) &&\n            (ipv6_hdr->dst.u32[1].u32 == 0) &&\n            (ipv6_hdr->dst.u16[4].u16 == 0)) {\n            /* if multicast address is of format ff02::XX */\n            if ((ipv6_hdr->dst.u8[1] == 0x02) &&\n                (ipv6_hdr->dst.u32[2].u32 == 0) &&\n                (ipv6_hdr->dst.u16[6].u16 == 0) &&\n                (ipv6_hdr->dst.u8[14] == 0)) {\n                /* 8 bits. The address is derived using 8 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_8;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[15];\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX */\n            else if ((ipv6_hdr->dst.u16[5].u16 == 0) &&\n                     (ipv6_hdr->dst.u8[12] == 0)) {\n                /* 32 bits. The address is derived using 32 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_32;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 13, 3);\n                inline_pos += 3;\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX:XXXX */\n            else if (ipv6_hdr->dst.u8[10] == 0) {\n                /* 48 bits. The address is derived using 48 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_48;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 11, 5);\n                inline_pos += 5;\n                addr_comp = true;\n            }\n        }\n        /* try unicast prefix based compression */\n        else {\n            gnrc_sixlowpan_ctx_t *ctx;\n            ipv6_addr_t unicast_prefix;\n            unicast_prefix.u16[0] = ipv6_hdr->dst.u16[2];\n            unicast_prefix.u16[1] = ipv6_hdr->dst.u16[3];\n            unicast_prefix.u16[2] = ipv6_hdr->dst.u16[4];\n            unicast_prefix.u16[3] = ipv6_hdr->dst.u16[5];\n\n            ctx = gnrc_sixlowpan_ctx_lookup_addr(&unicast_prefix);\n\n            if ((ctx != NULL) && (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP) &&\n                (ctx->prefix_len == ipv6_hdr->dst.u8[3])) {\n                /* Unicast prefix based IPv6 multicast address\n                 * (https://tools.ietf.org/html/rfc3306) with given context\n                 * for unicast prefix -> context based compression */\n                iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n                if ((ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0) {\n                    iphc_hdr[CID_EXT_IDX] |= (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n                }\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[2];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u16 + 6, 4);\n                inline_pos += 4;\n                addr_comp = true;\n            }\n        }\n    }\n    else if (((dst_ctx != NULL) ||\n              ipv6_addr_is_link_local(&ipv6_hdr->dst)) && (netif_hdr->dst_l2addr_len > 0)) {\n        eui64_t iid;\n\n        if (dst_ctx != NULL) {\n            /* stateful destination address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n\n            if (((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= (dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(iface, netif_hdr, &iid) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((ipv6_hdr->dst.u64[1].u64 == iid.uint64.u64) ||\n            _context_overlaps_iid(dst_ctx, &(ipv6_hdr->dst), &iid)) {\n            /* 0 bits. The address is derived using the link-layer address */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_L2;\n            addr_comp = true;\n        }\n        else if ((byteorder_ntohl(ipv6_hdr->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(ipv6_hdr->dst.u16[6]) == 0xfe00)) {\n            /* 16 bits. The address is derived using 16 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_16;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u16[7]), 2);\n            inline_pos += 2;\n            addr_comp = true;\n        }\n        else {\n            /* 64 bits. The address is derived using 64 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_64;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u8[8]), 8);\n            inline_pos += 8;\n            addr_comp = true;\n        }\n    }\n\n    if (!addr_comp) {\n        /* full destination address is carried inline */\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n        memcpy(iphc_hdr + inline_pos, &ipv6_hdr->dst, 16);\n        inline_pos += 16;\n    }\n\n    return inline_pos;\n}",
  "abstract_func_before": "static size_t _iphc_ipv6_encode(gnrc_pktsnip_t *VAR_0,\n                                const gnrc_netif_hdr_t *VAR_1,\n                                gnrc_netif_t *VAR_2,\n                                uint8_t *VAR_3)\n{\n    gnrc_sixlowpan_ctx_t *VAR_4 = NULL, *VAR_5 = NULL;\n    ipv6_hdr_t *VAR_6 = VAR_0->next->data;\n    bool VAR_7 = false;\n    uint16_t VAR_8 = VAR_9;\n\n    assert(VAR_2 != NULL);\n\n    /* COMMENT_0 */\n    VAR_3[VAR_10] = VAR_11;\n    VAR_3[VAR_12] = 0;\n\n    /* COMMENT_1 */\n    if (!ipv6_addr_is_unspecified(&(VAR_6->src))) {\n        VAR_4 = gnrc_sixlowpan_ctx_lookup_addr(&(VAR_6->src));\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        if (VAR_4 && !(VAR_4->flags_id & VAR_13)) {\n            VAR_4 = NULL;\n        }\n        /* COMMENT_4 */\n        if (VAR_4 &&\n            ipv6_addr_match_prefix(&VAR_4->prefix, &VAR_6->src) < VAR_14) {\n            VAR_4 = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&VAR_6->dst)) {\n        VAR_5 = gnrc_sixlowpan_ctx_lookup_addr(&(VAR_6->dst));\n        /* COMMENT_5 */\n        /* COMMENT_3 */\n        if (VAR_5 && !(VAR_5->flags_id & VAR_13)) {\n            VAR_5 = NULL;\n        }\n        /* COMMENT_4 */\n        if (VAR_5 &&\n            ipv6_addr_match_prefix(&VAR_5->prefix, &VAR_6->dst) < VAR_14) {\n            VAR_5 = NULL;\n        }\n    }\n\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    if (((VAR_4 != NULL) &&\n            ((VAR_4->flags_id & VAR_15) != 0)) ||\n        ((VAR_5 != NULL) &&\n            ((VAR_5->flags_id & VAR_15) != 0))) {\n        /* COMMENT_8 */\n        VAR_3[VAR_12] |= VAR_16;\n        VAR_3[VAR_17] = 0;\n\n        /* COMMENT_9 */\n        VAR_8 += VAR_18;\n    }\n\n    /* COMMENT_10 */\n    if (ipv6_hdr_get_fl(VAR_6) == 0) {\n        if (ipv6_hdr_get_tc(VAR_6) == 0) {\n            /* COMMENT_11 */\n            VAR_3[VAR_10] |= VAR_19;\n        }\n        else {\n            /* COMMENT_12 */\n            VAR_3[VAR_10] |= VAR_20;\n            VAR_3[VAR_8++] = ipv6_hdr_get_tc(VAR_6);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(VAR_6) == 0) {\n            /* COMMENT_13 */\n            VAR_3[VAR_10] |= VAR_21;\n            VAR_3[VAR_8++] = (uint8_t)((ipv6_hdr_get_tc_ecn(VAR_6) << 6) |\n                                               ((ipv6_hdr_get_fl(VAR_6) & 0x000f0000) >> 16));\n        }\n        else {\n            /* COMMENT_14 */\n            VAR_3[VAR_10] |= VAR_22;\n            VAR_3[VAR_8++] = ipv6_hdr_get_tc(VAR_6);\n            VAR_3[VAR_8++] = (uint8_t)((ipv6_hdr_get_fl(VAR_6) & 0x000f0000) >> 16);\n        }\n\n        /* COMMENT_15 */\n        VAR_3[VAR_8++] = (uint8_t)((ipv6_hdr_get_fl(VAR_6) & 0x0000ff00) >> 8);\n        VAR_3[VAR_8++] = (uint8_t)(ipv6_hdr_get_fl(VAR_6) & 0x000000ff);\n    }\n\n    /* COMMENT_16 */\n    if (_compressible_nh(VAR_6->nh)) {\n        VAR_3[VAR_10] |= VAR_23;\n    }\n    else {\n        VAR_3[VAR_8++] = VAR_6->nh;\n    }\n\n    /* COMMENT_17 */\n    switch (VAR_6->hl) {\n        case 1:\n            VAR_3[VAR_10] |= VAR_24;\n            break;\n\n        case 64:\n            VAR_3[VAR_10] |= VAR_25;\n            break;\n\n        case 255:\n            VAR_3[VAR_10] |= VAR_26;\n            break;\n\n        default:\n            VAR_3[VAR_10] |= VAR_27;\n            VAR_3[VAR_8++] = VAR_6->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(VAR_6->src))) {\n        VAR_3[VAR_12] |= VAR_28;\n    }\n    else {\n        if (VAR_4 != NULL) {\n            /* COMMENT_18 */\n            VAR_3[VAR_12] |= VAR_29;\n\n            if (((VAR_4->flags_id & VAR_15) != 0)) {\n                VAR_3[VAR_17] |= ((VAR_4->flags_id & VAR_15) << 4);\n            }\n        }\n\n        if ((VAR_4 != NULL) || ipv6_addr_is_link_local(&(VAR_6->src))) {\n            eui64_t VAR_30;\n            VAR_30.uint64.u64 = 0;\n\n            gnrc_netif_acquire(VAR_2);\n            if (gnrc_netif_ipv6_get_iid(VAR_2, &VAR_30) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(VAR_2);\n                return 0;\n            }\n            gnrc_netif_release(VAR_2);\n\n            if ((VAR_6->src.u64[1].u64 == VAR_30.uint64.u64) ||\n                _context_overlaps_iid(VAR_4, &VAR_6->src, &VAR_30)) {\n                /* COMMENT_19 */\n                VAR_3[VAR_12] |= VAR_31;\n                VAR_7 = true;\n            }\n            else if ((byteorder_ntohl(VAR_6->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(VAR_6->src.u16[6]) == 0xfe00)) {\n                /* COMMENT_20 */\n                VAR_3[VAR_12] |= VAR_32;\n                memcpy(VAR_3 + VAR_8, VAR_6->src.u16 + 7, 2);\n                VAR_8 += 2;\n                VAR_7 = true;\n            }\n            else {\n                /* COMMENT_21 */\n                VAR_3[VAR_12] |= VAR_33;\n                memcpy(VAR_3 + VAR_8, VAR_6->src.u64 + 1, 8);\n                VAR_8 += 8;\n                VAR_7 = true;\n            }\n        }\n\n        if (!VAR_7) {\n            /* COMMENT_22 */\n            VAR_3[VAR_12] |= VAR_34;\n            memcpy(VAR_3 + VAR_8, &VAR_6->src, 16);\n            VAR_8 += 16;\n        }\n    }\n\n    VAR_7 = false;\n\n    /* COMMENT_23 */\n    if (ipv6_addr_is_multicast(&(VAR_6->dst))) {\n        VAR_3[VAR_12] |= VAR_35;\n\n        /* COMMENT_24 */\n        if ((VAR_6->dst.u16[1].u16 == 0) &&\n            (VAR_6->dst.u32[1].u32 == 0) &&\n            (VAR_6->dst.u16[4].u16 == 0)) {\n            /* COMMENT_25 */\n            if ((VAR_6->dst.u8[1] == 0x02) &&\n                (VAR_6->dst.u32[2].u32 == 0) &&\n                (VAR_6->dst.u16[6].u16 == 0) &&\n                (VAR_6->dst.u8[14] == 0)) {\n                /* COMMENT_26 */\n                VAR_3[VAR_12] |= VAR_36;\n                VAR_3[VAR_8++] = VAR_6->dst.u8[15];\n                VAR_7 = true;\n            }\n            /* COMMENT_27 */\n            else if ((VAR_6->dst.u16[5].u16 == 0) &&\n                     (VAR_6->dst.u8[12] == 0)) {\n                /* COMMENT_28 */\n                VAR_3[VAR_12] |= VAR_37;\n                VAR_3[VAR_8++] = VAR_6->dst.u8[1];\n                memcpy(VAR_3 + VAR_8, VAR_6->dst.u8 + 13, 3);\n                VAR_8 += 3;\n                VAR_7 = true;\n            }\n            /* COMMENT_29 */\n            else if (VAR_6->dst.u8[10] == 0) {\n                /* COMMENT_30 */\n                VAR_3[VAR_12] |= VAR_38;\n                VAR_3[VAR_8++] = VAR_6->dst.u8[1];\n                memcpy(VAR_3 + VAR_8, VAR_6->dst.u8 + 11, 5);\n                VAR_8 += 5;\n                VAR_7 = true;\n            }\n        }\n        /* COMMENT_31 */\n        else {\n            gnrc_sixlowpan_ctx_t *VAR_39;\n            ipv6_addr_t VAR_40;\n            VAR_40.u16[0] = VAR_6->dst.u16[2];\n            VAR_40.u16[1] = VAR_6->dst.u16[3];\n            VAR_40.u16[2] = VAR_6->dst.u16[4];\n            VAR_40.u16[3] = VAR_6->dst.u16[5];\n\n            VAR_39 = gnrc_sixlowpan_ctx_lookup_addr(&VAR_40);\n\n            if ((VAR_39 != NULL) && (VAR_39->flags_id & VAR_13) &&\n                (VAR_39->prefix_len == VAR_6->dst.u8[3])) {\n                /* COMMENT_32 */\n                                                                           \n                                                                     \n                VAR_3[VAR_12] |= VAR_41;\n                if ((VAR_39->flags_id & VAR_15) != 0) {\n                    VAR_3[VAR_17] |= (VAR_39->flags_id & VAR_15);\n                }\n                VAR_3[VAR_8++] = VAR_6->dst.u8[1];\n                VAR_3[VAR_8++] = VAR_6->dst.u8[2];\n                memcpy(VAR_3 + VAR_8, VAR_6->dst.u16 + 6, 4);\n                VAR_8 += 4;\n                VAR_7 = true;\n            }\n        }\n    }\n    else if (((VAR_5 != NULL) ||\n              ipv6_addr_is_link_local(&VAR_6->dst)) && (VAR_1->dst_l2addr_len > 0)) {\n        eui64_t VAR_30;\n\n        if (VAR_5 != NULL) {\n            /* COMMENT_35 */\n            VAR_3[VAR_12] |= VAR_41;\n\n            if (((VAR_5->flags_id & VAR_15) != 0)) {\n                VAR_3[VAR_17] |= (VAR_5->flags_id & VAR_15);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(VAR_2, VAR_1, &VAR_30) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((VAR_6->dst.u64[1].u64 == VAR_30.uint64.u64) ||\n            _context_overlaps_iid(VAR_5, &(VAR_6->dst), &VAR_30)) {\n            /* COMMENT_36 */\n            VAR_3[VAR_12] |= VAR_42;\n            VAR_7 = true;\n        }\n        else if ((byteorder_ntohl(VAR_6->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(VAR_6->dst.u16[6]) == 0xfe00)) {\n            /* COMMENT_20 */\n            VAR_3[VAR_12] |= VAR_43;\n            memcpy(&(VAR_3[VAR_8]), &(VAR_6->dst.u16[7]), 2);\n            VAR_8 += 2;\n            VAR_7 = true;\n        }\n        else {\n            /* COMMENT_21 */\n            VAR_3[VAR_12] |= VAR_44;\n            memcpy(&(VAR_3[VAR_8]), &(VAR_6->dst.u8[8]), 8);\n            VAR_8 += 8;\n            VAR_7 = true;\n        }\n    }\n\n    if (!VAR_7) {\n        /* COMMENT_37 */\n        VAR_3[VAR_12] |= VAR_34;\n        memcpy(VAR_3 + VAR_8, &VAR_6->dst, 16);\n        VAR_8 += 16;\n    }\n\n    return VAR_8;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/c9d7863e5664a169035038628029bb07e090c5ff/gnrc_sixlowpan_iphc.c/vul/before/0.json",
  "func": "static size_t _iphc_ipv6_encode(gnrc_pktsnip_t *pkt,\n                                const gnrc_netif_hdr_t *netif_hdr,\n                                gnrc_netif_t *iface,\n                                uint8_t *iphc_hdr)\n{\n    gnrc_sixlowpan_ctx_t *src_ctx = NULL, *dst_ctx = NULL;\n    ipv6_hdr_t *ipv6_hdr;\n    bool addr_comp = false;\n    uint16_t inline_pos = SIXLOWPAN_IPHC_HDR_LEN;\n\n    assert(iface != NULL);\n\n    if (pkt->next == NULL) {\n        DEBUG(\"6lo iphc: packet missing header\\n\");\n        return 0;\n    }\n    ipv6_hdr = pkt->next->data;\n\n    /* set initial dispatch value*/\n    iphc_hdr[IPHC1_IDX] = SIXLOWPAN_IPHC1_DISP;\n    iphc_hdr[IPHC2_IDX] = 0;\n\n    /* check for available contexts */\n    if (!ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        src_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->src));\n        /* do not use source context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (src_ctx && !(src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            src_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (src_ctx &&\n            ipv6_addr_match_prefix(&src_ctx->prefix, &ipv6_hdr->src) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            src_ctx = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&ipv6_hdr->dst)) {\n        dst_ctx = gnrc_sixlowpan_ctx_lookup_addr(&(ipv6_hdr->dst));\n        /* do not use destination context for compression if */\n        /* GNRC_SIXLOWPAN_CTX_FLAGS_COMP is not set */\n        if (dst_ctx && !(dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP)) {\n            dst_ctx = NULL;\n        }\n        /* prefix bits not covered by context information must be zero */\n        if (dst_ctx &&\n            ipv6_addr_match_prefix(&dst_ctx->prefix, &ipv6_hdr->dst) < SIXLOWPAN_IPHC_PREFIX_LEN) {\n            dst_ctx = NULL;\n        }\n    }\n\n    /* if contexts available and both != 0 */\n    /* since this moves inline_pos we have to do this ahead*/\n    if (((src_ctx != NULL) &&\n            ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) ||\n        ((dst_ctx != NULL) &&\n            ((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0))) {\n        /* add context identifier extension */\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_CID_EXT;\n        iphc_hdr[CID_EXT_IDX] = 0;\n\n        /* move position to behind CID extension */\n        inline_pos += SIXLOWPAN_IPHC_CID_EXT_LEN;\n    }\n\n    /* compress flow label and traffic class */\n    if (ipv6_hdr_get_fl(ipv6_hdr) == 0) {\n        if (ipv6_hdr_get_tc(ipv6_hdr) == 0) {\n            /* elide both traffic class and flow label */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_ELIDE;\n        }\n        else {\n            /* elide flow label, traffic class (ECN + DSCP) inline (1 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(ipv6_hdr) == 0) {\n            /* elide DSCP, ECN + 2-bit pad + flow label inline (3 byte) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_FL;\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_tc_ecn(ipv6_hdr) << 6) |\n                                               ((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16));\n        }\n        else {\n            /* ECN + DSCP + 4-bit pad + flow label (4 bytes) */\n            iphc_hdr[IPHC1_IDX] |= IPHC_TF_ECN_DSCP_FL;\n            iphc_hdr[inline_pos++] = ipv6_hdr_get_tc(ipv6_hdr);\n            iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x000f0000) >> 16);\n        }\n\n        /* copy remaining bytes of flow label */\n        iphc_hdr[inline_pos++] = (uint8_t)((ipv6_hdr_get_fl(ipv6_hdr) & 0x0000ff00) >> 8);\n        iphc_hdr[inline_pos++] = (uint8_t)(ipv6_hdr_get_fl(ipv6_hdr) & 0x000000ff);\n    }\n\n    /* check for compressible next header */\n    if (_compressible_nh(ipv6_hdr->nh)) {\n        iphc_hdr[IPHC1_IDX] |= SIXLOWPAN_IPHC1_NH;\n    }\n    else {\n        iphc_hdr[inline_pos++] = ipv6_hdr->nh;\n    }\n\n    /* compress hop limit */\n    switch (ipv6_hdr->hl) {\n        case 1:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_1;\n            break;\n\n        case 64:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_64;\n            break;\n\n        case 255:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_255;\n            break;\n\n        default:\n            iphc_hdr[IPHC1_IDX] |= IPHC_HL_INLINE;\n            iphc_hdr[inline_pos++] = ipv6_hdr->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(ipv6_hdr->src))) {\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_UNSPEC;\n    }\n    else {\n        if (src_ctx != NULL) {\n            /* stateful source address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_SAC;\n\n            if (((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= ((src_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) << 4);\n            }\n        }\n\n        if ((src_ctx != NULL) || ipv6_addr_is_link_local(&(ipv6_hdr->src))) {\n            eui64_t iid;\n            iid.uint64.u64 = 0;\n\n            gnrc_netif_acquire(iface);\n            if (gnrc_netif_ipv6_get_iid(iface, &iid) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(iface);\n                return 0;\n            }\n            gnrc_netif_release(iface);\n\n            if ((ipv6_hdr->src.u64[1].u64 == iid.uint64.u64) ||\n                _context_overlaps_iid(src_ctx, &ipv6_hdr->src, &iid)) {\n                /* 0 bits. The address is derived from link-layer address */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_L2;\n                addr_comp = true;\n            }\n            else if ((byteorder_ntohl(ipv6_hdr->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(ipv6_hdr->src.u16[6]) == 0xfe00)) {\n                /* 16 bits. The address is derived using 16 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_16;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u16 + 7, 2);\n                inline_pos += 2;\n                addr_comp = true;\n            }\n            else {\n                /* 64 bits. The address is derived using 64 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_64;\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->src.u64 + 1, 8);\n                inline_pos += 8;\n                addr_comp = true;\n            }\n        }\n\n        if (!addr_comp) {\n            /* full address is carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n            memcpy(iphc_hdr + inline_pos, &ipv6_hdr->src, 16);\n            inline_pos += 16;\n        }\n    }\n\n    addr_comp = false;\n\n    /* M: Multicast compression */\n    if (ipv6_addr_is_multicast(&(ipv6_hdr->dst))) {\n        iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_M;\n\n        /* if multicast address is of format ffXX::XXXX:XXXX:XXXX */\n        if ((ipv6_hdr->dst.u16[1].u16 == 0) &&\n            (ipv6_hdr->dst.u32[1].u32 == 0) &&\n            (ipv6_hdr->dst.u16[4].u16 == 0)) {\n            /* if multicast address is of format ff02::XX */\n            if ((ipv6_hdr->dst.u8[1] == 0x02) &&\n                (ipv6_hdr->dst.u32[2].u32 == 0) &&\n                (ipv6_hdr->dst.u16[6].u16 == 0) &&\n                (ipv6_hdr->dst.u8[14] == 0)) {\n                /* 8 bits. The address is derived using 8 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_8;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[15];\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX */\n            else if ((ipv6_hdr->dst.u16[5].u16 == 0) &&\n                     (ipv6_hdr->dst.u8[12] == 0)) {\n                /* 32 bits. The address is derived using 32 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_32;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 13, 3);\n                inline_pos += 3;\n                addr_comp = true;\n            }\n            /* if multicast address is of format ffXX::XX:XXXX:XXXX */\n            else if (ipv6_hdr->dst.u8[10] == 0) {\n                /* 48 bits. The address is derived using 48 bits carried inline */\n                iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_M_48;\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u8 + 11, 5);\n                inline_pos += 5;\n                addr_comp = true;\n            }\n        }\n        /* try unicast prefix based compression */\n        else {\n            gnrc_sixlowpan_ctx_t *ctx;\n            ipv6_addr_t unicast_prefix;\n            unicast_prefix.u16[0] = ipv6_hdr->dst.u16[2];\n            unicast_prefix.u16[1] = ipv6_hdr->dst.u16[3];\n            unicast_prefix.u16[2] = ipv6_hdr->dst.u16[4];\n            unicast_prefix.u16[3] = ipv6_hdr->dst.u16[5];\n\n            ctx = gnrc_sixlowpan_ctx_lookup_addr(&unicast_prefix);\n\n            if ((ctx != NULL) && (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_COMP) &&\n                (ctx->prefix_len == ipv6_hdr->dst.u8[3])) {\n                /* Unicast prefix based IPv6 multicast address\n                 * (https://tools.ietf.org/html/rfc3306) with given context\n                 * for unicast prefix -> context based compression */\n                iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n                if ((ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0) {\n                    iphc_hdr[CID_EXT_IDX] |= (ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n                }\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[1];\n                iphc_hdr[inline_pos++] = ipv6_hdr->dst.u8[2];\n                memcpy(iphc_hdr + inline_pos, ipv6_hdr->dst.u16 + 6, 4);\n                inline_pos += 4;\n                addr_comp = true;\n            }\n        }\n    }\n    else if (((dst_ctx != NULL) ||\n              ipv6_addr_is_link_local(&ipv6_hdr->dst)) && (netif_hdr->dst_l2addr_len > 0)) {\n        eui64_t iid;\n\n        if (dst_ctx != NULL) {\n            /* stateful destination address compression */\n            iphc_hdr[IPHC2_IDX] |= SIXLOWPAN_IPHC2_DAC;\n\n            if (((dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK) != 0)) {\n                iphc_hdr[CID_EXT_IDX] |= (dst_ctx->flags_id & GNRC_SIXLOWPAN_CTX_FLAGS_CID_MASK);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(iface, netif_hdr, &iid) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((ipv6_hdr->dst.u64[1].u64 == iid.uint64.u64) ||\n            _context_overlaps_iid(dst_ctx, &(ipv6_hdr->dst), &iid)) {\n            /* 0 bits. The address is derived using the link-layer address */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_L2;\n            addr_comp = true;\n        }\n        else if ((byteorder_ntohl(ipv6_hdr->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(ipv6_hdr->dst.u16[6]) == 0xfe00)) {\n            /* 16 bits. The address is derived using 16 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_16;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u16[7]), 2);\n            inline_pos += 2;\n            addr_comp = true;\n        }\n        else {\n            /* 64 bits. The address is derived using 64 bits carried inline */\n            iphc_hdr[IPHC2_IDX] |= IPHC_M_DAC_DAM_U_64;\n            memcpy(&(iphc_hdr[inline_pos]), &(ipv6_hdr->dst.u8[8]), 8);\n            inline_pos += 8;\n            addr_comp = true;\n        }\n    }\n\n    if (!addr_comp) {\n        /* full destination address is carried inline */\n        iphc_hdr[IPHC2_IDX] |= IPHC_SAC_SAM_FULL;\n        memcpy(iphc_hdr + inline_pos, &ipv6_hdr->dst, 16);\n        inline_pos += 16;\n    }\n\n    return inline_pos;\n}",
  "abstract_func": "static size_t _iphc_ipv6_encode(gnrc_pktsnip_t *VAR_0,\n                                const gnrc_netif_hdr_t *VAR_1,\n                                gnrc_netif_t *VAR_2,\n                                uint8_t *VAR_3)\n{\n    gnrc_sixlowpan_ctx_t *VAR_4 = NULL, *VAR_5 = NULL;\n    ipv6_hdr_t *VAR_6;\n    bool VAR_7 = false;\n    uint16_t VAR_8 = VAR_9;\n\n    assert(VAR_2 != NULL);\n\n    if (VAR_0->next == NULL) {\n        DEBUG(\"6lo iphc: packet missing header\\n\");\n        return 0;\n    }\n    VAR_6 = VAR_0->next->data;\n\n    /* COMMENT_0 */\n    VAR_3[VAR_10] = VAR_11;\n    VAR_3[VAR_12] = 0;\n\n    /* COMMENT_1 */\n    if (!ipv6_addr_is_unspecified(&(VAR_6->src))) {\n        VAR_4 = gnrc_sixlowpan_ctx_lookup_addr(&(VAR_6->src));\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        if (VAR_4 && !(VAR_4->flags_id & VAR_13)) {\n            VAR_4 = NULL;\n        }\n        /* COMMENT_4 */\n        if (VAR_4 &&\n            ipv6_addr_match_prefix(&VAR_4->prefix, &VAR_6->src) < VAR_14) {\n            VAR_4 = NULL;\n        }\n    }\n\n    if (!ipv6_addr_is_multicast(&VAR_6->dst)) {\n        VAR_5 = gnrc_sixlowpan_ctx_lookup_addr(&(VAR_6->dst));\n        /* COMMENT_5 */\n        /* COMMENT_3 */\n        if (VAR_5 && !(VAR_5->flags_id & VAR_13)) {\n            VAR_5 = NULL;\n        }\n        /* COMMENT_4 */\n        if (VAR_5 &&\n            ipv6_addr_match_prefix(&VAR_5->prefix, &VAR_6->dst) < VAR_14) {\n            VAR_5 = NULL;\n        }\n    }\n\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    if (((VAR_4 != NULL) &&\n            ((VAR_4->flags_id & VAR_15) != 0)) ||\n        ((VAR_5 != NULL) &&\n            ((VAR_5->flags_id & VAR_15) != 0))) {\n        /* COMMENT_8 */\n        VAR_3[VAR_12] |= VAR_16;\n        VAR_3[VAR_17] = 0;\n\n        /* COMMENT_9 */\n        VAR_8 += VAR_18;\n    }\n\n    /* COMMENT_10 */\n    if (ipv6_hdr_get_fl(VAR_6) == 0) {\n        if (ipv6_hdr_get_tc(VAR_6) == 0) {\n            /* COMMENT_11 */\n            VAR_3[VAR_10] |= VAR_19;\n        }\n        else {\n            /* COMMENT_12 */\n            VAR_3[VAR_10] |= VAR_20;\n            VAR_3[VAR_8++] = ipv6_hdr_get_tc(VAR_6);\n        }\n    }\n    else {\n        if (ipv6_hdr_get_tc_dscp(VAR_6) == 0) {\n            /* COMMENT_13 */\n            VAR_3[VAR_10] |= VAR_21;\n            VAR_3[VAR_8++] = (uint8_t)((ipv6_hdr_get_tc_ecn(VAR_6) << 6) |\n                                               ((ipv6_hdr_get_fl(VAR_6) & 0x000f0000) >> 16));\n        }\n        else {\n            /* COMMENT_14 */\n            VAR_3[VAR_10] |= VAR_22;\n            VAR_3[VAR_8++] = ipv6_hdr_get_tc(VAR_6);\n            VAR_3[VAR_8++] = (uint8_t)((ipv6_hdr_get_fl(VAR_6) & 0x000f0000) >> 16);\n        }\n\n        /* COMMENT_15 */\n        VAR_3[VAR_8++] = (uint8_t)((ipv6_hdr_get_fl(VAR_6) & 0x0000ff00) >> 8);\n        VAR_3[VAR_8++] = (uint8_t)(ipv6_hdr_get_fl(VAR_6) & 0x000000ff);\n    }\n\n    /* COMMENT_16 */\n    if (_compressible_nh(VAR_6->nh)) {\n        VAR_3[VAR_10] |= VAR_23;\n    }\n    else {\n        VAR_3[VAR_8++] = VAR_6->nh;\n    }\n\n    /* COMMENT_17 */\n    switch (VAR_6->hl) {\n        case 1:\n            VAR_3[VAR_10] |= VAR_24;\n            break;\n\n        case 64:\n            VAR_3[VAR_10] |= VAR_25;\n            break;\n\n        case 255:\n            VAR_3[VAR_10] |= VAR_26;\n            break;\n\n        default:\n            VAR_3[VAR_10] |= VAR_27;\n            VAR_3[VAR_8++] = VAR_6->hl;\n            break;\n    }\n\n    if (ipv6_addr_is_unspecified(&(VAR_6->src))) {\n        VAR_3[VAR_12] |= VAR_28;\n    }\n    else {\n        if (VAR_4 != NULL) {\n            /* COMMENT_18 */\n            VAR_3[VAR_12] |= VAR_29;\n\n            if (((VAR_4->flags_id & VAR_15) != 0)) {\n                VAR_3[VAR_17] |= ((VAR_4->flags_id & VAR_15) << 4);\n            }\n        }\n\n        if ((VAR_4 != NULL) || ipv6_addr_is_link_local(&(VAR_6->src))) {\n            eui64_t VAR_30;\n            VAR_30.uint64.u64 = 0;\n\n            gnrc_netif_acquire(VAR_2);\n            if (gnrc_netif_ipv6_get_iid(VAR_2, &VAR_30) < 0) {\n                DEBUG(\"6lo iphc: could not get interface's IID\\n\");\n                gnrc_netif_release(VAR_2);\n                return 0;\n            }\n            gnrc_netif_release(VAR_2);\n\n            if ((VAR_6->src.u64[1].u64 == VAR_30.uint64.u64) ||\n                _context_overlaps_iid(VAR_4, &VAR_6->src, &VAR_30)) {\n                /* COMMENT_19 */\n                VAR_3[VAR_12] |= VAR_31;\n                VAR_7 = true;\n            }\n            else if ((byteorder_ntohl(VAR_6->src.u32[2]) == 0x000000ff) &&\n                     (byteorder_ntohs(VAR_6->src.u16[6]) == 0xfe00)) {\n                /* COMMENT_20 */\n                VAR_3[VAR_12] |= VAR_32;\n                memcpy(VAR_3 + VAR_8, VAR_6->src.u16 + 7, 2);\n                VAR_8 += 2;\n                VAR_7 = true;\n            }\n            else {\n                /* COMMENT_21 */\n                VAR_3[VAR_12] |= VAR_33;\n                memcpy(VAR_3 + VAR_8, VAR_6->src.u64 + 1, 8);\n                VAR_8 += 8;\n                VAR_7 = true;\n            }\n        }\n\n        if (!VAR_7) {\n            /* COMMENT_22 */\n            VAR_3[VAR_12] |= VAR_34;\n            memcpy(VAR_3 + VAR_8, &VAR_6->src, 16);\n            VAR_8 += 16;\n        }\n    }\n\n    VAR_7 = false;\n\n    /* COMMENT_23 */\n    if (ipv6_addr_is_multicast(&(VAR_6->dst))) {\n        VAR_3[VAR_12] |= VAR_35;\n\n        /* COMMENT_24 */\n        if ((VAR_6->dst.u16[1].u16 == 0) &&\n            (VAR_6->dst.u32[1].u32 == 0) &&\n            (VAR_6->dst.u16[4].u16 == 0)) {\n            /* COMMENT_25 */\n            if ((VAR_6->dst.u8[1] == 0x02) &&\n                (VAR_6->dst.u32[2].u32 == 0) &&\n                (VAR_6->dst.u16[6].u16 == 0) &&\n                (VAR_6->dst.u8[14] == 0)) {\n                /* COMMENT_26 */\n                VAR_3[VAR_12] |= VAR_36;\n                VAR_3[VAR_8++] = VAR_6->dst.u8[15];\n                VAR_7 = true;\n            }\n            /* COMMENT_27 */\n            else if ((VAR_6->dst.u16[5].u16 == 0) &&\n                     (VAR_6->dst.u8[12] == 0)) {\n                /* COMMENT_28 */\n                VAR_3[VAR_12] |= VAR_37;\n                VAR_3[VAR_8++] = VAR_6->dst.u8[1];\n                memcpy(VAR_3 + VAR_8, VAR_6->dst.u8 + 13, 3);\n                VAR_8 += 3;\n                VAR_7 = true;\n            }\n            /* COMMENT_29 */\n            else if (VAR_6->dst.u8[10] == 0) {\n                /* COMMENT_30 */\n                VAR_3[VAR_12] |= VAR_38;\n                VAR_3[VAR_8++] = VAR_6->dst.u8[1];\n                memcpy(VAR_3 + VAR_8, VAR_6->dst.u8 + 11, 5);\n                VAR_8 += 5;\n                VAR_7 = true;\n            }\n        }\n        /* COMMENT_31 */\n        else {\n            gnrc_sixlowpan_ctx_t *VAR_39;\n            ipv6_addr_t VAR_40;\n            VAR_40.u16[0] = VAR_6->dst.u16[2];\n            VAR_40.u16[1] = VAR_6->dst.u16[3];\n            VAR_40.u16[2] = VAR_6->dst.u16[4];\n            VAR_40.u16[3] = VAR_6->dst.u16[5];\n\n            VAR_39 = gnrc_sixlowpan_ctx_lookup_addr(&VAR_40);\n\n            if ((VAR_39 != NULL) && (VAR_39->flags_id & VAR_13) &&\n                (VAR_39->prefix_len == VAR_6->dst.u8[3])) {\n                /* COMMENT_32 */\n                                                                           \n                                                                     \n                VAR_3[VAR_12] |= VAR_41;\n                if ((VAR_39->flags_id & VAR_15) != 0) {\n                    VAR_3[VAR_17] |= (VAR_39->flags_id & VAR_15);\n                }\n                VAR_3[VAR_8++] = VAR_6->dst.u8[1];\n                VAR_3[VAR_8++] = VAR_6->dst.u8[2];\n                memcpy(VAR_3 + VAR_8, VAR_6->dst.u16 + 6, 4);\n                VAR_8 += 4;\n                VAR_7 = true;\n            }\n        }\n    }\n    else if (((VAR_5 != NULL) ||\n              ipv6_addr_is_link_local(&VAR_6->dst)) && (VAR_1->dst_l2addr_len > 0)) {\n        eui64_t VAR_30;\n\n        if (VAR_5 != NULL) {\n            /* COMMENT_35 */\n            VAR_3[VAR_12] |= VAR_41;\n\n            if (((VAR_5->flags_id & VAR_15) != 0)) {\n                VAR_3[VAR_17] |= (VAR_5->flags_id & VAR_15);\n            }\n        }\n\n        if (gnrc_netif_hdr_ipv6_iid_from_dst(VAR_2, VAR_1, &VAR_30) < 0) {\n            DEBUG(\"6lo iphc: could not get destination's IID\\n\");\n            return 0;\n        }\n\n        if ((VAR_6->dst.u64[1].u64 == VAR_30.uint64.u64) ||\n            _context_overlaps_iid(VAR_5, &(VAR_6->dst), &VAR_30)) {\n            /* COMMENT_36 */\n            VAR_3[VAR_12] |= VAR_42;\n            VAR_7 = true;\n        }\n        else if ((byteorder_ntohl(VAR_6->dst.u32[2]) == 0x000000ff) &&\n                 (byteorder_ntohs(VAR_6->dst.u16[6]) == 0xfe00)) {\n            /* COMMENT_20 */\n            VAR_3[VAR_12] |= VAR_43;\n            memcpy(&(VAR_3[VAR_8]), &(VAR_6->dst.u16[7]), 2);\n            VAR_8 += 2;\n            VAR_7 = true;\n        }\n        else {\n            /* COMMENT_21 */\n            VAR_3[VAR_12] |= VAR_44;\n            memcpy(&(VAR_3[VAR_8]), &(VAR_6->dst.u8[8]), 8);\n            VAR_8 += 8;\n            VAR_7 = true;\n        }\n    }\n\n    if (!VAR_7) {\n        /* COMMENT_37 */\n        VAR_3[VAR_12] |= VAR_34;\n        memcpy(VAR_3 + VAR_8, &VAR_6->dst, 16);\n        VAR_8 += 16;\n    }\n\n    return VAR_8;\n}",
  "func_graph_path": "RIOT-OS/RIOT/c9d7863e5664a169035038628029bb07e090c5ff/gnrc_sixlowpan_iphc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,11 +4,17 @@\n                                 uint8_t *iphc_hdr)\n {\n     gnrc_sixlowpan_ctx_t *src_ctx = NULL, *dst_ctx = NULL;\n-    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n+    ipv6_hdr_t *ipv6_hdr;\n     bool addr_comp = false;\n     uint16_t inline_pos = SIXLOWPAN_IPHC_HDR_LEN;\n \n     assert(iface != NULL);\n+\n+    if (pkt->next == NULL) {\n+        DEBUG(\"6lo iphc: packet missing header\\n\");\n+        return 0;\n+    }\n+    ipv6_hdr = pkt->next->data;\n \n     /* set initial dispatch value*/\n     iphc_hdr[IPHC1_IDX] = SIXLOWPAN_IPHC1_DISP;",
  "diff_line_info": {
    "deleted_lines": [
      "    ipv6_hdr_t *ipv6_hdr = pkt->next->data;"
    ],
    "added_lines": [
      "    ipv6_hdr_t *ipv6_hdr;",
      "",
      "    if (pkt->next == NULL) {",
      "        DEBUG(\"6lo iphc: packet missing header\\n\");",
      "        return 0;",
      "    }",
      "    ipv6_hdr = pkt->next->data;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/19678",
  "description": {
    "pr_info": {
      "title": "gnrc_sixlowpan_iphc: fix NULL pointer dereference",
      "number": 19678
    },
    "comment": [
      "<!--\r\nThe RIOT community cares a lot about code quality.\r\nTherefore, before describing what your contribution is about, we would like\r\nyou to make sure that your modifications are compliant with the RIOT\r\ncoding conventions, see https://github.com/RIOT-OS/RIOT/blob/master/CODING_CONVENTIONS.md.\r\n-->\r\n\r\n### Contribution description\r\nSee https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-r2pv-3jqc-vh7w.\r\n<!--\r\nPut here the description of your contribution:\r\n- describe which part(s) of RIOT is (are) involved\r\n- if it's a bug fix, describe the bug that it solves and how it is solved\r\n- you can also give more information to reviewers about how to test your changes\r\n-->\r\n\r\n\r\n### Testing procedure\r\n\r\n<!--\r\nDetails steps to test your contribution:\r\n- which test/example to compile for which board and is there a 'test' command\r\n- how to know that it was not working/available in master\r\n- the expected success test output\r\n-->\r\n\r\n\r\n### Issues/PRs references\r\n\r\n<!--\r\nExamples: Fixes #1234. See also #5678. Depends on PR #9876.\r\n\r\nPlease use keywords (e.g., fixes, resolve) with the links to the issues you\r\nresolved, this way they will be automatically closed when your pull request\r\nis merged. See https://help.github.com/articles/closing-issues-using-keywords/.\r\n-->\r\n",
      "### Murdock results\n\n:heavy_check_mark: [PASSED](https://ci.riot-os.org/details/3be43c81fbb24b2abe89a6e8a482e8e0)\n\nc9d7863e5664a169035038628029bb07e090c5ff gnrc_sixlowpan_iphc: fix NULL pointer dereference\n\n|  Success  |  Failures  |  Total  |  Runtime  |\n| :-------: | :--------: | :-----: | :-------: |\n| 6933 | 0 | 6933 | 13m:05s |\n\n\n#### Artifacts\n- [Documentation preview](https://ci.riot-os.org/results/3be43c81fbb24b2abe89a6e8a482e8e0/doc-preview/)\n",
      "bors merge",
      "bors cancel\r\nbors merge",
      "Canceled.",
      "Build failed (retrying...):\n  * [Murdock](https://ci.riot-os.org/details/921602a9417d44289c8d9e559aca3c65)",
      "`tests/drivers/servo` failed... Looks unrelated Oo",
      "It was a timeout during a long rust build, likely caused because cargo fetches are slow now. The exact same thing happened on a different worker before. I think it is caused by upstream repos being a bit slower now then they used to be. But I'd actually blame our lack of caching of remote resources in our CI.",
      "Github was very slow the past few days, but only from some ISPs. Maybe it's related.",
      "This PR was included in a batch that was canceled, it will be automatically retried",
      "  Build succeeded!\n\n  The publicly hosted instance of bors-ng is deprecated and will go away soon.\n\n  If you want to self-host your own instance, [instructions are here][instructions].\n  For more help, visit [the forum].\n\n  If you want to switch to GitHub's built-in merge queue, visit [their help page][gh].\n\n  [instructions]: https://github.com/bors-ng/bors-ng#how-to-set-up-your-own-real-instance\n  [the forum]: https://forum.bors.tech\n  [gh]: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue\n\n\n\n  * [Murdock](https://ci.riot-os.org/details/fb540a7fea3d482dbf15b594aaf08a39)\n  * [static-tests](https://github.com/RIOT-OS/RIOT/actions/runs/5124347194/jobs/9216073113)\n  * [tools-build-success](https://github.com/RIOT-OS/RIOT/actions/runs/5124347197/jobs/9216103309)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\nStep-by-step explanation:\n\n1. **Input Analysis:** Commit message indicates a fix for a NULL pointer dereference, which is a known security issue. The code diff shows a check added to prevent accessing `pkt->next->data` if `pkt->next` is NULL.\n\n2. **Consistency Check:** The commit message aligns with the code change, which adds a NULL check to prevent dereferencing.\n\n3. **Purpose Evaluation:** The change is to fix a specific bug that would cause a crash, indicating a security issue.\n\n4. **Security Vulnerability Assessment:** The patch addresses a potential NULL pointer dereference, a classic security vulnerability (CWE-476), which can lead to application crashes or potential exploitation.\n\n5. **Confidence Scoring:** The information is clear, the code change directly addresses a known security issue, so confidence is high."
}