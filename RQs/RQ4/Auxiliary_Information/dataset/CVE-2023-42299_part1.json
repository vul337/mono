{
  "cve_id": "CVE-2023-42299",
  "cwe_ids": [
    "CWE-787",
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "AcademySoftwareFoundation/OpenImageIO",
  "commit_msg": "fix heap-buffer-overflow in file src/gif.imageio/gifinput.cpp, line 368",
  "commit_hash": "b359c90c84b770d1d39c15aa4662478c7c09d745",
  "git_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/commit/b359c90c84b770d1d39c15aa4662478c7c09d745",
  "file_path": "src/gif.imageio/gifinput.cpp",
  "func_name": "GIFInput::read_subimage_data",
  "func_before": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* colormap = NULL;\n    if (m_gif_file->Image.ColorMap) {  // local colormap\n        colormap = m_gif_file->Image.ColorMap->Colors;\n    } else if (m_gif_file->SColorMap) {  // global colormap\n        colormap = m_gif_file->SColorMap->Colors;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) {\n        // make whole canvas transparent\n        std::fill(m_canvas.begin(), m_canvas.end(), 0x00);\n    }\n\n    // decode scanline index if image is interlaced\n    bool interlacing = m_spec.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    // get subimage dimensions and draw it on canvas\n    int window_height = m_gif_file->Image.Height;\n    int window_width  = m_gif_file->Image.Width;\n    int window_top    = m_gif_file->Image.Top;\n    int window_left   = m_gif_file->Image.Left;\n    std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]);\n    for (int wy = 0; wy < window_height; wy++) {\n        if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) {\n            report_last_error();\n            return false;\n        }\n        int y = window_top\n                + (interlacing ? decode_line_number(wy, window_height) : wy);\n        if (0 <= y && y < m_spec.height) {\n            for (int wx = 0; wx < window_width; wx++) {\n                int x   = window_left + wx;\n                int idx = m_spec.nchannels * (y * m_spec.width + x);\n                if (0 <= x && x < m_spec.width\n                    && fscanline[wx] != m_transparent_color) {\n                    m_canvas[idx]     = colormap[fscanline[wx]].Red;\n                    m_canvas[idx + 1] = colormap[fscanline[wx]].Green;\n                    m_canvas[idx + 2] = colormap[fscanline[wx]].Blue;\n                    m_canvas[idx + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "abstract_func_before": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* VAR_0 = NULL;\n    if (VAR_1->Image.ColorMap) {  /* COMMENT_0 */\n        VAR_0 = VAR_1->Image.ColorMap->Colors;\n    } else if (VAR_1->SColorMap) {  /* COMMENT_1 */\n        VAR_0 = VAR_1->SColorMap->Colors;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (VAR_2 == 0 || VAR_3 == VAR_4) {\n        /* COMMENT_2 */\n        std::fill(VAR_5.begin(), VAR_5.end(), 0x00);\n    }\n\n    /* COMMENT_3 */\n    bool VAR_6 = VAR_7.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    /* COMMENT_4 */\n    int VAR_8 = VAR_1->Image.Height;\n    int VAR_9  = VAR_1->Image.Width;\n    int VAR_10    = VAR_1->Image.Top;\n    int VAR_11   = VAR_1->Image.Left;\n    std::unique_ptr<unsigned char[]> VAR_12(new unsigned char[VAR_9]);\n    for (int VAR_13 = 0; VAR_13 < VAR_8; VAR_13++) {\n        if (DGifGetLine(VAR_1, &VAR_12[0], VAR_9) == VAR_14) {\n            report_last_error();\n            return false;\n        }\n        int VAR_15 = VAR_10\n                + (VAR_6 ? decode_line_number(VAR_13, VAR_8) : VAR_13);\n        if (0 <= VAR_15 && VAR_15 < VAR_7.height) {\n            for (int VAR_16 = 0; VAR_16 < VAR_9; VAR_16++) {\n                int VAR_17   = VAR_11 + VAR_16;\n                int VAR_18 = VAR_7.nchannels * (VAR_15 * VAR_7.width + VAR_17);\n                if (0 <= VAR_17 && VAR_17 < VAR_7.width\n                    && VAR_12[VAR_16] != VAR_19) {\n                    VAR_5[VAR_18]     = VAR_0[VAR_12[VAR_16]].Red;\n                    VAR_5[VAR_18 + 1] = VAR_0[VAR_12[VAR_16]].Green;\n                    VAR_5[VAR_18 + 2] = VAR_0[VAR_12[VAR_16]].Blue;\n                    VAR_5[VAR_18 + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/OpenImageIO/b359c90c84b770d1d39c15aa4662478c7c09d745/gifinput.cpp/vul/before/0.json",
  "func": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* colormap = NULL;\n    int colormap_count;\n    if (m_gif_file->Image.ColorMap) {  // local colormap\n        colormap = m_gif_file->Image.ColorMap->Colors;\n        colormap_count = m_gif_file->Image.ColorMap->ColorCount;\n    } else if (m_gif_file->SColorMap) {  // global colormap\n        colormap = m_gif_file->SColorMap->Colors;\n        colormap_count = m_gif_file->SColorMap->ColorCount;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) {\n        // make whole canvas transparent\n        std::fill(m_canvas.begin(), m_canvas.end(), 0x00);\n    }\n\n    // decode scanline index if image is interlaced\n    bool interlacing = m_spec.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    // get subimage dimensions and draw it on canvas\n    int window_height = m_gif_file->Image.Height;\n    int window_width  = m_gif_file->Image.Width;\n    int window_top    = m_gif_file->Image.Top;\n    int window_left   = m_gif_file->Image.Left;\n    std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]);\n    for (int wy = 0; wy < window_height; wy++) {\n        if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) {\n            report_last_error();\n            return false;\n        }\n        int y = window_top\n                + (interlacing ? decode_line_number(wy, window_height) : wy);\n        if (0 <= y && y < m_spec.height) {\n            for (int wx = 0; wx < window_width; wx++) {\n                if (fscanline[wx] >= colormap_count) {\n                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n                             fscanline[wx], wx, y, colormap_count);\n                    return false;\n                }\n                int x   = window_left + wx;\n                int idx = m_spec.nchannels * (y * m_spec.width + x);\n                if (0 <= x && x < m_spec.width\n                    && fscanline[wx] != m_transparent_color) {\n                    m_canvas[idx]     = colormap[fscanline[wx]].Red;\n                    m_canvas[idx + 1] = colormap[fscanline[wx]].Green;\n                    m_canvas[idx + 2] = colormap[fscanline[wx]].Blue;\n                    m_canvas[idx + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "abstract_func": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* VAR_0 = NULL;\n    int VAR_1;\n    if (VAR_2->Image.ColorMap) {  /* COMMENT_0 */\n        VAR_0 = VAR_2->Image.ColorMap->Colors;\n        VAR_1 = VAR_2->Image.ColorMap->ColorCount;\n    } else if (VAR_2->SColorMap) {  /* COMMENT_1 */\n        VAR_0 = VAR_2->SColorMap->Colors;\n        VAR_1 = VAR_2->SColorMap->ColorCount;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (VAR_3 == 0 || VAR_4 == VAR_5) {\n        /* COMMENT_2 */\n        std::fill(VAR_6.begin(), VAR_6.end(), 0x00);\n    }\n\n    /* COMMENT_3 */\n    bool VAR_7 = VAR_8.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    /* COMMENT_4 */\n    int VAR_9 = VAR_2->Image.Height;\n    int VAR_10  = VAR_2->Image.Width;\n    int VAR_11    = VAR_2->Image.Top;\n    int VAR_12   = VAR_2->Image.Left;\n    std::unique_ptr<unsigned char[]> VAR_13(new unsigned char[VAR_10]);\n    for (int VAR_14 = 0; VAR_14 < VAR_9; VAR_14++) {\n        if (DGifGetLine(VAR_2, &VAR_13[0], VAR_10) == VAR_15) {\n            report_last_error();\n            return false;\n        }\n        int VAR_16 = VAR_11\n                + (VAR_7 ? decode_line_number(VAR_14, VAR_9) : VAR_14);\n        if (0 <= VAR_16 && VAR_16 < VAR_8.height) {\n            for (int VAR_17 = 0; VAR_17 < VAR_10; VAR_17++) {\n                if (VAR_13[VAR_17] >= VAR_1) {\n                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n                             VAR_13[VAR_17], VAR_17, VAR_16, VAR_1);\n                    return false;\n                }\n                int VAR_18   = VAR_12 + VAR_17;\n                int VAR_19 = VAR_8.nchannels * (VAR_16 * VAR_8.width + VAR_18);\n                if (0 <= VAR_18 && VAR_18 < VAR_8.width\n                    && VAR_13[VAR_17] != VAR_20) {\n                    VAR_6[VAR_19]     = VAR_0[VAR_13[VAR_17]].Red;\n                    VAR_6[VAR_19 + 1] = VAR_0[VAR_13[VAR_17]].Green;\n                    VAR_6[VAR_19 + 2] = VAR_0[VAR_13[VAR_17]].Blue;\n                    VAR_6[VAR_19 + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
  "func_graph_path": "AcademySoftwareFoundation/OpenImageIO/b359c90c84b770d1d39c15aa4662478c7c09d745/gifinput.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,10 +2,13 @@\n GIFInput::read_subimage_data()\n {\n     GifColorType* colormap = NULL;\n+    int colormap_count;\n     if (m_gif_file->Image.ColorMap) {  // local colormap\n         colormap = m_gif_file->Image.ColorMap->Colors;\n+        colormap_count = m_gif_file->Image.ColorMap->ColorCount;\n     } else if (m_gif_file->SColorMap) {  // global colormap\n         colormap = m_gif_file->SColorMap->Colors;\n+        colormap_count = m_gif_file->SColorMap->ColorCount;\n     } else {\n         errorf(\"Neither local nor global colormap present.\");\n         return false;\n@@ -34,6 +37,11 @@\n                 + (interlacing ? decode_line_number(wy, window_height) : wy);\n         if (0 <= y && y < m_spec.height) {\n             for (int wx = 0; wx < window_width; wx++) {\n+                if (fscanline[wx] >= colormap_count) {\n+                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n+                             fscanline[wx], wx, y, colormap_count);\n+                    return false;\n+                }\n                 int x   = window_left + wx;\n                 int idx = m_spec.nchannels * (y * m_spec.width + x);\n                 if (0 <= x && x < m_spec.width",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    int colormap_count;",
      "        colormap_count = m_gif_file->Image.ColorMap->ColorCount;",
      "        colormap_count = m_gif_file->SColorMap->ColorCount;",
      "                if (fscanline[wx] >= colormap_count) {",
      "                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",",
      "                             fscanline[wx], wx, y, colormap_count);",
      "                    return false;",
      "                }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/pull/3841",
  "description": {
    "pr_info": {
      "title": "fix heap-buffer-overflow in file src/gif.imageio/gifinput.cpp, line 368",
      "number": 3841
    },
    "comment": [
      "## Description\r\n\r\nfix #3840: heap-buffer-overflow in file src/gif.imageio/gifinput.cpp, line 368\r\n\r\n## Checklist:\r\n\r\n<!-- Put an 'x' in the boxes as you complete the checklist items -->\r\n\r\n- [x] I have read the [contribution guidelines](https://github.com/OpenImageIO/oiio/blob/master/CONTRIBUTING.md).\r\n- [x] My code follows the prevailing code style of this project.\r\n\r\n",
      "Merged, thanks for the fix!\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch addresses a heap-buffer-overflow issue, a known security vulnerability. The code adds bounds checking to prevent overflow, indicating a clear security fix. The commit message, vulnerability description, and code diff are consistent, confirming it's a security patch. \n\n**Step-by-Step Explanation:**\n\n1. **Commit Message and Vulnerability:** The commit explicitly mentions fixing a heap-buffer-overflow, a security issue.\n2. **Code Diff:** Introduces bounds checks to prevent accessing invalid memory, directly mitigating the overflow.\n3. **Purpose:** The change addresses a security risk in handling external data, preventing potential exploits.\n4. **Confidence:** High due to clear and consistent evidence of a security fix.\n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}