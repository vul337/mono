{
  "cve_id": "CVE-2019-1010251",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "teredo: be stricter on what to consider valid teredo\n\nInvalid Teredo can lead to valid DNS traffic (or other UDP traffic)\nbeing misdetected as Teredo. This leads to false negatives in the\nUDP payload inspection.\n\nMake the teredo code only consider a packet teredo if the encapsulated\ndata was decoded without any 'invalid' events being set.\n\nBug #2736.",
  "commit_hash": "11f3659f64a4e42e90cb3c09fcef66894205aefe",
  "git_url": "https://github.com/OISF/suricata/commit/11f3659f64a4e42e90cb3c09fcef66894205aefe",
  "file_path": "src/decode-teredo.c",
  "func_name": "DecodeTeredo",
  "func_before": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n    /* There is no specific field that we can check to prove that the packet\n     * is a Teredo packet. We've zapped here all the possible Teredo header\n     * and we should have an IPv6 packet at the start pointer.\n     * We then can only do two checks before sending the encapsulated packets\n     * to decoding:\n     *  - The packet has a protocol version which is IPv6.\n     *  - The IPv6 length of the packet matches what remains in buffer.\n     */\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                /* spawn off tunnel packet */\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}",
  "abstract_func_before": "int DecodeTeredo(ThreadVars *VAR_0, DecodeThreadVars *VAR_1, Packet *VAR_2, uint8_t *VAR_3, uint16_t VAR_4, PacketQueue *VAR_5)\n{\n    if (!VAR_6)\n        return VAR_7;\n\n    uint8_t *VAR_8 = VAR_3;\n\n    /* COMMENT_0 */\n    if (VAR_4 < VAR_9)\n        return VAR_7;\n\n    /* COMMENT_1 */\n                                                                    \n                                                                          \n    if (VAR_8[0] == 0x0) {\n        switch (VAR_8[1]) {\n            /* COMMENT_4 */\n            case 0x0:\n                /* COMMENT_5 */\n                if (VAR_4 >= VAR_10 + VAR_9)\n                    VAR_8 += VAR_10;\n                else\n                    return VAR_7;\n                break;\n            /* COMMENT_6 */\n            case 0x1:\n                return VAR_7;\n            /* COMMENT_7 */\n            default:\n                return VAR_7;\n        }\n    }\n\n    /* COMMENT_8 */\n                                                                           \n                                                              \n                                                                             \n                   \n                                                          \n                                                                       \n       \n    if (IP_GET_RAW_VER(VAR_8) == 6) {\n        IPV6Hdr *VAR_11 = (IPV6Hdr *)VAR_8;\n        if (VAR_4 ==  VAR_9 +\n                IPV6_GET_RAW_PLEN(VAR_11) + (VAR_8 - VAR_3)) {\n            if (VAR_5 != NULL) {\n                int VAR_12 = VAR_4 - (VAR_8 - VAR_3);\n                /* COMMENT_16 */\n                Packet *VAR_13 = PacketTunnelPktSetup(VAR_0, VAR_1, VAR_2, VAR_8, VAR_12,\n                                                  VAR_14, VAR_5);\n                if (VAR_13 != NULL) {\n                    PKT_SET_SRC(VAR_13, VAR_15);\n                    /* COMMENT_17 */\n                    PacketEnqueue(VAR_5,VAR_13);\n                    StatsIncr(VAR_0, VAR_1->counter_teredo);\n                    return VAR_16;\n                }\n            }\n        }\n        return VAR_7;\n    }\n\n    return VAR_7;\n}",
  "func_graph_path_before": "OISF/suricata/11f3659f64a4e42e90cb3c09fcef66894205aefe/decode-teredo.c/vul/before/0.json",
  "func": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n    /* There is no specific field that we can check to prove that the packet\n     * is a Teredo packet. We've zapped here all the possible Teredo header\n     * and we should have an IPv6 packet at the start pointer.\n     * We then can only do a few checks before sending the encapsulated packets\n     * to decoding:\n     *  - The packet has a protocol version which is IPv6.\n     *  - The IPv6 length of the packet matches what remains in buffer.\n     *  - HLIM is 0. This would technically be valid, but still weird.\n     *  - NH 0 (HOP) and not enough data.\n     *\n     *  If all these conditions are met, the tunnel decoder will be called.\n     *  If the packet gets an invalid event set, it will still be rejected.\n     */\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n\n        /* ignore hoplimit 0 packets, most likely an artifact of bad detection */\n        if (IPV6_GET_RAW_HLIM(thdr) == 0)\n            return TM_ECODE_FAILED;\n\n        /* if nh is 0 (HOP) with little data we have a bogus packet */\n        if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)\n            return TM_ECODE_FAILED;\n\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                /* spawn off tunnel packet */\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6_TEREDO, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}",
  "abstract_func": "int DecodeTeredo(ThreadVars *VAR_0, DecodeThreadVars *VAR_1, Packet *VAR_2, uint8_t *VAR_3, uint16_t VAR_4, PacketQueue *VAR_5)\n{\n    if (!VAR_6)\n        return VAR_7;\n\n    uint8_t *VAR_8 = VAR_3;\n\n    /* COMMENT_0 */\n    if (VAR_4 < VAR_9)\n        return VAR_7;\n\n    /* COMMENT_1 */\n                                                                    \n                                                                          \n    if (VAR_8[0] == 0x0) {\n        switch (VAR_8[1]) {\n            /* COMMENT_4 */\n            case 0x0:\n                /* COMMENT_5 */\n                if (VAR_4 >= VAR_10 + VAR_9)\n                    VAR_8 += VAR_10;\n                else\n                    return VAR_7;\n                break;\n            /* COMMENT_6 */\n            case 0x1:\n                return VAR_7;\n            /* COMMENT_7 */\n            default:\n                return VAR_7;\n        }\n    }\n\n    /* COMMENT_8 */\n                                                                           \n                                                              \n                                                                               \n                   \n                                                          \n                                                                       \n                                                                      \n                                         \n      \n                                                                           \n                                                                           \n       \n    if (IP_GET_RAW_VER(VAR_8) == 6) {\n        IPV6Hdr *VAR_11 = (IPV6Hdr *)VAR_8;\n\n        /* COMMENT_21 */\n        if (IPV6_GET_RAW_HLIM(VAR_11) == 0)\n            return VAR_7;\n\n        /* COMMENT_22 */\n        if (IPV6_GET_RAW_NH(VAR_11) == 0 && IPV6_GET_RAW_PLEN(VAR_11) < 8)\n            return VAR_7;\n\n        if (VAR_4 ==  VAR_9 +\n                IPV6_GET_RAW_PLEN(VAR_11) + (VAR_8 - VAR_3)) {\n            if (VAR_5 != NULL) {\n                int VAR_12 = VAR_4 - (VAR_8 - VAR_3);\n                /* COMMENT_23 */\n                Packet *VAR_13 = PacketTunnelPktSetup(VAR_0, VAR_1, VAR_2, VAR_8, VAR_12,\n                                                  VAR_14, VAR_5);\n                if (VAR_13 != NULL) {\n                    PKT_SET_SRC(VAR_13, VAR_15);\n                    /* COMMENT_24 */\n                    PacketEnqueue(VAR_5,VAR_13);\n                    StatsIncr(VAR_0, VAR_1->counter_teredo);\n                    return VAR_16;\n                }\n            }\n        }\n        return VAR_7;\n    }\n\n    return VAR_7;\n}",
  "func_graph_path": "OISF/suricata/11f3659f64a4e42e90cb3c09fcef66894205aefe/decode-teredo.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -34,20 +34,34 @@\n     /* There is no specific field that we can check to prove that the packet\n      * is a Teredo packet. We've zapped here all the possible Teredo header\n      * and we should have an IPv6 packet at the start pointer.\n-     * We then can only do two checks before sending the encapsulated packets\n+     * We then can only do a few checks before sending the encapsulated packets\n      * to decoding:\n      *  - The packet has a protocol version which is IPv6.\n      *  - The IPv6 length of the packet matches what remains in buffer.\n+     *  - HLIM is 0. This would technically be valid, but still weird.\n+     *  - NH 0 (HOP) and not enough data.\n+     *\n+     *  If all these conditions are met, the tunnel decoder will be called.\n+     *  If the packet gets an invalid event set, it will still be rejected.\n      */\n     if (IP_GET_RAW_VER(start) == 6) {\n         IPV6Hdr *thdr = (IPV6Hdr *)start;\n+\n+        /* ignore hoplimit 0 packets, most likely an artifact of bad detection */\n+        if (IPV6_GET_RAW_HLIM(thdr) == 0)\n+            return TM_ECODE_FAILED;\n+\n+        /* if nh is 0 (HOP) with little data we have a bogus packet */\n+        if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)\n+            return TM_ECODE_FAILED;\n+\n         if (len ==  IPV6_HEADER_LEN +\n                 IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n             if (pq != NULL) {\n                 int blen = len - (start - pkt);\n                 /* spawn off tunnel packet */\n                 Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n-                                                  DECODE_TUNNEL_IPV6, pq);\n+                                                  DECODE_TUNNEL_IPV6_TEREDO, pq);\n                 if (tp != NULL) {\n                     PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                     /* add the tp to the packet queue. */",
  "diff_line_info": {
    "deleted_lines": [
      "     * We then can only do two checks before sending the encapsulated packets",
      "                                                  DECODE_TUNNEL_IPV6, pq);"
    ],
    "added_lines": [
      "     * We then can only do a few checks before sending the encapsulated packets",
      "     *  - HLIM is 0. This would technically be valid, but still weird.",
      "     *  - NH 0 (HOP) and not enough data.",
      "     *",
      "     *  If all these conditions are met, the tunnel decoder will be called.",
      "     *  If the packet gets an invalid event set, it will still be rejected.",
      "",
      "        /* ignore hoplimit 0 packets, most likely an artifact of bad detection */",
      "        if (IPV6_GET_RAW_HLIM(thdr) == 0)",
      "            return TM_ECODE_FAILED;",
      "",
      "        /* if nh is 0 (HOP) with little data we have a bogus packet */",
      "        if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)",
      "            return TM_ECODE_FAILED;",
      "",
      "                                                  DECODE_TUNNEL_IPV6_TEREDO, pq);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/3590",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OISF/suricata/pull/3590: 403 Client Error: Forbidden for url: https://api.github.com/repos/OISF/suricata/pulls/3590",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9"
}