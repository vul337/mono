{
  "cve_id": "CVE-2020-16124",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ros/ros_comm",
  "commit_msg": "Trap for overly large input to XmlRPCPP which could cause problems with int <-> size_t conversions.\n\n - In XmlRpcClient, XmlRpcServerConnection and XmlRpcSocket, recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header, and generate an error if the length is invalid or too large.\n - In XmlRpcUtil, prevent attempts to parse overly large XML input.\n - Add tests where they can reasonably be inserted into existing test routines.\n\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\n\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\n\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
  "commit_hash": "3dd308911d7294bc6cff12f626b8467fe1555423",
  "git_url": "https://github.com/ros/ros_comm/commit/3dd308911d7294bc6cff12f626b8467fe1555423",
  "file_path": "utilities/xmlrpcpp/src/XmlRpcServerConnection.cpp",
  "func_name": "XmlRpcServerConnection::readRequest",
  "func_before": "bool\nXmlRpcServerConnection::readRequest()\n{\n  // If we dont have the entire request yet, read available data\n  if (int(_request.length()) < _contentLength) {\n    bool eof;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), _request, &eof)) {\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      return false;\n    }\n\n    // If we haven't gotten the entire request yet, return (keep reading)\n    if (int(_request.length()) < _contentLength) {\n      if (eof) {\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: EOF while reading request\");\n        return false;   // Either way we close the connection\n      }\n      return true;\n    }\n  }\n\n  // Otherwise, parse and dispatch the request\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readRequest read %d bytes.\", _request.length());\n  //XmlRpcUtil::log(5, \"XmlRpcServerConnection::readRequest:\\n%s\\n\", _request.c_str());\n\n  _connectionState = WRITE_RESPONSE;\n\n  return true;    // Continue monitoring this source\n}",
  "abstract_func_before": "bool\nXmlRpcServerConnection::readRequest()\n{\n  /* COMMENT_0 */\n  if (int(VAR_0.length()) < VAR_1) {\n    bool VAR_2;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_0, &VAR_2)) {\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      return false;\n    }\n\n    /* COMMENT_1 */\n    if (int(VAR_0.length()) < VAR_1) {\n      if (VAR_2) {\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: EOF while reading request\");\n        return false;   /* COMMENT_2 */\n      }\n      return true;\n    }\n  }\n\n  /* COMMENT_3 */\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readRequest read %d bytes.\", VAR_0.length());\n  /* COMMENT_4 */\n\n  VAR_3 = VAR_4;\n\n  return true;    /* COMMENT_5 */\n}",
  "func_graph_path_before": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcServerConnection.cpp/vul/before/2.json",
  "func": "bool\nXmlRpcServerConnection::readRequest()\n{\n  // If we dont have the entire request yet, read available data\n  if (int(_request.length()) < _contentLength) {\n    bool eof;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), _request, &eof)) {\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      return false;\n    }\n    // Avoid an overly large request\n    if (_request.length() > size_t(__INT_MAX__)) {\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: request length (%u) exceeds the maximum allowed size (%u)\",\n                        _request.length(), __INT_MAX__);\n      _request.resize(__INT_MAX__);\n      return false;\n    }\n\n    // If we haven't gotten the entire request yet, return (keep reading)\n    if (int(_request.length()) < _contentLength) {\n      if (eof) {\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: EOF while reading request\");\n        return false;   // Either way we close the connection\n      }\n      return true;\n    }\n  }\n\n  // Otherwise, parse and dispatch the request\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readRequest read %d bytes.\", _request.length());\n  //XmlRpcUtil::log(5, \"XmlRpcServerConnection::readRequest:\\n%s\\n\", _request.c_str());\n\n  _connectionState = WRITE_RESPONSE;\n\n  return true;    // Continue monitoring this source\n}",
  "abstract_func": "bool\nXmlRpcServerConnection::readRequest()\n{\n  /* COMMENT_0 */\n  if (int(VAR_0.length()) < VAR_1) {\n    bool VAR_2;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_0, &VAR_2)) {\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      return false;\n    }\n    /* COMMENT_1 */\n    if (VAR_0.length() > size_t(VAR_3)) {\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: request length (%u) exceeds the maximum allowed size (%u)\",\n                        VAR_0.length(), VAR_3);\n      VAR_0.resize(VAR_3);\n      return false;\n    }\n\n    /* COMMENT_2 */\n    if (int(VAR_0.length()) < VAR_1) {\n      if (VAR_2) {\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: EOF while reading request\");\n        return false;   /* COMMENT_3 */\n      }\n      return true;\n    }\n  }\n\n  /* COMMENT_4 */\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readRequest read %d bytes.\", VAR_0.length());\n  /* COMMENT_5 */\n\n  VAR_4 = VAR_5;\n\n  return true;    /* COMMENT_6 */\n}",
  "func_graph_path": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcServerConnection.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,13 @@\n     bool eof;\n     if ( ! XmlRpcSocket::nbRead(this->getfd(), _request, &eof)) {\n       XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n+      return false;\n+    }\n+    // Avoid an overly large request\n+    if (_request.length() > size_t(__INT_MAX__)) {\n+      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: request length (%u) exceeds the maximum allowed size (%u)\",\n+                        _request.length(), __INT_MAX__);\n+      _request.resize(__INT_MAX__);\n       return false;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      return false;",
      "    }",
      "    // Avoid an overly large request",
      "    if (_request.length() > size_t(__INT_MAX__)) {",
      "      XmlRpcUtil::error(\"XmlRpcServerConnection::readRequest: request length (%u) exceeds the maximum allowed size (%u)\",",
      "                        _request.length(), __INT_MAX__);",
      "      _request.resize(__INT_MAX__);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ros/ros_comm/pull/2065",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/ros/ros_comm/pull/2065: 403 Client Error: Forbidden for url: https://api.github.com/repos/ros/ros_comm/pulls/2065",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}