{
  "cve_id": "CVE-2023-51387",
  "cwe_ids": [
    "CWE-94"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "apache/hertzbeat",
  "commit_msg": "fix: expression injection RCE (#1241)",
  "commit_hash": "8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2",
  "git_url": "https://github.com/apache/hertzbeat/commit/8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2",
  "file_path": "common/src/main/java/org/dromara/hertzbeat/common/config/AviatorConfiguration.java",
  "func_name": "configAviatorEvaluator",
  "func_before": "@Bean\n    public void configAviatorEvaluator() {\n        // 配置AviatorEvaluator使用LRU缓存编译后的表达式\n        AviatorEvaluator.getInstance()\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // 配置自定义aviator函数\n        AviatorEvaluator.getInstance().addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        AviatorEvaluator.getInstance().addFunction(new StrContainsFunction());\n        AviatorEvaluator.getInstance().addFunction(new ObjectExistsFunction());\n        AviatorEvaluator.getInstance().addFunction(new StrMatchesFunction());\n    }",
  "abstract_func_before": "@Bean\n    public void configAviatorEvaluator() {\n        /* COMMENT_0 */\n        VAR_0.getInstance()\n                .useLRUExpressionCache(VAR_1)\n                .addFunction(new StrEqualFunction());\n\n        /* COMMENT_1 */\n        VAR_0.getInstance().addOpFunction(VAR_2.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> VAR_3, final AviatorObject VAR_4,\n                                      final AviatorObject VAR_5) {\n                try {\n                    Object VAR_6 = VAR_4.getValue(VAR_3);\n                    Object VAR_7 = VAR_5.getValue(VAR_3);\n                    Object VAR_8 = VAR_6 == null ? VAR_7 : VAR_6;\n                    if (VAR_4.getAviatorType() == VAR_9.String) {\n                        return new AviatorString(VAR_10.valueOf(VAR_8));\n                    } else {\n                        return VAR_11.valueOf(VAR_8);\n                    }\n                } catch (Exception VAR_12) {\n                    VAR_13.error(VAR_12.getMessage());\n                }\n                return VAR_4.bitOr(VAR_5, VAR_3);\n            }\n            @Override\n            public String getName() {\n                return VAR_2.BIT_OR.getToken();\n            }\n        });\n\n        VAR_0.getInstance().addFunction(new StrContainsFunction());\n        VAR_0.getInstance().addFunction(new ObjectExistsFunction());\n        VAR_0.getInstance().addFunction(new StrMatchesFunction());\n    }",
  "func_graph_path_before": "apache/hertzbeat/8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2/AviatorConfiguration.java/vul/before/0.json",
  "func": "@Bean\n    public void configAviatorEvaluator() {\n        AviatorEvaluatorInstance instance = AviatorEvaluator.getInstance();\n\n        // 配置AviatorEvaluator使用LRU缓存编译后的表达式\n        instance\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // 配置Aviator语法特性集合\n        instance.setOption(Options.FEATURE_SET,\n                Feature.asSet(Feature.If,\n                        Feature.Assignment,\n                        Feature.Let,\n                        Feature.StringInterpolation));\n\n        // 配置自定义aviator函数\n        instance.addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        instance.addFunction(new StrContainsFunction());\n        instance.addFunction(new ObjectExistsFunction());\n        instance.addFunction(new StrMatchesFunction());\n    }",
  "abstract_func": "@Bean\n    public void configAviatorEvaluator() {\n        AviatorEvaluatorInstance VAR_0 = VAR_1.getInstance();\n\n        /* COMMENT_0 */\n        VAR_0\n                .useLRUExpressionCache(VAR_2)\n                .addFunction(new StrEqualFunction());\n\n        /* COMMENT_1 */\n        VAR_0.setOption(VAR_3.FEATURE_SET,\n                VAR_4.asSet(VAR_4.If,\n                        VAR_4.Assignment,\n                        VAR_4.Let,\n                        VAR_4.StringInterpolation));\n\n        /* COMMENT_2 */\n        VAR_0.addOpFunction(VAR_5.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> VAR_6, final AviatorObject VAR_7,\n                                      final AviatorObject VAR_8) {\n                try {\n                    Object VAR_9 = VAR_7.getValue(VAR_6);\n                    Object VAR_10 = VAR_8.getValue(VAR_6);\n                    Object VAR_11 = VAR_9 == null ? VAR_10 : VAR_9;\n                    if (VAR_7.getAviatorType() == VAR_12.String) {\n                        return new AviatorString(VAR_13.valueOf(VAR_11));\n                    } else {\n                        return VAR_14.valueOf(VAR_11);\n                    }\n                } catch (Exception VAR_15) {\n                    VAR_16.error(VAR_15.getMessage());\n                }\n                return VAR_7.bitOr(VAR_8, VAR_6);\n            }\n            @Override\n            public String getName() {\n                return VAR_5.BIT_OR.getToken();\n            }\n        });\n\n        VAR_0.addFunction(new StrContainsFunction());\n        VAR_0.addFunction(new ObjectExistsFunction());\n        VAR_0.addFunction(new StrMatchesFunction());\n    }",
  "func_graph_path": "apache/hertzbeat/8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2/AviatorConfiguration.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,21 @@\n @Bean\n     public void configAviatorEvaluator() {\n+        AviatorEvaluatorInstance instance = AviatorEvaluator.getInstance();\n+\n         // 配置AviatorEvaluator使用LRU缓存编译后的表达式\n-        AviatorEvaluator.getInstance()\n+        instance\n                 .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                 .addFunction(new StrEqualFunction());\n \n+        // 配置Aviator语法特性集合\n+        instance.setOption(Options.FEATURE_SET,\n+                Feature.asSet(Feature.If,\n+                        Feature.Assignment,\n+                        Feature.Let,\n+                        Feature.StringInterpolation));\n+\n         // 配置自定义aviator函数\n-        AviatorEvaluator.getInstance().addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n+        instance.addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n             @Override\n             public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                       final AviatorObject arg2) {\n@@ -30,7 +39,7 @@\n             }\n         });\n \n-        AviatorEvaluator.getInstance().addFunction(new StrContainsFunction());\n-        AviatorEvaluator.getInstance().addFunction(new ObjectExistsFunction());\n-        AviatorEvaluator.getInstance().addFunction(new StrMatchesFunction());\n+        instance.addFunction(new StrContainsFunction());\n+        instance.addFunction(new ObjectExistsFunction());\n+        instance.addFunction(new StrMatchesFunction());\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "        AviatorEvaluator.getInstance()",
      "        AviatorEvaluator.getInstance().addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {",
      "        AviatorEvaluator.getInstance().addFunction(new StrContainsFunction());",
      "        AviatorEvaluator.getInstance().addFunction(new ObjectExistsFunction());",
      "        AviatorEvaluator.getInstance().addFunction(new StrMatchesFunction());"
    ],
    "added_lines": [
      "        AviatorEvaluatorInstance instance = AviatorEvaluator.getInstance();",
      "",
      "        instance",
      "        // 配置Aviator语法特性集合",
      "        instance.setOption(Options.FEATURE_SET,",
      "                Feature.asSet(Feature.If,",
      "                        Feature.Assignment,",
      "                        Feature.Let,",
      "                        Feature.StringInterpolation));",
      "",
      "        instance.addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {",
      "        instance.addFunction(new StrContainsFunction());",
      "        instance.addFunction(new ObjectExistsFunction());",
      "        instance.addFunction(new StrMatchesFunction());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/apache/hertzbeat/pull/1241",
  "description": {
    "pr_info": {
      "title": "fix: expression injection RCE",
      "number": 1241
    },
    "comment": [
      "## What's changed?\r\n\r\nFixed AviatorScript expression injection RCE issues:\r\n\r\n- Disabled Feature.Module\r\n- Disabled Feature.NewInstance\r\n- Minimized feature set\r\n\r\n\r\n## Checklist\r\n\r\n- [x]  I have read the [Contributing Guide](https://hertzbeat.com/docs/others/contributing/)\r\n- [x]  I have written the necessary doc or comment.\r\n- [x]  I have added the necessary unit tests and all cases have passed.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a security issue by modifying the Aviator evaluator's configuration to prevent expression injection leading to RCE by disabling certain features.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}