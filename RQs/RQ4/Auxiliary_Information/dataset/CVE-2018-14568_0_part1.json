{
  "cve_id": "CVE-2018-14568",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "stream: support RST getting lost/ignored\n\nIn case of a valid RST on a SYN, the state is switched to 'TCP_CLOSED'.\nHowever, the target of the RST may not have received it, or may not\nhave accepted it. Also, the RST may have been injected, so the supposed\nsender may not actually be aware of the RST that was sent in it's name.\n\nIn this case the previous behavior was to switch the state to CLOSED and\naccept no further TCP updates or stream reassembly.\n\nThis patch changes this. It still switches the state to CLOSED, as this\nis by far the most likely to be correct. However, it will reconsider\nthe state if the receiver continues to talk.\n\nTo do this on each state change the previous state will be recorded in\nTcpSession::pstate. If a non-RST packet is received after a RST, this\nTcpSession::pstate is used to try to continue the conversation.\n\nIf the (supposed) sender of the RST is also continueing the conversation\nas normal, it's highly likely it didn't send the RST. In this case\na stream event is generated.\n\nTicket: #2501\n\nReported-By: Kirill Shipulin",
  "commit_hash": "843d0b7a10bb45627f94764a6c5d468a24143345",
  "git_url": "https://github.com/OISF/suricata/commit/843d0b7a10bb45627f94764a6c5d468a24143345",
  "file_path": "src/stream-tcp.c",
  "func_name": "StreamTcpPacket",
  "func_before": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id == 0)) {\n        p->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n    }\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        /* check if the packet is in right direction, when we missed the\n           SYN packet and picked up midstream session. */\n        if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\n            StreamTcpPacketSwitchDir(ssn, p);\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        switch (ssn->state) {\n            case TCP_SYN_SENT:\n                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_SYN_RECV:\n                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_ESTABLISHED:\n                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT1:\n                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT2:\n                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSING:\n                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSE_WAIT:\n                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_LAST_ACK:\n                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_TIME_WAIT:\n                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSED:\n                /* TCP session memory is not returned to pool until timeout. */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}",
  "abstract_func_before": "int StreamTcpPacket (ThreadVars *VAR_0, Packet *VAR_1, StreamTcpThread *VAR_2,\n                     PacketQueue *VAR_3)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(VAR_1->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"VAR_4, VAR_1->pcap_cnt);\n\n    /* COMMENT_0 */\n    if (unlikely(VAR_1->flow->thread_id == 0)) {\n        VAR_1->flow->thread_id = (FlowThreadId)VAR_0->id;\n#ifdef VAR_5\n    } else if (unlikely((FlowThreadId)VAR_0->id != VAR_1->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", VAR_1->flow->thread_id, VAR_0->id);\n#endif\n    }\n\n    TcpSession *VAR_6 = (TcpSession *)VAR_1->flow->protoctx;\n\n    /* COMMENT_1 */\n    if (VAR_6 != NULL) {\n        VAR_6->tcp_packet_flags |= VAR_1->tcph->th_flags;\n        if (PKT_IS_TOSERVER(VAR_1))\n            VAR_6->client.tcp_flags |= VAR_1->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(VAR_1))\n            VAR_6->server.tcp_flags |= VAR_1->tcph->th_flags;\n\n        /* COMMENT_2 */\n        if (VAR_6->flags & VAR_7 &&\n            VAR_6->client.tcp_flags != 0 &&\n            VAR_6->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", VAR_6);\n            VAR_6->flags &= ~VAR_7;\n        }\n    }\n\n    /* COMMENT_3 */\n    if ((VAR_1->tcph->th_flags & (VAR_8|VAR_9)) == (VAR_8|VAR_9)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_synack);\n    } else if (VAR_1->tcph->th_flags & (VAR_8)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_syn);\n    }\n    if (VAR_1->tcph->th_flags & (VAR_10)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_rst);\n    }\n\n    /* COMMENT_4 */\n    if (!(VAR_1->tcph->th_flags & VAR_9) && TCP_GET_ACK(VAR_1) != 0) {\n        StreamTcpSetEvent(VAR_1, VAR_11);\n    }\n\n    /* COMMENT_5 */\n                                                                   \n                                                                   \n                                                         \n    if (StreamTcpCheckFlowDrops(VAR_1) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(VAR_1->flow);\n        DecodeSetNoPacketInspectionFlag(VAR_1);\n        StreamTcpDisableAppLayer(VAR_1->flow);\n        PACKET_DROP(VAR_1);\n        /* COMMENT_9 */\n        StreamTcpSessionPktFree(VAR_1);\n        SCReturnInt(0);\n    }\n\n    if (VAR_6 == NULL || VAR_6->state == VAR_12) {\n        if (StreamTcpPacketStateNone(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (VAR_6 != NULL)\n            SCLogDebug(\"ssn->alproto %\"VAR_13\"\", VAR_1->flow->alproto);\n    } else {\n        /* COMMENT_10 */\n                                                               \n                                            \n        if (VAR_1->flags & VAR_14) {\n            if (PKT_IS_TOCLIENT(VAR_1)) {\n                VAR_6->client.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->server, VAR_1, VAR_3);\n            } else {\n                VAR_6->server.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->client, VAR_1, VAR_3);\n            }\n            /* COMMENT_13 */\n            goto skip;\n        }\n\n        /* COMMENT_14 */\n                                                         \n        if (VAR_6->flags & VAR_15)\n            StreamTcpPacketSwitchDir(VAR_6, VAR_1);\n\n        if (StreamTcpPacketIsKeepAlive(VAR_6, VAR_1) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(VAR_6, VAR_1) == 1) {\n            StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n\n        /* COMMENT_16 */\n                                                                      \n        if (StreamTcpPacketIsFinShutdownAck(VAR_6, VAR_1) == 0)\n            if (StreamTcpPacketIsWindowUpdate(VAR_6, VAR_1) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(VAR_6,VAR_1))\n                    goto skip;\n\n        switch (VAR_6->state) {\n            case VAR_16:\n                if(StreamTcpPacketStateSynSent(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_17:\n                if(StreamTcpPacketStateSynRecv(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_18:\n                if(StreamTcpPacketStateEstablished(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_19:\n                if(StreamTcpPacketStateFinWait1(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_20:\n                if(StreamTcpPacketStateFinWait2(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_21:\n                if(StreamTcpPacketStateClosing(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_22:\n                if(StreamTcpPacketStateCloseWait(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_23:\n                if(StreamTcpPacketStateLastAck(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_24:\n                if(StreamTcpPacketStateTimeWait(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_25:\n                /* COMMENT_18 */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (VAR_6->state >= VAR_18) {\n            VAR_1->flags |= VAR_26;\n        }\n    }\n\n    /* COMMENT_19 */\n                                                                      \n                                                                      \n                          \n                                                                      \n    if (VAR_6 != NULL) {\n        while (VAR_2->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *VAR_27 = PacketDequeue(&VAR_2->pseudo_queue);\n            if (VAR_27 != NULL) {\n                /* COMMENT_24 */\n                if (PKT_IS_TOSERVER(VAR_27)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->client, VAR_27, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->server, VAR_27, NULL);\n                }\n\n                /* COMMENT_25 */\n                PacketEnqueue(VAR_3, VAR_27);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* COMMENT_26 */\n        if (VAR_1->flags & VAR_28) {\n            ReCalculateChecksum(VAR_1);\n        }\n\n        /* COMMENT_27 */\n\n        /* COMMENT_28 */\n        if ((VAR_6->client.flags & VAR_29) &&\n             (VAR_6->server.flags & VAR_29))\n        {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n        }\n\n        if ((VAR_6->client.flags & VAR_29) ||\n             (VAR_6->server.flags & VAR_29))\n        {\n            VAR_1->flags |= VAR_30;\n        }\n\n        /* COMMENT_30 */\n        if ((PKT_IS_TOSERVER(VAR_1) && (VAR_6->client.flags & VAR_31)) ||\n            (PKT_IS_TOCLIENT(VAR_1) && (VAR_6->server.flags & VAR_31)))\n        {\n            VAR_1->flags |= VAR_30;\n        }\n\n        if (VAR_6->flags & VAR_32) {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n\n        /* COMMENT_31 */\n        } else if (VAR_33 &&\n                (VAR_6->client.flags & VAR_31) &&\n                (VAR_6->server.flags & VAR_31) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(VAR_1);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* COMMENT_32 */\n    while (VAR_2->pseudo_queue.len > 0) {\n        Packet *VAR_27 = PacketDequeue(&VAR_2->pseudo_queue);\n        if (VAR_27 != NULL) {\n            PacketEnqueue(VAR_3, VAR_27);\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_1->flags & VAR_28) {\n        ReCalculateChecksum(VAR_1);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* COMMENT_33 */\n                                                                 \n                                                     \n        DecodeSetNoPayloadInspectionFlag(VAR_1);\n        PACKET_DROP(VAR_1);\n    }\n    SCReturnInt(-1);\n}",
  "func_graph_path_before": "OISF/suricata/843d0b7a10bb45627f94764a6c5d468a24143345/stream-tcp.c/vul/before/1.json",
  "func": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id == 0)) {\n        p->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n    }\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        /* check if the packet is in right direction, when we missed the\n           SYN packet and picked up midstream session. */\n        if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\n            StreamTcpPacketSwitchDir(ssn, p);\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        /* handle the per 'state' logic */\n        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)\n            goto error;\n\n    skip:\n        StreamTcpPacketCheckPostRst(ssn, p);\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}",
  "abstract_func": "int StreamTcpPacket (ThreadVars *VAR_0, Packet *VAR_1, StreamTcpThread *VAR_2,\n                     PacketQueue *VAR_3)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(VAR_1->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"VAR_4, VAR_1->pcap_cnt);\n\n    /* COMMENT_0 */\n    if (unlikely(VAR_1->flow->thread_id == 0)) {\n        VAR_1->flow->thread_id = (FlowThreadId)VAR_0->id;\n#ifdef VAR_5\n    } else if (unlikely((FlowThreadId)VAR_0->id != VAR_1->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", VAR_1->flow->thread_id, VAR_0->id);\n#endif\n    }\n\n    TcpSession *VAR_6 = (TcpSession *)VAR_1->flow->protoctx;\n\n    /* COMMENT_1 */\n    if (VAR_6 != NULL) {\n        VAR_6->tcp_packet_flags |= VAR_1->tcph->th_flags;\n        if (PKT_IS_TOSERVER(VAR_1))\n            VAR_6->client.tcp_flags |= VAR_1->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(VAR_1))\n            VAR_6->server.tcp_flags |= VAR_1->tcph->th_flags;\n\n        /* COMMENT_2 */\n        if (VAR_6->flags & VAR_7 &&\n            VAR_6->client.tcp_flags != 0 &&\n            VAR_6->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", VAR_6);\n            VAR_6->flags &= ~VAR_7;\n        }\n    }\n\n    /* COMMENT_3 */\n    if ((VAR_1->tcph->th_flags & (VAR_8|VAR_9)) == (VAR_8|VAR_9)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_synack);\n    } else if (VAR_1->tcph->th_flags & (VAR_8)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_syn);\n    }\n    if (VAR_1->tcph->th_flags & (VAR_10)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_rst);\n    }\n\n    /* COMMENT_4 */\n    if (!(VAR_1->tcph->th_flags & VAR_9) && TCP_GET_ACK(VAR_1) != 0) {\n        StreamTcpSetEvent(VAR_1, VAR_11);\n    }\n\n    /* COMMENT_5 */\n                                                                   \n                                                                   \n                                                         \n    if (StreamTcpCheckFlowDrops(VAR_1) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(VAR_1->flow);\n        DecodeSetNoPacketInspectionFlag(VAR_1);\n        StreamTcpDisableAppLayer(VAR_1->flow);\n        PACKET_DROP(VAR_1);\n        /* COMMENT_9 */\n        StreamTcpSessionPktFree(VAR_1);\n        SCReturnInt(0);\n    }\n\n    if (VAR_6 == NULL || VAR_6->state == VAR_12) {\n        if (StreamTcpPacketStateNone(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (VAR_6 != NULL)\n            SCLogDebug(\"ssn->alproto %\"VAR_13\"\", VAR_1->flow->alproto);\n    } else {\n        /* COMMENT_10 */\n                                                               \n                                            \n        if (VAR_1->flags & VAR_14) {\n            if (PKT_IS_TOCLIENT(VAR_1)) {\n                VAR_6->client.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->server, VAR_1, VAR_3);\n            } else {\n                VAR_6->server.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->client, VAR_1, VAR_3);\n            }\n            /* COMMENT_13 */\n            goto skip;\n        }\n\n        /* COMMENT_14 */\n                                                         \n        if (VAR_6->flags & VAR_15)\n            StreamTcpPacketSwitchDir(VAR_6, VAR_1);\n\n        if (StreamTcpPacketIsKeepAlive(VAR_6, VAR_1) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(VAR_6, VAR_1) == 1) {\n            StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n\n        /* COMMENT_16 */\n                                                                      \n        if (StreamTcpPacketIsFinShutdownAck(VAR_6, VAR_1) == 0)\n            if (StreamTcpPacketIsWindowUpdate(VAR_6, VAR_1) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(VAR_6,VAR_1))\n                    goto skip;\n\n        /* COMMENT_18 */\n        if (StreamTcpStateDispatch(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue, VAR_6->state) < 0)\n            goto error;\n\n    skip:\n        StreamTcpPacketCheckPostRst(VAR_6, VAR_1);\n\n        if (VAR_6->state >= VAR_16) {\n            VAR_1->flags |= VAR_17;\n        }\n    }\n\n    /* COMMENT_19 */\n                                                                      \n                                                                      \n                          \n                                                                      \n    if (VAR_6 != NULL) {\n        while (VAR_2->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *VAR_18 = PacketDequeue(&VAR_2->pseudo_queue);\n            if (VAR_18 != NULL) {\n                /* COMMENT_24 */\n                if (PKT_IS_TOSERVER(VAR_18)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->client, VAR_18, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->server, VAR_18, NULL);\n                }\n\n                /* COMMENT_25 */\n                PacketEnqueue(VAR_3, VAR_18);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* COMMENT_26 */\n        if (VAR_1->flags & VAR_19) {\n            ReCalculateChecksum(VAR_1);\n        }\n\n        /* COMMENT_27 */\n\n        /* COMMENT_28 */\n        if ((VAR_6->client.flags & VAR_20) &&\n             (VAR_6->server.flags & VAR_20))\n        {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n        }\n\n        if ((VAR_6->client.flags & VAR_20) ||\n             (VAR_6->server.flags & VAR_20))\n        {\n            VAR_1->flags |= VAR_21;\n        }\n\n        /* COMMENT_30 */\n        if ((PKT_IS_TOSERVER(VAR_1) && (VAR_6->client.flags & VAR_22)) ||\n            (PKT_IS_TOCLIENT(VAR_1) && (VAR_6->server.flags & VAR_22)))\n        {\n            VAR_1->flags |= VAR_21;\n        }\n\n        if (VAR_6->flags & VAR_23) {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n\n        /* COMMENT_31 */\n        } else if (VAR_24 &&\n                (VAR_6->client.flags & VAR_22) &&\n                (VAR_6->server.flags & VAR_22) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(VAR_1);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* COMMENT_32 */\n    while (VAR_2->pseudo_queue.len > 0) {\n        Packet *VAR_18 = PacketDequeue(&VAR_2->pseudo_queue);\n        if (VAR_18 != NULL) {\n            PacketEnqueue(VAR_3, VAR_18);\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_1->flags & VAR_19) {\n        ReCalculateChecksum(VAR_1);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* COMMENT_33 */\n                                                                 \n                                                     \n        DecodeSetNoPayloadInspectionFlag(VAR_1);\n        PACKET_DROP(VAR_1);\n    }\n    SCReturnInt(-1);\n}",
  "func_graph_path": "OISF/suricata/843d0b7a10bb45627f94764a6c5d468a24143345/stream-tcp.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -112,61 +112,12 @@\n                 if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                     goto skip;\n \n-        switch (ssn->state) {\n-            case TCP_SYN_SENT:\n-                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_SYN_RECV:\n-                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_ESTABLISHED:\n-                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_FIN_WAIT1:\n-                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_FIN_WAIT2:\n-                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_CLOSING:\n-                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_CLOSE_WAIT:\n-                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_LAST_ACK:\n-                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_TIME_WAIT:\n-                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n-                    goto error;\n-                }\n-                break;\n-            case TCP_CLOSED:\n-                /* TCP session memory is not returned to pool until timeout. */\n-                SCLogDebug(\"packet received on closed state\");\n-                break;\n-            default:\n-                SCLogDebug(\"packet received on default state\");\n-                break;\n-        }\n+        /* handle the per 'state' logic */\n+        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)\n+            goto error;\n+\n     skip:\n+        StreamTcpPacketCheckPostRst(ssn, p);\n \n         if (ssn->state >= TCP_ESTABLISHED) {\n             p->flags |= PKT_STREAM_EST;",
  "diff_line_info": {
    "deleted_lines": [
      "        switch (ssn->state) {",
      "            case TCP_SYN_SENT:",
      "                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_SYN_RECV:",
      "                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_ESTABLISHED:",
      "                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_FIN_WAIT1:",
      "                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_FIN_WAIT2:",
      "                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_CLOSING:",
      "                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_CLOSE_WAIT:",
      "                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_LAST_ACK:",
      "                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_TIME_WAIT:",
      "                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {",
      "                    goto error;",
      "                }",
      "                break;",
      "            case TCP_CLOSED:",
      "                /* TCP session memory is not returned to pool until timeout. */",
      "                SCLogDebug(\"packet received on closed state\");",
      "                break;",
      "            default:",
      "                SCLogDebug(\"packet received on default state\");",
      "                break;",
      "        }"
    ],
    "added_lines": [
      "        /* handle the per 'state' logic */",
      "        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)",
      "            goto error;",
      "",
      "        StreamTcpPacketCheckPostRst(ssn, p);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/3428",
  "description": {
    "pr_info": {
      "title": "Next/20180718/v5",
      "number": 3428
    },
    "comment": [
      "Describe changes:\r\n- #3422\r\n- #3427\r\n- fixes for the tickets below\r\n\r\nTickets:\r\nhttps://redmine.openinfosecfoundation.org/issues/2542\r\nhttps://redmine.openinfosecfoundation.org/issues/2543\r\nhttps://redmine.openinfosecfoundation.org/issues/2501\r\n\r\n[PRScript](https://redmine.openinfosecfoundation.org/projects/suricata/wiki/PRscript) output (if applicable):\r\n- PR victorjulien-pcap: https://buildbot.openinfosecfoundation.org/builders/victorjulien-pcap/builds/152\r\n- PR victorjulien: https://buildbot.openinfosecfoundation.org/builders/victorjulien/builds/154\r\n\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.7\n\nThe patch modifies TCP session handling, specifically improving how RST packets are processed. While related to session management, it's categorized as a feature upgrade rather than a security fix due to the absence of explicit security references. The confidence is moderate because while the changes address core logic, the lack of CVE/CWE identifiers introduces some ambiguity."
}