{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveInstanceFieldRefInto",
  "func_before": "IDATA   \nresolveInstanceFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMFieldRef *ramCPEntry)\n{\n\tIDATA fieldOffset = -1;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInstanceFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\t\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If clazz is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tchar *nlsStr = NULL;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tUDATA fieldIndex = 0;\n\t\tbool fccEntryFieldNotSet = true;\n\t\tJ9Class *flattenableClass = NULL;\n\t\tJ9FlattenedClassCache *flattenedClassCache = NULL;\n#endif\t\t\n\t\tbool isWithField = false;\n\t\tJ9Class *currentTargetClass = NULL;\n\t\tJ9Class *currentSenderClass = NULL;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\ttargetClass = resolvedClass;\n\t\t\tgoto illegalAccess;\n\t\t}\n\t\t/* Reset checkResult to the default error case */\n\t\tcheckResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tisWithField = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_WITH_FIELD);\n\t\t/**\n\t\t * This is an optimization that searches for a field offset in the FCC. \n\t\t * If the offset is found there is no need to repeat the process. \n\t\t * Also, since this optimization is only done for ValueTypes, \n\t\t * the resolvedClass will always be the class that owns the field, \n\t\t * since ValueType superclasses can not have fields.\n\t\t */\n\t\tif (J9_IS_J9CLASS_VALUETYPE(resolvedClass)) {\n\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\tflattenedClassCache = resolvedClass->flattenedClassCache;\n\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\tAssert_VM_false(UDATA_MAX == fieldIndex);\n\t\t\t\tJ9FlattenedClassCacheEntry * flattenedClassCacheEntry = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\tfieldOffset = flattenedClassCacheEntry->offset;\n\t\t\t\tif (-1 != fieldOffset) {\n\t\t\t\t\tdefiningClass = resolvedClass;\n\t\t\t\t\tfield = flattenedClassCacheEntry->field;\n\t\t\t\t\tflattenableClass = J9_VM_FCC_CLASS_FROM_ENTRY(flattenedClassCacheEntry);\n\t\t\t\t\tfccEntryFieldNotSet = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fccEntryFieldNotSet) \n#endif\n\t\t{\n\t\t\tfieldOffset = instanceFieldOffsetWithSourceClass(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t}\n\t\t/* Stop if an exception occurred. */\n\t\tif (fieldOffset != -1) {\n\t\t\tcurrentTargetClass = J9_CURRENT_CLASS(resolvedClass);\n\t\t\tcurrentSenderClass = J9_CURRENT_CLASS(classFromCP);\n\t\t\tmodifiers = field->modifiers;\n\n\t\t\t/* Add the field checking to ensure IllegalAccessError\n\t\t\t * gets thrown out in the case of protected field if in different packages\n\t\t\t */\n\t\t\tif (J9_ARE_ALL_BITS_SET(modifiers, J9AccProtected)\n\t\t\t&& J9_ARE_NO_BITS_SET(modifiers, J9AccStatic)\n\t\t\t&& !J9ROMCLASS_IS_ARRAY(currentTargetClass->romClass)\n\t\t\t&& isSameOrSuperClassOf(definingClass, currentSenderClass)\n\t\t\t&& (definingClass->packageID != currentSenderClass->packageID)\n\t\t\t&& !isSameOrSuperClassOf(currentSenderClass, currentTargetClass)\n\t\t\t&& !isSameOrSuperClassOf(currentTargetClass, currentSenderClass)\n\t\t\t) {\n\t\t\t\tbadMemberModifier = modifiers;\n\t\t\t\ttargetClass = currentTargetClass;\n\t\t\t\tgoto illegalAccess;\n\t\t\t}\n\n\t\t\tif ((modifiers & J9AccFinal) != 0) {\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_FIELD_SETTER)\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t|| isWithField\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\t\t\t\t) {\n\t\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, isWithField ? lookupOptions : (lookupOptions | J9_LOOK_NO_NESTMATES));\n\t\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\t\tbadMemberModifier = J9AccPrivate;\n\t\t\t\t\t\ttargetClass = definingClass;\nillegalAccess:\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, nlsStr);\n\t\t\t\t\t\t\tj9mem_free_memory(nlsStr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t\t\t/* The withfield bytecode is allowed to set a final field. However, the invoker of withfield must have private access\n\t\t\t\t\t\t\t * to the field (similar to a constructor setting a final field). The private access check is done above, so if we get\n\t\t\t\t\t\t\t * to this point we can skip the finalFieldSetAllowed() if we know its a withfield */\n\t\t\t\t\t\t\t!isWithField &&\n#endif\n\t\t\t\t\t\t\t!finalFieldSetAllowed(vmStruct, false, method, definingClass, classFromCP, field, canRunJavaCode)\n\t\t\t\t\t) {\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (ramCPEntry != NULL) {\n\t\t\t\tUDATA valueOffset = fieldOffset;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\tflattenedClassCache = definingClass->flattenedClassCache;\n\t\t\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\t\t\tflattenableClass = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->clazz;\n\t\t\t\t\t}\n\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(flattenableClass->classFlags, J9ClassIsFlattened)) {\n\t\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\t\tJ9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->offset = valueOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodifiers |= J9FieldFlagFlattened;\n\t\t\t\t\t\tvalueOffset = (UDATA) J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\t\t\t/* offset must be written to flattenedClassCache before fieldref is marked as resolved */\n\t\t\t\t\t\tissueWriteBarrier();\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* Sign extend the resolved constant to make sure that it is always larger than valueOffset field */\n\t\t\t\tmodifiers |= (UDATA)(IDATA)(I_32) J9FieldFlagResolved;\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tmodifiers |= J9FieldFlagPutResolved;\n\t\t\t\t}\n\t\t\t\tramCPEntry->valueOffset = valueOffset;\n\t\t\t\tramCPEntry->flags = modifiers;\n\t\t\t}\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveInstanceFieldRef_Exit(vmStruct, fieldOffset);\n\treturn fieldOffset;\n}",
  "abstract_func_before": "IDATA   \nresolveInstanceFieldRefInto(J9VMThread *VAR_0, J9Method *VAR_1, J9ConstantPool *VAR_2, UDATA VAR_3, UDATA VAR_4, J9ROMFieldShape **VAR_5, J9RAMFieldRef *VAR_6)\n{\n\tIDATA VAR_7 = -1;\n\tJ9ROMFieldRef *VAR_8;\n\tJ9Class *VAR_9;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_4, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_4, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_4, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveInstanceFieldRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);\n\t\n\t/* COMMENT_0 */\n\tVAR_8 = (J9ROMFieldRef *)&VAR_2->romConstantPool[VAR_3];\n\t/* COMMENT_1 */\n\tVAR_9 = resolveClassRef(VAR_0, VAR_2, VAR_8->classRefCPIndex, VAR_4);\n\t\n\t/* COMMENT_2 */\n\tif (VAR_9 != NULL) {\n\t\tJ9JavaVM *VAR_19 = VAR_0->javaVM;\n\t\tJ9Class *VAR_20 = J9_CLASS_FROM_CP(VAR_2);\n\t\tJ9ROMFieldShape *VAR_21;\n\t\tJ9Class *VAR_22;\n\t\tJ9ROMNameAndSignature *VAR_23;\n\t\tJ9UTF8 *VAR_24;\n\t\tJ9UTF8 *VAR_25;\n\t\tIDATA VAR_26 = VAR_27;\n\t\tIDATA VAR_28 = 0;\n\t\tJ9Class *VAR_29 = NULL;\n\t\tUDATA VAR_30 = 0;\n\t\tchar *VAR_31 = NULL;\n#if defined(VAR_32)\n\t\tUDATA VAR_33 = 0;\n\t\tbool VAR_34 = true;\n\t\tJ9Class *VAR_35 = NULL;\n\t\tJ9FlattenedClassCache *VAR_36 = NULL;\n#endif\t\t\n\t\tbool VAR_37 = false;\n\t\tJ9Class *VAR_38 = NULL;\n\t\tJ9Class *VAR_39 = NULL;\n\n\t\t/* COMMENT_3 */\n\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_9, VAR_9->romClass->modifiers, VAR_16);\n\t\tif (VAR_26 < VAR_40) {\n\t\t\tVAR_28 = VAR_9->romClass->modifiers;\n\t\t\tVAR_29 = VAR_9;\n\t\t\tgoto illegalAccess;\n\t\t}\n\t\t/* COMMENT_4 */\n\t\tVAR_26 = VAR_27;\n\n\t\t/* COMMENT_5 */\n\t\tVAR_23 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_8);\n\t\tVAR_24 = J9ROMNAMEANDSIGNATURE_NAME(VAR_23);\n\t\tVAR_25 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_23);\n#if defined(VAR_32)\n\t\tVAR_37 = J9_ARE_ANY_BITS_SET(VAR_4, VAR_41);\n\t\t/* COMMENT_6 */\n                                                                          \n                                                                    \n                                                                \n                                                                     \n                                                      \n     \n\t\tif (J9_IS_J9CLASS_VALUETYPE(VAR_9)) {\n\t\t\tif ('Q' == J9UTF8_DATA(VAR_25)[0]) {\n\t\t\t\tVAR_36 = VAR_9->flattenedClassCache;\n\t\t\t\tVAR_33 = findIndexInFlattenedClassCache(VAR_36, VAR_23);\n\t\t\t\tAssert_VM_false(VAR_42 == VAR_33);\n\t\t\t\tJ9FlattenedClassCacheEntry * VAR_43 = J9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33);\n\t\t\t\tVAR_7 = VAR_43->offset;\n\t\t\t\tif (-1 != VAR_7) {\n\t\t\t\t\tVAR_22 = VAR_9;\n\t\t\t\t\tVAR_21 = VAR_43->field;\n\t\t\t\t\tVAR_35 = J9_VM_FCC_CLASS_FROM_ENTRY(VAR_43);\n\t\t\t\t\tVAR_34 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (VAR_34) \n#endif\n\t\t{\n\t\t\tVAR_7 = instanceFieldOffsetWithSourceClass(VAR_0, VAR_9, J9UTF8_DATA(VAR_24), J9UTF8_LENGTH(VAR_24), J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), &VAR_22, (UDATA *)&VAR_21, VAR_16, VAR_20);\n\t\t}\n\t\t/* COMMENT_13 */\n\t\tif (VAR_7 != -1) {\n\t\t\tVAR_38 = J9_CURRENT_CLASS(VAR_9);\n\t\t\tVAR_39 = J9_CURRENT_CLASS(VAR_20);\n\t\t\tVAR_30 = VAR_21->modifiers;\n\n\t\t\t/* COMMENT_14 */\n                                                                             \n      \n\t\t\tif (J9_ARE_ALL_BITS_SET(VAR_30, VAR_44)\n\t\t\t&& J9_ARE_NO_BITS_SET(VAR_30, VAR_45)\n\t\t\t&& !J9ROMCLASS_IS_ARRAY(VAR_38->romClass)\n\t\t\t&& isSameOrSuperClassOf(VAR_22, VAR_39)\n\t\t\t&& (VAR_22->packageID != VAR_39->packageID)\n\t\t\t&& !isSameOrSuperClassOf(VAR_39, VAR_38)\n\t\t\t&& !isSameOrSuperClassOf(VAR_38, VAR_39)\n\t\t\t) {\n\t\t\t\tVAR_28 = VAR_30;\n\t\t\t\tVAR_29 = VAR_38;\n\t\t\t\tgoto illegalAccess;\n\t\t\t}\n\n\t\t\tif ((VAR_30 & VAR_46) != 0) {\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_4, VAR_47)\n#if defined(VAR_32)\n\t\t\t\t\t|| VAR_37\n#endif /* COMMENT_17 */\n\t\t\t\t) {\n\t\t\t\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_22, VAR_48, VAR_37 ? VAR_16 : (VAR_16 | VAR_49));\n\t\t\t\t\tif (VAR_26 < VAR_40) {\n\t\t\t\t\t\tVAR_28 = VAR_48;\n\t\t\t\t\t\tVAR_29 = VAR_22;\nillegalAccess:\n\t\t\t\t\t\tVAR_7 = -1;\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(VAR_0);\n\t\t\t\t\t\t\tif (VAR_27 == VAR_26) {\n\t\t\t\t\t\t\t\tVAR_31 = illegalAccessMessage(VAR_0, VAR_28, VAR_20, VAR_29, VAR_27);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tVAR_31 = illegalAccessMessage(VAR_0, -1, VAR_20, VAR_29, VAR_26);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_50, VAR_31);\n\t\t\t\t\t\t\tj9mem_free_memory(VAR_31);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n#if defined(VAR_32)\n\t\t\t\t\t\t\t/* COMMENT_18 */\n                                                                                                                             \n                                                                                            \n\t\t\t\t\t\t\t!VAR_37 &&\n#endif\n\t\t\t\t\t\t\t!finalFieldSetAllowed(VAR_0, false, VAR_1, VAR_22, VAR_20, VAR_21, VAR_12)\n\t\t\t\t\t) {\n\t\t\t\t\t\tVAR_7 = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_21 */\n\t\t\tif ((VAR_19->runtimeFlags & VAR_51) != 0) {\n\t\t\t\tJ9ClassLoader *VAR_52 = VAR_20->classLoader;\n\t\t\t\tJ9ClassLoader *VAR_53 = VAR_22->classLoader;\n\n\t\t\t\tif (VAR_52 == NULL) {\n\t\t\t\t\tVAR_52 = VAR_19->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (VAR_52 != VAR_53) {\n\t\t\t\t\tJ9UTF8 *VAR_54 = J9ROMFIELDSHAPE_SIGNATURE(VAR_21);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(VAR_0, VAR_52, VAR_53, VAR_25, VAR_54) != 0) {\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_55, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_7 = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (VAR_6 != NULL) {\n\t\t\t\tUDATA VAR_56 = VAR_7;\n#if defined(VAR_32)\n\t\t\t\tif ('Q' == J9UTF8_DATA(VAR_25)[0]) {\n\t\t\t\t\tif (VAR_34) {\n\t\t\t\t\t\tVAR_36 = VAR_22->flattenedClassCache;\n\t\t\t\t\t\tVAR_33 = findIndexInFlattenedClassCache(VAR_36, VAR_23);\n\t\t\t\t\t\tVAR_35 = J9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33)->clazz;\n\t\t\t\t\t}\n\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(VAR_35->classFlags, VAR_57)) {\n\t\t\t\t\t\tif (VAR_34) {\n\t\t\t\t\t\t\tJ9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33)->offset = VAR_56;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_30 |= VAR_58;\n\t\t\t\t\t\tVAR_56 = (UDATA) J9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33);\n\t\t\t\t\t\t/* COMMENT_22 */\n\t\t\t\t\t\tissueWriteBarrier();\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* COMMENT_23 */\n\t\t\t\tVAR_30 |= (UDATA)(IDATA)(I_32) VAR_59;\n\t\t\t\tif (0 != (VAR_4 & VAR_47)) {\n\t\t\t\t\tVAR_30 |= VAR_60;\n\t\t\t\t}\n\t\t\t\tVAR_6->valueOffset = VAR_56;\n\t\t\t\tVAR_6->flags = VAR_30;\n\t\t\t}\n\n\t\t\tif (VAR_5 != NULL) {\n\t\t\t\t*VAR_5 = VAR_21;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveInstanceFieldRef_Exit(VAR_0, VAR_7);\n\treturn VAR_7;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/12.json",
  "func": "IDATA   \nresolveInstanceFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMFieldRef *ramCPEntry)\n{\n\tIDATA fieldOffset = -1;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInstanceFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\t\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If clazz is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tchar *nlsStr = NULL;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tUDATA fieldIndex = 0;\n\t\tbool fccEntryFieldNotSet = true;\n\t\tJ9Class *flattenableClass = NULL;\n\t\tJ9FlattenedClassCache *flattenedClassCache = NULL;\n#endif\t\t\n\t\tbool isWithField = false;\n\t\tJ9Class *currentTargetClass = NULL;\n\t\tJ9Class *currentSenderClass = NULL;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\ttargetClass = resolvedClass;\n\t\t\tgoto illegalAccess;\n\t\t}\n\t\t/* Reset checkResult to the default error case */\n\t\tcheckResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tisWithField = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_WITH_FIELD);\n\t\t/**\n\t\t * This is an optimization that searches for a field offset in the FCC. \n\t\t * If the offset is found there is no need to repeat the process. \n\t\t * Also, since this optimization is only done for ValueTypes, \n\t\t * the resolvedClass will always be the class that owns the field, \n\t\t * since ValueType superclasses can not have fields.\n\t\t */\n\t\tif (J9_IS_J9CLASS_VALUETYPE(resolvedClass)) {\n\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\tflattenedClassCache = resolvedClass->flattenedClassCache;\n\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\tAssert_VM_false(UDATA_MAX == fieldIndex);\n\t\t\t\tJ9FlattenedClassCacheEntry * flattenedClassCacheEntry = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\tfieldOffset = flattenedClassCacheEntry->offset;\n\t\t\t\tif (-1 != fieldOffset) {\n\t\t\t\t\tdefiningClass = resolvedClass;\n\t\t\t\t\tfield = flattenedClassCacheEntry->field;\n\t\t\t\t\tflattenableClass = J9_VM_FCC_CLASS_FROM_ENTRY(flattenedClassCacheEntry);\n\t\t\t\t\tfccEntryFieldNotSet = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fccEntryFieldNotSet) \n#endif\n\t\t{\n\t\t\tfieldOffset = instanceFieldOffsetWithSourceClass(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t}\n\t\t/* Stop if an exception occurred. */\n\t\tif (fieldOffset != -1) {\n\t\t\tcurrentTargetClass = J9_CURRENT_CLASS(resolvedClass);\n\t\t\tcurrentSenderClass = J9_CURRENT_CLASS(classFromCP);\n\t\t\tmodifiers = field->modifiers;\n\n\t\t\t/* Add the field checking to ensure IllegalAccessError\n\t\t\t * gets thrown out in the case of protected field if in different packages\n\t\t\t */\n\t\t\tif (J9_ARE_ALL_BITS_SET(modifiers, J9AccProtected)\n\t\t\t&& J9_ARE_NO_BITS_SET(modifiers, J9AccStatic)\n\t\t\t&& !J9ROMCLASS_IS_ARRAY(currentTargetClass->romClass)\n\t\t\t&& isSameOrSuperClassOf(definingClass, currentSenderClass)\n\t\t\t&& (definingClass->packageID != currentSenderClass->packageID)\n\t\t\t&& !isSameOrSuperClassOf(currentSenderClass, currentTargetClass)\n\t\t\t&& !isSameOrSuperClassOf(currentTargetClass, currentSenderClass)\n\t\t\t) {\n\t\t\t\tbadMemberModifier = modifiers;\n\t\t\t\ttargetClass = currentTargetClass;\n\t\t\t\tgoto illegalAccess;\n\t\t\t}\n\n\t\t\tif ((modifiers & J9AccFinal) != 0) {\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_FIELD_SETTER)\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t|| isWithField\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\t\t\t\t) {\n\t\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, isWithField ? lookupOptions : (lookupOptions | J9_LOOK_NO_NESTMATES));\n\t\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\t\tbadMemberModifier = J9AccPrivate;\n\t\t\t\t\t\ttargetClass = definingClass;\nillegalAccess:\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, nlsStr);\n\t\t\t\t\t\t\tj9mem_free_memory(nlsStr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t\t\t/* The withfield bytecode is allowed to set a final field. However, the invoker of withfield must have private access\n\t\t\t\t\t\t\t * to the field (similar to a constructor setting a final field). The private access check is done above, so if we get\n\t\t\t\t\t\t\t * to this point we can skip the finalFieldSetAllowed() if we know its a withfield */\n\t\t\t\t\t\t\t!isWithField &&\n#endif\n\t\t\t\t\t\t\t!finalFieldSetAllowed(vmStruct, false, method, definingClass, classFromCP, field, canRunJavaCode)\n\t\t\t\t\t) {\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\tUDATA valueOffset = fieldOffset;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\tflattenedClassCache = definingClass->flattenedClassCache;\n\t\t\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\t\t\tflattenableClass = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->clazz;\n\t\t\t\t\t}\n\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(flattenableClass->classFlags, J9ClassIsFlattened)) {\n\t\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\t\tJ9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->offset = valueOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodifiers |= J9FieldFlagFlattened;\n\t\t\t\t\t\tvalueOffset = (UDATA) J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\t\t\t/* offset must be written to flattenedClassCache before fieldref is marked as resolved */\n\t\t\t\t\t\tissueWriteBarrier();\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* Sign extend the resolved constant to make sure that it is always larger than valueOffset field */\n\t\t\t\tmodifiers |= (UDATA)(IDATA)(I_32) J9FieldFlagResolved;\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tmodifiers |= J9FieldFlagPutResolved;\n\t\t\t\t}\n\t\t\t\tramCPEntry->valueOffset = valueOffset;\n\t\t\t\tramCPEntry->flags = modifiers;\n\t\t\t}\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveInstanceFieldRef_Exit(vmStruct, fieldOffset);\n\treturn fieldOffset;\n}",
  "abstract_func": "IDATA   \nresolveInstanceFieldRefInto(J9VMThread *VAR_0, J9Method *VAR_1, J9ConstantPool *VAR_2, UDATA VAR_3, UDATA VAR_4, J9ROMFieldShape **VAR_5, J9RAMFieldRef *VAR_6)\n{\n\tIDATA VAR_7 = -1;\n\tJ9ROMFieldRef *VAR_8;\n\tJ9Class *VAR_9;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_4, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_4, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_4, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveInstanceFieldRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5);\n\t\n\t/* COMMENT_0 */\n\tVAR_8 = (J9ROMFieldRef *)&VAR_2->romConstantPool[VAR_3];\n\t/* COMMENT_1 */\n\tVAR_9 = resolveClassRef(VAR_0, VAR_2, VAR_8->classRefCPIndex, VAR_4);\n\t\n\t/* COMMENT_2 */\n\tif (VAR_9 != NULL) {\n\t\tJ9JavaVM *VAR_19 = VAR_0->javaVM;\n\t\tJ9Class *VAR_20 = J9_CLASS_FROM_CP(VAR_2);\n\t\tJ9ROMFieldShape *VAR_21;\n\t\tJ9Class *VAR_22;\n\t\tJ9ROMNameAndSignature *VAR_23;\n\t\tJ9UTF8 *VAR_24;\n\t\tJ9UTF8 *VAR_25;\n\t\tIDATA VAR_26 = VAR_27;\n\t\tIDATA VAR_28 = 0;\n\t\tJ9Class *VAR_29 = NULL;\n\t\tUDATA VAR_30 = 0;\n\t\tchar *VAR_31 = NULL;\n#if defined(VAR_32)\n\t\tUDATA VAR_33 = 0;\n\t\tbool VAR_34 = true;\n\t\tJ9Class *VAR_35 = NULL;\n\t\tJ9FlattenedClassCache *VAR_36 = NULL;\n#endif\t\t\n\t\tbool VAR_37 = false;\n\t\tJ9Class *VAR_38 = NULL;\n\t\tJ9Class *VAR_39 = NULL;\n\n\t\t/* COMMENT_3 */\n\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_9, VAR_9->romClass->modifiers, VAR_16);\n\t\tif (VAR_26 < VAR_40) {\n\t\t\tVAR_28 = VAR_9->romClass->modifiers;\n\t\t\tVAR_29 = VAR_9;\n\t\t\tgoto illegalAccess;\n\t\t}\n\t\t/* COMMENT_4 */\n\t\tVAR_26 = VAR_27;\n\n\t\t/* COMMENT_5 */\n\t\tVAR_23 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_8);\n\t\tVAR_24 = J9ROMNAMEANDSIGNATURE_NAME(VAR_23);\n\t\tVAR_25 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_23);\n#if defined(VAR_32)\n\t\tVAR_37 = J9_ARE_ANY_BITS_SET(VAR_4, VAR_41);\n\t\t/* COMMENT_6 */\n                                                                          \n                                                                    \n                                                                \n                                                                     \n                                                      \n     \n\t\tif (J9_IS_J9CLASS_VALUETYPE(VAR_9)) {\n\t\t\tif ('Q' == J9UTF8_DATA(VAR_25)[0]) {\n\t\t\t\tVAR_36 = VAR_9->flattenedClassCache;\n\t\t\t\tVAR_33 = findIndexInFlattenedClassCache(VAR_36, VAR_23);\n\t\t\t\tAssert_VM_false(VAR_42 == VAR_33);\n\t\t\t\tJ9FlattenedClassCacheEntry * VAR_43 = J9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33);\n\t\t\t\tVAR_7 = VAR_43->offset;\n\t\t\t\tif (-1 != VAR_7) {\n\t\t\t\t\tVAR_22 = VAR_9;\n\t\t\t\t\tVAR_21 = VAR_43->field;\n\t\t\t\t\tVAR_35 = J9_VM_FCC_CLASS_FROM_ENTRY(VAR_43);\n\t\t\t\t\tVAR_34 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (VAR_34) \n#endif\n\t\t{\n\t\t\tVAR_7 = instanceFieldOffsetWithSourceClass(VAR_0, VAR_9, J9UTF8_DATA(VAR_24), J9UTF8_LENGTH(VAR_24), J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), &VAR_22, (UDATA *)&VAR_21, VAR_16, VAR_20);\n\t\t}\n\t\t/* COMMENT_13 */\n\t\tif (VAR_7 != -1) {\n\t\t\tVAR_38 = J9_CURRENT_CLASS(VAR_9);\n\t\t\tVAR_39 = J9_CURRENT_CLASS(VAR_20);\n\t\t\tVAR_30 = VAR_21->modifiers;\n\n\t\t\t/* COMMENT_14 */\n                                                                             \n      \n\t\t\tif (J9_ARE_ALL_BITS_SET(VAR_30, VAR_44)\n\t\t\t&& J9_ARE_NO_BITS_SET(VAR_30, VAR_45)\n\t\t\t&& !J9ROMCLASS_IS_ARRAY(VAR_38->romClass)\n\t\t\t&& isSameOrSuperClassOf(VAR_22, VAR_39)\n\t\t\t&& (VAR_22->packageID != VAR_39->packageID)\n\t\t\t&& !isSameOrSuperClassOf(VAR_39, VAR_38)\n\t\t\t&& !isSameOrSuperClassOf(VAR_38, VAR_39)\n\t\t\t) {\n\t\t\t\tVAR_28 = VAR_30;\n\t\t\t\tVAR_29 = VAR_38;\n\t\t\t\tgoto illegalAccess;\n\t\t\t}\n\n\t\t\tif ((VAR_30 & VAR_46) != 0) {\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_4, VAR_47)\n#if defined(VAR_32)\n\t\t\t\t\t|| VAR_37\n#endif /* COMMENT_17 */\n\t\t\t\t) {\n\t\t\t\t\tVAR_26 = checkVisibility(VAR_0, VAR_20, VAR_22, VAR_48, VAR_37 ? VAR_16 : (VAR_16 | VAR_49));\n\t\t\t\t\tif (VAR_26 < VAR_40) {\n\t\t\t\t\t\tVAR_28 = VAR_48;\n\t\t\t\t\t\tVAR_29 = VAR_22;\nillegalAccess:\n\t\t\t\t\t\tVAR_7 = -1;\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(VAR_0);\n\t\t\t\t\t\t\tif (VAR_27 == VAR_26) {\n\t\t\t\t\t\t\t\tVAR_31 = illegalAccessMessage(VAR_0, VAR_28, VAR_20, VAR_29, VAR_27);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tVAR_31 = illegalAccessMessage(VAR_0, -1, VAR_20, VAR_29, VAR_26);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_50, VAR_31);\n\t\t\t\t\t\t\tj9mem_free_memory(VAR_31);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n#if defined(VAR_32)\n\t\t\t\t\t\t\t/* COMMENT_18 */\n                                                                                                                             \n                                                                                            \n\t\t\t\t\t\t\t!VAR_37 &&\n#endif\n\t\t\t\t\t\t\t!finalFieldSetAllowed(VAR_0, false, VAR_1, VAR_22, VAR_20, VAR_21, VAR_12)\n\t\t\t\t\t) {\n\t\t\t\t\t\tVAR_7 = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_21 */\n\t\t\tif ((VAR_19->runtimeFlags & VAR_51) != 0) {\n\t\t\t\tJ9ClassLoader *VAR_52 = VAR_20->classLoader;\n\t\t\t\tJ9ClassLoader *VAR_53 = VAR_22->classLoader;\n\n\t\t\t\tif (VAR_52 == NULL) {\n\t\t\t\t\tVAR_52 = VAR_19->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (VAR_52 != VAR_53) {\n\t\t\t\t\tJ9UTF8 *VAR_54 = J9ROMFIELDSHAPE_SIGNATURE(VAR_21);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(VAR_0, VAR_52, VAR_53, VAR_25, VAR_54) != 0) {\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_55, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_7 = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif ((NULL != VAR_6) && J9_ARE_NO_BITS_SET(VAR_4, VAR_56)) {\n\t\t\t\tUDATA VAR_57 = VAR_7;\n#if defined(VAR_32)\n\t\t\t\tif ('Q' == J9UTF8_DATA(VAR_25)[0]) {\n\t\t\t\t\tif (VAR_34) {\n\t\t\t\t\t\tVAR_36 = VAR_22->flattenedClassCache;\n\t\t\t\t\t\tVAR_33 = findIndexInFlattenedClassCache(VAR_36, VAR_23);\n\t\t\t\t\t\tVAR_35 = J9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33)->clazz;\n\t\t\t\t\t}\n\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(VAR_35->classFlags, VAR_58)) {\n\t\t\t\t\t\tif (VAR_34) {\n\t\t\t\t\t\t\tJ9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33)->offset = VAR_57;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_30 |= VAR_59;\n\t\t\t\t\t\tVAR_57 = (UDATA) J9_VM_FCC_ENTRY_FROM_FCC(VAR_36, VAR_33);\n\t\t\t\t\t\t/* COMMENT_22 */\n\t\t\t\t\t\tissueWriteBarrier();\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* COMMENT_23 */\n\t\t\t\tVAR_30 |= (UDATA)(IDATA)(I_32) VAR_60;\n\t\t\t\tif (0 != (VAR_4 & VAR_47)) {\n\t\t\t\t\tVAR_30 |= VAR_61;\n\t\t\t\t}\n\t\t\t\tVAR_6->valueOffset = VAR_57;\n\t\t\t\tVAR_6->flags = VAR_30;\n\t\t\t}\n\n\t\t\tif (VAR_5 != NULL) {\n\t\t\t\t*VAR_5 = VAR_21;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveInstanceFieldRef_Exit(VAR_0, VAR_7);\n\treturn VAR_7;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/12.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -171,7 +171,7 @@\n \t\t\t\t}\n \t\t\t}\n \t\t\n-\t\t\tif (ramCPEntry != NULL) {\n+\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\t\tUDATA valueOffset = fieldOffset;\n #if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n \t\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tif (ramCPEntry != NULL) {"
    ],
    "added_lines": [
      "\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8"
}