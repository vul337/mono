{
  "cve_id": "CVE-2018-9009",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "decompile: fix use-after-free in decompileJUMP\n\nSame issue as f42fdb4 (functions accessing actions array without\nchecking the validity of n, the user entered index), same fix.\n\nIn this patch we also fix other source code places which might be\naffected by the same bug.\n\nFixes #131 (CVE-2018-9009).",
  "commit_hash": "1d698a4b1f03d6136bbf2b0171b86985be553454",
  "git_url": "https://github.com/libming/libming/commit/1d698a4b1f03d6136bbf2b0171b86985be553454",
  "file_path": "util/decompile.c",
  "func_name": "decompileJUMP",
  "func_before": "static int\ndecompileJUMP(int n, SWF_ACTION *actions, int maxn)\n{\n\tint i=0,j=0;\n\tint offSave;\n\tstruct SWF_ACTIONIF *sactif;\n\tOUT_BEGIN2(SWF_ACTIONJUMP);\n\tsactif=NULL;\n\n\tif(isLogicalOp(n+1, actions, maxn) ||\n\t   (OpCode(actions, n+1, maxn) == SWFACTION_PUSH && isLogicalOp(n+2, actions, maxn)))\n\t{\n\t\t/* Probably the start of a do {} while(), so skip it */\n\t\treturn 0;\n\t}\n\n\t/* Probably the end of a switch{}, so skip it */\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t\treturn 1;\n\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_JUMP) \n\t{\n\t\tif (actions[n+1].SWF_ACTIONJUMP.BranchOffset==0)\n\t\t\treturn 1;\n\t}\n\n\tfor(i=0; n + 1 + i < maxn && (actions[(n+1)+i].SWF_ACTIONRECORD.Offset < (actions[n+1].SWF_ACTIONRECORD.Offset+actions[n ].SWF_ACTIONJUMP.BranchOffset)); i++)\n\t{\n#if 0\n\t\tprintf(\"/* for PART3 OP 0x%x */\\n\",actions[n+1+i].SWF_ACTIONRECORD.ActionCode);\n#endif\n\t\t; // NOOP\n\t}\n\n\tif (i)\n\t{\n\t\tfor (j=0; n+j+i<maxn; j++)\n\t\t{\n#if 0\n\t\t\t printf(\"/* FOR part2 OP 0x%x */\\n\",actions[n+i+j].SWF_ACTIONRECORD.ActionCode)\n\t\t\t// at least one should push on stack\n#endif\n\t \n\t\t\tif (OpCode(actions, n+i+j, maxn) == SWFACTION_IF)\n\t\t\t{\n\t\t\t\tsactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);\n\t\t\t\t/* chk whether last jump does lead us back to start of loop */\n\t\t\t\tif (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP\n\t\t\t\t    && sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+\n\t\t\t\t    sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==\n\t\t\t\t    actions[n].SWF_ACTIONRECORD.Offset )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsactif=NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sactif)\n\t{\n\t\tINDENT\n\t\tputs(\"while(\");\n\t\tdecompileActions(j-1, &actions[n+1+i], gIndent);\n\t\tputs(getName(pop()));\n\t\tprintln(\"){         /* original FOR loop rewritten to WHILE */\");\n\t\toffSave=offseoloop;\n\t\tif (n+i+j+1<maxn)\t\t\t\t\t\t// see part2 above\n\t\t\toffseoloop=actions[n+i+j+1].SWF_ACTIONRECORD.Offset;\n\t\telse\n\t\t\toffseoloop=actions[n+i+j].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sactif->numActions-1, sactif->Actions,gIndent+1);\n\t\tdecompileActions(i, &actions[n+1], gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tprintln(\"};\");\n\t\treturn i+j; \n\t}\n\t\n\tif (sact->BranchOffset>0)\n\t{\n\t\tif ( stackVal(n,actions) == 1 && n+1==maxn)\n\t\t{\t// leaving block @last op with value on stack: a return x;\n\t\t\treturn decompileRETURN(n, actions,maxn);\n\t\t}\n\t\tif (n+2 < maxn && OpCode(actions, n+1, maxn) == SWFACTION_PUSH && \n\t\t\tactions[n+2].SWF_ACTIONRECORD.Offset == actions[n+1].SWF_ACTIONRECORD.Offset+sact->BranchOffset)\n\t\t{\n\t\t\treturn 1; \t// jump to short to be a 'break': but an internal jump over a push\n\t\t}\t\t\t// to do: add some control flow analysis\n\t\t\n\t\tINDENT\n\t\t\n\t\tif (offseoloop==actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5)\n\t\t\tputs(\"break;\" );\n\t\telse\n\t\t\tputs(\"return;\" );\n\t\t\n\t\tprintln(\"\\t\\t\\t// offs_end_of_loop=%d  offs_jmp_dest=%d\",\n\t\t        offseoloop, actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5);\n\t}\n\telse\n\t{\n\t\tif (sact->BranchOffset<0)\n\t\t{\n\t\t\tINDENT\n\t\t\tprintln(\"continue;     /*------*/\");\n\t\t}\n\t}\n\t/* error(\"Unhandled JUMP\"); */\n\treturn 0;\n}",
  "abstract_func_before": "static int\ndecompileJUMP(int VAR_0, SWF_ACTION *VAR_1, int VAR_2)\n{\n\tint VAR_3=0,VAR_4=0;\n\tint VAR_5;\n\tstruct SWF_ACTIONIF *VAR_6;\n\tOUT_BEGIN2(VAR_7);\n\tVAR_6=NULL;\n\n\tif(isLogicalOp(VAR_0+1, VAR_1, VAR_2) ||\n\t   (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && isLogicalOp(VAR_0+2, VAR_1, VAR_2)))\n\t{\n\t\t/* COMMENT_0 */\n\t\treturn 0;\n\t}\n\n\t/* COMMENT_1 */\n\tif (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_9)\n\t\treturn 1;\n\n\tif (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_10) \n\t{\n\t\tif (VAR_1[VAR_0+1].SWF_ACTIONJUMP.BranchOffset==0)\n\t\t\treturn 1;\n\t}\n\n\tfor(VAR_3=0; VAR_0 + 1 + VAR_3 < VAR_2 && (VAR_1[(VAR_0+1)+VAR_3].SWF_ACTIONRECORD.Offset < (VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_1[VAR_0 ].SWF_ACTIONJUMP.BranchOffset)); VAR_3++)\n\t{\n#if 0\n\t\tprintf(\"/* for PART3 OP 0x%x */\\n\",VAR_1[VAR_0+1+VAR_3].SWF_ACTIONRECORD.ActionCode);\n#endif\n\t\t; /* COMMENT_2 */\n\t}\n\n\tif (VAR_3)\n\t{\n\t\tfor (VAR_4=0; VAR_0+VAR_4+VAR_3<VAR_2; VAR_4++)\n\t\t{\n#if 0\n\t\t\t printf(\"/* FOR part2 OP 0x%x */\\n\",VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.ActionCode)\n\t\t\t/* COMMENT_3 */\n#endif\n\t \n\t\t\tif (OpCode(VAR_1, VAR_0+VAR_3+VAR_4, VAR_2) == VAR_11)\n\t\t\t{\n\t\t\t\tVAR_6 = (struct SWF_ACTIONIF *)&(VAR_1[VAR_0+VAR_3+VAR_4]);\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tif (VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONRECORD.ActionCode==VAR_10\n\t\t\t\t    && VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.BranchOffset+\n\t\t\t\t    VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.Offset==\n\t\t\t\t    VAR_1[VAR_0].SWF_ACTIONRECORD.Offset )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tVAR_6=NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (VAR_6)\n\t{\n\t\tINDENT\n\t\tVAR_12(\"while(\");\n\t\tdecompileActions(VAR_4-1, &VAR_1[VAR_0+1+VAR_3], VAR_13);\n\t\tVAR_12(getName(pop()));\n\t\tprintln(\"){         /* original FOR loop rewritten to WHILE */\");\n\t\tVAR_5=VAR_14;\n\t\tif (VAR_0+VAR_3+VAR_4+1<VAR_2)\t\t\t\t\t\t/* COMMENT_5 */\n\t\t\tVAR_14=VAR_1[VAR_0+VAR_3+VAR_4+1].SWF_ACTIONRECORD.Offset;\n\t\telse\n\t\t\tVAR_14=VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(VAR_6->numActions-1, VAR_6->Actions,VAR_13+1);\n\t\tdecompileActions(VAR_3, &VAR_1[VAR_0+1], VAR_13+1);\n\t\tVAR_14=VAR_5;\n\t\tINDENT\n\t\tVAR_15(\"};\");\n\t\treturn VAR_3+VAR_4; \n\t}\n\t\n\tif (VAR_16->BranchOffset>0)\n\t{\n\t\tif ( stackVal(VAR_0,VAR_1) == 1 && VAR_0+1==VAR_2)\n\t\t{\t/* COMMENT_6 */\n\t\t\treturn decompileRETURN(VAR_0, VAR_1,VAR_2);\n\t\t}\n\t\tif (VAR_0+2 < VAR_2 && OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && \n\t\t\tVAR_1[VAR_0+2].SWF_ACTIONRECORD.Offset == VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset)\n\t\t{\n\t\t\treturn 1; \t/* COMMENT_7 */\n\t\t}\t\t\t/* COMMENT_8 */\n\t\t\n\t\tINDENT\n\t\t\n\t\tif (offseoloop==VAR_1[VAR_0].VAR_17.VAR_18+VAR_16->VAR_19+5)\n\t\t\tVAR_12(\"break;\" );\n\t\telse\n\t\t\tVAR_12(\"return;\" );\n\t\t\n\t\tVAR_15(\"\\t\\t\\t// offs_end_of_loop=%d  offs_jmp_dest=%d\",\n\t\t        offseoloop, VAR_1[VAR_0].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset+5);\n\t}\n\telse\n\t{\n\t\tif (VAR_16->BranchOffset<0)\n\t\t{\n\t\t\tINDENT\n\t\t\tVAR_15(\"continue;     /* COMMENT_9 */\");\n\t\t}\n\t}\n\t/* COMMENT_10 */\n\treturn 0;\n}",
  "func_graph_path_before": "libming/1d698a4b1f03d6136bbf2b0171b86985be553454/decompile.c/vul/before/0.json",
  "func": "static int\ndecompileJUMP(int n, SWF_ACTION *actions, int maxn)\n{\n\tint i=0,j=0;\n\tint offSave;\n\tstruct SWF_ACTIONIF *sactif;\n\tOUT_BEGIN2(SWF_ACTIONJUMP);\n\tsactif=NULL;\n\n\tif(isLogicalOp(n+1, actions, maxn) ||\n\t   (OpCode(actions, n+1, maxn) == SWFACTION_PUSH && isLogicalOp(n+2, actions, maxn)))\n\t{\n\t\t/* Probably the start of a do {} while(), so skip it */\n\t\treturn 0;\n\t}\n\n\t/* Probably the end of a switch{}, so skip it */\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t\treturn 1;\n\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_JUMP) \n\t{\n\t\tif (actions[n+1].SWF_ACTIONJUMP.BranchOffset==0)\n\t\t\treturn 1;\n\t}\n\n\tfor(i=0; n + 1 + i < maxn && (actions[(n+1)+i].SWF_ACTIONRECORD.Offset < (actions[n+1].SWF_ACTIONRECORD.Offset+actions[n ].SWF_ACTIONJUMP.BranchOffset)); i++)\n\t{\n#if 0\n\t\tprintf(\"/* for PART3 OP 0x%x */\\n\",actions[n+1+i].SWF_ACTIONRECORD.ActionCode);\n#endif\n\t\t; // NOOP\n\t}\n\n\tif (i)\n\t{\n\t\tfor (j=0; n+j+i<maxn; j++)\n\t\t{\n#if 0\n\t\t\t printf(\"/* FOR part2 OP 0x%x */\\n\",actions[n+i+j].SWF_ACTIONRECORD.ActionCode)\n\t\t\t// at least one should push on stack\n#endif\n\t \n\t\t\tif (OpCode(actions, n+i+j, maxn) == SWFACTION_IF)\n\t\t\t{\n\t\t\t\tsactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);\n\t\t\t\t/* chk whether last jump does lead us back to start of loop */\n\t\t\t\tif (OpCode(sactif->Actions, sactif->numActions-1, maxn) == SWFACTION_JUMP\n\t\t\t\t    && sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+\n\t\t\t\t    sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==\n\t\t\t\t    actions[n].SWF_ACTIONRECORD.Offset )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsactif=NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sactif)\n\t{\n\t\tINDENT\n\t\tputs(\"while(\");\n\t\tdecompileActions(j-1, &actions[n+1+i], gIndent);\n\t\tputs(getName(pop()));\n\t\tprintln(\"){         /* original FOR loop rewritten to WHILE */\");\n\t\toffSave=offseoloop;\n\t\tif (n+i+j+1<maxn)\t\t\t\t\t\t// see part2 above\n\t\t\toffseoloop=actions[n+i+j+1].SWF_ACTIONRECORD.Offset;\n\t\telse\n\t\t\toffseoloop=actions[n+i+j].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(sactif->numActions-1, sactif->Actions,gIndent+1);\n\t\tdecompileActions(i, &actions[n+1], gIndent+1);\n\t\toffseoloop=offSave;\n\t\tINDENT\n\t\tprintln(\"};\");\n\t\treturn i+j; \n\t}\n\t\n\tif (sact->BranchOffset>0)\n\t{\n\t\tif ( stackVal(n,actions) == 1 && n+1==maxn)\n\t\t{\t// leaving block @last op with value on stack: a return x;\n\t\t\treturn decompileRETURN(n, actions,maxn);\n\t\t}\n\t\tif (n+2 < maxn && OpCode(actions, n+1, maxn) == SWFACTION_PUSH && \n\t\t\tactions[n+2].SWF_ACTIONRECORD.Offset == actions[n+1].SWF_ACTIONRECORD.Offset+sact->BranchOffset)\n\t\t{\n\t\t\treturn 1; \t// jump to short to be a 'break': but an internal jump over a push\n\t\t}\t\t\t// to do: add some control flow analysis\n\t\t\n\t\tINDENT\n\t\t\n\t\tif (offseoloop==actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5)\n\t\t\tputs(\"break;\" );\n\t\telse\n\t\t\tputs(\"return;\" );\n\t\t\n\t\tprintln(\"\\t\\t\\t// offs_end_of_loop=%d  offs_jmp_dest=%d\",\n\t\t        offseoloop, actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5);\n\t}\n\telse\n\t{\n\t\tif (sact->BranchOffset<0)\n\t\t{\n\t\t\tINDENT\n\t\t\tprintln(\"continue;     /*------*/\");\n\t\t}\n\t}\n\t/* error(\"Unhandled JUMP\"); */\n\treturn 0;\n}",
  "abstract_func": "static int\ndecompileJUMP(int VAR_0, SWF_ACTION *VAR_1, int VAR_2)\n{\n\tint VAR_3=0,VAR_4=0;\n\tint VAR_5;\n\tstruct SWF_ACTIONIF *VAR_6;\n\tOUT_BEGIN2(VAR_7);\n\tVAR_6=NULL;\n\n\tif(isLogicalOp(VAR_0+1, VAR_1, VAR_2) ||\n\t   (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && isLogicalOp(VAR_0+2, VAR_1, VAR_2)))\n\t{\n\t\t/* COMMENT_0 */\n\t\treturn 0;\n\t}\n\n\t/* COMMENT_1 */\n\tif (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_9)\n\t\treturn 1;\n\n\tif (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_10) \n\t{\n\t\tif (VAR_1[VAR_0+1].SWF_ACTIONJUMP.BranchOffset==0)\n\t\t\treturn 1;\n\t}\n\n\tfor(VAR_3=0; VAR_0 + 1 + VAR_3 < VAR_2 && (VAR_1[(VAR_0+1)+VAR_3].SWF_ACTIONRECORD.Offset < (VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_1[VAR_0 ].SWF_ACTIONJUMP.BranchOffset)); VAR_3++)\n\t{\n#if 0\n\t\tprintf(\"/* for PART3 OP 0x%x */\\n\",VAR_1[VAR_0+1+VAR_3].SWF_ACTIONRECORD.ActionCode);\n#endif\n\t\t; /* COMMENT_2 */\n\t}\n\n\tif (VAR_3)\n\t{\n\t\tfor (VAR_4=0; VAR_0+VAR_4+VAR_3<VAR_2; VAR_4++)\n\t\t{\n#if 0\n\t\t\t printf(\"/* FOR part2 OP 0x%x */\\n\",VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.ActionCode)\n\t\t\t/* COMMENT_3 */\n#endif\n\t \n\t\t\tif (OpCode(VAR_1, VAR_0+VAR_3+VAR_4, VAR_2) == VAR_11)\n\t\t\t{\n\t\t\t\tVAR_6 = (struct SWF_ACTIONIF *)&(VAR_1[VAR_0+VAR_3+VAR_4]);\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tif (OpCode(VAR_6->Actions, VAR_6->numActions-1, VAR_2) == VAR_10\n\t\t\t\t    && VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.BranchOffset+\n\t\t\t\t    VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.Offset==\n\t\t\t\t    VAR_1[VAR_0].SWF_ACTIONRECORD.Offset )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tVAR_6=NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (VAR_6)\n\t{\n\t\tINDENT\n\t\tVAR_12(\"while(\");\n\t\tdecompileActions(VAR_4-1, &VAR_1[VAR_0+1+VAR_3], VAR_13);\n\t\tVAR_12(getName(pop()));\n\t\tprintln(\"){         /* original FOR loop rewritten to WHILE */\");\n\t\tVAR_5=VAR_14;\n\t\tif (VAR_0+VAR_3+VAR_4+1<VAR_2)\t\t\t\t\t\t/* COMMENT_5 */\n\t\t\tVAR_14=VAR_1[VAR_0+VAR_3+VAR_4+1].SWF_ACTIONRECORD.Offset;\n\t\telse\n\t\t\tVAR_14=VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.Offset+5;\n\t\tdecompileActions(VAR_6->numActions-1, VAR_6->Actions,VAR_13+1);\n\t\tdecompileActions(VAR_3, &VAR_1[VAR_0+1], VAR_13+1);\n\t\tVAR_14=VAR_5;\n\t\tINDENT\n\t\tVAR_15(\"};\");\n\t\treturn VAR_3+VAR_4; \n\t}\n\t\n\tif (VAR_16->BranchOffset>0)\n\t{\n\t\tif ( stackVal(VAR_0,VAR_1) == 1 && VAR_0+1==VAR_2)\n\t\t{\t/* COMMENT_6 */\n\t\t\treturn decompileRETURN(VAR_0, VAR_1,VAR_2);\n\t\t}\n\t\tif (VAR_0+2 < VAR_2 && OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && \n\t\t\tVAR_1[VAR_0+2].SWF_ACTIONRECORD.Offset == VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset)\n\t\t{\n\t\t\treturn 1; \t/* COMMENT_7 */\n\t\t}\t\t\t/* COMMENT_8 */\n\t\t\n\t\tINDENT\n\t\t\n\t\tif (offseoloop==VAR_1[VAR_0].VAR_17.VAR_18+VAR_16->VAR_19+5)\n\t\t\tVAR_12(\"break;\" );\n\t\telse\n\t\t\tVAR_12(\"return;\" );\n\t\t\n\t\tVAR_15(\"\\t\\t\\t// offs_end_of_loop=%d  offs_jmp_dest=%d\",\n\t\t        offseoloop, VAR_1[VAR_0].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset+5);\n\t}\n\telse\n\t{\n\t\tif (VAR_16->BranchOffset<0)\n\t\t{\n\t\t\tINDENT\n\t\t\tVAR_15(\"continue;     /* COMMENT_9 */\");\n\t\t}\n\t}\n\t/* COMMENT_10 */\n\treturn 0;\n}",
  "func_graph_path": "libming/1d698a4b1f03d6136bbf2b0171b86985be553454/decompile.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \t\t\t{\n \t\t\t\tsactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);\n \t\t\t\t/* chk whether last jump does lead us back to start of loop */\n-\t\t\t\tif (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP\n+\t\t\t\tif (OpCode(sactif->Actions, sactif->numActions-1, maxn) == SWFACTION_JUMP\n \t\t\t\t    && sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+\n \t\t\t\t    sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==\n \t\t\t\t    actions[n].SWF_ACTIONRECORD.Offset )",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tif (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP"
    ],
    "added_lines": [
      "\t\t\t\tif (OpCode(sactif->Actions, sactif->numActions-1, maxn) == SWFACTION_JUMP"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/145",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libming/libming/pull/145: 403 Client Error: Forbidden for url: https://api.github.com/repos/libming/libming/pulls/145",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a use-after-free vulnerability, confirmed by the code changes and CVE reference. \n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\n# Final Answer\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}