{
  "cve_id": "CVE-2023-1801",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "the-tcpdump-group/tcpdump",
  "commit_msg": "Have a common routine for converting dates and times to strings.\n\nHave a routine that takes a buffer, a strftime format, and a struct tm *\nas arguments, and:\n\n* checks whether the struct tm * is null and, if so, returns a string\nindicating that the date and time couldn't be converted;\n\n* otherwise, passes it to strftime(), along with the buffer and the\nformat argument and, if strftime() returns 0, meaning the string didn't\nfit into the buffer and thus that the buffer's contents are undefined,\nreturns a string indicating that the date and time didn't fit into the\nbuffer;\n\n* otherwise, returns a pointer to the buffer.\n\nCall that routine instead of directly calling strftime() in printers;\nthat prevents printing a buffer with undefined data if the buffer isn't\nbig enough for the string.\n\nAlso, when generating file names using an strftime format, check the\nreturn value of strftime() to make sure the buffer didn't overflow.",
  "commit_hash": "7578e1c04ee280dda50c4c2813e7d55f539c6501",
  "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/7578e1c04ee280dda50c4c2813e7d55f539c6501",
  "file_path": "ntp.c",
  "func_name": "p_ntp_time",
  "func_before": "void\np_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t/* some compilers are buggy */\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t/* shift radix point by 32 bits */\n\tf = (uint32_t)(ff * 1000000000.0);\t/* treat fraction as parts per billion */\n\tND_PRINT(\"%u.%09u\", i, f);\n\n\t/*\n\t * print the UTC time in human-readable format.\n\t */\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    struct tm *tm;\n\t    char time_buf[128];\n\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\t/*\n\t\t * It doesn't fit into a time_t, so we can't hand it\n\t\t * to gmtime.\n\t\t */\n\t\tND_PRINT(\" (unrepresentable)\");\n\t    } else {\n\t\ttm = gmtime(&seconds);\n\t\tif (tm == NULL) {\n\t\t    /*\n\t\t     * gmtime() can't handle it.\n\t\t     * (Yes, that might happen with some version of\n\t\t     * Microsoft's C library.)\n\t\t     */\n\t\t    ND_PRINT(\" (unrepresentable)\");\n\t\t} else {\n\t\t    /* use ISO 8601 (RFC3339) format */\n\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\t    ND_PRINT(\" (%s)\", time_buf);\n\t\t}\n\t    }\n\t}\n}",
  "abstract_func_before": "void\np_ntp_time(netdissect_options *VAR_0,\n\t   const struct l_fixedpt *VAR_1)\n{\n\tuint32_t VAR_2;\n\tuint32_t VAR_3;\n\tuint32_t VAR_4;\n\tdouble VAR_5;\n\n\tVAR_2 = GET_BE_U_4(VAR_1->int_part);\n\tVAR_3 = GET_BE_U_4(VAR_1->fraction);\n\tVAR_5 = VAR_3;\n\tif (VAR_5 < 0.0)\t\t/* COMMENT_0 */\n\t\tVAR_5 += VAR_6;\n\tVAR_5 = VAR_5 / VAR_6;\t\t\t/* COMMENT_1 */\n\tVAR_4 = (uint32_t)(VAR_5 * 1000000000.0);\t/* COMMENT_2 */\n\tND_PRINT(\"%u.%09u\", VAR_2, VAR_4);\n\n\t/* COMMENT_3 */\n                                                \n    \n\tif (VAR_2) {\n\t    int64_t VAR_7 = (int64_t)VAR_2 - VAR_8;\n\t    time_t VAR_9;\n\t    struct tm *tm;\n\t    char VAR_10[128];\n\n\t    VAR_9 = (time_t)VAR_7;\n\t    if (VAR_9 != VAR_7) {\n\t\t/* COMMENT_6 */\n                                                      \n               \n     \n\t\tND_PRINT(\" (unrepresentable)\");\n\t    } else {\n\t\ttm = gmtime(&VAR_9);\n\t\tif (tm == NULL) {\n\t\t    /* COMMENT_10 */\n                                  \n                                                     \n                                \n         \n\t\t    ND_PRINT(\" (unrepresentable)\");\n\t\t} else {\n\t\t    /* COMMENT_15 */\n\t\t    strftime(VAR_10, sizeof (VAR_10), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\t    ND_PRINT(\" (%s)\", VAR_10);\n\t\t}\n\t    }\n\t}\n}",
  "func_graph_path_before": "the-tcpdump-group/tcpdump/7578e1c04ee280dda50c4c2813e7d55f539c6501/ntp.c/vul/before/0.json",
  "func": "void\np_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t/* some compilers are buggy */\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t/* shift radix point by 32 bits */\n\tf = (uint32_t)(ff * 1000000000.0);\t/* treat fraction as parts per billion */\n\tND_PRINT(\"%u.%09u\", i, f);\n\n\t/*\n\t * print the UTC time in human-readable format.\n\t */\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    char time_buf[128];\n\t    const char *time_string;\n\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\t/*\n\t\t * It doesn't fit into a time_t, so we can't hand it\n\t\t * to gmtime.\n\t\t */\n\t\ttime_string = \"[Time is too large to fit into a time_t]\";\n\t    } else {\n\t\t/* use ISO 8601 (RFC3339) format */\n\t\ttime_string = nd_format_time(time_buf, sizeof (time_buf),\n\t\t  \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&seconds));\n\t    }\n\t    ND_PRINT(\" (%s)\", time_string);\n\t}\n}",
  "abstract_func": "void\np_ntp_time(netdissect_options *VAR_0,\n\t   const struct l_fixedpt *VAR_1)\n{\n\tuint32_t VAR_2;\n\tuint32_t VAR_3;\n\tuint32_t VAR_4;\n\tdouble VAR_5;\n\n\tVAR_2 = GET_BE_U_4(VAR_1->int_part);\n\tVAR_3 = GET_BE_U_4(VAR_1->fraction);\n\tVAR_5 = VAR_3;\n\tif (VAR_5 < 0.0)\t\t/* COMMENT_0 */\n\t\tVAR_5 += VAR_6;\n\tVAR_5 = VAR_5 / VAR_6;\t\t\t/* COMMENT_1 */\n\tVAR_4 = (uint32_t)(VAR_5 * 1000000000.0);\t/* COMMENT_2 */\n\tND_PRINT(\"%u.%09u\", VAR_2, VAR_4);\n\n\t/* COMMENT_3 */\n                                                \n    \n\tif (VAR_2) {\n\t    int64_t VAR_7 = (int64_t)VAR_2 - VAR_8;\n\t    time_t VAR_9;\n\t    char VAR_10[128];\n\t    const char *VAR_11;\n\n\t    VAR_9 = (time_t)VAR_7;\n\t    if (VAR_9 != VAR_7) {\n\t\t/* COMMENT_6 */\n                                                      \n               \n     \n\t\tVAR_11 = \"[Time is too large to fit into a time_t]\";\n\t    } else {\n\t\t/* COMMENT_10 */\n\t\tVAR_11 = nd_format_time(VAR_10, sizeof (VAR_10),\n\t\t  \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&VAR_9));\n\t    }\n\t    ND_PRINT(\" (%s)\", VAR_11);\n\t}\n}",
  "func_graph_path": "the-tcpdump-group/tcpdump/7578e1c04ee280dda50c4c2813e7d55f539c6501/ntp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,8 +22,8 @@\n \tif (i) {\n \t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n \t    time_t seconds;\n-\t    struct tm *tm;\n \t    char time_buf[128];\n+\t    const char *time_string;\n \n \t    seconds = (time_t)seconds_64bit;\n \t    if (seconds != seconds_64bit) {\n@@ -31,21 +31,12 @@\n \t\t * It doesn't fit into a time_t, so we can't hand it\n \t\t * to gmtime.\n \t\t */\n-\t\tND_PRINT(\" (unrepresentable)\");\n+\t\ttime_string = \"[Time is too large to fit into a time_t]\";\n \t    } else {\n-\t\ttm = gmtime(&seconds);\n-\t\tif (tm == NULL) {\n-\t\t    /*\n-\t\t     * gmtime() can't handle it.\n-\t\t     * (Yes, that might happen with some version of\n-\t\t     * Microsoft's C library.)\n-\t\t     */\n-\t\t    ND_PRINT(\" (unrepresentable)\");\n-\t\t} else {\n-\t\t    /* use ISO 8601 (RFC3339) format */\n-\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n-\t\t    ND_PRINT(\" (%s)\", time_buf);\n-\t\t}\n+\t\t/* use ISO 8601 (RFC3339) format */\n+\t\ttime_string = nd_format_time(time_buf, sizeof (time_buf),\n+\t\t  \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&seconds));\n \t    }\n+\t    ND_PRINT(\" (%s)\", time_string);\n \t}\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\t    struct tm *tm;",
      "\t\tND_PRINT(\" (unrepresentable)\");",
      "\t\ttm = gmtime(&seconds);",
      "\t\tif (tm == NULL) {",
      "\t\t    /*",
      "\t\t     * gmtime() can't handle it.",
      "\t\t     * (Yes, that might happen with some version of",
      "\t\t     * Microsoft's C library.)",
      "\t\t     */",
      "\t\t    ND_PRINT(\" (unrepresentable)\");",
      "\t\t} else {",
      "\t\t    /* use ISO 8601 (RFC3339) format */",
      "\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);",
      "\t\t    ND_PRINT(\" (%s)\", time_buf);",
      "\t\t}"
    ],
    "added_lines": [
      "\t    const char *time_string;",
      "\t\ttime_string = \"[Time is too large to fit into a time_t]\";",
      "\t\t/* use ISO 8601 (RFC3339) format */",
      "\t\ttime_string = nd_format_time(time_buf, sizeof (time_buf),",
      "\t\t  \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&seconds));",
      "\t    ND_PRINT(\" (%s)\", time_string);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/the-tcpdump-group/tcpdump/pull/1032",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/the-tcpdump-group/tcpdump/pull/1032: 403 Client Error: Forbidden for url: https://api.github.com/repos/the-tcpdump-group/tcpdump/pulls/1032",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit introduces a routine to safely handle date/time conversions, checking for null pointers and buffer overflows.\n2. **Consistency Check:** The code changes align with the commit message, introducing a safer function for strftime usage.\n3. **Purpose Evaluation:** The change directly addresses potential buffer overflow issues, a security concern.\n4. **Security Assessment:** While no CVE is mentioned, the fix targets known security risks (buffer overflow) in string formatting functions.\n5. **Confidence:** High, as the fix clearly addresses a security-related issue.\n\nThe patch mitigates a buffer overflow vulnerability by ensuring proper handling of strftime's return values and buffer sizes, thus classified as a security fix with high confidence."
}