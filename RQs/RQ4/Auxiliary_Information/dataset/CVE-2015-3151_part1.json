{
  "cve_id": "CVE-2015-3151",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "abrt/libreport",
  "commit_msg": "dd: harden functions against directory traversal issues\n\nTest correctness of all accessed dump dir files in all dd* functions.\nBefore this commit, the callers were allowed to pass strings like\n\"../../etc/shadow\" in the filename argument of all dd* functions.\n\nRelated: #1214457\n\nSigned-off-by: Jakub Filak <jfilak@redhat.com>",
  "commit_hash": "239c4f7d1f47265526b39ad70106767d00805277",
  "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
  "file_path": "src/lib/create_dump_dir.c",
  "func_name": "create_dump_dir_from_problem_data",
  "func_before": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        /* only files should contain '/' and those are handled earlier */\n        if (name[0] == '.' || strchr(name, '/'))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}",
  "abstract_func_before": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *VAR_0, const char *VAR_1)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *VAR_2 = problem_data_get_content_or_NULL(VAR_0, VAR_3);\n\n    if (!VAR_2)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), VAR_3);\n        return NULL;\n    }\n\n    uid_t VAR_4 = (uid_t)-1L;\n    char *VAR_5 = problem_data_get_content_or_NULL(VAR_0, VAR_6);\n\n    if (VAR_5)\n    {\n        char *VAR_7;\n        VAR_8 = 0;\n        long VAR_9 = strtol(VAR_5, &VAR_7, 10);\n\n        if (VAR_8 != 0 || VAR_7 == VAR_5 || *VAR_7 != '\\0' || VAR_10 < VAR_9)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), VAR_5);\n            return NULL;\n        }\n\n        VAR_4 = (uid_t)VAR_9;\n    }\n\n    struct timeval VAR_11;\n    if (gettimeofday(&VAR_11, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *VAR_12 = xasprintf(\"%s-%s.%ld-%lu\"VAR_13, VAR_2, iso_date_string(&(VAR_11.tv_sec)), (long)VAR_11.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", VAR_1, VAR_12, VAR_4);\n\n    struct dump_dir *VAR_14;\n    if (VAR_1)\n        VAR_14 = try_dd_create(VAR_1, VAR_12, VAR_4);\n    else\n    {\n        /* COMMENT_0 */\n        VAR_14 = try_dd_create(VAR_15\"/run/abrt\", VAR_12, VAR_4);\n        /* COMMENT_1 */\n        if (!VAR_14)\n        {\n            char *VAR_16 = getenv(\"HOME\");\n            if (VAR_16 && VAR_16[0])\n            {\n                VAR_16 = concat_path_file(VAR_16, \"tmp\");\n                /* COMMENT_2 */\n                VAR_14 = try_dd_create(VAR_16, VAR_12, VAR_4);\n                free(VAR_16);\n            }\n        }\n/* COMMENT_3 */\n        /* COMMENT_4 */\n        if (!VAR_14)\n            VAR_14 = try_dd_create(VAR_17, VAR_12, VAR_4);\n    }\n\n    if (!VAR_14) /* COMMENT_5 */\n        goto ret;\n\n    GHashTableIter VAR_18;\n    char *VAR_19;\n    struct problem_item *VAR_20;\n    g_hash_table_iter_init(&VAR_18, VAR_0);\n    while (g_hash_table_iter_next(&VAR_18, (void**)&VAR_19, (void**)&VAR_20))\n    {\n        if (VAR_20->flags & VAR_21)\n        {\n            char *VAR_22 = concat_path_file(VAR_14->dd_dirname, VAR_19);\n            log_info(\"copying '%s' to '%s'\", VAR_20->content, VAR_22);\n            off_t VAR_23 = copy_file(VAR_20->content, VAR_22, VAR_24 | VAR_25);\n            if (VAR_23 < 0)\n                error_msg(\"Can't copy %s to %s\", VAR_20->content, VAR_22);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)VAR_23);\n            free(VAR_22);\n\n            continue;\n        }\n\n        /* COMMENT_6 */\n        if (VAR_19[0] == '.' || strchr(VAR_19, '/'))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", VAR_19);\n            continue;\n        }\n\n        dd_save_text(VAR_14, VAR_19, VAR_20->content);\n    }\n\n    /* COMMENT_7 */\n                                                                      \n                                                                               \n                                            \n       \n    dd_create_basic_files(VAR_14, VAR_4, NULL);\n\n    VAR_12[strlen(VAR_12) - strlen(VAR_13)] = '\\0';\n    char* VAR_26 = concat_path_file(VAR_1, VAR_12);\n    log_info(\"Renaming from '%s' to '%s'\", VAR_14->dd_dirname, VAR_26);\n    dd_rename(VAR_14, VAR_26);\n\n ret:\n    free(VAR_12);\n    return VAR_14;\n}",
  "func_graph_path_before": "abrt/libreport/239c4f7d1f47265526b39ad70106767d00805277/create_dump_dir.c/vul/before/0.json",
  "func": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    if (!str_is_correct_filename(type))\n    {\n        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (!str_is_correct_filename(name))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}",
  "abstract_func": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *VAR_0, const char *VAR_1)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *VAR_2 = problem_data_get_content_or_NULL(VAR_0, VAR_3);\n\n    if (!VAR_2)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), VAR_3);\n        return NULL;\n    }\n\n    if (!str_is_correct_filename(VAR_2))\n    {\n        error_msg(_(\"'%s' is not correct file name\"), VAR_3);\n        return NULL;\n    }\n\n    uid_t VAR_4 = (uid_t)-1L;\n    char *VAR_5 = problem_data_get_content_or_NULL(VAR_0, VAR_6);\n\n    if (VAR_5)\n    {\n        char *VAR_7;\n        VAR_8 = 0;\n        long VAR_9 = strtol(VAR_5, &VAR_7, 10);\n\n        if (VAR_8 != 0 || VAR_7 == VAR_5 || *VAR_7 != '\\0' || VAR_10 < VAR_9)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), VAR_5);\n            return NULL;\n        }\n\n        VAR_4 = (uid_t)VAR_9;\n    }\n\n    struct timeval VAR_11;\n    if (gettimeofday(&VAR_11, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *VAR_12 = xasprintf(\"%s-%s.%ld-%lu\"VAR_13, VAR_2, iso_date_string(&(VAR_11.tv_sec)), (long)VAR_11.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", VAR_1, VAR_12, VAR_4);\n\n    struct dump_dir *VAR_14;\n    if (VAR_1)\n        VAR_14 = try_dd_create(VAR_1, VAR_12, VAR_4);\n    else\n    {\n        /* COMMENT_0 */\n        VAR_14 = try_dd_create(VAR_15\"/run/abrt\", VAR_12, VAR_4);\n        /* COMMENT_1 */\n        if (!VAR_14)\n        {\n            char *VAR_16 = getenv(\"HOME\");\n            if (VAR_16 && VAR_16[0])\n            {\n                VAR_16 = concat_path_file(VAR_16, \"tmp\");\n                /* COMMENT_2 */\n                VAR_14 = try_dd_create(VAR_16, VAR_12, VAR_4);\n                free(VAR_16);\n            }\n        }\n/* COMMENT_3 */\n        /* COMMENT_4 */\n        if (!VAR_14)\n            VAR_14 = try_dd_create(VAR_17, VAR_12, VAR_4);\n    }\n\n    if (!VAR_14) /* COMMENT_5 */\n        goto ret;\n\n    GHashTableIter VAR_18;\n    char *VAR_19;\n    struct problem_item *VAR_20;\n    g_hash_table_iter_init(&VAR_18, VAR_0);\n    while (g_hash_table_iter_next(&VAR_18, (void**)&VAR_19, (void**)&VAR_20))\n    {\n        if (!str_is_correct_filename(VAR_19))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", VAR_19);\n            continue;\n        }\n\n        if (VAR_20->flags & VAR_21)\n        {\n            char *VAR_22 = concat_path_file(VAR_14->dd_dirname, VAR_19);\n            log_info(\"copying '%s' to '%s'\", VAR_20->content, VAR_22);\n            off_t VAR_23 = copy_file(VAR_20->content, VAR_22, VAR_24 | VAR_25);\n            if (VAR_23 < 0)\n                error_msg(\"Can't copy %s to %s\", VAR_20->content, VAR_22);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)VAR_23);\n            free(VAR_22);\n\n            continue;\n        }\n\n        dd_save_text(VAR_14, VAR_19, VAR_20->content);\n    }\n\n    /* COMMENT_6 */\n                                                                      \n                                                                               \n                                            \n       \n    dd_create_basic_files(VAR_14, VAR_4, NULL);\n\n    VAR_12[strlen(VAR_12) - strlen(VAR_13)] = '\\0';\n    char* VAR_26 = concat_path_file(VAR_1, VAR_12);\n    log_info(\"Renaming from '%s' to '%s'\", VAR_14->dd_dirname, VAR_26);\n    dd_rename(VAR_14, VAR_26);\n\n ret:\n    free(VAR_12);\n    return VAR_14;\n}",
  "func_graph_path": "abrt/libreport/239c4f7d1f47265526b39ad70106767d00805277/create_dump_dir.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,12 @@\n     if (!type)\n     {\n         error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n+        return NULL;\n+    }\n+\n+    if (!str_is_correct_filename(type))\n+    {\n+        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n         return NULL;\n     }\n \n@@ -73,6 +79,12 @@\n     g_hash_table_iter_init(&iter, problem_data);\n     while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n     {\n+        if (!str_is_correct_filename(name))\n+        {\n+            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n+            continue;\n+        }\n+\n         if (value->flags & CD_FLAG_BIN)\n         {\n             char *dest = concat_path_file(dd->dd_dirname, name);\n@@ -84,13 +96,6 @@\n                 log_info(\"copied %li bytes\", (unsigned long)copied);\n             free(dest);\n \n-            continue;\n-        }\n-\n-        /* only files should contain '/' and those are handled earlier */\n-        if (name[0] == '.' || strchr(name, '/'))\n-        {\n-            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n             continue;\n         }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "            continue;",
      "        }",
      "",
      "        /* only files should contain '/' and those are handled earlier */",
      "        if (name[0] == '.' || strchr(name, '/'))",
      "        {",
      "            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);"
    ],
    "added_lines": [
      "        return NULL;",
      "    }",
      "",
      "    if (!str_is_correct_filename(type))",
      "    {",
      "        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);",
      "        if (!str_is_correct_filename(name))",
      "        {",
      "            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);",
      "            continue;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/abrt/libreport/pull/343",
  "description": {
    "pr_info": {
      "title": "RHEL7: copy file chown",
      "number": 343
    },
    "comment": [
      "Needed to avoid race-conditions between copy & chown.\n\nRelated: #1211835\n\nSigned-off-by: Jakub Filak jfilak@redhat.com\n",
      "Went through the code and it seems to mitigate time of check / time of use race conditions and improve malicious path handling. Ack.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Commit Analysis:** The commit message indicates a security fix aimed at preventing directory traversal. The code adds checks for correct filenames, which aligns with the stated purpose.\n\n2. **Code Consistency:** The code modifications, such as adding `str_is_correct_filename` checks, directly address the security concern mentioned.\n\n3. **Security Context:** Validation against directory traversal is a classic security fix, preventing unauthorized file access, thus qualifying as a security vulnerability fix.\n\n4. **Confidence:** High confidence due to clear commit message and code that directly addresses the security issue. No conflicting information is present.\n\n**Final Answer:**\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}