{
  "cve_id": "CVE-2020-22219",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "xiph/flac",
  "commit_msg": "Add checks that supplied samples are bounded within bits-per-sample\n\nCredit: Oss-Fuzz\nIssue: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=19758\nIssue: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=31727",
  "commit_hash": "5a79fb5ce99b4fb7ba01b4ea85a0e5911e82b243",
  "git_url": "https://github.com/xiph/flac/commit/5a79fb5ce99b4fb7ba01b4ea85a0e5911e82b243",
  "file_path": "src/libFLAC/stream_encoder.c",
  "func_name": "FLAC__stream_encoder_process",
  "func_before": "FLAC_API FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], uint32_t samples)\n{\n\tuint32_t i, j = 0, channel;\n\tconst uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\n\tdo {\n\t\tconst uint32_t n = flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j);\n\n\t\tif(encoder->protected_->verify)\n\t\t\tappend_to_verify_fifo_(&encoder->private_->verify.input_fifo, buffer, j, channels, n);\n\n\t\tfor(channel = 0; channel < channels; channel++) {\n\t\t\tif (buffer[channel] == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(&encoder->private_->integer_signal[channel][encoder->private_->current_sample_number], &buffer[channel][j], sizeof(buffer[channel][0]) * n);\n\t\t}\n\n\t\tif(encoder->protected_->do_mid_side_stereo) {\n\t\t\tFLAC__ASSERT(channels == 2);\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][i] = buffer[0][j] - buffer[1][j];\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][i] = (buffer[0][j] + buffer[1][j]) >> 1; /* NOTE: not the same as 'mid = (buffer[0][j] + buffer[1][j]) / 2' ! */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tj += n;\n\n\t\tencoder->private_->current_sample_number += n;\n\n\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\tif(encoder->private_->current_sample_number > blocksize) {\n\t\t\tFLAC__ASSERT(encoder->private_->current_sample_number == blocksize+OVERREAD_);\n\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\treturn false;\n\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\tencoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];\n\t\t\tif(encoder->protected_->do_mid_side_stereo) {\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = 1;\n\t\t}\n\t} while(j < samples);\n\n\treturn true;\n}",
  "abstract_func_before": "FLAC_API VAR_0 FLAC__stream_encoder_process(FLAC__StreamEncoder *VAR_1, const FLAC__int32 * const VAR_2[], uint32_t VAR_3)\n{\n\tuint32_t VAR_4, VAR_5 = 0, VAR_6;\n\tconst uint32_t VAR_7 = VAR_1->protected_->channels, VAR_8 = VAR_1->protected_->blocksize;\n\n\tFLAC__ASSERT(0 != VAR_1);\n\tFLAC__ASSERT(0 != VAR_1->private_);\n\tFLAC__ASSERT(0 != VAR_1->protected_);\n\tFLAC__ASSERT(VAR_1->protected_->state == VAR_9);\n\n\tdo {\n\t\tconst uint32_t VAR_10 = flac_min(VAR_8+VAR_11-VAR_1->private_->current_sample_number, VAR_3-VAR_5);\n\n\t\tif(VAR_1->protected_->verify)\n\t\t\tappend_to_verify_fifo_(&VAR_1->private_->verify.input_fifo, VAR_2, VAR_5, VAR_7, VAR_10);\n\n\t\tfor(VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {\n\t\t\tif (VAR_2[VAR_6] == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(&VAR_1->private_->integer_signal[VAR_6][VAR_1->private_->current_sample_number], &VAR_2[VAR_6][VAR_5], sizeof(VAR_2[VAR_6][0]) * VAR_10);\n\t\t}\n\n\t\tif(VAR_1->protected_->do_mid_side_stereo) {\n\t\t\tFLAC__ASSERT(VAR_7 == 2);\n\t\t\t/* COMMENT_0 */\n\t\t\tfor(VAR_4 = VAR_1->private_->current_sample_number; VAR_4 <= VAR_8 && VAR_5 < VAR_3; VAR_4++, VAR_5++) {\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][VAR_4] = VAR_2[0][VAR_5] - VAR_2[1][VAR_5];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][VAR_4] = (VAR_2[0][VAR_5] + VAR_2[1][VAR_5]) >> 1; /* COMMENT_1 */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tVAR_5 += VAR_10;\n\n\t\tVAR_1->private_->current_sample_number += VAR_10;\n\n\t\t/* COMMENT_2 */\n\t\tif(VAR_1->private_->current_sample_number > VAR_8) {\n\t\t\tFLAC__ASSERT(VAR_1->private_->current_sample_number == VAR_8+VAR_11);\n\t\t\tFLAC__ASSERT(VAR_11 == 1); /* COMMENT_3 */\n\t\t\tif(!process_frame_(VAR_1, /* COMMENT_4 */false, /* COMMENT_5 */false))\n\t\t\t\treturn false;\n\t\t\t/* COMMENT_6 */\n\t\t\tfor(VAR_6 = 0; VAR_6 < VAR_7; VAR_6++)\n\t\t\t\tVAR_1->private_->integer_signal[VAR_6][0] = VAR_1->private_->integer_signal[VAR_6][VAR_8];\n\t\t\tif(VAR_1->protected_->do_mid_side_stereo) {\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][0] = VAR_1->private_->integer_signal_mid_side[0][VAR_8];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][0] = VAR_1->private_->integer_signal_mid_side[1][VAR_8];\n\t\t\t}\n\t\t\tVAR_1->private_->current_sample_number = 1;\n\t\t}\n\t} while(VAR_5 < VAR_3);\n\n\treturn true;\n}",
  "func_graph_path_before": null,
  "func": "FLAC_API FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], uint32_t samples)\n{\n\tuint32_t i, j = 0, k = 0, channel;\n\tconst uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n\tconst FLAC__int32 sample_max = INT32_MAX >> (32 - encoder->protected_->bits_per_sample);\n\tconst FLAC__int32 sample_min = INT32_MIN >> (32 - encoder->protected_->bits_per_sample);\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\n\tdo {\n\t\tconst uint32_t n = flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j);\n\n\t\tif(encoder->protected_->verify)\n\t\t\tappend_to_verify_fifo_(&encoder->private_->verify.input_fifo, buffer, j, channels, n);\n\n\t\tfor(channel = 0; channel < channels; channel++) {\n\t\t\tfor(i = encoder->private_->current_sample_number, k = j; i <= blocksize && k < samples; i++, k++) {\n\t\t\t\tif(buffer[channel][k] < sample_min || buffer[channel][k] > sample_max){\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (buffer[channel] == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(&encoder->private_->integer_signal[channel][encoder->private_->current_sample_number], &buffer[channel][j], sizeof(buffer[channel][0]) * n);\n\t\t}\n\n\t\tif(encoder->protected_->do_mid_side_stereo) {\n\t\t\tFLAC__ASSERT(channels == 2);\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][i] = buffer[0][j] - buffer[1][j];\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][i] = (buffer[0][j] + buffer[1][j]) >> 1; /* NOTE: not the same as 'mid = (buffer[0][j] + buffer[1][j]) / 2' ! */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tj += n;\n\n\t\tencoder->private_->current_sample_number += n;\n\n\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\tif(encoder->private_->current_sample_number > blocksize) {\n\t\t\tFLAC__ASSERT(encoder->private_->current_sample_number == blocksize+OVERREAD_);\n\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\treturn false;\n\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\tencoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];\n\t\t\tif(encoder->protected_->do_mid_side_stereo) {\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = 1;\n\t\t}\n\t} while(j < samples);\n\n\treturn true;\n}",
  "abstract_func": "FLAC_API VAR_0 FLAC__stream_encoder_process(FLAC__StreamEncoder *VAR_1, const FLAC__int32 * const VAR_2[], uint32_t VAR_3)\n{\n\tuint32_t VAR_4, VAR_5 = 0, VAR_6 = 0, VAR_7;\n\tconst uint32_t VAR_8 = VAR_1->protected_->channels, VAR_9 = VAR_1->protected_->blocksize;\n\tconst FLAC__int32 VAR_10 = VAR_11 >> (32 - VAR_1->protected_->bits_per_sample);\n\tconst FLAC__int32 VAR_12 = VAR_13 >> (32 - VAR_1->protected_->bits_per_sample);\n\n\tFLAC__ASSERT(0 != VAR_1);\n\tFLAC__ASSERT(0 != VAR_1->private_);\n\tFLAC__ASSERT(0 != VAR_1->protected_);\n\tFLAC__ASSERT(VAR_1->protected_->state == VAR_14);\n\n\tdo {\n\t\tconst uint32_t VAR_15 = flac_min(VAR_9+VAR_16-VAR_1->private_->current_sample_number, VAR_3-VAR_5);\n\n\t\tif(VAR_1->protected_->verify)\n\t\t\tappend_to_verify_fifo_(&VAR_1->private_->verify.input_fifo, VAR_2, VAR_5, VAR_8, VAR_15);\n\n\t\tfor(VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n\t\t\tfor(VAR_4 = VAR_1->private_->current_sample_number, VAR_6 = VAR_5; VAR_4 <= VAR_9 && VAR_6 < VAR_3; VAR_4++, VAR_6++) {\n\t\t\t\tif(VAR_2[VAR_7][VAR_6] < VAR_12 || VAR_2[VAR_7][VAR_6] > VAR_10){\n\t\t\t\t\tVAR_1->protected_->state = VAR_17;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_2[VAR_7] == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(&VAR_1->private_->integer_signal[VAR_7][VAR_1->private_->current_sample_number], &VAR_2[VAR_7][VAR_5], sizeof(VAR_2[VAR_7][0]) * VAR_15);\n\t\t}\n\n\t\tif(VAR_1->protected_->do_mid_side_stereo) {\n\t\t\tFLAC__ASSERT(VAR_8 == 2);\n\t\t\t/* COMMENT_0 */\n\t\t\tfor(VAR_4 = VAR_1->private_->current_sample_number; VAR_4 <= VAR_9 && VAR_5 < VAR_3; VAR_4++, VAR_5++) {\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][VAR_4] = VAR_2[0][VAR_5] - VAR_2[1][VAR_5];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][VAR_4] = (VAR_2[0][VAR_5] + VAR_2[1][VAR_5]) >> 1; /* COMMENT_1 */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tVAR_5 += VAR_15;\n\n\t\tVAR_1->private_->current_sample_number += VAR_15;\n\n\t\t/* COMMENT_2 */\n\t\tif(VAR_1->private_->current_sample_number > VAR_9) {\n\t\t\tFLAC__ASSERT(VAR_1->private_->current_sample_number == VAR_9+VAR_16);\n\t\t\tFLAC__ASSERT(VAR_16 == 1); /* COMMENT_3 */\n\t\t\tif(!process_frame_(VAR_1, /* COMMENT_4 */false, /* COMMENT_5 */false))\n\t\t\t\treturn false;\n\t\t\t/* COMMENT_6 */\n\t\t\tfor(VAR_7 = 0; VAR_7 < VAR_8; VAR_7++)\n\t\t\t\tVAR_1->private_->integer_signal[VAR_7][0] = VAR_1->private_->integer_signal[VAR_7][VAR_9];\n\t\t\tif(VAR_1->protected_->do_mid_side_stereo) {\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][0] = VAR_1->private_->integer_signal_mid_side[0][VAR_9];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][0] = VAR_1->private_->integer_signal_mid_side[1][VAR_9];\n\t\t\t}\n\t\t\tVAR_1->private_->current_sample_number = 1;\n\t\t}\n\t} while(VAR_5 < VAR_3);\n\n\treturn true;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,9 @@\n FLAC_API FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], uint32_t samples)\n {\n-\tuint32_t i, j = 0, channel;\n+\tuint32_t i, j = 0, k = 0, channel;\n \tconst uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n+\tconst FLAC__int32 sample_max = INT32_MAX >> (32 - encoder->protected_->bits_per_sample);\n+\tconst FLAC__int32 sample_min = INT32_MIN >> (32 - encoder->protected_->bits_per_sample);\n \n \tFLAC__ASSERT(0 != encoder);\n \tFLAC__ASSERT(0 != encoder->private_);\n@@ -15,6 +17,12 @@\n \t\t\tappend_to_verify_fifo_(&encoder->private_->verify.input_fifo, buffer, j, channels, n);\n \n \t\tfor(channel = 0; channel < channels; channel++) {\n+\t\t\tfor(i = encoder->private_->current_sample_number, k = j; i <= blocksize && k < samples; i++, k++) {\n+\t\t\t\tif(buffer[channel][k] < sample_min || buffer[channel][k] > sample_max){\n+\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif (buffer[channel] == NULL) {\n \t\t\t\treturn false;\n \t\t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\tuint32_t i, j = 0, channel;"
    ],
    "added_lines": [
      "\tuint32_t i, j = 0, k = 0, channel;",
      "\tconst FLAC__int32 sample_max = INT32_MAX >> (32 - encoder->protected_->bits_per_sample);",
      "\tconst FLAC__int32 sample_min = INT32_MIN >> (32 - encoder->protected_->bits_per_sample);",
      "\t\t\tfor(i = encoder->private_->current_sample_number, k = j; i <= blocksize && k < samples; i++, k++) {",
      "\t\t\t\tif(buffer[channel][k] < sample_min || buffer[channel][k] > sample_max){",
      "\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;",
      "\t\t\t\t\treturn false;",
      "\t\t\t\t}",
      "\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xiph/flac/pull/273",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/xiph/flac/pull/273: 403 Client Error: Forbidden for url: https://api.github.com/repos/xiph/flac/pulls/273",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}