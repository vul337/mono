{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvRMDIR",
  "func_before": "int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    word32 sz;\n    int    ret = 0;\n    char*  dir;\n    word32 idx = 0;\n    byte*  out;\n    word32 outSz = 0;\n    byte   type;\n\n    char err[] = \"Remove Directory Error\";\n    char suc[] = \"Removed Directory\";\n    char* res  = NULL;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RMDIR\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == 0) {\n    #ifndef USE_WINDOWS_API\n        ret = WRMDIR(ssh->fs, dir);\n    #else /* USE_WINDOWS_API */\n        ret = WS_RemoveDirectoryA(dir, ssh->ctx->heap) == 0;\n    #endif /* USE_WINDOWS_API */\n    }\n    WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    res  = (ret != 0)? err : suc;\n    type = (ret != 0)? WOLFSSH_FTP_FAILURE : WOLFSSH_FTP_OK;\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != 0) {\n        /* @TODO errno holds reason for rmdir failure. Status sent could be\n         * better if using errno value to send reason i.e. permissions .. */\n        WLOG(WS_LOG_SFTP, \"Error removing directory %s\", dir);\n        ret = WS_BAD_FILE_E;\n    }\n    else {\n        ret = WS_SUCCESS;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func_before": "int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n{\n    word32 VAR_4;\n    int    VAR_5 = 0;\n    char*  VAR_6;\n    word32 VAR_7 = 0;\n    byte*  VAR_8;\n    word32 VAR_9 = 0;\n    byte   VAR_10;\n\n    char VAR_11[] = \"Remove Directory Error\";\n    char VAR_12[] = \"Removed Directory\";\n    char* VAR_13  = NULL;\n\n    if (VAR_0 == NULL) {\n        return VAR_14;\n    }\n\n    WLOG(VAR_15, \"Receiving WOLFSSH_FTP_RMDIR\");\n\n    ato32(VAR_2 + VAR_7, &VAR_4); VAR_7 += VAR_16;\n    if (VAR_4 + VAR_7 > VAR_3) {\n        return VAR_17;\n    }\n\n    /* COMMENT_0 */\n    VAR_6 = (char*)WMALLOC(VAR_4 + 1, VAR_0->ctx->heap, VAR_18);\n    if (VAR_6 == NULL) {\n        return VAR_19;\n    }\n    WMEMCPY(VAR_6, VAR_2 + VAR_7, VAR_4);\n    VAR_6[VAR_4] = '\\0';\n\n    if (wolfSSH_CleanPath(VAR_0, VAR_6) < 0) {\n        VAR_5 = VAR_20;\n    }\n\n    if (VAR_5 == 0) {\n    #ifndef VAR_21\n        VAR_5 = WRMDIR(VAR_0->fs, VAR_6);\n    #else /* COMMENT_1 */\n        VAR_5 = WS_RemoveDirectoryA(VAR_6, VAR_0->ctx->heap) == 0;\n    #endif /* COMMENT_1 */\n    }\n    WFREE(VAR_6, VAR_0->ctx->heap, VAR_18);\n\n    VAR_13  = (VAR_5 != 0)? VAR_11 : VAR_12;\n    VAR_10 = (VAR_5 != 0)? VAR_22 : VAR_23;\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_10, VAR_1, VAR_13,\n                \"English\", NULL, &VAR_9) != VAR_24) {\n        return VAR_20;\n    }\n\n    VAR_8 = (byte*)WMALLOC(VAR_9, VAR_0->ctx->heap, VAR_18);\n    if (VAR_8 == NULL) {\n        return VAR_19;\n    }\n\n    if (VAR_5 != 0) {\n        /* COMMENT_2 */\n                                                                            \n        WLOG(VAR_15, \"Error removing directory %s\", VAR_6);\n        VAR_5 = VAR_25;\n    }\n    else {\n        VAR_5 = VAR_26;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_10, VAR_1, VAR_13, \"English\", VAR_8,\n                &VAR_9) != VAR_26) {\n        WFREE(VAR_8, VAR_0->ctx->heap, VAR_18);\n        return VAR_20;\n    }\n\n    /* COMMENT_4 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_8, VAR_9);\n    return VAR_5;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/3.json",
  "func": "int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    word32 sz;\n    int    ret = 0;\n    char*  dir;\n    word32 idx = 0;\n    byte*  out;\n    word32 outSz = 0;\n    byte   type;\n\n    char err[] = \"Remove Directory Error\";\n    char suc[] = \"Removed Directory\";\n    char* res  = NULL;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RMDIR\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == 0) {\n    #ifndef USE_WINDOWS_API\n        ret = WRMDIR(ssh->fs, dir);\n    #else /* USE_WINDOWS_API */\n        ret = WS_RemoveDirectoryA(dir, ssh->ctx->heap) == 0;\n    #endif /* USE_WINDOWS_API */\n    }\n    WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    res  = (ret != 0)? err : suc;\n    type = (ret != 0)? WOLFSSH_FTP_FAILURE : WOLFSSH_FTP_OK;\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != 0) {\n        /* @TODO errno holds reason for rmdir failure. Status sent could be\n         * better if using errno value to send reason i.e. permissions .. */\n        WLOG(WS_LOG_SFTP, \"Error removing directory %s\", dir);\n        ret = WS_BAD_FILE_E;\n    }\n    else {\n        ret = WS_SUCCESS;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}",
  "abstract_func": "int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n{\n    word32 VAR_4;\n    int    VAR_5 = 0;\n    char*  VAR_6;\n    word32 VAR_7 = 0;\n    byte*  VAR_8;\n    word32 VAR_9 = 0;\n    byte   VAR_10;\n\n    char VAR_11[] = \"Remove Directory Error\";\n    char VAR_12[] = \"Removed Directory\";\n    char* VAR_13  = NULL;\n\n    if (VAR_0 == NULL) {\n        return VAR_14;\n    }\n\n    WLOG(VAR_15, \"Receiving WOLFSSH_FTP_RMDIR\");\n\n    ato32(VAR_2 + VAR_7, &VAR_4); VAR_7 += VAR_16;\n    if (VAR_4 > VAR_3 - VAR_7) {\n        return VAR_17;\n    }\n\n    /* COMMENT_0 */\n    VAR_6 = (char*)WMALLOC(VAR_4 + 1, VAR_0->ctx->heap, VAR_18);\n    if (VAR_6 == NULL) {\n        return VAR_19;\n    }\n    WMEMCPY(VAR_6, VAR_2 + VAR_7, VAR_4);\n    VAR_6[VAR_4] = '\\0';\n\n    if (wolfSSH_CleanPath(VAR_0, VAR_6) < 0) {\n        VAR_5 = VAR_20;\n    }\n\n    if (VAR_5 == 0) {\n    #ifndef VAR_21\n        VAR_5 = WRMDIR(VAR_0->fs, VAR_6);\n    #else /* COMMENT_1 */\n        VAR_5 = WS_RemoveDirectoryA(VAR_6, VAR_0->ctx->heap) == 0;\n    #endif /* COMMENT_1 */\n    }\n    WFREE(VAR_6, VAR_0->ctx->heap, VAR_18);\n\n    VAR_13  = (VAR_5 != 0)? VAR_11 : VAR_12;\n    VAR_10 = (VAR_5 != 0)? VAR_22 : VAR_23;\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_10, VAR_1, VAR_13,\n                \"English\", NULL, &VAR_9) != VAR_24) {\n        return VAR_20;\n    }\n\n    VAR_8 = (byte*)WMALLOC(VAR_9, VAR_0->ctx->heap, VAR_18);\n    if (VAR_8 == NULL) {\n        return VAR_19;\n    }\n\n    if (VAR_5 != 0) {\n        /* COMMENT_2 */\n                                                                            \n        WLOG(VAR_15, \"Error removing directory %s\", VAR_6);\n        VAR_5 = VAR_25;\n    }\n    else {\n        VAR_5 = VAR_26;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_10, VAR_1, VAR_13, \"English\", VAR_8,\n                &VAR_9) != VAR_26) {\n        WFREE(VAR_8, VAR_0->ctx->heap, VAR_18);\n        return VAR_20;\n    }\n\n    /* COMMENT_4 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_8, VAR_9);\n    return VAR_5;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n     WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RMDIR\");\n \n     ato32(data + idx, &sz); idx += UINT32_SZ;\n-    if (sz + idx > maxSz) {\n+    if (sz > maxSz - idx) {\n         return WS_BUFFER_E;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    if (sz + idx > maxSz) {"
    ],
    "added_lines": [
      "    if (sz > maxSz - idx) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": {
    "pr_info": {
      "title": "ASAN SFTP Fixes",
      "number": 360
    },
    "comment": [
      "When decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}