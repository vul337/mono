{
  "cve_id": "CVE-2017-8314",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "xbmc",
  "commit_msg": "[filesystem] ZipManager: skip path traversal",
  "commit_hash": "35cfe35608b15335ef21d798947fceab3f47c8d7",
  "git_url": "https://github.com/xbmc/xbmc/commit/35cfe35608b15335ef21d798947fceab3f47c8d7",
  "file_path": "xbmc/filesystem/ZipManager.cpp",
  "func_name": "CZipManager::GetZipList",
  "func_before": "bool CZipManager::GetZipList(const CURL& url, std::vector<SZipEntry>& items)\n{\n  struct __stat64 m_StatData = {};\n\n  std::string strFile = url.GetHostName();\n\n  if (CFile::Stat(strFile,&m_StatData))\n  {\n    CLog::Log(LOGDEBUG,\"CZipManager::GetZipList: failed to stat file %s\", url.GetRedacted().c_str());\n    return false;\n  }\n\n  std::map<std::string, std::vector<SZipEntry> >::iterator it = mZipMap.find(strFile);\n  if (it != mZipMap.end()) // already listed, just return it if not changed, else release and reread\n  {\n    std::map<std::string,int64_t>::iterator it2=mZipDate.find(strFile);\n\n    if (m_StatData.st_mtime == it2->second)\n    {\n      items = it->second;\n      return true;\n    }\n    mZipMap.erase(it);\n    mZipDate.erase(it2);\n  }\n\n  CFile mFile;\n  if (!mFile.Open(strFile))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: unable to open file %s!\",strFile.c_str());\n    return false;\n  }\n\n  unsigned int hdr;\n  if (mFile.Read(&hdr, 4)!=4 || (Endian_SwapLE32(hdr) != ZIP_LOCAL_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_DATA_RECORD_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_SPLIT_ARCHIVE_HEADER))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: not a zip file!\");\n    mFile.Close();\n    return false;\n  }\n\n  if (Endian_SwapLE32(hdr) == ZIP_SPLIT_ARCHIVE_HEADER)\n    CLog::LogF(LOGWARNING, \"ZIP split archive header found. Trying to process as a single archive..\");\n\n  // push date for update detection\n  mZipDate.insert(make_pair(strFile,m_StatData.st_mtime));\n\n\n  // Look for end of central directory record\n  // Zipfile comment may be up to 65535 bytes\n  // End of central directory record is 22 bytes (ECDREC_SIZE)\n  // -> need to check the last 65557 bytes\n  int64_t fileSize = mFile.GetLength();\n  // Don't need to look in the last 18 bytes (ECDREC_SIZE-4)\n  // But as we need to do overlapping between blocks (3 bytes),\n  // we start the search at ECDREC_SIZE-1 from the end of file\n  if (fileSize < ECDREC_SIZE - 1)\n  {\n    CLog::Log(LOGERROR, \"ZipManager: Invalid zip file length: %\" PRId64\"\", fileSize);\n    return false;\n  }\n  int searchSize = (int) std::min(static_cast<int64_t>(65557), fileSize-ECDREC_SIZE+1);\n  int blockSize = (int) std::min(1024, searchSize);\n  int nbBlock = searchSize / blockSize;\n  int extraBlockSize = searchSize % blockSize;\n  // Signature is on 4 bytes\n  // It could be between 2 blocks, so we need to read 3 extra bytes\n  auto_buffer buffer(blockSize + 3);\n  bool found = false;\n\n  // Loop through blocks starting at the end of the file (minus ECDREC_SIZE-1)\n  for (int nb=1; !found && (nb <= nbBlock); nb++)\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb),SEEK_SET);\n    if (mFile.Read(buffer.get(), blockSize + 3) != blockSize + 3)\n      return false;\n    for (int i=blockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb)+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  // If not found, look in the last block left...\n  if ( !found && (extraBlockSize > 0) )\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize,SEEK_SET);\n    if (mFile.Read(buffer.get(), extraBlockSize + 3) != extraBlockSize + 3)\n      return false;\n    for (int i=extraBlockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  buffer.clear();\n\n  if ( !found )\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n    mFile.Close();\n    return false;\n  }\n\n  unsigned int cdirOffset, cdirSize;\n  // Get size of the central directory\n  mFile.Seek(12,SEEK_CUR);\n  if (mFile.Read(&cdirSize, 4) != 4)\n    return false;\n  cdirSize = Endian_SwapLE32(cdirSize);\n  // Get Offset of start of central directory with respect to the starting disk number\n  if (mFile.Read(&cdirOffset, 4) != 4)\n    return false;\n  cdirOffset = Endian_SwapLE32(cdirOffset);\n\n  // Go to the start of central directory\n  mFile.Seek(cdirOffset,SEEK_SET);\n\n  char temp[CHDR_SIZE];\n  while (mFile.GetPosition() < cdirOffset + cdirSize)\n  {\n    SZipEntry ze;\n    if (mFile.Read(temp, CHDR_SIZE) != CHDR_SIZE)\n      return false;\n    readCHeader(temp, ze);\n    if (ze.header != ZIP_CENTRAL_HEADER)\n    {\n      CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n      mFile.Close();\n      return false;\n    }\n\n    // Get the filename just after the central file header\n    auto_buffer bufName(ze.flength);\n    if (mFile.Read(bufName.get(), ze.flength) != ze.flength)\n      return false;\n    std::string strName(bufName.get(), bufName.size());\n    bufName.clear();\n    g_charsetConverter.unknownToUTF8(strName);\n    ZeroMemory(ze.name, 255);\n    strncpy(ze.name, strName.c_str(), strName.size()>254 ? 254 : strName.size());\n\n    // Jump after central file header extra field and file comment\n    mFile.Seek(ze.eclength + ze.clength,SEEK_CUR);\n\n    items.push_back(ze);\n  }\n\n  /* go through list and figure out file header lengths */\n  for(std::vector<SZipEntry>::iterator it = items.begin(); it != items.end(); ++it)\n  {\n    SZipEntry& ze = *it;\n    // Go to the local file header to get the extra field length\n    // !! local header extra field length != central file header extra field length !!\n    mFile.Seek(ze.lhdrOffset+28,SEEK_SET);\n    if (mFile.Read(&(ze.elength), 2) != 2)\n      return false;\n    ze.elength = Endian_SwapLE16(ze.elength);\n\n    // Compressed data offset = local header offset + size of local header + filename length + local file header extra field length\n    ze.offset = ze.lhdrOffset + LHDR_SIZE + ze.flength + ze.elength;\n\n  }\n\n  mZipMap.insert(make_pair(strFile,items));\n  mFile.Close();\n  return true;\n}",
  "abstract_func_before": "bool CZipManager::GetZipList(const CURL& VAR_0, std::vector<SZipEntry>& VAR_1)\n{\n  struct __stat64 VAR_2 = {};\n\n  std::string VAR_3 = VAR_0.GetHostName();\n\n  if (CFile::Stat(VAR_3,&VAR_2))\n  {\n    CLog::Log(VAR_4,\"CZipManager::GetZipList: failed to stat file %s\", VAR_0.GetRedacted().c_str());\n    return false;\n  }\n\n  std::map<std::string, std::vector<SZipEntry> >::iterator VAR_5 = VAR_6.find(VAR_3);\n  if (VAR_5 != VAR_6.end()) /* COMMENT_0 */\n  {\n    std::map<std::string,int64_t>::iterator VAR_7=VAR_8.find(VAR_3);\n\n    if (VAR_2.st_mtime == VAR_7->second)\n    {\n      VAR_1 = VAR_5->second;\n      return true;\n    }\n    VAR_6.erase(VAR_5);\n    VAR_8.erase(VAR_7);\n  }\n\n  CFile VAR_9;\n  if (!VAR_9.Open(VAR_3))\n  {\n    CLog::Log(VAR_4,\"ZipManager: unable to open file %s!\",VAR_3.c_str());\n    return false;\n  }\n\n  unsigned int VAR_10;\n  if (VAR_9.Read(&VAR_10, 4)!=4 || (Endian_SwapLE32(VAR_10) != VAR_11 &&\n                                 Endian_SwapLE32(VAR_10) != VAR_12 &&\n                                 Endian_SwapLE32(VAR_10) != VAR_13))\n  {\n    CLog::Log(VAR_4,\"ZipManager: not a zip file!\");\n    VAR_9.Close();\n    return false;\n  }\n\n  if (Endian_SwapLE32(VAR_10) == VAR_13)\n    CLog::LogF(VAR_14, \"ZIP split archive header found. Trying to process as a single archive..\");\n\n  /* COMMENT_1 */\n  VAR_8.insert(make_pair(VAR_3,VAR_2.st_mtime));\n\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  int64_t VAR_15 = VAR_9.GetLength();\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (VAR_15 < VAR_16 - 1)\n  {\n    CLog::Log(VAR_17, \"ZipManager: Invalid zip file length: %\" VAR_18\"\", VAR_15);\n    return false;\n  }\n  int VAR_19 = (int) std::min(VAR_20<int64_t>(65557), VAR_15-VAR_16+1);\n  int VAR_21 = (int) std::min(1024, VAR_19);\n  int VAR_22 = VAR_19 / VAR_21;\n  int VAR_23 = VAR_19 % VAR_21;\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  auto_buffer VAR_24(VAR_21 + 3);\n  bool VAR_25 = false;\n\n  /* COMMENT_11 */\n  for (int VAR_26=1; !VAR_25 && (VAR_26 <= VAR_22); VAR_26++)\n  {\n    VAR_9.Seek(VAR_15-VAR_16+1-(VAR_21*VAR_26),VAR_27);\n    if (VAR_9.Read(VAR_24.get(), VAR_21 + 3) != VAR_21 + 3)\n      return false;\n    for (int VAR_28=VAR_21-1; !VAR_25 && (VAR_28 >= 0); VAR_28--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(VAR_24.get()+VAR_28))) == VAR_29 )\n      {\n        /* COMMENT_12 */\n        VAR_9.Seek(VAR_15-VAR_16+1-(VAR_21*VAR_26)+VAR_28,VAR_27);\n        VAR_25 = true;\n      }\n    }\n  }\n\n  /* COMMENT_13 */\n  if ( !VAR_25 && (VAR_23 > 0) )\n  {\n    VAR_9.Seek(VAR_15-VAR_16+1-VAR_19,VAR_27);\n    if (VAR_9.Read(VAR_24.get(), VAR_23 + 3) != VAR_23 + 3)\n      return false;\n    for (int VAR_28=VAR_23-1; !VAR_25 && (VAR_28 >= 0); VAR_28--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(VAR_24.get()+VAR_28))) == VAR_29 )\n      {\n        /* COMMENT_12 */\n        VAR_9.Seek(VAR_15-VAR_16+1-VAR_19+VAR_28,VAR_27);\n        VAR_25 = true;\n      }\n    }\n  }\n\n  VAR_24.clear();\n\n  if ( !VAR_25 )\n  {\n    CLog::Log(VAR_4,\"ZipManager: broken file %s!\",VAR_3.c_str());\n    VAR_9.Close();\n    return false;\n  }\n\n  unsigned int VAR_30, VAR_31;\n  /* COMMENT_14 */\n  VAR_9.Seek(12,VAR_32);\n  if (VAR_9.Read(&VAR_31, 4) != 4)\n    return false;\n  VAR_31 = Endian_SwapLE32(VAR_31);\n  /* COMMENT_15 */\n  if (VAR_9.Read(&VAR_30, 4) != 4)\n    return false;\n  VAR_30 = Endian_SwapLE32(VAR_30);\n\n  /* COMMENT_16 */\n  VAR_9.Seek(VAR_30,VAR_27);\n\n  char VAR_33[VAR_34];\n  while (VAR_9.GetPosition() < VAR_30 + VAR_31)\n  {\n    SZipEntry VAR_35;\n    if (VAR_9.Read(VAR_33, VAR_34) != VAR_34)\n      return false;\n    readCHeader(VAR_33, VAR_35);\n    if (VAR_35.header != VAR_36)\n    {\n      CLog::Log(VAR_4,\"ZipManager: broken file %s!\",VAR_3.c_str());\n      VAR_9.Close();\n      return false;\n    }\n\n    /* COMMENT_17 */\n    auto_buffer VAR_37(VAR_35.flength);\n    if (VAR_9.Read(VAR_37.get(), VAR_35.flength) != VAR_35.flength)\n      return false;\n    std::string VAR_38(VAR_37.get(), VAR_37.size());\n    VAR_37.clear();\n    VAR_39.unknownToUTF8(VAR_38);\n    ZeroMemory(VAR_35.name, 255);\n    strncpy(VAR_35.name, VAR_38.c_str(), VAR_38.size()>254 ? 254 : VAR_38.size());\n\n    /* COMMENT_18 */\n    VAR_9.Seek(VAR_35.eclength + VAR_35.clength,VAR_32);\n\n    VAR_1.push_back(VAR_35);\n  }\n\n  /* COMMENT_19 */\n  for(std::vector<SZipEntry>::iterator VAR_5 = VAR_1.begin(); VAR_5 != VAR_1.end(); ++VAR_5)\n  {\n    SZipEntry& VAR_35 = *VAR_5;\n    /* COMMENT_20 */\n    /* COMMENT_21 */\n    VAR_9.Seek(VAR_35.lhdrOffset+28,VAR_27);\n    if (VAR_9.Read(&(VAR_35.elength), 2) != 2)\n      return false;\n    VAR_35.elength = Endian_SwapLE16(VAR_35.elength);\n\n    /* COMMENT_22 */\n    VAR_35.offset = VAR_35.lhdrOffset + VAR_40 + VAR_35.flength + VAR_35.elength;\n\n  }\n\n  VAR_6.insert(make_pair(VAR_3,VAR_1));\n  VAR_9.Close();\n  return true;\n}",
  "func_graph_path_before": "xbmc/35cfe35608b15335ef21d798947fceab3f47c8d7/ZipManager.cpp/vul/before/0.json",
  "func": "bool CZipManager::GetZipList(const CURL& url, std::vector<SZipEntry>& items)\n{\n  struct __stat64 m_StatData = {};\n\n  std::string strFile = url.GetHostName();\n\n  if (CFile::Stat(strFile,&m_StatData))\n  {\n    CLog::Log(LOGDEBUG,\"CZipManager::GetZipList: failed to stat file %s\", url.GetRedacted().c_str());\n    return false;\n  }\n\n  std::map<std::string, std::vector<SZipEntry> >::iterator it = mZipMap.find(strFile);\n  if (it != mZipMap.end()) // already listed, just return it if not changed, else release and reread\n  {\n    std::map<std::string,int64_t>::iterator it2=mZipDate.find(strFile);\n\n    if (m_StatData.st_mtime == it2->second)\n    {\n      items = it->second;\n      return true;\n    }\n    mZipMap.erase(it);\n    mZipDate.erase(it2);\n  }\n\n  CFile mFile;\n  if (!mFile.Open(strFile))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: unable to open file %s!\",strFile.c_str());\n    return false;\n  }\n\n  unsigned int hdr;\n  if (mFile.Read(&hdr, 4)!=4 || (Endian_SwapLE32(hdr) != ZIP_LOCAL_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_DATA_RECORD_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_SPLIT_ARCHIVE_HEADER))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: not a zip file!\");\n    mFile.Close();\n    return false;\n  }\n\n  if (Endian_SwapLE32(hdr) == ZIP_SPLIT_ARCHIVE_HEADER)\n    CLog::LogF(LOGWARNING, \"ZIP split archive header found. Trying to process as a single archive..\");\n\n  // push date for update detection\n  mZipDate.insert(make_pair(strFile,m_StatData.st_mtime));\n\n\n  // Look for end of central directory record\n  // Zipfile comment may be up to 65535 bytes\n  // End of central directory record is 22 bytes (ECDREC_SIZE)\n  // -> need to check the last 65557 bytes\n  int64_t fileSize = mFile.GetLength();\n  // Don't need to look in the last 18 bytes (ECDREC_SIZE-4)\n  // But as we need to do overlapping between blocks (3 bytes),\n  // we start the search at ECDREC_SIZE-1 from the end of file\n  if (fileSize < ECDREC_SIZE - 1)\n  {\n    CLog::Log(LOGERROR, \"ZipManager: Invalid zip file length: %\" PRId64\"\", fileSize);\n    return false;\n  }\n  int searchSize = (int) std::min(static_cast<int64_t>(65557), fileSize-ECDREC_SIZE+1);\n  int blockSize = (int) std::min(1024, searchSize);\n  int nbBlock = searchSize / blockSize;\n  int extraBlockSize = searchSize % blockSize;\n  // Signature is on 4 bytes\n  // It could be between 2 blocks, so we need to read 3 extra bytes\n  auto_buffer buffer(blockSize + 3);\n  bool found = false;\n\n  // Loop through blocks starting at the end of the file (minus ECDREC_SIZE-1)\n  for (int nb=1; !found && (nb <= nbBlock); nb++)\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb),SEEK_SET);\n    if (mFile.Read(buffer.get(), blockSize + 3) != blockSize + 3)\n      return false;\n    for (int i=blockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb)+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  // If not found, look in the last block left...\n  if ( !found && (extraBlockSize > 0) )\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize,SEEK_SET);\n    if (mFile.Read(buffer.get(), extraBlockSize + 3) != extraBlockSize + 3)\n      return false;\n    for (int i=extraBlockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  buffer.clear();\n\n  if ( !found )\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n    mFile.Close();\n    return false;\n  }\n\n  unsigned int cdirOffset, cdirSize;\n  // Get size of the central directory\n  mFile.Seek(12,SEEK_CUR);\n  if (mFile.Read(&cdirSize, 4) != 4)\n    return false;\n  cdirSize = Endian_SwapLE32(cdirSize);\n  // Get Offset of start of central directory with respect to the starting disk number\n  if (mFile.Read(&cdirOffset, 4) != 4)\n    return false;\n  cdirOffset = Endian_SwapLE32(cdirOffset);\n\n  // Go to the start of central directory\n  mFile.Seek(cdirOffset,SEEK_SET);\n\n  char temp[CHDR_SIZE];\n  while (mFile.GetPosition() < cdirOffset + cdirSize)\n  {\n    SZipEntry ze;\n    if (mFile.Read(temp, CHDR_SIZE) != CHDR_SIZE)\n      return false;\n    readCHeader(temp, ze);\n    if (ze.header != ZIP_CENTRAL_HEADER)\n    {\n      CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n      mFile.Close();\n      return false;\n    }\n\n    // Get the filename just after the central file header\n    auto_buffer bufName(ze.flength);\n    if (mFile.Read(bufName.get(), ze.flength) != ze.flength)\n      return false;\n    std::string strName(bufName.get(), bufName.size());\n    bufName.clear();\n    g_charsetConverter.unknownToUTF8(strName);\n    ZeroMemory(ze.name, 255);\n    strncpy(ze.name, strName.c_str(), strName.size()>254 ? 254 : strName.size());\n\n    // Jump after central file header extra field and file comment\n    mFile.Seek(ze.eclength + ze.clength,SEEK_CUR);\n\n    if (!std::regex_search(strName, PATH_TRAVERSAL))\n      items.push_back(ze);\n  }\n\n  /* go through list and figure out file header lengths */\n  for(std::vector<SZipEntry>::iterator it = items.begin(); it != items.end(); ++it)\n  {\n    SZipEntry& ze = *it;\n    // Go to the local file header to get the extra field length\n    // !! local header extra field length != central file header extra field length !!\n    mFile.Seek(ze.lhdrOffset+28,SEEK_SET);\n    if (mFile.Read(&(ze.elength), 2) != 2)\n      return false;\n    ze.elength = Endian_SwapLE16(ze.elength);\n\n    // Compressed data offset = local header offset + size of local header + filename length + local file header extra field length\n    ze.offset = ze.lhdrOffset + LHDR_SIZE + ze.flength + ze.elength;\n\n  }\n\n  mZipMap.insert(make_pair(strFile,items));\n  mFile.Close();\n  return true;\n}",
  "abstract_func": "bool CZipManager::GetZipList(const CURL& VAR_0, std::vector<SZipEntry>& VAR_1)\n{\n  struct __stat64 VAR_2 = {};\n\n  std::string VAR_3 = VAR_0.GetHostName();\n\n  if (CFile::Stat(VAR_3,&VAR_2))\n  {\n    CLog::Log(VAR_4,\"CZipManager::GetZipList: failed to stat file %s\", VAR_0.GetRedacted().c_str());\n    return false;\n  }\n\n  std::map<std::string, std::vector<SZipEntry> >::iterator VAR_5 = VAR_6.find(VAR_3);\n  if (VAR_5 != VAR_6.end()) /* COMMENT_0 */\n  {\n    std::map<std::string,int64_t>::iterator VAR_7=VAR_8.find(VAR_3);\n\n    if (VAR_2.st_mtime == VAR_7->second)\n    {\n      VAR_1 = VAR_5->second;\n      return true;\n    }\n    VAR_6.erase(VAR_5);\n    VAR_8.erase(VAR_7);\n  }\n\n  CFile VAR_9;\n  if (!VAR_9.Open(VAR_3))\n  {\n    CLog::Log(VAR_4,\"ZipManager: unable to open file %s!\",VAR_3.c_str());\n    return false;\n  }\n\n  unsigned int VAR_10;\n  if (VAR_9.Read(&VAR_10, 4)!=4 || (Endian_SwapLE32(VAR_10) != VAR_11 &&\n                                 Endian_SwapLE32(VAR_10) != VAR_12 &&\n                                 Endian_SwapLE32(VAR_10) != VAR_13))\n  {\n    CLog::Log(VAR_4,\"ZipManager: not a zip file!\");\n    VAR_9.Close();\n    return false;\n  }\n\n  if (Endian_SwapLE32(VAR_10) == VAR_13)\n    CLog::LogF(VAR_14, \"ZIP split archive header found. Trying to process as a single archive..\");\n\n  /* COMMENT_1 */\n  VAR_8.insert(make_pair(VAR_3,VAR_2.st_mtime));\n\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  int64_t VAR_15 = VAR_9.GetLength();\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (VAR_15 < VAR_16 - 1)\n  {\n    CLog::Log(VAR_17, \"ZipManager: Invalid zip file length: %\" VAR_18\"\", VAR_15);\n    return false;\n  }\n  int VAR_19 = (int) std::min(VAR_20<int64_t>(65557), VAR_15-VAR_16+1);\n  int VAR_21 = (int) std::min(1024, VAR_19);\n  int VAR_22 = VAR_19 / VAR_21;\n  int VAR_23 = VAR_19 % VAR_21;\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  auto_buffer VAR_24(VAR_21 + 3);\n  bool VAR_25 = false;\n\n  /* COMMENT_11 */\n  for (int VAR_26=1; !VAR_25 && (VAR_26 <= VAR_22); VAR_26++)\n  {\n    VAR_9.Seek(VAR_15-VAR_16+1-(VAR_21*VAR_26),VAR_27);\n    if (VAR_9.Read(VAR_24.get(), VAR_21 + 3) != VAR_21 + 3)\n      return false;\n    for (int VAR_28=VAR_21-1; !VAR_25 && (VAR_28 >= 0); VAR_28--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(VAR_24.get()+VAR_28))) == VAR_29 )\n      {\n        /* COMMENT_12 */\n        VAR_9.Seek(VAR_15-VAR_16+1-(VAR_21*VAR_26)+VAR_28,VAR_27);\n        VAR_25 = true;\n      }\n    }\n  }\n\n  /* COMMENT_13 */\n  if ( !VAR_25 && (VAR_23 > 0) )\n  {\n    VAR_9.Seek(VAR_15-VAR_16+1-VAR_19,VAR_27);\n    if (VAR_9.Read(VAR_24.get(), VAR_23 + 3) != VAR_23 + 3)\n      return false;\n    for (int VAR_28=VAR_23-1; !VAR_25 && (VAR_28 >= 0); VAR_28--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(VAR_24.get()+VAR_28))) == VAR_29 )\n      {\n        /* COMMENT_12 */\n        VAR_9.Seek(VAR_15-VAR_16+1-VAR_19+VAR_28,VAR_27);\n        VAR_25 = true;\n      }\n    }\n  }\n\n  VAR_24.clear();\n\n  if ( !VAR_25 )\n  {\n    CLog::Log(VAR_4,\"ZipManager: broken file %s!\",VAR_3.c_str());\n    VAR_9.Close();\n    return false;\n  }\n\n  unsigned int VAR_30, VAR_31;\n  /* COMMENT_14 */\n  VAR_9.Seek(12,VAR_32);\n  if (VAR_9.Read(&VAR_31, 4) != 4)\n    return false;\n  VAR_31 = Endian_SwapLE32(VAR_31);\n  /* COMMENT_15 */\n  if (VAR_9.Read(&VAR_30, 4) != 4)\n    return false;\n  VAR_30 = Endian_SwapLE32(VAR_30);\n\n  /* COMMENT_16 */\n  VAR_9.Seek(VAR_30,VAR_27);\n\n  char VAR_33[VAR_34];\n  while (VAR_9.GetPosition() < VAR_30 + VAR_31)\n  {\n    SZipEntry VAR_35;\n    if (VAR_9.Read(VAR_33, VAR_34) != VAR_34)\n      return false;\n    readCHeader(VAR_33, VAR_35);\n    if (VAR_35.header != VAR_36)\n    {\n      CLog::Log(VAR_4,\"ZipManager: broken file %s!\",VAR_3.c_str());\n      VAR_9.Close();\n      return false;\n    }\n\n    /* COMMENT_17 */\n    auto_buffer VAR_37(VAR_35.flength);\n    if (VAR_9.Read(VAR_37.get(), VAR_35.flength) != VAR_35.flength)\n      return false;\n    std::string VAR_38(VAR_37.get(), VAR_37.size());\n    VAR_37.clear();\n    VAR_39.unknownToUTF8(VAR_38);\n    ZeroMemory(VAR_35.name, 255);\n    strncpy(VAR_35.name, VAR_38.c_str(), VAR_38.size()>254 ? 254 : VAR_38.size());\n\n    /* COMMENT_18 */\n    VAR_9.Seek(VAR_35.eclength + VAR_35.clength,VAR_32);\n\n    if (!std::regex_search(VAR_38, VAR_40))\n      VAR_1.push_back(VAR_35);\n  }\n\n  /* COMMENT_19 */\n  for(std::vector<SZipEntry>::iterator VAR_5 = VAR_1.begin(); VAR_5 != VAR_1.end(); ++VAR_5)\n  {\n    SZipEntry& VAR_35 = *VAR_5;\n    /* COMMENT_20 */\n    /* COMMENT_21 */\n    VAR_9.Seek(VAR_35.lhdrOffset+28,VAR_27);\n    if (VAR_9.Read(&(VAR_35.elength), 2) != 2)\n      return false;\n    VAR_35.elength = Endian_SwapLE16(VAR_35.elength);\n\n    /* COMMENT_22 */\n    VAR_35.offset = VAR_35.lhdrOffset + VAR_41 + VAR_35.flength + VAR_35.elength;\n\n  }\n\n  VAR_6.insert(make_pair(VAR_3,VAR_1));\n  VAR_9.Close();\n  return true;\n}",
  "func_graph_path": "xbmc/35cfe35608b15335ef21d798947fceab3f47c8d7/ZipManager.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -154,7 +154,8 @@\n     // Jump after central file header extra field and file comment\n     mFile.Seek(ze.eclength + ze.clength,SEEK_CUR);\n \n-    items.push_back(ze);\n+    if (!std::regex_search(strName, PATH_TRAVERSAL))\n+      items.push_back(ze);\n   }\n \n   /* go through list and figure out file header lengths */",
  "diff_line_info": {
    "deleted_lines": [
      "    items.push_back(ze);"
    ],
    "added_lines": [
      "    if (!std::regex_search(strName, PATH_TRAVERSAL))",
      "      items.push_back(ze);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xbmc/xbmc/pull/12024",
  "description": {
    "pr_info": {
      "title": "[filesystem] ZipManager: skip path traversal",
      "number": 12024
    },
    "comment": [
      "<!--- Provide a general summary of your change in the Title above -->\r\n\r\n## Description\r\nSkip items in a zip file, which try to traverse to a parent directory.\r\nBackport of #12023 \r\n<!--- Describe your change in detail -->\r\n\r\n## Motivation and Context\r\nWithout this a zip file can override every file the current user has write permission.\r\n<!--- Why is this change required? What problem does it solve? -->\r\n<!--- If it fixes an open issue, please link to the issue here -->\r\n\r\n## How Has This Been Tested?\r\nTested with a malicious zip file.\r\n<!--- Please describe in detail how you tested your change -->\r\n<!--- Include details of your testing environment, and the tests you ran to -->\r\n<!--- see how your change affects other areas of the code, etc -->\r\n\r\n<!--## Screenshots (if appropriate):-->\r\n\r\n## Types of change\r\n<!--- What type of change does your code introduce? Put an `x` in all the boxes that apply like this: [X] -->\r\n- [x] Bug fix (non-breaking change which fixes an issue)\r\n- [ ] New feature (non-breaking change which adds functionality)\r\n- [ ] Breaking change (fix or feature that would cause existing functionality to change)\r\n\r\n## Checklist:\r\n<!--- Go over all the following points, and put an `x` in all the boxes that apply like this: [X] -->\r\n<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->\r\n- [x] My code follows the [Code guidelines](https://codedocs.xyz/xbmc/xbmc/code_guidelines.html) of this project \r\n- [ ] My change requires a change to the documentation, either Doxygen or wiki\r\n- [ ] I have updated the documentation accordingly\r\n- [x] I have read the [CONTRIBUTING](https://github.com/xbmc/xbmc/blob/master/CONTRIBUTING.md) document\r\n- [ ] I have added tests to cover my change\r\n- [ ] All new and existing tests passed\r\n",
      "updated to be equal with #12023",
      "jenkins build this please",
      "jenkins build this please",
      "jenkins build this please",
      "Hello,\r\n\r\nis this already available here?\r\nhttps://kodi.tv/download\r\n\r\nI see it is in the milestone and from https://kodi.tv/download seems that 17.2 has been released also there.\r\n\r\nI just wanted to double check.\r\n(also it is all on all platforms right?)",
      "Ok I found the article here: https://kodi.tv/article/kodi-v172-minor-bug-fix-and-security-release\r\nThanks :D",
      "Hi,\r\n\r\nI will make a presentation about [Hacked in translation](http://blog.checkpoint.com/2017/05/23/hacked-in-translation/) at one of my computer science courses. I would like also to reproduce the bug with a zip file. Could any of you guys can help me out with a malicious zip file?",
      "@razvansalajan sorry for being harsh on you, but you should be able to make one yourself."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch addresses a path traversal vulnerability in zip file handling, which is a recognized security issue. The commit message and code changes align correctly, filtering out entries that attempt to traverse directories, thereby enhancing security."
}