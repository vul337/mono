{
  "cve_id": "CVE-2017-12562",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libsndfile",
  "commit_msg": "src/common.c: Fix heap buffer overflows when writing strings in binheader\n\nFixes the following problems:\n 1. Case 's' only enlarges the buffer by 16 bytes instead of size bytes.\n 2. psf_binheader_writef() enlarges the header buffer (if needed) prior to the\n    big switch statement by an amount (16 bytes) which is enough for all cases\n    where only a single value gets added. Cases 's', 'S', 'p' however\n    additionally write an arbitrary length block of data and again enlarge the\n    buffer to the required amount. However, the required space calculation does\n    not take into account the size of the length field which gets output before\n    the data.\n 3. Buffer size requirement calculation in case 'S' does not account for the\n    padding byte (\"size += (size & 1) ;\" happens after the calculation which\n    uses \"size\").\n 4. Case 'S' can overrun the header buffer by 1 byte when no padding is\n    involved\n    (\"memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;\" while\n    the buffer is only guaranteed to have \"size\" space available).\n 5. \"psf->header.ptr [psf->header.indx] = 0 ;\" in case 'S' always writes 1 byte\n    beyond the space which is guaranteed to be allocated in the header buffer.\n 6. Case 's' can overrun the provided source string by 1 byte if padding is\n    involved (\"memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\"\n    where \"size\" is \"strlen (strptr) + 1\" (which includes the 0 terminator,\n    plus optionally another 1 which is padding and not guaranteed to be\n    readable via the source string pointer).\n\nCloses: https://github.com/erikd/libsndfile/issues/292",
  "commit_hash": "b6a9d7e95888ffa77d8c75ce3f03e6c7165587cd",
  "git_url": "https://github.com/libsndfile/libsndfile/commit/b6a9d7e95888ffa77d8c75ce3f03e6c7165587cd",
  "file_path": "src/common.c",
  "func_name": "psf_binheader_writef",
  "func_before": "int\npsf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tsf_count_t \t\tcountdata ;\n\tunsigned long \tlongdata ;\n\tunsigned int \tdata ;\n\tfloat\t\t\tfloatdata ;\n\tdouble\t\t\tdoubledata ;\n\tvoid\t\t\t*bindata ;\n\tsize_t\t\t\tsize ;\n\tchar\t\t\tc, *strptr ;\n\tint\t\t\t\tcount = 0, trunc_8to4 ;\n\n\ttrunc_8to4 = SF_FALSE ;\n\n\tva_start (argptr, format) ;\n\n\twhile ((c = *format++))\n\t{\n\t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))\n\t\t\treturn count ;\n\n\t\tswitch (c)\n\t\t{\tcase ' ' : /* Do nothing. Just used to space out format string. */\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'e' : /* All conversions are now from LE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 't' : /* All 8 byte values now get written as 4 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'T' : /* All 8 byte values now get written as 8 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_FALSE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_marker (psf, data) ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_byte (psf, data) ;\n\t\t\t\t\tcount += 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_short (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_short (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 2 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* tribyte */\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_3byte (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_3byte (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 3 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_int (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_int (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' :\n\t\t\t\t\tcountdata = va_arg (argptr, sf_count_t) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_be_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_le_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_be_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_le_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' :\n\t\t\t\t\t/* Floats are passed as doubles. Is this always true? */\n\t\t\t\t\tfloatdata = (float) va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tfloat32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tfloat32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\tpsf->header.indx += 4 ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' :\n\t\t\t\t\tdoubledata = va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tdouble64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tdouble64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\tpsf->header.indx += 8 ;\n\t\t\t\t\tcount += 8 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\t/* Write a C string (guaranteed to have a zero terminator). */\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) + 1 ;\n\t\t\t\t\tsize += (size & 1) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tpsf->header.ptr [psf->header.indx - 1] = 0 ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'S' :\n\t\t\t\t\t/*\n\t\t\t\t\t**\tWrite an AIFF style string (no zero terminator but possibly\n\t\t\t\t\t**\tan extra pad byte if the string length is odd).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;\n\t\t\t\t\tsize += (size & 1) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tpsf->header.ptr [psf->header.indx] = 0 ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\n\t\t\t\t\t/* Write a PASCAL string (as used by AIFF files).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tsize = (size & 1) ? size : size + 1 ;\n\t\t\t\t\tsize = (size > 254) ? 254 : size ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\theader_put_byte (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += 1 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' :\n\t\t\t\t\tbindata\t= va_arg (argptr, void *) ;\n\t\t\t\t\tsize\t= va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tcount += size ;\n\t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;\n\t\t\t\t\t\tpsf->header.indx ++ ;\n\t\t\t\t\t\tsize -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tbindata = va_arg (argptr, void *) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;\n\t\t\t\t\tpsf->header.indx += 16 ;\n\t\t\t\t\tcount += 16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* Jump forwards/backwards by specified amount. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'o' :\t/* Jump to specified offset. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tpsf->header.indx = size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\treturn count ;\n}",
  "abstract_func_before": "int\npsf_binheader_writef (SF_PRIVATE *VAR_0, const char *VAR_1, ...)\n{\tva_list\tVAR_2 ;\n\tsf_count_t \t\tVAR_3 ;\n\tunsigned long \tVAR_4 ;\n\tunsigned int \tVAR_5 ;\n\tfloat\t\t\tVAR_6 ;\n\tdouble\t\t\tVAR_7 ;\n\tvoid\t\t\t*VAR_8 ;\n\tsize_t\t\t\tVAR_9 ;\n\tchar\t\t\tVAR_10, *VAR_11 ;\n\tint\t\t\t\tVAR_12 = 0, VAR_13 ;\n\n\tVAR_13 = VAR_14 ;\n\n\tva_start (VAR_2, VAR_1) ;\n\n\twhile ((VAR_10 = *VAR_1++))\n\t{\n\t\tif (VAR_0->header.indx + 16 >= VAR_0->header.len && psf_bump_header_allocation (VAR_0, 16))\n\t\t\treturn VAR_12 ;\n\n\t\tswitch (VAR_10)\n\t\t{\tcase ' ' : /* COMMENT_0 */\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'e' : /* COMMENT_1 */\n\t\t\t\t\tVAR_0->rwf_endian = VAR_15 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* COMMENT_2 */\n\t\t\t\t\tVAR_0->rwf_endian = VAR_16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 't' : /* COMMENT_3 */\n\t\t\t\t\tVAR_13 = VAR_17 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'T' : /* COMMENT_4 */\n\t\t\t\t\tVAR_13 = VAR_14 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\theader_put_marker (VAR_0, VAR_5) ;\n\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\theader_put_byte (VAR_0, VAR_5) ;\n\t\t\t\t\tVAR_12 += 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t{\theader_put_be_short (VAR_0, VAR_5) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_short (VAR_0, VAR_5) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tVAR_12 += 2 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* COMMENT_5 */\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t{\theader_put_be_3byte (VAR_0, VAR_5) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_3byte (VAR_0, VAR_5) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tVAR_12 += 3 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t{\theader_put_be_int (VAR_0, VAR_5) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_int (VAR_0, VAR_5) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' :\n\t\t\t\t\tVAR_3 = va_arg (VAR_2, sf_count_t) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16 && VAR_13 == VAR_14)\n\t\t\t\t\t{\theader_put_be_8byte (VAR_0, VAR_3) ;\n\t\t\t\t\t\tVAR_12 += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (VAR_0->rwf_endian == VAR_15 && VAR_13 == VAR_14)\n\t\t\t\t\t{\theader_put_le_8byte (VAR_0, VAR_3) ;\n\t\t\t\t\t\tVAR_12 += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (VAR_0->rwf_endian == VAR_16 && VAR_13 == VAR_17)\n\t\t\t\t\t{\tVAR_4 = VAR_3 & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_be_int (VAR_0, VAR_4) ;\n\t\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (VAR_0->rwf_endian == VAR_15 && VAR_13 == VAR_17)\n\t\t\t\t\t{\tVAR_4 = VAR_3 & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_le_int (VAR_0, VAR_4) ;\n\t\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' :\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tVAR_6 = (float) va_arg (VAR_2, double) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\tfloat32_be_write (VAR_6, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tfloat32_le_write (VAR_6, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\tVAR_0->header.indx += 4 ;\n\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' :\n\t\t\t\t\tVAR_7 = va_arg (VAR_2, double) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\tdouble64_be_write (VAR_7, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tdouble64_le_write (VAR_7, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\tVAR_0->header.indx += 8 ;\n\t\t\t\t\tVAR_12 += 8 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\t/* COMMENT_7 */\n\t\t\t\t\tVAR_11 = va_arg (VAR_2, char *) ;\n\t\t\t\t\tVAR_9 = strlen (VAR_11) + 1 ;\n\t\t\t\t\tVAR_9 += (VAR_9 & 1) ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 >= VAR_0->header.len && psf_bump_header_allocation (VAR_0, 16))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\theader_put_be_int (VAR_0, VAR_9) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (VAR_0, VAR_9) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_11, VAR_9) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_0->header.ptr [VAR_0->header.indx - 1] = 0 ;\n\t\t\t\t\tVAR_12 += 4 + VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'S' :\n\t\t\t\t\t/* COMMENT_8 */\n                                                                   \n                                                       \n       \n\t\t\t\t\tVAR_11 = va_arg (VAR_2, char *) ;\n\t\t\t\t\tVAR_9 = strlen (VAR_11) ;\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\theader_put_be_int (VAR_0, VAR_9) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (VAR_0, VAR_9) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_11, VAR_9 + 1) ;\n\t\t\t\t\tVAR_9 += (VAR_9 & 1) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_0->header.ptr [VAR_0->header.indx] = 0 ;\n\t\t\t\t\tVAR_12 += 4 + VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\n\t\t\t\t\t/* COMMENT_12 */\n       \n\t\t\t\t\tVAR_11 = va_arg (VAR_2, char *) ;\n\t\t\t\t\tVAR_9 = strlen (VAR_11) ;\n\t\t\t\t\tVAR_9 = (VAR_9 & 1) ? VAR_9 : VAR_9 + 1 ;\n\t\t\t\t\tVAR_9 = (VAR_9 > 254) ? 254 : VAR_9 ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\theader_put_byte (VAR_0, VAR_9) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_11, VAR_9) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_12 += 1 + VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' :\n\t\t\t\t\tVAR_8\t= va_arg (VAR_2, void *) ;\n\t\t\t\t\tVAR_9\t= va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_8, VAR_9) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_12 += VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tVAR_9 = va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tVAR_12 += VAR_9 ;\n\t\t\t\t\twhile (VAR_9)\n\t\t\t\t\t{\tVAR_0->header.ptr [VAR_0->header.indx] = 0 ;\n\t\t\t\t\t\tVAR_0->header.indx ++ ;\n\t\t\t\t\t\tVAR_9 -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tVAR_8 = va_arg (VAR_2, void *) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_8, 16) ;\n\t\t\t\t\tVAR_0->header.indx += 16 ;\n\t\t\t\t\tVAR_12 += 16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* COMMENT_14 */\n\t\t\t\t\tVAR_9 = va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_12 += VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'o' :\t/* COMMENT_15 */\n\t\t\t\t\tVAR_9 = va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif ((sf_count_t) VAR_9 >= VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tVAR_0->header.indx = VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (VAR_0, \"*** Invalid format specifier `%c'\\n\", VAR_10) ;\n\t\t\t\tVAR_0->error = VAR_18 ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (VAR_2) ;\n\treturn VAR_12 ;\n}",
  "func_graph_path_before": "libsndfile/b6a9d7e95888ffa77d8c75ce3f03e6c7165587cd/common.c/vul/before/0.json",
  "func": "int\npsf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tsf_count_t \t\tcountdata ;\n\tunsigned long \tlongdata ;\n\tunsigned int \tdata ;\n\tfloat\t\t\tfloatdata ;\n\tdouble\t\t\tdoubledata ;\n\tvoid\t\t\t*bindata ;\n\tsize_t\t\t\tsize ;\n\tchar\t\t\tc, *strptr ;\n\tint\t\t\t\tcount = 0, trunc_8to4 ;\n\n\ttrunc_8to4 = SF_FALSE ;\n\n\tva_start (argptr, format) ;\n\n\twhile ((c = *format++))\n\t{\n\t\tif (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))\n\t\t\treturn count ;\n\n\t\tswitch (c)\n\t\t{\tcase ' ' : /* Do nothing. Just used to space out format string. */\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'e' : /* All conversions are now from LE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_LITTLE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* All conversions are now from BE to host. */\n\t\t\t\t\tpsf->rwf_endian = SF_ENDIAN_BIG ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 't' : /* All 8 byte values now get written as 4 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'T' : /* All 8 byte values now get written as 8 bytes. */\n\t\t\t\t\ttrunc_8to4 = SF_FALSE ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_marker (psf, data) ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\theader_put_byte (psf, data) ;\n\t\t\t\t\tcount += 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_short (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_short (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 2 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* tribyte */\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_3byte (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_3byte (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 3 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' :\n\t\t\t\t\tdata = va_arg (argptr, unsigned int) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t{\theader_put_be_int (psf, data) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_int (psf, data) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' :\n\t\t\t\t\tcountdata = va_arg (argptr, sf_count_t) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_be_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)\n\t\t\t\t\t{\theader_put_le_8byte (psf, countdata) ;\n\t\t\t\t\t\tcount += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_be_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)\n\t\t\t\t\t{\tlongdata = countdata & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_le_int (psf, longdata) ;\n\t\t\t\t\t\tcount += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' :\n\t\t\t\t\t/* Floats are passed as doubles. Is this always true? */\n\t\t\t\t\tfloatdata = (float) va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tfloat32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tfloat32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\tpsf->header.indx += 4 ;\n\t\t\t\t\tcount += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' :\n\t\t\t\t\tdoubledata = va_arg (argptr, double) ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\tdouble64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tdouble64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;\n\t\t\t\t\tpsf->header.indx += 8 ;\n\t\t\t\t\tcount += 8 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\t/* Write a C string (guaranteed to have a zero terminator). */\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) + 1 ;\n\n\t\t\t\t\tif (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size + (size & 1)) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size + (size & 1)) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tsize += (size & 1) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tpsf->header.ptr [psf->header.indx - 1] = 0 ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'S' :\n\t\t\t\t\t/*\n\t\t\t\t\t**\tWrite an AIFF style string (no zero terminator but possibly\n\t\t\t\t\t**\tan extra pad byte if the string length is odd).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tif (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))\n\t\t\t\t\t\treturn count ;\n\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n\t\t\t\t\t\theader_put_be_int (psf, size) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + (size & 1)) ;\n\t\t\t\t\tsize += (size & 1) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += 4 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\n\t\t\t\t\t/* Write a PASCAL string (as used by AIFF files).\n\t\t\t\t\t*/\n\t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n\t\t\t\t\tsize = strlen (strptr) ;\n\t\t\t\t\tsize = (size & 1) ? size : size + 1 ;\n\t\t\t\t\tsize = (size > 254) ? 254 : size ;\n\n\t\t\t\t\tif (psf->header.indx + 1 + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, 1 + size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\theader_put_byte (psf, size) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += 1 + size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' :\n\t\t\t\t\tbindata\t= va_arg (argptr, void *) ;\n\t\t\t\t\tsize\t= va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tcount += size ;\n\t\t\t\t\twhile (size)\n\t\t\t\t\t{\tpsf->header.ptr [psf->header.indx] = 0 ;\n\t\t\t\t\t\tpsf->header.indx ++ ;\n\t\t\t\t\t\tsize -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tbindata = va_arg (argptr, void *) ;\n\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;\n\t\t\t\t\tpsf->header.indx += 16 ;\n\t\t\t\t\tcount += 16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* Jump forwards/backwards by specified amount. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tpsf->header.indx += size ;\n\t\t\t\t\tcount += size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'o' :\t/* Jump to specified offset. */\n\t\t\t\t\tsize = va_arg (argptr, size_t) ;\n\n\t\t\t\t\tif ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))\n\t\t\t\t\t\treturn count ;\n\n\t\t\t\t\tpsf->header.indx = size ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;\n\t\t\t\tpsf->error = SFE_INTERNAL ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (argptr) ;\n\treturn count ;\n}",
  "abstract_func": "int\npsf_binheader_writef (SF_PRIVATE *VAR_0, const char *VAR_1, ...)\n{\tva_list\tVAR_2 ;\n\tsf_count_t \t\tVAR_3 ;\n\tunsigned long \tVAR_4 ;\n\tunsigned int \tVAR_5 ;\n\tfloat\t\t\tVAR_6 ;\n\tdouble\t\t\tVAR_7 ;\n\tvoid\t\t\t*VAR_8 ;\n\tsize_t\t\t\tVAR_9 ;\n\tchar\t\t\tVAR_10, *VAR_11 ;\n\tint\t\t\t\tVAR_12 = 0, VAR_13 ;\n\n\tVAR_13 = VAR_14 ;\n\n\tva_start (VAR_2, VAR_1) ;\n\n\twhile ((VAR_10 = *VAR_1++))\n\t{\n\t\tif (VAR_0->header.indx + 16 >= VAR_0->header.len && psf_bump_header_allocation (VAR_0, 16))\n\t\t\treturn VAR_12 ;\n\n\t\tswitch (VAR_10)\n\t\t{\tcase ' ' : /* COMMENT_0 */\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'e' : /* COMMENT_1 */\n\t\t\t\t\tVAR_0->rwf_endian = VAR_15 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'E' : /* COMMENT_2 */\n\t\t\t\t\tVAR_0->rwf_endian = VAR_16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 't' : /* COMMENT_3 */\n\t\t\t\t\tVAR_13 = VAR_17 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'T' : /* COMMENT_4 */\n\t\t\t\t\tVAR_13 = VAR_14 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'm' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\theader_put_marker (VAR_0, VAR_5) ;\n\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '1' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\theader_put_byte (VAR_0, VAR_5) ;\n\t\t\t\t\tVAR_12 += 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '2' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t{\theader_put_be_short (VAR_0, VAR_5) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_short (VAR_0, VAR_5) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tVAR_12 += 2 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '3' : /* COMMENT_5 */\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t{\theader_put_be_3byte (VAR_0, VAR_5) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_3byte (VAR_0, VAR_5) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tVAR_12 += 3 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '4' :\n\t\t\t\t\tVAR_5 = va_arg (VAR_2, unsigned int) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t{\theader_put_be_int (VAR_0, VAR_5) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\theader_put_le_int (VAR_0, VAR_5) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase '8' :\n\t\t\t\t\tVAR_3 = va_arg (VAR_2, sf_count_t) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16 && VAR_13 == VAR_14)\n\t\t\t\t\t{\theader_put_be_8byte (VAR_0, VAR_3) ;\n\t\t\t\t\t\tVAR_12 += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (VAR_0->rwf_endian == VAR_15 && VAR_13 == VAR_14)\n\t\t\t\t\t{\theader_put_le_8byte (VAR_0, VAR_3) ;\n\t\t\t\t\t\tVAR_12 += 8 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (VAR_0->rwf_endian == VAR_16 && VAR_13 == VAR_17)\n\t\t\t\t\t{\tVAR_4 = VAR_3 & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_be_int (VAR_0, VAR_4) ;\n\t\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (VAR_0->rwf_endian == VAR_15 && VAR_13 == VAR_17)\n\t\t\t\t\t{\tVAR_4 = VAR_3 & 0xFFFFFFFF ;\n\t\t\t\t\t\theader_put_le_int (VAR_0, VAR_4) ;\n\t\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'f' :\n\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\tVAR_6 = (float) va_arg (VAR_2, double) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\tfloat32_be_write (VAR_6, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tfloat32_le_write (VAR_6, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\tVAR_0->header.indx += 4 ;\n\t\t\t\t\tVAR_12 += 4 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'd' :\n\t\t\t\t\tVAR_7 = va_arg (VAR_2, double) ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\tdouble64_be_write (VAR_7, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tdouble64_le_write (VAR_7, VAR_0->header.ptr + VAR_0->header.indx) ;\n\t\t\t\t\tVAR_0->header.indx += 8 ;\n\t\t\t\t\tVAR_12 += 8 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 's' :\n\t\t\t\t\t/* COMMENT_7 */\n\t\t\t\t\tVAR_11 = va_arg (VAR_2, char *) ;\n\t\t\t\t\tVAR_9 = strlen (VAR_11) + 1 ;\n\n\t\t\t\t\tif (VAR_0->header.indx + 4 + (sf_count_t) VAR_9 + (sf_count_t) (VAR_9 & 1) > VAR_0->header.len && psf_bump_header_allocation (VAR_0, 4 + VAR_9 + (VAR_9 & 1)))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\theader_put_be_int (VAR_0, VAR_9 + (VAR_9 & 1)) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (VAR_0, VAR_9 + (VAR_9 & 1)) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_11, VAR_9) ;\n\t\t\t\t\tVAR_9 += (VAR_9 & 1) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_0->header.ptr [VAR_0->header.indx - 1] = 0 ;\n\t\t\t\t\tVAR_12 += 4 + VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'S' :\n\t\t\t\t\t/* COMMENT_8 */\n                                                                   \n                                                       \n       \n\t\t\t\t\tVAR_11 = va_arg (VAR_2, char *) ;\n\t\t\t\t\tVAR_9 = strlen (VAR_11) ;\n\t\t\t\t\tif (VAR_0->header.indx + 4 + (sf_count_t) VAR_9 + (sf_count_t) (VAR_9 & 1) > VAR_0->header.len && psf_bump_header_allocation (VAR_0, 4 + VAR_9 + (VAR_9 & 1)))\n\t\t\t\t\t\treturn VAR_12 ;\n\t\t\t\t\tif (VAR_0->rwf_endian == VAR_16)\n\t\t\t\t\t\theader_put_be_int (VAR_0, VAR_9) ;\n\t\t\t\t\telse\n\t\t\t\t\t\theader_put_le_int (VAR_0, VAR_9) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_11, VAR_9 + (VAR_9 & 1)) ;\n\t\t\t\t\tVAR_9 += (VAR_9 & 1) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_12 += 4 + VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'p' :\n\t\t\t\t\t/* COMMENT_12 */\n       \n\t\t\t\t\tVAR_11 = va_arg (VAR_2, char *) ;\n\t\t\t\t\tVAR_9 = strlen (VAR_11) ;\n\t\t\t\t\tVAR_9 = (VAR_9 & 1) ? VAR_9 : VAR_9 + 1 ;\n\t\t\t\t\tVAR_9 = (VAR_9 > 254) ? 254 : VAR_9 ;\n\n\t\t\t\t\tif (VAR_0->header.indx + 1 + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, 1 + VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\theader_put_byte (VAR_0, VAR_9) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_11, VAR_9) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_12 += 1 + VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'b' :\n\t\t\t\t\tVAR_8\t= va_arg (VAR_2, void *) ;\n\t\t\t\t\tVAR_9\t= va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_8, VAR_9) ;\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_12 += VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'z' :\n\t\t\t\t\tVAR_9 = va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tVAR_12 += VAR_9 ;\n\t\t\t\t\twhile (VAR_9)\n\t\t\t\t\t{\tVAR_0->header.ptr [VAR_0->header.indx] = 0 ;\n\t\t\t\t\t\tVAR_0->header.indx ++ ;\n\t\t\t\t\t\tVAR_9 -- ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'h' :\n\t\t\t\t\tVAR_8 = va_arg (VAR_2, void *) ;\n\t\t\t\t\tmemcpy (&(VAR_0->header.ptr [VAR_0->header.indx]), VAR_8, 16) ;\n\t\t\t\t\tVAR_0->header.indx += 16 ;\n\t\t\t\t\tVAR_12 += 16 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'j' :\t/* COMMENT_14 */\n\t\t\t\t\tVAR_9 = va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif (VAR_0->header.indx + (sf_count_t) VAR_9 > VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tVAR_0->header.indx += VAR_9 ;\n\t\t\t\t\tVAR_12 += VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase 'o' :\t/* COMMENT_15 */\n\t\t\t\t\tVAR_9 = va_arg (VAR_2, size_t) ;\n\n\t\t\t\t\tif ((sf_count_t) VAR_9 >= VAR_0->header.len && psf_bump_header_allocation (VAR_0, VAR_9))\n\t\t\t\t\t\treturn VAR_12 ;\n\n\t\t\t\t\tVAR_0->header.indx = VAR_9 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\tpsf_log_printf (VAR_0, \"*** Invalid format specifier `%c'\\n\", VAR_10) ;\n\t\t\t\tVAR_0->error = VAR_18 ;\n\t\t\t\tbreak ;\n\t\t\t} ;\n\t\t} ;\n\n\tva_end (VAR_2) ;\n\treturn VAR_12 ;\n}",
  "func_graph_path": "libsndfile/b6a9d7e95888ffa77d8c75ce3f03e6c7165587cd/common.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -132,16 +132,16 @@\n \t\t\t\t\t/* Write a C string (guaranteed to have a zero terminator). */\n \t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n \t\t\t\t\tsize = strlen (strptr) + 1 ;\n+\n+\t\t\t\t\tif (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))\n+\t\t\t\t\t\treturn count ;\n+\n+\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n+\t\t\t\t\t\theader_put_be_int (psf, size + (size & 1)) ;\n+\t\t\t\t\telse\n+\t\t\t\t\t\theader_put_le_int (psf, size + (size & 1)) ;\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n \t\t\t\t\tsize += (size & 1) ;\n-\n-\t\t\t\t\tif (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))\n-\t\t\t\t\t\treturn count ;\n-\n-\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n-\t\t\t\t\t\theader_put_be_int (psf, size) ;\n-\t\t\t\t\telse\n-\t\t\t\t\t\theader_put_le_int (psf, size) ;\n-\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\n \t\t\t\t\tpsf->header.indx += size ;\n \t\t\t\t\tpsf->header.ptr [psf->header.indx - 1] = 0 ;\n \t\t\t\t\tcount += 4 + size ;\n@@ -154,16 +154,15 @@\n \t\t\t\t\t*/\n \t\t\t\t\tstrptr = va_arg (argptr, char *) ;\n \t\t\t\t\tsize = strlen (strptr) ;\n-\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\tif (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))\n \t\t\t\t\t\treturn count ;\n \t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)\n \t\t\t\t\t\theader_put_be_int (psf, size) ;\n \t\t\t\t\telse\n \t\t\t\t\t\theader_put_le_int (psf, size) ;\n-\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;\n+\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + (size & 1)) ;\n \t\t\t\t\tsize += (size & 1) ;\n \t\t\t\t\tpsf->header.indx += size ;\n-\t\t\t\t\tpsf->header.ptr [psf->header.indx] = 0 ;\n \t\t\t\t\tcount += 4 + size ;\n \t\t\t\t\tbreak ;\n \n@@ -175,7 +174,7 @@\n \t\t\t\t\tsize = (size & 1) ? size : size + 1 ;\n \t\t\t\t\tsize = (size > 254) ? 254 : size ;\n \n-\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))\n+\t\t\t\t\tif (psf->header.indx + 1 + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, 1 + size))\n \t\t\t\t\t\treturn count ;\n \n \t\t\t\t\theader_put_byte (psf, size) ;",
  "diff_line_info": {
    "deleted_lines": [
      "",
      "\t\t\t\t\tif (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))",
      "\t\t\t\t\t\treturn count ;",
      "",
      "\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)",
      "\t\t\t\t\t\theader_put_be_int (psf, size) ;",
      "\t\t\t\t\telse",
      "\t\t\t\t\t\theader_put_le_int (psf, size) ;",
      "\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;",
      "\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))",
      "\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;",
      "\t\t\t\t\tpsf->header.ptr [psf->header.indx] = 0 ;",
      "\t\t\t\t\tif (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))"
    ],
    "added_lines": [
      "",
      "\t\t\t\t\tif (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))",
      "\t\t\t\t\t\treturn count ;",
      "",
      "\t\t\t\t\tif (psf->rwf_endian == SF_ENDIAN_BIG)",
      "\t\t\t\t\t\theader_put_be_int (psf, size + (size & 1)) ;",
      "\t\t\t\t\telse",
      "\t\t\t\t\t\theader_put_le_int (psf, size + (size & 1)) ;",
      "\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;",
      "\t\t\t\t\tif (psf->header.indx + 4 + (sf_count_t) size + (sf_count_t) (size & 1) > psf->header.len && psf_bump_header_allocation (psf, 4 + size + (size & 1)))",
      "\t\t\t\t\tmemcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + (size & 1)) ;",
      "\t\t\t\t\tif (psf->header.indx + 1 + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, 1 + size))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libsndfile/libsndfile/pull/293",
  "description": {
    "pr_info": {
      "title": "src/common.c: Fix heap buffer overflows when writing strings in binheader",
      "number": 293
    },
    "comment": [
      "Fixes the following problems:\r\n 1. Case 's' only enlarges the buffer by 16 bytes instead of size bytes.\r\n 2. psf_binheader_writef() enlarges the header buffer (if needed) prior to the\r\n    big switch statement by an amount (16 bytes) which is enough for all cases\r\n    where only a single value gets added. Cases 's', 'S', 'p' however\r\n    additionally write an arbitrary length block of data and again enlarge the\r\n    buffer to the required amount. However, the required space calculation does\r\n    not take into account the size of the length field which gets output before\r\n    the data.\r\n 3. Buffer size requirement calculation in case 'S' does not account for the\r\n    padding byte (\"size += (size & 1) ;\" happens after the calculation which\r\n    uses \"size\").\r\n 4. Case 'S' can overrun the header buffer by 1 byte when no padding is\r\n    involved\r\n    (\"memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;\" while\r\n    the buffer is only guaranteed to have \"size\" space available).\r\n 5. \"psf->header.ptr [psf->header.indx] = 0 ;\" in case 'S' always writes 1 byte\r\n    beyond the space which is guaranteed to be allocated in the header buffer.\r\n 6. Case 's' can overrun the provided source string by 1 byte if padding is\r\n    involved (\"memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;\"\r\n    where \"size\" is \"strlen (strptr) + 1\" (which includes the 0 terminator,\r\n    plus optionally another 1 which is padding and not guaranteed to be\r\n    readable via the source string pointer).\r\n\r\nCloses: https://github.com/erikd/libsndfile/issues/292\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}