{
  "cve_id": "CVE-2021-41099",
  "cwe_ids": [
    "CWE-190",
    "CWE-680"
  ],
  "cvss_vector": "AV:N/AC:M/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix integer overflow in _sdsMakeRoomFor (CVE-2021-41099)",
  "commit_hash": "c6ad876774f3cc11e32681ea02a2eead00f2c521",
  "git_url": "https://github.com/redis/redis/commit/c6ad876774f3cc11e32681ea02a2eead00f2c521",
  "file_path": "src/sds.c",
  "func_name": "sdsMakeRoomFor",
  "func_before": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}",
  "abstract_func_before": "sds sdsMakeRoomFor(sds VAR_0, size_t VAR_1) {\n    void *VAR_2, *VAR_3;\n    size_t VAR_4 = sdsavail(VAR_0);\n    size_t VAR_5, VAR_6;\n    char VAR_7, VAR_8 = VAR_0[-1] & VAR_9;\n    int VAR_10;\n\n    /* COMMENT_0 */\n    if (VAR_4 >= VAR_1) return VAR_0;\n\n    VAR_5 = sdslen(VAR_0);\n    VAR_2 = (char*)VAR_0-sdsHdrSize(VAR_8);\n    VAR_6 = (VAR_5+VAR_1);\n    assert(VAR_6 > VAR_5);   /* COMMENT_1 */\n    if (VAR_6 < VAR_11)\n        VAR_6 *= 2;\n    else\n        VAR_6 += VAR_11;\n\n    VAR_7 = sdsReqType(VAR_6);\n\n    /* COMMENT_2 */\n                                                                           \n                                       \n    if (VAR_7 == VAR_12) VAR_7 = VAR_13;\n\n    VAR_10 = sdsHdrSize(VAR_7);\n    assert(VAR_10 + VAR_6 + 1 > VAR_5);  /* COMMENT_1 */\n    if (VAR_8==VAR_7) {\n        VAR_3 = s_realloc(VAR_2, VAR_10+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        VAR_0 = (char*)VAR_3+VAR_10;\n    } else {\n        /* COMMENT_5 */\n                                   \n        VAR_3 = s_malloc(VAR_10+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        memcpy((char*)VAR_3+VAR_10, VAR_0, VAR_5+1);\n        s_free(VAR_2);\n        VAR_0 = (char*)VAR_3+VAR_10;\n        VAR_0[-1] = VAR_7;\n        sdssetlen(VAR_0, VAR_5);\n    }\n    sdssetalloc(VAR_0, VAR_6);\n    return VAR_0;\n}",
  "func_graph_path_before": "redis/c6ad876774f3cc11e32681ea02a2eead00f2c521/sds.c/vul/before/0.json",
  "func": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}",
  "abstract_func": "sds sdsMakeRoomFor(sds VAR_0, size_t VAR_1) {\n    void *VAR_2, *VAR_3;\n    size_t VAR_4 = sdsavail(VAR_0);\n    size_t VAR_5, VAR_6, VAR_7;\n    char VAR_8, VAR_9 = VAR_0[-1] & VAR_10;\n    int VAR_11;\n\n    /* COMMENT_0 */\n    if (VAR_4 >= VAR_1) return VAR_0;\n\n    VAR_5 = sdslen(VAR_0);\n    VAR_2 = (char*)VAR_0-sdsHdrSize(VAR_9);\n    VAR_7 = VAR_6 = (VAR_5+VAR_1);\n    assert(VAR_6 > VAR_5);   /* COMMENT_1 */\n    if (VAR_6 < VAR_12)\n        VAR_6 *= 2;\n    else\n        VAR_6 += VAR_12;\n\n    VAR_8 = sdsReqType(VAR_6);\n\n    /* COMMENT_2 */\n                                                                           \n                                       \n    if (VAR_8 == VAR_13) VAR_8 = VAR_14;\n\n    VAR_11 = sdsHdrSize(VAR_8);\n    assert(VAR_11 + VAR_6 + 1 > VAR_7);  /* COMMENT_1 */\n    if (VAR_9==VAR_8) {\n        VAR_3 = s_realloc(VAR_2, VAR_11+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        VAR_0 = (char*)VAR_3+VAR_11;\n    } else {\n        /* COMMENT_5 */\n                                   \n        VAR_3 = s_malloc(VAR_11+VAR_6+1);\n        if (VAR_3 == NULL) return NULL;\n        memcpy((char*)VAR_3+VAR_11, VAR_0, VAR_5+1);\n        s_free(VAR_2);\n        VAR_0 = (char*)VAR_3+VAR_11;\n        VAR_0[-1] = VAR_8;\n        sdssetlen(VAR_0, VAR_5);\n    }\n    sdssetalloc(VAR_0, VAR_6);\n    return VAR_0;\n}",
  "func_graph_path": "redis/c6ad876774f3cc11e32681ea02a2eead00f2c521/sds.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n sds sdsMakeRoomFor(sds s, size_t addlen) {\n     void *sh, *newsh;\n     size_t avail = sdsavail(s);\n-    size_t len, newlen;\n+    size_t len, newlen, reqlen;\n     char type, oldtype = s[-1] & SDS_TYPE_MASK;\n     int hdrlen;\n \n@@ -10,7 +10,7 @@\n \n     len = sdslen(s);\n     sh = (char*)s-sdsHdrSize(oldtype);\n-    newlen = (len+addlen);\n+    reqlen = newlen = (len+addlen);\n     assert(newlen > len);   /* Catch size_t overflow */\n     if (newlen < SDS_MAX_PREALLOC)\n         newlen *= 2;\n@@ -25,7 +25,7 @@\n     if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n \n     hdrlen = sdsHdrSize(type);\n-    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n+    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */\n     if (oldtype==type) {\n         newsh = s_realloc(sh, hdrlen+newlen+1);\n         if (newsh == NULL) return NULL;",
  "diff_line_info": {
    "deleted_lines": [
      "    size_t len, newlen;",
      "    newlen = (len+addlen);",
      "    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */"
    ],
    "added_lines": [
      "    size_t len, newlen, reqlen;",
      "    reqlen = newlen = (len+addlen);",
      "    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch addresses an integer overflow vulnerability (CVE-2021-41099) by modifying memory allocation checks in sdsMakeRoomFor, clearly intended to prevent buffer overflow attacks."
}