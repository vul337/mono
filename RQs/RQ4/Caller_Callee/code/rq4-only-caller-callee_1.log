nohup: ignoring input
 10:14:28 PM - [INFO]: Using model: Qwen/Qwen3-32B with podman containers: 5
 		platform: github
 10:14:28 PM - [INFO]: Loaded 97 success CVEs.
 10:14:28 PM - [INFO]: Loaded 4 CVEs to process
 10:14:28 PM - [INFO]: Thread-Thread-1 processing CVE-2022-47662
 10:14:29 PM - [INFO]: Thread-Thread-2 processing CVE-2018-11243
 10:14:29 PM - [INFO]: Thread-Thread-3 processing CVE-2019-25104
 10:14:29 PM - [INFO]: Thread-Thread-4 processing CVE-2023-39150
 10:14:50 PM - [INFO]: [Initial analysis response] 
{
    "language": "c",
    "vulnerability_type": "memory",
    "repair_strategy": "The patch adds a null check for `sample` after calling `gf_isom_get_sample` in `isom_tools.c:3544`, preventing dereference of a null pointer which would cause a segmentation fault. If `sample` is null, it retrieves the error and exits via `err_exit`.",
    "analysis": "The null check in `gf_media_split_hevc_tiles` prevents invalid memory access when `gf_isom_get_sample` fails. However, the connection between this patch and the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly evident from the provided code. The patch likely addresses an indirect trigger condition but does not explain the recursion root cause. Further context is required to trace how `gf_media_split_hevc_tiles` interacts with `Media_GetSample`.",
    "need_context": true,
    "required_context": [
        "caller: gf_media_split_hevc_tiles",
        "function: gf_isom_get_sample"
    ],
    "root_cause": "In `gf_media_split_hevc_tiles` (isom_tools.c:3544), `gf_isom_get_sample` may return null, leading to uninitialized `sample->data`/`sample->dataLength` access. The patch adds a null check to prevent this. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly addressed here. GAP: Missing link between `gf_media_split_hevc_tiles` and `Media_GetSample` logic.",
    "confidence_score": 0.65
}
 10:14:50 PM - [INFO]: http://localhost:2000 Joern service is available
 10:14:51 PM - [INFO]: [Initial analysis response] 
{
    "language": "c",
    "vulnerability_type": "memory",
    "repair_strategy": "Replaced G_Alloc with trap_Alloc in AICast_ScriptParse (code/game/ai_cast_script.c:519, 592, 624) and AICast_ScriptLoad (code/game/ai_cast_script.c:392) to mitigate memory exhaustion.",
    "analysis": "The patch addresses a denial-of-service vulnerability caused by memory allocation failures in G_Alloc. Repeated team command spam triggers excessive allocations via G_Alloc, exhausting its fixed POOLSIZE. The fix replaces G_Alloc with trap_Alloc, which likely manages memory differently (e.g., dynamic allocation or larger pool). However, the exact behavior of G_Alloc vs. trap_Alloc is not visible in the patch, leaving a gap in understanding why this mitigates the issue.",
    "need_context": true,
    "required_context": [
        "function: G_Alloc",
        "function: trap_Alloc"
    ],
    "root_cause": "Spamming team commands triggers repeated allocations via G_Alloc (code/game/ai_cast_script.c:519, 592, 624, 392), exhausting a fixed-size memory pool (POOLSIZE). Replacing G_Alloc with trap_Alloc mitigates this, but the underlying difference in memory management between these allocators is not evident from the patch. GAP: Implementation details of G_Alloc and trap_Alloc are missing.",
    "confidence_score": 0.75
}
 10:14:52 PM - [INFO]: http://localhost:2002 Joern service is available
 10:14:52 PM - [INFO]: [Initial analysis response] 
{
    "language": "cpp",
    "vulnerability_type": "memory",
    "repair_strategy": "In 'calls_crt1', added null checks for 'dynsym' and 'dynstr' (src/p_lx_elf.cpp:1667+8) to prevent invalid memory dereference. In 'check_pt_dynamic', added page alignment check for PT_DYNAMIC segment (src/p_lx_elf.cpp:4343+11) to reject malformed segments.",
    "analysis": "The double free vulnerability likely arises from improper validation of PT_DYNAMIC segment alignment and symbol table pointers. The patches add checks to prevent processing invalid or unaligned PT_DYNAMIC data and ensure symbol tables are valid before dereferencing. However, the full chain from unpack() to these functions is not visible in the provided patch.",
    "need_context": true,
    "required_context": [
        "function: PackLinuxElf64::unpack",
        "caller: PackLinuxElf64::check_pt_dynamic",
        "caller: PackLinuxElf64::calls_crt1"
    ],
    "root_cause": "Root cause involves improper validation of PT_DYNAMIC segment alignment and symbol table pointers in 'check_pt_dynamic' (src/p_lx_elf.cpp:4343) and 'calls_crt1' (src/p_lx_elf.cpp:1667). Malformed PT_DYNAMIC data could lead to invalid memory operations in 'unpack'. GAP: Missing 'unpack' implementation and caller context to trace the full data flow.",
    "confidence_score": 0.75
}
 10:14:52 PM - [INFO]: http://localhost:2001 Joern service is available
 10:14:55 PM - [INFO]: http://localhost:2001 init new project
 10:14:55 PM - [INFO]: http://localhost:2000 init new project
 10:14:56 PM - [INFO]: http://localhost:2002 init new project
 10:14:58 PM - [INFO]: http://localhost:2001: Context actor work for /storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f with id 0ce3f3b8a29e26f10c30bffeaba84f87
 10:14:59 PM - [INFO]: http://localhost:2000: Context actor work for /storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec with id fb942f96fe2adf2a33e5c92db4241000
 10:14:59 PM - [INFO]: http://localhost:2002: Context actor work for /storage/result/Part2_result/github/CVE-2019-25104/old_repos/rtcwcoop-rtcwcoop_39bcb1c with id 0bb98005c842c43d03ac360584a67e65
 10:15:09 PM - [INFO]: Tools query: [{'tool': 'caller_info.find_caller_for_func', 'params': {'func_name': 'gf_media_split_hevc_tiles'}}, {'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'gf_isom_get_sample'}}]
 10:15:10 PM - [INFO]: Executing tool: caller_info.find_caller_for_func({'func_name': 'gf_media_split_hevc_tiles', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:15:10 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 1912, 'call_code': 'gf_media_split_hevc_tiles(dest, split_tile_mode - 1)', 'caller_code': 'GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, GF_Fraction force_fps, u32 frames_per_sample, GF_FilterSession *fsess, char **mux_args_if_first_pass, char **mux_sid_if_first_pass, u32 tk_idx)\n{\n\tu32 track_id, i, j, timescale, track, stype, profile, compat, level, new_timescale, rescale_num, rescale_den, svc_mode, txt_flags, split_tile_mode, temporal_mode, nb_tracks;\n\ts32 par_d, par_n, prog_id, force_rate, moov_timescale;\n\ts32 tw, th, tx, ty, tz, txtw, txth, txtx, txty;\n\tBool do_audio, do_video, do_auxv,do_pict, do_all, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, rap_only, refs_only, force_par, rewrite_bs;\n\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc, do_disable;\n\tconst char *szLan;\n\tGF_Err e = GF_OK;\n\tGF_Fraction delay;\n\tu32 tmcd_track = 0, neg_ctts_mode=0;\n\tBool keep_audelim = GF_FALSE;\n\tu32 print_stats_graph=fs_dump_flags;\n\tGF_MediaImporter import;\n\tchar *ext, *final_name=NULL, *handler_name, *rvc_config, *chapter_name;\n\tGF_List *kinds;\n\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\n\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\n\tu32 clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod;\n\tBool has_clap=GF_FALSE;\n\tBool use_stz2=GF_FALSE;\n\tBool has_mx=GF_FALSE;\n\ts32 mx[9];\n\tu32 bitdepth=0;\n\tchar dv_profile[100]; /*Dolby Vision*/\n\tu32 clr_type=0;\n\tu32 clr_prim;\n\tu32 clr_tranf;\n\tu32 clr_mx;\n\tBool rescale_override=GF_FALSE;\n\tBool clr_full_range=GF_FALSE;\n\tBool fmt_ok = GF_TRUE;\n\tu32 icc_size=0, track_flags=0;\n\tu8 *icc_data = NULL;\n\tu32 tc_fps_num=0, tc_fps_den=0, tc_h=0, tc_m=0, tc_s=0, tc_f=0, tc_frames_per_tick=0;\n\tBool tc_force_counter=GF_FALSE;\n\tBool tc_drop_frame = GF_FALSE;\n\tchar *ext_start;\n\tu32 xps_inband=0;\n\tu64 source_magic=0;\n\tchar *opt_src = NULL;\n\tchar *opt_dst = NULL;\n\tchar *fchain = NULL;\n\tchar *edits = NULL;\n\tconst char *fail_msg = NULL;\n\tchar *hdr_file=NULL;\n\tBool set_ccst=GF_FALSE;\n\tBool has_last_sample_dur=GF_FALSE;\n\tu32 fake_import = 0;\n\tGF_Fraction last_sample_dur = {0,0};\n\ts32 fullrange, videofmt, colorprim, colortfc, colormx;\n\tclap_wn = clap_wd = clap_hn = clap_hd = clap_hon = clap_hod = clap_von = clap_vod = 0;\n\tGF_ISOMTrackFlagOp track_flags_mode=0;\n\tu32 roll_change=0;\n\ts32 roll = 0;\n\tBool src_is_isom = GF_FALSE;\n\ts32 dlb_mode = -2;\n\n\tdv_profile[0] = 0;\n\trvc_predefined = 0;\n\tchapter_name = NULL;\n\tnew_timescale = 1;\n\tmoov_timescale = 0;\n\trescale_num = rescale_den = 0;\n\ttext_layout = 0;\n\t/*0: merge all\n\t  1: split base and all SVC in two tracks\n\t  2: split all base and SVC layers in dedicated tracks\n\t */\n\tsvc_mode = 0;\n\n\tif (import_flags==0xFFFFFFFF) {\n\t\timport_flags = 0;\n\t\tfake_import = 1;\n\t}\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\n\tfinal_name = gf_strdup(inName);\n#ifdef WIN32\n\t/*dirty hack for msys&mingw: when we use import options, the \':\' separator used prevents msys from translating the path\n\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we\'re screwed :( */\n\tif ( (final_name[0]==\'/\') && (final_name[2]==\'/\')) {\n\t\tfinal_name[0] = final_name[1];\n\t\tfinal_name[1] = \':\';\n\t}\n#endif\n\n\tis_chap_file = 0;\n\thandler = 0;\n\tdo_disable = 0;\n\tchap_ref = 0;\n\tis_chap = 0;\n\tkinds = gf_list_new();\n\ttrack_layout = 0;\n\tszLan = NULL;\n\tdelay.num = delay.den = 0;\n\tgroup = 0;\n\tstype = 0;\n\tprofile = compat = level = 0;\n\tfullrange = videofmt = colorprim = colortfc = colormx = -1;\n\tsplit_tile_mode = 0;\n\ttemporal_mode = 0;\n\trap_only = 0;\n\trefs_only = 0;\n\ttxt_flags = 0;\n\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\n\tforce_rate = -1;\n\n\ttw = th = tx = ty = tz = txtw = txth = txtx = txty = 0;\n\tpar_d = par_n = -1;\n\tforce_par = rewrite_bs = GF_FALSE;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, \'#\');\n\tif (!ext) ext = gf_url_colon_suffix(final_name, \'=\');\n\tchar c_sep = ext ? ext[0] : 0;\n\tif (ext) ext[0] = 0;\n \tif (!strlen(final_name) || !strcmp(final_name, "self")) {\n\t\tfake_import = 2;\n\t\tsrc_is_isom = GF_TRUE;\n\t}\n\tchar *frag = strrchr(final_name, \'#\');\n\tif (frag) frag[0] = 0;\n\tif (gf_isom_probe_file(final_name))\n\t\tsrc_is_isom = GF_TRUE;\n\tif (frag) frag[0] = \'#\';\n\n\tif (ext) ext[0] = c_sep;\n\n\text = gf_url_colon_suffix(final_name, \'=\');\n\n#define GOTO_EXIT(_msg) if (e) { fail_msg = _msg; goto exit; }\n\n#define CHECK_FAKEIMPORT(_opt) if (fake_import) { M4_LOG(GF_LOG_ERROR, ("Option %s not available for self-reference import\\n", _opt)); e = GF_BAD_PARAM; goto exit; }\n#define CHECK_FAKEIMPORT_2(_opt) if (fake_import==1) { M4_LOG(GF_LOG_ERROR, ("Option %s not available for self-reference import\\n", _opt)); e = GF_BAD_PARAM; goto exit; }\n\n\n\thandler_name = NULL;\n\trvc_config = NULL;\n\twhile (ext) {\n\t\tchar *ext2 = gf_url_colon_suffix(ext+1, \'=\');\n\n\t\tif (ext2) ext2[0] = 0;\n\n\t\t/*all extensions for track-based importing*/\n\t\tif (!strnicmp(ext+1, "dur=", 4)) {\n\t\t\tCHECK_FAKEIMPORT("dur")\n\n\t\t\tif (strchr(ext, \'-\')) {\n\t\t\t\timport.duration.num = parse_s32(ext+5, "dur");\n\t\t\t\timport.duration.den = 1;\n\t\t\t} else {\n\t\t\t\tgf_parse_frac(ext+5, &import.duration);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "start=", 6)) {\n\t\t\tCHECK_FAKEIMPORT("start")\n\t\t\timport.start_time = atof(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "lang=", 5)) {\n\t\t\t/* prevent leak if param is set twice */\n\t\t\tif (szLan)\n\t\t\t\tgf_free((char*) szLan);\n\n\t\t\tszLan = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "delay=", 6)) {\n\t\t\tif (sscanf(ext+7, "%d/%u", &delay.num, &delay.den)!=2) {\n\t\t\t\tdelay.num = parse_s32(ext+7, "delay");\n\t\t\t\tdelay.den = 1000; //in ms\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "par=", 4)) {\n\t\t\tif (!stricmp(ext + 5, "none")) {\n\t\t\t\tpar_n = par_d = 0;\n\t\t\t} else if (!stricmp(ext + 5, "auto")) {\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else if (!stricmp(ext + 5, "force")) {\n\t\t\t\tpar_n = par_d = 1;\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (ext2) {\n\t\t\t\t\text2[0] = \':\';\n\t\t\t\t\text2 = strchr(ext2+1, \':\');\n\t\t\t\t\tif (ext2) ext2[0] = 0;\n\t\t\t\t}\n\t\t\t\tif (ext[5]==\'w\') {\n\t\t\t\t\trewrite_bs = GF_TRUE;\n\t\t\t\t\tif (sscanf(ext+6, "%d:%d", &par_n, &par_d)!=2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized syntax for par=, expecting N:D got %s\\n", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (sscanf(ext+5, "%d:%d", &par_n, &par_d) != 2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized syntax for par=, expecting N:D got %s\\n", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "clap=", 5)) {\n\t\t\tif (!stricmp(ext+6, "none")) {\n\t\t\t\thas_clap=GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (sscanf(ext+6, "%d,%d,%d,%d,%d,%d,%d,%d", &clap_wn, &clap_wd, &clap_hn, &clap_hd, &clap_hon, &clap_hod, &clap_von, &clap_vod)==8) {\n\t\t\t\t\thas_clap=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "mx=", 3)) {\n\t\t\tif (strstr(ext+4, "0x")) {\n\t\t\t\tif (sscanf(ext+4, "0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%d", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\t\thas_mx=GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (sscanf(ext+4, "%d,%d,%d,%d,%d,%d,%d,%d,%d", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\thas_mx=GF_TRUE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "name=", 5)) {\n\t\t\thandler_name = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "ext=", 4)) {\n\t\t\tCHECK_FAKEIMPORT("ext")\n\t\t\t/*extensions begin with \'.\'*/\n\t\t\tif (*(ext+5) == \'.\')\n\t\t\t\timport.force_ext = gf_strdup(ext+5);\n\t\t\telse {\n\t\t\t\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\n\t\t\t\timport.force_ext[0] = \'.\';\n\t\t\t\tstrcat(import.force_ext+1, ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "hdlr=", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\n\t\telse if (!strnicmp(ext+1, "stype=", 6)) stype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\n\t\telse if (!strnicmp(ext+1, "tkhd", 4)) {\n\t\t\tchar *flags = ext+6;\n\t\t\tif (flags[0]==\'+\') { track_flags_mode = GF_ISOM_TKFLAGS_ADD; flags += 1; }\n\t\t\telse if (flags[0]==\'-\') { track_flags_mode = GF_ISOM_TKFLAGS_REM; flags += 1; }\n\t\t\telse track_flags_mode = GF_ISOM_TKFLAGS_SET;\n\n\t\t\tif (strstr(flags, "enable")) track_flags |= GF_ISOM_TK_ENABLED;\n\t\t\tif (strstr(flags, "movie")) track_flags |= GF_ISOM_TK_IN_MOVIE;\n\t\t\tif (strstr(flags, "preview")) track_flags |= GF_ISOM_TK_IN_PREVIEW;\n\t\t\tif (strstr(flags, "size_ar")) track_flags |= GF_ISOM_TK_SIZE_IS_AR;\n\t\t\tif (!track_flags) {\n\t\t\t\tif (!strnicmp(flags, "0x", 2)) flags += 2;\n\t\t\t\tsscanf(flags, "%X", &track_flags);\n\t\t\t}\n\t\t} else if (!strnicmp(ext+1, "disable", 7)) {\n\t\t\tdo_disable = !stricmp(ext+1, "disable=no") ? 2 : 1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "group=", 6)) {\n\t\t\tgroup = parse_u32(ext+7, "group");\n\t\t\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "fps=", 4)) {\n\t\t\tu32 ticks, dts_inc;\n\t\t\tif (!strcmp(ext+5, "auto")) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning, fps=auto option is deprecated\\n"));\n\t\t\t} else if ((sscanf(ext+5, "%u-%u", &ticks, &dts_inc) == 2) || (sscanf(ext+5, "%u/%u", &ticks, &dts_inc) == 2)) {\n\t\t\t\tif (!dts_inc) dts_inc=1;\n\t\t\t\tforce_fps.num = ticks;\n\t\t\t\tforce_fps.den = dts_inc;\n\t\t\t} else {\n\t\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\t\tforce_fps.den = 1000;\n\t\t\t\t\tforce_fps.num = (u32) (atof(ext+5) * force_fps.den);\n\t\t\t\t} else {\n\t\t\t\t\tgf_parse_frac(ext+5, &force_fps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, "rap")) rap_only = 1;\n\t\telse if (!stricmp(ext+1, "refs")) refs_only = 1;\n\t\telse if (!stricmp(ext+1, "trailing")) { CHECK_FAKEIMPORT("trailing") import_flags |= GF_IMPORT_KEEP_TRAILING; }\n\t\telse if (!strnicmp(ext+1, "agg=", 4)) { CHECK_FAKEIMPORT("agg") frames_per_sample = parse_u32(ext+5, "agg"); }\n\t\telse if (!stricmp(ext+1, "dref")) { CHECK_FAKEIMPORT("dref")  import_flags |= GF_IMPORT_USE_DATAREF; }\n\t\telse if (!stricmp(ext+1, "keep_refs")) { CHECK_FAKEIMPORT("keep_refs") import_flags |= GF_IMPORT_KEEP_REFS; }\n\t\telse if (!stricmp(ext+1, "nodrop")) { CHECK_FAKEIMPORT("nodrop") import_flags |= GF_IMPORT_NO_FRAME_DROP; }\n\t\telse if (!stricmp(ext+1, "packed")) { CHECK_FAKEIMPORT("packed") import_flags |= GF_IMPORT_FORCE_PACKED; }\n\t\telse if (!stricmp(ext+1, "sbr")) { CHECK_FAKEIMPORT("sbr") import_flags |= GF_IMPORT_SBR_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, "sbrx")) { CHECK_FAKEIMPORT("sbrx") import_flags |= GF_IMPORT_SBR_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, "ovsbr")) { CHECK_FAKEIMPORT("ovsbr") import_flags |= GF_IMPORT_OVSBR; }\n\t\telse if (!stricmp(ext+1, "ps")) { CHECK_FAKEIMPORT("ps") import_flags |= GF_IMPORT_PS_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, "psx")) { CHECK_FAKEIMPORT("psx") import_flags |= GF_IMPORT_PS_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, "mpeg4")) { CHECK_FAKEIMPORT("mpeg4") import_flags |= GF_IMPORT_FORCE_MPEG4; }\n\t\telse if (!stricmp(ext+1, "nosei")) { CHECK_FAKEIMPORT("nosei") import_flags |= GF_IMPORT_NO_SEI; }\n\t\telse if (!stricmp(ext+1, "svc") || !stricmp(ext+1, "lhvc") ) { CHECK_FAKEIMPORT("svc/lhvc") import_flags |= GF_IMPORT_SVC_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, "nosvc") || !stricmp(ext+1, "nolhvc")) { CHECK_FAKEIMPORT("nosvc/nolhvc") import_flags |= GF_IMPORT_SVC_NONE; }\n\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, "svcmode=", 8) || !strnicmp(ext+1, "lhvcmode=", 9)) {\n\t\t\tchar *mode = ext+9;\n\t\t\tCHECK_FAKEIMPORT_2("svcmode/lhvcmode")\n\t\t\tif (mode[0]==\'=\') mode = ext+10;\n\n\t\t\tif (!stricmp(mode, "splitnox"))\n\t\t\t\tsvc_mode = 3;\n\t\t\telse if (!stricmp(mode, "splitnoxib"))\n\t\t\t\tsvc_mode = 4;\n\t\t\telse if (!stricmp(mode, "splitall") || !stricmp(mode, "split"))\n\t\t\t\tsvc_mode = 2;\n\t\t\telse if (!stricmp(mode, "splitbase"))\n\t\t\t\tsvc_mode = 1;\n\t\t\telse if (!stricmp(mode, "merged") || !stricmp(mode, "merge"))\n\t\t\t\tsvc_mode = 0;\n\t\t}\n\t\t/*split SHVC temporal sublayers*/\n\t\telse if (!strnicmp(ext+1, "temporal=", 9)) {\n\t\t\tchar *mode = ext+10;\n\t\t\tCHECK_FAKEIMPORT_2("svcmode/lhvcmode")\n\t\t\tif (!stricmp(mode, "split"))\n\t\t\t\ttemporal_mode = 2;\n\t\t\telse if (!stricmp(mode, "splitnox"))\n\t\t\t\ttemporal_mode = 3;\n\t\t\telse if (!stricmp(mode, "splitbase"))\n\t\t\t\ttemporal_mode = 1;\n\t\t\telse {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized temporal mode %s, ignoring\\n", mode));\n\t\t\t\ttemporal_mode = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, "subsamples")) { CHECK_FAKEIMPORT("subsamples") import_flags |= GF_IMPORT_SET_SUBSAMPLES; }\n\t\telse if (!stricmp(ext+1, "deps")) { CHECK_FAKEIMPORT("deps") import_flags |= GF_IMPORT_SAMPLE_DEPS; }\n\t\telse if (!stricmp(ext+1, "ccst")) { CHECK_FAKEIMPORT("ccst") set_ccst = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, "alpha")) { CHECK_FAKEIMPORT("alpha") import.is_alpha = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, "forcesync")) { CHECK_FAKEIMPORT("forcesync") import_flags |= GF_IMPORT_FORCE_SYNC; }\n\t\telse if (!stricmp(ext+1, "xps_inband")) { CHECK_FAKEIMPORT("xps_inband") xps_inband = 1; }\n\t\telse if (!stricmp(ext+1, "xps_inbandx")) { CHECK_FAKEIMPORT("xps_inbandx") xps_inband = 2; }\n\t\telse if (!stricmp(ext+1, "au_delim")) { CHECK_FAKEIMPORT("au_delim") keep_audelim = GF_TRUE; }\n\t\telse if (!strnicmp(ext+1, "max_lid=", 8) || !strnicmp(ext+1, "max_tid=", 8)) {\n\t\t\ts32 val = parse_u32(ext+9, "Max TID/LID");\n\t\t\tCHECK_FAKEIMPORT_2("max_lid/lhvcmode")\n\t\t\tif (val < 0) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning: request max layer/temporal id is negative - ignoring\\n"));\n\t\t\t} else {\n\t\t\t\tif (!strnicmp(ext+1, "max_lid=", 8))\n\t\t\t\t\tmax_layer_id_plus_one = 1 + (u8) val;\n\t\t\t\telse\n\t\t\t\t\tmax_temporal_id_plus_one = 1 + (u8) val;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, "tiles")) { CHECK_FAKEIMPORT_2("tiles") split_tile_mode = 2; }\n\t\telse if (!stricmp(ext+1, "tiles_rle")) { CHECK_FAKEIMPORT_2("tiles_rle") split_tile_mode = 3; }\n\t\telse if (!stricmp(ext+1, "split_tiles")) { CHECK_FAKEIMPORT_2("split_tiles") split_tile_mode = 1; }\n\n\t\t/*force all composition offsets to be positive*/\n\t\telse if (!strnicmp(ext+1, "negctts", 7)) {\n\t\t\tneg_ctts_mode = !strnicmp(ext+1, "negctts=no", 10) ? 2 : 1;\n\t\t}\n\t\telse if (!stricmp(ext+1, "chap")) is_chap = 1;\n\t\telse if (!strnicmp(ext+1, "chapter=", 8)) {\n\t\t\tchapter_name = gf_strdup(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "chapfile=", 9)) {\n\t\t\tchapter_name = gf_strdup(ext+10);\n\t\t\tis_chap_file=1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "layout=", 7)) {\n\t\t\ttrack_layout = 1;\n\t\t\tif ( sscanf(ext+13, "%dx%dx%dx%dx%d", &tw, &th, &tx, &ty, &tz)==5) {\n\t\t\t} else if ( sscanf(ext+13, "%dx%dx%dx%d", &tw, &th, &tx, &ty)==4) {\n\t\t\t\ttz = 0;\n\t\t\t} else if ( sscanf(ext+13, "%dx%dx%d", &tw, &th, &tz)==3) {\n\t\t\t\ttx = ty = 0;\n\t\t\t} else if ( sscanf(ext+8, "%dx%d", &tw, &th)==2) {\n\t\t\t\ttx = ty = tz = 0;\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, "rescale=", 8)) {\n\t\t\tif (sscanf(ext+9, "%u/%u", &rescale_num, &rescale_den) != 2) {\n\t\t\t\trescale_num = parse_u32(ext+9, "rescale");\n\t\t\t\trescale_den = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "sampdur=", 8)) {\n\t\t\tif (sscanf(ext+9, "%u/%u", &rescale_den, &rescale_num) != 2) {\n\t\t\t\trescale_den = parse_u32(ext+9, "sampdur");\n\t\t\t\trescale_num = 0;\n\t\t\t}\n\t\t\trescale_override = GF_TRUE;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "timescale=", 10)) {\n\t\t\tnew_timescale = parse_u32(ext+11, "timescale");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "moovts=", 7)) {\n\t\t\tmoov_timescale = parse_u32(ext+8, "moovts");\n\t\t}\n\n\t\telse if (!stricmp(ext+1, "noedit")) { import_flags |= GF_IMPORT_NO_EDIT_LIST; }\n\n\n\t\telse if (!strnicmp(ext+1, "rvc=", 4)) {\n\t\t\tif (sscanf(ext+5, "%d", &rvc_predefined) != 1) {\n\t\t\t\trvc_config = gf_strdup(ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "fmt=", 4)) import.streamFormat = gf_strdup(ext+5);\n\n\t\telse if (!strnicmp(ext+1, "profile=", 8)) {\n\t\t\tif (!stricmp(ext+9, "high444")) profile = 244;\n\t\t\telse if (!stricmp(ext+9, "high")) profile = 100;\n\t\t\telse if (!stricmp(ext+9, "extended")) profile = 88;\n\t\t\telse if (!stricmp(ext+9, "main")) profile = 77;\n\t\t\telse if (!stricmp(ext+9, "baseline")) profile = 66;\n\t\t\telse profile = parse_u32(ext+9, "profile");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "level=", 6)) {\n\t\t\tif( atof(ext+7) < 6 )\n\t\t\t\tlevel = (int)(10*atof(ext+7)+.5);\n\t\t\telse\n\t\t\t\tlevel = parse_u32(ext+7, "level");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "compat=", 7)) {\n\t\t\tcompat = parse_u32(ext+8, "compat");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "dlba=", 5)) {\n\t\t\tif (!strcmp(ext+6, "no")) dlb_mode=0;\n\t\t\telse if (!strcmp(ext+6, "auto")) dlb_mode=-1;\n\t\t\telse if (sscanf(ext+6, "%d", &dlb_mode) != 1) {\n\t\t\t\tGOTO_EXIT("Unrecognized dolby atmos mode")\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, "novpsext", 8)) { CHECK_FAKEIMPORT("novpsext") import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS; }\n\t\telse if (!strnicmp(ext+1, "keepav1t", 8)) { CHECK_FAKEIMPORT("keepav1t") import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU; }\n\n\t\telse if (!strnicmp(ext+1, "font=", 5)) { CHECK_FAKEIMPORT("font") import.fontName = gf_strdup(ext+6); }\n\t\telse if (!strnicmp(ext+1, "size=", 5)) { CHECK_FAKEIMPORT("size") import.fontSize = parse_u32(ext+6, "size"); }\n\t\telse if (!strnicmp(ext+1, "text_layout=", 12)) {\n\t\t\tif ( sscanf(ext+13, "%dx%dx%dx%d", &txtw, &txth, &txtx, &txty)==4) {\n\t\t\t\ttext_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, "%dx%d", &txtw, &txth)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttxtx = txty = 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\telse if (!stricmp(ext+1, "swf-global")) { CHECK_FAKEIMPORT("swf-global") import.swf_flags |= GF_SM_SWF_STATIC_DICT; }\n\t\telse if (!stricmp(ext+1, "swf-no-ctrl")) { CHECK_FAKEIMPORT("swf-no-ctrl") import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE; }\n\t\telse if (!stricmp(ext+1, "swf-no-text")) { CHECK_FAKEIMPORT("swf-no-text") import.swf_flags |= GF_SM_SWF_NO_TEXT; }\n\t\telse if (!stricmp(ext+1, "swf-no-font")) { CHECK_FAKEIMPORT("swf-no-font") import.swf_flags |= GF_SM_SWF_NO_FONT; }\n\t\telse if (!stricmp(ext+1, "swf-no-line")) { CHECK_FAKEIMPORT("swf-no-line") import.swf_flags |= GF_SM_SWF_NO_LINE; }\n\t\telse if (!stricmp(ext+1, "swf-no-grad")) { CHECK_FAKEIMPORT("swf-no-grad") import.swf_flags |= GF_SM_SWF_NO_GRADIENT; }\n\t\telse if (!stricmp(ext+1, "swf-quad")) { CHECK_FAKEIMPORT("swf-quad") import.swf_flags |= GF_SM_SWF_QUAD_CURVE; }\n\t\telse if (!stricmp(ext+1, "swf-xlp")) { CHECK_FAKEIMPORT("swf-xlp") import.swf_flags |= GF_SM_SWF_SCALABLE_LINE; }\n\t\telse if (!stricmp(ext+1, "swf-ic2d")) { CHECK_FAKEIMPORT("swf-ic2d") import.swf_flags |= GF_SM_SWF_USE_IC2D; }\n\t\telse if (!stricmp(ext+1, "swf-same-app")) { CHECK_FAKEIMPORT("swf-same-app") import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE; }\n\t\telse if (!strnicmp(ext+1, "swf-flatten=", 12)) { CHECK_FAKEIMPORT("swf-flatten") import.swf_flatten_angle = (Float) atof(ext+13); }\n#endif\n\n\t\telse if (!strnicmp(ext+1, "kind=", 5)) {\n\t\t\tchar *kind_scheme, *kind_value;\n\t\t\tchar *kind_data = ext+6;\n\t\t\tchar *sep = strchr(kind_data, \'=\');\n\t\t\tif (sep) {\n\t\t\t\t*sep = 0;\n\t\t\t}\n\t\t\tkind_scheme = gf_strdup(kind_data);\n\t\t\tif (sep) {\n\t\t\t\t*sep = \'=\';\n\t\t\t\tkind_value = gf_strdup(sep+1);\n\t\t\t} else {\n\t\t\t\tkind_value = NULL;\n\t\t\t}\n\t\t\tgf_list_add(kinds, kind_scheme);\n\t\t\tgf_list_add(kinds, kind_value);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "txtflags", 8)) {\n\t\t\tif (!strnicmp(ext+1, "txtflags=", 9)) {\n\t\t\t\tsscanf(ext+10, "%x", &txt_flags);\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, "txtflags+=", 10)) {\n\t\t\t\tsscanf(ext+11, "%x", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, "txtflags-=", 10)) {\n\t\t\t\tsscanf(ext+11, "%x", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "rate=", 5)) {\n\t\t\tforce_rate = parse_s32(ext+6, "rate");\n\t\t}\n\t\telse if (!stricmp(ext+1, "stats") || !stricmp(ext+1, "fstat"))\n\t\t\tprint_stats_graph |= 1;\n\t\telse if (!stricmp(ext+1, "graph") || !stricmp(ext+1, "graph"))\n\t\t\tprint_stats_graph |= 2;\n\t\telse if (!strncmp(ext+1, "sopt", 4) || !strncmp(ext+1, "dopt", 4) || !strncmp(ext+1, "@", 1)) {\n\t\t\tif (ext2) ext2[0] = \':\';\n\t\t\topt_src = strstr(ext, ":sopt:");\n\t\t\topt_dst = strstr(ext, ":dopt:");\n\t\t\tfchain = strstr(ext, ":@");\n\t\t\tif (opt_src) opt_src[0] = 0;\n\t\t\tif (opt_dst) opt_dst[0] = 0;\n\t\t\tif (fchain) fchain[0] = 0;\n\n\t\t\tif (opt_src) import.filter_src_opts = opt_src+6;\n\t\t\tif (opt_dst) import.filter_dst_opts = opt_dst+6;\n\t\t\tif (fchain) {\n\t\t\t\t//check for old syntax (0.9->1.0) :@@\n\t\t\t\tif (fchain[2]==\'@\') {\n\t\t\t\t\timport.filter_chain = fchain + 3;\n\t\t\t\t\timport.is_chain_old_syntax = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\timport.filter_chain = fchain + 2;\n\t\t\t\t\timport.is_chain_old_syntax = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\text = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, "asemode=", 8)){\n\t\t\tchar *mode = ext+9;\n\t\t\tif (!stricmp(mode, "v0-bs"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\n\t\t\telse if (!stricmp(mode, "v0-2"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\n\t\t\telse if (!stricmp(mode, "v1"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\n\t\t\telse if (!stricmp(mode, "v1-qt"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\telse\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized audio sample entry mode %s, ignoring\\n", mode));\n\t\t}\n\t\telse if (!strnicmp(ext+1, "audio_roll=", 11)) { roll_change = 3; roll = parse_s32(ext+12, "audio_roll"); }\n\t\telse if (!strnicmp(ext+1, "roll=", 5)) { roll_change = 1; roll = parse_s32(ext+6, "roll"); }\n\t\telse if (!strnicmp(ext+1, "proll=", 6)) { roll_change = 2; roll = parse_s32(ext+7, "proll"); }\n\t\telse if (!strcmp(ext+1, "stz2")) {\n\t\t\tuse_stz2 = GF_TRUE;\n\t\t} else if (!strnicmp(ext+1, "bitdepth=", 9)) {\n\t\t\tbitdepth = parse_u32(ext+10, "bitdepth");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "hdr=", 4)) {\n\t\t\thdr_file = gf_strdup(ext+5);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colr=", 5)) {\n\t\t\tchar *cval = ext+6;\n\t\t\tif (!strcmp(cval, "none")) {\n\t\t\t\tclr_type = (u32) -1;\n\t\t\t} else if (strlen(cval)<6) {\n\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tclr_type = GF_4CC(cval[0],cval[1],cval[2],cval[3]);\n\t\t\t\tcval+=4;\n\t\t\t\tif (cval[0] != \',\') {\n\t\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_NCLX) || (clr_type==GF_ISOM_SUBTYPE_NCLC)) {\n\t\t\t\t\tfmt_ok = scan_color(cval+1, &clr_prim, &clr_tranf, &clr_mx, &clr_full_range);\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_RICC) || (clr_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\t\t\t\tFILE *f = gf_fopen(cval+1, "rb");\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Failed to open file %s\\n", cval+1));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_END);\n\t\t\t\t\t\ticc_size = (u32) gf_ftell(f);\n\t\t\t\t\t\ticc_data = gf_malloc(sizeof(char)*icc_size);\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_SET);\n\t\t\t\t\t\ticc_size = (u32) gf_fread(icc_data, icc_size, f);\n\t\t\t\t\t\tgf_fclose(f);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized colr profile %s\\n", gf_4cc_to_str(clr_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fmt_ok) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("parsing colr option");\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext + 1, "dvp=", 4)) {\n\t\t\tstrncpy(dv_profile, ext + 5, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\t//old name\n\t\telse if (!strnicmp(ext + 1, "dv-profile=", 11)) {\n\t\t\tM4_LOG(GF_LOG_WARNING, ("Deprecated option name, use `:dvp=` instead\\n"));\n\t\t\tstrncpy(dv_profile, ext + 12, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "fullrange=", 10)) {\n\t\t\tif (!stricmp(ext+11, "off") || !stricmp(ext+11, "no")) fullrange = 0;\n\t\t\telse if (!stricmp(ext+11, "on") || !stricmp(ext+11, "yes")) fullrange = 1;\n\t\t\telse {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for fullrange")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "videofmt=", 10)) {\n\t\t\tu32 idx, count = GF_ARRAY_LENGTH(videofmt_names);\n\t\t\tfor (idx=0; idx<count; idx++) {\n\t\t\t\tif (!strcmp(ext+11, videofmt_names[idx])) {\n\t\t\t\t\tvideofmt = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (videofmt==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for videofmt")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colorprim=", 10)) {\n\t\t\tcolorprim = gf_cicp_parse_color_primaries(ext+11);\n\t\t\tif (colorprim==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for colorprim")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colortfc=", 9)) {\n\t\t\tcolortfc = gf_cicp_parse_color_transfer(ext+10);\n\t\t\tif (colortfc==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for colortfc")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colormx=", 10)) {\n\t\t\tcolormx = gf_cicp_parse_color_matrix(ext+11);\n\t\t\tif (colormx==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for colormx")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "tc=", 3)) {\n\t\t\tchar *tc_str = ext+4;\n\t\t\t\n\t\t\tif (tc_str[0] == \'d\') {\n\t\t\t\ttc_drop_frame=GF_TRUE;\n\t\t\t\ttc_str+=1;\n\t\t\t}\n\t\t\tif (sscanf(tc_str, "%d/%d,%d,%d,%d,%d,%d", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 7) {\n\t\t\t} else if (sscanf(tc_str, "%d/%d,%d,%d,%d,%d", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f) == 6) {\n\t\t\t} else if (sscanf(tc_str, "%d,%d,%d,%d,%d,%d", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 6) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, "%d,%d,%d,%d,%d", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f) == 5) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, "%d/%d,%d,%d", &tc_fps_num, &tc_fps_den, &tc_f, &tc_frames_per_tick) == 4) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, "%d/%d,%d", &tc_fps_num, &tc_fps_den, &tc_f) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, "%d,%d,%d", &tc_fps_num, &tc_f, &tc_frames_per_tick) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, "%d,%d", &tc_fps_num, &tc_f) == 2) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Bad format %s for timecode, ignoring\\n", ext+1));\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "edits=", 6)) {\n\t\t\tedits = gf_strdup(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "lastsampdur", 11)) {\n\t\t\thas_last_sample_dur = GF_TRUE;\n\t\t\tif (!strnicmp(ext+1, "lastsampdur=", 12)) {\n\t\t\t\tif (sscanf(ext+13, "%d/%u", &last_sample_dur.num, &last_sample_dur.den)==2) {\n\t\t\t\t} else {\n\t\t\t\t\tlast_sample_dur.num = parse_s32(ext+13, "lastsampdur");\n\t\t\t\t\tlast_sample_dur.den = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "ID=", 3)) {\n\t\t\timport.target_trackID = (u32) parse_u32(ext+4, "ID");\n\t\t}\n\t\t/*unrecognized, assume name has colon in it*/\n\t\telse {\n\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized import option %s, ignoring\\n", ext+1));\n\t\t\tif (ext2) ext2[0] = \':\';\n\t\t\text = ext2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (src_is_isom) {\n\t\t\tchar *opt = ext+1;\n\t\t\tchar *sep_eq = strchr(opt, \'=\');\n\t\t\tif (sep_eq) sep_eq[0] = 0;\n\t\t\tif (!mp4box_check_isom_fileopt(opt)) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("\\t! Import option `%s` not available for ISOBMFF/QT sources, ignoring !\\n", ext+1));\n\t\t\t}\n\t\t\tif (sep_eq) sep_eq[0] = \'=\';\n\t\t}\n\n\t\tif (ext2) ext2[0] = \':\';\n\n\t\text[0] = 0;\n\n\t\t/* restart from where we stopped\n\t\t * if we didn\'t stop (ext2 null) then the end has been reached\n\t\t * so we can stop the whole thing */\n\t\text = ext2;\n\t}\n\n\t/*check duration import (old syntax)*/\n\text = strrchr(final_name, \'%\');\n\tif (ext) {\n\t\tgf_parse_frac(ext+1, &import.duration);\n\t\text[0] = 0;\n\t}\n\n\t/*select switches for av containers import*/\n\tdo_audio = do_video = do_auxv = do_pict = 0;\n\ttrack_id = prog_id = 0;\n\tdo_all = 1;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, \'#\');\n\tif (ext) ext[0] = 0;\n\n\tif (fake_import && ext) {\n\t\text++;\n\t\tif (!strnicmp(ext, "audio", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, "video", 5)) do_video = 1;\n\t\telse if (!strnicmp(ext, "auxv", 4)) do_auxv = 1;\n\t\telse if (!strnicmp(ext, "pict", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, "trackID=", 8)) track_id = parse_u32(&ext[8], "trackID");\n\t\telse track_id = parse_u32(ext, "ID");\n\t}\n\telse if (ext) {\n\t\text++;\n\t\tchar *sep = gf_url_colon_suffix(ext, \'=\');\n\t\tif (sep) sep[0] = 0;\n\n\t\t//we have a fragment, we need to check if the track or the program is present in source\n\t\timport.in_name = final_name;\n\t\timport.flags = GF_IMPORT_PROBE_ONLY;\n\t\te = gf_media_import(&import);\n\t\tGOTO_EXIT("importing import");\n\n\t\tif (!strnicmp(ext, "audio", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, "video", 5)) do_video = 1;\n        else if (!strnicmp(ext, "auxv", 4)) do_auxv = 1;\n        else if (!strnicmp(ext, "pict", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, "trackID=", 8)) track_id = parse_u32(&ext[8], "trackID");\n\t\telse if (!strnicmp(ext, "PID=", 4)) track_id = parse_u32(&ext[4], "ID");\n\t\telse if (!strnicmp(ext, "program=", 8)) {\n\t\t\tfor (i=0; i<import.nb_progs; i++) {\n\t\t\t\tif (!stricmp(import.pg_info[i].name, ext+8)) {\n\t\t\t\t\tprog_id = import.pg_info[i].number;\n\t\t\t\t\tdo_all = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext, "prog_id=", 8)) {\n\t\t\tprog_id = parse_u32(ext+8, "prog_id");\n\t\t\tdo_all = 0;\n\t\t}\n\t\telse track_id = parse_u32(ext, "ID");\n\n\t\t//figure out trackID\n\t\tif (do_audio || do_video || do_auxv || do_pict || track_id) {\n\t\t\tBool found = track_id ? GF_FALSE : GF_TRUE;\n\t\t\tfor (i=0; i<import.nb_tracks; i++) {\n\t\t\t\tif (track_id && (import.tk_info[i].track_num==track_id)) {\n\t\t\t\t\tfound=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (do_audio && (import.tk_info[i].stream_type==GF_STREAM_AUDIO)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_video && (import.tk_info[i].stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_auxv && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_AUXV)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_pict && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_PICT)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!track_id || !found) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Cannot find track ID matching fragment #%s\\n", ext));\n\t\t\t\tif (sep) sep[0] = \':\';\n\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (sep) sep[0] = \':\';\n\t}\n\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\n\n\tif (track_layout || is_chap) {\n\t\tu32 w, h, sw, sh, fw, fh;\n\t\tw = h = sw = sh = fw = fh = 0;\n\t\tchap_ref = 0;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n            case GF_ISOM_MEDIA_AUXV:\n            case GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\n\t\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\n\t\t\t\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\n\t\t\t\tif (w<sw) w = sw;\n\t\t\t\tif (w<fw) w = fw;\n\t\t\t\tif (h<sh) h = sh;\n\t\t\t\tif (h<fh) h = fh;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (track_layout) {\n\t\t\tif (!tw) tw = w;\n\t\t\tif (!th) th = h;\n\t\t\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\n\t\t\timport.text_width = tw;\n\t\t\timport.text_height = th;\n\t\t}\n\t\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\n\t}\n\tif (text_layout && txtw && txth) {\n\t\timport.text_track_width = import.text_width ? import.text_width : txtw;\n\t\timport.text_track_height = import.text_height ? import.text_height : txth;\n\t\timport.text_width = txtw;\n\t\timport.text_height = txth;\n\t\timport.text_x = txtx;\n\t\timport.text_y = txty;\n\t}\n\n\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\n\n\tsource_magic = (u64) gf_crc_32((u8 *)inName, (u32) strlen(inName));\n\tif (!fake_import && (!fsess || mux_args_if_first_pass)) {\n\t\timport.in_name = final_name;\n\t\timport.dest = dest;\n\t\timport.video_fps = force_fps;\n\t\timport.frames_per_sample = frames_per_sample;\n\t\timport.flags = import_flags;\n\t\timport.keep_audelim = keep_audelim;\n\t\timport.print_stats_graph = print_stats_graph;\n\t\timport.xps_inband = xps_inband;\n\t\timport.prog_id = prog_id;\n\t\timport.trackID = track_id;\n\t\timport.source_magic = source_magic;\n\t\timport.track_index = tk_idx;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (moov_timescale<0) {\n\t\t\timport.moov_timescale = moov_timescale;\n\t\t}\n\t\t//otherwise force it now\n\t\telse if (moov_timescale>0) {\n\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\tGOTO_EXIT("changing timescale")\n\t\t}\n\n\t\timport.run_in_session = fsess;\n\t\timport.update_mux_args = NULL;\n\t\tif (do_all)\n\t\t\timport.flags |= GF_IMPORT_KEEP_REFS;\n\n\t\te = gf_media_import(&import);\n\t\tif (e) {\n\t\t\tif (import.update_mux_args) gf_free(import.update_mux_args);\n\t\t\tGOTO_EXIT("importing media");\n\t\t}\n\n\t\tif (fsess) {\n\t\t\t*mux_args_if_first_pass = import.update_mux_args;\n\t\t\timport.update_mux_args = NULL;\n\t\t\t*mux_sid_if_first_pass = import.update_mux_sid;\n\t\t\timport.update_mux_sid = NULL;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tnb_tracks = gf_isom_get_track_count(dest);\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu32 media_type;\n\t\ttrack = i+1;\n\t\tmedia_type = gf_isom_get_media_type(dest, track);\n\t\te = GF_OK;\n\t\tif (!fake_import) {\n\t\t\tu64 tk_source_magic;\n\t\t\ttk_source_magic = gf_isom_get_track_magic(dest, track);\n\n\t\t\tif ((tk_source_magic & 0xFFFFFFFFUL) != source_magic)\n\t\t\t\tcontinue;\n\t\t\ttk_source_magic>>=32;\t\t\n\t\t\tkeep_handler = (tk_source_magic & 1) ? GF_TRUE : GF_FALSE;\n\t\t} else {\n\t\t\tkeep_handler = GF_TRUE;\n\n\t\t\tif (do_audio && (media_type!=GF_ISOM_MEDIA_AUDIO)) continue;\n\t\t\tif (do_video && (media_type!=GF_ISOM_MEDIA_VISUAL)) continue;\n\t\t\tif (do_auxv && (media_type!=GF_ISOM_MEDIA_AUXV)) continue;\n\t\t\tif (do_pict && (media_type!=GF_ISOM_MEDIA_PICT)) continue;\n\t\t\tif (track_id && (gf_isom_get_track_id(dest, track) != track_id))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttimescale = gf_isom_get_timescale(dest);\n\t\tif (szLan) {\n\t\t\te = gf_isom_set_media_language(dest, track, (char *) szLan);\n\t\t\tGOTO_EXIT("changing language")\n\t\t}\n\t\tif (do_disable) {\n\t\t\te = gf_isom_set_track_enabled(dest, track, (do_disable==2) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT("disabling track")\n\t\t}\n\t\tif (track_flags_mode) {\n\t\t\te = gf_isom_set_track_flags(dest, track, track_flags, track_flags_mode);\n\t\t\tGOTO_EXIT("disabling track")\n\t\t}\n\n\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST) {\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\tGOTO_EXIT("removing edits")\n\t\t}\n\t\tif (delay.num && delay.den) {\n\t\t\tu64 tk_dur;\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\ttk_dur = gf_isom_get_track_duration(dest, track);\n\t\t\tif (delay.num>0) {\n\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\te |= gf_isom_append_edit(dest, track, ((s64) delay.num) * timescale / delay.den, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t} else {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\tu64 to_skip = ((s64) -delay.num) * timescale / delay.den;\n\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\t\tu64 media_time = ((s64) -delay.num) * gf_isom_get_media_timescale(dest, track) / delay.den;\n\t\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning: request negative delay longer than track duration - ignoring\\n"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tGOTO_EXIT("assigning delay")\n\t\t}\n\t\tif (gf_isom_is_video_handler_type(media_type)) {\n\t\t\tif (((par_n>=0) && (par_d>=0)) || force_par) {\n\t\t\t\te = gf_media_change_par(dest, track, par_n, par_d, force_par, rewrite_bs);\n\t\t\t\tGOTO_EXIT("changing PAR")\n\t\t\t}\n\t\t\tif ((fullrange>=0) || (videofmt>=0) || (colorprim>=0) || (colortfc>=0) || (colormx>=0)) {\n\t\t\t\te = gf_media_change_color(dest, i+1, fullrange, videofmt, colorprim, colortfc, colormx);\n\t\t\t\tGOTO_EXIT("changing color in bitstream")\n\t\t\t}\n\t\t\tif (has_clap) {\n\t\t\t\te = gf_isom_set_clean_aperture(dest, track, 1, clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod);\n\t\t\t\tGOTO_EXIT("changing clean aperture")\n\t\t\t}\n\t\t\tif (bitdepth) {\n\t\t\t\te = gf_isom_set_visual_bit_depth(dest, track, 1, bitdepth);\n\t\t\t\tGOTO_EXIT("changing bit depth")\n\t\t\t}\n\t\t\tif (clr_type) {\n\t\t\t\tif (clr_type==(u32)-1)\n\t\t\t\t\tclr_type = 0;\n\n\t\t\t\te = gf_isom_set_visual_color_info(dest, track, 1, clr_type, clr_prim, clr_tranf, clr_mx, clr_full_range, icc_data, icc_size);\n\t\t\t\tGOTO_EXIT("changing color info")\n\t\t\t}\n\t\t\tif (hdr_file) {\n\t\t\t\te = parse_high_dynamc_range_xml_desc(dest, track, hdr_file);\n\t\t\t\tGOTO_EXIT("setting HDR info")\n\t\t\t}\n\t\t\tif (dv_profile[0]) {\n\t\t\t\te = set_dv_profile(dest, track, dv_profile);\n\t\t\t\tGOTO_EXIT("setting DV profile")\n\t\t\t}\n\n\t\t\tif (set_ccst) {\n\t\t\t\te = gf_isom_set_image_sequence_coding_constraints(dest, track, 1, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\t\tGOTO_EXIT("setting image sequence constraints")\n\t\t\t}\n\t\t}\n\t\tif (has_mx) {\n\t\t\te = gf_isom_set_track_matrix(dest, track, mx);\n\t\t\tGOTO_EXIT("setting track matrix")\n\t\t}\n\t\tif (use_stz2) {\n\t\t\te = gf_isom_use_compact_size(dest, track, GF_TRUE);\n\t\t\tGOTO_EXIT("setting compact size")\n\t\t}\n\n\t\tif (gf_isom_get_media_subtype(dest, track, 1) == GF_ISOM_MEDIA_TIMECODE) {\n\t\t\ttmcd_track = track;\n\t\t}\n\t\tif (rap_only || refs_only) {\n\t\t\te = gf_media_remove_non_rap(dest, track, refs_only);\n\t\t\tGOTO_EXIT("removing non RAPs")\n\t\t}\n\t\tif (handler_name) {\n\t\t\te = gf_isom_set_handler_name(dest, track, handler_name);\n\t\t\tGOTO_EXIT("setting handler name")\n\t\t}\n\t\telse if (!keep_handler) {\n\t\t\tchar szHName[1024];\n\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\tfName = strchr(fName, \'.\');\n\t\t\tif (fName) fName += 1;\n\t\t\telse fName = "?";\n\n\t\t\tsprintf(szHName, "%s@GPAC%s", fName, gf_gpac_version());\n\t\t\te = gf_isom_set_handler_name(dest, track, szHName);\n\t\t\tGOTO_EXIT("setting handler name")\n\t\t}\n\t\tif (handler) {\n\t\t\te = gf_isom_set_media_type(dest, track, handler);\n\t\t\tGOTO_EXIT("setting media type")\n\t\t}\n\t\tif (group) {\n\t\t\te = gf_isom_set_alternate_group_id(dest, track, group);\n\t\t\tGOTO_EXIT("setting alternate group")\n\t\t}\n\n\t\tif (track_layout) {\n\t\t\te = gf_isom_set_track_layout_info(dest, track, tw<<16, th<<16, tx<<16, ty<<16, tz);\n\t\t\tGOTO_EXIT("setting track layout")\n\t\t}\n\t\tif (stype) {\n\t\t\te = gf_isom_set_media_subtype(dest, track, 1, stype);\n\t\t\tGOTO_EXIT("setting media subtype")\n\t\t}\n\t\tif (is_chap && chap_ref) {\n\t\t\te = set_chapter_track(dest, track, chap_ref);\n\t\t\tGOTO_EXIT("setting chapter track")\n\t\t}\n\n\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\te = gf_isom_add_track_kind(dest, i+1, kind_scheme, kind_value);\n\t\t\tGOTO_EXIT("setting track kind")\n\t\t}\n\n\t\tif (profile || compat || level) {\n\t\t\te = gf_media_change_pl(dest, track, profile, compat, level);\n\t\t\tGOTO_EXIT("changing video PL")\n\t\t}\n\t\tif (gf_isom_get_mpeg4_subtype(dest, track, 1))\n\t\t\tkeep_sys_tracks = 1;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (fake_import) {\n\t\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST)\n\t\t\t\tgf_isom_remove_edits(dest, track);\n\n\t\t\tif (moov_timescale<0) {\n\t\t\t\tmoov_timescale = gf_isom_get_media_timescale(dest, track);\n\t\t\t}\n\t\t\tif (moov_timescale>0) {\n\t\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\t\tGOTO_EXIT("changing timescale")\n\t\t\t}\n\n\t\t\tif (import.asemode && (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\tu32 sr, ch, bps;\n\t\t\t\tgf_isom_get_audio_info(dest, track, 1, &sr, &ch, &bps);\n\t\t\t\tgf_isom_set_audio_info(dest, track, 1, sr, ch, bps, import.asemode);\n\t\t\t}\n\t\t}\n\n\t\tif (roll_change) {\n\t\t\tif ((roll_change!=3) || (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\te = gf_isom_set_sample_roll_group(dest, track, (u32) -1, (roll_change==2) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL, roll);\n\t\t\t\tGOTO_EXIT("assigning roll")\n\t\t\t}\n\t\t}\n\n\t\tif (new_timescale>1) {\n\t\t\te = gf_isom_set_media_timescale(dest, track, new_timescale, 0, 0);\n\t\t\tGOTO_EXIT("setting media timescale")\n\t\t}\n\n\t\tif (rescale_num > 1) {\n\t\t\tswitch (gf_isom_get_media_type(dest, track)) {\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!rescale_override) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Cannot force media timescale for audio media types - ignoring\\n"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, rescale_num, rescale_den, rescale_override ? 2 : 1);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Rescale ignored, same config in source file\\n"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\t\t\t\tGOTO_EXIT("rescaling media track")\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (src_is_isom && force_fps.den && force_fps.num) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, track))) {\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, force_fps.num, force_fps.den, 2);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Rescale ignored, same config in source file\\n"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Cannot force FPS for media types %s - ignoring\\n", gf_4cc_to_str( gf_isom_get_media_type(dest, track)) ));\n\t\t\t}\n\t\t}\n\n\t\tif (has_last_sample_dur) {\n\t\t\te = gf_isom_set_last_sample_duration_ex(dest, track, last_sample_dur.num, last_sample_dur.den);\n\t\t\tGOTO_EXIT("setting last sample duration")\n\t\t}\n\t\tif (rvc_config) {\n#ifdef GPAC_DISABLE_ZLIB\n\t\t\tM4_LOG(GF_LOG_ERROR, ("Error: no zlib support - RVC not available\\n"));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n#else\n\t\t\tu8 *data;\n\t\t\tu32 size;\n\t\t\te = gf_file_load_data(rvc_config, (u8 **) &data, &size);\n\t\t\tGOTO_EXIT("loading RVC config file")\n\n\t\t\tgf_gz_compress_payload(&data, size, &size);\n\t\t\te |= gf_isom_set_rvc_config(dest, track, 1, 0, "application/rvc-config+xml+gz", data, size);\n\t\t\tgf_free(data);\n\t\t\tGOTO_EXIT("compressing and assigning RVC config")\n#endif\n\t\t} else if (rvc_predefined>0) {\n\t\t\te = gf_isom_set_rvc_config(dest, track, 1, rvc_predefined, NULL, NULL, 0);\n\t\t\tGOTO_EXIT("setting RVC predefined config")\n\t\t}\n\n\t\tif (neg_ctts_mode) {\n\t\t\te = gf_isom_set_composition_offset_mode(dest, track, (neg_ctts_mode==1) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT("setting composition offset mode")\n\t\t}\n\n\t\tif (gf_isom_get_avc_svc_type(dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\tcheck_track_for_svc = track;\n\n\t\tswitch (gf_isom_get_hevc_lhvc_type(dest, track, 1)) {\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\tcheck_track_for_hevc=1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (txt_flags) {\n\t\t\te = gf_isom_text_set_display_flags(dest, track, 0, txt_flags, txt_mode);\n\t\t\tGOTO_EXIT("setting text track display flags")\n\t\t}\n\n\t\tif (edits) {\n\t\t\te = apply_edits(dest, track, edits);\n\t\t\tGOTO_EXIT("applying edits")\n\t\t}\n\n\t\tif (force_rate>=0) {\n\t\t\te = gf_isom_update_bitrate(dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\tGOTO_EXIT("updating bitrate")\n\t\t}\n\n\t\tif (split_tile_mode) {\n\t\t\tswitch (gf_isom_get_media_subtype(dest, track, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((dlb_mode>=-1) && (gf_isom_get_media_subtype(dest, track, 1)==GF_ISOM_SUBTYPE_EC3)) {\n\t\t\tGF_AC3Config *ac3c = gf_isom_ac3_config_get(dest, track, 1);\n\t\t\tif (ac3c) {\n\t\t\t\tif (dlb_mode==0) {\n\t\t\t\t\tac3c->is_ec3 = GF_TRUE;\n\t\t\t\t\tac3c->atmos_ec3_ext=0;\n\t\t\t\t\tac3c->complexity_index_type=0;\n\t\t\t\t} else {\n\t\t\t\t\tu32 di;\n\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(dest, track, 1, &di);\n\t\t\t\t\tu32 pos;\n\t\t\t\t\tgf_eac3_parser(samp->data, samp->dataLength, &pos, ac3c, GF_TRUE);\n\n\t\t\t\t\tif (dlb_mode>0) {\n\t\t\t\t\t\tac3c->atmos_ec3_ext = 1;\n\t\t\t\t\t\tac3c->complexity_index_type = dlb_mode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_ac3_config_update(dest, track, 1, ac3c);\n\t\t\t\tgf_free(ac3c);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chapter_name) {\n\t\tif (is_chap_file) {\n\t\t\tGF_Fraction a_fps = {0,0};\n\t\t\te = gf_media_import_chapters(dest, chapter_name, a_fps, GF_FALSE);\n\t\t} else {\n\t\t\te = gf_isom_add_chapter(dest, 0, 0, chapter_name);\n\t\t}\n\t\tGOTO_EXIT("importing chapters")\n\t}\n\n\tif (tmcd_track) {\n\t\tu32 tmcd_id = gf_isom_get_track_id(dest, tmcd_track);\n\t\tfor (i=0; i < gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_isom_set_track_reference(dest, i+1, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT("assigning TMCD track references")\n\t\t}\n\t}\n\n\t/*force to rewrite all dependencies*/\n\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t{\n\t\te = gf_isom_rewrite_track_dependencies(dest, i);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("Warning: track ID %d has references to a track not imported\\n", gf_isom_get_track_id(dest, i) ));\n\t\t\te = GF_OK;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\n\t\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t\t{\n\t\t\te = gf_media_filter_hevc(dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning: track ID %d: error while filtering LHVC layers\\n", gf_isom_get_track_id(dest, i)));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (check_track_for_svc) {\n\t\tif (svc_mode) {\n\t\t\te = gf_media_split_svc(dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\n\t\t\tGOTO_EXIT("splitting SVC track")\n\t\t} else {\n\t\t\te = gf_media_merge_svc(dest, check_track_for_svc, 1);\n\t\t\tGOTO_EXIT("merging SVC/SHVC track")\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (check_track_for_lhvc) {\n\t\tif (svc_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\n\t\t\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\n\t\t\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\n\t\t\tGOTO_EXIT("splitting L-HEVC track")\n\t\t} else {\n\t\t\t//TODO - merge, temporal sublayers\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_HEVC\n\tif (check_track_for_hevc) {\n\t\tif (split_tile_mode) {\n\t\t\te = gf_media_split_hevc_tiles(dest, split_tile_mode - 1);\n\t\t\tGOTO_EXIT("splitting HEVC tiles")\n\t\t}\n\t\tif (temporal_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\n\t\t\tGOTO_EXIT("splitting HEVC temporal sublayers")\n\t\t}\n\t}\n#endif\n\n\tif (tc_fps_num) {\n\t\tu32 desc_index=0;\n\t\tu32 tmcd_tk, tmcd_id;\n\t\tu32 video_ref = 0;\n\t\tGF_BitStream *bs;\n\t\tGF_ISOSample *samp;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, i+1))) {\n\t\t\t\tvideo_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttmcd_tk = gf_isom_new_track(dest, 0, GF_ISOM_MEDIA_TIMECODE, tc_fps_num);\n\t\tif (!tmcd_tk) {\n\t\t\te = gf_isom_last_error(dest);\n\t\t\tGOTO_EXIT("creating TMCD track")\n\t\t}\n\t\te = gf_isom_set_track_enabled(dest, tmcd_tk, 1);\n\t\tif (e != GF_OK) {\n\t\t\tGOTO_EXIT("enabling TMCD track")\n\t\t}\n\n\t\tif (!tc_frames_per_tick) {\n\t\t\ttc_frames_per_tick = tc_fps_num;\n\t\t\ttc_frames_per_tick /= tc_fps_den;\n\t\t\tif (tc_frames_per_tick * tc_fps_den < tc_fps_num)\n\t\t\t\ttc_frames_per_tick++;\n\t\t}\n\n\t\tu32 tmcd_value = (tc_h * 3600 + tc_m*60 + tc_s)*tc_frames_per_tick+tc_f;\n\t\ttmcd_id = gf_isom_get_track_id(dest, tmcd_tk);\n\n\t\te = gf_isom_tmcd_config_new(dest, tmcd_tk, tc_fps_num, tc_fps_den, tc_frames_per_tick, tc_drop_frame, tc_force_counter, &desc_index);\n\t\tGOTO_EXIT("configuring TMCD sample description")\n\n\t\tif (video_ref) {\n\t\t\te = gf_isom_set_track_reference(dest, video_ref, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT("assigning TMCD track ref on video track")\n\t\t}\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, tmcd_value);\n\t\tsamp = gf_isom_sample_new();\n\t\tsamp->IsRAP = SAP_TYPE_1;\n\t\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\t\tgf_bs_del(bs);\n\t\te = gf_isom_add_sample(dest, tmcd_tk, desc_index, samp);\n\t\tgf_isom_sample_del(&samp);\n\t\tGOTO_EXIT("assigning TMCD sample")\n\n\t\tif (video_ref) {\n\t\t\tu64 video_ref_dur = gf_isom_get_media_duration(dest, video_ref);\n\t\t\tvideo_ref_dur *= tc_fps_num;\n\t\t\tvideo_ref_dur /= gf_isom_get_media_timescale(dest, video_ref);\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, (u32) video_ref_dur);\n\t\t} else {\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, tc_fps_den ? tc_fps_den : 1);\n\t\t}\n\t\tGOTO_EXIT("setting TMCD sample dur")\n\t}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nexit:\n\twhile (gf_list_count(kinds)) {\n\t\tchar *kind = (char *)gf_list_get(kinds, 0);\n\t\tgf_list_rem(kinds, 0);\n\t\tif (kind) gf_free(kind);\n\t}\n\tif (opt_src) opt_src[0] = \':\';\n\tif (opt_dst) opt_dst[0] = \':\';\n\tif (fchain) fchain[0] = \':\';\n\tif (hdr_file) gf_free(hdr_file);\n\n\tgf_list_del(kinds);\n\tif (handler_name) gf_free(handler_name);\n\tif (chapter_name ) gf_free(chapter_name);\n\tif (import.fontName) gf_free(import.fontName);\n\tif (import.streamFormat) gf_free(import.streamFormat);\n\tif (import.force_ext) gf_free(import.force_ext);\n\tif (rvc_config) gf_free(rvc_config);\n\tif (edits) gf_free(edits);\n\tif (szLan) gf_free((char *)szLan);\n\tif (icc_data) gf_free(icc_data);\n\tif (final_name) gf_free(final_name);\n\n\tif (!e) return GF_OK;\n\tif (fail_msg) {\n\t\tM4_LOG(GF_LOG_ERROR, ("Failure while %s: %s\\n", fail_msg, gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n', 'caller_start': 622, 'file_path': 'applications/mp4box/fileimport.c'}, {'type': 'caller_info', 'call_line': 1273, 'call_code': 'gf_media_split_hevc_tiles(movie, 0)', 'caller_code': 'static GF_Err gf_isom_iff_create_image_item_from_track_internal(GF_ISOFile *movie, Bool root_meta, u32 meta_track_number, u32 imported_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs, u32 sample_number) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_Err e;\n\tu32 w, h, hSpacing, vSpacing;\n\tu8 num_channels;\n\tu8 bits_per_channel[3];\n\tu32 subtype;\n\tGF_ISOSample *sample = NULL;\n\tu32 timescale;\n\tu32 item_type = 0;\n\tGF_ImageItemProperties local_image_props;\n\tGF_ImageItemProtection ipro, *orig_ipro = NULL;\n\tBool config_needed = 0;\n\tGF_Box *config_box = NULL;\n\tBool is_cenc = GF_FALSE;\n\tBool is_first = GF_TRUE;\n\tBool neg_time = (image_props && image_props->time<0) ? GF_TRUE : GF_FALSE;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0, sai_alloc_size = 0;\n\tu32 sample_desc_index = 0;\n\tGF_ISOFile *fsrc = movie;\n\tBool reset_brands = GF_FALSE;\n\n\t//only reset brands if first item import\n\tif (!gf_isom_get_meta_item_count(movie, root_meta, meta_track_number))\n\t\treset_brands = GF_TRUE;\n\n\tif (image_props && image_props->src_file)\n\t\tfsrc = image_props->src_file;\n\n\tif (image_props && image_props->tile_mode != TILE_ITEM_NONE) {\n\t\t/* Processing the input file in Tiled mode:\n\t\t   The single track is split into multiple tracks\n\t\t   and each track is processed to create an item */\n\t\tu32 i, count;\n\t\tu32 tile_track;\n\t\tGF_List *tile_item_ids;\n\t\tchar sz_item_name[256];\n\t\tGF_TileItemMode orig_tile_mode;\n\n#if !defined(GPAC_DISABLE_HEVC) && !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (image_props->src_file)\n\t\t\te = GF_SERVICE_ERROR;\n\t\telse\n\t\t\te = gf_media_split_hevc_tiles(movie, 0);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\n\t\tif (e) return e;\n\t\ttile_item_ids = gf_list_new();\n\t\torig_tile_mode = image_props->tile_mode;\n\t\timage_props->tile_mode = TILE_ITEM_NONE;\n\t\tcount = gf_isom_get_reference_count(movie, imported_track, GF_ISOM_REF_SABT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_malloc(sizeof(u32));\n\t\t\tif (!tile_item_id) return GF_OUT_OF_MEM;\n\n\t\t\t*tile_item_id = item_id + i+1;\n\t\t\tgf_list_add(tile_item_ids, tile_item_id);\n\t\t\te = gf_isom_get_reference(movie, imported_track, GF_ISOM_REF_SABT, 1, &tile_track);\n\t\t\tif (e) return e;\n\t\t\tif (item_name)\n\t\t\t\tsprintf(sz_item_name, "%s-Tile%d", item_name, i + 1);\n\t\t\tif (orig_tile_mode != TILE_ITEM_SINGLE || image_props->single_tile_number == i + 1) {\n\t\t\t\te = gf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, tile_track, item_name ? sz_item_name : NULL, *tile_item_id, NULL, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t\tgf_isom_remove_track(movie, tile_track);\n\t\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\t\te = gf_isom_meta_add_item_ref(movie, root_meta, meta_track_number, *tile_item_id, item_id, GF_ISOM_REF_TBAS, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (item_name)\n\t\t\tsprintf(sz_item_name, "%s-TileBase", item_name);\n\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\tgf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, imported_track, item_name ? sz_item_name : NULL, item_id, image_props, tile_item_ids);\n\t\t}\n\t\telse if (orig_tile_mode == TILE_ITEM_ALL_GRID) {\n\t\t\t// TODO\n\t\t}\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_list_get(tile_item_ids, i);\n\t\t\tgf_free(tile_item_id);\n\t\t}\n\t\tgf_list_del(tile_item_ids);\n\t\treturn GF_OK;\n\t}\n\n\tif (!image_props) {\n\t\timage_props = &local_image_props;\n\t\tmemset(image_props, 0, sizeof(GF_ImageItemProperties));\n\t} else {\n\t\torig_ipro = image_props->cenc_info;\n\t\timage_props->cenc_info = NULL;\n\t}\n\n\tif (!imported_track) {\n\t\tGF_ImageItemProperties src_props;\n\t\tu32 item_idx, ref_id;\n\t\tu32 scheme_type=0, scheme_version=0;\n\t\tconst char *orig_item_name, *orig_item_mime_type, *orig_item_encoding;\n\t\tif (!image_props->item_ref_id) return GF_BAD_PARAM;\n\n\t\tif (gf_isom_meta_get_item_ref_count(fsrc, GF_TRUE, 0, image_props->item_ref_id, GF_4CC(\'d\',\'i\',\'m\',\'g\')) > 0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Cannnot import derived image, only native image import is supported\\n"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\titem_idx = gf_isom_get_meta_item_by_id(fsrc, GF_TRUE, 0, image_props->item_ref_id);\n\t\tif (!item_idx) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: No item with ID %d, cannnot import\\n", image_props->item_ref_id));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\torig_item_name = orig_item_mime_type = orig_item_encoding = NULL;\n\t\tgf_isom_get_meta_item_info(fsrc, GF_TRUE, 0, item_idx, &ref_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &orig_item_name, &orig_item_mime_type, &orig_item_encoding);\n\n\t\tif (!ref_id) return GF_BAD_PARAM;\n\t\tif (ref_id != image_props->item_ref_id) return GF_ISOM_INVALID_FILE;\n\n\t\tgf_isom_get_meta_image_props(fsrc, GF_TRUE, 0, ref_id, &src_props, NULL);\n\n\t\timage_props->config = src_props.config;\n\t\timage_props->width = src_props.width;\n\t\timage_props->height = src_props.height;\n\t\timage_props->num_channels = src_props.num_channels;\n\t\tmemcpy(image_props->av1_layer_size, src_props.av1_layer_size, sizeof(u32)*3);\n\t\tmemcpy(image_props->bits_per_channel, src_props.bits_per_channel, sizeof(u32)*3);\n\t\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\t\timage_props->hSpacing = src_props.hSpacing;\n\t\t\timage_props->vSpacing = src_props.vSpacing;\n\t\t}\n\t\tif (image_props->copy_props) {\n\t\t\tif (!image_props->hOffset && !image_props->vOffset) {\n\t\t\t\timage_props->hOffset = src_props.hOffset;\n\t\t\t\timage_props->vOffset = src_props.vOffset;\n\t\t\t}\n\t\t\tif (!image_props->clap_wden) {\n\t\t\t\timage_props->clap_wnum = src_props.clap_wnum;\n\t\t\t\timage_props->clap_wden = src_props.clap_wden;\n\t\t\t\timage_props->clap_hnum = src_props.clap_hnum;\n\t\t\t\timage_props->clap_hden = src_props.clap_hden;\n\t\t\t\timage_props->clap_honum = src_props.clap_honum;\n\t\t\t\timage_props->clap_hoden = src_props.clap_hoden;\n\t\t\t\timage_props->clap_vonum = src_props.clap_vonum;\n\t\t\t\timage_props->clap_voden = src_props.clap_voden;\n\t\t\t}\n\t\t\tif (!image_props->alpha) image_props->alpha = src_props.alpha;\n\t\t\tif (!image_props->depth) image_props->depth = src_props.depth;\n\t\t\tif (!image_props->hidden) image_props->hidden = src_props.hidden;\n\t\t\tif (!image_props->angle) image_props->angle = src_props.angle;\n\t\t\tif (!image_props->mirror) image_props->mirror = src_props.mirror;\n\t\t\tif (!image_props->av1_op_index) image_props->av1_op_index = src_props.av1_op_index;\n\t\t}\n\t\tif (!item_name) item_name = orig_item_name;\n\n\t\tif (!image_props->use_reference || (fsrc == image_props->src_file)) {\n\t\t\tu8 *data = NULL;\n\t\t\tu32 size=0;\n\t\t\te = gf_isom_extract_meta_item_mem(fsrc, GF_TRUE, 0, ref_id, &data, &size, &size, NULL, GF_FALSE);\n\t\t\tif (e) return GF_BAD_PARAM;\n\n\t\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, data, size, NULL);\n\t\t\tif (data) gf_free(data);\n\t\t} else {\n\t\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, 0, ref_id);\n\t\t}\n\t\treturn e;\n\t}\n\nimport_next_sample:\n\n\ttimescale = gf_isom_get_media_timescale(fsrc, imported_track);\n\tif (image_props->sample_num) {\n\t\tsample_number = image_props->sample_num;\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else if (image_props->time<0) {\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else {\n\t\te = gf_isom_get_sample_for_media_time(fsrc, imported_track, (u64)(image_props->time*timescale), &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &sample, &sample_number, NULL);\n\t}\n\tif (e || !sample || !sample->IsRAP) {\n\t\tif (!sample) {\n\t\t\tif (is_first) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("No sample found%s\\n", (image_props->time<0) ? "" : " for requested time"));\n\t\t\t} else {\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if ((image_props->time<0) || (image_props->step_time)) {\n\t\t\tif (image_props->sample_num) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: imported sample %d (DTS "LLU") is not a sync sample (RAP %d size %d)\\n", sample_number, sample->DTS, sample->IsRAP, sample->dataLength));\n\t\t\t} else if (image_props->step_time) {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\tsample_number++;\n\t\t\t\tif (sample_number == gf_isom_get_sample_count(fsrc, imported_track)) {\n\t\t\t\t\te = GF_OK;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgoto import_next_sample;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error no sync sample found after time %g\\n", image_props->time));\n\t\t}\n\t\tif (!e) e = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the track type is supported as item type */\n\t/* Get the config box if needed */\n\tsubtype = gf_isom_get_media_subtype(fsrc, imported_track, sample_desc_index);\n\tif (gf_isom_is_media_encrypted(fsrc, imported_track, sample_desc_index)) {\n\t\tif (gf_isom_is_cenc_media(fsrc, imported_track, sample_desc_index)) {\n\t\t\te = gf_isom_get_original_format_type(fsrc, imported_track, sample_desc_index, &subtype);\n\t\t\tif (e) goto exit;\n\t\t\tis_cenc = GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Protected sample not using CENC, cannot add as item\\n"));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_avc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_svc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_mvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_hevc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\tif (subtype == GF_ISOM_SUBTYPE_HVT1) {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVT1;\n\t\t}\n\t\telse {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tconfig_needed = 1;\n\t\tif (!((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_lhvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t}\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_AV01:\n\t\t{\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_isom_av1_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\t\tconfig_needed = 1;\n\t\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\t\tnum_channels = 1;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = 0;\n\t\t\t\tbits_per_channel[2] = 0;\n\t\t\t} else {\n\t\t\t\tnum_channels = 3;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = depth;\n\t\t\t\tbits_per_channel[2] = depth;\n\t\t\t}\n\t\t\t// presence of OBU SH in config is not recommended and properties should be used instead of metadata OBUs\n\t\t\twhile (gf_list_count(((GF_AV1ConfigurationBox *)config_box)->config->obu_array)) {\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_pop_back(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t\tif (obu) {\n\t\t\t\t\tif (obu->obu) gf_free(obu->obu);\n\t\t\t\t\tgf_free(obu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config->obu_array = NULL;\n\t\t\te = gf_media_av1_layer_size_get(fsrc, imported_track, sample_number, image_props->av1_op_index, image_props->av1_layer_size);\n      if (e) {\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("AV1 operating point index out of range for stream\\n"));\n        goto exit;\n      }\n\t\t\t//media_brand = GF_ISOM_BRAND_AVIF;\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_isom_vvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\tbits_per_channel[1] = bits_per_channel[2] = bits_per_channel[0];\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Codec not supported to create HEIF image items\\n"));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto exit;\n\t}\n\tif (config_needed && !config_box && !((GF_AVCConfigurationBox *)config_box)->config) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Image type %s requires a missing configuration box\\n", gf_4cc_to_str(item_type)));\n\t\te = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\t/* Get some images properties from the track data */\n\te = gf_isom_get_visual_info(fsrc, imported_track, sample_desc_index, &w, &h);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error determining image size\\n"));\n\t\tgoto exit;\n\t}\n\te = gf_isom_get_pixel_aspect_ratio(fsrc, imported_track, sample_desc_index, &hSpacing, &vSpacing);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error determining image aspect ratio\\n"));\n\t\tgoto exit;\n\t}\n\tif (!image_props->width && !image_props->height) {\n\t\timage_props->width = w;\n\t\timage_props->height = h;\n\t}\n\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\timage_props->hSpacing = hSpacing;\n\t\timage_props->vSpacing = vSpacing;\n\t}\n\timage_props->config = config_box;\n\tif (!image_props->num_channels) {\n\t\timage_props->num_channels = num_channels;\n\t\timage_props->bits_per_channel[0] = bits_per_channel[0];\n\t\timage_props->bits_per_channel[1] = bits_per_channel[1];\n\t\timage_props->bits_per_channel[2] = bits_per_channel[2];\n\t}\n\tif (is_cenc) {\n\t\tBool Is_Encrypted;\n\n\t\tmemset(&ipro, 0, sizeof(GF_ImageItemProtection));\n\t\tgf_isom_get_cenc_info(fsrc, imported_track, sample_desc_index, NULL, &ipro.scheme_type, &ipro.scheme_version);\n\t\te = gf_isom_get_sample_cenc_info(fsrc, imported_track, sample_desc_index, &Is_Encrypted, &ipro.crypt_byte_block, &ipro.skip_byte_block, &ipro.key_info, &ipro.key_info_size);\n\t\tif (e) goto exit;\n\n\t\tif (Is_Encrypted) {\n\t\t\tsai_size = sai_alloc_size;\n\t\t\te = gf_isom_cenc_get_sample_aux_info(fsrc, imported_track, sample_number, sample_desc_index, NULL, &sai, &sai_size);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (sai_size > sai_alloc_size)\n\t\t\t\tsai_alloc_size = sai_size;\n\n\t\t\tipro.sai_data = sai;\n\t\t\tipro.sai_data_size = sai_size;\n\t\t\timage_props->cenc_info = &ipro;\n\n\t\t\tif (is_first) {\n\t\t\t\tu32 i, nb_pssh = gf_isom_get_pssh_count(fsrc);\n\t\t\t\tfor (i=0; i<nb_pssh; i++) {\n\t\t\t\t\tbin128 SystemID;\n\t\t\t\t\tu32 version;\n\t\t\t\t\tu32 KID_count;\n\t\t\t\t\tconst bin128 *KIDs;\n\t\t\t\t\tconst u8 *private_data;\n\t\t\t\t\tu32 private_data_size;\n\n\t\t\t\t\tgf_isom_get_pssh_info(fsrc, i+1, SystemID, &version, &KID_count, &KIDs, &private_data, &private_data_size);\n\t\t\t\t\t\n\t\t\t\t\tgf_cenc_set_pssh(movie, SystemID, version, KID_count, (bin128 *) KIDs, (u8 *) private_data, private_data_size, 2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\timage_props->cenc_info = NULL;\n\t\t}\n\t}\n\tif (!item_id) {\n\t\te = gf_isom_meta_get_next_item_id(movie, root_meta, meta_track_number, &item_id);\n\t\tif (e) goto exit;\n\t}\n\tif (image_props->use_reference) {\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("referring trackID %d sample %d as item %d\\n", imported_track, sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("referring trackID %d sample at time %.3f as item %d\\n", imported_track, (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, imported_track, sample_number);\n\t} else {\n\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("Adding sample %d as item %d\\n", sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("Adding sample at time %.3f as item %d\\n", (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, sample->data, sample->dataLength, item_extent_refs);\n\t}\n\n\timage_props->cenc_info = NULL;\n\n\tif (reset_brands) {\n\t\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(movie);\n\n\t\t// TODO Analyze configuration to determine the brand */\n\t\t//if (media_brand) {\n\t\t//\tgf_isom_modify_alternate_brand(movie, media_brand, GF_TRUE);\n\t\t//}\n\t}\n\n\t\n\tif (neg_time)\n\t\timage_props->time = -1;\n\n\tif (!e && !image_props->sample_num && ((image_props->time<0) || image_props->end_time || image_props->step_time)) {\n\t\tif (image_props->end_time || image_props->step_time) {\n\t\t\tDouble t = (Double) (sample->DTS + sample->CTS_Offset);\n\t\t\tt /= timescale;\n\t\t\tif (image_props->step_time) {\n\t\t\t\tt += image_props->step_time;\n\t\t\t} else {\n\t\t\t\t//step 1ms\n\t\t\t\tt += 0.001;\n\t\t\t}\n\n\t\t\tif ((image_props->end_time>0) && (t>image_props->end_time)) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\timage_props->time = t;\n\t\t}\n\n\t\titem_id=0;\n\t\tgf_isom_sample_del(&sample);\n\t\tif (config_box) {\n\t\t\tgf_isom_box_del(config_box);\n\t\t\tconfig_box = NULL;\n\t\t}\n\t\tis_first = GF_FALSE;\n\t\tif (sample_number >= gf_isom_get_sample_count(fsrc, imported_track)) return e;\n\t\tsample_number++;\n\t\t//avoid recursion this could get quite big\n\t\tgoto import_next_sample;\n\t}\n\nexit:\n\tif (sai) gf_free(sai);\n\tgf_isom_sample_del(&sample);\n\tif (config_box) gf_isom_box_del(config_box);\n\timage_props->cenc_info = orig_ipro;\n\treturn e;\n\n\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n', 'caller_start': 1229, 'file_path': 'src/isomedia/iff.c'}]
 10:15:10 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'gf_isom_get_sample', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:15:10 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}', 'start_line': 1934, 'end_line': 1937, 'full_name': 'gf_isom_get_sample', 'file_path': 'src/isomedia/isom_read.c'}]
 10:15:32 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'G_Alloc'}}, {'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'trap_Alloc'}}]
 10:15:32 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'G_Alloc', 'project_dir': '/storage/result/Part2_result/github/CVE-2019-25104/old_repos/rtcwcoop-rtcwcoop_39bcb1c'})
 10:15:32 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void *G_Alloc( int size ) {\n\tchar    *p;\n\n\tif ( g_debugAlloc.integer ) {\n\t\tG_Printf( "G_Alloc of %i bytes (%i left)\\n", size, POOLSIZE - allocPoint - ( ( size + 31 ) & ~31 ) );\n\t}\n\n\tif ( allocPoint + size > POOLSIZE ) {\n\t\tG_Error( "G_Alloc: failed on allocation of %i bytes", size );\n\t\treturn NULL;\n\t}\n\n\tp = &memoryPool[allocPoint];\n\n\tallocPoint += ( size + 31 ) & ~31;\n\n\treturn p;\n}', 'start_line': 45, 'end_line': 62, 'full_name': 'G_Alloc', 'file_path': 'code/game/g_mem.c'}]
 10:15:32 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'trap_Alloc', 'project_dir': '/storage/result/Part2_result/github/CVE-2019-25104/old_repos/rtcwcoop-rtcwcoop_39bcb1c'})
 10:15:32 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void *trap_Alloc( int size ) {\n\treturn (void*)syscall( CG_ALLOC, size );\n}', 'start_line': 570, 'end_line': 572, 'full_name': 'trap_Alloc', 'file_path': 'code/cgame/cg_syscalls.c'}, {'type': 'function_def', 'code': 'void *trap_Alloc( int size ) {\n\treturn (void*)syscall( G_ALLOC, size );\n}', 'start_line': 813, 'end_line': 815, 'full_name': 'trap_Alloc<duplicate>0', 'file_path': 'code/game/g_syscalls.c'}, {'type': 'function_def', 'code': 'void *trap_Alloc( int size ) {\n\treturn (void*)syscall( UI_ALLOC, size );\n}', 'start_line': 477, 'end_line': 479, 'full_name': 'trap_Alloc<duplicate>1', 'file_path': 'code/ui/ui_syscalls.c'}]
 10:15:34 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'unpack'}}, {'tool': 'caller_info.find_caller_for_func', 'params': {'func_name': 'check_pt_dynamic'}}, {'tool': 'caller_info.find_caller_for_func', 'params': {'func_name': 'calls_crt1'}}]
 10:15:35 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:15:35 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', 'start_line': 236, 'end_line': 261, 'full_name': 'PackCom.unpack:void(OutputFile*)', 'file_path': 'src/p_com.cpp'}, {'type': 'function_def', 'code': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', 'start_line': 401, 'end_line': 470, 'full_name': 'PackDjgpp2.unpack:void(OutputFile*)', 'file_path': 'src/p_djgpp2.cpp'}, {'type': 'function_def', 'code': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', 'start_line': 688, 'end_line': 806, 'full_name': 'PackExe.unpack:void(OutputFile*)', 'file_path': 'src/p_exe.cpp'}]
 10:15:35 PM - [INFO]: Executing tool: caller_info.find_caller_for_func({'func_name': 'check_pt_dynamic', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:15:35 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 301, 'call_code': 'check_pt_dynamic(phdr)', 'caller_code': 'void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack("0==e_phnum");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * sizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack("bad e_phoff");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    unsigned const last_Shdr = e_shoff + e_shnum * sizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack("bad e_shoff");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack("bad dynsym->sh_link");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup("JNI_OnLoad");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n', 'caller_start': 240, 'file_path': 'src/p_lx_elf.cpp'}, {'type': 'caller_info', 'call_line': 771, 'call_code': 'check_pt_dynamic(phdr)', 'caller_code': 'void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack("0==e_phnum");\n    e_phoff = get_te64(&ehdri.e_phoff);\n    upx_uint64_t const last_Phdr = e_phoff + e_phnum * sizeof(Elf64_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack("bad e_phoff");\n    }\n    e_shoff = get_te64(&ehdri.e_shoff);\n    upx_uint64_t const last_Shdr = e_shoff + e_shnum * sizeof(Elf64_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack("bad e_shoff");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf64_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack("bad dynsym->sh_link");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup("JNI_OnLoad");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n', 'caller_start': 710, 'file_path': 'src/p_lx_elf.cpp'}, {'type': 'caller_info', 'call_line': 1835, 'call_code': 'check_pt_dynamic(phdr)', 'caller_code': 'bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: \'~\': zero extending \'unsigned int\' to \'upx_uint64_t\' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack("PT_NOTEs too big; try \'--force-execve\'");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#x above stub", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1694, 'file_path': 'src/p_lx_elf.cpp'}, {'type': 'caller_info', 'call_line': 2072, 'call_code': 'check_pt_dynamic(phdr)', 'caller_code': 'bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#lx above stub", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1981, 'file_path': 'src/p_lx_elf.cpp'}]
 10:15:36 PM - [INFO]: Executing tool: caller_info.find_caller_for_func({'func_name': 'calls_crt1', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:15:36 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 1845, 'call_code': 'calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))', 'caller_code': 'bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: \'~\': zero extending \'unsigned int\' to \'upx_uint64_t\' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack("PT_NOTEs too big; try \'--force-execve\'");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#x above stub", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1694, 'file_path': 'src/p_lx_elf.cpp'}, {'type': 'caller_info', 'call_line': 1847, 'call_code': 'calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))', 'caller_code': 'bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: \'~\': zero extending \'unsigned int\' to \'upx_uint64_t\' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack("PT_NOTEs too big; try \'--force-execve\'");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#x above stub", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1694, 'file_path': 'src/p_lx_elf.cpp'}, {'type': 'caller_info', 'call_line': 2082, 'call_code': 'calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))', 'caller_code': 'bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#lx above stub", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1981, 'file_path': 'src/p_lx_elf.cpp'}, {'type': 'caller_info', 'call_line': 2084, 'call_code': 'calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))', 'caller_code': 'bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#lx above stub", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1981, 'file_path': 'src/p_lx_elf.cpp'}]
 10:15:59 PM - [INFO]: [Initial analysis response] 
{
    "language": "cpp",
    "vulnerability_type": "logic",
    "repair_strategy": "The patch modifies the condition in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) to allow the escape character (0x1B) while retaining filtering of other control characters (<0x20). This changes the sanitization logic to explicitly permit ANSI escape sequences while blocking other unsafe control characters.",
    "analysis": "The root cause lies in insufficient sanitization of control characters in title responses. The patch allows 0x1B (escape) through, which may be part of ANSI escape sequences, but the full handling of these sequences is not visible in the patch. Without examining how the `ReportString` functions process these sequences (e.g., parsing logic for escape codes), the chain of execution leading to arbitrary code execution remains incomplete. The vulnerability likely stems from improper validation of the full escape sequence after this sanitization step.",
    "need_context": true,
    "required_context": [
        "function: CEAnsi::ReportString",
        "function: SrvAnsiImpl::ReportString"
    ],
    "root_cause": "The original code in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) replaced all control characters (<0x20) with spaces. The patch adds an exception for 0x1B (escape), allowing ANSI escape sequences. If subsequent processing of these sequences does not validate their structure or content, malicious sequences could trigger unintended behavior. GAP: The implementation of `ReportString` beyond the patch lines is not visible, making it impossible to confirm if escape sequences are safely handled.",
    "confidence_score": 0.75
}
 10:15:59 PM - [INFO]: http://localhost:2003 Joern service is available
 10:16:02 PM - [INFO]: http://localhost:2003 init new project
 10:16:05 PM - [INFO]: http://localhost:2003: Context actor work for /storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571 with id 98eb5c261b6bf416446f88e2cadc4464
 10:16:17 PM - [INFO]: http://localhost:2000 Joern service is available
 10:16:20 PM - [INFO]: http://localhost:2001 Joern service is available
 10:16:22 PM - [INFO]: http://localhost:2002 Joern service is available
 10:16:27 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'isomedia/media.c', 'func_name': 'Media_GetSample'}}, {'tool': 'caller_info.find_caller_for_func_file', 'params': {'file_path': 'isomedia/media.c', 'func_name': 'Media_GetSample'}}]
 10:16:27 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'isomedia/media.c', 'func_name': 'Media_GetSample', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:16:27 PM - [INFO]: Tool result: None
 10:16:27 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'Media_GetSample', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:16:27 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n", 'start_line': 467, 'end_line': 680, 'full_name': 'Media_GetSample', 'file_path': 'src/isomedia/media.c'}]
 10:16:28 PM - [INFO]: Executing tool: caller_info.find_caller_for_func_file({'file_path': 'isomedia/media.c', 'func_name': 'Media_GetSample', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:16:28 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 182, 'call_code': 'Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL)', 'caller_code': 'static GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(mdia->nalu_parser) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(mdia->nalu_parser, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(mdia->nalu_parser) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tsample_offset = (s8) gf_bs_read_int(mdia->nalu_parser, 8);\n\t\t\tdata_offset = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("ISOBMF: Extractor target track is not present in file - skipping.\\n"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\tif (!mdia->extracted_samp) return GF_IO_ERR;\n\t\t\t}\n\t\t\tif (!mdia->extracted_bs) {\n\t\t\t\tmdia->extracted_bs = gf_bs_new("a", 1, GF_BITSTREAM_READ);\n\t\t\t\tif (!mdia->extracted_bs) return GF_IO_ERR;\n\t\t\t}\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\t\t\tif (!mdia->extracted_samp->alloc_size)\n\t\t\t\tmdia->extracted_samp->alloc_size = mdia->extracted_samp->dataLength;\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 "all supported NALUs" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_bs_reassign_buffer(mdia->extracted_bs, mdia->extracted_samp->data + data_offset, mdia->extracted_samp->dataLength - data_offset);\n\n\t\t\tif (mdia->extracted_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(mdia->extracted_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer_alloc = ref_nalu_size;\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(mdia->extracted_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("ISOBMF: Extractor size is larger than referred sample size - skipping.\\n"));\n\t\t\t}\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tif (nal_size - nb_bytes_nalh > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size - nb_bytes_nalh;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * (nal_size - nb_bytes_nalh) );\n\t\t}\n\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n', 'caller_start': 101, 'file_path': 'src/isomedia/avc_ext.c'}, {'type': 'caller_info', 'call_line': 1916, 'call_code': 'Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset)', 'caller_code': 'GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n', 'caller_start': 1891, 'file_path': 'src/isomedia/isom_read.c'}, {'type': 'caller_info', 'call_line': 2069, 'call_code': 'Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset)', 'caller_code': 'GF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}', 'caller_start': 2049, 'file_path': 'src/isomedia/isom_read.c'}, {'type': 'caller_info', 'call_line': 2266, 'call_code': 'Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset)', 'caller_code': "GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n", 'caller_start': 2142, 'file_path': 'src/isomedia/isom_read.c'}]
 10:16:28 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'ReportString'}}, {'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'ReportString'}}]
 10:16:28 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'ReportString', 'project_dir': '/storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})
 10:16:28 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", 'start_line': 974, 'end_line': 1004, 'full_name': 'SrvAnsiImpl.ReportString:bool(LPCWSTR)', 'file_path': 'src/ConEmuCD/ConAnsiImpl.cpp'}, {'type': 'function_def', 'code': "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", 'start_line': 2492, 'end_line': 2525, 'full_name': 'CEAnsi.ReportString:BOOL(LPCWSTR)', 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'function_def', 'code': 'BOOL ReportString(LPCWSTR asRet);', 'start_line': 202, 'end_line': 202, 'full_name': 'CEAnsi.ReportString:ANY(LPCWSTR)', 'file_path': 'src/ConEmuHk/Ansi.h'}]
 10:16:28 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'ReportString', 'project_dir': '/storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})
 10:16:28 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", 'start_line': 974, 'end_line': 1004, 'full_name': 'SrvAnsiImpl.ReportString:bool(LPCWSTR)', 'file_path': 'src/ConEmuCD/ConAnsiImpl.cpp'}, {'type': 'function_def', 'code': "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", 'start_line': 2492, 'end_line': 2525, 'full_name': 'CEAnsi.ReportString:BOOL(LPCWSTR)', 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'function_def', 'code': 'BOOL ReportString(LPCWSTR asRet);', 'start_line': 202, 'end_line': 202, 'full_name': 'CEAnsi.ReportString:ANY(LPCWSTR)', 'file_path': 'src/ConEmuHk/Ansi.h'}]
 10:16:42 PM - [INFO]: Tools query: [{'tool': 'caller_info.find_caller_for_func_file', 'params': {'file_path': 'code/game/ai_cast_script.c', 'func_name': 'AICast_ScriptParse'}}, {'tool': 'caller_info.find_caller_for_func_file', 'params': {'file_path': 'code/game/ai_cast_script.c', 'func_name': 'AICast_ScriptLoad'}}]
 10:16:42 PM - [INFO]: Executing tool: caller_info.find_caller_for_func_file({'file_path': 'code/game/ai_cast_script.c', 'func_name': 'AICast_ScriptParse', 'project_dir': '/storage/result/Part2_result/github/CVE-2019-25104/old_repos/rtcwcoop-rtcwcoop_39bcb1c'})
 10:16:42 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 417, 'call_code': 'AICast_ScriptParse( cs )', 'caller_code': 'gentity_t *AICast_CreateCharacter( gentity_t *ent, float *attributes, cast_weapon_info_t *weaponInfo, char *castname, char *model, char *head, char *sex, char *color, char *handicap ) {\n\tgentity_t       *newent;\n\tgclient_t       *client;\n\tcast_state_t    *cs;\n\tchar            **ppStr;\n\tint j;\n\n\tif ( g_gametype.integer > GT_SINGLE_PLAYER ) { // no cast AI in multiplayer\n\t\treturn NULL;\n\t}\n\t// are bots enabled?\n\tif ( !trap_Cvar_VariableIntegerValue( "bot_enable" ) ) {\n\t\tG_Printf( S_COLOR_RED "ERROR: Unable to spawn %s, \'bot_enable\' is not set\\n", ent->classname );\n\t\treturn NULL;\n\t}\n\t//\n\t// make sure we have a free slot for them\n\t//\n\tif ( level.numPlayingClients + 1 > aicast_maxclients ) {\n\t\tG_Error( "Exceeded sv_maxclients (%d), unable to create %s\\n", aicast_maxclients, ent->classname );\n\t\treturn NULL;\n\t}\n\t//\n\t// add it to the list (only do this if everything else passed)\n\t//\n\n\tnewent = AICast_AddCastToGame( ent, castname, model, head, sex, color, handicap );\n\n\tif ( !newent ) {\n\t\treturn NULL;\n\t}\n\tclient = newent->client;\n\t//\n\t// setup the character..\n\t//\n\tcs = AICast_GetCastState( newent->s.number );\n\t//\n\tcs->aiCharacter = ent->aiCharacter;\n\t// used with g_airespawn\n\tcs->died = qfalse;\n\tcs->norespawn = qfalse;\n\n\tclient->ps.aiChar = ent->aiCharacter;\n\t// setup the attributes\n\tmemcpy( cs->attributes, attributes, sizeof( cs->attributes ) );\n\tppStr = &ent->aiAttributes;\n\tAICast_CheckLevelAttributes( cs, ent, ppStr );\n\t//\n\tAICast_SetAASIndex( cs );\n\t// make sure they face the right direction\n\tVectorCopy( ent->s.angles, cs->ideal_viewangles );\n\t// factor in the delta_angles\n\tfor ( j = 0; j < 3; j++ ) {\n\t\tcs->viewangles[j] = AngleMod( newent->s.angles[j] - SHORT2ANGLE( newent->client->ps.delta_angles[j] ) );\n\t}\n\tVectorCopy( ent->s.angles, newent->s.angles );\n\tVectorCopy( ent->s.origin, cs->startOrigin );\n\t//\n\tcs->lastEnemy = -1;\n\tcs->enemyNum = -1;\n\tcs->leaderNum = -1;\n\tcs->castScriptStatus.scriptGotoEnt = -1;\n\t//\n\tnewent->aiName = ent->aiName;\n\tnewent->aiTeam = ent->aiTeam;\n\tnewent->targetname = ent->targetname;\n\t//\n\tnewent->AIScript_AlertEntity = ent->AIScript_AlertEntity;\n\tnewent->aiInactive = ent->aiInactive;\n\tnewent->aiCharacter = cs->aiCharacter;\n\t//\n\t// parse the AI script for this character (if applicable)\n\tcs->aiFlags |= AIFL_CORPSESIGHTING;     // this is on by default for all characters, disabled if they have a "friendlysightcorpse" script event\n\tAICast_ScriptParse( cs );\n\t//\n\t// setup bounding boxes\n\t//VectorCopy( mins, client->ps.mins );\n\t//VectorCopy( maxs, client->ps.maxs );\n\tAIChar_SetBBox( newent, cs, qfalse );\n\tclient->ps.friction = cs->attributes[RUNNING_SPEED] / 300.0;\n\t//\n\t// clear weapons/ammo\n\tclient->ps.weapon = 0;\n\tmemcpy( client->ps.weapons, weaponInfo->startingWeapons, sizeof( weaponInfo->startingWeapons ) );\n\tmemcpy( client->ps.ammo, weaponInfo->startingAmmo, sizeof( client->ps.ammo ) );\n\t//\n\t// starting health\n\tif ( ent->health ) {\n\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = ent->health;\n\t} else {\n\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = cs->attributes[STARTING_HEALTH];\n\t}\n\n\tif ( g_gametype.integer <= GT_COOP ) {\n#if 0\n\t\tif ( newent->health < 125 ) {\n\t\t\tif ( g_gameskill.integer == GSKILL_EASY ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 75;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_MEDIUM ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 100;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_HARD ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 125;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_MAX ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 225;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tif ( g_gameskill.integer == GSKILL_MEDIUM ) {\n\t\t\t\tnewent->health *= 1.25;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_HARD ) {\n\t\t\t\tnewent->health *= 1.5;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_MAX ) {\n\t\t\t\tnewent->health *= 2;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif ( g_gameskill.integer == GSKILL_EASY ) {\n\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 1;\n\t\t\tcs->attributes[AIM_SKILL] = 0.6;\n\t\t\tcs->attributes[ATTACK_SKILL] = 0.6;\n\t\t} else if ( g_gameskill.integer == GSKILL_MEDIUM ) {\n\t\t\tcs->attributes[AIM_SKILL] = 0.75;\n\t\t\tcs->attributes[ATTACK_SKILL] = 0.75;\n\t\t} else if ( g_gameskill.integer == GSKILL_HARD ) {\n\t\t\tcs->attributes[AIM_SKILL] = 0.9;\n\t\t\tcs->attributes[ATTACK_SKILL] = 0.9;\n\t\t} else if ( g_gameskill.integer == GSKILL_MAX ) {\n\t\t\tcs->attributes[AIM_SKILL] = 1.0;\n\t\t\tcs->attributes[ATTACK_SKILL] = 1.0;\n\t\t}\n\n\t\tcs->respawnsleft = g_airespawn.integer;\n\t}\n\t//\n\tcs->weaponInfo = weaponInfo;\n\t//\n\tcs->lastThink = level.time;\n\t//\n\tnewent->pain = AICast_Pain;\n\tnewent->die = AICast_Die;\n\t//\n\t//update the attack inventory values\n\tAICast_UpdateBattleInventory( cs, cs->enemyNum );\n\n//----(SA)\tmake sure all clips are loaded so we don\'t hear everyone loading up\n//\t\t\t(we don\'t want to do this inside AICast_UpdateBattleInventory(), only on spawn or giveweapon)\n\tfor ( j = 0; j < WP_NUM_WEAPONS; j++ ) {\n\t\tFill_Clip( &client->ps, j );\n\t}\n//----(SA)\tend\n\n\t// select a weapon\n\tAICast_ChooseWeapon( cs, qfalse );\n\n\t//\n\t// set the default function, overwrite if necessary\n\tcs->aiFlags |= AIFL_JUST_SPAWNED;\n\tAIFunc_DefaultStart( cs );\n\t//\n\tnumcast++;\n\t//\n\treturn newent;\n}\n', 'caller_start': 344, 'file_path': 'code/game/ai_cast.c'}, {'type': 'caller_info', 'call_line': 1871, 'call_code': 'AICast_ScriptParse( AICast_GetCastState( ent->s.number ) )', 'caller_code': 'void ClientSpawn( gentity_t *ent ) {\n\tint index;\n\tvec3_t spawn_origin, spawn_angles;\n\tgclient_t   *client;\n\tint i;\n\tclientPersistant_t saved;\n\tclientSession_t savedSess;\n\tint persistant[MAX_PERSISTANT];\n\tgentity_t   *spawnPoint = NULL;\n\tgentity_t *tent;\n\tint flags;\n\tint savedPing;\n\t//int savedTeam;\n\tint savedAmmo[MAX_WEAPONS];\n\tint savedAmmoclip[MAX_WEAPONS];\n\tint savedWeapon = 0, savedWeaponstate = 0;\n\tint savedWeapons[MAX_WEAPONS] = { 0 };\n\tvec3_t saved_spawn_origin = { 0, 0, 0 }, saved_spawn_angles = { 0, 0, 0 };\n\tqboolean savedHasCoopSpawn = qtrue;\n\n\tindex = ent - g_entities;\n\tclient = ent->client;\n\n\tVectorClear(spawn_origin);\n\n\t// find a spawn point\n\t// do it before setting health back up, so farthest\n\t// ranging doesn\'t count this client\n\n\t// Ridah\n\tif ( ent->r.svFlags & SVF_CASTAI ) {\n\t\tspawnPoint = ent;\n\t\tVectorCopy( ent->s.origin, spawn_origin );\n\t\tspawn_origin[2] += 9;   // spawns seem to be sunk into ground?\n\t\tVectorCopy( ent->s.angles, spawn_angles );\n\t} else {\n\t\t// force team\n\t\tif ( client->sess.sessionTeam == TEAM_FREE ) {\n\t\t\tclient->sess.sessionTeam = TEAM_BLUE;\n\t\t}\n\n\t\t// force this player to AICHAR_NONE (for G_IsClientAI)\n\t\tent->aiCharacter = AICHAR_NONE;\n\n\t\tif ( !ent->client->pers.initialSpawn ) {\n\t\t\tent->aiName = "player";  // needed for script AI\n\t\t\tif ( client->sess.sessionTeam == TEAM_RED ) {\n\t\t\t\tent->aiTeam = AITEAM_NAZI;                        // member of axis\n\t\t\t} else if ( client->sess.sessionTeam == TEAM_BLUE ) {\n\t\t\t\tent->aiTeam = AITEAM_ALLIES;                        // member of allies\n\t\t\t}\n\t\t\tent->client->ps.teamNum = ent->aiTeam;\n\t\t\tAICast_ScriptParse( AICast_GetCastState( ent->s.number ) );\n\t\t}\n\n\t\tif ( client->sess.sessionTeam == TEAM_SPECTATOR ) {\n\t\t\tspawnPoint = SelectSpectatorSpawnPoint(\n\t\t\t\tspawn_origin, spawn_angles );\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// the first spawn should be at a good looking spot\n\t\t\t\tif ( !client->pers.initialSpawn && client->pers.localClient ) {\n\t\t\t\t\t// moved this down\n\t\t\t\t\t//client->pers.initialSpawn = qtrue;\n\t\t\t\t\tif ( client->sess.sessionTeam == TEAM_RED ) {\n\t\t\t\t\t\tif ( g_gametype.integer != GT_COOP_BATTLE ) {\n\t\t\t\t\t\t\tspawnPoint = SelectRandomAntiCoopSpawnPoint( ent, spawn_origin, spawn_angles );\n\t\t\t\t\t\t\tif ( !spawnPoint ) { // we need spawnpoints for the axis\n\t\t\t\t\t\t\t\tspawnPoint = SelectSpawnPoint(\n\t\t\t\t\t\t\t\t\tclient->ps.origin,\n\t\t\t\t\t\t\t\t\tspawn_origin, spawn_angles );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( g_gametype.integer <= GT_COOP ) {\n\t\t\t\t\t\t\tspawnPoint = SelectRandomCoopSpawnPoint( spawn_origin, spawn_angles );\n\t\t\t\t\t\t\tif ( !spawnPoint ) {\n\t\t\t\t\t\t\t\tG_Printf( "No coop spawnpoints found\\n" );\n\t\t\t\t\t\t\t\tspawnPoint = SelectInitialSpawnPoint( spawn_origin, spawn_angles, qfalse );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspawnPoint = SelectInitialSpawnPoint( spawn_origin, spawn_angles, qfalse );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tent->client->hasCoopSpawn = qfalse;\n\t\t\t\t} else {\n\t\t\t\t\t// note: on a dedicated server when the first player arrives and he\'s axis\n\t\t\t\t\t// no bots are alive, so no spawnpoint (bot) can be found\n\t\t\t\t\tif ( client->sess.sessionTeam == TEAM_RED && g_gametype.integer != GT_COOP_BATTLE ) {\n\t\t\t\t\t\tspawnPoint = SelectRandomAntiCoopSpawnPoint( ent, spawn_origin, spawn_angles );\n\t\t\t\t\t\tif ( !spawnPoint ) { // we need spawnpoints for the axis\n\t\t\t\t\t\t\tspawnPoint = SelectSpawnPoint( client->ps.origin, spawn_origin, spawn_angles );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( g_gametype.integer <= GT_COOP && ent->client->hasCoopSpawn ) {\n\t\t\t\t\t\t\t// TODO: select random spot from friends\n\t\t\t\t\t\t\tVectorCopy( client->coopSpawnPointOrigin, spawn_origin );\n\t\t\t\t\t\t\tVectorCopy( client->coopSpawnPointAngles, spawn_angles );\n\t\t\t\t\t\t\tspawnPoint = ent;\n\n\t\t\t\t\t\t\t// don\'t spawn near existing origin if possible\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspawnPoint = SelectRandomCoopSpawnPoint( spawn_origin, spawn_angles );\n\t\t\t\t\t\t\tif ( !spawnPoint ) {\n\t\t\t\t\t\t\t\tspawnPoint = SelectSpawnPoint( client->ps.origin, spawn_origin, spawn_angles );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tim needs to prevent bots from spawning at the initial point\n\t\t\t\t// on q3dm0...\n\t\t\t\tif ( ( spawnPoint->flags & FL_NO_BOTS ) && ( ent->r.svFlags & SVF_BOT ) ) {\n\t\t\t\t\tcontinue;   // try again\n\t\t\t\t}\n\t\t\t\t// just to be symetric, we have a nohumans option...\n\t\t\t\tif ( ( spawnPoint->flags & FL_NO_HUMANS ) && !( ent->r.svFlags & SVF_BOT ) ) {\n\t\t\t\t\tcontinue;   // try again\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t} while ( 1 );\n\t\t}\n\t\t\n\t\t// Ridah\n\t}\n\t// done.\n\n\tclient->pers.teamState.state = TEAM_ACTIVE;\n\n\n\t// toggle the teleport bit so the client knows to not lerp\n\tflags = ent->client->ps.eFlags & EF_TELEPORT_BIT;\n\tflags ^= EF_TELEPORT_BIT;\n\n\t// Save the Vote if player cast it\n\tflags |= ( client->ps.eFlags & EF_VOTED );\n\n\t// clear everything but the persistant data\n\tsaved = client->pers;\n\tsavedSess = client->sess;\n\tsavedPing = client->ps.ping;\n\t//savedTeam = client->ps.teamNum;\n\tfor ( i = 0 ; i < MAX_PERSISTANT ; i++ ) {\n\t\tpersistant[i] = client->ps.persistant[i];\n\t}\n\n\tif ( g_gametype.integer <= GT_COOP ) {\n\n\t\t// save weapons for respawn\n\t\tsavedWeapon = client->ps.weapon;\n\t\tsavedWeaponstate = client->ps.weaponstate;\n\n\t\tfor ( i = 0 ; i < MAX_WEAPONS ; i++ ) {\n\t\t\tsavedAmmo[i] = client->ps.ammo[i];\n\t\t\tsavedAmmoclip[i] = client->ps.ammoclip[i];\n\t\t}\n\t\tfor ( i = 0 ; i < ( MAX_WEAPONS / ( sizeof( int ) * 8 ) ) ; i++ ) {\n\t\t\tsavedWeapons[i] = client->ps.weapons[i];\n\t\t}\n\n\t\t// later on, we will disable this for speedrun\n\t\tif ( g_gametype.integer <= GT_COOP ) {\n\t\t\t// save the spawnpoint\n\t\t\tVectorCopy( client->coopSpawnPointOrigin, saved_spawn_origin );\n\t\t\tVectorCopy( client->coopSpawnPointAngles, saved_spawn_angles );\n\t\t\tsavedHasCoopSpawn = client->hasCoopSpawn;\n\t\t}\n\t}\n\n\t// clear everything\n\tmemset( client, 0, sizeof( *client ) );\n\n\tclient->pers = saved;\n\tclient->sess = savedSess;\n\tclient->ps.ping = savedPing;\n\tclient->ps.teamNum = ent->aiTeam; /*savedTeam;*/\n\tfor ( i = 0 ; i < MAX_PERSISTANT ; i++ ) {\n\t\tclient->ps.persistant[i] = persistant[i];\n\t}\n\n\tif ( g_gametype.integer <= GT_COOP ) {\n\n\t\t// restore weapons after a respawn\n\t\tclient->ps.weapon = savedWeapon;\n\t\tclient->ps.weaponstate = savedWeaponstate;\n\n\t\tfor ( i = 0 ; i < MAX_WEAPONS ; i++ ) {\n\t\t\tclient->ps.ammo[i] = savedAmmo[i];\n\t\t\tclient->ps.ammoclip[i] = savedAmmoclip[i];\n\t\t}\n\t\tfor ( i = 0 ; i < ( MAX_WEAPONS / ( sizeof( int ) * 8 ) ) ; i++ ) {\n\t\t\tclient->ps.weapons[i] = savedWeapons[i];\n\t\t}\n\n\t\t// later on, we will disable this for speedrun\n\t\tif ( g_gametype.integer <= GT_COOP ) {\n\t\t\t// restore the spawnpoint\n\t\t\tVectorCopy( saved_spawn_origin, client->coopSpawnPointOrigin );\n\t\t\tVectorCopy( saved_spawn_angles, client->coopSpawnPointAngles );\n\t\t\tclient->hasCoopSpawn = savedHasCoopSpawn;\n\t\t}\n\t}\n\n\t// increment the spawncount so the client will detect the respawn\n\tclient->ps.persistant[PERS_SPAWN_COUNT]++;\n\tclient->ps.persistant[PERS_TEAM] = client->sess.sessionTeam;\n\n\tclient->airOutTime = level.time + 12000;\n\n\t// clear entity values\n\tclient->ps.stats[STAT_MAX_HEALTH] = client->pers.maxHealth;\n\tclient->ps.eFlags = flags;\n\t// MrE: use capsules for AI and player\n\tclient->ps.eFlags |= EF_CAPSULE;\n\n\tent->s.groundEntityNum = ENTITYNUM_NONE;\n\tent->client = &level.clients[index];\n\tent->takedamage = qtrue;\n\tent->inuse = qtrue;\n\tif ( !( ent->r.svFlags & SVF_CASTAI ) ) {\n\t\tent->classname = "player";\n\t}\n\tent->r.contents = CONTENTS_BODY;\n\n\t// RF, AI should be clipped by monsterclip brushes\n\tif ( ent->r.svFlags & SVF_CASTAI ) {\n\t\tent->clipmask = MASK_PLAYERSOLID | CONTENTS_MONSTERCLIP;\n\t} else {\n\t\tent->clipmask = MASK_PLAYERSOLID;\n\t}\n\n\tent->die = player_die;\n\tent->waterlevel = 0;\n\tent->watertype = 0;\n\tent->flags = 0;\n\n\t// freeze the players if needed\n\tif ( g_freeze.integer && g_gametype.integer <= GT_COOP && !( ent->r.svFlags & SVF_CASTAI ) ) {\n\t\tint frozen = 0;\n\t\tint i = 0;\n\t\tgentity_t *player;\n\n\t\tfor ( i = 0 ; i < g_maxclients.integer ; i++ ) {\n\t\t\tplayer = &g_entities[i];\n\n\t\t\tif ( !player || !player->inuse || player == ent ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( player->r.svFlags & SVF_CASTAI ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( player->client->ps.eFlags & EF_FROZEN ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrozen++;\n\t\t}\n\n\t\t// only freeze them when there are still others not frozen\n\t\tif ( frozen && client->ps.persistant[PERS_SPAWN_COUNT] > 1 ) {\n\t\t\tclient->ps.eFlags |= EF_FROZEN;\n\t\t\tent->flags |= FL_NOTARGET;\n\t\t}\n\t}\n\n\tVectorCopy( playerMins, ent->r.mins );\n\tVectorCopy( playerMaxs, ent->r.maxs );\n\n\t// Ridah, setup the bounding boxes and viewheights for prediction\n\tVectorCopy( ent->r.mins, client->ps.mins );\n\tVectorCopy( ent->r.maxs, client->ps.maxs );\n\n\tclient->ps.crouchViewHeight = CROUCH_VIEWHEIGHT;\n\tclient->ps.standViewHeight = DEFAULT_VIEWHEIGHT;\n\tclient->ps.deadViewHeight = DEAD_VIEWHEIGHT;\n\n\tclient->ps.crouchMaxZ = client->ps.maxs[2] - ( client->ps.standViewHeight - client->ps.crouchViewHeight );\n\n\tclient->ps.runSpeedScale = 0.8;\n//\tclient->ps.sprintSpeedScale = 1.20;\n\tclient->ps.sprintSpeedScale = 1.1;  // (SA) trying new value\n\tclient->ps.crouchSpeedScale = 0.25;\n\n\t// Rafael\n\tclient->ps.sprintTime = 20000;\n\tclient->ps.sprintExertTime = 0;\n\n\tclient->ps.friction = 1.0;\n\t// done.\n\n\tclient->ps.clientNum = index;\n\n\t// DHM - Nerve :: Add appropriate weapons\n/*\n\tif ( g_gametype.integer == GT_WOLF ) {\n\t\tSetWolfSpawnWeapons( client ); // JPW NERVE -- increases stats[STAT_MAX_HEALTH] based on # of medics in game\n\t}\n\t// dhm - end\n*/\n\n\t// give the player some basic stuff\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tif ( !Q_stricmp( ent->classname, "player" ) ) {\n\t\t\tSetCoopSpawnWeapons( client );\n\t\t}\n\t}\n\n\tclient->pers.initialSpawn = qtrue;\n\n\t// Note to Ryan:\n\t// had to add this because key word giveweapon to player is causing a fatal crash\n\t// This is only a quick fix for the beach map\n/*\n\tif (!(ent->r.svFlags & SVF_CASTAI) && level.scriptAI && strstr (level.scriptAI, "beach assault"))\n\t{\n\t\tCOM_BitSet( client->ps.weapons, WP_THOMPSON );\n\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_THOMPSON)] = 100;\n\n\t\tCOM_BitSet( client->ps.weapons, WP_GRENADE_PINEAPPLE );\n\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_GRENADE_PINEAPPLE)] = 5;\n\n\t\tclient->ps.weapon = WP_THOMPSON;\n\t\tclient->ps.weaponstate = WEAPON_READY;\n\t}\n*/\n\t//----(SA) no longer giving the player any default stuff\n\n//\tCOM_BitSet( client->ps.weapons, WP_MP40 );\n//\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_MP40)] = 100;\n\n//\tif ( g_gametype.integer == GT_SINGLE_PLAYER ) {\n//\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_LUGER)] = 50;\n//\t} else {\n//\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_LUGER)] = 100;\n//\t}\n\n//\tCOM_BitSet( client->ps.weapons, WP_GAUNTLET );\n//\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_GAUNTLET)] = -1;\n\n\t// health will count down towards max_health\n//\tent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] * 1.25;\n\n// JPW NERVE ***NOTE*** the following line is order-dependent and must *FOLLOW* SetWolfSpawnWeapons() in multiplayer\n// SetWolfSpawnWeapons() now adds medic team bonus and stores in ps.stats[STAT_MAX_HEALTH].\n\tent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH];\n\n\tG_SetOrigin( ent, spawn_origin );\n\tVectorCopy( spawn_origin, client->ps.origin );\n\n\t// the respawned flag will be cleared after the attack and jump keys come up\n\tclient->ps.pm_flags |= PMF_RESPAWNED;\n\n\ttrap_GetUsercmd( client - level.clients, &ent->client->pers.cmd );\n\tSetClientViewAngle( ent, spawn_angles );\n\n\t// don\'t allow full run speed for a bit\n\tclient->ps.pm_flags |= PMF_TIME_KNOCKBACK;\n\tclient->ps.pm_time = 100;\n\n\tclient->respawnTime = level.time;\n\tclient->inactivityTime = level.time + g_inactivity.integer * 1000;\n\tclient->latched_buttons = 0;\n\tclient->latched_wbuttons = 0;   //----(SA)\tadded\n\n\tif (!level.intermissiontime) {\n\t\tif (ent->client->sess.sessionTeam != TEAM_SPECTATOR) {\n\t\t\t// don\'t kill our coop friends !\n\t\t\t// FIXME: make sure players dont get stuck in each other\n\t\t\t//if ( !g_coop.integer )\n\t\t\t\tG_KillBox(ent);\n\n\t\t\t// force the base weapon up\n//\t\t\tclient->ps.weapon = WP_MACHINEGUN;\n//\t\t\tclient->ps.weaponstate = WEAPON_READY;\n\n\t\t\t// fire the targets of the spawn point\n\t\t\tif ( g_gametype.integer < GT_SINGLE_PLAYER ) {\n\t\t\t\tG_UseTargets( spawnPoint, ent );\n\t\t\t}\n\t\t\t// select the highest weapon number available, after any spawn given items have fired\n//\t\t\tclient->ps.weapon = 1;\n//\t\t\tfor (i = WP_NUM_WEAPONS - 1 ; i > 0 ; i--) {\n//\t\t\t\tif (client->ps.stats[STAT_WEAPONS] & (1 << i)) {\n//\t\t\t\t\tclient->ps.weapon = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\n\t\t\t// positively link the client, even if the command times are weird\n\t\t\tVectorCopy(ent->client->ps.origin, ent->r.currentOrigin);\n\n\t\t\ttent = G_TempEntity(ent->client->ps.origin, EV_PLAYER_TELEPORT_IN);\n\t\t\ttent->s.clientNum = ent->s.clientNum;\n\n\t\t\ttrap_LinkEntity (ent);\n\t\t}\n\t} else {\n\t\t// move players to intermission\n\t\tMoveClientToIntermission(ent);\n\t}\n\n\t// run a client frame to drop exactly to the floor,\n\t// initialize animations and other things\n\tclient->ps.commandTime = level.time - 100;\n\tent->client->pers.cmd.serverTime = level.time;\n\tClientThink( ent - g_entities );\n\n\t// Spectator\'s should probably have 0 health.\n\tif ( G_IsClientOnTeam( ent, TEAM_SPECTATOR ) ) {\n\t\tent->health = 0;\n\t}\n\n\t// run the presend to set anything else, follow spectators wait\n\t// until all clients have been reconnected after map_restart\n\tif ( ent->client->sess.spectatorState != SPECTATOR_FOLLOW ) {\n\t\tClientEndFrame( ent );\n\t}\n\n\t// clear entity state values\n\tBG_PlayerStateToEntityState( &client->ps, &ent->s, qtrue );\n\n\t// et sdk antilag\n\tG_ResetMarkers( ent );\n}\n', 'caller_start': 1819, 'file_path': 'code/game/g_client.c'}]
 10:16:42 PM - [INFO]: Executing tool: caller_info.find_caller_for_func_file({'file_path': 'code/game/ai_cast_script.c', 'func_name': 'AICast_ScriptLoad', 'project_dir': '/storage/result/Part2_result/github/CVE-2019-25104/old_repos/rtcwcoop-rtcwcoop_39bcb1c'})
 10:16:42 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 1422, 'call_code': 'AICast_ScriptLoad()', 'caller_code': 'void G_InitGame( int levelTime, int randomSeed, int restart ) {\n\tint i;\n\tint fps;\n\tint r;\n\n\t//if ( trap_Cvar_VariableIntegerValue( "g_gametype" ) != GT_SINGLE_PLAYER ) {\n\tG_Printf( "------- Game Initialization -------\\n" );\n\tG_Printf( "gamename: %s\\n", GAMEVERSION );\n\tG_Printf( "gamedate: %s\\n", PRODUCT_DATE );\n\t//}\n\n\tsrand( randomSeed );\n\n\tG_RegisterCvars();\n\n\t// g_random is a value from 1 - 10 (1 and 10 included)\n\t// is used in the scripting to randomize entity locations, and more\n\tr = ( rand() % 10 ) + 1;\n\ttrap_Cvar_Set( "g_random", va( "%d", r ) );\n\n\t// Xian enforcemaxlives stuff\n\t/*\n\twe need to clear the list even if enforce maxlives is not active\n\tin cas ethe g_maxlives was changed, and a map_restart happened\n\t*/\n\tClearMaxLivesGUID();\n\n\t// just for verbosity\n\tif ( g_enforcemaxlives.integer && ( g_maxlives.integer > 0 ) ) {\n\t\tG_Printf( "EnforceMaxLives-Cleared GUID List\\n" );\n\t}\n\n#ifndef _ADMINS\n\tG_ProcessIPBans();\n#endif\n\n\tG_InitMemory();\n\n\t// NERVE - SMF - intialize gamestate\n\tif ( g_gamestate.integer == GS_INITIALIZE ) {\n\t\t//if ( g_noTeamSwitching.integer ) {\n\t\t//        trap_Cvar_Set( "gamestate", va( "%i", GS_WAITING_FOR_PLAYERS ) );\n\t\t//} else {\n\t\ttrap_Cvar_Set( "gamestate", va( "%i", GS_WARMUP ) );\n\t\t//}\n\t}\n\n\t// set some level globals\n\tmemset( &level, 0, sizeof( level ) );\n\tlevel.time = levelTime;\n\tlevel.startTime = levelTime;\n\n\tlevel.lastSpawnSave = levelTime;\n\tlevel.lastBattleScorecheck = levelTime;\n\n\tlevel.numSecrets = 0;   //----(SA)\tadded\n\n\t// don\'t need it.\n//\tlevel.snd_fry = G_SoundIndex("sound/player/fry.wav");\t// FIXME standing in lava / slime\n\n\tlevel.bulletRicochetSound = G_SoundIndex( "bulletRicochet" );\n\n\tlevel.snipersound = G_SoundIndex( "sound/weapons/mauser/mauserf1.wav" );\n\n\t//----(SA)\tadded sound caching\n\tlevel.knifeSound[0] = G_SoundIndex( "sound/weapons/knife/knife_hitwall1.wav" );\n\t//----(SA)\tend\n\n\t// RF, init the anim scripting\n\tlevel.animScriptData.soundIndex = G_SoundIndex;\n\tlevel.animScriptData.playSound = G_AnimScriptSound;\n\n\tG_InitWorldSession();\n\n\t// initialize all entities for this game\n\tmemset( g_entities, 0, MAX_GENTITIES * sizeof( g_entities[0] ) );\n\tlevel.gentities = g_entities;\n\n\t// initialize all clients for this game\n\tlevel.maxclients = g_maxclients.integer;\n\tmemset( g_clients, 0, MAX_CLIENTS * sizeof( g_clients[0] ) );\n\tlevel.clients = g_clients;\n\n\t// set client fields on player ents\n\tfor ( i = 0 ; i < level.maxclients ; i++ ) {\n\t\tg_entities[i].client = level.clients + i;\n\t}\n\n\t// always leave room for the max number of clients,\n\t// even if they aren\'t all used, so numbers inside that\n\t// range are NEVER anything but clients\n\tlevel.num_entities = MAX_CLIENTS;\n\n\tfor ( i=0 ; i<MAX_CLIENTS ; i++ ) {\n\t\tg_entities[i].classname = "clientslot";\n\t}\n\n\t// let the server system know where the entites are\n\ttrap_LocateGameData( level.gentities, level.num_entities, sizeof( gentity_t ),\n\t\t\t\t\t\t &level.clients[0].ps, sizeof( level.clients[0] ) );\n\n\t// Ridah\n\tif ( g_gametype.integer <= GT_SINGLE_PLAYER ) {\n\t\tchar s[10];\n\n\t\t// Ridah, initialize cast AI system\n\t\t// DHM - Nerve :: Moved this down so that it only happens in SinglePlayer games\n\t\tAICast_Init();\n\t\t// done.\n\n\t\tAICast_ScriptLoad();\n\n\t\ttrap_Cvar_VariableStringBuffer( "g_missionStats", s, sizeof( s ) );\n\t\tif ( strlen( s ) < 1 ) {\n\t\t\t// g_missionStats is used to get the player to press a key to begin\n\t\t\ttrap_Cvar_Set( "g_missionStats", "xx" );\n\t\t}\n\n\t\tfor ( i = 0; i < 8; i++ )     {  // max objective cvars: 8 (FIXME: use #define somewhere)\n\t\t\ttrap_Cvar_Set( va( "g_objective%i", i + 1 ), "0" );   // clear the objective ROM cvars\n\t\t}\n\n\t\tif ( g_gametype.integer == GT_SINGLE_PLAYER ) {\n\t\t\ttrap_Cvar_Set( "cg_youGotMail", "0" ); // set flag to draw icon\n\t\t} else {\n\t\t\ttrap_SendServerCommand( -1, "yougotmail 0\\n" );\n\t\t}\n\t}\n\n\tfps = trap_Cvar_VariableIntegerValue( "sv_fps" );\n\n\tif ( fps > 0 && g_limbotime.integer <= ( 1000 / fps ) ) {\n\t\ttrap_Cvar_Set( "g_limbotime", "1000" );\n\t\tG_Printf( "WARNING: g_limbotime <= (1000 / sv_fps), forcing to 1000 (one second)\\n" );\n\t}\n\n\tif ( g_gametype.integer == GT_COOP_BATTLE ) {\n\t\ttrap_Cvar_Set( "g_friendlyfire", "2" );\n\t\t//trap_Cvar_Set("g_spawnpoints", "1");\n#ifdef INGAME_CUTSCENES\n\t\ttrap_Cvar_Set( "g_skipcutscenes", "1" );\n#endif\n\t\ttrap_Cvar_Set( "g_freeze", "0" );\n\t\t//trap_Cvar_Set("g_warmup", "20");\n\t\t//trap_Cvar_Set("g_reinforce", "0");\n\t\ttrap_Cvar_Set( "sv_maxcoopclients", "2" );\n\t\ttrap_Cvar_Set( "g_teleporttime", "30000" );\n\t} else {\n\t\t//trap_Cvar_Set("g_warmup", "0");\n\t\t//trap_Cvar_Set("g_warmup", "20");\n\t}\n\n\tif ( g_gametype.integer == GT_COOP_SPEEDRUN ) {\n\t\tchar mapname[MAX_QPATH];\n\t\tchar maptimelimit[MAX_QPATH];\n\t\tfloat newtimelimit = 0.0;\n\n\t\ttrap_Cvar_VariableStringBuffer( "mapname", mapname, sizeof( mapname ) );\n\t\ttrap_Cvar_VariableStringBuffer( va( "g_%s_timelimit", mapname ), maptimelimit, sizeof( maptimelimit ) );\n\n\t\tnewtimelimit = atof( maptimelimit );\n\n\t\tif ( newtimelimit ) {\n\t\t\ttrap_Cvar_Set( "timelimit", va( "%f", newtimelimit ) );\n\t\t} else {\n\t\t\ttrap_Cvar_Set( "timelimit", "20" );\n\t\t}\n\t\tG_Printf( "Timelimit is: %f\\n", g_timelimit.value );\n\t}\n\n\tG_Script_ScriptLoad();\n\t// done.\n\n\t// reserve some spots for dead player bodies\n\tInitBodyQue();\n\n\tClearRegisteredItems();\n\n\t// parse the key/value pairs and spawn gentities\n\tG_SpawnEntitiesFromString();\n\n\t// create the camera entity that will communicate with the scripts\n\tG_SpawnScriptCamera();\n\n\t// general initialization\n\tG_FindTeams();\n\n\tSaveRegisteredItems();\n\n\tif ( g_gametype.integer <= GT_SINGLE_PLAYER || trap_Cvar_VariableIntegerValue( "com_buildScript" ) ) {\n\t\tG_ModelIndex( SP_PODIUM_MODEL );\n\t}\n\n\tif ( trap_Cvar_VariableIntegerValue( "bot_enable" ) ) {\n\t\tBotAISetup( restart );\n\t\tBotAILoadMap( restart );\n//\t\tG_InitBots( restart );\n\t}\n\n\tG_RemapTeamShaders();\n\n\ttrap_SetConfigstring( CS_INTERMISSION, "" );\n\n\t// fretn\n\tG_LoadArenas();\n}\n', 'caller_start': 1312, 'file_path': 'code/game/g_main.c'}]
 10:16:54 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'PackLinuxElf64.unpack'}}]
 10:16:54 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'PackLinuxElf64.unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:16:54 PM - [INFO]: Tool result: None
 10:17:09 PM - [INFO]: http://localhost:2003 Joern service is available
 10:17:09 PM - [INFO]: http://localhost:2000 Joern service is available
 10:17:17 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'DumpKnownEscape'}}]
 10:17:17 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'DumpKnownEscape', 'project_dir': '/storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})
 10:17:17 PM - [INFO]: Tool result: None
 10:17:23 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'isomedia/media.c', 'func_name': 'Media_RewriteODFrame'}}, {'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'isomedia/isom_nalu.c', 'func_name': 'gf_isom_nalu_sample_rewrite'}}, {'tool': 'caller_info.find_caller_for_func_file', 'params': {'file_path': 'isomedia/media.c', 'func_name': 'Media_RewriteODFrame'}}]
 10:17:24 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'isomedia/media.c', 'func_name': 'Media_RewriteODFrame', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:17:24 PM - [INFO]: Tool result: None
 10:17:24 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'Media_RewriteODFrame', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:17:24 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}\n', 'start_line': 31, 'end_line': 229, 'full_name': 'Media_RewriteODFrame', 'file_path': 'src/isomedia/media_odf.c'}]
 10:17:24 PM - [WARNING]: No matching file found in cache for: 
/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec
isomedia/isom_nalu.c
 10:17:24 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'isomedia/isom_nalu.c', 'func_name': 'gf_isom_nalu_sample_rewrite', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:17:24 PM - [INFO]: Tool result: None
 10:17:24 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'gf_isom_nalu_sample_rewrite', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:17:24 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'GF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_BitStream *sei_suffix_bs = NULL;\n\tBool ps_transfered = GF_FALSE;\n\tu32 nal_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\tu8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tGF_ISOSample *base_samp;\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+base_samp->dataLength) ) {\n\t\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+base_samp->dataLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\n\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\ttile_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+tile_samp->dataLength) ) {\n\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+tile_samp->dataLength;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->child_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(mdia, sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (!entry) return GF_BAD_PARAM;\n\n\t//this is a compatible HEVC, don\'t insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config && entry->avc_config->config)\n\t\t\tnal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\t\tnal_unit_size_field = entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\t//setup PS rewriter\n\tif (!mdia->nalu_ps_bs)\n\t\tmdia->nalu_ps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_seek(mdia->nalu_ps_bs, 0);\n\n\t//setup sample reader\n\tif (mdia->in_sample_buffer_alloc<sample->dataLength) {\n\t\tmdia->in_sample_buffer_alloc = sample->dataLength;\n\t\tmdia->in_sample_buffer = gf_realloc(mdia->in_sample_buffer, sample->dataLength);\n\t}\n\tmemcpy(mdia->in_sample_buffer, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) {\n\t\tmdia->nalu_parser = gf_bs_new(mdia->in_sample_buffer, sample->dataLength, GF_BITSTREAM_READ);\n\t\tif (!mdia->nalu_parser && sample->data) return GF_ISOM_INVALID_FILE;\n\t} else {\n\t\te = gf_bs_reassign_buffer(mdia->nalu_parser, mdia->in_sample_buffer, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\t//setup output\n\tif (!mdia->nalu_out_bs) {\n\t\tu8 *output;\n\t\tu32 outSize;\n\t\tmdia->nalu_out_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_get_content(mdia->nalu_out_bs, &output, &outSize);\n\t}\n\n\tgf_bs_reassign_buffer(mdia->nalu_out_bs, sample->data, sample->alloc_size ? sample->alloc_size : sample->dataLength);\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don\'t write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don\'t insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0xF0 , 8); /*7 "all supported NALUs" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\tBool has_vps = GF_FALSE;\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc, &has_vps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc, &has_vps);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (! ps_transfered) {\n\t\t\t\t\tnal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\t\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tps_transfered = GF_TRUE;\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (! ps_transfered)\n\t\t{\n\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t}\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\t\treturn GF_OK;\n\t}\n\n\tif (!mdia->tmp_nal_copy_buffer) {\n\t\tmdia->tmp_nal_copy_buffer = gf_malloc(sizeof(char) * 4096);\n\t\tmdia->tmp_nal_copy_buffer_alloc = 4096;\n\t}\n\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tnal_size = gf_bs_read_int(mdia->nalu_parser, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(mdia->nalu_parser) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char)*nal_size);\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tGF_BitStream *write_to_bs = mdia->nalu_out_bs;\n#endif\n\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tswitch (nal_type) {\n\t\t\t/*we already wrote AU delim, and we trash aggregators*/\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FF_AGGREGATOR:\n\t\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-2);\n\t\t\t\tcontinue;\n\n\t\t\t//extractor\n\t\t\tcase GF_HEVC_NALU_FF_EXTRACTOR:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(mdia->nalu_out_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\tif (sei_suffix_bs) gf_bs_del(sei_suffix_bs);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid nal size %d in sample %d\\n", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tcase GF_AVC_NALU_FF_AGGREGATOR:\n\t\t\t/*we already wrote this stuff, and we trash aggregators*/\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase GF_AVC_NALU_FF_EXTRACTOR:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (!ps_transfered) {\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(mdia->nalu_out_bs, sei_suffix_bs, GF_FALSE);\n\t}\n\t/*done*/\n\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (sei_suffix_bs)\n\t\tgf_bs_del(sei_suffix_bs);\n\n\treturn e;\n}\n', 'start_line': 401, 'end_line': 845, 'full_name': 'gf_isom_nalu_sample_rewrite', 'file_path': 'src/isomedia/avc_ext.c'}]
 10:17:24 PM - [INFO]: Executing tool: caller_info.find_caller_for_func_file({'file_path': 'isomedia/media.c', 'func_name': 'Media_RewriteODFrame', 'project_dir': '/storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})
 10:17:24 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 655, 'call_code': 'Media_RewriteODFrame(mdia, *samp)', 'caller_code': "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n", 'caller_start': 467, 'file_path': 'src/isomedia/media.c'}]
 10:17:27 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'PackLinuxElf64', 'func_name': 'unpack'}}]
 10:17:27 PM - [WARNING]: No matching file found in cache for: 
/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f
PackLinuxElf64
 10:17:27 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'PackLinuxElf64', 'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:17:27 PM - [INFO]: Tool result: None
 10:17:27 PM - [ERROR]: [Analysis ERROR] Root cause analysis failed: Internal Server Error
 10:17:27 PM - [ERROR]: Analysis failed: [Analysis ERROR] Root cause analysis failed
NoneType: None
 10:17:27 PM - [ERROR]: Workflow ended in error state: Analysis failed: [Analysis ERROR] Root cause analysis failed
 10:17:28 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:17:28 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', 'start_line': 236, 'end_line': 261, 'full_name': 'PackCom.unpack:void(OutputFile*)', 'file_path': 'src/p_com.cpp'}, {'type': 'function_def', 'code': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', 'start_line': 401, 'end_line': 470, 'full_name': 'PackDjgpp2.unpack:void(OutputFile*)', 'file_path': 'src/p_djgpp2.cpp'}, {'type': 'function_def', 'code': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', 'start_line': 688, 'end_line': 806, 'full_name': 'PackExe.unpack:void(OutputFile*)', 'file_path': 'src/p_exe.cpp'}]
 10:17:33 PM - [INFO]: Finalizing report.
 10:17:48 PM - [INFO]: http://localhost:2001 Joern service is available
 10:17:48 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'PackLinuxElf64.unpack'}}]
 10:17:49 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'PackLinuxElf64.unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:17:49 PM - [INFO]: Tool result: None
 10:17:50 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'PackLinuxElf64', 'func_name': 'unpack'}}]
 10:17:50 PM - [WARNING]: No matching file found in cache for: 
/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f
PackLinuxElf64
 10:17:50 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'PackLinuxElf64', 'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:17:50 PM - [INFO]: Tool result: None
 10:17:50 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:17:50 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', 'start_line': 236, 'end_line': 261, 'full_name': 'PackCom.unpack:void(OutputFile*)', 'file_path': 'src/p_com.cpp'}, {'type': 'function_def', 'code': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', 'start_line': 401, 'end_line': 470, 'full_name': 'PackDjgpp2.unpack:void(OutputFile*)', 'file_path': 'src/p_djgpp2.cpp'}, {'type': 'function_def', 'code': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', 'start_line': 688, 'end_line': 806, 'full_name': 'PackExe.unpack:void(OutputFile*)', 'file_path': 'src/p_exe.cpp'}]
 10:17:57 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'DumpKnownEscape'}}]
 10:17:58 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'DumpKnownEscape', 'project_dir': '/storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})
 10:17:58 PM - [INFO]: Tool result: None
 10:18:14 PM - [INFO]: http://localhost:2001 Joern service is available
 10:18:14 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'PackLinuxElf64.unpack'}}]
 10:18:15 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'PackLinuxElf64.unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:15 PM - [INFO]: Tool result: None
 10:18:15 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'PackLinuxElf64', 'func_name': 'unpack'}}]
 10:18:15 PM - [WARNING]: No matching file found in cache for: 
/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f
PackLinuxElf64
 10:18:15 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'PackLinuxElf64', 'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:15 PM - [INFO]: Tool result: None
 10:18:15 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:15 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', 'start_line': 236, 'end_line': 261, 'full_name': 'PackCom.unpack:void(OutputFile*)', 'file_path': 'src/p_com.cpp'}, {'type': 'function_def', 'code': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', 'start_line': 401, 'end_line': 470, 'full_name': 'PackDjgpp2.unpack:void(OutputFile*)', 'file_path': 'src/p_djgpp2.cpp'}, {'type': 'function_def', 'code': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', 'start_line': 688, 'end_line': 806, 'full_name': 'PackExe.unpack:void(OutputFile*)', 'file_path': 'src/p_exe.cpp'}]
 10:18:37 PM - [INFO]: http://localhost:2001 Joern service is available
 10:18:37 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'PackLinuxElf64.unpack'}}]
 10:18:38 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'PackLinuxElf64.unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:38 PM - [INFO]: Tool result: None
 10:18:38 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'PackLinuxElf64', 'func_name': 'unpack'}}]
 10:18:38 PM - [WARNING]: No matching file found in cache for: 
/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f
PackLinuxElf64
 10:18:38 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'PackLinuxElf64', 'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:38 PM - [INFO]: Tool result: None
 10:18:38 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:38 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', 'start_line': 236, 'end_line': 261, 'full_name': 'PackCom.unpack:void(OutputFile*)', 'file_path': 'src/p_com.cpp'}, {'type': 'function_def', 'code': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', 'start_line': 401, 'end_line': 470, 'full_name': 'PackDjgpp2.unpack:void(OutputFile*)', 'file_path': 'src/p_djgpp2.cpp'}, {'type': 'function_def', 'code': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', 'start_line': 688, 'end_line': 806, 'full_name': 'PackExe.unpack:void(OutputFile*)', 'file_path': 'src/p_exe.cpp'}]
 10:18:59 PM - [INFO]: http://localhost:2001 Joern service is available
 10:18:59 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_name', 'params': {'func_name': 'PackLinuxElf64.unpack'}}]
 10:18:59 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'PackLinuxElf64.unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:59 PM - [INFO]: Tool result: None
 10:18:59 PM - [INFO]: Tools query: [{'tool': 'func_info.fetch_func_by_file_name', 'params': {'file_path': 'PackLinuxElf64', 'func_name': 'unpack'}}]
 10:18:59 PM - [WARNING]: No matching file found in cache for: 
/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f
PackLinuxElf64
 10:18:59 PM - [INFO]: Executing tool: func_info.fetch_func_by_file_name({'file_path': 'PackLinuxElf64', 'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:18:59 PM - [INFO]: Tool result: None
 10:19:00 PM - [INFO]: Executing tool: func_info.fetch_func_by_name({'func_name': 'unpack', 'project_dir': '/storage/result/Part2_result/github/CVE-2018-11243/old_repos/upx-upx_614c86f'})
 10:19:00 PM - [INFO]: Tool result: [{'type': 'function_def', 'code': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', 'start_line': 236, 'end_line': 261, 'full_name': 'PackCom.unpack:void(OutputFile*)', 'file_path': 'src/p_com.cpp'}, {'type': 'function_def', 'code': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', 'start_line': 401, 'end_line': 470, 'full_name': 'PackDjgpp2.unpack:void(OutputFile*)', 'file_path': 'src/p_djgpp2.cpp'}, {'type': 'function_def', 'code': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', 'start_line': 688, 'end_line': 806, 'full_name': 'PackExe.unpack:void(OutputFile*)', 'file_path': 'src/p_exe.cpp'}]
 10:19:02 PM - [ERROR]: [Analysis ERROR] Root cause analysis failed: Internal Server Error
 10:19:02 PM - [ERROR]: Analysis failed: [Analysis ERROR] Root cause analysis failed
NoneType: None
 10:19:02 PM - [ERROR]: Workflow ended in error state: Analysis failed: [Analysis ERROR] Root cause analysis failed
 10:29:25 PM - [INFO]: Tools query: [{'tool': 'caller_info.find_caller_for_func', 'params': {'func_name': 'DumpKnownEscape'}}]
 10:29:26 PM - [INFO]: Executing tool: caller_info.find_caller_for_func({'func_name': 'DumpKnownEscape', 'project_dir': '/storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})
 10:29:26 PM - [INFO]: Tool result: [{'type': 'caller_info', 'call_line': 1434, 'call_code': 'DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal)', 'caller_code': 'BOOL CEAnsi::OurWriteConsoleW(HANDLE hConsoleOutput, const VOID *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved, bool bInternal /*= false*/)\n{\n\tORIGINAL_KRNL(WriteConsoleW);\n\tBOOL lbRc = FALSE;\n\t//ExtWriteTextParm wrt = {sizeof(wrt), ewtf_None, hConsoleOutput};\n\tbool bIsConOut = false;\n\tbool bIsAnsi = false;\n\n\tFIRST_ANSI_CALL(static_cast<const BYTE*>(lpBuffer), nNumberOfCharsToWrite);\n\n#if 0\n\t// Store prompt(?) for clink 0.1.1\n\tif ((gnAllowClinkUsage == 1) && nNumberOfCharsToWrite && lpBuffer && gpszLastWriteConsole && gcchLastWriteConsoleMax)\n\t{\n\t\tsize_t cchMax = std::min(gcchLastWriteConsoleMax-1,nNumberOfCharsToWrite);\n\t\tgpszLastWriteConsole[cchMax] = 0;\n\t\twmemmove(gpszLastWriteConsole, (const wchar_t*)lpBuffer, cchMax);\n\t}\n#endif\n\n\t// In debug builds: Write to debug console all console Output\n\tconst auto ansiIndex = DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal);\n\n#ifdef _DEBUG\n\tstruct AnsiDuration  // NOLINT(cppcoreguidelines-special-member-functions)\n\t{\n\t\tconst int ansiIndex_;\n\t\tconst std::chrono::steady_clock::time_point startTime_;\n\n\t\tAnsiDuration(const int ansiIndex)\n\t\t\t: ansiIndex_(ansiIndex), startTime_(std::chrono::steady_clock::now())\n\t\t{\n\t\t}\n\n\t\t~AnsiDuration()\n\t\t{\n\t\t\tconst auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - startTime_);\n\t\t\twchar_t info[80] = L"";\n\t\t\tmsprintf(info, countof(info), L"[%u] AnsiDump #%u duration(ms): %u\\n", GetCurrentThreadId(), ansiIndex_, duration.count());\n\t\t\tOutputDebugStringW(info);\n\t\t}\n\t};\n\tAnsiDuration duration(ansiIndex);\n#endif\n\n\tCEAnsi* pObj = nullptr;\n\tCEStr cpCvtBuffer;\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput)\n\t{\n\t\tbIsAnsi = HandleKeeper::IsAnsiCapable(hConsoleOutput, &bIsConOut);\n\n\t\tif (ghAnsiLogFile && bIsConOut)\n\t\t{\n\t\t\tCEAnsi::WriteAnsiLogW(static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite);\n\t\t}\n\t}\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput && bIsAnsi)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (!bInternal && gCpConv.nFromCP && gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from unicode to MBCS\n\t\t\tCEStrA pszTemp;\n\t\t\tint iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif ((iMbcsLen > 0) && ((pszTemp.GetBuffer(iMbcsLen)) != nullptr))\n\t\t\t{\n\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can\'t be mapped\n\t\t\t\tiMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, pszTemp.data(), iMbcsLen, nullptr, &bFailed);\n\t\t\t\tif ((iMbcsLen > 0) && !bFailed)\n\t\t\t\t{\n\t\t\t\t\tint iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, nullptr, 0);\n\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t* ptrBuf = cpCvtBuffer.GetBuffer(iWideLen);\n\t\t\t\t\t\tif (ptrBuf)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t{\n\t\t\tif (pObj->gnPrevAnsiPart || gDisplayOpt.WrapWasSet)\n\t\t\t{\n\t\t\t\t// Если остался "хвост" от предущей записи - сразу, без проверок\n\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\tgoto ansidone;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_ASSERTEX(ESC==27 && BEL==7 && DSC==0x90);\n\t\t\t\tconst wchar_t* pch = static_cast<const wchar_t*>(lpBuffer);\n\t\t\t\tfor (size_t i = nNumberOfCharsToWrite; i--; pch++)\n\t\t\t\t{\n\t\t\t\t\t// Если в выводимой строке встречается "Ansi ESC Code" - выводим сами\n\t\t\t\t\tTODO("Non-CSI codes, like as BEL, BS, CR, LF, FF, TAB, VT, SO, SI");\n\t\t\t\t\tif (*pch == ESC /*|| *pch == BEL*/ /*|| *pch == ENQ*/)\n\t\t\t\t\t{\n\t\t\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\t\t\tgoto ansidone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!bIsAnsi || ((pObj = CEAnsi::Object()) == nullptr))\n\t{\n\t\tlbRc = F(WriteConsoleW)(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n\t}\n\telse\n\t{\n\t\tlbRc = pObj->WriteText(F(WriteConsoleW), hConsoleOutput, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten, TRUE);\n\t\t//wrt.Flags = ewtf_Current|ewtf_Commit;\n\t\t//wrt.Buffer = (const wchar_t*)lpBuffer;\n\t\t//wrt.NumberOfCharsToWrite = nNumberOfCharsToWrite;\n\t\t//wrt.Private = F(WriteConsoleW);\n\t\t//lbRc = ExtWriteText(&wrt);\n\t\t//if (lbRc)\n\t\t//{\n\t\t//\tif (lpNumberOfCharsWritten)\n\t\t//\t\t*lpNumberOfCharsWritten = wrt.NumberOfCharsWritten;\n\t\t//\tif (wrt.ScrolledRowsUp > 0)\n\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)wrt.ScrolledRowsUp));\n\t\t//}\n\t}\n\tgoto wrap;\n\nansidone:\n\t{\n\t\tExtCommitParm cmt = {sizeof(cmt), hConsoleOutput};\n\t\tExtCommit(&cmt);\n\t}\nwrap:\n\treturn lbRc;\n}\n', 'caller_start': 1413, 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'caller_info', 'call_line': 1740, 'call_code': 'DumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl)', 'caller_code': 'int CEAnsi::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, CEAnsi::AnsiEscCode& Code, BOOL ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tconst INT_PTR nCurPrevLen = gnPrevAnsiPart;\n\t\t\tconst INT_PTR nAdd = std::min((lpEnd-lpBuffer),static_cast<INT_PTR>(countof(gsPrevAnsiPart))-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX(static_cast<INT_PTR>(countof(gsPrevAnsiPart)) > (nCurPrevLen + nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING("Проверить!!!");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tconst int iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart + nAdd + gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst INT_PTR nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen > 0 && nSkipLen <= static_cast<INT_PTR>(countof(gsPrevAnsiPart)) && nSkipLen <= gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(writeConsoleW, hConsoleOutput, gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= (static_cast<int>(CEAnsi_MaxPrevPart) - static_cast<int>(cchPrevPart)));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += static_cast<int>(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING("Проверить!!!");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && "Invalid esc sequence, need dump to screen?");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tINT_PTR nLeft;\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like "ESC 7" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some "special" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'7\': // Save xterm cursor\n\t\t\t\t\tcase L\'8\': // Restore xterm cursor\n\t\t\t\t\tcase L\'c\': // Full reset\n\t\t\t\t\tcase L\'g\': // Visual Bell\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\tcase L\'H\': // Horizontal Tab Set\n\t\t\t\t\tcase L\'M\': // Reverse LF\n\t\t\t\t\tcase L\'E\': // CR-LF\n\t\t\t\t\tcase L\'D\': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO("Bypass unrecognized ESC sequences to screen? Don\'t try to eliminate \'Possible\' sequences?");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* \'|\' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L"[]|()%", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don\'t assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk="VK_ESCAPE" [27/0x001B], Scan=0x0001 uChar=[U=\'\\x1b\' (0x001B): A=\'\\x1b\' (0x1B)]\n\t\t\t\t\t\tconst bool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart - 1) == L\'\\\'\' && Code.Second == L\'\\\'\') || (*(lpSaveStart - 1) == L\' \' && Code.Second == L\' \'));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && "Unsupported control sequence?");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now parameters go\n\t\t\t\t\t++lpBuffer; // move pointer to the first char beyond CSI (after \'[\')\n\n\t\t\t\t\tauto parseNumArgs = [&Code](const wchar_t* &lpBufferParam, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wcSave;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBufferParam < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBufferParam)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L\'0\': case L\'1\': case L\'2\': case L\'3\': case L\'4\':\n\t\t\t\t\t\t\tcase L\'5\': case L\'6\': case L\'7\': case L\'8\': case L\'9\':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (static_cast<int>(*lpBufferParam) - L\'0\');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L\';\':\n\t\t\t\t\t\t\t\t// Even if there were no digits - default is "0"\n\t\t\t\t\t\t\t\tif (Code.ArgC < static_cast<int>(countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L\']\')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (((wcSave = *lpBufferParam) >= 64) && (wcSave <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wcSave;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((static_cast<size_t>(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wcSave; // Skip private symbols\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBufferParam;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L\']\');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\tcase L\')\':\n\t\t\t\t\tcase L\'%\':\n\t\t\t\t\t//case L\'#\':\n\t\t\t\t\t//case L\'*\':\n\t\t\t\t\t//case L\'+\':\n\t\t\t\t\t//case L\'-\':\n\t\t\t\t\t//case L\'.\':\n\t\t\t\t\t//case L\'/\':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\t// ReSharper disable once CppDeclaratorNeverUsed\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// В данном запросе (на запись) конца последовательности нет,\n\t\t\t\t\t\t// оставшийся хвост нужно сохранить в буфере, для следующего запроса\n\t\t\t\t\t\t// Ниже\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t// Finalizing (ST) with "\\x1B\\\\" or "\\x07"\n\t\t\t\t\t\t// "%]4;16;rgb:00/00/00%\\" - "%" is ESC\n\t\t\t\t\t\t// "%]0;this is the window titleBEL"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; "txt" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; "txt" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar "ConEmuWaitKey" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; "txt" ST        Execute GuiMacro. Set EnvVar "ConEmuMacroResult" on exit.\n\t\t\t\t\t\t// and others... look at CEAnsi::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we\'ll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // первый символ последовательности\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L\'\\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of "switch (Code.Second)"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && "Need to be checked!"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && "Too long Esc-sequence part, Need to be checked!");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of "case 27:"\n\t\t} // end of "switch (*lpBuffer)"\n\n\t\t++lpBuffer;\n\t} // end of "while (lpBuffer < lpEnd)"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n', 'caller_start': 1585, 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'caller_info', 'call_line': 2515, 'call_code': 'DumpKnownEscape(asRet, nLen, de_Report)', 'caller_code': "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", 'caller_start': 2492, 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'caller_info', 'call_line': 2734, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'caller_code': 'BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// \'^\' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\'[\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\']\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L\'|\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'7\':\n\t\t\t\t\tcase L\'8\':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L\'7\'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'c\':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'g\':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'H\':\n\t\t\t\t\t\t// #ANSI gh-1827: support \'H\' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'M\':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'E\':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L"\\r\\n", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'D\':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\t\t// xterm "ESC =" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm "ESC >" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L\'0\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L\'B\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means "Esc part stored in buffer"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n', 'caller_start': 2608, 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'caller_info', 'call_line': 2749, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'caller_code': 'BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// \'^\' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\'[\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\']\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L\'|\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'7\':\n\t\t\t\t\tcase L\'8\':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L\'7\'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'c\':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'g\':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'H\':\n\t\t\t\t\t\t// #ANSI gh-1827: support \'H\' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'M\':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'E\':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L"\\r\\n", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'D\':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\t\t// xterm "ESC =" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm "ESC >" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L\'0\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L\'B\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means "Esc part stored in buffer"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n', 'caller_start': 2608, 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'caller_info', 'call_line': 2765, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'caller_code': 'BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// \'^\' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\'[\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\']\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L\'|\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'7\':\n\t\t\t\t\tcase L\'8\':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L\'7\'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'c\':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'g\':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'H\':\n\t\t\t\t\t\t// #ANSI gh-1827: support \'H\' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'M\':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'E\':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L"\\r\\n", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'D\':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\t\t// xterm "ESC =" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm "ESC >" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L\'0\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L\'B\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means "Esc part stored in buffer"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n', 'caller_start': 2608, 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'caller_info', 'call_line': 3286, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'caller_code': 'void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L\'s\':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'u\':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'H\': // Set cursor position (1-based)\n\tcase L\'f\': // Same as \'H\'\n\tcase L\'A\': // Cursor up by N rows\n\tcase L\'B\': // Cursor down by N rows\n\tcase L\'C\': // Cursor right by N cols\n\tcase L\'D\': // Cursor left by N cols\n\tcase L\'E\': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L\'F\': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L\'G\': // Moves the cursor to column n.\n\tcase L\'d\': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L\'H\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'f\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'A\':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'B\':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'C\':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'D\':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'E\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'F\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'G\':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'d\':\n\t\t\t\t// Moves the cursor to line n (almost the same as \'H\', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && "Missed (sub)case value!");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case \'H\', \'f\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'d\'\n\t\tbreak;\n\n\tcase L\'J\': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport\'s upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L\'J\':\n\t\tbreak;\n\n\tcase L\'b\':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L\'b\'\n\n\tcase L\'K\': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO("Need to clear attributes?");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'K\':\n\t\tbreak;\n\n\tcase L\'r\':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L\'S\':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L\'L\':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L\'M\':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually "Scroll UP N line(s) inside defined scrolling region"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'@\':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L\'P\':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L\'T\':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO("Define scrolling region");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'h\':\n\tcase L\'l\':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as "ESC ] 9 ; 12 ST"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L\'h\');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO("Need to find proper way for activation alternative buffer from ViM?");\n\t\t\t\t\t\tif (Code.Action == L\'h\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L\'h\'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L\'h\');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L\'h\');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L\'h\');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm\'s UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm\'s CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt\'s CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L\'h\')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* \'V\': Mouse wheel reporting */\n\t\t\tcase 7787: /* \'W\': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret "meta" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'h\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L\'h\'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'l\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L\'h\'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All "pasted" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L\'h\'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L\'h\') && (Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L\'h\')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L\'h\': case L\'l\':\n\n\tcase L\'n\':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L"\\x1B[0n");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'m\':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // "[...m"\n\n\tcase L\'p\':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L\'!\')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[!p"\n\n\tcase L\'q\':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\' \'))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu\'s default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can\'t implement all possible styles in RealConsole,\n\t\t\t\t// but we can use "Block/Underline" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[...q"\n\n\tcase L\'t\':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO("ANSI: xterm window manipulation");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'c\':\n\t\t// echo -e "\\e[>c"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'>\')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal\'s identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be "ESC > 67 ; build ; 0 c"\n\t\t\t// 67 is ASCII code of \'C\' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L"\\x1B>%u;%u;0c", (int)\'C\', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L"\\x1B[>0;136;0c");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e "\\e[c"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report "VT100 with Advanced Video Option"\n\t\t\tReportString(L"\\x1B[?1;2c");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'X\':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'X\':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n', 'caller_start': 2829, 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'type': 'caller_info', 'call_line': 3328, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'caller_code': 'void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L\'s\':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'u\':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'H\': // Set cursor position (1-based)\n\tcase L\'f\': // Same as \'H\'\n\tcase L\'A\': // Cursor up by N rows\n\tcase L\'B\': // Cursor down by N rows\n\tcase L\'C\': // Cursor right by N cols\n\tcase L\'D\': // Cursor left by N cols\n\tcase L\'E\': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L\'F\': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L\'G\': // Moves the cursor to column n.\n\tcase L\'d\': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L\'H\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'f\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'A\':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'B\':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'C\':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'D\':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'E\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'F\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'G\':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'d\':\n\t\t\t\t// Moves the cursor to line n (almost the same as \'H\', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && "Missed (sub)case value!");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case \'H\', \'f\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'d\'\n\t\tbreak;\n\n\tcase L\'J\': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport\'s upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L\'J\':\n\t\tbreak;\n\n\tcase L\'b\':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L\'b\'\n\n\tcase L\'K\': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO("Need to clear attributes?");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'K\':\n\t\tbreak;\n\n\tcase L\'r\':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L\'S\':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L\'L\':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L\'M\':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually "Scroll UP N line(s) inside defined scrolling region"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'@\':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L\'P\':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L\'T\':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO("Define scrolling region");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'h\':\n\tcase L\'l\':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as "ESC ] 9 ; 12 ST"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L\'h\');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO("Need to find proper way for activation alternative buffer from ViM?");\n\t\t\t\t\t\tif (Code.Action == L\'h\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L\'h\'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L\'h\');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L\'h\');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L\'h\');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm\'s UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm\'s CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt\'s CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L\'h\')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* \'V\': Mouse wheel reporting */\n\t\t\tcase 7787: /* \'W\': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret "meta" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'h\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L\'h\'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'l\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L\'h\'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All "pasted" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L\'h\'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L\'h\') && (Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L\'h\')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L\'h\': case L\'l\':\n\n\tcase L\'n\':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L"\\x1B[0n");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'m\':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // "[...m"\n\n\tcase L\'p\':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L\'!\')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[!p"\n\n\tcase L\'q\':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\' \'))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu\'s default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can\'t implement all possible styles in RealConsole,\n\t\t\t\t// but we can use "Block/Underline" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[...q"\n\n\tcase L\'t\':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO("ANSI: xterm window manipulation");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'c\':\n\t\t// echo -e "\\e[>c"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'>\')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal\'s identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be "ESC > 67 ; build ; 0 c"\n\t\t\t// 67 is ASCII code of \'C\' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L"\\x1B>%u;%u;0c", (int)\'C\', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L"\\x1B[>0;136;0c");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e "\\e[c"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report "VT100 with Advanced Video Option"\n\t\t\tReportString(L"\\x1B[?1;2c");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'X\':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'X\':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n', 'caller_start': 2829, 'file_path': 'src/ConEmuHk/Ansi.cpp'}]
 10:29:29 PM - [ERROR]: [Analysis ERROR] Root cause analysis failed: Internal Server Error
 10:29:29 PM - [ERROR]: Analysis failed: [Analysis ERROR] Root cause analysis failed
NoneType: None
 10:29:29 PM - [ERROR]: Workflow ended in error state: Analysis failed: [Analysis ERROR] Root cause analysis failed
 10:29:29 PM - [INFO]: Done. Success: 58, Failed: 43, Total: 4
/app/repos/upx-upx_614c86f
Workspace already exists, importing it...
[33mval[0m [36mres471[0m: [32mOption[0m[io.joern.console.workspacehandling.Project] = Some(
  value = Project(
    projectFile = ProjectFile(
      inputPath = "/app/repos/upx-upx_614c86f/cpg.bin",
      name = "0ce3f3b8a29e26f10c30bffeaba84f87"
    ),
    path = /app/workspace/0ce3f3b8a29e26f10c30bffeaba84f87,
    cpg = Some(value = Cpg[Graph[375921 nodes]])
  )
)

/app/repos/gpac-gpac_aa8fbec
Workspace already exists, importing it...
/app/repos/rtcwcoop-rtcwcoop_39bcb1c
Workspace already exists, importing it...
[33mval[0m [36mres417[0m: [32mOption[0m[io.joern.console.workspacehandling.Project] = Some(
  value = Project(
    projectFile = ProjectFile(
      inputPath = "/app/repos/gpac-gpac_aa8fbec/cpg.bin",
      name = "fb942f96fe2adf2a33e5c92db4241000"
    ),
    path = /app/workspace/fb942f96fe2adf2a33e5c92db4241000,
    cpg = Some(value = Cpg[Graph[3296388 nodes]])
  )
)

[33mval[0m [36mres249[0m: [32mOption[0m[io.joern.console.workspacehandling.Project] = Some(
  value = Project(
    projectFile = ProjectFile(
      inputPath = "/app/repos/rtcwcoop-rtcwcoop_39bcb1c/cpg.bin",
      name = "0bb98005c842c43d03ac360584a67e65"
    ),
    path = /app/workspace/0bb98005c842c43d03ac360584a67e65,
    cpg = Some(value = Cpg[Graph[2655287 nodes]])
  )
)

Tool result: [{'caller_func': 'GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, GF_Fraction force_fps, u32 frames_per_sample, GF_FilterSession *fsess, char **mux_args_if_first_pass, char **mux_sid_if_first_pass, u32 tk_idx)\n{\n\tu32 track_id, i, j, timescale, track, stype, profile, compat, level, new_timescale, rescale_num, rescale_den, svc_mode, txt_flags, split_tile_mode, temporal_mode, nb_tracks;\n\ts32 par_d, par_n, prog_id, force_rate, moov_timescale;\n\ts32 tw, th, tx, ty, tz, txtw, txth, txtx, txty;\n\tBool do_audio, do_video, do_auxv,do_pict, do_all, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, rap_only, refs_only, force_par, rewrite_bs;\n\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc, do_disable;\n\tconst char *szLan;\n\tGF_Err e = GF_OK;\n\tGF_Fraction delay;\n\tu32 tmcd_track = 0, neg_ctts_mode=0;\n\tBool keep_audelim = GF_FALSE;\n\tu32 print_stats_graph=fs_dump_flags;\n\tGF_MediaImporter import;\n\tchar *ext, *final_name=NULL, *handler_name, *rvc_config, *chapter_name;\n\tGF_List *kinds;\n\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\n\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\n\tu32 clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod;\n\tBool has_clap=GF_FALSE;\n\tBool use_stz2=GF_FALSE;\n\tBool has_mx=GF_FALSE;\n\ts32 mx[9];\n\tu32 bitdepth=0;\n\tchar dv_profile[100]; /*Dolby Vision*/\n\tu32 clr_type=0;\n\tu32 clr_prim;\n\tu32 clr_tranf;\n\tu32 clr_mx;\n\tBool rescale_override=GF_FALSE;\n\tBool clr_full_range=GF_FALSE;\n\tBool fmt_ok = GF_TRUE;\n\tu32 icc_size=0, track_flags=0;\n\tu8 *icc_data = NULL;\n\tu32 tc_fps_num=0, tc_fps_den=0, tc_h=0, tc_m=0, tc_s=0, tc_f=0, tc_frames_per_tick=0;\n\tBool tc_force_counter=GF_FALSE;\n\tBool tc_drop_frame = GF_FALSE;\n\tchar *ext_start;\n\tu32 xps_inband=0;\n\tu64 source_magic=0;\n\tchar *opt_src = NULL;\n\tchar *opt_dst = NULL;\n\tchar *fchain = NULL;\n\tchar *edits = NULL;\n\tconst char *fail_msg = NULL;\n\tchar *hdr_file=NULL;\n\tBool set_ccst=GF_FALSE;\n\tBool has_last_sample_dur=GF_FALSE;\n\tu32 fake_import = 0;\n\tGF_Fraction last_sample_dur = {0,0};\n\ts32 fullrange, videofmt, colorprim, colortfc, colormx;\n\tclap_wn = clap_wd = clap_hn = clap_hd = clap_hon = clap_hod = clap_von = clap_vod = 0;\n\tGF_ISOMTrackFlagOp track_flags_mode=0;\n\tu32 roll_change=0;\n\ts32 roll = 0;\n\tBool src_is_isom = GF_FALSE;\n\ts32 dlb_mode = -2;\n\n\tdv_profile[0] = 0;\n\trvc_predefined = 0;\n\tchapter_name = NULL;\n\tnew_timescale = 1;\n\tmoov_timescale = 0;\n\trescale_num = rescale_den = 0;\n\ttext_layout = 0;\n\t/*0: merge all\n\t  1: split base and all SVC in two tracks\n\t  2: split all base and SVC layers in dedicated tracks\n\t */\n\tsvc_mode = 0;\n\n\tif (import_flags==0xFFFFFFFF) {\n\t\timport_flags = 0;\n\t\tfake_import = 1;\n\t}\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\n\tfinal_name = gf_strdup(inName);\n#ifdef WIN32\n\t/*dirty hack for msys&mingw: when we use import options, the \':\' separator used prevents msys from translating the path\n\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we\'re screwed :( */\n\tif ( (final_name[0]==\'/\') && (final_name[2]==\'/\')) {\n\t\tfinal_name[0] = final_name[1];\n\t\tfinal_name[1] = \':\';\n\t}\n#endif\n\n\tis_chap_file = 0;\n\thandler = 0;\n\tdo_disable = 0;\n\tchap_ref = 0;\n\tis_chap = 0;\n\tkinds = gf_list_new();\n\ttrack_layout = 0;\n\tszLan = NULL;\n\tdelay.num = delay.den = 0;\n\tgroup = 0;\n\tstype = 0;\n\tprofile = compat = level = 0;\n\tfullrange = videofmt = colorprim = colortfc = colormx = -1;\n\tsplit_tile_mode = 0;\n\ttemporal_mode = 0;\n\trap_only = 0;\n\trefs_only = 0;\n\ttxt_flags = 0;\n\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\n\tforce_rate = -1;\n\n\ttw = th = tx = ty = tz = txtw = txth = txtx = txty = 0;\n\tpar_d = par_n = -1;\n\tforce_par = rewrite_bs = GF_FALSE;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, \'#\');\n\tif (!ext) ext = gf_url_colon_suffix(final_name, \'=\');\n\tchar c_sep = ext ? ext[0] : 0;\n\tif (ext) ext[0] = 0;\n \tif (!strlen(final_name) || !strcmp(final_name, "self")) {\n\t\tfake_import = 2;\n\t\tsrc_is_isom = GF_TRUE;\n\t}\n\tchar *frag = strrchr(final_name, \'#\');\n\tif (frag) frag[0] = 0;\n\tif (gf_isom_probe_file(final_name))\n\t\tsrc_is_isom = GF_TRUE;\n\tif (frag) frag[0] = \'#\';\n\n\tif (ext) ext[0] = c_sep;\n\n\text = gf_url_colon_suffix(final_name, \'=\');\n\n#define GOTO_EXIT(_msg) if (e) { fail_msg = _msg; goto exit; }\n\n#define CHECK_FAKEIMPORT(_opt) if (fake_import) { M4_LOG(GF_LOG_ERROR, ("Option %s not available for self-reference import\\n", _opt)); e = GF_BAD_PARAM; goto exit; }\n#define CHECK_FAKEIMPORT_2(_opt) if (fake_import==1) { M4_LOG(GF_LOG_ERROR, ("Option %s not available for self-reference import\\n", _opt)); e = GF_BAD_PARAM; goto exit; }\n\n\n\thandler_name = NULL;\n\trvc_config = NULL;\n\twhile (ext) {\n\t\tchar *ext2 = gf_url_colon_suffix(ext+1, \'=\');\n\n\t\tif (ext2) ext2[0] = 0;\n\n\t\t/*all extensions for track-based importing*/\n\t\tif (!strnicmp(ext+1, "dur=", 4)) {\n\t\t\tCHECK_FAKEIMPORT("dur")\n\n\t\t\tif (strchr(ext, \'-\')) {\n\t\t\t\timport.duration.num = parse_s32(ext+5, "dur");\n\t\t\t\timport.duration.den = 1;\n\t\t\t} else {\n\t\t\t\tgf_parse_frac(ext+5, &import.duration);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "start=", 6)) {\n\t\t\tCHECK_FAKEIMPORT("start")\n\t\t\timport.start_time = atof(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "lang=", 5)) {\n\t\t\t/* prevent leak if param is set twice */\n\t\t\tif (szLan)\n\t\t\t\tgf_free((char*) szLan);\n\n\t\t\tszLan = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "delay=", 6)) {\n\t\t\tif (sscanf(ext+7, "%d/%u", &delay.num, &delay.den)!=2) {\n\t\t\t\tdelay.num = parse_s32(ext+7, "delay");\n\t\t\t\tdelay.den = 1000; //in ms\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "par=", 4)) {\n\t\t\tif (!stricmp(ext + 5, "none")) {\n\t\t\t\tpar_n = par_d = 0;\n\t\t\t} else if (!stricmp(ext + 5, "auto")) {\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else if (!stricmp(ext + 5, "force")) {\n\t\t\t\tpar_n = par_d = 1;\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (ext2) {\n\t\t\t\t\text2[0] = \':\';\n\t\t\t\t\text2 = strchr(ext2+1, \':\');\n\t\t\t\t\tif (ext2) ext2[0] = 0;\n\t\t\t\t}\n\t\t\t\tif (ext[5]==\'w\') {\n\t\t\t\t\trewrite_bs = GF_TRUE;\n\t\t\t\t\tif (sscanf(ext+6, "%d:%d", &par_n, &par_d)!=2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized syntax for par=, expecting N:D got %s\\n", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (sscanf(ext+5, "%d:%d", &par_n, &par_d) != 2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized syntax for par=, expecting N:D got %s\\n", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "clap=", 5)) {\n\t\t\tif (!stricmp(ext+6, "none")) {\n\t\t\t\thas_clap=GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (sscanf(ext+6, "%d,%d,%d,%d,%d,%d,%d,%d", &clap_wn, &clap_wd, &clap_hn, &clap_hd, &clap_hon, &clap_hod, &clap_von, &clap_vod)==8) {\n\t\t\t\t\thas_clap=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "mx=", 3)) {\n\t\t\tif (strstr(ext+4, "0x")) {\n\t\t\t\tif (sscanf(ext+4, "0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%d", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\t\thas_mx=GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (sscanf(ext+4, "%d,%d,%d,%d,%d,%d,%d,%d,%d", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\thas_mx=GF_TRUE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "name=", 5)) {\n\t\t\thandler_name = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "ext=", 4)) {\n\t\t\tCHECK_FAKEIMPORT("ext")\n\t\t\t/*extensions begin with \'.\'*/\n\t\t\tif (*(ext+5) == \'.\')\n\t\t\t\timport.force_ext = gf_strdup(ext+5);\n\t\t\telse {\n\t\t\t\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\n\t\t\t\timport.force_ext[0] = \'.\';\n\t\t\t\tstrcat(import.force_ext+1, ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "hdlr=", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\n\t\telse if (!strnicmp(ext+1, "stype=", 6)) stype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\n\t\telse if (!strnicmp(ext+1, "tkhd", 4)) {\n\t\t\tchar *flags = ext+6;\n\t\t\tif (flags[0]==\'+\') { track_flags_mode = GF_ISOM_TKFLAGS_ADD; flags += 1; }\n\t\t\telse if (flags[0]==\'-\') { track_flags_mode = GF_ISOM_TKFLAGS_REM; flags += 1; }\n\t\t\telse track_flags_mode = GF_ISOM_TKFLAGS_SET;\n\n\t\t\tif (strstr(flags, "enable")) track_flags |= GF_ISOM_TK_ENABLED;\n\t\t\tif (strstr(flags, "movie")) track_flags |= GF_ISOM_TK_IN_MOVIE;\n\t\t\tif (strstr(flags, "preview")) track_flags |= GF_ISOM_TK_IN_PREVIEW;\n\t\t\tif (strstr(flags, "size_ar")) track_flags |= GF_ISOM_TK_SIZE_IS_AR;\n\t\t\tif (!track_flags) {\n\t\t\t\tif (!strnicmp(flags, "0x", 2)) flags += 2;\n\t\t\t\tsscanf(flags, "%X", &track_flags);\n\t\t\t}\n\t\t} else if (!strnicmp(ext+1, "disable", 7)) {\n\t\t\tdo_disable = !stricmp(ext+1, "disable=no") ? 2 : 1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "group=", 6)) {\n\t\t\tgroup = parse_u32(ext+7, "group");\n\t\t\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "fps=", 4)) {\n\t\t\tu32 ticks, dts_inc;\n\t\t\tif (!strcmp(ext+5, "auto")) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning, fps=auto option is deprecated\\n"));\n\t\t\t} else if ((sscanf(ext+5, "%u-%u", &ticks, &dts_inc) == 2) || (sscanf(ext+5, "%u/%u", &ticks, &dts_inc) == 2)) {\n\t\t\t\tif (!dts_inc) dts_inc=1;\n\t\t\t\tforce_fps.num = ticks;\n\t\t\t\tforce_fps.den = dts_inc;\n\t\t\t} else {\n\t\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\t\tforce_fps.den = 1000;\n\t\t\t\t\tforce_fps.num = (u32) (atof(ext+5) * force_fps.den);\n\t\t\t\t} else {\n\t\t\t\t\tgf_parse_frac(ext+5, &force_fps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, "rap")) rap_only = 1;\n\t\telse if (!stricmp(ext+1, "refs")) refs_only = 1;\n\t\telse if (!stricmp(ext+1, "trailing")) { CHECK_FAKEIMPORT("trailing") import_flags |= GF_IMPORT_KEEP_TRAILING; }\n\t\telse if (!strnicmp(ext+1, "agg=", 4)) { CHECK_FAKEIMPORT("agg") frames_per_sample = parse_u32(ext+5, "agg"); }\n\t\telse if (!stricmp(ext+1, "dref")) { CHECK_FAKEIMPORT("dref")  import_flags |= GF_IMPORT_USE_DATAREF; }\n\t\telse if (!stricmp(ext+1, "keep_refs")) { CHECK_FAKEIMPORT("keep_refs") import_flags |= GF_IMPORT_KEEP_REFS; }\n\t\telse if (!stricmp(ext+1, "nodrop")) { CHECK_FAKEIMPORT("nodrop") import_flags |= GF_IMPORT_NO_FRAME_DROP; }\n\t\telse if (!stricmp(ext+1, "packed")) { CHECK_FAKEIMPORT("packed") import_flags |= GF_IMPORT_FORCE_PACKED; }\n\t\telse if (!stricmp(ext+1, "sbr")) { CHECK_FAKEIMPORT("sbr") import_flags |= GF_IMPORT_SBR_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, "sbrx")) { CHECK_FAKEIMPORT("sbrx") import_flags |= GF_IMPORT_SBR_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, "ovsbr")) { CHECK_FAKEIMPORT("ovsbr") import_flags |= GF_IMPORT_OVSBR; }\n\t\telse if (!stricmp(ext+1, "ps")) { CHECK_FAKEIMPORT("ps") import_flags |= GF_IMPORT_PS_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, "psx")) { CHECK_FAKEIMPORT("psx") import_flags |= GF_IMPORT_PS_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, "mpeg4")) { CHECK_FAKEIMPORT("mpeg4") import_flags |= GF_IMPORT_FORCE_MPEG4; }\n\t\telse if (!stricmp(ext+1, "nosei")) { CHECK_FAKEIMPORT("nosei") import_flags |= GF_IMPORT_NO_SEI; }\n\t\telse if (!stricmp(ext+1, "svc") || !stricmp(ext+1, "lhvc") ) { CHECK_FAKEIMPORT("svc/lhvc") import_flags |= GF_IMPORT_SVC_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, "nosvc") || !stricmp(ext+1, "nolhvc")) { CHECK_FAKEIMPORT("nosvc/nolhvc") import_flags |= GF_IMPORT_SVC_NONE; }\n\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, "svcmode=", 8) || !strnicmp(ext+1, "lhvcmode=", 9)) {\n\t\t\tchar *mode = ext+9;\n\t\t\tCHECK_FAKEIMPORT_2("svcmode/lhvcmode")\n\t\t\tif (mode[0]==\'=\') mode = ext+10;\n\n\t\t\tif (!stricmp(mode, "splitnox"))\n\t\t\t\tsvc_mode = 3;\n\t\t\telse if (!stricmp(mode, "splitnoxib"))\n\t\t\t\tsvc_mode = 4;\n\t\t\telse if (!stricmp(mode, "splitall") || !stricmp(mode, "split"))\n\t\t\t\tsvc_mode = 2;\n\t\t\telse if (!stricmp(mode, "splitbase"))\n\t\t\t\tsvc_mode = 1;\n\t\t\telse if (!stricmp(mode, "merged") || !stricmp(mode, "merge"))\n\t\t\t\tsvc_mode = 0;\n\t\t}\n\t\t/*split SHVC temporal sublayers*/\n\t\telse if (!strnicmp(ext+1, "temporal=", 9)) {\n\t\t\tchar *mode = ext+10;\n\t\t\tCHECK_FAKEIMPORT_2("svcmode/lhvcmode")\n\t\t\tif (!stricmp(mode, "split"))\n\t\t\t\ttemporal_mode = 2;\n\t\t\telse if (!stricmp(mode, "splitnox"))\n\t\t\t\ttemporal_mode = 3;\n\t\t\telse if (!stricmp(mode, "splitbase"))\n\t\t\t\ttemporal_mode = 1;\n\t\t\telse {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized temporal mode %s, ignoring\\n", mode));\n\t\t\t\ttemporal_mode = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, "subsamples")) { CHECK_FAKEIMPORT("subsamples") import_flags |= GF_IMPORT_SET_SUBSAMPLES; }\n\t\telse if (!stricmp(ext+1, "deps")) { CHECK_FAKEIMPORT("deps") import_flags |= GF_IMPORT_SAMPLE_DEPS; }\n\t\telse if (!stricmp(ext+1, "ccst")) { CHECK_FAKEIMPORT("ccst") set_ccst = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, "alpha")) { CHECK_FAKEIMPORT("alpha") import.is_alpha = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, "forcesync")) { CHECK_FAKEIMPORT("forcesync") import_flags |= GF_IMPORT_FORCE_SYNC; }\n\t\telse if (!stricmp(ext+1, "xps_inband")) { CHECK_FAKEIMPORT("xps_inband") xps_inband = 1; }\n\t\telse if (!stricmp(ext+1, "xps_inbandx")) { CHECK_FAKEIMPORT("xps_inbandx") xps_inband = 2; }\n\t\telse if (!stricmp(ext+1, "au_delim")) { CHECK_FAKEIMPORT("au_delim") keep_audelim = GF_TRUE; }\n\t\telse if (!strnicmp(ext+1, "max_lid=", 8) || !strnicmp(ext+1, "max_tid=", 8)) {\n\t\t\ts32 val = parse_u32(ext+9, "Max TID/LID");\n\t\t\tCHECK_FAKEIMPORT_2("max_lid/lhvcmode")\n\t\t\tif (val < 0) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning: request max layer/temporal id is negative - ignoring\\n"));\n\t\t\t} else {\n\t\t\t\tif (!strnicmp(ext+1, "max_lid=", 8))\n\t\t\t\t\tmax_layer_id_plus_one = 1 + (u8) val;\n\t\t\t\telse\n\t\t\t\t\tmax_temporal_id_plus_one = 1 + (u8) val;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, "tiles")) { CHECK_FAKEIMPORT_2("tiles") split_tile_mode = 2; }\n\t\telse if (!stricmp(ext+1, "tiles_rle")) { CHECK_FAKEIMPORT_2("tiles_rle") split_tile_mode = 3; }\n\t\telse if (!stricmp(ext+1, "split_tiles")) { CHECK_FAKEIMPORT_2("split_tiles") split_tile_mode = 1; }\n\n\t\t/*force all composition offsets to be positive*/\n\t\telse if (!strnicmp(ext+1, "negctts", 7)) {\n\t\t\tneg_ctts_mode = !strnicmp(ext+1, "negctts=no", 10) ? 2 : 1;\n\t\t}\n\t\telse if (!stricmp(ext+1, "chap")) is_chap = 1;\n\t\telse if (!strnicmp(ext+1, "chapter=", 8)) {\n\t\t\tchapter_name = gf_strdup(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "chapfile=", 9)) {\n\t\t\tchapter_name = gf_strdup(ext+10);\n\t\t\tis_chap_file=1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "layout=", 7)) {\n\t\t\ttrack_layout = 1;\n\t\t\tif ( sscanf(ext+13, "%dx%dx%dx%dx%d", &tw, &th, &tx, &ty, &tz)==5) {\n\t\t\t} else if ( sscanf(ext+13, "%dx%dx%dx%d", &tw, &th, &tx, &ty)==4) {\n\t\t\t\ttz = 0;\n\t\t\t} else if ( sscanf(ext+13, "%dx%dx%d", &tw, &th, &tz)==3) {\n\t\t\t\ttx = ty = 0;\n\t\t\t} else if ( sscanf(ext+8, "%dx%d", &tw, &th)==2) {\n\t\t\t\ttx = ty = tz = 0;\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, "rescale=", 8)) {\n\t\t\tif (sscanf(ext+9, "%u/%u", &rescale_num, &rescale_den) != 2) {\n\t\t\t\trescale_num = parse_u32(ext+9, "rescale");\n\t\t\t\trescale_den = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "sampdur=", 8)) {\n\t\t\tif (sscanf(ext+9, "%u/%u", &rescale_den, &rescale_num) != 2) {\n\t\t\t\trescale_den = parse_u32(ext+9, "sampdur");\n\t\t\t\trescale_num = 0;\n\t\t\t}\n\t\t\trescale_override = GF_TRUE;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "timescale=", 10)) {\n\t\t\tnew_timescale = parse_u32(ext+11, "timescale");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "moovts=", 7)) {\n\t\t\tmoov_timescale = parse_u32(ext+8, "moovts");\n\t\t}\n\n\t\telse if (!stricmp(ext+1, "noedit")) { import_flags |= GF_IMPORT_NO_EDIT_LIST; }\n\n\n\t\telse if (!strnicmp(ext+1, "rvc=", 4)) {\n\t\t\tif (sscanf(ext+5, "%d", &rvc_predefined) != 1) {\n\t\t\t\trvc_config = gf_strdup(ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "fmt=", 4)) import.streamFormat = gf_strdup(ext+5);\n\n\t\telse if (!strnicmp(ext+1, "profile=", 8)) {\n\t\t\tif (!stricmp(ext+9, "high444")) profile = 244;\n\t\t\telse if (!stricmp(ext+9, "high")) profile = 100;\n\t\t\telse if (!stricmp(ext+9, "extended")) profile = 88;\n\t\t\telse if (!stricmp(ext+9, "main")) profile = 77;\n\t\t\telse if (!stricmp(ext+9, "baseline")) profile = 66;\n\t\t\telse profile = parse_u32(ext+9, "profile");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "level=", 6)) {\n\t\t\tif( atof(ext+7) < 6 )\n\t\t\t\tlevel = (int)(10*atof(ext+7)+.5);\n\t\t\telse\n\t\t\t\tlevel = parse_u32(ext+7, "level");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "compat=", 7)) {\n\t\t\tcompat = parse_u32(ext+8, "compat");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "dlba=", 5)) {\n\t\t\tif (!strcmp(ext+6, "no")) dlb_mode=0;\n\t\t\telse if (!strcmp(ext+6, "auto")) dlb_mode=-1;\n\t\t\telse if (sscanf(ext+6, "%d", &dlb_mode) != 1) {\n\t\t\t\tGOTO_EXIT("Unrecognized dolby atmos mode")\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, "novpsext", 8)) { CHECK_FAKEIMPORT("novpsext") import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS; }\n\t\telse if (!strnicmp(ext+1, "keepav1t", 8)) { CHECK_FAKEIMPORT("keepav1t") import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU; }\n\n\t\telse if (!strnicmp(ext+1, "font=", 5)) { CHECK_FAKEIMPORT("font") import.fontName = gf_strdup(ext+6); }\n\t\telse if (!strnicmp(ext+1, "size=", 5)) { CHECK_FAKEIMPORT("size") import.fontSize = parse_u32(ext+6, "size"); }\n\t\telse if (!strnicmp(ext+1, "text_layout=", 12)) {\n\t\t\tif ( sscanf(ext+13, "%dx%dx%dx%d", &txtw, &txth, &txtx, &txty)==4) {\n\t\t\t\ttext_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, "%dx%d", &txtw, &txth)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttxtx = txty = 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\telse if (!stricmp(ext+1, "swf-global")) { CHECK_FAKEIMPORT("swf-global") import.swf_flags |= GF_SM_SWF_STATIC_DICT; }\n\t\telse if (!stricmp(ext+1, "swf-no-ctrl")) { CHECK_FAKEIMPORT("swf-no-ctrl") import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE; }\n\t\telse if (!stricmp(ext+1, "swf-no-text")) { CHECK_FAKEIMPORT("swf-no-text") import.swf_flags |= GF_SM_SWF_NO_TEXT; }\n\t\telse if (!stricmp(ext+1, "swf-no-font")) { CHECK_FAKEIMPORT("swf-no-font") import.swf_flags |= GF_SM_SWF_NO_FONT; }\n\t\telse if (!stricmp(ext+1, "swf-no-line")) { CHECK_FAKEIMPORT("swf-no-line") import.swf_flags |= GF_SM_SWF_NO_LINE; }\n\t\telse if (!stricmp(ext+1, "swf-no-grad")) { CHECK_FAKEIMPORT("swf-no-grad") import.swf_flags |= GF_SM_SWF_NO_GRADIENT; }\n\t\telse if (!stricmp(ext+1, "swf-quad")) { CHECK_FAKEIMPORT("swf-quad") import.swf_flags |= GF_SM_SWF_QUAD_CURVE; }\n\t\telse if (!stricmp(ext+1, "swf-xlp")) { CHECK_FAKEIMPORT("swf-xlp") import.swf_flags |= GF_SM_SWF_SCALABLE_LINE; }\n\t\telse if (!stricmp(ext+1, "swf-ic2d")) { CHECK_FAKEIMPORT("swf-ic2d") import.swf_flags |= GF_SM_SWF_USE_IC2D; }\n\t\telse if (!stricmp(ext+1, "swf-same-app")) { CHECK_FAKEIMPORT("swf-same-app") import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE; }\n\t\telse if (!strnicmp(ext+1, "swf-flatten=", 12)) { CHECK_FAKEIMPORT("swf-flatten") import.swf_flatten_angle = (Float) atof(ext+13); }\n#endif\n\n\t\telse if (!strnicmp(ext+1, "kind=", 5)) {\n\t\t\tchar *kind_scheme, *kind_value;\n\t\t\tchar *kind_data = ext+6;\n\t\t\tchar *sep = strchr(kind_data, \'=\');\n\t\t\tif (sep) {\n\t\t\t\t*sep = 0;\n\t\t\t}\n\t\t\tkind_scheme = gf_strdup(kind_data);\n\t\t\tif (sep) {\n\t\t\t\t*sep = \'=\';\n\t\t\t\tkind_value = gf_strdup(sep+1);\n\t\t\t} else {\n\t\t\t\tkind_value = NULL;\n\t\t\t}\n\t\t\tgf_list_add(kinds, kind_scheme);\n\t\t\tgf_list_add(kinds, kind_value);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "txtflags", 8)) {\n\t\t\tif (!strnicmp(ext+1, "txtflags=", 9)) {\n\t\t\t\tsscanf(ext+10, "%x", &txt_flags);\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, "txtflags+=", 10)) {\n\t\t\t\tsscanf(ext+11, "%x", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, "txtflags-=", 10)) {\n\t\t\t\tsscanf(ext+11, "%x", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "rate=", 5)) {\n\t\t\tforce_rate = parse_s32(ext+6, "rate");\n\t\t}\n\t\telse if (!stricmp(ext+1, "stats") || !stricmp(ext+1, "fstat"))\n\t\t\tprint_stats_graph |= 1;\n\t\telse if (!stricmp(ext+1, "graph") || !stricmp(ext+1, "graph"))\n\t\t\tprint_stats_graph |= 2;\n\t\telse if (!strncmp(ext+1, "sopt", 4) || !strncmp(ext+1, "dopt", 4) || !strncmp(ext+1, "@", 1)) {\n\t\t\tif (ext2) ext2[0] = \':\';\n\t\t\topt_src = strstr(ext, ":sopt:");\n\t\t\topt_dst = strstr(ext, ":dopt:");\n\t\t\tfchain = strstr(ext, ":@");\n\t\t\tif (opt_src) opt_src[0] = 0;\n\t\t\tif (opt_dst) opt_dst[0] = 0;\n\t\t\tif (fchain) fchain[0] = 0;\n\n\t\t\tif (opt_src) import.filter_src_opts = opt_src+6;\n\t\t\tif (opt_dst) import.filter_dst_opts = opt_dst+6;\n\t\t\tif (fchain) {\n\t\t\t\t//check for old syntax (0.9->1.0) :@@\n\t\t\t\tif (fchain[2]==\'@\') {\n\t\t\t\t\timport.filter_chain = fchain + 3;\n\t\t\t\t\timport.is_chain_old_syntax = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\timport.filter_chain = fchain + 2;\n\t\t\t\t\timport.is_chain_old_syntax = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\text = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, "asemode=", 8)){\n\t\t\tchar *mode = ext+9;\n\t\t\tif (!stricmp(mode, "v0-bs"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\n\t\t\telse if (!stricmp(mode, "v0-2"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\n\t\t\telse if (!stricmp(mode, "v1"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\n\t\t\telse if (!stricmp(mode, "v1-qt"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\telse\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized audio sample entry mode %s, ignoring\\n", mode));\n\t\t}\n\t\telse if (!strnicmp(ext+1, "audio_roll=", 11)) { roll_change = 3; roll = parse_s32(ext+12, "audio_roll"); }\n\t\telse if (!strnicmp(ext+1, "roll=", 5)) { roll_change = 1; roll = parse_s32(ext+6, "roll"); }\n\t\telse if (!strnicmp(ext+1, "proll=", 6)) { roll_change = 2; roll = parse_s32(ext+7, "proll"); }\n\t\telse if (!strcmp(ext+1, "stz2")) {\n\t\t\tuse_stz2 = GF_TRUE;\n\t\t} else if (!strnicmp(ext+1, "bitdepth=", 9)) {\n\t\t\tbitdepth = parse_u32(ext+10, "bitdepth");\n\t\t}\n\t\telse if (!strnicmp(ext+1, "hdr=", 4)) {\n\t\t\thdr_file = gf_strdup(ext+5);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colr=", 5)) {\n\t\t\tchar *cval = ext+6;\n\t\t\tif (!strcmp(cval, "none")) {\n\t\t\t\tclr_type = (u32) -1;\n\t\t\t} else if (strlen(cval)<6) {\n\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tclr_type = GF_4CC(cval[0],cval[1],cval[2],cval[3]);\n\t\t\t\tcval+=4;\n\t\t\t\tif (cval[0] != \',\') {\n\t\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_NCLX) || (clr_type==GF_ISOM_SUBTYPE_NCLC)) {\n\t\t\t\t\tfmt_ok = scan_color(cval+1, &clr_prim, &clr_tranf, &clr_mx, &clr_full_range);\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_RICC) || (clr_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\t\t\t\tFILE *f = gf_fopen(cval+1, "rb");\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Failed to open file %s\\n", cval+1));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_END);\n\t\t\t\t\t\ticc_size = (u32) gf_ftell(f);\n\t\t\t\t\t\ticc_data = gf_malloc(sizeof(char)*icc_size);\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_SET);\n\t\t\t\t\t\ticc_size = (u32) gf_fread(icc_data, icc_size, f);\n\t\t\t\t\t\tgf_fclose(f);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized colr profile %s\\n", gf_4cc_to_str(clr_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fmt_ok) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("parsing colr option");\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext + 1, "dvp=", 4)) {\n\t\t\tstrncpy(dv_profile, ext + 5, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\t//old name\n\t\telse if (!strnicmp(ext + 1, "dv-profile=", 11)) {\n\t\t\tM4_LOG(GF_LOG_WARNING, ("Deprecated option name, use `:dvp=` instead\\n"));\n\t\t\tstrncpy(dv_profile, ext + 12, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\telse if (!strnicmp(ext+1, "fullrange=", 10)) {\n\t\t\tif (!stricmp(ext+11, "off") || !stricmp(ext+11, "no")) fullrange = 0;\n\t\t\telse if (!stricmp(ext+11, "on") || !stricmp(ext+11, "yes")) fullrange = 1;\n\t\t\telse {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for fullrange")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "videofmt=", 10)) {\n\t\t\tu32 idx, count = GF_ARRAY_LENGTH(videofmt_names);\n\t\t\tfor (idx=0; idx<count; idx++) {\n\t\t\t\tif (!strcmp(ext+11, videofmt_names[idx])) {\n\t\t\t\t\tvideofmt = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (videofmt==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for videofmt")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colorprim=", 10)) {\n\t\t\tcolorprim = gf_cicp_parse_color_primaries(ext+11);\n\t\t\tif (colorprim==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for colorprim")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colortfc=", 9)) {\n\t\t\tcolortfc = gf_cicp_parse_color_transfer(ext+10);\n\t\t\tif (colortfc==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for colortfc")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "colormx=", 10)) {\n\t\t\tcolormx = gf_cicp_parse_color_matrix(ext+11);\n\t\t\tif (colormx==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT("invalid format for colormx")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "tc=", 3)) {\n\t\t\tchar *tc_str = ext+4;\n\t\t\t\n\t\t\tif (tc_str[0] == \'d\') {\n\t\t\t\ttc_drop_frame=GF_TRUE;\n\t\t\t\ttc_str+=1;\n\t\t\t}\n\t\t\tif (sscanf(tc_str, "%d/%d,%d,%d,%d,%d,%d", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 7) {\n\t\t\t} else if (sscanf(tc_str, "%d/%d,%d,%d,%d,%d", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f) == 6) {\n\t\t\t} else if (sscanf(tc_str, "%d,%d,%d,%d,%d,%d", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 6) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, "%d,%d,%d,%d,%d", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f) == 5) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, "%d/%d,%d,%d", &tc_fps_num, &tc_fps_den, &tc_f, &tc_frames_per_tick) == 4) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, "%d/%d,%d", &tc_fps_num, &tc_fps_den, &tc_f) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, "%d,%d,%d", &tc_fps_num, &tc_f, &tc_frames_per_tick) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, "%d,%d", &tc_fps_num, &tc_f) == 2) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Bad format %s for timecode, ignoring\\n", ext+1));\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "edits=", 6)) {\n\t\t\tedits = gf_strdup(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, "lastsampdur", 11)) {\n\t\t\thas_last_sample_dur = GF_TRUE;\n\t\t\tif (!strnicmp(ext+1, "lastsampdur=", 12)) {\n\t\t\t\tif (sscanf(ext+13, "%d/%u", &last_sample_dur.num, &last_sample_dur.den)==2) {\n\t\t\t\t} else {\n\t\t\t\t\tlast_sample_dur.num = parse_s32(ext+13, "lastsampdur");\n\t\t\t\t\tlast_sample_dur.den = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, "ID=", 3)) {\n\t\t\timport.target_trackID = (u32) parse_u32(ext+4, "ID");\n\t\t}\n\t\t/*unrecognized, assume name has colon in it*/\n\t\telse {\n\t\t\tM4_LOG(GF_LOG_ERROR, ("Unrecognized import option %s, ignoring\\n", ext+1));\n\t\t\tif (ext2) ext2[0] = \':\';\n\t\t\text = ext2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (src_is_isom) {\n\t\t\tchar *opt = ext+1;\n\t\t\tchar *sep_eq = strchr(opt, \'=\');\n\t\t\tif (sep_eq) sep_eq[0] = 0;\n\t\t\tif (!mp4box_check_isom_fileopt(opt)) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("\\t! Import option `%s` not available for ISOBMFF/QT sources, ignoring !\\n", ext+1));\n\t\t\t}\n\t\t\tif (sep_eq) sep_eq[0] = \'=\';\n\t\t}\n\n\t\tif (ext2) ext2[0] = \':\';\n\n\t\text[0] = 0;\n\n\t\t/* restart from where we stopped\n\t\t * if we didn\'t stop (ext2 null) then the end has been reached\n\t\t * so we can stop the whole thing */\n\t\text = ext2;\n\t}\n\n\t/*check duration import (old syntax)*/\n\text = strrchr(final_name, \'%\');\n\tif (ext) {\n\t\tgf_parse_frac(ext+1, &import.duration);\n\t\text[0] = 0;\n\t}\n\n\t/*select switches for av containers import*/\n\tdo_audio = do_video = do_auxv = do_pict = 0;\n\ttrack_id = prog_id = 0;\n\tdo_all = 1;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, \'#\');\n\tif (ext) ext[0] = 0;\n\n\tif (fake_import && ext) {\n\t\text++;\n\t\tif (!strnicmp(ext, "audio", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, "video", 5)) do_video = 1;\n\t\telse if (!strnicmp(ext, "auxv", 4)) do_auxv = 1;\n\t\telse if (!strnicmp(ext, "pict", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, "trackID=", 8)) track_id = parse_u32(&ext[8], "trackID");\n\t\telse track_id = parse_u32(ext, "ID");\n\t}\n\telse if (ext) {\n\t\text++;\n\t\tchar *sep = gf_url_colon_suffix(ext, \'=\');\n\t\tif (sep) sep[0] = 0;\n\n\t\t//we have a fragment, we need to check if the track or the program is present in source\n\t\timport.in_name = final_name;\n\t\timport.flags = GF_IMPORT_PROBE_ONLY;\n\t\te = gf_media_import(&import);\n\t\tGOTO_EXIT("importing import");\n\n\t\tif (!strnicmp(ext, "audio", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, "video", 5)) do_video = 1;\n        else if (!strnicmp(ext, "auxv", 4)) do_auxv = 1;\n        else if (!strnicmp(ext, "pict", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, "trackID=", 8)) track_id = parse_u32(&ext[8], "trackID");\n\t\telse if (!strnicmp(ext, "PID=", 4)) track_id = parse_u32(&ext[4], "ID");\n\t\telse if (!strnicmp(ext, "program=", 8)) {\n\t\t\tfor (i=0; i<import.nb_progs; i++) {\n\t\t\t\tif (!stricmp(import.pg_info[i].name, ext+8)) {\n\t\t\t\t\tprog_id = import.pg_info[i].number;\n\t\t\t\t\tdo_all = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext, "prog_id=", 8)) {\n\t\t\tprog_id = parse_u32(ext+8, "prog_id");\n\t\t\tdo_all = 0;\n\t\t}\n\t\telse track_id = parse_u32(ext, "ID");\n\n\t\t//figure out trackID\n\t\tif (do_audio || do_video || do_auxv || do_pict || track_id) {\n\t\t\tBool found = track_id ? GF_FALSE : GF_TRUE;\n\t\t\tfor (i=0; i<import.nb_tracks; i++) {\n\t\t\t\tif (track_id && (import.tk_info[i].track_num==track_id)) {\n\t\t\t\t\tfound=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (do_audio && (import.tk_info[i].stream_type==GF_STREAM_AUDIO)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_video && (import.tk_info[i].stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_auxv && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_AUXV)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_pict && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_PICT)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!track_id || !found) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Cannot find track ID matching fragment #%s\\n", ext));\n\t\t\t\tif (sep) sep[0] = \':\';\n\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (sep) sep[0] = \':\';\n\t}\n\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\n\n\tif (track_layout || is_chap) {\n\t\tu32 w, h, sw, sh, fw, fh;\n\t\tw = h = sw = sh = fw = fh = 0;\n\t\tchap_ref = 0;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n            case GF_ISOM_MEDIA_AUXV:\n            case GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\n\t\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\n\t\t\t\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\n\t\t\t\tif (w<sw) w = sw;\n\t\t\t\tif (w<fw) w = fw;\n\t\t\t\tif (h<sh) h = sh;\n\t\t\t\tif (h<fh) h = fh;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (track_layout) {\n\t\t\tif (!tw) tw = w;\n\t\t\tif (!th) th = h;\n\t\t\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\n\t\t\timport.text_width = tw;\n\t\t\timport.text_height = th;\n\t\t}\n\t\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\n\t}\n\tif (text_layout && txtw && txth) {\n\t\timport.text_track_width = import.text_width ? import.text_width : txtw;\n\t\timport.text_track_height = import.text_height ? import.text_height : txth;\n\t\timport.text_width = txtw;\n\t\timport.text_height = txth;\n\t\timport.text_x = txtx;\n\t\timport.text_y = txty;\n\t}\n\n\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\n\n\tsource_magic = (u64) gf_crc_32((u8 *)inName, (u32) strlen(inName));\n\tif (!fake_import && (!fsess || mux_args_if_first_pass)) {\n\t\timport.in_name = final_name;\n\t\timport.dest = dest;\n\t\timport.video_fps = force_fps;\n\t\timport.frames_per_sample = frames_per_sample;\n\t\timport.flags = import_flags;\n\t\timport.keep_audelim = keep_audelim;\n\t\timport.print_stats_graph = print_stats_graph;\n\t\timport.xps_inband = xps_inband;\n\t\timport.prog_id = prog_id;\n\t\timport.trackID = track_id;\n\t\timport.source_magic = source_magic;\n\t\timport.track_index = tk_idx;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (moov_timescale<0) {\n\t\t\timport.moov_timescale = moov_timescale;\n\t\t}\n\t\t//otherwise force it now\n\t\telse if (moov_timescale>0) {\n\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\tGOTO_EXIT("changing timescale")\n\t\t}\n\n\t\timport.run_in_session = fsess;\n\t\timport.update_mux_args = NULL;\n\t\tif (do_all)\n\t\t\timport.flags |= GF_IMPORT_KEEP_REFS;\n\n\t\te = gf_media_import(&import);\n\t\tif (e) {\n\t\t\tif (import.update_mux_args) gf_free(import.update_mux_args);\n\t\t\tGOTO_EXIT("importing media");\n\t\t}\n\n\t\tif (fsess) {\n\t\t\t*mux_args_if_first_pass = import.update_mux_args;\n\t\t\timport.update_mux_args = NULL;\n\t\t\t*mux_sid_if_first_pass = import.update_mux_sid;\n\t\t\timport.update_mux_sid = NULL;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tnb_tracks = gf_isom_get_track_count(dest);\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu32 media_type;\n\t\ttrack = i+1;\n\t\tmedia_type = gf_isom_get_media_type(dest, track);\n\t\te = GF_OK;\n\t\tif (!fake_import) {\n\t\t\tu64 tk_source_magic;\n\t\t\ttk_source_magic = gf_isom_get_track_magic(dest, track);\n\n\t\t\tif ((tk_source_magic & 0xFFFFFFFFUL) != source_magic)\n\t\t\t\tcontinue;\n\t\t\ttk_source_magic>>=32;\t\t\n\t\t\tkeep_handler = (tk_source_magic & 1) ? GF_TRUE : GF_FALSE;\n\t\t} else {\n\t\t\tkeep_handler = GF_TRUE;\n\n\t\t\tif (do_audio && (media_type!=GF_ISOM_MEDIA_AUDIO)) continue;\n\t\t\tif (do_video && (media_type!=GF_ISOM_MEDIA_VISUAL)) continue;\n\t\t\tif (do_auxv && (media_type!=GF_ISOM_MEDIA_AUXV)) continue;\n\t\t\tif (do_pict && (media_type!=GF_ISOM_MEDIA_PICT)) continue;\n\t\t\tif (track_id && (gf_isom_get_track_id(dest, track) != track_id))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttimescale = gf_isom_get_timescale(dest);\n\t\tif (szLan) {\n\t\t\te = gf_isom_set_media_language(dest, track, (char *) szLan);\n\t\t\tGOTO_EXIT("changing language")\n\t\t}\n\t\tif (do_disable) {\n\t\t\te = gf_isom_set_track_enabled(dest, track, (do_disable==2) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT("disabling track")\n\t\t}\n\t\tif (track_flags_mode) {\n\t\t\te = gf_isom_set_track_flags(dest, track, track_flags, track_flags_mode);\n\t\t\tGOTO_EXIT("disabling track")\n\t\t}\n\n\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST) {\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\tGOTO_EXIT("removing edits")\n\t\t}\n\t\tif (delay.num && delay.den) {\n\t\t\tu64 tk_dur;\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\ttk_dur = gf_isom_get_track_duration(dest, track);\n\t\t\tif (delay.num>0) {\n\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\te |= gf_isom_append_edit(dest, track, ((s64) delay.num) * timescale / delay.den, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t} else {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\tu64 to_skip = ((s64) -delay.num) * timescale / delay.den;\n\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\t\tu64 media_time = ((s64) -delay.num) * gf_isom_get_media_timescale(dest, track) / delay.den;\n\t\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning: request negative delay longer than track duration - ignoring\\n"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tGOTO_EXIT("assigning delay")\n\t\t}\n\t\tif (gf_isom_is_video_handler_type(media_type)) {\n\t\t\tif (((par_n>=0) && (par_d>=0)) || force_par) {\n\t\t\t\te = gf_media_change_par(dest, track, par_n, par_d, force_par, rewrite_bs);\n\t\t\t\tGOTO_EXIT("changing PAR")\n\t\t\t}\n\t\t\tif ((fullrange>=0) || (videofmt>=0) || (colorprim>=0) || (colortfc>=0) || (colormx>=0)) {\n\t\t\t\te = gf_media_change_color(dest, i+1, fullrange, videofmt, colorprim, colortfc, colormx);\n\t\t\t\tGOTO_EXIT("changing color in bitstream")\n\t\t\t}\n\t\t\tif (has_clap) {\n\t\t\t\te = gf_isom_set_clean_aperture(dest, track, 1, clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod);\n\t\t\t\tGOTO_EXIT("changing clean aperture")\n\t\t\t}\n\t\t\tif (bitdepth) {\n\t\t\t\te = gf_isom_set_visual_bit_depth(dest, track, 1, bitdepth);\n\t\t\t\tGOTO_EXIT("changing bit depth")\n\t\t\t}\n\t\t\tif (clr_type) {\n\t\t\t\tif (clr_type==(u32)-1)\n\t\t\t\t\tclr_type = 0;\n\n\t\t\t\te = gf_isom_set_visual_color_info(dest, track, 1, clr_type, clr_prim, clr_tranf, clr_mx, clr_full_range, icc_data, icc_size);\n\t\t\t\tGOTO_EXIT("changing color info")\n\t\t\t}\n\t\t\tif (hdr_file) {\n\t\t\t\te = parse_high_dynamc_range_xml_desc(dest, track, hdr_file);\n\t\t\t\tGOTO_EXIT("setting HDR info")\n\t\t\t}\n\t\t\tif (dv_profile[0]) {\n\t\t\t\te = set_dv_profile(dest, track, dv_profile);\n\t\t\t\tGOTO_EXIT("setting DV profile")\n\t\t\t}\n\n\t\t\tif (set_ccst) {\n\t\t\t\te = gf_isom_set_image_sequence_coding_constraints(dest, track, 1, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\t\tGOTO_EXIT("setting image sequence constraints")\n\t\t\t}\n\t\t}\n\t\tif (has_mx) {\n\t\t\te = gf_isom_set_track_matrix(dest, track, mx);\n\t\t\tGOTO_EXIT("setting track matrix")\n\t\t}\n\t\tif (use_stz2) {\n\t\t\te = gf_isom_use_compact_size(dest, track, GF_TRUE);\n\t\t\tGOTO_EXIT("setting compact size")\n\t\t}\n\n\t\tif (gf_isom_get_media_subtype(dest, track, 1) == GF_ISOM_MEDIA_TIMECODE) {\n\t\t\ttmcd_track = track;\n\t\t}\n\t\tif (rap_only || refs_only) {\n\t\t\te = gf_media_remove_non_rap(dest, track, refs_only);\n\t\t\tGOTO_EXIT("removing non RAPs")\n\t\t}\n\t\tif (handler_name) {\n\t\t\te = gf_isom_set_handler_name(dest, track, handler_name);\n\t\t\tGOTO_EXIT("setting handler name")\n\t\t}\n\t\telse if (!keep_handler) {\n\t\t\tchar szHName[1024];\n\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\tfName = strchr(fName, \'.\');\n\t\t\tif (fName) fName += 1;\n\t\t\telse fName = "?";\n\n\t\t\tsprintf(szHName, "%s@GPAC%s", fName, gf_gpac_version());\n\t\t\te = gf_isom_set_handler_name(dest, track, szHName);\n\t\t\tGOTO_EXIT("setting handler name")\n\t\t}\n\t\tif (handler) {\n\t\t\te = gf_isom_set_media_type(dest, track, handler);\n\t\t\tGOTO_EXIT("setting media type")\n\t\t}\n\t\tif (group) {\n\t\t\te = gf_isom_set_alternate_group_id(dest, track, group);\n\t\t\tGOTO_EXIT("setting alternate group")\n\t\t}\n\n\t\tif (track_layout) {\n\t\t\te = gf_isom_set_track_layout_info(dest, track, tw<<16, th<<16, tx<<16, ty<<16, tz);\n\t\t\tGOTO_EXIT("setting track layout")\n\t\t}\n\t\tif (stype) {\n\t\t\te = gf_isom_set_media_subtype(dest, track, 1, stype);\n\t\t\tGOTO_EXIT("setting media subtype")\n\t\t}\n\t\tif (is_chap && chap_ref) {\n\t\t\te = set_chapter_track(dest, track, chap_ref);\n\t\t\tGOTO_EXIT("setting chapter track")\n\t\t}\n\n\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\te = gf_isom_add_track_kind(dest, i+1, kind_scheme, kind_value);\n\t\t\tGOTO_EXIT("setting track kind")\n\t\t}\n\n\t\tif (profile || compat || level) {\n\t\t\te = gf_media_change_pl(dest, track, profile, compat, level);\n\t\t\tGOTO_EXIT("changing video PL")\n\t\t}\n\t\tif (gf_isom_get_mpeg4_subtype(dest, track, 1))\n\t\t\tkeep_sys_tracks = 1;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (fake_import) {\n\t\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST)\n\t\t\t\tgf_isom_remove_edits(dest, track);\n\n\t\t\tif (moov_timescale<0) {\n\t\t\t\tmoov_timescale = gf_isom_get_media_timescale(dest, track);\n\t\t\t}\n\t\t\tif (moov_timescale>0) {\n\t\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\t\tGOTO_EXIT("changing timescale")\n\t\t\t}\n\n\t\t\tif (import.asemode && (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\tu32 sr, ch, bps;\n\t\t\t\tgf_isom_get_audio_info(dest, track, 1, &sr, &ch, &bps);\n\t\t\t\tgf_isom_set_audio_info(dest, track, 1, sr, ch, bps, import.asemode);\n\t\t\t}\n\t\t}\n\n\t\tif (roll_change) {\n\t\t\tif ((roll_change!=3) || (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\te = gf_isom_set_sample_roll_group(dest, track, (u32) -1, (roll_change==2) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL, roll);\n\t\t\t\tGOTO_EXIT("assigning roll")\n\t\t\t}\n\t\t}\n\n\t\tif (new_timescale>1) {\n\t\t\te = gf_isom_set_media_timescale(dest, track, new_timescale, 0, 0);\n\t\t\tGOTO_EXIT("setting media timescale")\n\t\t}\n\n\t\tif (rescale_num > 1) {\n\t\t\tswitch (gf_isom_get_media_type(dest, track)) {\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!rescale_override) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Cannot force media timescale for audio media types - ignoring\\n"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, rescale_num, rescale_den, rescale_override ? 2 : 1);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Rescale ignored, same config in source file\\n"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\t\t\t\tGOTO_EXIT("rescaling media track")\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (src_is_isom && force_fps.den && force_fps.num) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, track))) {\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, force_fps.num, force_fps.den, 2);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Rescale ignored, same config in source file\\n"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, ("Cannot force FPS for media types %s - ignoring\\n", gf_4cc_to_str( gf_isom_get_media_type(dest, track)) ));\n\t\t\t}\n\t\t}\n\n\t\tif (has_last_sample_dur) {\n\t\t\te = gf_isom_set_last_sample_duration_ex(dest, track, last_sample_dur.num, last_sample_dur.den);\n\t\t\tGOTO_EXIT("setting last sample duration")\n\t\t}\n\t\tif (rvc_config) {\n#ifdef GPAC_DISABLE_ZLIB\n\t\t\tM4_LOG(GF_LOG_ERROR, ("Error: no zlib support - RVC not available\\n"));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n#else\n\t\t\tu8 *data;\n\t\t\tu32 size;\n\t\t\te = gf_file_load_data(rvc_config, (u8 **) &data, &size);\n\t\t\tGOTO_EXIT("loading RVC config file")\n\n\t\t\tgf_gz_compress_payload(&data, size, &size);\n\t\t\te |= gf_isom_set_rvc_config(dest, track, 1, 0, "application/rvc-config+xml+gz", data, size);\n\t\t\tgf_free(data);\n\t\t\tGOTO_EXIT("compressing and assigning RVC config")\n#endif\n\t\t} else if (rvc_predefined>0) {\n\t\t\te = gf_isom_set_rvc_config(dest, track, 1, rvc_predefined, NULL, NULL, 0);\n\t\t\tGOTO_EXIT("setting RVC predefined config")\n\t\t}\n\n\t\tif (neg_ctts_mode) {\n\t\t\te = gf_isom_set_composition_offset_mode(dest, track, (neg_ctts_mode==1) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT("setting composition offset mode")\n\t\t}\n\n\t\tif (gf_isom_get_avc_svc_type(dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\tcheck_track_for_svc = track;\n\n\t\tswitch (gf_isom_get_hevc_lhvc_type(dest, track, 1)) {\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\tcheck_track_for_hevc=1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (txt_flags) {\n\t\t\te = gf_isom_text_set_display_flags(dest, track, 0, txt_flags, txt_mode);\n\t\t\tGOTO_EXIT("setting text track display flags")\n\t\t}\n\n\t\tif (edits) {\n\t\t\te = apply_edits(dest, track, edits);\n\t\t\tGOTO_EXIT("applying edits")\n\t\t}\n\n\t\tif (force_rate>=0) {\n\t\t\te = gf_isom_update_bitrate(dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\tGOTO_EXIT("updating bitrate")\n\t\t}\n\n\t\tif (split_tile_mode) {\n\t\t\tswitch (gf_isom_get_media_subtype(dest, track, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((dlb_mode>=-1) && (gf_isom_get_media_subtype(dest, track, 1)==GF_ISOM_SUBTYPE_EC3)) {\n\t\t\tGF_AC3Config *ac3c = gf_isom_ac3_config_get(dest, track, 1);\n\t\t\tif (ac3c) {\n\t\t\t\tif (dlb_mode==0) {\n\t\t\t\t\tac3c->is_ec3 = GF_TRUE;\n\t\t\t\t\tac3c->atmos_ec3_ext=0;\n\t\t\t\t\tac3c->complexity_index_type=0;\n\t\t\t\t} else {\n\t\t\t\t\tu32 di;\n\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(dest, track, 1, &di);\n\t\t\t\t\tu32 pos;\n\t\t\t\t\tgf_eac3_parser(samp->data, samp->dataLength, &pos, ac3c, GF_TRUE);\n\n\t\t\t\t\tif (dlb_mode>0) {\n\t\t\t\t\t\tac3c->atmos_ec3_ext = 1;\n\t\t\t\t\t\tac3c->complexity_index_type = dlb_mode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_ac3_config_update(dest, track, 1, ac3c);\n\t\t\t\tgf_free(ac3c);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chapter_name) {\n\t\tif (is_chap_file) {\n\t\t\tGF_Fraction a_fps = {0,0};\n\t\t\te = gf_media_import_chapters(dest, chapter_name, a_fps, GF_FALSE);\n\t\t} else {\n\t\t\te = gf_isom_add_chapter(dest, 0, 0, chapter_name);\n\t\t}\n\t\tGOTO_EXIT("importing chapters")\n\t}\n\n\tif (tmcd_track) {\n\t\tu32 tmcd_id = gf_isom_get_track_id(dest, tmcd_track);\n\t\tfor (i=0; i < gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_isom_set_track_reference(dest, i+1, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT("assigning TMCD track references")\n\t\t}\n\t}\n\n\t/*force to rewrite all dependencies*/\n\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t{\n\t\te = gf_isom_rewrite_track_dependencies(dest, i);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("Warning: track ID %d has references to a track not imported\\n", gf_isom_get_track_id(dest, i) ));\n\t\t\te = GF_OK;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\n\t\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t\t{\n\t\t\te = gf_media_filter_hevc(dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, ("Warning: track ID %d: error while filtering LHVC layers\\n", gf_isom_get_track_id(dest, i)));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (check_track_for_svc) {\n\t\tif (svc_mode) {\n\t\t\te = gf_media_split_svc(dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\n\t\t\tGOTO_EXIT("splitting SVC track")\n\t\t} else {\n\t\t\te = gf_media_merge_svc(dest, check_track_for_svc, 1);\n\t\t\tGOTO_EXIT("merging SVC/SHVC track")\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (check_track_for_lhvc) {\n\t\tif (svc_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\n\t\t\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\n\t\t\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\n\t\t\tGOTO_EXIT("splitting L-HEVC track")\n\t\t} else {\n\t\t\t//TODO - merge, temporal sublayers\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_HEVC\n\tif (check_track_for_hevc) {\n\t\tif (split_tile_mode) {\n\t\t\te = gf_media_split_hevc_tiles(dest, split_tile_mode - 1);\n\t\t\tGOTO_EXIT("splitting HEVC tiles")\n\t\t}\n\t\tif (temporal_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\n\t\t\tGOTO_EXIT("splitting HEVC temporal sublayers")\n\t\t}\n\t}\n#endif\n\n\tif (tc_fps_num) {\n\t\tu32 desc_index=0;\n\t\tu32 tmcd_tk, tmcd_id;\n\t\tu32 video_ref = 0;\n\t\tGF_BitStream *bs;\n\t\tGF_ISOSample *samp;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, i+1))) {\n\t\t\t\tvideo_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttmcd_tk = gf_isom_new_track(dest, 0, GF_ISOM_MEDIA_TIMECODE, tc_fps_num);\n\t\tif (!tmcd_tk) {\n\t\t\te = gf_isom_last_error(dest);\n\t\t\tGOTO_EXIT("creating TMCD track")\n\t\t}\n\t\te = gf_isom_set_track_enabled(dest, tmcd_tk, 1);\n\t\tif (e != GF_OK) {\n\t\t\tGOTO_EXIT("enabling TMCD track")\n\t\t}\n\n\t\tif (!tc_frames_per_tick) {\n\t\t\ttc_frames_per_tick = tc_fps_num;\n\t\t\ttc_frames_per_tick /= tc_fps_den;\n\t\t\tif (tc_frames_per_tick * tc_fps_den < tc_fps_num)\n\t\t\t\ttc_frames_per_tick++;\n\t\t}\n\n\t\tu32 tmcd_value = (tc_h * 3600 + tc_m*60 + tc_s)*tc_frames_per_tick+tc_f;\n\t\ttmcd_id = gf_isom_get_track_id(dest, tmcd_tk);\n\n\t\te = gf_isom_tmcd_config_new(dest, tmcd_tk, tc_fps_num, tc_fps_den, tc_frames_per_tick, tc_drop_frame, tc_force_counter, &desc_index);\n\t\tGOTO_EXIT("configuring TMCD sample description")\n\n\t\tif (video_ref) {\n\t\t\te = gf_isom_set_track_reference(dest, video_ref, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT("assigning TMCD track ref on video track")\n\t\t}\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, tmcd_value);\n\t\tsamp = gf_isom_sample_new();\n\t\tsamp->IsRAP = SAP_TYPE_1;\n\t\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\t\tgf_bs_del(bs);\n\t\te = gf_isom_add_sample(dest, tmcd_tk, desc_index, samp);\n\t\tgf_isom_sample_del(&samp);\n\t\tGOTO_EXIT("assigning TMCD sample")\n\n\t\tif (video_ref) {\n\t\t\tu64 video_ref_dur = gf_isom_get_media_duration(dest, video_ref);\n\t\t\tvideo_ref_dur *= tc_fps_num;\n\t\t\tvideo_ref_dur /= gf_isom_get_media_timescale(dest, video_ref);\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, (u32) video_ref_dur);\n\t\t} else {\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, tc_fps_den ? tc_fps_den : 1);\n\t\t}\n\t\tGOTO_EXIT("setting TMCD sample dur")\n\t}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nexit:\n\twhile (gf_list_count(kinds)) {\n\t\tchar *kind = (char *)gf_list_get(kinds, 0);\n\t\tgf_list_rem(kinds, 0);\n\t\tif (kind) gf_free(kind);\n\t}\n\tif (opt_src) opt_src[0] = \':\';\n\tif (opt_dst) opt_dst[0] = \':\';\n\tif (fchain) fchain[0] = \':\';\n\tif (hdr_file) gf_free(hdr_file);\n\n\tgf_list_del(kinds);\n\tif (handler_name) gf_free(handler_name);\n\tif (chapter_name ) gf_free(chapter_name);\n\tif (import.fontName) gf_free(import.fontName);\n\tif (import.streamFormat) gf_free(import.streamFormat);\n\tif (import.force_ext) gf_free(import.force_ext);\n\tif (rvc_config) gf_free(rvc_config);\n\tif (edits) gf_free(edits);\n\tif (szLan) gf_free((char *)szLan);\n\tif (icc_data) gf_free(icc_data);\n\tif (final_name) gf_free(final_name);\n\n\tif (!e) return GF_OK;\n\tif (fail_msg) {\n\t\tM4_LOG(GF_LOG_ERROR, ("Failure while %s: %s\\n", fail_msg, gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n', 'caller_start': 622, 'caller_end': 2013, 'call_line': 1912, 'call_code': 'gf_media_split_hevc_tiles(dest, split_tile_mode - 1)', 'call_path': 'applications/mp4box/fileimport.c'}, {'caller_func': 'static GF_Err gf_isom_iff_create_image_item_from_track_internal(GF_ISOFile *movie, Bool root_meta, u32 meta_track_number, u32 imported_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs, u32 sample_number) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_Err e;\n\tu32 w, h, hSpacing, vSpacing;\n\tu8 num_channels;\n\tu8 bits_per_channel[3];\n\tu32 subtype;\n\tGF_ISOSample *sample = NULL;\n\tu32 timescale;\n\tu32 item_type = 0;\n\tGF_ImageItemProperties local_image_props;\n\tGF_ImageItemProtection ipro, *orig_ipro = NULL;\n\tBool config_needed = 0;\n\tGF_Box *config_box = NULL;\n\tBool is_cenc = GF_FALSE;\n\tBool is_first = GF_TRUE;\n\tBool neg_time = (image_props && image_props->time<0) ? GF_TRUE : GF_FALSE;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0, sai_alloc_size = 0;\n\tu32 sample_desc_index = 0;\n\tGF_ISOFile *fsrc = movie;\n\tBool reset_brands = GF_FALSE;\n\n\t//only reset brands if first item import\n\tif (!gf_isom_get_meta_item_count(movie, root_meta, meta_track_number))\n\t\treset_brands = GF_TRUE;\n\n\tif (image_props && image_props->src_file)\n\t\tfsrc = image_props->src_file;\n\n\tif (image_props && image_props->tile_mode != TILE_ITEM_NONE) {\n\t\t/* Processing the input file in Tiled mode:\n\t\t   The single track is split into multiple tracks\n\t\t   and each track is processed to create an item */\n\t\tu32 i, count;\n\t\tu32 tile_track;\n\t\tGF_List *tile_item_ids;\n\t\tchar sz_item_name[256];\n\t\tGF_TileItemMode orig_tile_mode;\n\n#if !defined(GPAC_DISABLE_HEVC) && !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (image_props->src_file)\n\t\t\te = GF_SERVICE_ERROR;\n\t\telse\n\t\t\te = gf_media_split_hevc_tiles(movie, 0);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\n\t\tif (e) return e;\n\t\ttile_item_ids = gf_list_new();\n\t\torig_tile_mode = image_props->tile_mode;\n\t\timage_props->tile_mode = TILE_ITEM_NONE;\n\t\tcount = gf_isom_get_reference_count(movie, imported_track, GF_ISOM_REF_SABT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_malloc(sizeof(u32));\n\t\t\tif (!tile_item_id) return GF_OUT_OF_MEM;\n\n\t\t\t*tile_item_id = item_id + i+1;\n\t\t\tgf_list_add(tile_item_ids, tile_item_id);\n\t\t\te = gf_isom_get_reference(movie, imported_track, GF_ISOM_REF_SABT, 1, &tile_track);\n\t\t\tif (e) return e;\n\t\t\tif (item_name)\n\t\t\t\tsprintf(sz_item_name, "%s-Tile%d", item_name, i + 1);\n\t\t\tif (orig_tile_mode != TILE_ITEM_SINGLE || image_props->single_tile_number == i + 1) {\n\t\t\t\te = gf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, tile_track, item_name ? sz_item_name : NULL, *tile_item_id, NULL, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t\tgf_isom_remove_track(movie, tile_track);\n\t\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\t\te = gf_isom_meta_add_item_ref(movie, root_meta, meta_track_number, *tile_item_id, item_id, GF_ISOM_REF_TBAS, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (item_name)\n\t\t\tsprintf(sz_item_name, "%s-TileBase", item_name);\n\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\tgf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, imported_track, item_name ? sz_item_name : NULL, item_id, image_props, tile_item_ids);\n\t\t}\n\t\telse if (orig_tile_mode == TILE_ITEM_ALL_GRID) {\n\t\t\t// TODO\n\t\t}\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_list_get(tile_item_ids, i);\n\t\t\tgf_free(tile_item_id);\n\t\t}\n\t\tgf_list_del(tile_item_ids);\n\t\treturn GF_OK;\n\t}\n\n\tif (!image_props) {\n\t\timage_props = &local_image_props;\n\t\tmemset(image_props, 0, sizeof(GF_ImageItemProperties));\n\t} else {\n\t\torig_ipro = image_props->cenc_info;\n\t\timage_props->cenc_info = NULL;\n\t}\n\n\tif (!imported_track) {\n\t\tGF_ImageItemProperties src_props;\n\t\tu32 item_idx, ref_id;\n\t\tu32 scheme_type=0, scheme_version=0;\n\t\tconst char *orig_item_name, *orig_item_mime_type, *orig_item_encoding;\n\t\tif (!image_props->item_ref_id) return GF_BAD_PARAM;\n\n\t\tif (gf_isom_meta_get_item_ref_count(fsrc, GF_TRUE, 0, image_props->item_ref_id, GF_4CC(\'d\',\'i\',\'m\',\'g\')) > 0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Cannnot import derived image, only native image import is supported\\n"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\titem_idx = gf_isom_get_meta_item_by_id(fsrc, GF_TRUE, 0, image_props->item_ref_id);\n\t\tif (!item_idx) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: No item with ID %d, cannnot import\\n", image_props->item_ref_id));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\torig_item_name = orig_item_mime_type = orig_item_encoding = NULL;\n\t\tgf_isom_get_meta_item_info(fsrc, GF_TRUE, 0, item_idx, &ref_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &orig_item_name, &orig_item_mime_type, &orig_item_encoding);\n\n\t\tif (!ref_id) return GF_BAD_PARAM;\n\t\tif (ref_id != image_props->item_ref_id) return GF_ISOM_INVALID_FILE;\n\n\t\tgf_isom_get_meta_image_props(fsrc, GF_TRUE, 0, ref_id, &src_props, NULL);\n\n\t\timage_props->config = src_props.config;\n\t\timage_props->width = src_props.width;\n\t\timage_props->height = src_props.height;\n\t\timage_props->num_channels = src_props.num_channels;\n\t\tmemcpy(image_props->av1_layer_size, src_props.av1_layer_size, sizeof(u32)*3);\n\t\tmemcpy(image_props->bits_per_channel, src_props.bits_per_channel, sizeof(u32)*3);\n\t\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\t\timage_props->hSpacing = src_props.hSpacing;\n\t\t\timage_props->vSpacing = src_props.vSpacing;\n\t\t}\n\t\tif (image_props->copy_props) {\n\t\t\tif (!image_props->hOffset && !image_props->vOffset) {\n\t\t\t\timage_props->hOffset = src_props.hOffset;\n\t\t\t\timage_props->vOffset = src_props.vOffset;\n\t\t\t}\n\t\t\tif (!image_props->clap_wden) {\n\t\t\t\timage_props->clap_wnum = src_props.clap_wnum;\n\t\t\t\timage_props->clap_wden = src_props.clap_wden;\n\t\t\t\timage_props->clap_hnum = src_props.clap_hnum;\n\t\t\t\timage_props->clap_hden = src_props.clap_hden;\n\t\t\t\timage_props->clap_honum = src_props.clap_honum;\n\t\t\t\timage_props->clap_hoden = src_props.clap_hoden;\n\t\t\t\timage_props->clap_vonum = src_props.clap_vonum;\n\t\t\t\timage_props->clap_voden = src_props.clap_voden;\n\t\t\t}\n\t\t\tif (!image_props->alpha) image_props->alpha = src_props.alpha;\n\t\t\tif (!image_props->depth) image_props->depth = src_props.depth;\n\t\t\tif (!image_props->hidden) image_props->hidden = src_props.hidden;\n\t\t\tif (!image_props->angle) image_props->angle = src_props.angle;\n\t\t\tif (!image_props->mirror) image_props->mirror = src_props.mirror;\n\t\t\tif (!image_props->av1_op_index) image_props->av1_op_index = src_props.av1_op_index;\n\t\t}\n\t\tif (!item_name) item_name = orig_item_name;\n\n\t\tif (!image_props->use_reference || (fsrc == image_props->src_file)) {\n\t\t\tu8 *data = NULL;\n\t\t\tu32 size=0;\n\t\t\te = gf_isom_extract_meta_item_mem(fsrc, GF_TRUE, 0, ref_id, &data, &size, &size, NULL, GF_FALSE);\n\t\t\tif (e) return GF_BAD_PARAM;\n\n\t\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, data, size, NULL);\n\t\t\tif (data) gf_free(data);\n\t\t} else {\n\t\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, 0, ref_id);\n\t\t}\n\t\treturn e;\n\t}\n\nimport_next_sample:\n\n\ttimescale = gf_isom_get_media_timescale(fsrc, imported_track);\n\tif (image_props->sample_num) {\n\t\tsample_number = image_props->sample_num;\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else if (image_props->time<0) {\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else {\n\t\te = gf_isom_get_sample_for_media_time(fsrc, imported_track, (u64)(image_props->time*timescale), &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &sample, &sample_number, NULL);\n\t}\n\tif (e || !sample || !sample->IsRAP) {\n\t\tif (!sample) {\n\t\t\tif (is_first) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("No sample found%s\\n", (image_props->time<0) ? "" : " for requested time"));\n\t\t\t} else {\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if ((image_props->time<0) || (image_props->step_time)) {\n\t\t\tif (image_props->sample_num) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: imported sample %d (DTS "LLU") is not a sync sample (RAP %d size %d)\\n", sample_number, sample->DTS, sample->IsRAP, sample->dataLength));\n\t\t\t} else if (image_props->step_time) {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\tsample_number++;\n\t\t\t\tif (sample_number == gf_isom_get_sample_count(fsrc, imported_track)) {\n\t\t\t\t\te = GF_OK;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgoto import_next_sample;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error no sync sample found after time %g\\n", image_props->time));\n\t\t}\n\t\tif (!e) e = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the track type is supported as item type */\n\t/* Get the config box if needed */\n\tsubtype = gf_isom_get_media_subtype(fsrc, imported_track, sample_desc_index);\n\tif (gf_isom_is_media_encrypted(fsrc, imported_track, sample_desc_index)) {\n\t\tif (gf_isom_is_cenc_media(fsrc, imported_track, sample_desc_index)) {\n\t\t\te = gf_isom_get_original_format_type(fsrc, imported_track, sample_desc_index, &subtype);\n\t\t\tif (e) goto exit;\n\t\t\tis_cenc = GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Protected sample not using CENC, cannot add as item\\n"));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_avc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_svc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_mvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_hevc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\tif (subtype == GF_ISOM_SUBTYPE_HVT1) {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVT1;\n\t\t}\n\t\telse {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tconfig_needed = 1;\n\t\tif (!((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_lhvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t}\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_AV01:\n\t\t{\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_isom_av1_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\t\tconfig_needed = 1;\n\t\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\t\tnum_channels = 1;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = 0;\n\t\t\t\tbits_per_channel[2] = 0;\n\t\t\t} else {\n\t\t\t\tnum_channels = 3;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = depth;\n\t\t\t\tbits_per_channel[2] = depth;\n\t\t\t}\n\t\t\t// presence of OBU SH in config is not recommended and properties should be used instead of metadata OBUs\n\t\t\twhile (gf_list_count(((GF_AV1ConfigurationBox *)config_box)->config->obu_array)) {\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_pop_back(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t\tif (obu) {\n\t\t\t\t\tif (obu->obu) gf_free(obu->obu);\n\t\t\t\t\tgf_free(obu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config->obu_array = NULL;\n\t\t\te = gf_media_av1_layer_size_get(fsrc, imported_track, sample_number, image_props->av1_op_index, image_props->av1_layer_size);\n      if (e) {\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("AV1 operating point index out of range for stream\\n"));\n        goto exit;\n      }\n\t\t\t//media_brand = GF_ISOM_BRAND_AVIF;\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_isom_vvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\tbits_per_channel[1] = bits_per_channel[2] = bits_per_channel[0];\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Codec not supported to create HEIF image items\\n"));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto exit;\n\t}\n\tif (config_needed && !config_box && !((GF_AVCConfigurationBox *)config_box)->config) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Image type %s requires a missing configuration box\\n", gf_4cc_to_str(item_type)));\n\t\te = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\t/* Get some images properties from the track data */\n\te = gf_isom_get_visual_info(fsrc, imported_track, sample_desc_index, &w, &h);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error determining image size\\n"));\n\t\tgoto exit;\n\t}\n\te = gf_isom_get_pixel_aspect_ratio(fsrc, imported_track, sample_desc_index, &hSpacing, &vSpacing);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error determining image aspect ratio\\n"));\n\t\tgoto exit;\n\t}\n\tif (!image_props->width && !image_props->height) {\n\t\timage_props->width = w;\n\t\timage_props->height = h;\n\t}\n\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\timage_props->hSpacing = hSpacing;\n\t\timage_props->vSpacing = vSpacing;\n\t}\n\timage_props->config = config_box;\n\tif (!image_props->num_channels) {\n\t\timage_props->num_channels = num_channels;\n\t\timage_props->bits_per_channel[0] = bits_per_channel[0];\n\t\timage_props->bits_per_channel[1] = bits_per_channel[1];\n\t\timage_props->bits_per_channel[2] = bits_per_channel[2];\n\t}\n\tif (is_cenc) {\n\t\tBool Is_Encrypted;\n\n\t\tmemset(&ipro, 0, sizeof(GF_ImageItemProtection));\n\t\tgf_isom_get_cenc_info(fsrc, imported_track, sample_desc_index, NULL, &ipro.scheme_type, &ipro.scheme_version);\n\t\te = gf_isom_get_sample_cenc_info(fsrc, imported_track, sample_desc_index, &Is_Encrypted, &ipro.crypt_byte_block, &ipro.skip_byte_block, &ipro.key_info, &ipro.key_info_size);\n\t\tif (e) goto exit;\n\n\t\tif (Is_Encrypted) {\n\t\t\tsai_size = sai_alloc_size;\n\t\t\te = gf_isom_cenc_get_sample_aux_info(fsrc, imported_track, sample_number, sample_desc_index, NULL, &sai, &sai_size);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (sai_size > sai_alloc_size)\n\t\t\t\tsai_alloc_size = sai_size;\n\n\t\t\tipro.sai_data = sai;\n\t\t\tipro.sai_data_size = sai_size;\n\t\t\timage_props->cenc_info = &ipro;\n\n\t\t\tif (is_first) {\n\t\t\t\tu32 i, nb_pssh = gf_isom_get_pssh_count(fsrc);\n\t\t\t\tfor (i=0; i<nb_pssh; i++) {\n\t\t\t\t\tbin128 SystemID;\n\t\t\t\t\tu32 version;\n\t\t\t\t\tu32 KID_count;\n\t\t\t\t\tconst bin128 *KIDs;\n\t\t\t\t\tconst u8 *private_data;\n\t\t\t\t\tu32 private_data_size;\n\n\t\t\t\t\tgf_isom_get_pssh_info(fsrc, i+1, SystemID, &version, &KID_count, &KIDs, &private_data, &private_data_size);\n\t\t\t\t\t\n\t\t\t\t\tgf_cenc_set_pssh(movie, SystemID, version, KID_count, (bin128 *) KIDs, (u8 *) private_data, private_data_size, 2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\timage_props->cenc_info = NULL;\n\t\t}\n\t}\n\tif (!item_id) {\n\t\te = gf_isom_meta_get_next_item_id(movie, root_meta, meta_track_number, &item_id);\n\t\tif (e) goto exit;\n\t}\n\tif (image_props->use_reference) {\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("referring trackID %d sample %d as item %d\\n", imported_track, sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("referring trackID %d sample at time %.3f as item %d\\n", imported_track, (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, imported_track, sample_number);\n\t} else {\n\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("Adding sample %d as item %d\\n", sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("Adding sample at time %.3f as item %d\\n", (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, sample->data, sample->dataLength, item_extent_refs);\n\t}\n\n\timage_props->cenc_info = NULL;\n\n\tif (reset_brands) {\n\t\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(movie);\n\n\t\t// TODO Analyze configuration to determine the brand */\n\t\t//if (media_brand) {\n\t\t//\tgf_isom_modify_alternate_brand(movie, media_brand, GF_TRUE);\n\t\t//}\n\t}\n\n\t\n\tif (neg_time)\n\t\timage_props->time = -1;\n\n\tif (!e && !image_props->sample_num && ((image_props->time<0) || image_props->end_time || image_props->step_time)) {\n\t\tif (image_props->end_time || image_props->step_time) {\n\t\t\tDouble t = (Double) (sample->DTS + sample->CTS_Offset);\n\t\t\tt /= timescale;\n\t\t\tif (image_props->step_time) {\n\t\t\t\tt += image_props->step_time;\n\t\t\t} else {\n\t\t\t\t//step 1ms\n\t\t\t\tt += 0.001;\n\t\t\t}\n\n\t\t\tif ((image_props->end_time>0) && (t>image_props->end_time)) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\timage_props->time = t;\n\t\t}\n\n\t\titem_id=0;\n\t\tgf_isom_sample_del(&sample);\n\t\tif (config_box) {\n\t\t\tgf_isom_box_del(config_box);\n\t\t\tconfig_box = NULL;\n\t\t}\n\t\tis_first = GF_FALSE;\n\t\tif (sample_number >= gf_isom_get_sample_count(fsrc, imported_track)) return e;\n\t\tsample_number++;\n\t\t//avoid recursion this could get quite big\n\t\tgoto import_next_sample;\n\t}\n\nexit:\n\tif (sai) gf_free(sai);\n\tgf_isom_sample_del(&sample);\n\tif (config_box) gf_isom_box_del(config_box);\n\timage_props->cenc_info = orig_ipro;\n\treturn e;\n\n\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n', 'caller_start': 1229, 'caller_end': 1737, 'call_line': 1273, 'call_code': 'gf_media_split_hevc_tiles(movie, 0)', 'call_path': 'src/isomedia/iff.c'}]
Tool result: [{'_1': 111669160175, '_2': 'GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}', '_3': 1934, '_4': 1937, '_5': 'gf_isom_get_sample', '_6': 'src/isomedia/isom_read.c'}]
Tool result: [{'_1': 111669155295, '_2': 'void *G_Alloc( int size ) {\n\tchar    *p;\n\n\tif ( g_debugAlloc.integer ) {\n\t\tG_Printf( "G_Alloc of %i bytes (%i left)\\n", size, POOLSIZE - allocPoint - ( ( size + 31 ) & ~31 ) );\n\t}\n\n\tif ( allocPoint + size > POOLSIZE ) {\n\t\tG_Error( "G_Alloc: failed on allocation of %i bytes", size );\n\t\treturn NULL;\n\t}\n\n\tp = &memoryPool[allocPoint];\n\n\tallocPoint += ( size + 31 ) & ~31;\n\n\treturn p;\n}', '_3': 45, '_4': 62, '_5': 'G_Alloc', '_6': 'code/game/g_mem.c'}]
Tool result: [{'_1': 111669151231, '_2': 'void *trap_Alloc( int size ) {\n\treturn (void*)syscall( CG_ALLOC, size );\n}', '_3': 570, '_4': 572, '_5': 'trap_Alloc', '_6': 'code/cgame/cg_syscalls.c'}, {'_1': 111669155953, '_2': 'void *trap_Alloc( int size ) {\n\treturn (void*)syscall( G_ALLOC, size );\n}', '_3': 813, '_4': 815, '_5': 'trap_Alloc<duplicate>0', '_6': 'code/game/g_syscalls.c'}, {'_1': 111669162133, '_2': 'void *trap_Alloc( int size ) {\n\treturn (void*)syscall( UI_ALLOC, size );\n}', '_3': 477, '_4': 479, '_5': 'trap_Alloc<duplicate>1', '_6': 'code/ui/ui_syscalls.c'}]
Tool result: [{'_1': 111669150013, '_2': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', '_3': 236, '_4': 261, '_5': 'PackCom.unpack:void(OutputFile*)', '_6': 'src/p_com.cpp'}, {'_1': 111669150030, '_2': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', '_3': 401, '_4': 470, '_5': 'PackDjgpp2.unpack:void(OutputFile*)', '_6': 'src/p_djgpp2.cpp'}, {'_1': 111669150043, '_2': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', '_3': 688, '_4': 806, '_5': 'PackExe.unpack:void(OutputFile*)', '_6': 'src/p_exe.cpp'}, {'_1': 111669150173, '_2': 'void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Rela offset", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 3844, '_4': 4161, '_5': 'PackLinuxElf64.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150213, '_2': 'void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n            unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n            Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf32_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                unsigned symval = get_te32(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf32_Sym::SHN_UNDEF != symsec\n                &&  Elf32_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te32(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr *dynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&dynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Rel offset", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 4604, '_4': 4922, '_5': 'PackLinuxElf32.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150214, '_2': 'void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack("internal error");\n}', '_3': 4924, '_4': 4927, '_5': 'PackLinuxElf.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150243, '_2': 'void PackLinuxElf32x86interp::unpack(OutputFile *fo)\n{\n#define MAX_INTERP_HDR 512\n    union {\n        unsigned char buf[MAX_INTERP_HDR];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        fi->seek(0, SEEK_SET);\n        fi->readx(u.buf, MAX_INTERP_HDR);\n        unsigned const e_entry = get_te32(&ehdr->e_entry);\n        if (e_entry < 0x401180) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n        throwCantUnpack("file header corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n    off_t ptload0hi=0, ptload1lo=0, ptload1sz=0;\n\n    // decompress PT_LOAD\n    bool first_PF_X = true;\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n    for (unsigned j=0; j < ehdr->e_phnum; ++phdr, ++j) {\n        if (PT_LOAD==phdr->p_type) {\n            if (0==ptload0hi) {\n                ptload0hi = phdr->p_filesz + phdr->p_offset;\n            }\n            else if (0==ptload1lo) {\n                ptload1lo = phdr->p_offset;\n                ptload1sz = phdr->p_filesz;\n            }\n            if (fo)\n                fo->seek(phdr->p_offset, SEEK_SET);\n            if (Elf32_Phdr::PF_X & phdr->p_flags) {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, first_PF_X, szb_info);\n                first_PF_X = false;\n            }\n            else {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, false, szb_info);\n            }\n        }\n    }\n\n    if (0!=ptload1sz && ptload0hi < ptload1lo) {  // alignment hole?\n        if (fo)\n            fo->seek(ptload0hi, SEEK_SET);\n        unpackExtent(ptload1lo - ptload0hi, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    if (total_out != orig_file_size) {  // non-PT_LOAD stuff\n        if (fo)\n            fo->seek(0, SEEK_END);\n        unpackExtent(orig_file_size - total_out, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_INTERP_HDR\n}\n', '_3': 198, '_4': 308, '_5': 'PackLinuxElf32x86interp.unpack:void(OutputFile*)', '_6': 'src/p_lx_interp.cpp'}, {'_1': 111669150315, '_2': 'void PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack("file header corrupted");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack("file header corrupted");\n    }\n    rawmseg = (Mach_segment_command *) New(char, sz_cmds);\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > 0x05000000)\n        throwCantUnpack("file header corrupted");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning("packed size too big; discarding appended data, keeping backup");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack("file header corrupted");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    Mach_header *const mhdr = (Mach_header *) New(upx_byte, ph.u_len);\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack("file header corrupted");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd = New(Mach_segment_command, ncmds);\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n        if (ptr_udiff(ptr, (1+ mhdr)) > ph.u_len) {\n            throwCantUnpack("cmdsize");\n        }\n    }\n\n    // Put LC_SEGMENT together at the beginning, ascending by .vmaddr.\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n    delete [] mhdr;\n}\n', '_3': 1421, '_4': 1547, '_5': 'PackMachBase.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150324, '_2': 'void PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode ("-t") sets fo = NULL\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n', '_3': 2200, '_4': 2300, '_5': 'PackMachFat.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150345, '_2': 'void PackPs1::unpack(OutputFile *fo)\n{\n    // restore orig exec hdr\n    memcpy(&oh, &ih, sizeof(ih));\n    memcpy((void *) &oh.epc, &bh, SZ_IH_BKUP);\n\n    // check for removed sector alignment\n    assert(oh.tx_len >= ph.u_len);\n    const unsigned pad = oh.tx_len - ph.u_len;\n\n    ibuf.alloc(fdata_size > PS_HDR_SIZE ? fdata_size : PS_HDR_SIZE);\n    obuf.allocForUncompression(ph.u_len, pad);\n\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // decompress\n    decompress(ibuf + (fdata_size - ph.c_len), obuf);\n\n    // write decompressed file\n    if (fo)\n    {\n        // write header\n        fo->write(&oh, sizeof(oh));\n        // align the ps exe header (mode 2 sector data size)\n        ibuf.clear();\n        fo->write(ibuf, PS_HDR_SIZE - fo->getBytesWritten());\n        // write uncompressed data + pad\n        obuf.clear(ph.u_len, pad);\n        fo->write(obuf, ph.u_len + pad);\n    }\n}', '_3': 708, '_4': 739, '_5': 'PackPs1.unpack:void(OutputFile*)', '_6': 'src/p_ps1.cpp'}, {'_1': 111669150361, '_2': 'void PackTmt::unpack(OutputFile *fo)\n{\n    Packer::handleStub(fi,fo,adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(),SEEK_SET);\n    fi->readx(ibuf,ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf+ph.u_len-4);\n    upx_byte *relocs = obuf + osize;\n    const unsigned origstart = get_le32(obuf+ph.u_len-8);\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf+ph.u_len-12) >> 24);\n        ft.unfilter(obuf, ptr_diff(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer wrkmem;\n    unsigned relocn = unoptimizeReloc32(&relocs,obuf,&wrkmem,1);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem+ic*4,get_le32(wrkmem+ic*4)+4);\n\n    memcpy(&oh,&ih,sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn*4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize\n        - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo)\n    {\n        fo->write(&oh,sizeof(oh));\n        fo->write(obuf,osize);\n        fo->write(wrkmem,relocn*4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, &obuf);\n}\n', '_3': 307, '_4': 361, '_5': 'PackTmt.unpack:void(OutputFile*)', '_6': 'src/p_tmt.cpp'}, {'_1': 111669150377, '_2': 'void PackTos::unpack(OutputFile *fo)\n{\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(FH_SIZE + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // write original header & decompressed file\n    if (fo)\n    {\n        unsigned overlay = file_size - (FH_SIZE + ih.fh_text + ih.fh_data);\n        if (ih.fh_reloc == 0 && overlay >= 4)\n            overlay -= 4;                           // this is our empty fixup\n        checkOverlay(overlay);\n\n        fo->write(obuf+ph.u_len-FH_SIZE, FH_SIZE);  // orig. file_hdr\n        fo->write(obuf, ph.u_len-FH_SIZE);          // orig. text+data+relocs\n\n        // copy any overlay\n        copyOverlay(fo, overlay, &obuf);\n    }\n}', '_3': 750, '_4': 775, '_5': 'PackTos.unpack:void(OutputFile*)', '_6': 'src/p_tos.cpp'}, {'_1': 111669150393, '_2': 'void PackUnix::unpack(OutputFile *fo)\n{\n    b_info bhdr;\n    unsigned const szb_info = (ph.version <= 11)\n        ? sizeof(bhdr.sz_unc) + sizeof(bhdr.sz_cpr)  // old style\n        : sizeof(bhdr);\n\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // defaults for ph.version == 8\n    unsigned orig_file_size = 0;\n    blocksize = 512 * 1024;\n\n    fi->seek(overlay_offset, SEEK_SET);\n    if (ph.version > 8)\n    {\n        p_info hbuf;\n        fi->readx(&hbuf, sizeof(hbuf));\n        orig_file_size = get_te32(&hbuf.p_filesize);\n        blocksize = get_te32(&hbuf.p_blocksize);\n\n        if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n            throwCantUnpack("file header corrupted");\n    }\n    else\n    {\n        // skip 4 bytes (program id)\n        fi->seek(4, SEEK_CUR);\n    }\n\n    if ((int)(blocksize + OVERHEAD) < 0)\n        throwCantUnpack("blocksize corrupted");\n    ibuf.alloc(blocksize + OVERHEAD);\n\n    // decompress blocks\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    memset(&bhdr, 0, sizeof(bhdr));\n    for (;;)\n    {\n#define buf ibuf\n        int i;\n        unsigned sz_unc, sz_cpr;\n\n        fi->readx(&bhdr, szb_info);\n        ph.u_len = sz_unc = get_te32(&bhdr.sz_unc);\n        ph.c_len = sz_cpr = get_te32(&bhdr.sz_cpr);\n\n        if (sz_unc == 0)                   // uncompressed size 0 -> EOF\n        {\n            // note: must reload sz_cpr as magic is always stored le32\n            sz_cpr = get_le32(&bhdr.sz_cpr);\n            if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n                throwCompressedDataViolation();\n            break;\n        }\n        if (sz_unc <= 0 || sz_cpr <= 0)\n            throwCompressedDataViolation();\n        if (sz_cpr > sz_unc || sz_unc > blocksize)\n            throwCompressedDataViolation();\n\n        i = blocksize + OVERHEAD - sz_cpr;\n        if (i < 0)\n            throwCantUnpack("corrupt b_info");\n        fi->readx(buf+i, sz_cpr);\n        // update checksum of compressed data\n        c_adler = upx_adler32(buf + i, sz_cpr, c_adler);\n        // decompress\n        if (sz_cpr < sz_unc) {\n            decompress(buf+i, buf, false);\n            if (0!=bhdr.b_ftid) {\n                Filter ft(ph.level);\n                ft.init(bhdr.b_ftid);\n                ft.cto = bhdr.b_cto8;\n                ft.unfilter(buf, sz_unc);\n            }\n            i = 0;\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(buf + i, sz_unc, u_adler);\n        total_in  += sz_cpr;\n        total_out += sz_unc;\n        // write block\n        if (fo)\n            fo->write(buf + i, sz_unc);\n#undef buf\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (ph.version > 8 && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 559, '_4': 659, '_5': 'PackUnix.unpack:void(OutputFile*)', '_6': 'src/p_unix.cpp'}, {'_1': 111669150403, '_2': 'void PackVmlinuxBase<T>::unpack(OutputFile *fo)\n{\n    TE32 word;\n    PackHeader const ph_tmp(ph);\n\n    fi->seek(p_note0->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note0->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n    if (!has_valid_vmlinux_head()) {\n        throwCantUnpack(".text corrupted");\n    }\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf);\n\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    fi->seek(p_note1->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note1->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, p_note1->sh_size - sizeof(ph.u_len));\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n}\n', '_3': 609, '_4': 656, '_5': 'PackVmlinuxBase.unpack:void(OutputFile*)', '_6': 'src/p_vmlinx.cpp'}, {'_1': 111669150469, '_2': 'void PackVmlinuzI386::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, physical_start);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 682, '_4': 710, '_5': 'PackVmlinuzI386.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150484, '_2': 'void PackVmlinuzARMEL::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 1039, '_4': 1067, '_5': 'PackVmlinuzARMEL.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150535, '_2': 'void PackWcle::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    readObjectTable();\n    iobject_desc.dealloc();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    decodeImage();\n    decodeObjectTable();\n\n    // unfilter\n    if (ph.filter)\n    {\n        const unsigned text_size = OOT(oh.init_cs_object-1,npages) * mps;\n        const unsigned text_vaddr = OOT(oh.init_cs_object-1,my_base_address);\n\n        Filter ft(ph.level);\n        ft.init(ph.filter, text_vaddr);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(oimage+ph.u_len-9) >> 24);\n        ft.unfilter(oimage+text_vaddr, text_size);\n    }\n\n    decodeFixupPageTable();\n    decodeFixups();\n    decodeEntryTable();\n    decodePageMap();\n    decodeResidentNames();\n    decodeNonResidentNames();\n\n    for (unsigned ic = 0; ic < soobject_table; ic++)\n        OOT(ic,my_base_address) = 0;\n\n    while (oimage[soimage-1] == 0)\n        soimage--;\n    oh.bytes_on_last_page = soimage % mps;\n\n    // write decompressed file\n    if (fo)\n        writeFile(fo, opt->watcom_le.le);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset\n        + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, &oimage);\n}\n', '_3': 803, '_4': 858, '_5': 'PackWcle.unpack:void(OutputFile*)', '_6': 'src/p_wcle.cpp'}, {'_1': 111669150641, '_2': 'void PackMaster::unpack(OutputFile *fo) {\n    p = getUnpacker(fi);\n    p->assertPacker();\n    fi = NULL;\n    p->doUnpack(fo);\n}', '_3': 265, '_4': 270, '_5': 'PackMaster.unpack:void(OutputFile*)', '_6': 'src/packmast.cpp'}, {'_1': 111669150763, '_2': 'void PeFile32::unpack(OutputFile *fo)\n{\n    bool set_oft = getFormat() == UPX_F_WINCE_ARM_PE;\n    unpack0<pe_header_t, LE32>(fo, ih, oh, 1U << 31, set_oft);\n}', '_3': 3118, '_4': 3122, '_5': 'PeFile32.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669150772, '_2': 'void PeFile64::unpack(OutputFile *fo)\n{\n    unpack0<pe_header_t, LE64>(fo, ih, oh, 1ULL << 63, false);\n}', '_3': 3173, '_4': 3176, '_5': 'PeFile64.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669152545, '_2': 'virtual void unpack(OutputFile *fo) = 0;', '_3': 155, '_4': 155, '_5': 'Packer.unpack:void(OutputFile*)', '_6': 'src/packer.h'}]
Tool result: [{'caller_func': 'void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack("0==e_phnum");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * sizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack("bad e_phoff");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    unsigned const last_Shdr = e_shoff + e_shnum * sizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack("bad e_shoff");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack("bad dynsym->sh_link");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup("JNI_OnLoad");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n', 'caller_start': 240, 'caller_end': 316, 'call_line': 301, 'call_code': 'check_pt_dynamic(phdr)', 'call_path': 'src/p_lx_elf.cpp'}, {'caller_func': 'void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack("0==e_phnum");\n    e_phoff = get_te64(&ehdri.e_phoff);\n    upx_uint64_t const last_Phdr = e_phoff + e_phnum * sizeof(Elf64_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack("bad e_phoff");\n    }\n    e_shoff = get_te64(&ehdri.e_shoff);\n    upx_uint64_t const last_Shdr = e_shoff + e_shnum * sizeof(Elf64_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack("bad e_shoff");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf64_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack("bad dynsym->sh_link");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup("JNI_OnLoad");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n', 'caller_start': 710, 'caller_end': 786, 'call_line': 771, 'call_code': 'check_pt_dynamic(phdr)', 'call_path': 'src/p_lx_elf.cpp'}, {'caller_func': 'bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: \'~\': zero extending \'unsigned int\' to \'upx_uint64_t\' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack("PT_NOTEs too big; try \'--force-execve\'");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#x above stub", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1694, 'caller_end': 1979, 'call_line': 1835, 'call_code': 'check_pt_dynamic(phdr)', 'call_path': 'src/p_lx_elf.cpp'}, {'caller_func': 'bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#lx above stub", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1981, 'caller_end': 2207, 'call_line': 2072, 'call_code': 'check_pt_dynamic(phdr)', 'call_path': 'src/p_lx_elf.cpp'}]
Tool result: [{'caller_func': 'bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: \'~\': zero extending \'unsigned int\' to \'upx_uint64_t\' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack("PT_NOTEs too big; try \'--force-execve\'");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#x above stub", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1694, 'caller_end': 1979, 'call_line': 1845, 'call_code': 'calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))', 'call_path': 'src/p_lx_elf.cpp'}, {'caller_func': 'bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: \'~\': zero extending \'unsigned int\' to \'upx_uint64_t\' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack("PT_NOTEs too big; try \'--force-execve\'");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#x above stub", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1694, 'caller_end': 1979, 'call_line': 1847, 'call_code': 'calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))', 'call_path': 'src/p_lx_elf.cpp'}, {'caller_func': 'bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#lx above stub", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1981, 'caller_end': 2207, 'call_line': 2082, 'call_code': 'calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))', 'call_path': 'src/p_lx_elf.cpp'}, {'caller_func': 'bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack("invalid Ehdr e_ehsize; try \'--force-execve\'");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack("non-contiguous Ehdr/Phdr; try \'--force-execve\'");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack("too many ElfXX_Phdr; try \'--force-execve\'");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack("Go-language PT_LOAD: try hemfix.c, or try \'--force-execve\'");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack("first PT_LOAD.p_offset != 0; try \'--force-execve\'");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)".shstrtab",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack("bad e_shstrndx");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack("DT_TEXTREL found; re-compile with -fPIC");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack("DT_ tag above stub");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           "PT_NOTE %#lx above stub", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, "shlib canPack: xct_va=%#lx  xct_off=%lx\\n",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack("need DT_INIT; try \\"void _init(void){}\\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}\n', 'caller_start': 1981, 'caller_end': 2207, 'call_line': 2084, 'call_code': 'calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))', 'call_path': 'src/p_lx_elf.cpp'}]
/app/repos/Maximus5-ConEmu_36e1571
Workspace already exists, importing it...
[33mval[0m [36mres186[0m: [32mOption[0m[io.joern.console.workspacehandling.Project] = Some(
  value = Project(
    projectFile = ProjectFile(
      inputPath = "/app/repos/Maximus5-ConEmu_36e1571/cpg.bin",
      name = "98eb5c261b6bf416446f88e2cadc4464"
    ),
    path = /app/workspace/98eb5c261b6bf416446f88e2cadc4464,
    cpg = Some(value = Cpg[Graph[984637 nodes]])
  )
)

Tool result: []
Tool result: [{'_1': 111669160541, '_2': "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n", '_3': 467, '_4': 680, '_5': 'Media_GetSample', '_6': 'src/isomedia/media.c'}]
Tool result: [{'caller_func': 'static GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(mdia->nalu_parser) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(mdia->nalu_parser, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(mdia->nalu_parser) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tsample_offset = (s8) gf_bs_read_int(mdia->nalu_parser, 8);\n\t\t\tdata_offset = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("ISOBMF: Extractor target track is not present in file - skipping.\\n"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\tif (!mdia->extracted_samp) return GF_IO_ERR;\n\t\t\t}\n\t\t\tif (!mdia->extracted_bs) {\n\t\t\t\tmdia->extracted_bs = gf_bs_new("a", 1, GF_BITSTREAM_READ);\n\t\t\t\tif (!mdia->extracted_bs) return GF_IO_ERR;\n\t\t\t}\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\t\t\tif (!mdia->extracted_samp->alloc_size)\n\t\t\t\tmdia->extracted_samp->alloc_size = mdia->extracted_samp->dataLength;\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 "all supported NALUs" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_bs_reassign_buffer(mdia->extracted_bs, mdia->extracted_samp->data + data_offset, mdia->extracted_samp->dataLength - data_offset);\n\n\t\t\tif (mdia->extracted_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(mdia->extracted_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer_alloc = ref_nalu_size;\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(mdia->extracted_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("ISOBMF: Extractor size is larger than referred sample size - skipping.\\n"));\n\t\t\t}\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tif (nal_size - nb_bytes_nalh > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size - nb_bytes_nalh;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * (nal_size - nb_bytes_nalh) );\n\t\t}\n\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n', 'caller_start': 101, 'caller_end': 266, 'call_line': 182, 'call_code': 'Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL)', 'call_path': 'src/isomedia/avc_ext.c'}, {'caller_func': 'GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n', 'caller_start': 1891, 'caller_end': 1931, 'call_line': 1916, 'call_code': 'Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset)', 'call_path': 'src/isomedia/isom_read.c'}, {'caller_func': 'GF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}', 'caller_start': 2049, 'caller_end': 2080, 'call_line': 2069, 'call_code': 'Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset)', 'call_path': 'src/isomedia/isom_read.c'}, {'caller_func': "GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n", 'caller_start': 2142, 'caller_end': 2309, 'call_line': 2266, 'call_code': 'Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset)', 'call_path': 'src/isomedia/isom_read.c'}]
Tool result: [{'_1': 111669153979, '_2': "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", '_3': 974, '_4': 1004, '_5': 'SrvAnsiImpl.ReportString:bool(LPCWSTR)', '_6': 'src/ConEmuCD/ConAnsiImpl.cpp'}, {'_1': 111669154618, '_2': "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", '_3': 2492, '_4': 2525, '_5': 'CEAnsi.ReportString:BOOL(LPCWSTR)', '_6': 'src/ConEmuHk/Ansi.cpp'}, {'_1': 111669158958, '_2': 'BOOL ReportString(LPCWSTR asRet);', '_3': 202, '_4': 202, '_5': 'CEAnsi.ReportString:ANY(LPCWSTR)', '_6': 'src/ConEmuHk/Ansi.h'}]
Tool result: [{'_1': 111669153979, '_2': "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", '_3': 974, '_4': 1004, '_5': 'SrvAnsiImpl.ReportString:bool(LPCWSTR)', '_6': 'src/ConEmuCD/ConAnsiImpl.cpp'}, {'_1': 111669154618, '_2': "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", '_3': 2492, '_4': 2525, '_5': 'CEAnsi.ReportString:BOOL(LPCWSTR)', '_6': 'src/ConEmuHk/Ansi.cpp'}, {'_1': 111669158958, '_2': 'BOOL ReportString(LPCWSTR asRet);', '_3': 202, '_4': 202, '_5': 'CEAnsi.ReportString:ANY(LPCWSTR)', '_6': 'src/ConEmuHk/Ansi.h'}]
Tool result: [{'caller_func': 'gentity_t *AICast_CreateCharacter( gentity_t *ent, float *attributes, cast_weapon_info_t *weaponInfo, char *castname, char *model, char *head, char *sex, char *color, char *handicap ) {\n\tgentity_t       *newent;\n\tgclient_t       *client;\n\tcast_state_t    *cs;\n\tchar            **ppStr;\n\tint j;\n\n\tif ( g_gametype.integer > GT_SINGLE_PLAYER ) { // no cast AI in multiplayer\n\t\treturn NULL;\n\t}\n\t// are bots enabled?\n\tif ( !trap_Cvar_VariableIntegerValue( "bot_enable" ) ) {\n\t\tG_Printf( S_COLOR_RED "ERROR: Unable to spawn %s, \'bot_enable\' is not set\\n", ent->classname );\n\t\treturn NULL;\n\t}\n\t//\n\t// make sure we have a free slot for them\n\t//\n\tif ( level.numPlayingClients + 1 > aicast_maxclients ) {\n\t\tG_Error( "Exceeded sv_maxclients (%d), unable to create %s\\n", aicast_maxclients, ent->classname );\n\t\treturn NULL;\n\t}\n\t//\n\t// add it to the list (only do this if everything else passed)\n\t//\n\n\tnewent = AICast_AddCastToGame( ent, castname, model, head, sex, color, handicap );\n\n\tif ( !newent ) {\n\t\treturn NULL;\n\t}\n\tclient = newent->client;\n\t//\n\t// setup the character..\n\t//\n\tcs = AICast_GetCastState( newent->s.number );\n\t//\n\tcs->aiCharacter = ent->aiCharacter;\n\t// used with g_airespawn\n\tcs->died = qfalse;\n\tcs->norespawn = qfalse;\n\n\tclient->ps.aiChar = ent->aiCharacter;\n\t// setup the attributes\n\tmemcpy( cs->attributes, attributes, sizeof( cs->attributes ) );\n\tppStr = &ent->aiAttributes;\n\tAICast_CheckLevelAttributes( cs, ent, ppStr );\n\t//\n\tAICast_SetAASIndex( cs );\n\t// make sure they face the right direction\n\tVectorCopy( ent->s.angles, cs->ideal_viewangles );\n\t// factor in the delta_angles\n\tfor ( j = 0; j < 3; j++ ) {\n\t\tcs->viewangles[j] = AngleMod( newent->s.angles[j] - SHORT2ANGLE( newent->client->ps.delta_angles[j] ) );\n\t}\n\tVectorCopy( ent->s.angles, newent->s.angles );\n\tVectorCopy( ent->s.origin, cs->startOrigin );\n\t//\n\tcs->lastEnemy = -1;\n\tcs->enemyNum = -1;\n\tcs->leaderNum = -1;\n\tcs->castScriptStatus.scriptGotoEnt = -1;\n\t//\n\tnewent->aiName = ent->aiName;\n\tnewent->aiTeam = ent->aiTeam;\n\tnewent->targetname = ent->targetname;\n\t//\n\tnewent->AIScript_AlertEntity = ent->AIScript_AlertEntity;\n\tnewent->aiInactive = ent->aiInactive;\n\tnewent->aiCharacter = cs->aiCharacter;\n\t//\n\t// parse the AI script for this character (if applicable)\n\tcs->aiFlags |= AIFL_CORPSESIGHTING;     // this is on by default for all characters, disabled if they have a "friendlysightcorpse" script event\n\tAICast_ScriptParse( cs );\n\t//\n\t// setup bounding boxes\n\t//VectorCopy( mins, client->ps.mins );\n\t//VectorCopy( maxs, client->ps.maxs );\n\tAIChar_SetBBox( newent, cs, qfalse );\n\tclient->ps.friction = cs->attributes[RUNNING_SPEED] / 300.0;\n\t//\n\t// clear weapons/ammo\n\tclient->ps.weapon = 0;\n\tmemcpy( client->ps.weapons, weaponInfo->startingWeapons, sizeof( weaponInfo->startingWeapons ) );\n\tmemcpy( client->ps.ammo, weaponInfo->startingAmmo, sizeof( client->ps.ammo ) );\n\t//\n\t// starting health\n\tif ( ent->health ) {\n\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = ent->health;\n\t} else {\n\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = cs->attributes[STARTING_HEALTH];\n\t}\n\n\tif ( g_gametype.integer <= GT_COOP ) {\n#if 0\n\t\tif ( newent->health < 125 ) {\n\t\t\tif ( g_gameskill.integer == GSKILL_EASY ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 75;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_MEDIUM ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 100;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_HARD ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 125;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_MAX ) {\n\t\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 225;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tif ( g_gameskill.integer == GSKILL_MEDIUM ) {\n\t\t\t\tnewent->health *= 1.25;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_HARD ) {\n\t\t\t\tnewent->health *= 1.5;\n\t\t\t} else if ( g_gameskill.integer == GSKILL_MAX ) {\n\t\t\t\tnewent->health *= 2;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif ( g_gameskill.integer == GSKILL_EASY ) {\n\t\t\tnewent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] = 1;\n\t\t\tcs->attributes[AIM_SKILL] = 0.6;\n\t\t\tcs->attributes[ATTACK_SKILL] = 0.6;\n\t\t} else if ( g_gameskill.integer == GSKILL_MEDIUM ) {\n\t\t\tcs->attributes[AIM_SKILL] = 0.75;\n\t\t\tcs->attributes[ATTACK_SKILL] = 0.75;\n\t\t} else if ( g_gameskill.integer == GSKILL_HARD ) {\n\t\t\tcs->attributes[AIM_SKILL] = 0.9;\n\t\t\tcs->attributes[ATTACK_SKILL] = 0.9;\n\t\t} else if ( g_gameskill.integer == GSKILL_MAX ) {\n\t\t\tcs->attributes[AIM_SKILL] = 1.0;\n\t\t\tcs->attributes[ATTACK_SKILL] = 1.0;\n\t\t}\n\n\t\tcs->respawnsleft = g_airespawn.integer;\n\t}\n\t//\n\tcs->weaponInfo = weaponInfo;\n\t//\n\tcs->lastThink = level.time;\n\t//\n\tnewent->pain = AICast_Pain;\n\tnewent->die = AICast_Die;\n\t//\n\t//update the attack inventory values\n\tAICast_UpdateBattleInventory( cs, cs->enemyNum );\n\n//----(SA)\tmake sure all clips are loaded so we don\'t hear everyone loading up\n//\t\t\t(we don\'t want to do this inside AICast_UpdateBattleInventory(), only on spawn or giveweapon)\n\tfor ( j = 0; j < WP_NUM_WEAPONS; j++ ) {\n\t\tFill_Clip( &client->ps, j );\n\t}\n//----(SA)\tend\n\n\t// select a weapon\n\tAICast_ChooseWeapon( cs, qfalse );\n\n\t//\n\t// set the default function, overwrite if necessary\n\tcs->aiFlags |= AIFL_JUST_SPAWNED;\n\tAIFunc_DefaultStart( cs );\n\t//\n\tnumcast++;\n\t//\n\treturn newent;\n}\n', 'caller_start': 344, 'caller_end': 507, 'call_line': 417, 'call_code': 'AICast_ScriptParse( cs )', 'call_path': 'code/game/ai_cast.c'}, {'caller_func': 'void ClientSpawn( gentity_t *ent ) {\n\tint index;\n\tvec3_t spawn_origin, spawn_angles;\n\tgclient_t   *client;\n\tint i;\n\tclientPersistant_t saved;\n\tclientSession_t savedSess;\n\tint persistant[MAX_PERSISTANT];\n\tgentity_t   *spawnPoint = NULL;\n\tgentity_t *tent;\n\tint flags;\n\tint savedPing;\n\t//int savedTeam;\n\tint savedAmmo[MAX_WEAPONS];\n\tint savedAmmoclip[MAX_WEAPONS];\n\tint savedWeapon = 0, savedWeaponstate = 0;\n\tint savedWeapons[MAX_WEAPONS] = { 0 };\n\tvec3_t saved_spawn_origin = { 0, 0, 0 }, saved_spawn_angles = { 0, 0, 0 };\n\tqboolean savedHasCoopSpawn = qtrue;\n\n\tindex = ent - g_entities;\n\tclient = ent->client;\n\n\tVectorClear(spawn_origin);\n\n\t// find a spawn point\n\t// do it before setting health back up, so farthest\n\t// ranging doesn\'t count this client\n\n\t// Ridah\n\tif ( ent->r.svFlags & SVF_CASTAI ) {\n\t\tspawnPoint = ent;\n\t\tVectorCopy( ent->s.origin, spawn_origin );\n\t\tspawn_origin[2] += 9;   // spawns seem to be sunk into ground?\n\t\tVectorCopy( ent->s.angles, spawn_angles );\n\t} else {\n\t\t// force team\n\t\tif ( client->sess.sessionTeam == TEAM_FREE ) {\n\t\t\tclient->sess.sessionTeam = TEAM_BLUE;\n\t\t}\n\n\t\t// force this player to AICHAR_NONE (for G_IsClientAI)\n\t\tent->aiCharacter = AICHAR_NONE;\n\n\t\tif ( !ent->client->pers.initialSpawn ) {\n\t\t\tent->aiName = "player";  // needed for script AI\n\t\t\tif ( client->sess.sessionTeam == TEAM_RED ) {\n\t\t\t\tent->aiTeam = AITEAM_NAZI;                        // member of axis\n\t\t\t} else if ( client->sess.sessionTeam == TEAM_BLUE ) {\n\t\t\t\tent->aiTeam = AITEAM_ALLIES;                        // member of allies\n\t\t\t}\n\t\t\tent->client->ps.teamNum = ent->aiTeam;\n\t\t\tAICast_ScriptParse( AICast_GetCastState( ent->s.number ) );\n\t\t}\n\n\t\tif ( client->sess.sessionTeam == TEAM_SPECTATOR ) {\n\t\t\tspawnPoint = SelectSpectatorSpawnPoint(\n\t\t\t\tspawn_origin, spawn_angles );\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// the first spawn should be at a good looking spot\n\t\t\t\tif ( !client->pers.initialSpawn && client->pers.localClient ) {\n\t\t\t\t\t// moved this down\n\t\t\t\t\t//client->pers.initialSpawn = qtrue;\n\t\t\t\t\tif ( client->sess.sessionTeam == TEAM_RED ) {\n\t\t\t\t\t\tif ( g_gametype.integer != GT_COOP_BATTLE ) {\n\t\t\t\t\t\t\tspawnPoint = SelectRandomAntiCoopSpawnPoint( ent, spawn_origin, spawn_angles );\n\t\t\t\t\t\t\tif ( !spawnPoint ) { // we need spawnpoints for the axis\n\t\t\t\t\t\t\t\tspawnPoint = SelectSpawnPoint(\n\t\t\t\t\t\t\t\t\tclient->ps.origin,\n\t\t\t\t\t\t\t\t\tspawn_origin, spawn_angles );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( g_gametype.integer <= GT_COOP ) {\n\t\t\t\t\t\t\tspawnPoint = SelectRandomCoopSpawnPoint( spawn_origin, spawn_angles );\n\t\t\t\t\t\t\tif ( !spawnPoint ) {\n\t\t\t\t\t\t\t\tG_Printf( "No coop spawnpoints found\\n" );\n\t\t\t\t\t\t\t\tspawnPoint = SelectInitialSpawnPoint( spawn_origin, spawn_angles, qfalse );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspawnPoint = SelectInitialSpawnPoint( spawn_origin, spawn_angles, qfalse );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tent->client->hasCoopSpawn = qfalse;\n\t\t\t\t} else {\n\t\t\t\t\t// note: on a dedicated server when the first player arrives and he\'s axis\n\t\t\t\t\t// no bots are alive, so no spawnpoint (bot) can be found\n\t\t\t\t\tif ( client->sess.sessionTeam == TEAM_RED && g_gametype.integer != GT_COOP_BATTLE ) {\n\t\t\t\t\t\tspawnPoint = SelectRandomAntiCoopSpawnPoint( ent, spawn_origin, spawn_angles );\n\t\t\t\t\t\tif ( !spawnPoint ) { // we need spawnpoints for the axis\n\t\t\t\t\t\t\tspawnPoint = SelectSpawnPoint( client->ps.origin, spawn_origin, spawn_angles );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( g_gametype.integer <= GT_COOP && ent->client->hasCoopSpawn ) {\n\t\t\t\t\t\t\t// TODO: select random spot from friends\n\t\t\t\t\t\t\tVectorCopy( client->coopSpawnPointOrigin, spawn_origin );\n\t\t\t\t\t\t\tVectorCopy( client->coopSpawnPointAngles, spawn_angles );\n\t\t\t\t\t\t\tspawnPoint = ent;\n\n\t\t\t\t\t\t\t// don\'t spawn near existing origin if possible\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tspawnPoint = SelectRandomCoopSpawnPoint( spawn_origin, spawn_angles );\n\t\t\t\t\t\t\tif ( !spawnPoint ) {\n\t\t\t\t\t\t\t\tspawnPoint = SelectSpawnPoint( client->ps.origin, spawn_origin, spawn_angles );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tim needs to prevent bots from spawning at the initial point\n\t\t\t\t// on q3dm0...\n\t\t\t\tif ( ( spawnPoint->flags & FL_NO_BOTS ) && ( ent->r.svFlags & SVF_BOT ) ) {\n\t\t\t\t\tcontinue;   // try again\n\t\t\t\t}\n\t\t\t\t// just to be symetric, we have a nohumans option...\n\t\t\t\tif ( ( spawnPoint->flags & FL_NO_HUMANS ) && !( ent->r.svFlags & SVF_BOT ) ) {\n\t\t\t\t\tcontinue;   // try again\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t} while ( 1 );\n\t\t}\n\t\t\n\t\t// Ridah\n\t}\n\t// done.\n\n\tclient->pers.teamState.state = TEAM_ACTIVE;\n\n\n\t// toggle the teleport bit so the client knows to not lerp\n\tflags = ent->client->ps.eFlags & EF_TELEPORT_BIT;\n\tflags ^= EF_TELEPORT_BIT;\n\n\t// Save the Vote if player cast it\n\tflags |= ( client->ps.eFlags & EF_VOTED );\n\n\t// clear everything but the persistant data\n\tsaved = client->pers;\n\tsavedSess = client->sess;\n\tsavedPing = client->ps.ping;\n\t//savedTeam = client->ps.teamNum;\n\tfor ( i = 0 ; i < MAX_PERSISTANT ; i++ ) {\n\t\tpersistant[i] = client->ps.persistant[i];\n\t}\n\n\tif ( g_gametype.integer <= GT_COOP ) {\n\n\t\t// save weapons for respawn\n\t\tsavedWeapon = client->ps.weapon;\n\t\tsavedWeaponstate = client->ps.weaponstate;\n\n\t\tfor ( i = 0 ; i < MAX_WEAPONS ; i++ ) {\n\t\t\tsavedAmmo[i] = client->ps.ammo[i];\n\t\t\tsavedAmmoclip[i] = client->ps.ammoclip[i];\n\t\t}\n\t\tfor ( i = 0 ; i < ( MAX_WEAPONS / ( sizeof( int ) * 8 ) ) ; i++ ) {\n\t\t\tsavedWeapons[i] = client->ps.weapons[i];\n\t\t}\n\n\t\t// later on, we will disable this for speedrun\n\t\tif ( g_gametype.integer <= GT_COOP ) {\n\t\t\t// save the spawnpoint\n\t\t\tVectorCopy( client->coopSpawnPointOrigin, saved_spawn_origin );\n\t\t\tVectorCopy( client->coopSpawnPointAngles, saved_spawn_angles );\n\t\t\tsavedHasCoopSpawn = client->hasCoopSpawn;\n\t\t}\n\t}\n\n\t// clear everything\n\tmemset( client, 0, sizeof( *client ) );\n\n\tclient->pers = saved;\n\tclient->sess = savedSess;\n\tclient->ps.ping = savedPing;\n\tclient->ps.teamNum = ent->aiTeam; /*savedTeam;*/\n\tfor ( i = 0 ; i < MAX_PERSISTANT ; i++ ) {\n\t\tclient->ps.persistant[i] = persistant[i];\n\t}\n\n\tif ( g_gametype.integer <= GT_COOP ) {\n\n\t\t// restore weapons after a respawn\n\t\tclient->ps.weapon = savedWeapon;\n\t\tclient->ps.weaponstate = savedWeaponstate;\n\n\t\tfor ( i = 0 ; i < MAX_WEAPONS ; i++ ) {\n\t\t\tclient->ps.ammo[i] = savedAmmo[i];\n\t\t\tclient->ps.ammoclip[i] = savedAmmoclip[i];\n\t\t}\n\t\tfor ( i = 0 ; i < ( MAX_WEAPONS / ( sizeof( int ) * 8 ) ) ; i++ ) {\n\t\t\tclient->ps.weapons[i] = savedWeapons[i];\n\t\t}\n\n\t\t// later on, we will disable this for speedrun\n\t\tif ( g_gametype.integer <= GT_COOP ) {\n\t\t\t// restore the spawnpoint\n\t\t\tVectorCopy( saved_spawn_origin, client->coopSpawnPointOrigin );\n\t\t\tVectorCopy( saved_spawn_angles, client->coopSpawnPointAngles );\n\t\t\tclient->hasCoopSpawn = savedHasCoopSpawn;\n\t\t}\n\t}\n\n\t// increment the spawncount so the client will detect the respawn\n\tclient->ps.persistant[PERS_SPAWN_COUNT]++;\n\tclient->ps.persistant[PERS_TEAM] = client->sess.sessionTeam;\n\n\tclient->airOutTime = level.time + 12000;\n\n\t// clear entity values\n\tclient->ps.stats[STAT_MAX_HEALTH] = client->pers.maxHealth;\n\tclient->ps.eFlags = flags;\n\t// MrE: use capsules for AI and player\n\tclient->ps.eFlags |= EF_CAPSULE;\n\n\tent->s.groundEntityNum = ENTITYNUM_NONE;\n\tent->client = &level.clients[index];\n\tent->takedamage = qtrue;\n\tent->inuse = qtrue;\n\tif ( !( ent->r.svFlags & SVF_CASTAI ) ) {\n\t\tent->classname = "player";\n\t}\n\tent->r.contents = CONTENTS_BODY;\n\n\t// RF, AI should be clipped by monsterclip brushes\n\tif ( ent->r.svFlags & SVF_CASTAI ) {\n\t\tent->clipmask = MASK_PLAYERSOLID | CONTENTS_MONSTERCLIP;\n\t} else {\n\t\tent->clipmask = MASK_PLAYERSOLID;\n\t}\n\n\tent->die = player_die;\n\tent->waterlevel = 0;\n\tent->watertype = 0;\n\tent->flags = 0;\n\n\t// freeze the players if needed\n\tif ( g_freeze.integer && g_gametype.integer <= GT_COOP && !( ent->r.svFlags & SVF_CASTAI ) ) {\n\t\tint frozen = 0;\n\t\tint i = 0;\n\t\tgentity_t *player;\n\n\t\tfor ( i = 0 ; i < g_maxclients.integer ; i++ ) {\n\t\t\tplayer = &g_entities[i];\n\n\t\t\tif ( !player || !player->inuse || player == ent ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( player->r.svFlags & SVF_CASTAI ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( player->client->ps.eFlags & EF_FROZEN ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrozen++;\n\t\t}\n\n\t\t// only freeze them when there are still others not frozen\n\t\tif ( frozen && client->ps.persistant[PERS_SPAWN_COUNT] > 1 ) {\n\t\t\tclient->ps.eFlags |= EF_FROZEN;\n\t\t\tent->flags |= FL_NOTARGET;\n\t\t}\n\t}\n\n\tVectorCopy( playerMins, ent->r.mins );\n\tVectorCopy( playerMaxs, ent->r.maxs );\n\n\t// Ridah, setup the bounding boxes and viewheights for prediction\n\tVectorCopy( ent->r.mins, client->ps.mins );\n\tVectorCopy( ent->r.maxs, client->ps.maxs );\n\n\tclient->ps.crouchViewHeight = CROUCH_VIEWHEIGHT;\n\tclient->ps.standViewHeight = DEFAULT_VIEWHEIGHT;\n\tclient->ps.deadViewHeight = DEAD_VIEWHEIGHT;\n\n\tclient->ps.crouchMaxZ = client->ps.maxs[2] - ( client->ps.standViewHeight - client->ps.crouchViewHeight );\n\n\tclient->ps.runSpeedScale = 0.8;\n//\tclient->ps.sprintSpeedScale = 1.20;\n\tclient->ps.sprintSpeedScale = 1.1;  // (SA) trying new value\n\tclient->ps.crouchSpeedScale = 0.25;\n\n\t// Rafael\n\tclient->ps.sprintTime = 20000;\n\tclient->ps.sprintExertTime = 0;\n\n\tclient->ps.friction = 1.0;\n\t// done.\n\n\tclient->ps.clientNum = index;\n\n\t// DHM - Nerve :: Add appropriate weapons\n/*\n\tif ( g_gametype.integer == GT_WOLF ) {\n\t\tSetWolfSpawnWeapons( client ); // JPW NERVE -- increases stats[STAT_MAX_HEALTH] based on # of medics in game\n\t}\n\t// dhm - end\n*/\n\n\t// give the player some basic stuff\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tif ( !Q_stricmp( ent->classname, "player" ) ) {\n\t\t\tSetCoopSpawnWeapons( client );\n\t\t}\n\t}\n\n\tclient->pers.initialSpawn = qtrue;\n\n\t// Note to Ryan:\n\t// had to add this because key word giveweapon to player is causing a fatal crash\n\t// This is only a quick fix for the beach map\n/*\n\tif (!(ent->r.svFlags & SVF_CASTAI) && level.scriptAI && strstr (level.scriptAI, "beach assault"))\n\t{\n\t\tCOM_BitSet( client->ps.weapons, WP_THOMPSON );\n\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_THOMPSON)] = 100;\n\n\t\tCOM_BitSet( client->ps.weapons, WP_GRENADE_PINEAPPLE );\n\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_GRENADE_PINEAPPLE)] = 5;\n\n\t\tclient->ps.weapon = WP_THOMPSON;\n\t\tclient->ps.weaponstate = WEAPON_READY;\n\t}\n*/\n\t//----(SA) no longer giving the player any default stuff\n\n//\tCOM_BitSet( client->ps.weapons, WP_MP40 );\n//\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_MP40)] = 100;\n\n//\tif ( g_gametype.integer == GT_SINGLE_PLAYER ) {\n//\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_LUGER)] = 50;\n//\t} else {\n//\t\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_LUGER)] = 100;\n//\t}\n\n//\tCOM_BitSet( client->ps.weapons, WP_GAUNTLET );\n//\tclient->ps.ammo[BG_FindAmmoForWeapon(WP_GAUNTLET)] = -1;\n\n\t// health will count down towards max_health\n//\tent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH] * 1.25;\n\n// JPW NERVE ***NOTE*** the following line is order-dependent and must *FOLLOW* SetWolfSpawnWeapons() in multiplayer\n// SetWolfSpawnWeapons() now adds medic team bonus and stores in ps.stats[STAT_MAX_HEALTH].\n\tent->health = client->ps.stats[STAT_HEALTH] = client->ps.stats[STAT_MAX_HEALTH];\n\n\tG_SetOrigin( ent, spawn_origin );\n\tVectorCopy( spawn_origin, client->ps.origin );\n\n\t// the respawned flag will be cleared after the attack and jump keys come up\n\tclient->ps.pm_flags |= PMF_RESPAWNED;\n\n\ttrap_GetUsercmd( client - level.clients, &ent->client->pers.cmd );\n\tSetClientViewAngle( ent, spawn_angles );\n\n\t// don\'t allow full run speed for a bit\n\tclient->ps.pm_flags |= PMF_TIME_KNOCKBACK;\n\tclient->ps.pm_time = 100;\n\n\tclient->respawnTime = level.time;\n\tclient->inactivityTime = level.time + g_inactivity.integer * 1000;\n\tclient->latched_buttons = 0;\n\tclient->latched_wbuttons = 0;   //----(SA)\tadded\n\n\tif (!level.intermissiontime) {\n\t\tif (ent->client->sess.sessionTeam != TEAM_SPECTATOR) {\n\t\t\t// don\'t kill our coop friends !\n\t\t\t// FIXME: make sure players dont get stuck in each other\n\t\t\t//if ( !g_coop.integer )\n\t\t\t\tG_KillBox(ent);\n\n\t\t\t// force the base weapon up\n//\t\t\tclient->ps.weapon = WP_MACHINEGUN;\n//\t\t\tclient->ps.weaponstate = WEAPON_READY;\n\n\t\t\t// fire the targets of the spawn point\n\t\t\tif ( g_gametype.integer < GT_SINGLE_PLAYER ) {\n\t\t\t\tG_UseTargets( spawnPoint, ent );\n\t\t\t}\n\t\t\t// select the highest weapon number available, after any spawn given items have fired\n//\t\t\tclient->ps.weapon = 1;\n//\t\t\tfor (i = WP_NUM_WEAPONS - 1 ; i > 0 ; i--) {\n//\t\t\t\tif (client->ps.stats[STAT_WEAPONS] & (1 << i)) {\n//\t\t\t\t\tclient->ps.weapon = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\n\t\t\t// positively link the client, even if the command times are weird\n\t\t\tVectorCopy(ent->client->ps.origin, ent->r.currentOrigin);\n\n\t\t\ttent = G_TempEntity(ent->client->ps.origin, EV_PLAYER_TELEPORT_IN);\n\t\t\ttent->s.clientNum = ent->s.clientNum;\n\n\t\t\ttrap_LinkEntity (ent);\n\t\t}\n\t} else {\n\t\t// move players to intermission\n\t\tMoveClientToIntermission(ent);\n\t}\n\n\t// run a client frame to drop exactly to the floor,\n\t// initialize animations and other things\n\tclient->ps.commandTime = level.time - 100;\n\tent->client->pers.cmd.serverTime = level.time;\n\tClientThink( ent - g_entities );\n\n\t// Spectator\'s should probably have 0 health.\n\tif ( G_IsClientOnTeam( ent, TEAM_SPECTATOR ) ) {\n\t\tent->health = 0;\n\t}\n\n\t// run the presend to set anything else, follow spectators wait\n\t// until all clients have been reconnected after map_restart\n\tif ( ent->client->sess.spectatorState != SPECTATOR_FOLLOW ) {\n\t\tClientEndFrame( ent );\n\t}\n\n\t// clear entity state values\n\tBG_PlayerStateToEntityState( &client->ps, &ent->s, qtrue );\n\n\t// et sdk antilag\n\tG_ResetMarkers( ent );\n}\n', 'caller_start': 1819, 'caller_end': 2247, 'call_line': 1871, 'call_code': 'AICast_ScriptParse( AICast_GetCastState( ent->s.number ) )', 'call_path': 'code/game/g_client.c'}]
Tool result: [{'caller_func': 'void G_InitGame( int levelTime, int randomSeed, int restart ) {\n\tint i;\n\tint fps;\n\tint r;\n\n\t//if ( trap_Cvar_VariableIntegerValue( "g_gametype" ) != GT_SINGLE_PLAYER ) {\n\tG_Printf( "------- Game Initialization -------\\n" );\n\tG_Printf( "gamename: %s\\n", GAMEVERSION );\n\tG_Printf( "gamedate: %s\\n", PRODUCT_DATE );\n\t//}\n\n\tsrand( randomSeed );\n\n\tG_RegisterCvars();\n\n\t// g_random is a value from 1 - 10 (1 and 10 included)\n\t// is used in the scripting to randomize entity locations, and more\n\tr = ( rand() % 10 ) + 1;\n\ttrap_Cvar_Set( "g_random", va( "%d", r ) );\n\n\t// Xian enforcemaxlives stuff\n\t/*\n\twe need to clear the list even if enforce maxlives is not active\n\tin cas ethe g_maxlives was changed, and a map_restart happened\n\t*/\n\tClearMaxLivesGUID();\n\n\t// just for verbosity\n\tif ( g_enforcemaxlives.integer && ( g_maxlives.integer > 0 ) ) {\n\t\tG_Printf( "EnforceMaxLives-Cleared GUID List\\n" );\n\t}\n\n#ifndef _ADMINS\n\tG_ProcessIPBans();\n#endif\n\n\tG_InitMemory();\n\n\t// NERVE - SMF - intialize gamestate\n\tif ( g_gamestate.integer == GS_INITIALIZE ) {\n\t\t//if ( g_noTeamSwitching.integer ) {\n\t\t//        trap_Cvar_Set( "gamestate", va( "%i", GS_WAITING_FOR_PLAYERS ) );\n\t\t//} else {\n\t\ttrap_Cvar_Set( "gamestate", va( "%i", GS_WARMUP ) );\n\t\t//}\n\t}\n\n\t// set some level globals\n\tmemset( &level, 0, sizeof( level ) );\n\tlevel.time = levelTime;\n\tlevel.startTime = levelTime;\n\n\tlevel.lastSpawnSave = levelTime;\n\tlevel.lastBattleScorecheck = levelTime;\n\n\tlevel.numSecrets = 0;   //----(SA)\tadded\n\n\t// don\'t need it.\n//\tlevel.snd_fry = G_SoundIndex("sound/player/fry.wav");\t// FIXME standing in lava / slime\n\n\tlevel.bulletRicochetSound = G_SoundIndex( "bulletRicochet" );\n\n\tlevel.snipersound = G_SoundIndex( "sound/weapons/mauser/mauserf1.wav" );\n\n\t//----(SA)\tadded sound caching\n\tlevel.knifeSound[0] = G_SoundIndex( "sound/weapons/knife/knife_hitwall1.wav" );\n\t//----(SA)\tend\n\n\t// RF, init the anim scripting\n\tlevel.animScriptData.soundIndex = G_SoundIndex;\n\tlevel.animScriptData.playSound = G_AnimScriptSound;\n\n\tG_InitWorldSession();\n\n\t// initialize all entities for this game\n\tmemset( g_entities, 0, MAX_GENTITIES * sizeof( g_entities[0] ) );\n\tlevel.gentities = g_entities;\n\n\t// initialize all clients for this game\n\tlevel.maxclients = g_maxclients.integer;\n\tmemset( g_clients, 0, MAX_CLIENTS * sizeof( g_clients[0] ) );\n\tlevel.clients = g_clients;\n\n\t// set client fields on player ents\n\tfor ( i = 0 ; i < level.maxclients ; i++ ) {\n\t\tg_entities[i].client = level.clients + i;\n\t}\n\n\t// always leave room for the max number of clients,\n\t// even if they aren\'t all used, so numbers inside that\n\t// range are NEVER anything but clients\n\tlevel.num_entities = MAX_CLIENTS;\n\n\tfor ( i=0 ; i<MAX_CLIENTS ; i++ ) {\n\t\tg_entities[i].classname = "clientslot";\n\t}\n\n\t// let the server system know where the entites are\n\ttrap_LocateGameData( level.gentities, level.num_entities, sizeof( gentity_t ),\n\t\t\t\t\t\t &level.clients[0].ps, sizeof( level.clients[0] ) );\n\n\t// Ridah\n\tif ( g_gametype.integer <= GT_SINGLE_PLAYER ) {\n\t\tchar s[10];\n\n\t\t// Ridah, initialize cast AI system\n\t\t// DHM - Nerve :: Moved this down so that it only happens in SinglePlayer games\n\t\tAICast_Init();\n\t\t// done.\n\n\t\tAICast_ScriptLoad();\n\n\t\ttrap_Cvar_VariableStringBuffer( "g_missionStats", s, sizeof( s ) );\n\t\tif ( strlen( s ) < 1 ) {\n\t\t\t// g_missionStats is used to get the player to press a key to begin\n\t\t\ttrap_Cvar_Set( "g_missionStats", "xx" );\n\t\t}\n\n\t\tfor ( i = 0; i < 8; i++ )     {  // max objective cvars: 8 (FIXME: use #define somewhere)\n\t\t\ttrap_Cvar_Set( va( "g_objective%i", i + 1 ), "0" );   // clear the objective ROM cvars\n\t\t}\n\n\t\tif ( g_gametype.integer == GT_SINGLE_PLAYER ) {\n\t\t\ttrap_Cvar_Set( "cg_youGotMail", "0" ); // set flag to draw icon\n\t\t} else {\n\t\t\ttrap_SendServerCommand( -1, "yougotmail 0\\n" );\n\t\t}\n\t}\n\n\tfps = trap_Cvar_VariableIntegerValue( "sv_fps" );\n\n\tif ( fps > 0 && g_limbotime.integer <= ( 1000 / fps ) ) {\n\t\ttrap_Cvar_Set( "g_limbotime", "1000" );\n\t\tG_Printf( "WARNING: g_limbotime <= (1000 / sv_fps), forcing to 1000 (one second)\\n" );\n\t}\n\n\tif ( g_gametype.integer == GT_COOP_BATTLE ) {\n\t\ttrap_Cvar_Set( "g_friendlyfire", "2" );\n\t\t//trap_Cvar_Set("g_spawnpoints", "1");\n#ifdef INGAME_CUTSCENES\n\t\ttrap_Cvar_Set( "g_skipcutscenes", "1" );\n#endif\n\t\ttrap_Cvar_Set( "g_freeze", "0" );\n\t\t//trap_Cvar_Set("g_warmup", "20");\n\t\t//trap_Cvar_Set("g_reinforce", "0");\n\t\ttrap_Cvar_Set( "sv_maxcoopclients", "2" );\n\t\ttrap_Cvar_Set( "g_teleporttime", "30000" );\n\t} else {\n\t\t//trap_Cvar_Set("g_warmup", "0");\n\t\t//trap_Cvar_Set("g_warmup", "20");\n\t}\n\n\tif ( g_gametype.integer == GT_COOP_SPEEDRUN ) {\n\t\tchar mapname[MAX_QPATH];\n\t\tchar maptimelimit[MAX_QPATH];\n\t\tfloat newtimelimit = 0.0;\n\n\t\ttrap_Cvar_VariableStringBuffer( "mapname", mapname, sizeof( mapname ) );\n\t\ttrap_Cvar_VariableStringBuffer( va( "g_%s_timelimit", mapname ), maptimelimit, sizeof( maptimelimit ) );\n\n\t\tnewtimelimit = atof( maptimelimit );\n\n\t\tif ( newtimelimit ) {\n\t\t\ttrap_Cvar_Set( "timelimit", va( "%f", newtimelimit ) );\n\t\t} else {\n\t\t\ttrap_Cvar_Set( "timelimit", "20" );\n\t\t}\n\t\tG_Printf( "Timelimit is: %f\\n", g_timelimit.value );\n\t}\n\n\tG_Script_ScriptLoad();\n\t// done.\n\n\t// reserve some spots for dead player bodies\n\tInitBodyQue();\n\n\tClearRegisteredItems();\n\n\t// parse the key/value pairs and spawn gentities\n\tG_SpawnEntitiesFromString();\n\n\t// create the camera entity that will communicate with the scripts\n\tG_SpawnScriptCamera();\n\n\t// general initialization\n\tG_FindTeams();\n\n\tSaveRegisteredItems();\n\n\tif ( g_gametype.integer <= GT_SINGLE_PLAYER || trap_Cvar_VariableIntegerValue( "com_buildScript" ) ) {\n\t\tG_ModelIndex( SP_PODIUM_MODEL );\n\t}\n\n\tif ( trap_Cvar_VariableIntegerValue( "bot_enable" ) ) {\n\t\tBotAISetup( restart );\n\t\tBotAILoadMap( restart );\n//\t\tG_InitBots( restart );\n\t}\n\n\tG_RemapTeamShaders();\n\n\ttrap_SetConfigstring( CS_INTERMISSION, "" );\n\n\t// fretn\n\tG_LoadArenas();\n}\n', 'caller_start': 1312, 'caller_end': 1517, 'call_line': 1422, 'call_code': 'AICast_ScriptLoad()', 'call_path': 'code/game/g_main.c'}]
Tool result: []
Tool result: []
Tool result: []
Tool result: [{'_1': 111669160554, '_2': 'GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}\n', '_3': 31, '_4': 229, '_5': 'Media_RewriteODFrame', '_6': 'src/isomedia/media_odf.c'}]
Tool result: []
Tool result: [{'_1': 111669158108, '_2': 'GF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_BitStream *sei_suffix_bs = NULL;\n\tBool ps_transfered = GF_FALSE;\n\tu32 nal_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\tu8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tGF_ISOSample *base_samp;\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+base_samp->dataLength) ) {\n\t\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+base_samp->dataLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\n\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\ttile_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+tile_samp->dataLength) ) {\n\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+tile_samp->dataLength;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->child_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(mdia, sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (!entry) return GF_BAD_PARAM;\n\n\t//this is a compatible HEVC, don\'t insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config && entry->avc_config->config)\n\t\t\tnal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\t\tnal_unit_size_field = entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\t//setup PS rewriter\n\tif (!mdia->nalu_ps_bs)\n\t\tmdia->nalu_ps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_seek(mdia->nalu_ps_bs, 0);\n\n\t//setup sample reader\n\tif (mdia->in_sample_buffer_alloc<sample->dataLength) {\n\t\tmdia->in_sample_buffer_alloc = sample->dataLength;\n\t\tmdia->in_sample_buffer = gf_realloc(mdia->in_sample_buffer, sample->dataLength);\n\t}\n\tmemcpy(mdia->in_sample_buffer, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) {\n\t\tmdia->nalu_parser = gf_bs_new(mdia->in_sample_buffer, sample->dataLength, GF_BITSTREAM_READ);\n\t\tif (!mdia->nalu_parser && sample->data) return GF_ISOM_INVALID_FILE;\n\t} else {\n\t\te = gf_bs_reassign_buffer(mdia->nalu_parser, mdia->in_sample_buffer, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\t//setup output\n\tif (!mdia->nalu_out_bs) {\n\t\tu8 *output;\n\t\tu32 outSize;\n\t\tmdia->nalu_out_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_get_content(mdia->nalu_out_bs, &output, &outSize);\n\t}\n\n\tgf_bs_reassign_buffer(mdia->nalu_out_bs, sample->data, sample->alloc_size ? sample->alloc_size : sample->dataLength);\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don\'t write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don\'t insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0xF0 , 8); /*7 "all supported NALUs" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\tBool has_vps = GF_FALSE;\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc, &has_vps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc, &has_vps);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (! ps_transfered) {\n\t\t\t\t\tnal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\t\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tps_transfered = GF_TRUE;\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (! ps_transfered)\n\t\t{\n\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t}\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\t\treturn GF_OK;\n\t}\n\n\tif (!mdia->tmp_nal_copy_buffer) {\n\t\tmdia->tmp_nal_copy_buffer = gf_malloc(sizeof(char) * 4096);\n\t\tmdia->tmp_nal_copy_buffer_alloc = 4096;\n\t}\n\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tnal_size = gf_bs_read_int(mdia->nalu_parser, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(mdia->nalu_parser) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char)*nal_size);\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tGF_BitStream *write_to_bs = mdia->nalu_out_bs;\n#endif\n\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tswitch (nal_type) {\n\t\t\t/*we already wrote AU delim, and we trash aggregators*/\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FF_AGGREGATOR:\n\t\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-2);\n\t\t\t\tcontinue;\n\n\t\t\t//extractor\n\t\t\tcase GF_HEVC_NALU_FF_EXTRACTOR:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(mdia->nalu_out_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\tif (sei_suffix_bs) gf_bs_del(sei_suffix_bs);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Invalid nal size %d in sample %d\\n", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tcase GF_AVC_NALU_FF_AGGREGATOR:\n\t\t\t/*we already wrote this stuff, and we trash aggregators*/\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase GF_AVC_NALU_FF_EXTRACTOR:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (!ps_transfered) {\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(mdia->nalu_out_bs, sei_suffix_bs, GF_FALSE);\n\t}\n\t/*done*/\n\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (sei_suffix_bs)\n\t\tgf_bs_del(sei_suffix_bs);\n\n\treturn e;\n}\n', '_3': 401, '_4': 845, '_5': 'gf_isom_nalu_sample_rewrite', '_6': 'src/isomedia/avc_ext.c'}]
Tool result: [{'caller_func': "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n", 'caller_start': 467, 'caller_end': 680, 'call_line': 655, 'call_code': 'Media_RewriteODFrame(mdia, *samp)', 'call_path': 'src/isomedia/media.c'}]
Tool result: []
Result saved to /4_Experiment/RQ5/Caller_Callee/Results/error_analysis/CVE-2022-47662_error.json
Tool result: [{'_1': 111669150013, '_2': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', '_3': 236, '_4': 261, '_5': 'PackCom.unpack:void(OutputFile*)', '_6': 'src/p_com.cpp'}, {'_1': 111669150030, '_2': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', '_3': 401, '_4': 470, '_5': 'PackDjgpp2.unpack:void(OutputFile*)', '_6': 'src/p_djgpp2.cpp'}, {'_1': 111669150043, '_2': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', '_3': 688, '_4': 806, '_5': 'PackExe.unpack:void(OutputFile*)', '_6': 'src/p_exe.cpp'}, {'_1': 111669150173, '_2': 'void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Rela offset", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 3844, '_4': 4161, '_5': 'PackLinuxElf64.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150213, '_2': 'void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n            unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n            Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf32_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                unsigned symval = get_te32(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf32_Sym::SHN_UNDEF != symsec\n                &&  Elf32_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te32(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr *dynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&dynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Rel offset", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 4604, '_4': 4922, '_5': 'PackLinuxElf32.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150214, '_2': 'void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack("internal error");\n}', '_3': 4924, '_4': 4927, '_5': 'PackLinuxElf.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150243, '_2': 'void PackLinuxElf32x86interp::unpack(OutputFile *fo)\n{\n#define MAX_INTERP_HDR 512\n    union {\n        unsigned char buf[MAX_INTERP_HDR];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        fi->seek(0, SEEK_SET);\n        fi->readx(u.buf, MAX_INTERP_HDR);\n        unsigned const e_entry = get_te32(&ehdr->e_entry);\n        if (e_entry < 0x401180) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n        throwCantUnpack("file header corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n    off_t ptload0hi=0, ptload1lo=0, ptload1sz=0;\n\n    // decompress PT_LOAD\n    bool first_PF_X = true;\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n    for (unsigned j=0; j < ehdr->e_phnum; ++phdr, ++j) {\n        if (PT_LOAD==phdr->p_type) {\n            if (0==ptload0hi) {\n                ptload0hi = phdr->p_filesz + phdr->p_offset;\n            }\n            else if (0==ptload1lo) {\n                ptload1lo = phdr->p_offset;\n                ptload1sz = phdr->p_filesz;\n            }\n            if (fo)\n                fo->seek(phdr->p_offset, SEEK_SET);\n            if (Elf32_Phdr::PF_X & phdr->p_flags) {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, first_PF_X, szb_info);\n                first_PF_X = false;\n            }\n            else {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, false, szb_info);\n            }\n        }\n    }\n\n    if (0!=ptload1sz && ptload0hi < ptload1lo) {  // alignment hole?\n        if (fo)\n            fo->seek(ptload0hi, SEEK_SET);\n        unpackExtent(ptload1lo - ptload0hi, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    if (total_out != orig_file_size) {  // non-PT_LOAD stuff\n        if (fo)\n            fo->seek(0, SEEK_END);\n        unpackExtent(orig_file_size - total_out, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_INTERP_HDR\n}\n', '_3': 198, '_4': 308, '_5': 'PackLinuxElf32x86interp.unpack:void(OutputFile*)', '_6': 'src/p_lx_interp.cpp'}, {'_1': 111669150315, '_2': 'void PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack("file header corrupted");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack("file header corrupted");\n    }\n    rawmseg = (Mach_segment_command *) New(char, sz_cmds);\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > 0x05000000)\n        throwCantUnpack("file header corrupted");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning("packed size too big; discarding appended data, keeping backup");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack("file header corrupted");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    Mach_header *const mhdr = (Mach_header *) New(upx_byte, ph.u_len);\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack("file header corrupted");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd = New(Mach_segment_command, ncmds);\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n        if (ptr_udiff(ptr, (1+ mhdr)) > ph.u_len) {\n            throwCantUnpack("cmdsize");\n        }\n    }\n\n    // Put LC_SEGMENT together at the beginning, ascending by .vmaddr.\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n    delete [] mhdr;\n}\n', '_3': 1421, '_4': 1547, '_5': 'PackMachBase.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150324, '_2': 'void PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode ("-t") sets fo = NULL\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n', '_3': 2200, '_4': 2300, '_5': 'PackMachFat.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150345, '_2': 'void PackPs1::unpack(OutputFile *fo)\n{\n    // restore orig exec hdr\n    memcpy(&oh, &ih, sizeof(ih));\n    memcpy((void *) &oh.epc, &bh, SZ_IH_BKUP);\n\n    // check for removed sector alignment\n    assert(oh.tx_len >= ph.u_len);\n    const unsigned pad = oh.tx_len - ph.u_len;\n\n    ibuf.alloc(fdata_size > PS_HDR_SIZE ? fdata_size : PS_HDR_SIZE);\n    obuf.allocForUncompression(ph.u_len, pad);\n\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // decompress\n    decompress(ibuf + (fdata_size - ph.c_len), obuf);\n\n    // write decompressed file\n    if (fo)\n    {\n        // write header\n        fo->write(&oh, sizeof(oh));\n        // align the ps exe header (mode 2 sector data size)\n        ibuf.clear();\n        fo->write(ibuf, PS_HDR_SIZE - fo->getBytesWritten());\n        // write uncompressed data + pad\n        obuf.clear(ph.u_len, pad);\n        fo->write(obuf, ph.u_len + pad);\n    }\n}', '_3': 708, '_4': 739, '_5': 'PackPs1.unpack:void(OutputFile*)', '_6': 'src/p_ps1.cpp'}, {'_1': 111669150361, '_2': 'void PackTmt::unpack(OutputFile *fo)\n{\n    Packer::handleStub(fi,fo,adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(),SEEK_SET);\n    fi->readx(ibuf,ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf+ph.u_len-4);\n    upx_byte *relocs = obuf + osize;\n    const unsigned origstart = get_le32(obuf+ph.u_len-8);\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf+ph.u_len-12) >> 24);\n        ft.unfilter(obuf, ptr_diff(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer wrkmem;\n    unsigned relocn = unoptimizeReloc32(&relocs,obuf,&wrkmem,1);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem+ic*4,get_le32(wrkmem+ic*4)+4);\n\n    memcpy(&oh,&ih,sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn*4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize\n        - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo)\n    {\n        fo->write(&oh,sizeof(oh));\n        fo->write(obuf,osize);\n        fo->write(wrkmem,relocn*4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, &obuf);\n}\n', '_3': 307, '_4': 361, '_5': 'PackTmt.unpack:void(OutputFile*)', '_6': 'src/p_tmt.cpp'}, {'_1': 111669150377, '_2': 'void PackTos::unpack(OutputFile *fo)\n{\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(FH_SIZE + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // write original header & decompressed file\n    if (fo)\n    {\n        unsigned overlay = file_size - (FH_SIZE + ih.fh_text + ih.fh_data);\n        if (ih.fh_reloc == 0 && overlay >= 4)\n            overlay -= 4;                           // this is our empty fixup\n        checkOverlay(overlay);\n\n        fo->write(obuf+ph.u_len-FH_SIZE, FH_SIZE);  // orig. file_hdr\n        fo->write(obuf, ph.u_len-FH_SIZE);          // orig. text+data+relocs\n\n        // copy any overlay\n        copyOverlay(fo, overlay, &obuf);\n    }\n}', '_3': 750, '_4': 775, '_5': 'PackTos.unpack:void(OutputFile*)', '_6': 'src/p_tos.cpp'}, {'_1': 111669150393, '_2': 'void PackUnix::unpack(OutputFile *fo)\n{\n    b_info bhdr;\n    unsigned const szb_info = (ph.version <= 11)\n        ? sizeof(bhdr.sz_unc) + sizeof(bhdr.sz_cpr)  // old style\n        : sizeof(bhdr);\n\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // defaults for ph.version == 8\n    unsigned orig_file_size = 0;\n    blocksize = 512 * 1024;\n\n    fi->seek(overlay_offset, SEEK_SET);\n    if (ph.version > 8)\n    {\n        p_info hbuf;\n        fi->readx(&hbuf, sizeof(hbuf));\n        orig_file_size = get_te32(&hbuf.p_filesize);\n        blocksize = get_te32(&hbuf.p_blocksize);\n\n        if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n            throwCantUnpack("file header corrupted");\n    }\n    else\n    {\n        // skip 4 bytes (program id)\n        fi->seek(4, SEEK_CUR);\n    }\n\n    if ((int)(blocksize + OVERHEAD) < 0)\n        throwCantUnpack("blocksize corrupted");\n    ibuf.alloc(blocksize + OVERHEAD);\n\n    // decompress blocks\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    memset(&bhdr, 0, sizeof(bhdr));\n    for (;;)\n    {\n#define buf ibuf\n        int i;\n        unsigned sz_unc, sz_cpr;\n\n        fi->readx(&bhdr, szb_info);\n        ph.u_len = sz_unc = get_te32(&bhdr.sz_unc);\n        ph.c_len = sz_cpr = get_te32(&bhdr.sz_cpr);\n\n        if (sz_unc == 0)                   // uncompressed size 0 -> EOF\n        {\n            // note: must reload sz_cpr as magic is always stored le32\n            sz_cpr = get_le32(&bhdr.sz_cpr);\n            if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n                throwCompressedDataViolation();\n            break;\n        }\n        if (sz_unc <= 0 || sz_cpr <= 0)\n            throwCompressedDataViolation();\n        if (sz_cpr > sz_unc || sz_unc > blocksize)\n            throwCompressedDataViolation();\n\n        i = blocksize + OVERHEAD - sz_cpr;\n        if (i < 0)\n            throwCantUnpack("corrupt b_info");\n        fi->readx(buf+i, sz_cpr);\n        // update checksum of compressed data\n        c_adler = upx_adler32(buf + i, sz_cpr, c_adler);\n        // decompress\n        if (sz_cpr < sz_unc) {\n            decompress(buf+i, buf, false);\n            if (0!=bhdr.b_ftid) {\n                Filter ft(ph.level);\n                ft.init(bhdr.b_ftid);\n                ft.cto = bhdr.b_cto8;\n                ft.unfilter(buf, sz_unc);\n            }\n            i = 0;\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(buf + i, sz_unc, u_adler);\n        total_in  += sz_cpr;\n        total_out += sz_unc;\n        // write block\n        if (fo)\n            fo->write(buf + i, sz_unc);\n#undef buf\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (ph.version > 8 && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 559, '_4': 659, '_5': 'PackUnix.unpack:void(OutputFile*)', '_6': 'src/p_unix.cpp'}, {'_1': 111669150403, '_2': 'void PackVmlinuxBase<T>::unpack(OutputFile *fo)\n{\n    TE32 word;\n    PackHeader const ph_tmp(ph);\n\n    fi->seek(p_note0->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note0->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n    if (!has_valid_vmlinux_head()) {\n        throwCantUnpack(".text corrupted");\n    }\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf);\n\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    fi->seek(p_note1->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note1->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, p_note1->sh_size - sizeof(ph.u_len));\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n}\n', '_3': 609, '_4': 656, '_5': 'PackVmlinuxBase.unpack:void(OutputFile*)', '_6': 'src/p_vmlinx.cpp'}, {'_1': 111669150469, '_2': 'void PackVmlinuzI386::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, physical_start);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 682, '_4': 710, '_5': 'PackVmlinuzI386.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150484, '_2': 'void PackVmlinuzARMEL::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 1039, '_4': 1067, '_5': 'PackVmlinuzARMEL.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150535, '_2': 'void PackWcle::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    readObjectTable();\n    iobject_desc.dealloc();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    decodeImage();\n    decodeObjectTable();\n\n    // unfilter\n    if (ph.filter)\n    {\n        const unsigned text_size = OOT(oh.init_cs_object-1,npages) * mps;\n        const unsigned text_vaddr = OOT(oh.init_cs_object-1,my_base_address);\n\n        Filter ft(ph.level);\n        ft.init(ph.filter, text_vaddr);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(oimage+ph.u_len-9) >> 24);\n        ft.unfilter(oimage+text_vaddr, text_size);\n    }\n\n    decodeFixupPageTable();\n    decodeFixups();\n    decodeEntryTable();\n    decodePageMap();\n    decodeResidentNames();\n    decodeNonResidentNames();\n\n    for (unsigned ic = 0; ic < soobject_table; ic++)\n        OOT(ic,my_base_address) = 0;\n\n    while (oimage[soimage-1] == 0)\n        soimage--;\n    oh.bytes_on_last_page = soimage % mps;\n\n    // write decompressed file\n    if (fo)\n        writeFile(fo, opt->watcom_le.le);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset\n        + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, &oimage);\n}\n', '_3': 803, '_4': 858, '_5': 'PackWcle.unpack:void(OutputFile*)', '_6': 'src/p_wcle.cpp'}, {'_1': 111669150641, '_2': 'void PackMaster::unpack(OutputFile *fo) {\n    p = getUnpacker(fi);\n    p->assertPacker();\n    fi = NULL;\n    p->doUnpack(fo);\n}', '_3': 265, '_4': 270, '_5': 'PackMaster.unpack:void(OutputFile*)', '_6': 'src/packmast.cpp'}, {'_1': 111669150763, '_2': 'void PeFile32::unpack(OutputFile *fo)\n{\n    bool set_oft = getFormat() == UPX_F_WINCE_ARM_PE;\n    unpack0<pe_header_t, LE32>(fo, ih, oh, 1U << 31, set_oft);\n}', '_3': 3118, '_4': 3122, '_5': 'PeFile32.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669150772, '_2': 'void PeFile64::unpack(OutputFile *fo)\n{\n    unpack0<pe_header_t, LE64>(fo, ih, oh, 1ULL << 63, false);\n}', '_3': 3173, '_4': 3176, '_5': 'PeFile64.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669152545, '_2': 'virtual void unpack(OutputFile *fo) = 0;', '_3': 155, '_4': 155, '_5': 'Packer.unpack:void(OutputFile*)', '_6': 'src/packer.h'}]
Result saved to /4_Experiment/RQ5/Caller_Callee/Results/success_analysis/CVE-2019-25104_success.json
Tool result: []
Tool result: []
Tool result: [{'_1': 111669150013, '_2': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', '_3': 236, '_4': 261, '_5': 'PackCom.unpack:void(OutputFile*)', '_6': 'src/p_com.cpp'}, {'_1': 111669150030, '_2': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', '_3': 401, '_4': 470, '_5': 'PackDjgpp2.unpack:void(OutputFile*)', '_6': 'src/p_djgpp2.cpp'}, {'_1': 111669150043, '_2': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', '_3': 688, '_4': 806, '_5': 'PackExe.unpack:void(OutputFile*)', '_6': 'src/p_exe.cpp'}, {'_1': 111669150173, '_2': 'void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Rela offset", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 3844, '_4': 4161, '_5': 'PackLinuxElf64.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150213, '_2': 'void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n            unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n            Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf32_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                unsigned symval = get_te32(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf32_Sym::SHN_UNDEF != symsec\n                &&  Elf32_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te32(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr *dynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&dynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Rel offset", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 4604, '_4': 4922, '_5': 'PackLinuxElf32.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150214, '_2': 'void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack("internal error");\n}', '_3': 4924, '_4': 4927, '_5': 'PackLinuxElf.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150243, '_2': 'void PackLinuxElf32x86interp::unpack(OutputFile *fo)\n{\n#define MAX_INTERP_HDR 512\n    union {\n        unsigned char buf[MAX_INTERP_HDR];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        fi->seek(0, SEEK_SET);\n        fi->readx(u.buf, MAX_INTERP_HDR);\n        unsigned const e_entry = get_te32(&ehdr->e_entry);\n        if (e_entry < 0x401180) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n        throwCantUnpack("file header corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n    off_t ptload0hi=0, ptload1lo=0, ptload1sz=0;\n\n    // decompress PT_LOAD\n    bool first_PF_X = true;\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n    for (unsigned j=0; j < ehdr->e_phnum; ++phdr, ++j) {\n        if (PT_LOAD==phdr->p_type) {\n            if (0==ptload0hi) {\n                ptload0hi = phdr->p_filesz + phdr->p_offset;\n            }\n            else if (0==ptload1lo) {\n                ptload1lo = phdr->p_offset;\n                ptload1sz = phdr->p_filesz;\n            }\n            if (fo)\n                fo->seek(phdr->p_offset, SEEK_SET);\n            if (Elf32_Phdr::PF_X & phdr->p_flags) {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, first_PF_X, szb_info);\n                first_PF_X = false;\n            }\n            else {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, false, szb_info);\n            }\n        }\n    }\n\n    if (0!=ptload1sz && ptload0hi < ptload1lo) {  // alignment hole?\n        if (fo)\n            fo->seek(ptload0hi, SEEK_SET);\n        unpackExtent(ptload1lo - ptload0hi, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    if (total_out != orig_file_size) {  // non-PT_LOAD stuff\n        if (fo)\n            fo->seek(0, SEEK_END);\n        unpackExtent(orig_file_size - total_out, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_INTERP_HDR\n}\n', '_3': 198, '_4': 308, '_5': 'PackLinuxElf32x86interp.unpack:void(OutputFile*)', '_6': 'src/p_lx_interp.cpp'}, {'_1': 111669150315, '_2': 'void PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack("file header corrupted");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack("file header corrupted");\n    }\n    rawmseg = (Mach_segment_command *) New(char, sz_cmds);\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > 0x05000000)\n        throwCantUnpack("file header corrupted");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning("packed size too big; discarding appended data, keeping backup");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack("file header corrupted");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    Mach_header *const mhdr = (Mach_header *) New(upx_byte, ph.u_len);\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack("file header corrupted");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd = New(Mach_segment_command, ncmds);\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n        if (ptr_udiff(ptr, (1+ mhdr)) > ph.u_len) {\n            throwCantUnpack("cmdsize");\n        }\n    }\n\n    // Put LC_SEGMENT together at the beginning, ascending by .vmaddr.\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n    delete [] mhdr;\n}\n', '_3': 1421, '_4': 1547, '_5': 'PackMachBase.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150324, '_2': 'void PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode ("-t") sets fo = NULL\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n', '_3': 2200, '_4': 2300, '_5': 'PackMachFat.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150345, '_2': 'void PackPs1::unpack(OutputFile *fo)\n{\n    // restore orig exec hdr\n    memcpy(&oh, &ih, sizeof(ih));\n    memcpy((void *) &oh.epc, &bh, SZ_IH_BKUP);\n\n    // check for removed sector alignment\n    assert(oh.tx_len >= ph.u_len);\n    const unsigned pad = oh.tx_len - ph.u_len;\n\n    ibuf.alloc(fdata_size > PS_HDR_SIZE ? fdata_size : PS_HDR_SIZE);\n    obuf.allocForUncompression(ph.u_len, pad);\n\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // decompress\n    decompress(ibuf + (fdata_size - ph.c_len), obuf);\n\n    // write decompressed file\n    if (fo)\n    {\n        // write header\n        fo->write(&oh, sizeof(oh));\n        // align the ps exe header (mode 2 sector data size)\n        ibuf.clear();\n        fo->write(ibuf, PS_HDR_SIZE - fo->getBytesWritten());\n        // write uncompressed data + pad\n        obuf.clear(ph.u_len, pad);\n        fo->write(obuf, ph.u_len + pad);\n    }\n}', '_3': 708, '_4': 739, '_5': 'PackPs1.unpack:void(OutputFile*)', '_6': 'src/p_ps1.cpp'}, {'_1': 111669150361, '_2': 'void PackTmt::unpack(OutputFile *fo)\n{\n    Packer::handleStub(fi,fo,adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(),SEEK_SET);\n    fi->readx(ibuf,ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf+ph.u_len-4);\n    upx_byte *relocs = obuf + osize;\n    const unsigned origstart = get_le32(obuf+ph.u_len-8);\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf+ph.u_len-12) >> 24);\n        ft.unfilter(obuf, ptr_diff(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer wrkmem;\n    unsigned relocn = unoptimizeReloc32(&relocs,obuf,&wrkmem,1);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem+ic*4,get_le32(wrkmem+ic*4)+4);\n\n    memcpy(&oh,&ih,sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn*4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize\n        - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo)\n    {\n        fo->write(&oh,sizeof(oh));\n        fo->write(obuf,osize);\n        fo->write(wrkmem,relocn*4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, &obuf);\n}\n', '_3': 307, '_4': 361, '_5': 'PackTmt.unpack:void(OutputFile*)', '_6': 'src/p_tmt.cpp'}, {'_1': 111669150377, '_2': 'void PackTos::unpack(OutputFile *fo)\n{\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(FH_SIZE + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // write original header & decompressed file\n    if (fo)\n    {\n        unsigned overlay = file_size - (FH_SIZE + ih.fh_text + ih.fh_data);\n        if (ih.fh_reloc == 0 && overlay >= 4)\n            overlay -= 4;                           // this is our empty fixup\n        checkOverlay(overlay);\n\n        fo->write(obuf+ph.u_len-FH_SIZE, FH_SIZE);  // orig. file_hdr\n        fo->write(obuf, ph.u_len-FH_SIZE);          // orig. text+data+relocs\n\n        // copy any overlay\n        copyOverlay(fo, overlay, &obuf);\n    }\n}', '_3': 750, '_4': 775, '_5': 'PackTos.unpack:void(OutputFile*)', '_6': 'src/p_tos.cpp'}, {'_1': 111669150393, '_2': 'void PackUnix::unpack(OutputFile *fo)\n{\n    b_info bhdr;\n    unsigned const szb_info = (ph.version <= 11)\n        ? sizeof(bhdr.sz_unc) + sizeof(bhdr.sz_cpr)  // old style\n        : sizeof(bhdr);\n\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // defaults for ph.version == 8\n    unsigned orig_file_size = 0;\n    blocksize = 512 * 1024;\n\n    fi->seek(overlay_offset, SEEK_SET);\n    if (ph.version > 8)\n    {\n        p_info hbuf;\n        fi->readx(&hbuf, sizeof(hbuf));\n        orig_file_size = get_te32(&hbuf.p_filesize);\n        blocksize = get_te32(&hbuf.p_blocksize);\n\n        if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n            throwCantUnpack("file header corrupted");\n    }\n    else\n    {\n        // skip 4 bytes (program id)\n        fi->seek(4, SEEK_CUR);\n    }\n\n    if ((int)(blocksize + OVERHEAD) < 0)\n        throwCantUnpack("blocksize corrupted");\n    ibuf.alloc(blocksize + OVERHEAD);\n\n    // decompress blocks\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    memset(&bhdr, 0, sizeof(bhdr));\n    for (;;)\n    {\n#define buf ibuf\n        int i;\n        unsigned sz_unc, sz_cpr;\n\n        fi->readx(&bhdr, szb_info);\n        ph.u_len = sz_unc = get_te32(&bhdr.sz_unc);\n        ph.c_len = sz_cpr = get_te32(&bhdr.sz_cpr);\n\n        if (sz_unc == 0)                   // uncompressed size 0 -> EOF\n        {\n            // note: must reload sz_cpr as magic is always stored le32\n            sz_cpr = get_le32(&bhdr.sz_cpr);\n            if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n                throwCompressedDataViolation();\n            break;\n        }\n        if (sz_unc <= 0 || sz_cpr <= 0)\n            throwCompressedDataViolation();\n        if (sz_cpr > sz_unc || sz_unc > blocksize)\n            throwCompressedDataViolation();\n\n        i = blocksize + OVERHEAD - sz_cpr;\n        if (i < 0)\n            throwCantUnpack("corrupt b_info");\n        fi->readx(buf+i, sz_cpr);\n        // update checksum of compressed data\n        c_adler = upx_adler32(buf + i, sz_cpr, c_adler);\n        // decompress\n        if (sz_cpr < sz_unc) {\n            decompress(buf+i, buf, false);\n            if (0!=bhdr.b_ftid) {\n                Filter ft(ph.level);\n                ft.init(bhdr.b_ftid);\n                ft.cto = bhdr.b_cto8;\n                ft.unfilter(buf, sz_unc);\n            }\n            i = 0;\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(buf + i, sz_unc, u_adler);\n        total_in  += sz_cpr;\n        total_out += sz_unc;\n        // write block\n        if (fo)\n            fo->write(buf + i, sz_unc);\n#undef buf\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (ph.version > 8 && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 559, '_4': 659, '_5': 'PackUnix.unpack:void(OutputFile*)', '_6': 'src/p_unix.cpp'}, {'_1': 111669150403, '_2': 'void PackVmlinuxBase<T>::unpack(OutputFile *fo)\n{\n    TE32 word;\n    PackHeader const ph_tmp(ph);\n\n    fi->seek(p_note0->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note0->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n    if (!has_valid_vmlinux_head()) {\n        throwCantUnpack(".text corrupted");\n    }\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf);\n\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    fi->seek(p_note1->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note1->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, p_note1->sh_size - sizeof(ph.u_len));\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n}\n', '_3': 609, '_4': 656, '_5': 'PackVmlinuxBase.unpack:void(OutputFile*)', '_6': 'src/p_vmlinx.cpp'}, {'_1': 111669150469, '_2': 'void PackVmlinuzI386::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, physical_start);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 682, '_4': 710, '_5': 'PackVmlinuzI386.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150484, '_2': 'void PackVmlinuzARMEL::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 1039, '_4': 1067, '_5': 'PackVmlinuzARMEL.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150535, '_2': 'void PackWcle::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    readObjectTable();\n    iobject_desc.dealloc();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    decodeImage();\n    decodeObjectTable();\n\n    // unfilter\n    if (ph.filter)\n    {\n        const unsigned text_size = OOT(oh.init_cs_object-1,npages) * mps;\n        const unsigned text_vaddr = OOT(oh.init_cs_object-1,my_base_address);\n\n        Filter ft(ph.level);\n        ft.init(ph.filter, text_vaddr);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(oimage+ph.u_len-9) >> 24);\n        ft.unfilter(oimage+text_vaddr, text_size);\n    }\n\n    decodeFixupPageTable();\n    decodeFixups();\n    decodeEntryTable();\n    decodePageMap();\n    decodeResidentNames();\n    decodeNonResidentNames();\n\n    for (unsigned ic = 0; ic < soobject_table; ic++)\n        OOT(ic,my_base_address) = 0;\n\n    while (oimage[soimage-1] == 0)\n        soimage--;\n    oh.bytes_on_last_page = soimage % mps;\n\n    // write decompressed file\n    if (fo)\n        writeFile(fo, opt->watcom_le.le);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset\n        + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, &oimage);\n}\n', '_3': 803, '_4': 858, '_5': 'PackWcle.unpack:void(OutputFile*)', '_6': 'src/p_wcle.cpp'}, {'_1': 111669150641, '_2': 'void PackMaster::unpack(OutputFile *fo) {\n    p = getUnpacker(fi);\n    p->assertPacker();\n    fi = NULL;\n    p->doUnpack(fo);\n}', '_3': 265, '_4': 270, '_5': 'PackMaster.unpack:void(OutputFile*)', '_6': 'src/packmast.cpp'}, {'_1': 111669150763, '_2': 'void PeFile32::unpack(OutputFile *fo)\n{\n    bool set_oft = getFormat() == UPX_F_WINCE_ARM_PE;\n    unpack0<pe_header_t, LE32>(fo, ih, oh, 1U << 31, set_oft);\n}', '_3': 3118, '_4': 3122, '_5': 'PeFile32.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669150772, '_2': 'void PeFile64::unpack(OutputFile *fo)\n{\n    unpack0<pe_header_t, LE64>(fo, ih, oh, 1ULL << 63, false);\n}', '_3': 3173, '_4': 3176, '_5': 'PeFile64.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669152545, '_2': 'virtual void unpack(OutputFile *fo) = 0;', '_3': 155, '_4': 155, '_5': 'Packer.unpack:void(OutputFile*)', '_6': 'src/packer.h'}]
Tool result: []
Tool result: []
Tool result: []
Tool result: [{'_1': 111669150013, '_2': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', '_3': 236, '_4': 261, '_5': 'PackCom.unpack:void(OutputFile*)', '_6': 'src/p_com.cpp'}, {'_1': 111669150030, '_2': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', '_3': 401, '_4': 470, '_5': 'PackDjgpp2.unpack:void(OutputFile*)', '_6': 'src/p_djgpp2.cpp'}, {'_1': 111669150043, '_2': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', '_3': 688, '_4': 806, '_5': 'PackExe.unpack:void(OutputFile*)', '_6': 'src/p_exe.cpp'}, {'_1': 111669150173, '_2': 'void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Rela offset", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 3844, '_4': 4161, '_5': 'PackLinuxElf64.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150213, '_2': 'void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n            unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n            Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf32_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                unsigned symval = get_te32(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf32_Sym::SHN_UNDEF != symsec\n                &&  Elf32_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te32(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr *dynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&dynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Rel offset", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 4604, '_4': 4922, '_5': 'PackLinuxElf32.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150214, '_2': 'void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack("internal error");\n}', '_3': 4924, '_4': 4927, '_5': 'PackLinuxElf.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150243, '_2': 'void PackLinuxElf32x86interp::unpack(OutputFile *fo)\n{\n#define MAX_INTERP_HDR 512\n    union {\n        unsigned char buf[MAX_INTERP_HDR];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        fi->seek(0, SEEK_SET);\n        fi->readx(u.buf, MAX_INTERP_HDR);\n        unsigned const e_entry = get_te32(&ehdr->e_entry);\n        if (e_entry < 0x401180) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n        throwCantUnpack("file header corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n    off_t ptload0hi=0, ptload1lo=0, ptload1sz=0;\n\n    // decompress PT_LOAD\n    bool first_PF_X = true;\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n    for (unsigned j=0; j < ehdr->e_phnum; ++phdr, ++j) {\n        if (PT_LOAD==phdr->p_type) {\n            if (0==ptload0hi) {\n                ptload0hi = phdr->p_filesz + phdr->p_offset;\n            }\n            else if (0==ptload1lo) {\n                ptload1lo = phdr->p_offset;\n                ptload1sz = phdr->p_filesz;\n            }\n            if (fo)\n                fo->seek(phdr->p_offset, SEEK_SET);\n            if (Elf32_Phdr::PF_X & phdr->p_flags) {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, first_PF_X, szb_info);\n                first_PF_X = false;\n            }\n            else {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, false, szb_info);\n            }\n        }\n    }\n\n    if (0!=ptload1sz && ptload0hi < ptload1lo) {  // alignment hole?\n        if (fo)\n            fo->seek(ptload0hi, SEEK_SET);\n        unpackExtent(ptload1lo - ptload0hi, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    if (total_out != orig_file_size) {  // non-PT_LOAD stuff\n        if (fo)\n            fo->seek(0, SEEK_END);\n        unpackExtent(orig_file_size - total_out, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_INTERP_HDR\n}\n', '_3': 198, '_4': 308, '_5': 'PackLinuxElf32x86interp.unpack:void(OutputFile*)', '_6': 'src/p_lx_interp.cpp'}, {'_1': 111669150315, '_2': 'void PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack("file header corrupted");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack("file header corrupted");\n    }\n    rawmseg = (Mach_segment_command *) New(char, sz_cmds);\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > 0x05000000)\n        throwCantUnpack("file header corrupted");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning("packed size too big; discarding appended data, keeping backup");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack("file header corrupted");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    Mach_header *const mhdr = (Mach_header *) New(upx_byte, ph.u_len);\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack("file header corrupted");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd = New(Mach_segment_command, ncmds);\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n        if (ptr_udiff(ptr, (1+ mhdr)) > ph.u_len) {\n            throwCantUnpack("cmdsize");\n        }\n    }\n\n    // Put LC_SEGMENT together at the beginning, ascending by .vmaddr.\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n    delete [] mhdr;\n}\n', '_3': 1421, '_4': 1547, '_5': 'PackMachBase.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150324, '_2': 'void PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode ("-t") sets fo = NULL\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n', '_3': 2200, '_4': 2300, '_5': 'PackMachFat.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150345, '_2': 'void PackPs1::unpack(OutputFile *fo)\n{\n    // restore orig exec hdr\n    memcpy(&oh, &ih, sizeof(ih));\n    memcpy((void *) &oh.epc, &bh, SZ_IH_BKUP);\n\n    // check for removed sector alignment\n    assert(oh.tx_len >= ph.u_len);\n    const unsigned pad = oh.tx_len - ph.u_len;\n\n    ibuf.alloc(fdata_size > PS_HDR_SIZE ? fdata_size : PS_HDR_SIZE);\n    obuf.allocForUncompression(ph.u_len, pad);\n\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // decompress\n    decompress(ibuf + (fdata_size - ph.c_len), obuf);\n\n    // write decompressed file\n    if (fo)\n    {\n        // write header\n        fo->write(&oh, sizeof(oh));\n        // align the ps exe header (mode 2 sector data size)\n        ibuf.clear();\n        fo->write(ibuf, PS_HDR_SIZE - fo->getBytesWritten());\n        // write uncompressed data + pad\n        obuf.clear(ph.u_len, pad);\n        fo->write(obuf, ph.u_len + pad);\n    }\n}', '_3': 708, '_4': 739, '_5': 'PackPs1.unpack:void(OutputFile*)', '_6': 'src/p_ps1.cpp'}, {'_1': 111669150361, '_2': 'void PackTmt::unpack(OutputFile *fo)\n{\n    Packer::handleStub(fi,fo,adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(),SEEK_SET);\n    fi->readx(ibuf,ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf+ph.u_len-4);\n    upx_byte *relocs = obuf + osize;\n    const unsigned origstart = get_le32(obuf+ph.u_len-8);\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf+ph.u_len-12) >> 24);\n        ft.unfilter(obuf, ptr_diff(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer wrkmem;\n    unsigned relocn = unoptimizeReloc32(&relocs,obuf,&wrkmem,1);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem+ic*4,get_le32(wrkmem+ic*4)+4);\n\n    memcpy(&oh,&ih,sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn*4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize\n        - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo)\n    {\n        fo->write(&oh,sizeof(oh));\n        fo->write(obuf,osize);\n        fo->write(wrkmem,relocn*4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, &obuf);\n}\n', '_3': 307, '_4': 361, '_5': 'PackTmt.unpack:void(OutputFile*)', '_6': 'src/p_tmt.cpp'}, {'_1': 111669150377, '_2': 'void PackTos::unpack(OutputFile *fo)\n{\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(FH_SIZE + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // write original header & decompressed file\n    if (fo)\n    {\n        unsigned overlay = file_size - (FH_SIZE + ih.fh_text + ih.fh_data);\n        if (ih.fh_reloc == 0 && overlay >= 4)\n            overlay -= 4;                           // this is our empty fixup\n        checkOverlay(overlay);\n\n        fo->write(obuf+ph.u_len-FH_SIZE, FH_SIZE);  // orig. file_hdr\n        fo->write(obuf, ph.u_len-FH_SIZE);          // orig. text+data+relocs\n\n        // copy any overlay\n        copyOverlay(fo, overlay, &obuf);\n    }\n}', '_3': 750, '_4': 775, '_5': 'PackTos.unpack:void(OutputFile*)', '_6': 'src/p_tos.cpp'}, {'_1': 111669150393, '_2': 'void PackUnix::unpack(OutputFile *fo)\n{\n    b_info bhdr;\n    unsigned const szb_info = (ph.version <= 11)\n        ? sizeof(bhdr.sz_unc) + sizeof(bhdr.sz_cpr)  // old style\n        : sizeof(bhdr);\n\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // defaults for ph.version == 8\n    unsigned orig_file_size = 0;\n    blocksize = 512 * 1024;\n\n    fi->seek(overlay_offset, SEEK_SET);\n    if (ph.version > 8)\n    {\n        p_info hbuf;\n        fi->readx(&hbuf, sizeof(hbuf));\n        orig_file_size = get_te32(&hbuf.p_filesize);\n        blocksize = get_te32(&hbuf.p_blocksize);\n\n        if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n            throwCantUnpack("file header corrupted");\n    }\n    else\n    {\n        // skip 4 bytes (program id)\n        fi->seek(4, SEEK_CUR);\n    }\n\n    if ((int)(blocksize + OVERHEAD) < 0)\n        throwCantUnpack("blocksize corrupted");\n    ibuf.alloc(blocksize + OVERHEAD);\n\n    // decompress blocks\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    memset(&bhdr, 0, sizeof(bhdr));\n    for (;;)\n    {\n#define buf ibuf\n        int i;\n        unsigned sz_unc, sz_cpr;\n\n        fi->readx(&bhdr, szb_info);\n        ph.u_len = sz_unc = get_te32(&bhdr.sz_unc);\n        ph.c_len = sz_cpr = get_te32(&bhdr.sz_cpr);\n\n        if (sz_unc == 0)                   // uncompressed size 0 -> EOF\n        {\n            // note: must reload sz_cpr as magic is always stored le32\n            sz_cpr = get_le32(&bhdr.sz_cpr);\n            if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n                throwCompressedDataViolation();\n            break;\n        }\n        if (sz_unc <= 0 || sz_cpr <= 0)\n            throwCompressedDataViolation();\n        if (sz_cpr > sz_unc || sz_unc > blocksize)\n            throwCompressedDataViolation();\n\n        i = blocksize + OVERHEAD - sz_cpr;\n        if (i < 0)\n            throwCantUnpack("corrupt b_info");\n        fi->readx(buf+i, sz_cpr);\n        // update checksum of compressed data\n        c_adler = upx_adler32(buf + i, sz_cpr, c_adler);\n        // decompress\n        if (sz_cpr < sz_unc) {\n            decompress(buf+i, buf, false);\n            if (0!=bhdr.b_ftid) {\n                Filter ft(ph.level);\n                ft.init(bhdr.b_ftid);\n                ft.cto = bhdr.b_cto8;\n                ft.unfilter(buf, sz_unc);\n            }\n            i = 0;\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(buf + i, sz_unc, u_adler);\n        total_in  += sz_cpr;\n        total_out += sz_unc;\n        // write block\n        if (fo)\n            fo->write(buf + i, sz_unc);\n#undef buf\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (ph.version > 8 && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 559, '_4': 659, '_5': 'PackUnix.unpack:void(OutputFile*)', '_6': 'src/p_unix.cpp'}, {'_1': 111669150403, '_2': 'void PackVmlinuxBase<T>::unpack(OutputFile *fo)\n{\n    TE32 word;\n    PackHeader const ph_tmp(ph);\n\n    fi->seek(p_note0->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note0->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n    if (!has_valid_vmlinux_head()) {\n        throwCantUnpack(".text corrupted");\n    }\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf);\n\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    fi->seek(p_note1->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note1->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, p_note1->sh_size - sizeof(ph.u_len));\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n}\n', '_3': 609, '_4': 656, '_5': 'PackVmlinuxBase.unpack:void(OutputFile*)', '_6': 'src/p_vmlinx.cpp'}, {'_1': 111669150469, '_2': 'void PackVmlinuzI386::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, physical_start);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 682, '_4': 710, '_5': 'PackVmlinuzI386.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150484, '_2': 'void PackVmlinuzARMEL::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 1039, '_4': 1067, '_5': 'PackVmlinuzARMEL.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150535, '_2': 'void PackWcle::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    readObjectTable();\n    iobject_desc.dealloc();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    decodeImage();\n    decodeObjectTable();\n\n    // unfilter\n    if (ph.filter)\n    {\n        const unsigned text_size = OOT(oh.init_cs_object-1,npages) * mps;\n        const unsigned text_vaddr = OOT(oh.init_cs_object-1,my_base_address);\n\n        Filter ft(ph.level);\n        ft.init(ph.filter, text_vaddr);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(oimage+ph.u_len-9) >> 24);\n        ft.unfilter(oimage+text_vaddr, text_size);\n    }\n\n    decodeFixupPageTable();\n    decodeFixups();\n    decodeEntryTable();\n    decodePageMap();\n    decodeResidentNames();\n    decodeNonResidentNames();\n\n    for (unsigned ic = 0; ic < soobject_table; ic++)\n        OOT(ic,my_base_address) = 0;\n\n    while (oimage[soimage-1] == 0)\n        soimage--;\n    oh.bytes_on_last_page = soimage % mps;\n\n    // write decompressed file\n    if (fo)\n        writeFile(fo, opt->watcom_le.le);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset\n        + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, &oimage);\n}\n', '_3': 803, '_4': 858, '_5': 'PackWcle.unpack:void(OutputFile*)', '_6': 'src/p_wcle.cpp'}, {'_1': 111669150641, '_2': 'void PackMaster::unpack(OutputFile *fo) {\n    p = getUnpacker(fi);\n    p->assertPacker();\n    fi = NULL;\n    p->doUnpack(fo);\n}', '_3': 265, '_4': 270, '_5': 'PackMaster.unpack:void(OutputFile*)', '_6': 'src/packmast.cpp'}, {'_1': 111669150763, '_2': 'void PeFile32::unpack(OutputFile *fo)\n{\n    bool set_oft = getFormat() == UPX_F_WINCE_ARM_PE;\n    unpack0<pe_header_t, LE32>(fo, ih, oh, 1U << 31, set_oft);\n}', '_3': 3118, '_4': 3122, '_5': 'PeFile32.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669150772, '_2': 'void PeFile64::unpack(OutputFile *fo)\n{\n    unpack0<pe_header_t, LE64>(fo, ih, oh, 1ULL << 63, false);\n}', '_3': 3173, '_4': 3176, '_5': 'PeFile64.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669152545, '_2': 'virtual void unpack(OutputFile *fo) = 0;', '_3': 155, '_4': 155, '_5': 'Packer.unpack:void(OutputFile*)', '_6': 'src/packer.h'}]
Tool result: []
Tool result: []
Tool result: [{'_1': 111669150013, '_2': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', '_3': 236, '_4': 261, '_5': 'PackCom.unpack:void(OutputFile*)', '_6': 'src/p_com.cpp'}, {'_1': 111669150030, '_2': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', '_3': 401, '_4': 470, '_5': 'PackDjgpp2.unpack:void(OutputFile*)', '_6': 'src/p_djgpp2.cpp'}, {'_1': 111669150043, '_2': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', '_3': 688, '_4': 806, '_5': 'PackExe.unpack:void(OutputFile*)', '_6': 'src/p_exe.cpp'}, {'_1': 111669150173, '_2': 'void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Rela offset", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 3844, '_4': 4161, '_5': 'PackLinuxElf64.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150213, '_2': 'void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n            unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n            Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf32_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                unsigned symval = get_te32(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf32_Sym::SHN_UNDEF != symsec\n                &&  Elf32_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te32(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr *dynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&dynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Rel offset", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 4604, '_4': 4922, '_5': 'PackLinuxElf32.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150214, '_2': 'void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack("internal error");\n}', '_3': 4924, '_4': 4927, '_5': 'PackLinuxElf.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150243, '_2': 'void PackLinuxElf32x86interp::unpack(OutputFile *fo)\n{\n#define MAX_INTERP_HDR 512\n    union {\n        unsigned char buf[MAX_INTERP_HDR];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        fi->seek(0, SEEK_SET);\n        fi->readx(u.buf, MAX_INTERP_HDR);\n        unsigned const e_entry = get_te32(&ehdr->e_entry);\n        if (e_entry < 0x401180) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n        throwCantUnpack("file header corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n    off_t ptload0hi=0, ptload1lo=0, ptload1sz=0;\n\n    // decompress PT_LOAD\n    bool first_PF_X = true;\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n    for (unsigned j=0; j < ehdr->e_phnum; ++phdr, ++j) {\n        if (PT_LOAD==phdr->p_type) {\n            if (0==ptload0hi) {\n                ptload0hi = phdr->p_filesz + phdr->p_offset;\n            }\n            else if (0==ptload1lo) {\n                ptload1lo = phdr->p_offset;\n                ptload1sz = phdr->p_filesz;\n            }\n            if (fo)\n                fo->seek(phdr->p_offset, SEEK_SET);\n            if (Elf32_Phdr::PF_X & phdr->p_flags) {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, first_PF_X, szb_info);\n                first_PF_X = false;\n            }\n            else {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, false, szb_info);\n            }\n        }\n    }\n\n    if (0!=ptload1sz && ptload0hi < ptload1lo) {  // alignment hole?\n        if (fo)\n            fo->seek(ptload0hi, SEEK_SET);\n        unpackExtent(ptload1lo - ptload0hi, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    if (total_out != orig_file_size) {  // non-PT_LOAD stuff\n        if (fo)\n            fo->seek(0, SEEK_END);\n        unpackExtent(orig_file_size - total_out, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_INTERP_HDR\n}\n', '_3': 198, '_4': 308, '_5': 'PackLinuxElf32x86interp.unpack:void(OutputFile*)', '_6': 'src/p_lx_interp.cpp'}, {'_1': 111669150315, '_2': 'void PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack("file header corrupted");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack("file header corrupted");\n    }\n    rawmseg = (Mach_segment_command *) New(char, sz_cmds);\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > 0x05000000)\n        throwCantUnpack("file header corrupted");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning("packed size too big; discarding appended data, keeping backup");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack("file header corrupted");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    Mach_header *const mhdr = (Mach_header *) New(upx_byte, ph.u_len);\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack("file header corrupted");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd = New(Mach_segment_command, ncmds);\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n        if (ptr_udiff(ptr, (1+ mhdr)) > ph.u_len) {\n            throwCantUnpack("cmdsize");\n        }\n    }\n\n    // Put LC_SEGMENT together at the beginning, ascending by .vmaddr.\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n    delete [] mhdr;\n}\n', '_3': 1421, '_4': 1547, '_5': 'PackMachBase.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150324, '_2': 'void PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode ("-t") sets fo = NULL\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n', '_3': 2200, '_4': 2300, '_5': 'PackMachFat.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150345, '_2': 'void PackPs1::unpack(OutputFile *fo)\n{\n    // restore orig exec hdr\n    memcpy(&oh, &ih, sizeof(ih));\n    memcpy((void *) &oh.epc, &bh, SZ_IH_BKUP);\n\n    // check for removed sector alignment\n    assert(oh.tx_len >= ph.u_len);\n    const unsigned pad = oh.tx_len - ph.u_len;\n\n    ibuf.alloc(fdata_size > PS_HDR_SIZE ? fdata_size : PS_HDR_SIZE);\n    obuf.allocForUncompression(ph.u_len, pad);\n\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // decompress\n    decompress(ibuf + (fdata_size - ph.c_len), obuf);\n\n    // write decompressed file\n    if (fo)\n    {\n        // write header\n        fo->write(&oh, sizeof(oh));\n        // align the ps exe header (mode 2 sector data size)\n        ibuf.clear();\n        fo->write(ibuf, PS_HDR_SIZE - fo->getBytesWritten());\n        // write uncompressed data + pad\n        obuf.clear(ph.u_len, pad);\n        fo->write(obuf, ph.u_len + pad);\n    }\n}', '_3': 708, '_4': 739, '_5': 'PackPs1.unpack:void(OutputFile*)', '_6': 'src/p_ps1.cpp'}, {'_1': 111669150361, '_2': 'void PackTmt::unpack(OutputFile *fo)\n{\n    Packer::handleStub(fi,fo,adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(),SEEK_SET);\n    fi->readx(ibuf,ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf+ph.u_len-4);\n    upx_byte *relocs = obuf + osize;\n    const unsigned origstart = get_le32(obuf+ph.u_len-8);\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf+ph.u_len-12) >> 24);\n        ft.unfilter(obuf, ptr_diff(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer wrkmem;\n    unsigned relocn = unoptimizeReloc32(&relocs,obuf,&wrkmem,1);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem+ic*4,get_le32(wrkmem+ic*4)+4);\n\n    memcpy(&oh,&ih,sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn*4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize\n        - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo)\n    {\n        fo->write(&oh,sizeof(oh));\n        fo->write(obuf,osize);\n        fo->write(wrkmem,relocn*4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, &obuf);\n}\n', '_3': 307, '_4': 361, '_5': 'PackTmt.unpack:void(OutputFile*)', '_6': 'src/p_tmt.cpp'}, {'_1': 111669150377, '_2': 'void PackTos::unpack(OutputFile *fo)\n{\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(FH_SIZE + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // write original header & decompressed file\n    if (fo)\n    {\n        unsigned overlay = file_size - (FH_SIZE + ih.fh_text + ih.fh_data);\n        if (ih.fh_reloc == 0 && overlay >= 4)\n            overlay -= 4;                           // this is our empty fixup\n        checkOverlay(overlay);\n\n        fo->write(obuf+ph.u_len-FH_SIZE, FH_SIZE);  // orig. file_hdr\n        fo->write(obuf, ph.u_len-FH_SIZE);          // orig. text+data+relocs\n\n        // copy any overlay\n        copyOverlay(fo, overlay, &obuf);\n    }\n}', '_3': 750, '_4': 775, '_5': 'PackTos.unpack:void(OutputFile*)', '_6': 'src/p_tos.cpp'}, {'_1': 111669150393, '_2': 'void PackUnix::unpack(OutputFile *fo)\n{\n    b_info bhdr;\n    unsigned const szb_info = (ph.version <= 11)\n        ? sizeof(bhdr.sz_unc) + sizeof(bhdr.sz_cpr)  // old style\n        : sizeof(bhdr);\n\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // defaults for ph.version == 8\n    unsigned orig_file_size = 0;\n    blocksize = 512 * 1024;\n\n    fi->seek(overlay_offset, SEEK_SET);\n    if (ph.version > 8)\n    {\n        p_info hbuf;\n        fi->readx(&hbuf, sizeof(hbuf));\n        orig_file_size = get_te32(&hbuf.p_filesize);\n        blocksize = get_te32(&hbuf.p_blocksize);\n\n        if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n            throwCantUnpack("file header corrupted");\n    }\n    else\n    {\n        // skip 4 bytes (program id)\n        fi->seek(4, SEEK_CUR);\n    }\n\n    if ((int)(blocksize + OVERHEAD) < 0)\n        throwCantUnpack("blocksize corrupted");\n    ibuf.alloc(blocksize + OVERHEAD);\n\n    // decompress blocks\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    memset(&bhdr, 0, sizeof(bhdr));\n    for (;;)\n    {\n#define buf ibuf\n        int i;\n        unsigned sz_unc, sz_cpr;\n\n        fi->readx(&bhdr, szb_info);\n        ph.u_len = sz_unc = get_te32(&bhdr.sz_unc);\n        ph.c_len = sz_cpr = get_te32(&bhdr.sz_cpr);\n\n        if (sz_unc == 0)                   // uncompressed size 0 -> EOF\n        {\n            // note: must reload sz_cpr as magic is always stored le32\n            sz_cpr = get_le32(&bhdr.sz_cpr);\n            if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n                throwCompressedDataViolation();\n            break;\n        }\n        if (sz_unc <= 0 || sz_cpr <= 0)\n            throwCompressedDataViolation();\n        if (sz_cpr > sz_unc || sz_unc > blocksize)\n            throwCompressedDataViolation();\n\n        i = blocksize + OVERHEAD - sz_cpr;\n        if (i < 0)\n            throwCantUnpack("corrupt b_info");\n        fi->readx(buf+i, sz_cpr);\n        // update checksum of compressed data\n        c_adler = upx_adler32(buf + i, sz_cpr, c_adler);\n        // decompress\n        if (sz_cpr < sz_unc) {\n            decompress(buf+i, buf, false);\n            if (0!=bhdr.b_ftid) {\n                Filter ft(ph.level);\n                ft.init(bhdr.b_ftid);\n                ft.cto = bhdr.b_cto8;\n                ft.unfilter(buf, sz_unc);\n            }\n            i = 0;\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(buf + i, sz_unc, u_adler);\n        total_in  += sz_cpr;\n        total_out += sz_unc;\n        // write block\n        if (fo)\n            fo->write(buf + i, sz_unc);\n#undef buf\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (ph.version > 8 && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 559, '_4': 659, '_5': 'PackUnix.unpack:void(OutputFile*)', '_6': 'src/p_unix.cpp'}, {'_1': 111669150403, '_2': 'void PackVmlinuxBase<T>::unpack(OutputFile *fo)\n{\n    TE32 word;\n    PackHeader const ph_tmp(ph);\n\n    fi->seek(p_note0->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note0->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n    if (!has_valid_vmlinux_head()) {\n        throwCantUnpack(".text corrupted");\n    }\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf);\n\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    fi->seek(p_note1->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note1->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, p_note1->sh_size - sizeof(ph.u_len));\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n}\n', '_3': 609, '_4': 656, '_5': 'PackVmlinuxBase.unpack:void(OutputFile*)', '_6': 'src/p_vmlinx.cpp'}, {'_1': 111669150469, '_2': 'void PackVmlinuzI386::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, physical_start);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 682, '_4': 710, '_5': 'PackVmlinuzI386.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150484, '_2': 'void PackVmlinuzARMEL::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 1039, '_4': 1067, '_5': 'PackVmlinuzARMEL.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150535, '_2': 'void PackWcle::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    readObjectTable();\n    iobject_desc.dealloc();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    decodeImage();\n    decodeObjectTable();\n\n    // unfilter\n    if (ph.filter)\n    {\n        const unsigned text_size = OOT(oh.init_cs_object-1,npages) * mps;\n        const unsigned text_vaddr = OOT(oh.init_cs_object-1,my_base_address);\n\n        Filter ft(ph.level);\n        ft.init(ph.filter, text_vaddr);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(oimage+ph.u_len-9) >> 24);\n        ft.unfilter(oimage+text_vaddr, text_size);\n    }\n\n    decodeFixupPageTable();\n    decodeFixups();\n    decodeEntryTable();\n    decodePageMap();\n    decodeResidentNames();\n    decodeNonResidentNames();\n\n    for (unsigned ic = 0; ic < soobject_table; ic++)\n        OOT(ic,my_base_address) = 0;\n\n    while (oimage[soimage-1] == 0)\n        soimage--;\n    oh.bytes_on_last_page = soimage % mps;\n\n    // write decompressed file\n    if (fo)\n        writeFile(fo, opt->watcom_le.le);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset\n        + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, &oimage);\n}\n', '_3': 803, '_4': 858, '_5': 'PackWcle.unpack:void(OutputFile*)', '_6': 'src/p_wcle.cpp'}, {'_1': 111669150641, '_2': 'void PackMaster::unpack(OutputFile *fo) {\n    p = getUnpacker(fi);\n    p->assertPacker();\n    fi = NULL;\n    p->doUnpack(fo);\n}', '_3': 265, '_4': 270, '_5': 'PackMaster.unpack:void(OutputFile*)', '_6': 'src/packmast.cpp'}, {'_1': 111669150763, '_2': 'void PeFile32::unpack(OutputFile *fo)\n{\n    bool set_oft = getFormat() == UPX_F_WINCE_ARM_PE;\n    unpack0<pe_header_t, LE32>(fo, ih, oh, 1U << 31, set_oft);\n}', '_3': 3118, '_4': 3122, '_5': 'PeFile32.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669150772, '_2': 'void PeFile64::unpack(OutputFile *fo)\n{\n    unpack0<pe_header_t, LE64>(fo, ih, oh, 1ULL << 63, false);\n}', '_3': 3173, '_4': 3176, '_5': 'PeFile64.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669152545, '_2': 'virtual void unpack(OutputFile *fo) = 0;', '_3': 155, '_4': 155, '_5': 'Packer.unpack:void(OutputFile*)', '_6': 'src/packer.h'}]
Tool result: []
Tool result: []
Tool result: [{'_1': 111669150013, '_2': 'void PackCom::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read whole file\n    fi->seek(0,SEEK_SET);\n    fi->readx(ibuf,file_size);\n\n    // get compressed data offset\n    int e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (file_size <= e_len + (off_t)ph.c_len)\n        throwCantUnpack("file damaged");\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, getCallTrickOffset());\n    ft.unfilter(obuf,ph.u_len);\n\n    // write decompressed file\n    if (fo)\n        fo->write(obuf,ph.u_len);\n}', '_3': 236, '_4': 261, '_5': 'PackCom.unpack:void(OutputFile*)', '_6': 'src/p_com.cpp'}, {'_1': 111669150030, '_2': 'void PackDjgpp2::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(coff_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    coff_header_t *chdr = (coff_header_t*) obuf.getVoidPtr();\n    text = chdr->sh;\n    data = text + 1;\n\n    const unsigned hdrsize = 20 + 28\n        + sizeof(external_scnhdr_t) * chdr->f_nscns;\n\n    unsigned addvalue;\n    if (ph.version >= 14)\n        addvalue = text->vaddr - hdrsize;\n    else\n        addvalue = text->vaddr &~ 0x1ff; // for old versions\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, addvalue);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n        {\n            unsigned char ctobuf[4];\n            fi->readx(ctobuf, 4);\n            ft.cto = (unsigned char) (get_le32(ctobuf) >> 24);\n        }\n        ft.unfilter(obuf, ph.u_len - data->size);\n    }\n\n    if (ph.version < 14)\n    {\n        // fixup for the aligning bug in strip 2.8+\n        text->scnptr &= 0x1ff;\n        data->scnptr = text->scnptr + text->size;\n        // write decompressed file\n        if (fo)\n            fo->write(obuf, ph.u_len);\n    }\n    else\n    {\n        // write the header\n        // some padding might be required between the end\n        // of the header and the start of the .text section\n\n        const unsigned padding = text->scnptr - hdrsize;\n        ibuf.clear(0, padding);\n\n        if (fo)\n        {\n            fo->write(obuf, hdrsize);\n            fo->write(ibuf, padding);\n            fo->write(obuf + hdrsize, ph.u_len - hdrsize);\n        }\n    }\n\n    if (fo)\n        handle_allegropak(fi, fo);\n}\n', '_3': 401, '_4': 470, '_5': 'PackDjgpp2.unpack:void(OutputFile*)', '_6': 'src/p_djgpp2.cpp'}, {'_1': 111669150043, '_2': 'void PackExe::unpack(OutputFile *fo)\n{\n    ibuf.alloc(file_size);\n    obuf.allocForUncompression(ph.u_len);\n\n    // read the file\n    fi->seek(ih.headsize16*16,SEEK_SET);\n    fi->readx(ibuf,ih_imagesize);\n\n    // get compressed data offset\n    unsigned e_len = ph.buf_offset + ph.getPackHeaderSize();\n    if (ih_imagesize <= e_len + ph.c_len)\n        throwCantUnpack("file damaged");\n\n    checkOverlay(ih_overlay);\n\n    // decompress\n    decompress(ibuf+e_len,obuf);\n\n    unsigned imagesize = ih_imagesize;\n    imagesize--;\n    const unsigned char flag = ibuf[imagesize];\n\n    unsigned relocn = 0;\n    upx_byte *relocs = obuf + ph.u_len;\n\n    MemBuffer wrkmem;\n    if (!(flag & NORELOC))\n    {\n        relocs -= get_le16(obuf+ph.u_len-2);\n        ph.u_len -= 2;\n\n        wrkmem.alloc(4*MAXRELOCS);\n        unsigned es = 0, ones = get_le16(relocs);\n        const unsigned seghi = get_le16(relocs+2);\n        const upx_byte *p = relocs + 4;\n\n        while (ones)\n        {\n            unsigned di = get_le16(p);\n            es += get_le16(p+2);\n            bool dorel = true;\n            for (p += 4; ones && di < 0x10000; p++)\n            {\n                if (dorel)\n                {\n                    set_le16(wrkmem+4*relocn,di);\n                    set_le16(wrkmem+2+4*relocn++,es);\n                    //printf ("%x\\n",es*16+di);\n                }\n                dorel = true;\n                if (*p == 0)\n                {\n                    const upx_byte *q;\n                    for (q = obuf+es*16+di; !(*q == 0x9a && get_le16(q+3) <= seghi); q++)\n                        ;\n                    di = ptr_diff(q, obuf+es*16) + 3;\n                }\n                else if (*p == 1)\n                {\n                    di += 254;\n                    if (di < 0x10000)\n                        ones--;\n                    dorel = false;\n                }\n                else\n                    di += *p;\n            }\n        }\n    }\n\n    // fill new exe header\n    memset(&oh,0,sizeof(oh));\n    oh.ident = \'M\' + \'Z\'*256;\n\n    if (relocn)\n    {\n        oh.relocs = relocn;\n        while (relocn & 3)\n            set_le32(wrkmem+4*relocn++,0);\n    }\n\n    unsigned outputlen = ptr_diff(relocs, obuf) + sizeof(oh) + relocn*4;\n    oh.m512 = outputlen & 511;\n    oh.p512 = (outputlen + 511) >> 9;\n    oh.headsize16 = 2+relocn/4;\n\n    oh.max = ih.max;\n    oh.min = ih.min;\n    oh.sp = ih.sp;\n    oh.ss = ih.ss;\n\n    if (flag & MAXMEM)\n        { imagesize -= 2; oh.max = get_le16(ibuf+imagesize); }\n    if (flag & MINMEM)\n        { imagesize -= 2; oh.min = get_le16(ibuf+imagesize); }\n    if (flag & SP)\n        { imagesize -= 2; oh.sp = get_le16(ibuf+imagesize); }\n    if (flag & SS)\n        { imagesize -= 2; oh.ss = get_le16(ibuf+imagesize); }\n\n    unsigned ip = (flag & USEJUMP) ? get_le32(ibuf+imagesize-4) : (unsigned) ih.firstreloc;\n    oh.ip = ip & 0xffff;\n    oh.cs = ip >> 16;\n\n    oh.relocoffs = sizeof(oh);\n    oh.firstreloc = 0;\n    if (!fo)\n        return;\n\n    // write header + relocations + uncompressed file\n    fo->write(&oh,sizeof(oh));\n    if (relocn)\n        fo->write(wrkmem,relocn*4);\n    fo->write(obuf, ptr_diff(relocs, obuf));\n\n    // copy the overlay\n    copyOverlay(fo, ih_overlay, &obuf);\n}\n', '_3': 688, '_4': 806, '_5': 'PackExe.unpack:void(OutputFile*)', '_6': 'src/p_exe.cpp'}, {'_1': 111669150173, '_2': 'void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Rela offset", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 3844, '_4': 4161, '_5': 'PackLinuxElf64.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150213, '_2': 'void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack("bad e_phoff");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack("l_info corrupted");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack("p_info corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack("b_info corrupted");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack("ElfXX_Ehdr corrupted");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack("bad compressed e_phnum");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n            unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n            Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                "bad dynsym", off_dynsym, sz_dynsym);\n            Elf32_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                unsigned symval = get_te32(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf32_Sym::SHN_UNDEF != symsec\n                &&  Elf32_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te32(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr *dynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&dynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by \'rust\' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Rel offset", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                "bad Jmprel offset", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 4604, '_4': 4922, '_5': 'PackLinuxElf32.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150214, '_2': 'void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack("internal error");\n}', '_3': 4924, '_4': 4927, '_5': 'PackLinuxElf.unpack:void(OutputFile*)', '_6': 'src/p_lx_elf.cpp'}, {'_1': 111669150243, '_2': 'void PackLinuxElf32x86interp::unpack(OutputFile *fo)\n{\n#define MAX_INTERP_HDR 512\n    union {\n        unsigned char buf[MAX_INTERP_HDR];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        fi->seek(0, SEEK_SET);\n        fi->readx(u.buf, MAX_INTERP_HDR);\n        unsigned const e_entry = get_te32(&ehdr->e_entry);\n        if (e_entry < 0x401180) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n        throwCantUnpack("file header corrupted");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n    off_t ptload0hi=0, ptload1lo=0, ptload1sz=0;\n\n    // decompress PT_LOAD\n    bool first_PF_X = true;\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n    for (unsigned j=0; j < ehdr->e_phnum; ++phdr, ++j) {\n        if (PT_LOAD==phdr->p_type) {\n            if (0==ptload0hi) {\n                ptload0hi = phdr->p_filesz + phdr->p_offset;\n            }\n            else if (0==ptload1lo) {\n                ptload1lo = phdr->p_offset;\n                ptload1sz = phdr->p_filesz;\n            }\n            if (fo)\n                fo->seek(phdr->p_offset, SEEK_SET);\n            if (Elf32_Phdr::PF_X & phdr->p_flags) {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, first_PF_X, szb_info);\n                first_PF_X = false;\n            }\n            else {\n                unpackExtent(phdr->p_filesz, fo, total_in, total_out,\n                    c_adler, u_adler, false, szb_info);\n            }\n        }\n    }\n\n    if (0!=ptload1sz && ptload0hi < ptload1lo) {  // alignment hole?\n        if (fo)\n            fo->seek(ptload0hi, SEEK_SET);\n        unpackExtent(ptload1lo - ptload0hi, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    if (total_out != orig_file_size) {  // non-PT_LOAD stuff\n        if (fo)\n            fo->seek(0, SEEK_END);\n        unpackExtent(orig_file_size - total_out, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_INTERP_HDR\n}\n', '_3': 198, '_4': 308, '_5': 'PackLinuxElf32x86interp.unpack:void(OutputFile*)', '_6': 'src/p_lx_interp.cpp'}, {'_1': 111669150315, '_2': 'void PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack("file header corrupted");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack("file header corrupted");\n    }\n    rawmseg = (Mach_segment_command *) New(char, sz_cmds);\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > 0x05000000)\n        throwCantUnpack("file header corrupted");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning("packed size too big; discarding appended data, keeping backup");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack("file header corrupted");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    Mach_header *const mhdr = (Mach_header *) New(upx_byte, ph.u_len);\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack("file header corrupted");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd = New(Mach_segment_command, ncmds);\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n        if (ptr_udiff(ptr, (1+ mhdr)) > ph.u_len) {\n            throwCantUnpack("cmdsize");\n        }\n    }\n\n    // Put LC_SEGMENT together at the beginning, ascending by .vmaddr.\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n    delete [] mhdr;\n}\n', '_3': 1421, '_4': 1547, '_5': 'PackMachBase.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150324, '_2': 'void PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode ("-t") sets fo = NULL\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n', '_3': 2200, '_4': 2300, '_5': 'PackMachFat.unpack:void(OutputFile*)', '_6': 'src/p_mach.cpp'}, {'_1': 111669150345, '_2': 'void PackPs1::unpack(OutputFile *fo)\n{\n    // restore orig exec hdr\n    memcpy(&oh, &ih, sizeof(ih));\n    memcpy((void *) &oh.epc, &bh, SZ_IH_BKUP);\n\n    // check for removed sector alignment\n    assert(oh.tx_len >= ph.u_len);\n    const unsigned pad = oh.tx_len - ph.u_len;\n\n    ibuf.alloc(fdata_size > PS_HDR_SIZE ? fdata_size : PS_HDR_SIZE);\n    obuf.allocForUncompression(ph.u_len, pad);\n\n    fi->seek(PS_HDR_SIZE, SEEK_SET);\n    fi->readx(ibuf, fdata_size);\n\n    // decompress\n    decompress(ibuf + (fdata_size - ph.c_len), obuf);\n\n    // write decompressed file\n    if (fo)\n    {\n        // write header\n        fo->write(&oh, sizeof(oh));\n        // align the ps exe header (mode 2 sector data size)\n        ibuf.clear();\n        fo->write(ibuf, PS_HDR_SIZE - fo->getBytesWritten());\n        // write uncompressed data + pad\n        obuf.clear(ph.u_len, pad);\n        fo->write(obuf, ph.u_len + pad);\n    }\n}', '_3': 708, '_4': 739, '_5': 'PackPs1.unpack:void(OutputFile*)', '_6': 'src/p_ps1.cpp'}, {'_1': 111669150361, '_2': 'void PackTmt::unpack(OutputFile *fo)\n{\n    Packer::handleStub(fi,fo,adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(),SEEK_SET);\n    fi->readx(ibuf,ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf+ph.u_len-4);\n    upx_byte *relocs = obuf + osize;\n    const unsigned origstart = get_le32(obuf+ph.u_len-8);\n\n    // unfilter\n    if (ph.filter)\n    {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf+ph.u_len-12) >> 24);\n        ft.unfilter(obuf, ptr_diff(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer wrkmem;\n    unsigned relocn = unoptimizeReloc32(&relocs,obuf,&wrkmem,1);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem+ic*4,get_le32(wrkmem+ic*4)+4);\n\n    memcpy(&oh,&ih,sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn*4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize\n        - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo)\n    {\n        fo->write(&oh,sizeof(oh));\n        fo->write(obuf,osize);\n        fo->write(wrkmem,relocn*4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, &obuf);\n}\n', '_3': 307, '_4': 361, '_5': 'PackTmt.unpack:void(OutputFile*)', '_6': 'src/p_tmt.cpp'}, {'_1': 111669150377, '_2': 'void PackTos::unpack(OutputFile *fo)\n{\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(FH_SIZE + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf,obuf);\n\n    // write original header & decompressed file\n    if (fo)\n    {\n        unsigned overlay = file_size - (FH_SIZE + ih.fh_text + ih.fh_data);\n        if (ih.fh_reloc == 0 && overlay >= 4)\n            overlay -= 4;                           // this is our empty fixup\n        checkOverlay(overlay);\n\n        fo->write(obuf+ph.u_len-FH_SIZE, FH_SIZE);  // orig. file_hdr\n        fo->write(obuf, ph.u_len-FH_SIZE);          // orig. text+data+relocs\n\n        // copy any overlay\n        copyOverlay(fo, overlay, &obuf);\n    }\n}', '_3': 750, '_4': 775, '_5': 'PackTos.unpack:void(OutputFile*)', '_6': 'src/p_tos.cpp'}, {'_1': 111669150393, '_2': 'void PackUnix::unpack(OutputFile *fo)\n{\n    b_info bhdr;\n    unsigned const szb_info = (ph.version <= 11)\n        ? sizeof(bhdr.sz_unc) + sizeof(bhdr.sz_cpr)  // old style\n        : sizeof(bhdr);\n\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // defaults for ph.version == 8\n    unsigned orig_file_size = 0;\n    blocksize = 512 * 1024;\n\n    fi->seek(overlay_offset, SEEK_SET);\n    if (ph.version > 8)\n    {\n        p_info hbuf;\n        fi->readx(&hbuf, sizeof(hbuf));\n        orig_file_size = get_te32(&hbuf.p_filesize);\n        blocksize = get_te32(&hbuf.p_blocksize);\n\n        if (file_size > (off_t)orig_file_size || blocksize > orig_file_size)\n            throwCantUnpack("file header corrupted");\n    }\n    else\n    {\n        // skip 4 bytes (program id)\n        fi->seek(4, SEEK_CUR);\n    }\n\n    if ((int)(blocksize + OVERHEAD) < 0)\n        throwCantUnpack("blocksize corrupted");\n    ibuf.alloc(blocksize + OVERHEAD);\n\n    // decompress blocks\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    memset(&bhdr, 0, sizeof(bhdr));\n    for (;;)\n    {\n#define buf ibuf\n        int i;\n        unsigned sz_unc, sz_cpr;\n\n        fi->readx(&bhdr, szb_info);\n        ph.u_len = sz_unc = get_te32(&bhdr.sz_unc);\n        ph.c_len = sz_cpr = get_te32(&bhdr.sz_cpr);\n\n        if (sz_unc == 0)                   // uncompressed size 0 -> EOF\n        {\n            // note: must reload sz_cpr as magic is always stored le32\n            sz_cpr = get_le32(&bhdr.sz_cpr);\n            if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n                throwCompressedDataViolation();\n            break;\n        }\n        if (sz_unc <= 0 || sz_cpr <= 0)\n            throwCompressedDataViolation();\n        if (sz_cpr > sz_unc || sz_unc > blocksize)\n            throwCompressedDataViolation();\n\n        i = blocksize + OVERHEAD - sz_cpr;\n        if (i < 0)\n            throwCantUnpack("corrupt b_info");\n        fi->readx(buf+i, sz_cpr);\n        // update checksum of compressed data\n        c_adler = upx_adler32(buf + i, sz_cpr, c_adler);\n        // decompress\n        if (sz_cpr < sz_unc) {\n            decompress(buf+i, buf, false);\n            if (0!=bhdr.b_ftid) {\n                Filter ft(ph.level);\n                ft.init(bhdr.b_ftid);\n                ft.cto = bhdr.b_cto8;\n                ft.unfilter(buf, sz_unc);\n            }\n            i = 0;\n        }\n        // update checksum of uncompressed data\n        u_adler = upx_adler32(buf + i, sz_unc, u_adler);\n        total_in  += sz_cpr;\n        total_out += sz_unc;\n        // write block\n        if (fo)\n            fo->write(buf + i, sz_unc);\n#undef buf\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (ph.version > 8 && total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n', '_3': 559, '_4': 659, '_5': 'PackUnix.unpack:void(OutputFile*)', '_6': 'src/p_unix.cpp'}, {'_1': 111669150403, '_2': 'void PackVmlinuxBase<T>::unpack(OutputFile *fo)\n{\n    TE32 word;\n    PackHeader const ph_tmp(ph);\n\n    fi->seek(p_note0->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note0->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n    if (!has_valid_vmlinux_head()) {\n        throwCantUnpack(".text corrupted");\n    }\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf);\n\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    fi->seek(p_note1->sh_offset, SEEK_SET);\n    fi->readx(&word, sizeof(word));\n    ph.u_len = word;\n    ph.c_len = p_note1->sh_size - sizeof(word);\n    ibuf.alloc(ph.c_len);\n    fi->readx(ibuf, p_note1->sh_size - sizeof(ph.u_len));\n    obuf.allocForUncompression(ph.u_len);\n    decompress(ibuf, obuf, false);\n    fo->write(obuf, ph.u_len);\n    obuf.dealloc();\n    ibuf.dealloc();\n\n    ph = ph_tmp;\n}\n', '_3': 609, '_4': 656, '_5': 'PackVmlinuxBase.unpack:void(OutputFile*)', '_6': 'src/p_vmlinx.cpp'}, {'_1': 111669150469, '_2': 'void PackVmlinuzI386::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, physical_start);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 682, '_4': 710, '_5': 'PackVmlinuzI386.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150484, '_2': 'void PackVmlinuzARMEL::unpack(OutputFile *fo)\n{\n    // no uncompression support for this format, so that\n    // it is possible to remove the original deflate code (>10 KiB)\n\n    // FIXME: but we could write the uncompressed "vmlinux" image\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForUncompression(ph.u_len);\n\n    fi->seek(setup_size + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // unfilter\n    Filter ft(ph.level);\n    ft.init(ph.filter, 0);\n    ft.cto = (unsigned char) ph.filter_cto;\n    ft.unfilter(obuf, ph.u_len);\n\n    // write decompressed file\n    if (fo)\n    {\n        throwCantUnpack("build a new kernel instead :-)");\n        //fo->write(obuf, ph.u_len);\n    }\n}', '_3': 1039, '_4': 1067, '_5': 'PackVmlinuzARMEL.unpack:void(OutputFile*)', '_6': 'src/p_vmlinz.cpp'}, {'_1': 111669150535, '_2': 'void PackWcle::unpack(OutputFile *fo)\n{\n    handleStub(fo);\n\n    readObjectTable();\n    iobject_desc.dealloc();\n    readPageMap();\n    readResidentNames();\n    readEntryTable();\n    readFixupPageTable();\n    readFixups();\n    readImage();\n    readNonResidentNames();\n\n    decodeImage();\n    decodeObjectTable();\n\n    // unfilter\n    if (ph.filter)\n    {\n        const unsigned text_size = OOT(oh.init_cs_object-1,npages) * mps;\n        const unsigned text_vaddr = OOT(oh.init_cs_object-1,my_base_address);\n\n        Filter ft(ph.level);\n        ft.init(ph.filter, text_vaddr);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(oimage+ph.u_len-9) >> 24);\n        ft.unfilter(oimage+text_vaddr, text_size);\n    }\n\n    decodeFixupPageTable();\n    decodeFixups();\n    decodeEntryTable();\n    decodePageMap();\n    decodeResidentNames();\n    decodeNonResidentNames();\n\n    for (unsigned ic = 0; ic < soobject_table; ic++)\n        OOT(ic,my_base_address) = 0;\n\n    while (oimage[soimage-1] == 0)\n        soimage--;\n    oh.bytes_on_last_page = soimage % mps;\n\n    // write decompressed file\n    if (fo)\n        writeFile(fo, opt->watcom_le.le);\n\n    // copy the overlay\n    const unsigned overlaystart = ih.data_pages_offset + exe_offset\n        + getImageSize();\n    const unsigned overlay = file_size - overlaystart - ih.non_resident_name_table_length;\n    checkOverlay(overlay);\n    copyOverlay(fo, overlay, &oimage);\n}\n', '_3': 803, '_4': 858, '_5': 'PackWcle.unpack:void(OutputFile*)', '_6': 'src/p_wcle.cpp'}, {'_1': 111669150641, '_2': 'void PackMaster::unpack(OutputFile *fo) {\n    p = getUnpacker(fi);\n    p->assertPacker();\n    fi = NULL;\n    p->doUnpack(fo);\n}', '_3': 265, '_4': 270, '_5': 'PackMaster.unpack:void(OutputFile*)', '_6': 'src/packmast.cpp'}, {'_1': 111669150763, '_2': 'void PeFile32::unpack(OutputFile *fo)\n{\n    bool set_oft = getFormat() == UPX_F_WINCE_ARM_PE;\n    unpack0<pe_header_t, LE32>(fo, ih, oh, 1U << 31, set_oft);\n}', '_3': 3118, '_4': 3122, '_5': 'PeFile32.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669150772, '_2': 'void PeFile64::unpack(OutputFile *fo)\n{\n    unpack0<pe_header_t, LE64>(fo, ih, oh, 1ULL << 63, false);\n}', '_3': 3173, '_4': 3176, '_5': 'PeFile64.unpack:void(OutputFile*)', '_6': 'src/pefile.cpp'}, {'_1': 111669152545, '_2': 'virtual void unpack(OutputFile *fo) = 0;', '_3': 155, '_4': 155, '_5': 'Packer.unpack:void(OutputFile*)', '_6': 'src/packer.h'}]
Result saved to /4_Experiment/RQ5/Caller_Callee/Results/error_analysis/CVE-2018-11243_error.json
Tool result: [{'caller_func': 'BOOL CEAnsi::OurWriteConsoleW(HANDLE hConsoleOutput, const VOID *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved, bool bInternal /*= false*/)\n{\n\tORIGINAL_KRNL(WriteConsoleW);\n\tBOOL lbRc = FALSE;\n\t//ExtWriteTextParm wrt = {sizeof(wrt), ewtf_None, hConsoleOutput};\n\tbool bIsConOut = false;\n\tbool bIsAnsi = false;\n\n\tFIRST_ANSI_CALL(static_cast<const BYTE*>(lpBuffer), nNumberOfCharsToWrite);\n\n#if 0\n\t// Store prompt(?) for clink 0.1.1\n\tif ((gnAllowClinkUsage == 1) && nNumberOfCharsToWrite && lpBuffer && gpszLastWriteConsole && gcchLastWriteConsoleMax)\n\t{\n\t\tsize_t cchMax = std::min(gcchLastWriteConsoleMax-1,nNumberOfCharsToWrite);\n\t\tgpszLastWriteConsole[cchMax] = 0;\n\t\twmemmove(gpszLastWriteConsole, (const wchar_t*)lpBuffer, cchMax);\n\t}\n#endif\n\n\t// In debug builds: Write to debug console all console Output\n\tconst auto ansiIndex = DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal);\n\n#ifdef _DEBUG\n\tstruct AnsiDuration  // NOLINT(cppcoreguidelines-special-member-functions)\n\t{\n\t\tconst int ansiIndex_;\n\t\tconst std::chrono::steady_clock::time_point startTime_;\n\n\t\tAnsiDuration(const int ansiIndex)\n\t\t\t: ansiIndex_(ansiIndex), startTime_(std::chrono::steady_clock::now())\n\t\t{\n\t\t}\n\n\t\t~AnsiDuration()\n\t\t{\n\t\t\tconst auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - startTime_);\n\t\t\twchar_t info[80] = L"";\n\t\t\tmsprintf(info, countof(info), L"[%u] AnsiDump #%u duration(ms): %u\\n", GetCurrentThreadId(), ansiIndex_, duration.count());\n\t\t\tOutputDebugStringW(info);\n\t\t}\n\t};\n\tAnsiDuration duration(ansiIndex);\n#endif\n\n\tCEAnsi* pObj = nullptr;\n\tCEStr cpCvtBuffer;\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput)\n\t{\n\t\tbIsAnsi = HandleKeeper::IsAnsiCapable(hConsoleOutput, &bIsConOut);\n\n\t\tif (ghAnsiLogFile && bIsConOut)\n\t\t{\n\t\t\tCEAnsi::WriteAnsiLogW(static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite);\n\t\t}\n\t}\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput && bIsAnsi)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (!bInternal && gCpConv.nFromCP && gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from unicode to MBCS\n\t\t\tCEStrA pszTemp;\n\t\t\tint iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif ((iMbcsLen > 0) && ((pszTemp.GetBuffer(iMbcsLen)) != nullptr))\n\t\t\t{\n\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can\'t be mapped\n\t\t\t\tiMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, pszTemp.data(), iMbcsLen, nullptr, &bFailed);\n\t\t\t\tif ((iMbcsLen > 0) && !bFailed)\n\t\t\t\t{\n\t\t\t\t\tint iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, nullptr, 0);\n\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t* ptrBuf = cpCvtBuffer.GetBuffer(iWideLen);\n\t\t\t\t\t\tif (ptrBuf)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t{\n\t\t\tif (pObj->gnPrevAnsiPart || gDisplayOpt.WrapWasSet)\n\t\t\t{\n\t\t\t\t// Если остался "хвост" от предущей записи - сразу, без проверок\n\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\tgoto ansidone;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_ASSERTEX(ESC==27 && BEL==7 && DSC==0x90);\n\t\t\t\tconst wchar_t* pch = static_cast<const wchar_t*>(lpBuffer);\n\t\t\t\tfor (size_t i = nNumberOfCharsToWrite; i--; pch++)\n\t\t\t\t{\n\t\t\t\t\t// Если в выводимой строке встречается "Ansi ESC Code" - выводим сами\n\t\t\t\t\tTODO("Non-CSI codes, like as BEL, BS, CR, LF, FF, TAB, VT, SO, SI");\n\t\t\t\t\tif (*pch == ESC /*|| *pch == BEL*/ /*|| *pch == ENQ*/)\n\t\t\t\t\t{\n\t\t\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\t\t\tgoto ansidone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!bIsAnsi || ((pObj = CEAnsi::Object()) == nullptr))\n\t{\n\t\tlbRc = F(WriteConsoleW)(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n\t}\n\telse\n\t{\n\t\tlbRc = pObj->WriteText(F(WriteConsoleW), hConsoleOutput, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten, TRUE);\n\t\t//wrt.Flags = ewtf_Current|ewtf_Commit;\n\t\t//wrt.Buffer = (const wchar_t*)lpBuffer;\n\t\t//wrt.NumberOfCharsToWrite = nNumberOfCharsToWrite;\n\t\t//wrt.Private = F(WriteConsoleW);\n\t\t//lbRc = ExtWriteText(&wrt);\n\t\t//if (lbRc)\n\t\t//{\n\t\t//\tif (lpNumberOfCharsWritten)\n\t\t//\t\t*lpNumberOfCharsWritten = wrt.NumberOfCharsWritten;\n\t\t//\tif (wrt.ScrolledRowsUp > 0)\n\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)wrt.ScrolledRowsUp));\n\t\t//}\n\t}\n\tgoto wrap;\n\nansidone:\n\t{\n\t\tExtCommitParm cmt = {sizeof(cmt), hConsoleOutput};\n\t\tExtCommit(&cmt);\n\t}\nwrap:\n\treturn lbRc;\n}\n', 'caller_start': 1413, 'caller_end': 1559, 'call_line': 1434, 'call_code': 'DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}, {'caller_func': 'int CEAnsi::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, CEAnsi::AnsiEscCode& Code, BOOL ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tconst INT_PTR nCurPrevLen = gnPrevAnsiPart;\n\t\t\tconst INT_PTR nAdd = std::min((lpEnd-lpBuffer),static_cast<INT_PTR>(countof(gsPrevAnsiPart))-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX(static_cast<INT_PTR>(countof(gsPrevAnsiPart)) > (nCurPrevLen + nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING("Проверить!!!");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tconst int iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart + nAdd + gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst INT_PTR nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen > 0 && nSkipLen <= static_cast<INT_PTR>(countof(gsPrevAnsiPart)) && nSkipLen <= gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(writeConsoleW, hConsoleOutput, gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= (static_cast<int>(CEAnsi_MaxPrevPart) - static_cast<int>(cchPrevPart)));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += static_cast<int>(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING("Проверить!!!");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && "Invalid esc sequence, need dump to screen?");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tINT_PTR nLeft;\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like "ESC 7" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some "special" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'7\': // Save xterm cursor\n\t\t\t\t\tcase L\'8\': // Restore xterm cursor\n\t\t\t\t\tcase L\'c\': // Full reset\n\t\t\t\t\tcase L\'g\': // Visual Bell\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\tcase L\'H\': // Horizontal Tab Set\n\t\t\t\t\tcase L\'M\': // Reverse LF\n\t\t\t\t\tcase L\'E\': // CR-LF\n\t\t\t\t\tcase L\'D\': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO("Bypass unrecognized ESC sequences to screen? Don\'t try to eliminate \'Possible\' sequences?");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* \'|\' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L"[]|()%", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don\'t assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk="VK_ESCAPE" [27/0x001B], Scan=0x0001 uChar=[U=\'\\x1b\' (0x001B): A=\'\\x1b\' (0x1B)]\n\t\t\t\t\t\tconst bool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart - 1) == L\'\\\'\' && Code.Second == L\'\\\'\') || (*(lpSaveStart - 1) == L\' \' && Code.Second == L\' \'));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && "Unsupported control sequence?");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now parameters go\n\t\t\t\t\t++lpBuffer; // move pointer to the first char beyond CSI (after \'[\')\n\n\t\t\t\t\tauto parseNumArgs = [&Code](const wchar_t* &lpBufferParam, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wcSave;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBufferParam < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBufferParam)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L\'0\': case L\'1\': case L\'2\': case L\'3\': case L\'4\':\n\t\t\t\t\t\t\tcase L\'5\': case L\'6\': case L\'7\': case L\'8\': case L\'9\':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (static_cast<int>(*lpBufferParam) - L\'0\');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L\';\':\n\t\t\t\t\t\t\t\t// Even if there were no digits - default is "0"\n\t\t\t\t\t\t\t\tif (Code.ArgC < static_cast<int>(countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L\']\')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (((wcSave = *lpBufferParam) >= 64) && (wcSave <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wcSave;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((static_cast<size_t>(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wcSave; // Skip private symbols\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBufferParam;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L\']\');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\tcase L\')\':\n\t\t\t\t\tcase L\'%\':\n\t\t\t\t\t//case L\'#\':\n\t\t\t\t\t//case L\'*\':\n\t\t\t\t\t//case L\'+\':\n\t\t\t\t\t//case L\'-\':\n\t\t\t\t\t//case L\'.\':\n\t\t\t\t\t//case L\'/\':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\t// ReSharper disable once CppDeclaratorNeverUsed\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// В данном запросе (на запись) конца последовательности нет,\n\t\t\t\t\t\t// оставшийся хвост нужно сохранить в буфере, для следующего запроса\n\t\t\t\t\t\t// Ниже\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t// Finalizing (ST) with "\\x1B\\\\" or "\\x07"\n\t\t\t\t\t\t// "%]4;16;rgb:00/00/00%\\" - "%" is ESC\n\t\t\t\t\t\t// "%]0;this is the window titleBEL"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; "txt" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; "txt" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar "ConEmuWaitKey" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; "txt" ST        Execute GuiMacro. Set EnvVar "ConEmuMacroResult" on exit.\n\t\t\t\t\t\t// and others... look at CEAnsi::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we\'ll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // первый символ последовательности\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L\'\\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of "switch (Code.Second)"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && "Need to be checked!"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && "Too long Esc-sequence part, Need to be checked!");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of "case 27:"\n\t\t} // end of "switch (*lpBuffer)"\n\n\t\t++lpBuffer;\n\t} // end of "while (lpBuffer < lpEnd)"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n', 'caller_start': 1585, 'caller_end': 1988, 'call_line': 1740, 'call_code': 'DumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}, {'caller_func': "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", 'caller_start': 2492, 'caller_end': 2525, 'call_line': 2515, 'call_code': 'DumpKnownEscape(asRet, nLen, de_Report)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}, {'caller_func': 'BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// \'^\' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\'[\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\']\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L\'|\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'7\':\n\t\t\t\t\tcase L\'8\':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L\'7\'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'c\':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'g\':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'H\':\n\t\t\t\t\t\t// #ANSI gh-1827: support \'H\' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'M\':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'E\':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L"\\r\\n", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'D\':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\t\t// xterm "ESC =" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm "ESC >" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L\'0\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L\'B\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means "Esc part stored in buffer"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n', 'caller_start': 2608, 'caller_end': 2827, 'call_line': 2734, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}, {'caller_func': 'BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// \'^\' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\'[\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\']\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L\'|\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'7\':\n\t\t\t\t\tcase L\'8\':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L\'7\'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'c\':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'g\':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'H\':\n\t\t\t\t\t\t// #ANSI gh-1827: support \'H\' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'M\':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'E\':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L"\\r\\n", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'D\':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\t\t// xterm "ESC =" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm "ESC >" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L\'0\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L\'B\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means "Esc part stored in buffer"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n', 'caller_start': 2608, 'caller_end': 2827, 'call_line': 2749, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}, {'caller_func': 'BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// \'^\' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L\'[\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\'[\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\']\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L\']\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'|\':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L\'|\':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L\'7\':\n\t\t\t\t\tcase L\'8\':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L\'7\'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'c\':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'g\':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'H\':\n\t\t\t\t\t\t// #ANSI gh-1827: support \'H\' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'M\':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'E\':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L"\\r\\n", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'D\':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'=\':\n\t\t\t\t\tcase L\'>\':\n\t\t\t\t\t\t// xterm "ESC =" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm "ESC >" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L\'(\':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L\'0\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L\'B\':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means "Esc part stored in buffer"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n', 'caller_start': 2608, 'caller_end': 2827, 'call_line': 2765, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}, {'caller_func': 'void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L\'s\':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'u\':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'H\': // Set cursor position (1-based)\n\tcase L\'f\': // Same as \'H\'\n\tcase L\'A\': // Cursor up by N rows\n\tcase L\'B\': // Cursor down by N rows\n\tcase L\'C\': // Cursor right by N cols\n\tcase L\'D\': // Cursor left by N cols\n\tcase L\'E\': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L\'F\': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L\'G\': // Moves the cursor to column n.\n\tcase L\'d\': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L\'H\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'f\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'A\':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'B\':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'C\':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'D\':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'E\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'F\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'G\':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'d\':\n\t\t\t\t// Moves the cursor to line n (almost the same as \'H\', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && "Missed (sub)case value!");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case \'H\', \'f\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'d\'\n\t\tbreak;\n\n\tcase L\'J\': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport\'s upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L\'J\':\n\t\tbreak;\n\n\tcase L\'b\':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L\'b\'\n\n\tcase L\'K\': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO("Need to clear attributes?");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'K\':\n\t\tbreak;\n\n\tcase L\'r\':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L\'S\':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L\'L\':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L\'M\':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually "Scroll UP N line(s) inside defined scrolling region"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'@\':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L\'P\':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L\'T\':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO("Define scrolling region");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'h\':\n\tcase L\'l\':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as "ESC ] 9 ; 12 ST"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L\'h\');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO("Need to find proper way for activation alternative buffer from ViM?");\n\t\t\t\t\t\tif (Code.Action == L\'h\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L\'h\'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L\'h\');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L\'h\');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L\'h\');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm\'s UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm\'s CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt\'s CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L\'h\')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* \'V\': Mouse wheel reporting */\n\t\t\tcase 7787: /* \'W\': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret "meta" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'h\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L\'h\'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'l\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L\'h\'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All "pasted" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L\'h\'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L\'h\') && (Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L\'h\')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L\'h\': case L\'l\':\n\n\tcase L\'n\':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L"\\x1B[0n");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'m\':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // "[...m"\n\n\tcase L\'p\':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L\'!\')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[!p"\n\n\tcase L\'q\':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\' \'))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu\'s default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can\'t implement all possible styles in RealConsole,\n\t\t\t\t// but we can use "Block/Underline" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[...q"\n\n\tcase L\'t\':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO("ANSI: xterm window manipulation");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'c\':\n\t\t// echo -e "\\e[>c"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'>\')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal\'s identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be "ESC > 67 ; build ; 0 c"\n\t\t\t// 67 is ASCII code of \'C\' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L"\\x1B>%u;%u;0c", (int)\'C\', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L"\\x1B[>0;136;0c");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e "\\e[c"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report "VT100 with Advanced Video Option"\n\t\t\tReportString(L"\\x1B[?1;2c");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'X\':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'X\':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n', 'caller_start': 2829, 'caller_end': 3819, 'call_line': 3286, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}, {'caller_func': 'void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L\'s\':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'u\':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L\'H\': // Set cursor position (1-based)\n\tcase L\'f\': // Same as \'H\'\n\tcase L\'A\': // Cursor up by N rows\n\tcase L\'B\': // Cursor down by N rows\n\tcase L\'C\': // Cursor right by N cols\n\tcase L\'D\': // Cursor left by N cols\n\tcase L\'E\': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L\'F\': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L\'G\': // Moves the cursor to column n.\n\tcase L\'d\': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L\'H\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'f\':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'A\':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'B\':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'C\':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'D\':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L\'E\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'F\':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'G\':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L\'d\':\n\t\t\t\t// Moves the cursor to line n (almost the same as \'H\', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && "Missed (sub)case value!");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case \'H\', \'f\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'d\'\n\t\tbreak;\n\n\tcase L\'J\': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport\'s upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L\'J\':\n\t\tbreak;\n\n\tcase L\'b\':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L\'b\'\n\n\tcase L\'K\': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO("Need to clear attributes?");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'K\':\n\t\tbreak;\n\n\tcase L\'r\':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L\'S\':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L\'L\':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L\'M\':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually "Scroll UP N line(s) inside defined scrolling region"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'@\':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L\'P\':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L\'T\':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO("Define scrolling region");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L\'h\':\n\tcase L\'l\':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as "ESC ] 9 ; 12 ST"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L\'h\');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO("Need to find proper way for activation alternative buffer from ViM?");\n\t\t\t\t\t\tif (Code.Action == L\'h\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L\'h\'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L\'h\');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L\'h\');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L\'h\');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm\'s UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm\'s CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt\'s CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L\'h\')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* \'V\': Mouse wheel reporting */\n\t\t\tcase 7787: /* \'W\': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret "meta" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'h\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L\'h\'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L\'l\'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L\'h\'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All "pasted" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L\'h\'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L\'h\') && (Code.PvtLen == 1) && (Code.Pvt[0] == L\'?\'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L\'h\')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L\'h\')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L\'h\': case L\'l\':\n\n\tcase L\'n\':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L"\\x1B[0n");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'m\':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // "[...m"\n\n\tcase L\'p\':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L\'!\')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[!p"\n\n\tcase L\'q\':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\' \'))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu\'s default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can\'t implement all possible styles in RealConsole,\n\t\t\t\t// but we can use "Block/Underline" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // "[...q"\n\n\tcase L\'t\':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO("ANSI: xterm window manipulation");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'c\':\n\t\t// echo -e "\\e[>c"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L\'>\')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal\'s identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be "ESC > 67 ; build ; 0 c"\n\t\t\t// 67 is ASCII code of \'C\' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L"\\x1B>%u;%u;0c", (int)\'C\', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L"\\x1B[>0;136;0c");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e "\\e[c"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report "VT100 with Advanced Video Option"\n\t\t\tReportString(L"\\x1B[?1;2c");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L\'X\':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L\' \', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L\'X\':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n', 'caller_start': 2829, 'caller_end': 3819, 'call_line': 3328, 'call_code': 'DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)', 'call_path': 'src/ConEmuHk/Ansi.cpp'}]
Result saved to /4_Experiment/RQ5/Caller_Callee/Results/error_analysis/CVE-2023-39150_error.json
