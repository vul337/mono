CVE,is_valid,Humman Res,LLM Res,Commit_url
CVE-2019-1010238,,,"In `pango/pango-bidi-type.c:182+`, the loop iterates using `length` (bytes) without validating against `n_chars` (UTF-8 characters). `n_chars` is computed via `g_utf8_strlen(text, length)` (line 130). If `text` contains invalid UTF-8, `g_utf8_strlen` may return a smaller value than expected, while the loop continues until `p < text + length` (line 182). This allows `i` to exceed `n_chars`, causing a heap-based buffer overflow when writing to `bidi_types[i]` (line 186). The patch adds `if (i == n_chars) break;` (line 185) to cap writes at `n_chars`.",https://github.com/GNOME/pango/commit/490f8979a260c16b1df055eab386345da18a2d54
CVE-2018-20855,,,"1. `resp` declared without initialization in `drivers/infiniband/hw/mlx5/qp.c:1607` (create_qp_common). 2. `resp` is passed to `create_user_qp` and partially populated (e.g., `resp->bfreg_index`). 3. `ib_copy_to_udata` in `drivers/infiniband/hw/mlx5/qp.c:863` (create_user_qp) copies `resp` to userspace, leaking uninitialized stack memory.",https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00
CVE-2018-1281,,,"src/zmq_van.h:64-8: Original code used hardcoded 'tcp://*:' (binding to all interfaces). Patch replaces '*' with node.hostname. node.hostname is populated from DMLC_PS_ROOT_URI (src/van.cc:32-34) for scheduler nodes, and from DMLC_NODE_HOST/DMLC_INTERFACE (src/van.cc:45-65) for non-scheduler nodes.",https://github.com/dmlc/ps-lite/commit/4be817e8b03e7e92517e91f2dfcc50865e91c6ea
CVE-2021-32620,,,"The root cause was the absence of `validkey` reset after validation in `validateUser` (XWiki.java:3858-). The patch adds this reset, preventing the key from being reused to reactivate a disabled user.",https://github.com/xwiki/xwiki-platform/commit/f9a677408ffb06f309be46ef9d8df1915d9099a4
CVE-2016-4449,,,"In parser.c:2862, the original code called `xmlLoadEntityContent(ctxt, ent)` unconditionally when an entity's content was null. The patch restricts this call to only occur if the parser is in validating mode or specific options are set. This prevents external entity resolution in non-validating contexts, which was the source of the XXE vulnerability.",https://github.com/GNOME/libxml2/commit/b1d34de46a11323fccffa9fadeb33be670d602f5
CVE-2017-12667,,,"The memory leak is caused by `clone_info` (allocated via `CloneImageInfo` in `coders/mat.c:932+`) not being destroyed when an error triggers the `MATLAB_KO` label. The original code at `MATLAB_KO` directly threw an exception without calling `DestroyImageInfo(clone_info)`, leaving allocated memory unreleased. The patch adds `DestroyImageInfo(clone_info)` to this error handler, ensuring cleanup. This occurs when invalid MATLAB headers or unsupported formats trigger early termination after `clone_info` has been allocated.",https://github.com/ImageMagick/ImageMagick/commit/bfb7915d4b2e11acb6a819e451c382dc645277db
CVE-2018-6192,,,"A crafted PDF file provides an object number exceeding `PDF_MAX_OBJECT_NUMBER`. This number is parsed by `pdf_parse_ind_obj` (source/pdf/pdf-parse.c:624-626) and passed to `pdf_read_new_xref` (source/pdf/pdf-xref.c:980). The number is then used in `pdf_get_populating_xref_entry` (source/pdf/pdf-xref.c:229-231), which previously only checked for negative values. Without the upper bound check, this leads to out-of-bounds memory access when accessing xref sections, causing a segmentation fault.",https://github.com/ArtifexSoftware/mupdf/commit/5e411a99604ff6be5db9e273ee84737204113299
CVE-2019-18798,,,"1. In `weaveParents` (src/ast_sel_weave.cpp:577-583), `groups1.erase(groups1.begin())` and `groups2.erase(groups2.begin())` could trigger OOB access if `groups1`/`groups2` were empty. The patch adds `if (!empty())` checks.\n2. In `parseCompoundSelector` (src/parser_selectors.cpp:141-151), `seq->last()` was accessed without verifying `seq->empty()`. The fix uses `seq->hasRealParent()` and `seq->empty()` checks to avoid OOB.\n3. Attack vector: Malicious SASS input triggers empty `groups1`/`groups2` in `weaveParents` (called from `weave` at src/ast_sel_weave.cpp:494) or empty `seq` in `parseCompoundSelector` (called from `parseComplexSelector` at src/parser_selectors.cpp:42), leading to OOB reads.",https://github.com/sass/libsass/commit/0b721e0f37fc69ab197ec956a923e036e3b05ca6
CVE-2015-6526,,,"The vulnerability stems from an infinite loop (`for (;;)` at arch/powerpc/perf/callchain.c:243) in `perf_callchain_user_64`, which processes 64-bit userspace backtraces. The loop lacked a depth limit, allowing deep/malformed stacks to cause excessive iterations or infinite loops. The patch introduces a termination condition (`while (entry->nr < PERF_MAX_STACK_DEPTH)`) and relies on `perf_callchain_store` (include/linux/perf_event.h:749-753) to increment `entry->nr` only while under the depth limit. This ensures traversal stops after 127 entries, preventing resource exhaustion.",https://github.com/torvalds/linux/commit/9a5cbce421a283e6aea3c4007f141735bf9da8c3
CVE-2011-3353,,,"The vulnerability originated from user-space input to the FUSE device, where 'nbytes' (the write length) was used to calculate the 'size' parameter passed to 'fuse_notify_inval_entry'. In 'fuse_dev_write' (fs/fuse/dev.c:1668), 'nbytes' is derived from the user's write request. This value flows to 'fuse_notify' (fs/fuse/dev.c:1587) as 'nbytes - sizeof(oh)', then to 'fuse_notify_inval_entry' (fs/fuse/dev.c:1362). The missing check in the latter function allowed an attacker to supply a malicious 'size' value, leading to a buffer overread. The patch introduces a validation to ensure the size matches the expected structure size.",https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae
CVE-2021-3410,,,"caca/canvas.c:376-385: Integer overflow in `width * height` calculation during canvas resizing. This causes `realloc` for `chars` and `attrs` arrays to allocate insufficient memory in `caca_resize()` (caca/canvas.c:406-407, 413-414). Subsequent writes to these undersized buffers (e.g., via `caca_put_char`) result in a buffer overflow. Triggered by `_import_text`/`_import_ansi` (text.c) passing large dimensions to `caca_set_canvas_size()` (caca/canvas.c:212-228).",https://github.com/cacalabs/libcaca/commit/a5b732fca8dbb499d9bd27cf3083509a4f27acf1
CVE-2016-10027,,,"The original TLS check in `afterFeaturesReceived()` (XMPPTCPConnection.java:1422) was executed during feature parsing, which occurs before TLS negotiation completion. This allowed attackers to manipulate server responses (e.g., stripping `starttls`) before enforcement. The patch moves the check to `connect()` (AbstractXMPPConnection.java:374), ensuring enforcement after connection establishment and SASL authentication. The call chain is: `connect()` → `afterFeaturesReceived()` (via `parseFeatures()` in `AbstractXMPPConnection.java:1348`), but the check was moved to post-SASL in `connect()`.",https://github.com/igniterealtime/Smack/commit/a9d5cd4a611f47123f9561bc5a81a4555fe7cb04
CVE-2018-1000879,,,"In libarchive/archive_acl.c:1726, *s is dereferenced without validating that field[n].start/end are non-NULL or that len > 0. Malformed ACLs can set field[n].start/end to NULL (as observed in GDB output), leading to a NULL dereference when len == 0. The patch adds a check for len == 0 at line 1724 to skip invalid fields.",https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175
CVE-2019-13617,,,"1. Malformed regex parsing in `njs_regexp_literal` (src/njs_regexp.c:334-360) allows `p` to exceed `lexer->end`, leading to invalid pointer dereference.\n2. Error handling triggers `njs_parser_lexer_error` (src/njs_parser.c:2329-2343), which calls `njs_parser_scope_error` (src/njs_parser.c:2296-2326).\n3. `njs_parser_scope_error` formats error messages using `njs_vsprintf` (src/njs_sprintf.c:83-426) with unsafe format specifiers (`%s`, `%V`).\n4. If arguments to `njs_vsprintf` (e.g., unterminated strings) are invalid, the loop in `njs_vsprintf` (lines 135-142, 83-426) reads beyond allocated buffers, causing a heap-based buffer over-read.",https://github.com/nginx/njs/commit/ee400ea880dc46bb02c4be2564b183c114d4cd42
CVE-2016-7466,,,"hw/usb/hcd-xhci.c:3716-3718: Original code called `memory_region_del_subregion()` but did not free `dev->msix_table` and `dev->msix_pba`. The patch replaces this with `msix_uninit(dev, &xhci->mem, &xhci->mem)`, which in `hw/pci/msix.c:372-390` calls `g_free(dev->msix_table)` and `g_free(dev->msix_pba)`, thus resolving the leak.",https://github.com/qemu/qemu/commit/b53dd4495ced2432a0b652ea895e651d07336f7e
CVE-2017-14175,,,"The `ReadXBMImage()` loop (coders/xbm.c:347, 355) processes XBM data without real-time EOF validation. The `XBMInteger()` function (coders/xbm.c:134-169) returns `0` on EOF instead of propagating the EOF condition as a negative value (since it returns `unsigned int`). This allows crafted XBM files with oversized headers and insufficient data to trigger infinite loops. The `c < 0` check in the loop (patched code) fails to detect EOF because `XBMInteger()` returns `0`, and the post-loop `EOFBlob()` check (MagickCore/blob.c:975-1023) is executed after CPU exhaustion occurs.",https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c
CVE-2019-25028,,,"1. Unsanitized input in `Grid.setHeaderCaption` (compatibility-server/Grid.java:3470-3484) and `Grid.Column.setCaption` (server/Grid.java:59) stored `caption` in `state.headerCaption`.\n2. `updateHeader` (client/Grid.java:5009-5017) retrieved `state.headerCaption` and passed it to `setText(caption)`.\n3. Server-side `setText` (compatibility-server/Grid.java:3478) used `setInnerText`, which safely escapes HTML. Prior to the patch, unsanitized input could have been rendered via unsafe client-side DOM insertion (e.g., `innerHTML`).\n4. Patches added `Jsoup.parse().text()` to sanitize input, ensuring only text is rendered.",https://github.com/vaadin/framework/commit/c40bed109c3723b38694ed160ea647fef5b28593
CVE-2022-0443,,,"1. In buffer.c:2289-2293, explicit `vim_free` without `VIM_CLEAR` left `b_p_vsts_array` as a dangling pointer after buffer wipe (:bwipe). 2. In buffer.c:1765-1771, `set_curbuf` failed to handle invalid buffers (e.g., autocommands deleting buffers), leading to potential use-after-free. Patch introduces `valid = buf_valid(buf)` and uses `VIM_CLEAR` to nullify pointers, preventing access to freed memory.",https://github.com/vim/vim/commit/9b4a80a66544f2782040b641498754bcb5b8d461
CVE-2017-11143,,,"In ext/wddx/wddx.c:800-807, ent.data was only allocated inside the if (atts) block. When attributes were absent, the else block executed ZVAL_FALSE(&ent.data) on an uninitialized zval, causing an invalid free during WDDX deserialization of empty boolean elements. The patch moves allocation before the if (atts) check.",https://github.com/php/php-src/commit/2aae60461c2ff7b7fbcdd194c789ac841d0747d7
CVE-2019-3552,,,"['In `thrift/lib/cpp2/protocol/Protocol.h`, the `skip` function had a `default:` case that silently returned on invalid types (before patch).', 'Malicious clients could send containers (e.g., lists/maps) with unknown types, causing the `skip` function to loop through all elements without processing, leading to excessive CPU usage (CVE-2019-3552).', 'The patch replaces the silent return with `TProtocolException::throwInvalidSkipType(arg_type)`, terminating processing immediately upon encountering invalid types.', 'Callers like `thrift/contrib/thrift_dump.cpp::main` (lines 91, 99) use `tap.skip(T_STRUCT)` in loops, which would previously silently process invalid data but now throw an exception, breaking the loop.', 'Other callers (e.g., `TBinaryAsyncChannel.cpp::tryReadUnframed`, line 55) catch `TTransportException`, but the patched `TProtocolException` may not be caught in all paths, though the vulnerability itself is resolved by preventing the long loop.']",https://github.com/facebook/fbthrift/commit/c5d6e07588cd03061bc54d451a7fa6e84883d62b
CVE-2020-35979,,,"Zero-sized `nalu_size` in `gp_rtp_builder_do_avc(src/ietf/rtp_pck_mpeg4.c:402-536)` bypasses validation, leading to malformed RTP packets. The patch in `isom_hinter.c:795-801` prevents zero-sized data from reaching `gf_rtp_builder_process(src/ietf/rtp_packetizer.c:87-130)`, which dispatches to `gp_rtp_builder_do_avc()`. The overflow occurs when `OnData()` processes unbounded or invalid sizes.",https://github.com/gpac/gpac/commit/b15020f54aff24aaeb64b80771472be8e64a7adc
CVE-2017-2630,,,"The vulnerability arises from the incorrect comparison `sizeof(small) < size` in `drop_sync` (nbd/client.c:95), which uses a stack-allocated `small[1024]` buffer when `size > 1024`. This leads to overflow during `read_sync()`. The `size` parameter originates from `reply.length` in `nbd_receive_list` (nbd/client.c:337, 353), which is derived from NBD server responses. The `reply.length` is read via `nbd_receive_option_reply` (nbd/client.c:169-198) without validation of its value beyond magic/option checks, allowing malicious servers to set arbitrary lengths.",https://github.com/qemu/qemu/commit/2563c9c6b8670400c48e562034b321a7cf3d9a85
CVE-2020-35963,,,"The root cause lies in the fixed buffer size calculation `out_size = in_len + 32` in `src/flb_gzip.c:L78`, which fails to account for RFC 1951's worst-case 5-byte expansion per 32KB of input. This results in an out-of-bounds write during compression. The patch replaces this with a dynamic calculation (`src/flb_gzip.c:L85-93`) based on input length and expansion ratios. The vulnerable `in_len` is passed from callers like `datadog.c:L335` (`payload_size`), which derives from `datadog_format` (called with `data` and `bytes` from `cb_datadog_flush`). These values are ultimately user-controlled input data processed by Fluent Bit's input plugins.",https://github.com/fluent/fluent-bit/commit/cadff53c093210404aed01c4cf586adb8caa07af
CVE-2016-2554,,,"In `ext/phar/tar.c:476-477`, `strlen(hdr->linkname)` is used without bounds checking. The `hdr` structure (pointing to `buf[512]`) contains a `linkname` field of fixed size (100 bytes in TAR format). A crafted TAR archive could omit the null-terminator in `linkname`, causing `strlen` to read beyond the allocated buffer on the stack. The patch introduces `linkname_len = strnlen(hdr->linkname, 100)` and uses `estrndup(hdr->linkname, linkname_len)` to enforce a 100-byte bound.",https://github.com/php/php-src/commit/07c7df68bd68bbe706371fccc77c814ebb335d9e
CVE-2019-18423,,,"The root cause was that p2m_set_entry (xen/arch/arm/p2m.c:1049-1053) updated p2m->max_mapped_gfn using the original GFN without masking unused top bits. This allowed a malicious guest to set max_mapped_gfn to a value that would later trigger p2m_get_root_pointer (xen/arch/arm/p2m.c:230-243) to return NULL for a GFN with non-zero top bits. Functions like p2m_get_entry (xen/arch/arm/p2m.c:403-408) assumed the root table was valid if the GFN was <= max_mapped_gfn, leading to a BUG_ON() and DoS. The patch fixes this by validating top bits and correcting range calculations.",https://github.com/xen-project/xen/commit/88aaf40eeff771c546ad3bbb02000171648a89f7
CVE-2019-18792,,,"['Malformed packets with non-zero ACK fields and no ACK flag (e.g., fake FIN packets) were processed instead of being rejected (src/stream-tcp.c:4804).', 'The patch adds a check in `StreamTcpPacket` (src/stream-tcp.c:4804) to trigger `goto error;` for such packets.', 'The `error` label in `StreamTcpPacket` (lines 4954-4957) handles packet rejection by calling `PACKET_DROP(p);` if inline drop is enabled, terminating further processing.', 'This prevents fake FIN packets from overlapping with legitimate packets, closing the evasion vector.']",https://github.com/OISF/suricata/commit/fa692df37a796c3330c81988d15ef1a219afc006
CVE-2019-20094,,,"In gif_init_frame (src/fromgif.c), integer overflow occurred during allocation size calculations (e.g., ncolors * 3). This caused sixel_allocator_malloc() to allocate insufficient memory (line 180, 201, 237), leading to heap-based buffer overflow when writing to the buffer. The patch introduces size_t variables (palette_size, frame_size) to prevent overflow by using unsigned arithmetic.",https://github.com/saitoha/libsixel/commit/a18b3789cfd147028403c17fe79a43b169d8f034
CVE-2018-1000204,,,"In `drivers/scsi/sg.c:1894`, `alloc_pages()` was called without `__GFP_ZERO`, leaving allocated pages with uninitialized data. When these pages were used in SG_IO ioctl handling (with empty commands), the uninitialized memory was copied to userspace. The patch ensures pages are zero-initialized at allocation, eliminating the leak.",https://github.com/torvalds/linux/commit/a45b599ad808c3c982fdcdc12b0b8611c2f92824
CVE-2011-2906,,,"In `pmcraid_ioctl_passthrough()` (drivers/scsi/pmcraid.c:3871), `request_size` is assigned from user-controlled `buffer->ioarcb.data_transfer_length` without validation. Before the patch, negative `request_size` values were passed to `pmcraid_build_passthrough_ioadls()` (drivers/scsi/pmcraid.c:3646), which calls `pmcraid_alloc_sglist()` (drivers/scsi/pmcraid.c:3334) with the negative size. This leads to incorrect `num_elem` calculations (e.g., integer underflow/overflow), resulting in excessive `alloc_pages()` calls or undersized `kzalloc()` allocations, causing memory corruption or OOM.",https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d
CVE-2020-24213,,,"1. User-controlled 'packet_len' is parsed in 'NetServer::ServerEchoRead' (gframe/netserver.cpp:126) from packet headers without validation. 2. 'packet_len' is passed as 'len' to 'NetServer::HandleCTOSPacket' (gframe/netserver.cpp:200), then as 'len - 1' to 'duel_mode->UpdateDeck'. 3. In 'TagDuel::UpdateDeck' and 'SingleDuel::UpdateDeck' (gframe/tag_duel.cpp:19, gframe/single_duel.cpp:19), the original unchecked sum of 'mainc + sidec' could overflow when converted to unsigned integers. The patch adds individual and combined checks against 'possibleMaxLength = (len - 8)/4'. 4. If 'len' is maliciously large (e.g., via oversized 'packet_len'), 'possibleMaxLength' could exceed the actual buffer size, allowing 'mainc'/'sidec' to reference out-of-bounds memory during subsequent operations.",https://github.com/Fluorohydride/ygopro/commit/3587d3bc009ea28eab68cb9ba86a442a4f3c7a3f
CVE-2017-11728,,,"In decompile.c:865-871, OpCode accesses actions[n] without validating n < 1. This is triggered by decompileAction (util/decompile.c:3135-3141) processing SWF action records, where 'n' is derived from untrusted SWF action offsets. For readBytes (util/read.c:228-236), negative 'size' values from SWF parsing (e.g., parseSWF_DEFINEBITS in util/parser.c:1480) could cause undersized buffer allocation. The patch adds n < 1 and size < 0 checks to prevent out-of-bounds access.",https://github.com/libming/libming/commit/2027b24f403a859016a70bbdc79a8da1d6f128eb
CVE-2015-7499,,,"parser.c:2074-2081 (xmlGROW) lacked bounds checks for ctxt->input->cur after buffer reallocation via xmlParserInputGrow (parserInternals.c:295-345). When xmlGROW is called (e.g., by xmlParseCharRef in parser.c:2256), xmlParserInputGrow may reallocate the buffer and adjust ctxt->input->cur. If cur fell outside [base, end] due to invalid input or reallocation logic, subsequent memory accesses would overflow. The patch adds validation to ensure cur remains within bounds.",https://github.com/GNOME/libxml2/commit/35bcb1d758ed70aa7b257c9c3b3ff55e54e3d0da
CVE-2013-7019,,,"In get_cox, s->reduction_factor was not validated against c->nreslevels, allowing values that cause c->nreslevels2decode = c->nreslevels - s->reduction_factor to produce invalid indices (libavcodec/jpeg2000dec.c:371+). The patch introduces a bounds check to enforce s->reduction_factor < c->nreslevels, preventing out-of-bounds array access.",https://github.com/FFmpeg/FFmpeg/commit/a1b9004b768bef606ee98d417bceb9392ceb788d
CVE-2018-7866,,,"The root cause is `getString` returning `act->p.String` (util/decompile.c:398) for PUSH_VARIABLE without checking for NULL. This NULL pointer is passed to `newVar3` in `decompileArithmeticOp` (util/decompile.c:1124-1126), which uses `strlen(var)` (util/decompile.c:584) on the NULL value, causing a dereference and crash. The patch adds a NULL check and returns a copied string instead.",https://github.com/libming/libming/commit/0aab70a3020dd8b4fad66b20995fc691f24a0317
CVE-2019-12790,,,"libr/egg/egg_lang.c:1221-1418: `r_egg_lang_parsechar` writes to `egg->lang.elem[egg->lang.elem_n++]` without validating that `elem_n` remains within the bounds of the statically allocated buffer `egg->lang.elem`. This allows an attacker to supply input that increments `elem_n` beyond the buffer size, causing a heap-based buffer over-read. The patch in `libr/egg/egg.c:343-347` adds a pre-call check in `r_egg_compile`, but it cannot prevent overflows that occur during `r_egg_lang_parsechar`'s execution (e.g., writing to `elem[elem_n]` after incrementing).",https://github.com/radareorg/radare2/commit/e710401ebb4a892a87b0c709d709af8b5dcbbb01
CVE-2017-9732,,,"In `read_packet`, memory allocated via `malloc` (bin/gssstdio.c:507) was not freed on error paths (e.g., EOF, read failures, oversized packet length). When triggered during authentication (via `gstd_accept` in bin/gssstdio.c:211, 213), this leak allowed remote attackers to exhaust memory by repeatedly sending malformed packets. The patch adds a `bail` label (bin/gssstdio.c:545-549) to ensure `tmpbuf` is freed before returning -1. Additionally, `gstd_accept` now releases GSSAPI buffers (bin/gssstdio.c:221, 224) to prevent related leaks.",https://github.com/elric1/knc/commit/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1
CVE-2021-32765,,,"In `hiredis.c`, the original code failed to validate that `elements` would not cause an overflow in `elements * sizeof(redisReply*)`. This led to a potential buffer overflow when `hi_calloc()` allocated insufficient memory. The added check in the patch prevents this by rejecting invalid `elements` values before allocation.",https://github.com/redis/hiredis/commit/76a7b10005c70babee357a7d0f2becf28ec7ed1e
CVE-2020-15563,,,"In `shadow_track_dirty_vram`, the conditional `if (!mfn_eq(mfn, INVALID_MFN))` was inverted. This caused invalid MFNs (which should trigger safety checks) to be treated as valid, leading to `mfn_to_page(mfn)` being called on an unmapped MFN. The inversion allowed invalid pointer dereference, triggering a hypervisor crash.",https://github.com/xen-project/xen/commit/23a216f99d40fbfbc2318ade89d8213eea6ba1f8
CVE-2019-18197,,,"In `libxslt/transform.c:1095`, `xsltCopyText` sets `ctxt->lasttext = copy->content;` during CDATA section processing but did not reset it in all code paths. If the memory referenced by `ctxt->lasttext` is later freed and reused, subsequent operations using this pointer (e.g., bounds checks) could access invalid memory. The patch adds `ctxt->lasttext = NULL;` in the CDATA case to prevent this. However, similar logic in other branches (e.g., normal text node creation) may also require explicit NULL resets if the associated memory is freed, though this is not confirmed here due to limited context.",https://github.com/GNOME/libxslt/commit/2232473733b7313d67de8836ea3b29eec6e8e285
CVE-2023-46928,,,"The SEGV in `gf_media_change_pl` (src/media_tools/isom_tools.c:3293) occurs when `avcc` (retrieved via `gf_isom_avc_config_get`) is null. The function `gf_isom_avc_config_get` (src/isomedia/avc_ext.c:2321-2335) returns null if: (1) the track is invalid, (2) the DescriptionIndex is out-of-bounds, (3) the track's media type is not video, or (4) `entry->avc_config` is null. Dereferencing the null `avcc` in `avcc->AVCLevelIndication` triggers the crash. The patch adds a null check to prevent this.",https://github.com/gpac/gpac/commit/0753bf6d867343a80a044bf47a27d0b7accc8bf1
CVE-2016-6835,,,"In hw/net/vmxnet_tx_pkt.c:179-183, the function vmxnet_tx_pkt_parse_headers sets l3_hdr->iov_len via IP_HDR_GET_LEN but did not validate it against sizeof(struct ip_header). This allowed crafted packets with insufficient IHL to reach ((struct ip_header *) l3_hdr->iov_base)->ip_p, causing OOB access. The patch (added check) ensures the header length is valid before proceeding.",https://github.com/qemu/qemu/commit/93060258ae748573ca7197204125a2670047896d
CVE-2019-14323,,,Original buffer size (MAX_PKT_SIZE) was insufficient to hold NUL terminator after recvfrom (ssdpd.c:435). Writing buf[len] = 0 caused a 1-byte stack overflow when len == MAX_PKT_SIZE. Patch resolves this by increasing buffer size and adjusting recvfrom read limit.,https://github.com/troglobit/ssdp-responder/commit/ce04b1f29a137198182f60bbb628d5ceb8171765
CVE-2022-38223,,,"In m17n mode, the original code failed to allocate sufficient memory for the plens array to track multibyte character lengths. During backspace handling, writes to plens occurred without verifying buffer size (etc.c:385-387). The patch fixes this by dynamically resizing plens_buffer (etc.c:255-260) before use, preventing OOB writes.",https://github.com/tats/w3m/commit/a40aa8e6387c9a7ee8013dd968298c26728c4966
CVE-2020-22874,,,"Integer overflow in `Jsi_ObjArraySizer` (src/jsiObj.c:416) allowed `nsiz` to exceed `MAX_ARRAY_LIST`, leading to unchecked buffer allocation. The patch adds checks against `interp->maxArrayList`, which is initialized in `jsi_InterpNew` (src/jsiInterp.c:1147) and enforced across array-handling functions.",https://github.com/pcmacdon/jsish/commit/858da537bde4de9d8c92466d5a866505310bc328
CVE-2017-10918,,,"Unvalidated memory allocation failures in `guest_physmap_remove_page()` (xen/arch/x86/mm/p2m.c:1141) allowed guests to trigger unchecked errors during P2M mapping modifications. The patch converts the function to return `int`, and callers like `gnttab_transfer()` (xen/common/grant_table.c:14) and `guest_remove_page()` (xen/common/memory.c:285) now propagate errors, preventing exploitation of allocation failures.",https://github.com/xen-project/xen/commit/a0cce6048d010a30ac82f8db7787bbf9aada64f4
CVE-2021-40346,,,"Missing length checks in `htx_add_header` (include/haproxy/htx.h:467) and `htx_add_trailer` (include/haproxy/htx.h:486) allowed `name.len` and `value.len` to overflow. Specifically:\n1. `name.len` (8-bit field in `blk->info`) could overflow if >255 bytes, corrupting `value.len` (16-bit field).\n2. `h2_make_htx_request` (src/h2.c:389) parses HTTP/2 headers into HTX blocks via `htx_add_header`, which lacked length checks until patched.\n3. A malicious HTTP/2 header (e.g., `Content-Length`) could bypass deduplication checks, enabling smuggling by misaligning request parsing between upstream/downstream servers.",https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95
CVE-2019-1000019,,,"In libarchive/archive_read_support_format_7zip.c:2965, get_uncompressed_data() previously requested only 1 byte via __archive_read_ahead() in 'copy mode', which could be insufficient. This caused 'bytes_avail' to be less than required by header_bytes()'s 'minimum' parameter (set by callers like parse_7zip_uint64 with 1-byte requests). The insufficient data led to crc32() reading invalid memory. The patch uses 'minimum' instead of '1' to ensure sufficient bytes are read. The trigger chain is: header_bytes() (line 2767) → read_stream() (line 3202) → get_uncompressed_data() (line 2965).",https://github.com/libarchive/libarchive/commit/65a23f5dbee4497064e9bb467f81138a62b0dae1
CVE-2018-9132,,,"In getInt (util/decompile.c), the PUSH_REGISTER case accessed regs[act->p.RegisterNumber] without verifying it was non-NULL. Dereferencing this potentially-NULL pointer caused the crash. The patch adds an explicit NULL check (lines 482-492) to prevent this.",https://github.com/libming/libming/commit/dc65ba0497f4c5ca58be2018e2816e72baf63634
CVE-2018-20845,,,"Invalid shifts on `comp->dx`/`comp->dy` (src/lib/openmj2/pi.c:324–331, 223–230) can produce zero or undefined values. These are used in `pi->y % (comp->dy << rpy)` (src/lib/openmj2/pi.c:328, 227), causing division-by-zero. The patch checks `rpx`/`rpy` limits and shift validity before use.",https://github.com/uclouvain/openjpeg/commit/c5bd64ea146162967c29bd2af0cbb845ba3eaaaf
CVE-2012-1909,,,The root cause was the absence of a rule to reject blocks containing transactions that overwrite existing unspent transactions. This was addressed by adding a check in CBlock::ConnectBlock (src/main.cpp:1264) to verify that no transaction in the block has a hash already present in the index with unspent outputs. The CTransaction::DisconnectInputs modification (src/main.cpp:979) ensures that duplicate removal during reorgs does not fail validation when outputs are already spent.,https://github.com/sipa/bitcoin/commit/a206b0ea12eb4606b93323268fc81a4f1f952531
CVE-2024-22862,,,"In 'libavcodec/jpegxl_parser.c:1327', 'ctx->skip += size;' lacks overflow checking, allowing 'ctx->skip' to overflow. This value is used in 'jpegxl_parse' (libavcodec/jpegxl_parser.c:1437) to compute 'ctx->next = ret + ctx->skip;', propagating the overflow. The overflowed 'next' is passed to 'ff_combine_frame' (libavcodec/parser.c:203), where it is used in buffer reallocation and copying operations (e.g., 'av_fast_realloc' with 'next + pc->index'), leading to potential out-of-bounds memory access.",https://github.com/FFmpeg/FFmpeg/commit/ca09d8a0dcd82e3128e62463231296aaf63ae6f7
CVE-2022-4087,,,"In src/net/tls.c:2822-2827, invalid padding (pad_len < 0) triggered an immediate error return. This created a timing discrepancy between valid/invalid padding cases, enabling padding oracle attacks. The patch changes this to pad_len = 0, ensuring MAC validation proceeds with incorrect padding, eliminating the oracle.",https://github.com/ipxe/ipxe/commit/186306d6199096b7a7c4b4574d4be8cdb8426729
CVE-2023-25155,,,"In `t_set.c:666`, `t_zset.c:4290`, and `t_hash.c:1121`, the original code used `getLongFromObjectOrReply` (from `src/object.c:880-894`) to parse user-provided count values without enforcing range constraints. This allowed negative `long` values (e.g., `-2^63`) to be parsed, which, when cast to `unsigned long` (e.g., in `count = (unsigned long) l`), overflowed to a large positive value. This overflow triggered assertions in downstream logic (e.g., memory allocation or iteration). Patches replaced these calls with `getRangeLongFromObjectOrReply` (from `src/object.c:896-907`), restricting values to `[-LONG_MAX, LONG_MAX]` and preventing overflow. Additionally, bounds checks in `zrandmemberCommand` and `hrandfieldCommand` were updated to use `-LONG_MAX/2` instead of `LONG_MIN/2` to avoid overflow in operations like multiplication.",https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619
CVE-2019-12111,,,"In pcpserver.c:179, the function 'copyIPv6IfDifferent' previously allowed a NULL 'src' argument to pass the 'dest != src' check. This resulted in a NULL pointer dereference during memcpy. The patch explicitly requires 'src != NULL' to prevent this.",https://github.com/miniupnp/miniupnp/commit/cb8a02af7a5677cf608e86d57ab04241cf34e24f
