{
    "patch": [
        {
            "func_name": "getString",
            "patch": "--- func_before\n+++ func_after\n@@ -398,7 +398,14 @@\n \tcase 12:\n \tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n \tcase PUSH_VARIABLE: /* VARIABLE */\n-\t\treturn act->p.String;\n+\t\tif (!act->p.String)\n+\t\t{\n+\t\t        SWF_warn(\"WARNING: Call to getString with PUSH_VARIABLE defining NULL string.\\n\");\n+\t\t        break;\n+\t\t}\n+\t\tt=malloc(strlen(act->p.String)+1); /* NULL character */\n+\t\tstrcpy(t,act->p.String);\n+\t\treturn t;\n \tdefault: \n \t\tfprintf (stderr,\"  Can't get string for type: %d\\n\", act->Type);\n \t\tbreak;",
            "file_path": "util/decompile.c"
        }
    ],
    "description": "A NULL pointer dereference was discovered in newVar3 in util/decompile.c in libming 0.4.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.",
    "msg": "decompile: fix null pointer dereference in newVar3\n\ngetString (indirectly called by getName) is passed a variable of non\nstandard type 10 (= \"PUSH_VARIABLE\"), which seems to return the\nstring contained in passed variable, without quotes. If contained\nstring is NULL, a NULL pointer is returned, which later causes NULL\npointer dereference.\n\nIn this patch we address this issue such that if the variable contains\nan invalid string, we act just like in the PUSH_STRING case. Otherwise\na copy of the string is returned.\n\nFixes: #118 (CVE-2018-7866).",
    "root_cause": "The root cause is `getString` returning `act->p.String` (util/decompile.c:398) for PUSH_VARIABLE without checking for NULL. This NULL pointer is passed to `newVar3` in `decompileArithmeticOp` (util/decompile.c:1124-1126), which uses `strlen(var)` (util/decompile.c:584) on the NULL value, causing a dereference and crash. The patch adds a NULL check and returns a copied string instead.",
    "confidence_score": 0.95,
    "enriched_data": [
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'getString', 'project_dir': './storage/result/Part2_result/github/CVE-2018-7866/old_repos/libming-libming_efc75c2'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 475,
                    "call_code": "getString(act)",
                    "caller_code": "static char *\ngetName(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n\n\tswitch( act->Type ) \t\n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(act->p.String)) /* Not a zero length string */\n\t\t{\n\t\t        t=malloc(strlen(act->p.String)+3);\n\t\t        strcpyext(t,act->p.String);\n\t\t        return t;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *return_string = \"this\";\n\t                t=malloc(strlen(return_string)+1); /* string length + \\0 */\n\t                strcpyext(t,return_string);\n\t\t\treturn t;\n\t\t}\n#if 0\n\t  case 4: /* REGISTER */\n\t\tt=malloc(5); /* Rddd */\n  \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n  \t\treturn t;\n#endif\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+1);\n\t\tstrcpyext(t,pool[act->p.Constant8]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}\n",
                    "caller_start": 412,
                    "file_path": "util/decompile.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 743,
                    "call_code": "getString(pop())",
                    "caller_code": "static struct SWF_ACTIONPUSHPARAM *\nnewVar_N(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops=getString(pop());\n\t\twhile ( strlen(v->p.String)+ 2 + strlen(pops) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}",
                    "caller_start": 726,
                    "file_path": "util/decompile.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 777,
                    "call_code": "getString(pop())",
                    "caller_code": "static struct SWF_ACTIONPUSHPARAM *\nnewVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}",
                    "caller_start": 760,
                    "file_path": "util/decompile.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 871,
                    "call_code": "getString(act)",
                    "caller_code": "static void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\n{\n\tchar *t;\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif( wantstring ) printf (\"'%s'\", act->p.String);\n\t\telse printf (\"%s\", act->p.String);\n\t\tbreak;\n\tcase PUSH_FLOAT: /* FLOAT */\n\t\tprintf (\"%f\", act->p.Float);\n\t\tbreak;\n\tcase PUSH_NULL: /* NULL */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase PUSH_UNDEF: /* Undefined */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase PUSH_REGISTER: /* Register */\n\t\tif( regs[act->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(act));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)act->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tprintf (\"%s\", act->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\tprintf (\"%g\", act->p.Double);\n\t\tbreak;\n\tcase PUSH_INT: /* INTEGER */\n\t\tprintf (\"%ld\", act->p.Integer);\n\t\tbreak;\n\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif( wantstring ) t=getString(act);\n\t  \telse t=getName(act);\n\t  \tputs(t);  \n\t  \tfree(t);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\tprintf (\"%s\", act->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", act->Type);\n\t}\n}\n",
                    "caller_start": 833,
                    "file_path": "util/decompile.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1124,
                    "call_code": "getString(left)",
                    "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                    "caller_start": 1107,
                    "file_path": "util/decompile.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1124,
                    "call_code": "getString(right)",
                    "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                    "caller_start": 1107,
                    "file_path": "util/decompile.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1126,
                    "call_code": "getString(left)",
                    "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                    "caller_start": 1107,
                    "file_path": "util/decompile.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1126,
                    "call_code": "getString(right)",
                    "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                    "caller_start": 1107,
                    "file_path": "util/decompile.c"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_file_name({'file_path': 'util/decompile.c', 'func_name': 'newVar3', 'project_dir': './storage/result/Part2_result/github/CVE-2018-7866/old_repos/libming-libming_efc75c2'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "struct SWF_ACTIONPUSHPARAM *\nnewVar3(char *var,char *var2, char *var3)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; /* VARIABLE */\n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\treturn v;\n}",
                    "start_line": 580,
                    "end_line": 592,
                    "full_name": "newVar3",
                    "file_path": "util/decompile.c"
                }
            ]
        }
    ],
    "analysis": {
        "patch": [
            {
                "func_name": "getString",
                "patch": "--- func_before\n+++ func_after\n@@ -398,7 +398,14 @@\n \tcase 12:\n \tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n \tcase PUSH_VARIABLE: /* VARIABLE */\n-\t\treturn act->p.String;\n+\t\tif (!act->p.String)\n+\t\t{\n+\t\t        SWF_warn(\"WARNING: Call to getString with PUSH_VARIABLE defining NULL string.\\n\");\n+\t\t        break;\n+\t\t}\n+\t\tt=malloc(strlen(act->p.String)+1); /* NULL character */\n+\t\tstrcpy(t,act->p.String);\n+\t\treturn t;\n \tdefault: \n \t\tfprintf (stderr,\"  Can't get string for type: %d\\n\", act->Type);\n \t\tbreak;",
                "file_path": "util/decompile.c"
            }
        ],
        "msg": "decompile: fix null pointer dereference in newVar3\n\ngetString (indirectly called by getName) is passed a variable of non\nstandard type 10 (= \"PUSH_VARIABLE\"), which seems to return the\nstring contained in passed variable, without quotes. If contained\nstring is NULL, a NULL pointer is returned, which later causes NULL\npointer dereference.\n\nIn this patch we address this issue such that if the variable contains\nan invalid string, we act just like in the PUSH_STRING case. Otherwise\na copy of the string is returned.\n\nFixes: #118 (CVE-2018-7866).",
        "description": "A NULL pointer dereference was discovered in newVar3 in util/decompile.c in libming 0.4.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.",
        "language": "c",
        "vulnerability_type": "memory",
        "repair_strategy": "The patch in util/decompile.c adds a NULL check for `act->p.String` in the `PUSH_VARIABLE` case. If the string is NULL, it logs a warning and breaks instead of returning the invalid pointer. For valid strings, it allocates a copy using `malloc` and `strcpy`, ensuring the returned pointer is non-NULL (lines 398-410).",
        "need_context": false,
        "required_context": [],
        "confidence_score": 0.95,
        "root_cause": "The root cause is `getString` returning `act->p.String` (util/decompile.c:398) for PUSH_VARIABLE without checking for NULL. This NULL pointer is passed to `newVar3` in `decompileArithmeticOp` (util/decompile.c:1124-1126), which uses `strlen(var)` (util/decompile.c:584) on the NULL value, causing a dereference and crash. The patch adds a NULL check and returns a copied string instead.",
        "analysis": "The root cause and trigger chain are fully evidenced. The vulnerability arises when `getString` returns a NULL pointer for a PUSH_VARIABLE, which is then passed to `newVar3` without validation, causing a NULL dereference in `strlen`. The patch addresses this by ensuring a non-NULL string is returned. The chain is: invalid input → `getString` returns NULL (pre-patch) → `decompileArithmeticOp` passes NULL to `newVar3` → `newVar3` dereferences NULL in `strlen`.",
        "attack_vectors": [
            "An attacker crafts a SWF file with a PUSH_VARIABLE action containing a NULL string. This triggers `getString` to return NULL, which is passed to `newVar3`, causing a segmentation fault when `strlen` is called on the NULL pointer."
        ]
    },
    "iteration": 2,
    "history": [
        {
            "stage": "initial",
            "prompt": "You are a senior security engineer. Using **only the provided patch and description**, and **restricted to context retrievable by the 'caller' and 'function' tools**, perform the initial vulnerability analysis.\n\n## INPUTS\n- **Commit Message**: decompile: fix null pointer dereference in newVar3\n\ngetString (indirectly called by getName) is passed a variable of non\nstandard type 10 (= \"PUSH_VARIABLE\"), which seems to return the\nstring contained in passed variable, without quotes. If contained\nstring is NULL, a NULL pointer is returned, which later causes NULL\npointer dereference.\n\nIn this patch we address this issue such that if the variable contains\nan invalid string, we act just like in the PUSH_STRING case. Otherwise\na copy of the string is returned.\n\nFixes: #118 (CVE-2018-7866).\n- **Vulnerability Description**: A NULL pointer dereference was discovered in newVar3 in util/decompile.c in libming 0.4.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.\n- **Patch Code**: [{'func_name': 'getString', 'patch': '--- func_before\\n+++ func_after\\n@@ -398,7 +398,14 @@\\n \\tcase 12:\\n \\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\\n \\tcase PUSH_VARIABLE: /* VARIABLE */\\n-\\t\\treturn act->p.String;\\n+\\t\\tif (!act->p.String)\\n+\\t\\t{\\n+\\t\\t        SWF_warn(\"WARNING: Call to getString with PUSH_VARIABLE defining NULL string.\\\\n\");\\n+\\t\\t        break;\\n+\\t\\t}\\n+\\t\\tt=malloc(strlen(act->p.String)+1); /* NULL character */\\n+\\t\\tstrcpy(t,act->p.String);\\n+\\t\\treturn t;\\n \\tdefault: \\n \\t\\tfprintf (stderr,\"  Can\\'t get string for type: %d\\\\n\", act->Type);\\n \\t\\tbreak;', 'file_path': 'util/decompile.c'}]\n\n## INSTRUCTIONS\n1. **Patch Review**  \n   • Detect primary language (`c`, `cpp`, `java`).  \n   • Classify vulnerability (`memory`, `logic`, `config`).  \n   • Explain how each patch hunk mitigates risk, citing `file:line`.  \n   → Populate `language`, `vulnerability_type`, `repair_rationale`.\n\n2. **Trace Root Cause within Patch**  \n   Follow calls / data flow in the patch, citing `file:line`.  \n   Where evidence ends, insert: `GAP: <why evidence stops>` → build `root_cause`.\n\n3. **Determine Missing Context (tools limited)**  \n   If gaps remain:  \n     • set `\"need_context\": true`  \n     • add precise, non-duplicate requests to `\"required_context\"` using **only**:  \n       - `function: …`  \n       - `caller: …`  \n   If the chain is fully evidenced from the patch, set `\"need_context\": false`.\n\n4. **Confidence Score**  \n   Set `confidence_score ≥ 0.90` only if the full chain is evidenced; otherwise `≤ 0.75`.\n\n## OUTPUT (MUST valid JSON — double quotes, no trailing commas)\n```json\n  {\n      \"language\": \"c | cpp | java\",\n      \"vulnerability_type\": \"memory | logic | config\",\n      \"repair_strategy\": \"<citing file:line from the patch>\",\n      \"analysis\": \"<Synthesis from Process Step 2. If full chain evident, explain that. If context needed, explain why requested context is essential to bridge gaps.>\",\n      \"need_context\": true | false, //false ONLY IF the full pattern was unambiguously evident from patch alone.\n      \"required_context\": \"<list of precise context requests if any context needed>\" ,\n      \"root_cause\": \"\"<Partial/complete trace with file:line evidence from the patch, noting gaps. If full chain evident, provide it.>\",\n      \"confidence_score\": 0.0-1.0 // Confidence in understanding the *full* path based on *this initial analysis phase*\n  }\n  ```\n\n## RULES\n* **Output must be valid JSON (no trailing commas).**\n* **Source-of-Truth** – Cite only code visible in the patch (`file:line`). Commit message / description are auxiliary.\n* **Zero-Assumption** – Never infer. Missing evidence → declare GAP, set `need_context=true`, and request context with allowed tools.\n* **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n* **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "language": "c",
                "vulnerability_type": "memory",
                "repair_strategy": "The patch in util/decompile.c adds a NULL check for `act->p.String` in the `PUSH_VARIABLE` case. If the string is NULL, it logs a warning and breaks instead of returning the invalid pointer. For valid strings, it allocates a copy using `malloc` and `strcpy`, ensuring the returned pointer is non-NULL (lines 398-410).",
                "analysis": "The original vulnerability occurred when `getString` returned a NULL pointer for `PUSH_VARIABLE` type, leading to a dereference in downstream code. The patch mitigates this by: (1) Adding a NULL check for `act->p.String`, and (2) Returning a copied string instead of the raw pointer. However, the full trace requires understanding where `getString` is called (e.g., `getName`) and how its return value is used, which is not fully visible in the provided context.",
                "need_context": true,
                "required_context": [
                    "caller: getString"
                ],
                "root_cause": "The root cause lies in `getString` returning `act->p.String` for `PUSH_VARIABLE` without validating it is non-NULL (util/decompile.c:398). If this value was NULL, subsequent code would dereference it, causing a crash. The patch explicitly checks for NULL and avoids returning an invalid pointer.",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:23:47.937846"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: getString"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'getString', 'project_dir': './storage/result/Part2_result/github/CVE-2018-7866/old_repos/libming-libming_efc75c2'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 475,
                            "call_code": "getString(act)",
                            "caller_code": "static char *\ngetName(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n\n\tswitch( act->Type ) \t\n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(act->p.String)) /* Not a zero length string */\n\t\t{\n\t\t        t=malloc(strlen(act->p.String)+3);\n\t\t        strcpyext(t,act->p.String);\n\t\t        return t;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *return_string = \"this\";\n\t                t=malloc(strlen(return_string)+1); /* string length + \\0 */\n\t                strcpyext(t,return_string);\n\t\t\treturn t;\n\t\t}\n#if 0\n\t  case 4: /* REGISTER */\n\t\tt=malloc(5); /* Rddd */\n  \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n  \t\treturn t;\n#endif\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+1);\n\t\tstrcpyext(t,pool[act->p.Constant8]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}\n",
                            "caller_start": 412,
                            "file_path": "util/decompile.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 743,
                            "call_code": "getString(pop())",
                            "caller_code": "static struct SWF_ACTIONPUSHPARAM *\nnewVar_N(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops=getString(pop());\n\t\twhile ( strlen(v->p.String)+ 2 + strlen(pops) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}",
                            "caller_start": 726,
                            "file_path": "util/decompile.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 777,
                            "call_code": "getString(pop())",
                            "caller_code": "static struct SWF_ACTIONPUSHPARAM *\nnewVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\t\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}",
                            "caller_start": 760,
                            "file_path": "util/decompile.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 871,
                            "call_code": "getString(act)",
                            "caller_code": "static void\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\n{\n\tchar *t;\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif( wantstring ) printf (\"'%s'\", act->p.String);\n\t\telse printf (\"%s\", act->p.String);\n\t\tbreak;\n\tcase PUSH_FLOAT: /* FLOAT */\n\t\tprintf (\"%f\", act->p.Float);\n\t\tbreak;\n\tcase PUSH_NULL: /* NULL */\n\t\tprintf (\"NULL\" );\n\t\tbreak;\n\tcase PUSH_UNDEF: /* Undefined */\n\t\tprintf (\"undefined\" );\n\t\tbreak;\n\tcase PUSH_REGISTER: /* Register */\n\t\tif( regs[act->p.RegisterNumber] ) {\n\t\t\tprintf (\"%s\", getName(act));\n\t\t} else {\n\t\t\tprintf (\"R%d\", (int)act->p.RegisterNumber);\n\t\t}\n\t\tbreak;\n\tcase PUSH_BOOLEAN: /* BOOLEAN */\n\t\tprintf (\"%s\", act->p.Boolean?\"true\":\"false\");\n\t\tbreak;\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\tprintf (\"%g\", act->p.Double);\n\t\tbreak;\n\tcase PUSH_INT: /* INTEGER */\n\t\tprintf (\"%ld\", act->p.Integer);\n\t\tbreak;\n\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif( wantstring ) t=getString(act);\n\t  \telse t=getName(act);\n\t  \tputs(t);  \n\t  \tfree(t);  \n\t  \tbreak;\n\n#if 0\n\t  case 8: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant8]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant8]);\n\t\tbreak;\n\t  case 9: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tif( wantstring )\n  \t\t  printf (\"'%s'\", pool[act->p.Constant16]);\n\t\telse\n  \t\t  printf (\"%s\", pool[act->p.Constant16]);\n\t\tbreak;\n#endif\n\tcase 12:\n\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\n\tcase PUSH_VARIABLE: /* VARIABLE */\n\t\tprintf (\"%s\", act->p.String);\n\t\tbreak;\n\tdefault: \n\t\tprintf (\"  Unknown type: %d\\n\", act->Type);\n\t}\n}\n",
                            "caller_start": 833,
                            "file_path": "util/decompile.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1124,
                            "call_code": "getString(left)",
                            "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                            "caller_start": 1107,
                            "file_path": "util/decompile.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1124,
                            "call_code": "getString(right)",
                            "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                            "caller_start": 1107,
                            "file_path": "util/decompile.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1126,
                            "call_code": "getString(left)",
                            "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                            "caller_start": 1107,
                            "file_path": "util/decompile.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1126,
                            "call_code": "getString(right)",
                            "caller_code": "static int\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *left, *right;\n\tint op_l = OpCode(actions, n, maxn);\n\tint op_r = OpCode(actions, n+1, maxn);\n\tright=pop();\n\tleft=pop();\n\tswitch(OpCode(actions, n, maxn))\n\t{\n\t/*\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompilePUSHPARAM(peek(),0);\n\t\tbreak;\n\t*/\n\tcase SWFACTION_INSTANCEOF:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\" instanceof \",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\" instanceof \",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"+\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"+\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SUBTRACT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"-\",getString(right)));\t      \n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"-\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MULTIPLY:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"*\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"*\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_DIVIDE:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"/\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"/\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_MODULO:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"%\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"%\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTLEFT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_SHIFTRIGHT2:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">>>\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">>>\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LOGICALOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"||\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"||\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEAND:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"&\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"&\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"|\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"|\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_BITWISEXOR:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"^\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"^\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_EQUALS2:\t/* including negation */\n\tcase SWFACTION_EQUAL:\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\n\t\t{\n\t\t\top_r = OpCode(actions, n+1, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESS2:\n\t\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\">=\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\">=\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t}\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_GREATER:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\">\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\">\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_LESSTHAN:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"<\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"<\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGEQ:\n\t\tif (precedence(op_l, op_r))\n\t\t\tpush(newVar3(getString(left),\"==\",getString(right)));\n\t\telse\n\t\t\tpush(newVar_N(\"(\",getString(left),\"==\",getString(right),0,\")\"));\n\t\tbreak;\n\tcase SWFACTION_STRINGCOMPARE:\n\t\tputs(\"STRINGCOMPARE\");\n\t\tbreak;\n\tcase SWFACTION_STRICTEQUALS:\n#ifdef DECOMP_SWITCH\n\t\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\n\t\t{\n\t\t\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\n\t\t\tif(check_switch(code))\n\t\t\t{\n\t\t\t\tpush(right);\t// keep left and right side separated\n\t\t\t\tpush(left);\t// because it seems we have found a switch(){} and\n\t\t\t\tbreak;\t// let decompileIF() once more do all the dirty work\n\t\t\t}\n\t\t}\n#endif\n\t\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\n\t\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \n\t\t{\n\t\t\top_r = OpCode(actions, n+2, maxn);\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"!==\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"!==\",getString(right),0,\")\"));\n\t\t\treturn 1; /* due negation op */\n\t\t} else {\n\t\t\tif (precedence(op_l, op_r))\n\t\t\t\tpush(newVar3(getString(left),\"===\",getString(right)));\n\t\t\telse\n\t\t\t\tpush(newVar_N(\"(\",getString(left),\"===\",getString(right),0,\")\"));\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tprintf(\"Unhandled Arithmetic/Logic OP %x\\n\",\n\t\t\tOpCode(actions, n, maxn));\n\t}\n\treturn 0;\n}\n",
                            "caller_start": 1107,
                            "file_path": "util/decompile.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:24:05.707280"
        },
        {
            "stage": "analysis",
            "iteration": 1,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: decompile: fix null pointer dereference in newVar3\n\ngetString (indirectly called by getName) is passed a variable of non\nstandard type 10 (= \"PUSH_VARIABLE\"), which seems to return the\nstring contained in passed variable, without quotes. If contained\nstring is NULL, a NULL pointer is returned, which later causes NULL\npointer dereference.\n\nIn this patch we address this issue such that if the variable contains\nan invalid string, we act just like in the PUSH_STRING case. Otherwise\na copy of the string is returned.\n\nFixes: #118 (CVE-2018-7866).\n- **Vulnerability Description**: A NULL pointer dereference was discovered in newVar3 in util/decompile.c in libming 0.4.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.\n- **Patch Code**: [{'func_name': 'getString', 'patch': '--- func_before\\n+++ func_after\\n@@ -398,7 +398,14 @@\\n \\tcase 12:\\n \\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\\n \\tcase PUSH_VARIABLE: /* VARIABLE */\\n-\\t\\treturn act->p.String;\\n+\\t\\tif (!act->p.String)\\n+\\t\\t{\\n+\\t\\t        SWF_warn(\"WARNING: Call to getString with PUSH_VARIABLE defining NULL string.\\\\n\");\\n+\\t\\t        break;\\n+\\t\\t}\\n+\\t\\tt=malloc(strlen(act->p.String)+1); /* NULL character */\\n+\\t\\tstrcpy(t,act->p.String);\\n+\\t\\treturn t;\\n \\tdefault: \\n \\t\\tfprintf (stderr,\"  Can\\'t get string for type: %d\\\\n\", act->Type);\\n \\t\\tbreak;', 'file_path': 'util/decompile.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch in util/decompile.c adds a NULL check for `act->p.String` in the `PUSH_VARIABLE` case. If the string is NULL, it logs a warning and breaks instead of returning the invalid pointer. For valid strings, it allocates a copy using `malloc` and `strcpy`, ensuring the returned pointer is non-NULL (lines 398-410).\",\n      \"required_context\": [\n        \"caller: getString\"\n      ],\n      \"root_cause\": \"The root cause lies in `getString` returning `act->p.String` for `PUSH_VARIABLE` without validating it is non-NULL (util/decompile.c:398). If this value was NULL, subsequent code would dereference it, causing a crash. The patch explicitly checks for NULL and avoids returning an invalid pointer.\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:getString)\",\n        \"result\": [\n          {\n            \"call_line\": 475,\n            \"call_code\": \"getString(act)\",\n            \"caller_code\": \"static char *\\ngetName(struct SWF_ACTIONPUSHPARAM *act)\\n{\\n\\tchar *t;\\n\\n\\tswitch( act->Type ) \\t\\n\\t{\\n\\tcase PUSH_STRING: /* STRING */\\n\\t\\tif (!act->p.String) /* Not a NULL string */\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: Call to getName with NULL string.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\telse if (strlen(act->p.String)) /* Not a zero length string */\\n\\t\\t{\\n\\t\\t        t=malloc(strlen(act->p.String)+3);\\n\\t\\t        strcpyext(t,act->p.String);\\n\\t\\t        return t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t        char *return_string = \\\"this\\\";\\n\\t                t=malloc(strlen(return_string)+1); /* string length + \\\\0 */\\n\\t                strcpyext(t,return_string);\\n\\t\\t\\treturn t;\\n\\t\\t}\\n#if 0\\n\\t  case 4: /* REGISTER */\\n\\t\\tt=malloc(5); /* Rddd */\\n  \\t\\tsprintf(t,\\\"R%d\\\", act->p.RegisterNumber );\\n  \\t\\treturn t;\\n#endif\\n\\tcase PUSH_CONSTANT: /* CONSTANT8 */\\n\\t\\tif (act->p.Constant8 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tt=malloc(strlenext(pool[act->p.Constant8])+1);\\n\\t\\tstrcpyext(t,pool[act->p.Constant8]);\\n\\t\\tif(strlen(t)) /* Not a zero length string */\\n\\t\\t\\treturn t;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tt=realloc(t,6);\\n\\t\\t\\treturn strcpy(t,\\\"this\\\");\\n\\t\\t}\\n\\tcase PUSH_CONSTANT16: /* CONSTANT16 */\\n\\t\\tif (act->p.Constant16 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tt=malloc(strlenext(pool[act->p.Constant16])+1);\\n\\t\\tstrcpyext(t,pool[act->p.Constant16]);\\n\\t\\tif(strlen(t)) /* Not a zero length string */\\n\\t\\t\\treturn t;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tt=realloc(t,6);\\n\\t\\t\\treturn strcpy(t,\\\"this\\\");\\n\\t\\t}\\n\\tdefault: \\n\\t\\treturn getString(act);\\n\\t}\\n\\n\\tt = malloc(sizeof(char));\\n\\tstrcpyext(t,\\\"\\\");\\n\\n\\treturn t;\\n}\\n\",\n            \"caller_start\": 412,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 743,\n            \"call_code\": \"getString(pop())\",\n            \"caller_code\": \"static struct SWF_ACTIONPUSHPARAM *\\nnewVar_N(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *v;\\n\\tint psize=PARAM_STRSIZE;\\n\\tint i;\\n\\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\\n\\t\\n\\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\\n\\tv->p.String = malloc(psize + slen);\\n\\tv->Type = PUSH_VARIABLE; \\n\\tstrcpy(v->p.String,var);\\n\\tstrcat(v->p.String,var2);\\n\\tstrcat(v->p.String,var3);\\n\\tstrcat(v->p.String,var4);\\n\\tfor(i=0;i<pop_counter;i++) \\n\\t{\\n\\t\\tchar *pops=getString(pop());\\n\\t\\twhile ( strlen(v->p.String)+ 2 + strlen(pops) +slen >= psize)\\n\\t\\t{\\n\\t\\t\\tpsize += PARAM_STRSIZE;\\n\\t\\t\\tv->p.String = realloc( v->p.String, psize);\\n\\t\\t}\\n\\t\\tstrcat(v->p.String,pops);\\n\\t\\tif( i < pop_counter-1 ) \\n\\t\\t\\tstrcat(v->p.String,\\\",\\\");\\n\\t}\\n\\tstrcat(v->p.String,final);\\n\\treturn v;\\n}\",\n            \"caller_start\": 726,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 777,\n            \"call_code\": \"getString(pop())\",\n            \"caller_code\": \"static struct SWF_ACTIONPUSHPARAM *\\nnewVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *v;\\n\\tint psize=PARAM_STRSIZE;\\n\\tint i;\\n\\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\\n\\t\\n\\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\\n\\tv->p.String = malloc(psize + slen);\\n\\tv->Type = PUSH_VARIABLE; \\n\\tstrcpy(v->p.String,var);\\n\\tstrcat(v->p.String,var2);\\n\\tstrcat(v->p.String,var3);\\n\\tstrcat(v->p.String,var4);\\n\\tfor(i=0;i<pop_counter;i++) \\n\\t{\\n\\t\\tchar *pops1=getString(pop());\\n\\t\\tchar *pops2=getName  (pop());\\n\\n\\t\\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\\n\\t\\t{\\n\\t\\t\\tpsize += PARAM_STRSIZE;\\n\\t\\t\\tv->p.String = realloc( v->p.String, psize);\\n\\t\\t}\\n\\t\\tstrcat(v->p.String,pops2);\\n\\t\\tstrcat(v->p.String,\\\":\\\");\\n\\t\\tstrcat(v->p.String,pops1);\\n\\t\\tif( i < pop_counter-1 ) \\n\\t\\t\\tstrcat(v->p.String,\\\",\\\");\\n\\t}\\n\\tstrcat(v->p.String,final);\\n\\treturn v;\\n}\",\n            \"caller_start\": 760,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 871,\n            \"call_code\": \"getString(act)\",\n            \"caller_code\": \"static void\\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\\n{\\n\\tchar *t;\\n\\tswitch( act->Type ) \\n\\t{\\n\\tcase PUSH_STRING: /* STRING */\\n\\t\\tif( wantstring ) printf (\\\"'%s'\\\", act->p.String);\\n\\t\\telse printf (\\\"%s\\\", act->p.String);\\n\\t\\tbreak;\\n\\tcase PUSH_FLOAT: /* FLOAT */\\n\\t\\tprintf (\\\"%f\\\", act->p.Float);\\n\\t\\tbreak;\\n\\tcase PUSH_NULL: /* NULL */\\n\\t\\tprintf (\\\"NULL\\\" );\\n\\t\\tbreak;\\n\\tcase PUSH_UNDEF: /* Undefined */\\n\\t\\tprintf (\\\"undefined\\\" );\\n\\t\\tbreak;\\n\\tcase PUSH_REGISTER: /* Register */\\n\\t\\tif( regs[act->p.RegisterNumber] ) {\\n\\t\\t\\tprintf (\\\"%s\\\", getName(act));\\n\\t\\t} else {\\n\\t\\t\\tprintf (\\\"R%d\\\", (int)act->p.RegisterNumber);\\n\\t\\t}\\n\\t\\tbreak;\\n\\tcase PUSH_BOOLEAN: /* BOOLEAN */\\n\\t\\tprintf (\\\"%s\\\", act->p.Boolean?\\\"true\\\":\\\"false\\\");\\n\\t\\tbreak;\\n\\tcase PUSH_DOUBLE: /* DOUBLE */\\n\\t\\tprintf (\\\"%g\\\", act->p.Double);\\n\\t\\tbreak;\\n\\tcase PUSH_INT: /* INTEGER */\\n\\t\\tprintf (\\\"%ld\\\", act->p.Integer);\\n\\t\\tbreak;\\n\\n\\tcase PUSH_CONSTANT: /* CONSTANT8 */\\n\\tcase PUSH_CONSTANT16: /* CONSTANT16 */\\n\\t\\tif( wantstring ) t=getString(act);\\n\\t  \\telse t=getName(act);\\n\\t  \\tputs(t);  \\n\\t  \\tfree(t);  \\n\\t  \\tbreak;\\n\\n#if 0\\n\\t  case 8: /* CONSTANT8 */\\n\\t\\tif (act->p.Constant8 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tif( wantstring )\\n  \\t\\t  printf (\\\"'%s'\\\", pool[act->p.Constant8]);\\n\\t\\telse\\n  \\t\\t  printf (\\\"%s\\\", pool[act->p.Constant8]);\\n\\t\\tbreak;\\n\\t  case 9: /* CONSTANT16 */\\n\\t\\tif (act->p.Constant16 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tif( wantstring )\\n  \\t\\t  printf (\\\"'%s'\\\", pool[act->p.Constant16]);\\n\\t\\telse\\n  \\t\\t  printf (\\\"%s\\\", pool[act->p.Constant16]);\\n\\t\\tbreak;\\n#endif\\n\\tcase 12:\\n\\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\\n\\tcase PUSH_VARIABLE: /* VARIABLE */\\n\\t\\tprintf (\\\"%s\\\", act->p.String);\\n\\t\\tbreak;\\n\\tdefault: \\n\\t\\tprintf (\\\"  Unknown type: %d\\\\n\\\", act->Type);\\n\\t}\\n}\\n\",\n            \"caller_start\": 833,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1124,\n            \"call_code\": \"getString(left)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1124,\n            \"call_code\": \"getString(right)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1126,\n            \"call_code\": \"getString(left)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1126,\n            \"call_code\": \"getString(right)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence* ≥ 0.90.  Incomplete chain ≤ 0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth** – Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is confirmed in `getString` returning an unvalidated NULL pointer for `PUSH_VARIABLE`, leading to a dereference in downstream callers. The trigger chain is partially evidenced: (1) Malformed input creates a `PUSH_VARIABLE` with NULL string. (2) `getString` returns NULL without validation (pre-patch). (3) Callers like `decompileArithmeticOp` pass this NULL to `newVar3`, which dereferences it. However, the exact dereference in `newVar3` is not visible in the provided code context, requiring additional function context.",
                "need_context": true,
                "required_context": [
                    "function: newVar3 (util/decompile.c)"
                ],
                "root_cause": "The vulnerability originates in `getString` (util/decompile.c:398) returning `act->p.String` for `PUSH_VARIABLE` without checking for NULL. If `act->p.String` is NULL, this returns a NULL pointer. Callers like `decompileArithmeticOp` (util/decompile.c:1124-1126) pass this result to `newVar3`, which dereferences the NULL pointer, causing a crash. The patch (util/decompile.c:398-410) adds a NULL check and returns a copied string instead.",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:24:52.655980"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: newVar3 (util/decompile.c)"
            ],
            "results": [
                {
                    "tool": "func_info.fetch_func_by_file_name({'file_path': 'util/decompile.c', 'func_name': 'newVar3', 'project_dir': './storage/result/Part2_result/github/CVE-2018-7866/old_repos/libming-libming_efc75c2'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "struct SWF_ACTIONPUSHPARAM *\nnewVar3(char *var,char *var2, char *var3)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; /* VARIABLE */\n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\treturn v;\n}",
                            "start_line": 580,
                            "end_line": 592,
                            "full_name": "newVar3",
                            "file_path": "util/decompile.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:25:03.466954"
        },
        {
            "stage": "analysis",
            "iteration": 2,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: decompile: fix null pointer dereference in newVar3\n\ngetString (indirectly called by getName) is passed a variable of non\nstandard type 10 (= \"PUSH_VARIABLE\"), which seems to return the\nstring contained in passed variable, without quotes. If contained\nstring is NULL, a NULL pointer is returned, which later causes NULL\npointer dereference.\n\nIn this patch we address this issue such that if the variable contains\nan invalid string, we act just like in the PUSH_STRING case. Otherwise\na copy of the string is returned.\n\nFixes: #118 (CVE-2018-7866).\n- **Vulnerability Description**: A NULL pointer dereference was discovered in newVar3 in util/decompile.c in libming 0.4.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.\n- **Patch Code**: [{'func_name': 'getString', 'patch': '--- func_before\\n+++ func_after\\n@@ -398,7 +398,14 @@\\n \\tcase 12:\\n \\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\\n \\tcase PUSH_VARIABLE: /* VARIABLE */\\n-\\t\\treturn act->p.String;\\n+\\t\\tif (!act->p.String)\\n+\\t\\t{\\n+\\t\\t        SWF_warn(\"WARNING: Call to getString with PUSH_VARIABLE defining NULL string.\\\\n\");\\n+\\t\\t        break;\\n+\\t\\t}\\n+\\t\\tt=malloc(strlen(act->p.String)+1); /* NULL character */\\n+\\t\\tstrcpy(t,act->p.String);\\n+\\t\\treturn t;\\n \\tdefault: \\n \\t\\tfprintf (stderr,\"  Can\\'t get string for type: %d\\\\n\", act->Type);\\n \\t\\tbreak;', 'file_path': 'util/decompile.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch in util/decompile.c adds a NULL check for `act->p.String` in the `PUSH_VARIABLE` case. If the string is NULL, it logs a warning and breaks instead of returning the invalid pointer. For valid strings, it allocates a copy using `malloc` and `strcpy`, ensuring the returned pointer is non-NULL (lines 398-410).\",\n      \"required_context\": [\n        \"caller: getString\"\n      ],\n      \"root_cause\": \"The root cause lies in `getString` returning `act->p.String` for `PUSH_VARIABLE` without validating it is non-NULL (util/decompile.c:398). If this value was NULL, subsequent code would dereference it, causing a crash. The patch explicitly checks for NULL and avoids returning an invalid pointer.\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:getString)\",\n        \"result\": [\n          {\n            \"call_line\": 475,\n            \"call_code\": \"getString(act)\",\n            \"caller_code\": \"static char *\\ngetName(struct SWF_ACTIONPUSHPARAM *act)\\n{\\n\\tchar *t;\\n\\n\\tswitch( act->Type ) \\t\\n\\t{\\n\\tcase PUSH_STRING: /* STRING */\\n\\t\\tif (!act->p.String) /* Not a NULL string */\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: Call to getName with NULL string.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\telse if (strlen(act->p.String)) /* Not a zero length string */\\n\\t\\t{\\n\\t\\t        t=malloc(strlen(act->p.String)+3);\\n\\t\\t        strcpyext(t,act->p.String);\\n\\t\\t        return t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t        char *return_string = \\\"this\\\";\\n\\t                t=malloc(strlen(return_string)+1); /* string length + \\\\0 */\\n\\t                strcpyext(t,return_string);\\n\\t\\t\\treturn t;\\n\\t\\t}\\n#if 0\\n\\t  case 4: /* REGISTER */\\n\\t\\tt=malloc(5); /* Rddd */\\n  \\t\\tsprintf(t,\\\"R%d\\\", act->p.RegisterNumber );\\n  \\t\\treturn t;\\n#endif\\n\\tcase PUSH_CONSTANT: /* CONSTANT8 */\\n\\t\\tif (act->p.Constant8 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tt=malloc(strlenext(pool[act->p.Constant8])+1);\\n\\t\\tstrcpyext(t,pool[act->p.Constant8]);\\n\\t\\tif(strlen(t)) /* Not a zero length string */\\n\\t\\t\\treturn t;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tt=realloc(t,6);\\n\\t\\t\\treturn strcpy(t,\\\"this\\\");\\n\\t\\t}\\n\\tcase PUSH_CONSTANT16: /* CONSTANT16 */\\n\\t\\tif (act->p.Constant16 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tt=malloc(strlenext(pool[act->p.Constant16])+1);\\n\\t\\tstrcpyext(t,pool[act->p.Constant16]);\\n\\t\\tif(strlen(t)) /* Not a zero length string */\\n\\t\\t\\treturn t;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tt=realloc(t,6);\\n\\t\\t\\treturn strcpy(t,\\\"this\\\");\\n\\t\\t}\\n\\tdefault: \\n\\t\\treturn getString(act);\\n\\t}\\n\\n\\tt = malloc(sizeof(char));\\n\\tstrcpyext(t,\\\"\\\");\\n\\n\\treturn t;\\n}\\n\",\n            \"caller_start\": 412,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 743,\n            \"call_code\": \"getString(pop())\",\n            \"caller_code\": \"static struct SWF_ACTIONPUSHPARAM *\\nnewVar_N(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *v;\\n\\tint psize=PARAM_STRSIZE;\\n\\tint i;\\n\\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\\n\\t\\n\\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\\n\\tv->p.String = malloc(psize + slen);\\n\\tv->Type = PUSH_VARIABLE; \\n\\tstrcpy(v->p.String,var);\\n\\tstrcat(v->p.String,var2);\\n\\tstrcat(v->p.String,var3);\\n\\tstrcat(v->p.String,var4);\\n\\tfor(i=0;i<pop_counter;i++) \\n\\t{\\n\\t\\tchar *pops=getString(pop());\\n\\t\\twhile ( strlen(v->p.String)+ 2 + strlen(pops) +slen >= psize)\\n\\t\\t{\\n\\t\\t\\tpsize += PARAM_STRSIZE;\\n\\t\\t\\tv->p.String = realloc( v->p.String, psize);\\n\\t\\t}\\n\\t\\tstrcat(v->p.String,pops);\\n\\t\\tif( i < pop_counter-1 ) \\n\\t\\t\\tstrcat(v->p.String,\\\",\\\");\\n\\t}\\n\\tstrcat(v->p.String,final);\\n\\treturn v;\\n}\",\n            \"caller_start\": 726,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 777,\n            \"call_code\": \"getString(pop())\",\n            \"caller_code\": \"static struct SWF_ACTIONPUSHPARAM *\\nnewVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *v;\\n\\tint psize=PARAM_STRSIZE;\\n\\tint i;\\n\\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\\n\\t\\n\\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\\n\\tv->p.String = malloc(psize + slen);\\n\\tv->Type = PUSH_VARIABLE; \\n\\tstrcpy(v->p.String,var);\\n\\tstrcat(v->p.String,var2);\\n\\tstrcat(v->p.String,var3);\\n\\tstrcat(v->p.String,var4);\\n\\tfor(i=0;i<pop_counter;i++) \\n\\t{\\n\\t\\tchar *pops1=getString(pop());\\n\\t\\tchar *pops2=getName  (pop());\\n\\n\\t\\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\\n\\t\\t{\\n\\t\\t\\tpsize += PARAM_STRSIZE;\\n\\t\\t\\tv->p.String = realloc( v->p.String, psize);\\n\\t\\t}\\n\\t\\tstrcat(v->p.String,pops2);\\n\\t\\tstrcat(v->p.String,\\\":\\\");\\n\\t\\tstrcat(v->p.String,pops1);\\n\\t\\tif( i < pop_counter-1 ) \\n\\t\\t\\tstrcat(v->p.String,\\\",\\\");\\n\\t}\\n\\tstrcat(v->p.String,final);\\n\\treturn v;\\n}\",\n            \"caller_start\": 760,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 871,\n            \"call_code\": \"getString(act)\",\n            \"caller_code\": \"static void\\ndecompilePUSHPARAM (struct SWF_ACTIONPUSHPARAM *act, int wantstring)\\n{\\n\\tchar *t;\\n\\tswitch( act->Type ) \\n\\t{\\n\\tcase PUSH_STRING: /* STRING */\\n\\t\\tif( wantstring ) printf (\\\"'%s'\\\", act->p.String);\\n\\t\\telse printf (\\\"%s\\\", act->p.String);\\n\\t\\tbreak;\\n\\tcase PUSH_FLOAT: /* FLOAT */\\n\\t\\tprintf (\\\"%f\\\", act->p.Float);\\n\\t\\tbreak;\\n\\tcase PUSH_NULL: /* NULL */\\n\\t\\tprintf (\\\"NULL\\\" );\\n\\t\\tbreak;\\n\\tcase PUSH_UNDEF: /* Undefined */\\n\\t\\tprintf (\\\"undefined\\\" );\\n\\t\\tbreak;\\n\\tcase PUSH_REGISTER: /* Register */\\n\\t\\tif( regs[act->p.RegisterNumber] ) {\\n\\t\\t\\tprintf (\\\"%s\\\", getName(act));\\n\\t\\t} else {\\n\\t\\t\\tprintf (\\\"R%d\\\", (int)act->p.RegisterNumber);\\n\\t\\t}\\n\\t\\tbreak;\\n\\tcase PUSH_BOOLEAN: /* BOOLEAN */\\n\\t\\tprintf (\\\"%s\\\", act->p.Boolean?\\\"true\\\":\\\"false\\\");\\n\\t\\tbreak;\\n\\tcase PUSH_DOUBLE: /* DOUBLE */\\n\\t\\tprintf (\\\"%g\\\", act->p.Double);\\n\\t\\tbreak;\\n\\tcase PUSH_INT: /* INTEGER */\\n\\t\\tprintf (\\\"%ld\\\", act->p.Integer);\\n\\t\\tbreak;\\n\\n\\tcase PUSH_CONSTANT: /* CONSTANT8 */\\n\\tcase PUSH_CONSTANT16: /* CONSTANT16 */\\n\\t\\tif( wantstring ) t=getString(act);\\n\\t  \\telse t=getName(act);\\n\\t  \\tputs(t);  \\n\\t  \\tfree(t);  \\n\\t  \\tbreak;\\n\\n#if 0\\n\\t  case 8: /* CONSTANT8 */\\n\\t\\tif (act->p.Constant8 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tif( wantstring )\\n  \\t\\t  printf (\\\"'%s'\\\", pool[act->p.Constant8]);\\n\\t\\telse\\n  \\t\\t  printf (\\\"%s\\\", pool[act->p.Constant8]);\\n\\t\\tbreak;\\n\\t  case 9: /* CONSTANT16 */\\n\\t\\tif (act->p.Constant16 > poolcounter)\\n\\t\\t{\\n\\t\\t        SWF_warn(\\\"WARNING: retrieving constants not present in the pool.\\\\n\\\");\\n\\t\\t        break;\\n\\t\\t}\\n\\t\\tif( wantstring )\\n  \\t\\t  printf (\\\"'%s'\\\", pool[act->p.Constant16]);\\n\\t\\telse\\n  \\t\\t  printf (\\\"%s\\\", pool[act->p.Constant16]);\\n\\t\\tbreak;\\n#endif\\n\\tcase 12:\\n\\tcase 11: /* INCREMENTED or DECREMENTED VARIABLE */\\n\\tcase PUSH_VARIABLE: /* VARIABLE */\\n\\t\\tprintf (\\\"%s\\\", act->p.String);\\n\\t\\tbreak;\\n\\tdefault: \\n\\t\\tprintf (\\\"  Unknown type: %d\\\\n\\\", act->Type);\\n\\t}\\n}\\n\",\n            \"caller_start\": 833,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1124,\n            \"call_code\": \"getString(left)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1124,\n            \"call_code\": \"getString(right)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1126,\n            \"call_code\": \"getString(left)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          },\n          {\n            \"call_line\": 1126,\n            \"call_code\": \"getString(right)\",\n            \"caller_code\": \"static int\\ndecompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *left, *right;\\n\\tint op_l = OpCode(actions, n, maxn);\\n\\tint op_r = OpCode(actions, n+1, maxn);\\n\\tright=pop();\\n\\tleft=pop();\\n\\tswitch(OpCode(actions, n, maxn))\\n\\t{\\n\\t/*\\n\\tcase SWFACTION_GETMEMBER:\\n\\t\\tdecompilePUSHPARAM(peek(),0);\\n\\t\\tbreak;\\n\\t*/\\n\\tcase SWFACTION_INSTANCEOF:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\" instanceof \\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\" instanceof \\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_ADD:\\n\\tcase SWFACTION_ADD2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"+\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"+\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SUBTRACT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"-\\\",getString(right)));\\t      \\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"-\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MULTIPLY:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"*\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"*\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_DIVIDE:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"/\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"/\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_MODULO:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"%\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"%\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTLEFT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_SHIFTRIGHT2:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">>>\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">>>\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LOGICALOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"||\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"||\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEAND:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"&\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"&\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"|\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"|\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_BITWISEXOR:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"^\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"^\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_EQUALS2:\\t/* including negation */\\n\\tcase SWFACTION_EQUAL:\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+1, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESS2:\\n\\t\\tif( OpCode(actions, n+1, maxn)  == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\">=\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">=\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t}\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_GREATER:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\">\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\">\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_LESSTHAN:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"<\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"<\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGEQ:\\n\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\tpush(newVar3(getString(left),\\\"==\\\",getString(right)));\\n\\t\\telse\\n\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"==\\\",getString(right),0,\\\")\\\"));\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRINGCOMPARE:\\n\\t\\tputs(\\\"STRINGCOMPARE\\\");\\n\\t\\tbreak;\\n\\tcase SWFACTION_STRICTEQUALS:\\n#ifdef DECOMP_SWITCH\\n\\t\\tif  (OpCode(actions, n, maxn) == SWFACTION_IF)\\n\\t\\t{\\n\\t\\t\\tint code = actions[n+1].SWF_ACTIONIF.Actions[0].SWF_ACTIONRECORD.ActionCode;\\n\\t\\t\\tif(check_switch(code))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpush(right);\\t// keep left and right side separated\\n\\t\\t\\t\\tpush(left);\\t// because it seems we have found a switch(){} and\\n\\t\\t\\t\\tbreak;\\t// let decompileIF() once more do all the dirty work\\n\\t\\t\\t}\\n\\t\\t}\\n#endif\\n\\t\\tif( OpCode(actions, n+1, maxn) == SWFACTION_LOGICALNOT &&\\n\\t\\t    OpCode(actions, n+2, maxn) != SWFACTION_IF ) \\n\\t\\t{\\n\\t\\t\\top_r = OpCode(actions, n+2, maxn);\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"!==\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"!==\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\treturn 1; /* due negation op */\\n\\t\\t} else {\\n\\t\\t\\tif (precedence(op_l, op_r))\\n\\t\\t\\t\\tpush(newVar3(getString(left),\\\"===\\\",getString(right)));\\n\\t\\t\\telse\\n\\t\\t\\t\\tpush(newVar_N(\\\"(\\\",getString(left),\\\"===\\\",getString(right),0,\\\")\\\"));\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\tdefault:\\n\\t\\tprintf(\\\"Unhandled Arithmetic/Logic OP %x\\\\n\\\",\\n\\t\\t\\tOpCode(actions, n, maxn));\\n\\t}\\n\\treturn 0;\\n}\\n\",\n            \"caller_start\": 1107,\n            \"file_path\": \"util/decompile.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"The vulnerability originates in `getString` (util/decompile.c:398) returning `act->p.String` for `PUSH_VARIABLE` without checking for NULL. If `act->p.String` is NULL, this returns a NULL pointer. Callers like `decompileArithmeticOp` (util/decompile.c:1124-1126) pass this result to `newVar3`, which dereferences the NULL pointer, causing a crash. The patch (util/decompile.c:398-410) adds a NULL check and returns a copied string instead.\",\n    \"required_context_next\": [\n      \"function: newVar3 (util/decompile.c)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is confirmed in `getString` returning an unvalidated NULL pointer for `PUSH_VARIABLE`, leading to a dereference in downstream callers. The trigger chain is partially evidenced: (1) Malformed input creates a `PUSH_VARIABLE` with NULL string. (2) `getString` returns NULL without validation (pre-patch). (3) Callers like `decompileArithmeticOp` pass this NULL to `newVar3`, which dereferences it. However, the exact dereference in `newVar3` is not visible in the provided code context, requiring additional function context.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(file:decompile.c, func:newVar3)\",\n        \"result\": [\n          {\n            \"code\": \"struct SWF_ACTIONPUSHPARAM *\\nnewVar3(char *var,char *var2, char *var3)\\n{\\n\\tstruct SWF_ACTIONPUSHPARAM *v;\\n\\n\\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\\n\\tv->Type = PUSH_VARIABLE; /* VARIABLE */\\n\\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+1);\\n\\tstrcpy(v->p.String,var);\\n\\tstrcat(v->p.String,var2);\\n\\tstrcat(v->p.String,var3);\\n\\treturn v;\\n}\",\n            \"start_line\": 580,\n            \"end_line\": 592,\n            \"full_name\": \"newVar3\",\n            \"file_path\": \"util/decompile.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence* ≥ 0.90.  Incomplete chain ≤ 0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth** – Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause and trigger chain are fully evidenced. The vulnerability arises when `getString` returns a NULL pointer for a PUSH_VARIABLE, which is then passed to `newVar3` without validation, causing a NULL dereference in `strlen`. The patch addresses this by ensuring a non-NULL string is returned. The chain is: invalid input → `getString` returns NULL (pre-patch) → `decompileArithmeticOp` passes NULL to `newVar3` → `newVar3` dereferences NULL in `strlen`.",
                "need_context": false,
                "required_context": [],
                "root_cause": "The root cause is `getString` returning `act->p.String` (util/decompile.c:398) for PUSH_VARIABLE without checking for NULL. This NULL pointer is passed to `newVar3` in `decompileArithmeticOp` (util/decompile.c:1124-1126), which uses `strlen(var)` (util/decompile.c:584) on the NULL value, causing a dereference and crash. The patch adds a NULL check and returns a copied string instead.",
                "confidence_score": 0.95,
                "attack_vectors": [
                    "An attacker crafts a SWF file with a PUSH_VARIABLE action containing a NULL string. This triggers `getString` to return NULL, which is passed to `newVar3`, causing a segmentation fault when `strlen` is called on the NULL pointer."
                ]
            },
            "timestamp": "2025-05-26T15:25:37.626698"
        }
    ],
    "debug_trace": [
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 1. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 2. Needs more context: False. Confidence: 0.95",
        "Report generation completed."
    ],
    "status": "completed",
    "error": null
}