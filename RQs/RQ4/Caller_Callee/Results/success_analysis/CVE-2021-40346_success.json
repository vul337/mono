{
    "patch": [
        {
            "func_name": "htx_add_header",
            "patch": "--- func_before\n+++ func_after\n@@ -467,7 +467,9 @@\n {\n \tstruct htx_blk *blk;\n \n-\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n+\tif (name.len > 255 || value.len > 1048575)\n+\t\treturn NULL;\n+\n \tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n \tif (!blk)\n \t\treturn NULL;",
            "file_path": "include/haproxy/htx.h"
        },
        {
            "func_name": "htx_add_trailer",
            "patch": "--- func_before\n+++ func_after\n@@ -486,7 +486,9 @@\n {\n \tstruct htx_blk *blk;\n \n-\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n+\tif (name.len > 255 || value.len > 1048575)\n+\t\treturn NULL;\n+\n \tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n \tif (!blk)\n \t\treturn NULL;",
            "file_path": "include/haproxy/htx.h"
        }
    ],
    "description": "An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.",
    "msg": "BUG/MAJOR: htx: fix missing header name length check in htx_add_header/trailer\n\nOri Hollander of JFrog Security reported that htx_add_header() and\nhtx_add_trailer() were missing a length check on the header name. While\nthis does not allow to overwrite any memory area, it results in bits of\nthe header name length to slip into the header value length and may\nresult in forging certain header names on the input. The sad thing here\nis that a FIXME comment was present suggesting to add the required length\nchecks :-(\n\nThe injected headers are visible to the HTTP internals and to the config\nrules, so haproxy will generally stay synchronized with the server. But\nthere is one exception which is the content-length header field, because\nit is already deduplicated on the input, but before being indexed. As\nsuch, injecting a content-length header after the deduplication stage\nmay be abused to present a different, shorter one on the other side and\nhelp build a request smuggling attack, or even maybe a response splitting\nattack. CVE-2021-40346 was assigned to this problem.\n\nAs a mitigation measure, it is sufficient to verify that no more than\none such header is present in any message, which is normally the case\nthanks to the duplicate checks:\n\n   http-request  deny if { req.hdr_cnt(content-length) gt 1 }\n   http-response deny if { res.hdr_cnt(content-length) gt 1 }\n\nThis must be backported to all HTX-enabled versions, hence as far as 2.0.\nIn 2.3 and earlier, the functions are in src/htx.c instead.\n\nMany thanks to Ori for his work and his responsible report!",
    "root_cause": "Missing length checks in `htx_add_header` (include/haproxy/htx.h:467) and `htx_add_trailer` (include/haproxy/htx.h:486) allowed `name.len` and `value.len` to overflow. Specifically:\\n1. `name.len` (8-bit field in `blk->info`) could overflow if >255 bytes, corrupting `value.len` (16-bit field).\\n2. `h2_make_htx_request` (src/h2.c:389) parses HTTP/2 headers into HTX blocks via `htx_add_header`, which lacked length checks until patched.\\n3. A malicious HTTP/2 header (e.g., `Content-Length`) could bypass deduplication checks, enabling smuggling by misaligning request parsing between upstream/downstream servers.",
    "confidence_score": 0.95,
    "enriched_data": [
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'htx_add_header', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
                    "start_line": 464,
                    "end_line": 478,
                    "full_name": "htx_add_header",
                    "file_path": "include/haproxy/htx.h"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'htx_add_trailer', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
                    "start_line": 483,
                    "end_line": 497,
                    "full_name": "htx_add_trailer",
                    "file_path": "include/haproxy/htx.h"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func_file({'file_path': 'include/haproxy/htx.h', 'func_name': 'htx_add_header', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 522,
                    "call_code": "htx_add_header(htx, hdrs[i].n, hdrs[i].v)",
                    "caller_code": "static inline struct htx_blk *htx_add_all_headers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_header(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOH);\n}",
                    "caller_start": 517,
                    "file_path": "include/haproxy/htx.h"
                },
                {
                    "type": "caller_info",
                    "call_line": 1415,
                    "call_code": "htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\"))",
                    "caller_code": "static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), ist(\"200\"), ist(\"OK\"));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\")) ||\n\t    !htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}",
                    "caller_start": 1404,
                    "file_path": "addons/promex/service-prometheus.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1416,
                    "call_code": "htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\"))",
                    "caller_code": "static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), ist(\"200\"), ist(\"OK\"));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\")) ||\n\t    !htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}",
                    "caller_start": 1404,
                    "file_path": "addons/promex/service-prometheus.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1417,
                    "call_code": "htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\"))",
                    "caller_code": "static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), ist(\"200\"), ist(\"OK\"));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\")) ||\n\t    !htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}",
                    "caller_start": 1404,
                    "file_path": "addons/promex/service-prometheus.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 468,
                    "call_code": "htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH])",
                    "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                    "caller_start": 389,
                    "file_path": "src/h2.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 515,
                    "call_code": "htx_add_header(htx, list[idx].n, list[idx].v)",
                    "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                    "caller_start": 389,
                    "file_path": "src/h2.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 541,
                    "call_code": "htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT])",
                    "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                    "caller_start": 389,
                    "file_path": "src/h2.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 543,
                    "call_code": "htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\"))",
                    "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                    "caller_start": 389,
                    "file_path": "src/h2.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func_file({'file_path': 'include/haproxy/htx.h', 'func_name': 'htx_add_trailer', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 536,
                    "call_code": "htx_add_trailer(htx, hdrs[i].n, hdrs[i].v)",
                    "caller_code": "static inline struct htx_blk *htx_add_all_trailers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_trailer(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOT);\n}",
                    "caller_start": 531,
                    "file_path": "include/haproxy/htx.h"
                },
                {
                    "type": "caller_info",
                    "call_line": 907,
                    "call_code": "htx_add_trailer(htx, list[idx].n, list[idx].v)",
                    "caller_code": "int h2_make_htx_trailers(struct http_hdr *list, struct htx *htx)\n{\n\tconst char *ctl;\n\tuint32_t idx;\n\tint i;\n\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* This is an indexed pseudo-header (RFC7540#8.1.2.1) */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t * #10.3: header names must be valid (i.e. match a token). This\n\t\t * also catches pseudo-headers which are forbidden in trailers.\n\t\t */\n\t\tfor (i = 0; i < list[idx].n.len; i++)\n\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\tgoto fail;\n\n\t\t/* these ones are forbidden in trailers (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"host\")) ||\n\t\t    isteq(list[idx].n, ist(\"content-length\")) ||\n\t\t    isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"te\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (!htx_add_trailer(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOT))\n\t\tgoto fail;\n\n\treturn 1;\n\n fail:\n\treturn -1;\n}\n",
                    "caller_start": 869,
                    "file_path": "src/h2.c"
                }
            ]
        }
    ],
    "analysis": {
        "patch": [
            {
                "func_name": "htx_add_header",
                "patch": "--- func_before\n+++ func_after\n@@ -467,7 +467,9 @@\n {\n \tstruct htx_blk *blk;\n \n-\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n+\tif (name.len > 255 || value.len > 1048575)\n+\t\treturn NULL;\n+\n \tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n \tif (!blk)\n \t\treturn NULL;",
                "file_path": "include/haproxy/htx.h"
            },
            {
                "func_name": "htx_add_trailer",
                "patch": "--- func_before\n+++ func_after\n@@ -486,7 +486,9 @@\n {\n \tstruct htx_blk *blk;\n \n-\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n+\tif (name.len > 255 || value.len > 1048575)\n+\t\treturn NULL;\n+\n \tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n \tif (!blk)\n \t\treturn NULL;",
                "file_path": "include/haproxy/htx.h"
            }
        ],
        "msg": "BUG/MAJOR: htx: fix missing header name length check in htx_add_header/trailer\n\nOri Hollander of JFrog Security reported that htx_add_header() and\nhtx_add_trailer() were missing a length check on the header name. While\nthis does not allow to overwrite any memory area, it results in bits of\nthe header name length to slip into the header value length and may\nresult in forging certain header names on the input. The sad thing here\nis that a FIXME comment was present suggesting to add the required length\nchecks :-(\n\nThe injected headers are visible to the HTTP internals and to the config\nrules, so haproxy will generally stay synchronized with the server. But\nthere is one exception which is the content-length header field, because\nit is already deduplicated on the input, but before being indexed. As\nsuch, injecting a content-length header after the deduplication stage\nmay be abused to present a different, shorter one on the other side and\nhelp build a request smuggling attack, or even maybe a response splitting\nattack. CVE-2021-40346 was assigned to this problem.\n\nAs a mitigation measure, it is sufficient to verify that no more than\none such header is present in any message, which is normally the case\nthanks to the duplicate checks:\n\n   http-request  deny if { req.hdr_cnt(content-length) gt 1 }\n   http-response deny if { res.hdr_cnt(content-length) gt 1 }\n\nThis must be backported to all HTX-enabled versions, hence as far as 2.0.\nIn 2.3 and earlier, the functions are in src/htx.c instead.\n\nMany thanks to Ori for his work and his responsible report!",
        "description": "An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.",
        "language": "c",
        "vulnerability_type": "logic",
        "repair_strategy": "The patch adds explicit length checks for header/trailer name and value lengths in `htx_add_header` and `htx_add_trailer` (file: include/haproxy/htx.h). For example, `if (name.len > 255 || value.len > 1048575) return NULL;` prevents oversized headers/trailers from being processed, mitigating header forgery and smuggling.",
        "need_context": false,
        "required_context": [
            "caller: I need the caller(s) of function htx_add_header in include/haproxy/htx.h",
            "caller: I need the caller(s) of function htx_add_trailer in include/haproxy/htx.h"
        ],
        "confidence_score": 0.95,
        "root_cause": "Missing length checks in `htx_add_header` (include/haproxy/htx.h:467) and `htx_add_trailer` (include/haproxy/htx.h:486) allowed `name.len` and `value.len` to overflow. Specifically:\\n1. `name.len` (8-bit field in `blk->info`) could overflow if >255 bytes, corrupting `value.len` (16-bit field).\\n2. `h2_make_htx_request` (src/h2.c:389) parses HTTP/2 headers into HTX blocks via `htx_add_header`, which lacked length checks until patched.\\n3. A malicious HTTP/2 header (e.g., `Content-Length`) could bypass deduplication checks, enabling smuggling by misaligning request parsing between upstream/downstream servers.",
        "analysis": "The vulnerability stems from missing length checks in `htx_add_header` and `htx_add_trailer`, enabling header/trailer name and value overflows. The root cause is the unchecked `name.len` (stored as 8 bits) and `value.len` (stored as 16 bits) in `blk->info`, which can be manipulated to forge headers like `Content-Length` after deduplication. Attackers exploit HTTP/2 header parsing (via `h2_make_htx_request`) to inject malicious headers, bypassing ACLs and enabling smuggling. The chain is now fully evidenced from HTTP/2 input parsing to HTX block creation.",
        "attack_vectors": [
            "HTTP/2 client sends a header with a name >255 bytes, causing `name.len` overflow in `blk->info` (src/h2.c:515).",
            "Forged `Content-Length` header injected after deduplication, allowing request smuggling by splitting the HTTP message."
        ]
    },
    "iteration": 2,
    "history": [
        {
            "stage": "initial",
            "prompt": "You are a senior security engineer. Using **only the provided patch and description**, and **restricted to context retrievable by the 'caller' and 'function' tools**, perform the initial vulnerability analysis.\n\n## INPUTS\n- **Commit Message**: BUG/MAJOR: htx: fix missing header name length check in htx_add_header/trailer\n\nOri Hollander of JFrog Security reported that htx_add_header() and\nhtx_add_trailer() were missing a length check on the header name. While\nthis does not allow to overwrite any memory area, it results in bits of\nthe header name length to slip into the header value length and may\nresult in forging certain header names on the input. The sad thing here\nis that a FIXME comment was present suggesting to add the required length\nchecks :-(\n\nThe injected headers are visible to the HTTP internals and to the config\nrules, so haproxy will generally stay synchronized with the server. But\nthere is one exception which is the content-length header field, because\nit is already deduplicated on the input, but before being indexed. As\nsuch, injecting a content-length header after the deduplication stage\nmay be abused to present a different, shorter one on the other side and\nhelp build a request smuggling attack, or even maybe a response splitting\nattack. CVE-2021-40346 was assigned to this problem.\n\nAs a mitigation measure, it is sufficient to verify that no more than\none such header is present in any message, which is normally the case\nthanks to the duplicate checks:\n\n   http-request  deny if { req.hdr_cnt(content-length) gt 1 }\n   http-response deny if { res.hdr_cnt(content-length) gt 1 }\n\nThis must be backported to all HTX-enabled versions, hence as far as 2.0.\nIn 2.3 and earlier, the functions are in src/htx.c instead.\n\nMany thanks to Ori for his work and his responsible report!\n- **Vulnerability Description**: An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.\n- **Patch Code**: [{'func_name': 'htx_add_header', 'patch': '--- func_before\\n+++ func_after\\n@@ -467,7 +467,9 @@\\n {\\n \\tstruct htx_blk *blk;\\n \\n-\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n+\\tif (name.len > 255 || value.len > 1048575)\\n+\\t\\treturn NULL;\\n+\\n \\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\\n \\tif (!blk)\\n \\t\\treturn NULL;', 'file_path': 'include/haproxy/htx.h'}, {'func_name': 'htx_add_trailer', 'patch': '--- func_before\\n+++ func_after\\n@@ -486,7 +486,9 @@\\n {\\n \\tstruct htx_blk *blk;\\n \\n-\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n+\\tif (name.len > 255 || value.len > 1048575)\\n+\\t\\treturn NULL;\\n+\\n \\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\\n \\tif (!blk)\\n \\t\\treturn NULL;', 'file_path': 'include/haproxy/htx.h'}]\n\n## INSTRUCTIONS\n1. **Patch Review**  \n    Detect primary language (`c`, `cpp`, `java`).  \n    Classify vulnerability (`memory`, `logic`, `config`).  \n    Explain how each patch hunk mitigates risk, citing `file:line`.  \n    Populate `language`, `vulnerability_type`, `repair_rationale`.\n\n2. **Trace Root Cause within Patch**  \n   Follow calls / data flow in the patch, citing `file:line`.  \n   Where evidence ends, insert: `GAP: <why evidence stops>`  build `root_cause`.\n\n3. **Determine Missing Context (tools limited)**  \n   If gaps remain:  \n      set `\"need_context\": true`  \n      add precise, non-duplicate requests to `\"required_context\"` using **only**:  \n       - `function: `  \n       - `caller: `  \n   If the chain is fully evidenced from the patch, set `\"need_context\": false`.\n\n4. **Confidence Score**  \n   Set `confidence_score  0.90` only if the full chain is evidenced; otherwise ` 0.75`.\n\n## OUTPUT (MUST valid JSON  double quotes, no trailing commas)\n```json\n  {\n      \"language\": \"c | cpp | java\",\n      \"vulnerability_type\": \"memory | logic | config\",\n      \"repair_strategy\": \"<citing file:line from the patch>\",\n      \"analysis\": \"<Synthesis from Process Step 2. If full chain evident, explain that. If context needed, explain why requested context is essential to bridge gaps.>\",\n      \"need_context\": true | false, //false ONLY IF the full pattern was unambiguously evident from patch alone.\n      \"required_context\": \"<list of precise context requests if any context needed>\" ,\n      \"root_cause\": \"\"<Partial/complete trace with file:line evidence from the patch, noting gaps. If full chain evident, provide it.>\",\n      \"confidence_score\": 0.0-1.0 // Confidence in understanding the *full* path based on *this initial analysis phase*\n  }\n  ```\n\n## RULES\n* **Output must be valid JSON (no trailing commas).**\n* **Source-of-Truth**  Cite only code visible in the patch (`file:line`). Commit message / description are auxiliary.\n* **Zero-Assumption**  Never infer. Missing evidence  declare GAP, set `need_context=true`, and request context with allowed tools.\n* **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n* **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "language": "c",
                "vulnerability_type": "logic",
                "repair_strategy": "The patch adds explicit length checks for header/trailer name and value lengths in `htx_add_header` and `htx_add_trailer` (file: include/haproxy/htx.h). For example, `if (name.len > 255 || value.len > 1048575) return NULL;` prevents oversized headers/trailers from being processed, mitigating header forgery and smuggling.",
                "analysis": "The patch addresses a missing validation in header/trailer processing. Without these checks, an attacker could inject malformed headers with excessive lengths, leading to HTTP smuggling. The logic flaw allowed header name lengths to influence downstream parsing. However, the patch code is in the header file (`htx.h`), but the actual function implementations are in `src/htx.c` (as noted in the commit message). To fully trace the root cause, we need the function definitions in `src/htx.c` to confirm how the header/trailer blocks are constructed and validated.",
                "need_context": true,
                "required_context": [
                    "function: htx_add_header in src/htx.c",
                    "function: htx_add_trailer in src/htx.c"
                ],
                "root_cause": "Missing length checks in `htx_add_header` and `htx_add_trailer` allowed header/trailer names/values to exceed safe limits (file: include/haproxy/htx.h). This enabled header name length manipulation, which could corrupt downstream parsing (e.g., content-length deduplication). GAP: The function implementations in `src/htx.c` are not visible in the provided patch, so the exact data flow from input parsing to HTX block construction is incomplete.",
                "confidence_score": 0.7
            },
            "timestamp": "2025-05-26T15:45:40.354322"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: htx_add_header in src/htx.c",
                "function: htx_add_trailer in src/htx.c"
            ],
            "results": [
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'htx_add_header', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
                            "start_line": 464,
                            "end_line": 478,
                            "full_name": "htx_add_header",
                            "file_path": "include/haproxy/htx.h"
                        }
                    ]
                },
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'htx_add_trailer', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
                            "start_line": 483,
                            "end_line": 497,
                            "full_name": "htx_add_trailer",
                            "file_path": "include/haproxy/htx.h"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:46:07.886774"
        },
        {
            "stage": "analysis",
            "iteration": 1,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: BUG/MAJOR: htx: fix missing header name length check in htx_add_header/trailer\n\nOri Hollander of JFrog Security reported that htx_add_header() and\nhtx_add_trailer() were missing a length check on the header name. While\nthis does not allow to overwrite any memory area, it results in bits of\nthe header name length to slip into the header value length and may\nresult in forging certain header names on the input. The sad thing here\nis that a FIXME comment was present suggesting to add the required length\nchecks :-(\n\nThe injected headers are visible to the HTTP internals and to the config\nrules, so haproxy will generally stay synchronized with the server. But\nthere is one exception which is the content-length header field, because\nit is already deduplicated on the input, but before being indexed. As\nsuch, injecting a content-length header after the deduplication stage\nmay be abused to present a different, shorter one on the other side and\nhelp build a request smuggling attack, or even maybe a response splitting\nattack. CVE-2021-40346 was assigned to this problem.\n\nAs a mitigation measure, it is sufficient to verify that no more than\none such header is present in any message, which is normally the case\nthanks to the duplicate checks:\n\n   http-request  deny if { req.hdr_cnt(content-length) gt 1 }\n   http-response deny if { res.hdr_cnt(content-length) gt 1 }\n\nThis must be backported to all HTX-enabled versions, hence as far as 2.0.\nIn 2.3 and earlier, the functions are in src/htx.c instead.\n\nMany thanks to Ori for his work and his responsible report!\n- **Vulnerability Description**: An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.\n- **Patch Code**: [{'func_name': 'htx_add_header', 'patch': '--- func_before\\n+++ func_after\\n@@ -467,7 +467,9 @@\\n {\\n \\tstruct htx_blk *blk;\\n \\n-\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n+\\tif (name.len > 255 || value.len > 1048575)\\n+\\t\\treturn NULL;\\n+\\n \\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\\n \\tif (!blk)\\n \\t\\treturn NULL;', 'file_path': 'include/haproxy/htx.h'}, {'func_name': 'htx_add_trailer', 'patch': '--- func_before\\n+++ func_after\\n@@ -486,7 +486,9 @@\\n {\\n \\tstruct htx_blk *blk;\\n \\n-\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n+\\tif (name.len > 255 || value.len > 1048575)\\n+\\t\\treturn NULL;\\n+\\n \\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\\n \\tif (!blk)\\n \\t\\treturn NULL;', 'file_path': 'include/haproxy/htx.h'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"logic\",\n      \"repair_strategy\": \"The patch adds explicit length checks for header/trailer name and value lengths in `htx_add_header` and `htx_add_trailer` (file: include/haproxy/htx.h). For example, `if (name.len > 255 || value.len > 1048575) return NULL;` prevents oversized headers/trailers from being processed, mitigating header forgery and smuggling.\",\n      \"required_context\": [\n        \"function: htx_add_header in src/htx.c\",\n        \"function: htx_add_trailer in src/htx.c\"\n      ],\n      \"root_cause\": \"Missing length checks in `htx_add_header` and `htx_add_trailer` allowed header/trailer names/values to exceed safe limits (file: include/haproxy/htx.h). This enabled header name length manipulation, which could corrupt downstream parsing (e.g., content-length deduplication). GAP: The function implementations in `src/htx.c` are not visible in the provided patch, so the exact data flow from input parsing to HTX block construction is incomplete.\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:htx_add_header)\",\n        \"result\": [\n          {\n            \"code\": \"static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\\n\\t\\t\\t\\t\\t     const struct ist value)\\n{\\n\\tstruct htx_blk *blk;\\n\\n\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n\\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\\n\\tif (!blk)\\n\\t\\treturn NULL;\\n\\n\\tblk->info += (value.len << 8) + name.len;\\n\\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\\n\\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\\n\\treturn blk;\\n}\",\n            \"start_line\": 464,\n            \"end_line\": 478,\n            \"full_name\": \"htx_add_header\",\n            \"file_path\": \"include/haproxy/htx.h\"\n          }\n        ]\n      },\n      {\n        \"source\": \"func_info(func:htx_add_trailer)\",\n        \"result\": [\n          {\n            \"code\": \"static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\\n\\t\\t\\t\\t\\t      const struct ist value)\\n{\\n\\tstruct htx_blk *blk;\\n\\n\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n\\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\\n\\tif (!blk)\\n\\t\\treturn NULL;\\n\\n\\tblk->info += (value.len << 8) + name.len;\\n\\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\\n\\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\\n\\treturn blk;\\n}\",\n            \"start_line\": 483,\n            \"end_line\": 497,\n            \"full_name\": \"htx_add_trailer\",\n            \"file_path\": \"include/haproxy/htx.h\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The vulnerability arises from missing length checks in `htx_add_header` and `htx_add_trailer`, which allow header/trailer names/values to exceed safe limits. The patch adds explicit checks for `name.len > 255` and `value.len > 1048575` to prevent header forgery. The root cause is the unchecked manipulation of `name.len` and `value.len` in `blk->info`, which can corrupt downstream parsing (e.g., for `Content-Length`). The attack vector involves crafting a header name that overflows into the value length field, enabling smuggling. However, the exact data flow from input parsing to HTX block construction remains incomplete due to missing caller context for `htx_add_header` and `htx_add_trailer`.",
                "need_context": true,
                "required_context": [
                    "caller: I need the caller(s) of function htx_add_header in include/haproxy/htx.h",
                    "caller: I need the caller(s) of function htx_add_trailer in include/haproxy/htx.h"
                ],
                "root_cause": "Missing length checks in `htx_add_header` (include/haproxy/htx.h:467) and `htx_add_trailer` (include/haproxy/htx.h:486) allowed `name.len` and `value.len` to exceed safe limits. The unchecked `name.len` (stored as a byte in `blk->info`) and `value.len` (stored as 16 bits) could be manipulated to overflow into adjacent fields, corrupting header parsing logic. For example, a header name longer than 255 bytes would overflow the 8-bit name length field in `blk->info`, corrupting the 16-bit value length field. This could allow injecting a malicious `Content-Length` header after deduplication, enabling request smuggling.",
                "confidence_score": 0.85
            },
            "timestamp": "2025-05-26T15:47:20.332599"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: I need the caller(s) of function htx_add_header in include/haproxy/htx.h",
                "caller: I need the caller(s) of function htx_add_trailer in include/haproxy/htx.h"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func_file({'file_path': 'include/haproxy/htx.h', 'func_name': 'htx_add_header', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 522,
                            "call_code": "htx_add_header(htx, hdrs[i].n, hdrs[i].v)",
                            "caller_code": "static inline struct htx_blk *htx_add_all_headers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_header(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOH);\n}",
                            "caller_start": 517,
                            "file_path": "include/haproxy/htx.h"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1415,
                            "call_code": "htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\"))",
                            "caller_code": "static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), ist(\"200\"), ist(\"OK\"));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\")) ||\n\t    !htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}",
                            "caller_start": 1404,
                            "file_path": "addons/promex/service-prometheus.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1416,
                            "call_code": "htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\"))",
                            "caller_code": "static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), ist(\"200\"), ist(\"OK\"));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\")) ||\n\t    !htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}",
                            "caller_start": 1404,
                            "file_path": "addons/promex/service-prometheus.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1417,
                            "call_code": "htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\"))",
                            "caller_code": "static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\"HTTP/1.1\"), ist(\"200\"), ist(\"OK\"));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\"Cache-Control\"), ist(\"no-cache\")) ||\n\t    !htx_add_header(htx, ist(\"Content-Type\"), ist(\"text/plain; version=0.0.4\")) ||\n\t    !htx_add_header(htx, ist(\"Transfer-Encoding\"), ist(\"chunked\")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}",
                            "caller_start": 1404,
                            "file_path": "addons/promex/service-prometheus.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 468,
                            "call_code": "htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH])",
                            "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                            "caller_start": 389,
                            "file_path": "src/h2.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 515,
                            "call_code": "htx_add_header(htx, list[idx].n, list[idx].v)",
                            "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                            "caller_start": 389,
                            "file_path": "src/h2.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 541,
                            "call_code": "htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT])",
                            "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                            "caller_start": 389,
                            "file_path": "src/h2.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 543,
                            "call_code": "htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\"))",
                            "caller_code": "int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n{\n\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\n\tuint32_t idx;\n\tint ck, lck; /* cookie index and last cookie index */\n\tint phdr;\n\tint ret;\n\tint i;\n\tstruct htx_sl *sl = NULL;\n\tunsigned int sl_flags = 0;\n\tconst char *ctl;\n\n\tlck = ck = -1; // no cookie for now\n\tfields = 0;\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* this is an indexed pseudo-header */\n\t\t\tphdr = list[idx].n.len;\n\t\t}\n\t\telse {\n\t\t\t/* this can be any type of header */\n\t\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t\t * #10.3: header names must be valid (i.e. match a token).\n\t\t\t * For pseudo-headers we check from 2nd char and for other ones\n\t\t\t * from the first char, because HTTP_IS_TOKEN() also excludes\n\t\t\t * the colon.\n\t\t\t */\n\t\t\tphdr = h2_str_to_phdr(list[idx].n);\n\n\t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n\t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n\t\t\t/* insert a pseudo header by its index (in phdr) and value (in value) */\n\t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n\t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n\t\t\t\t\t/* pseudo header field after regular headers */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* repeated pseudo header field */\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfields |= 1 << phdr;\n\t\t\tphdr_val[phdr] = list[idx].v;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (phdr != 0) {\n\t\t\t/* invalid pseudo header -- should never happen here */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* regular header field in (name,value) */\n\t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n\t\t\t/* no more pseudo-headers, time to build the request line */\n\t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\t\tif (!sl)\n\t\t\t\tgoto fail;\n\t\t\tfields |= H2_PHDR_FND_NONE;\n\n\t\t\t/* http2bis draft recommends to drop Host in favor of :authority when\n\t\t\t * the latter is present. This is required to make sure there is no\n\t\t\t * discrepancy between the authority and the host header, especially\n\t\t\t * since routing rules usually involve Host. Here we already know if\n\t\t\t * :authority was found so we can emit it right now and mark the host\n\t\t\t * as filled so that it's skipped later.\n\t\t\t */\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t}\n\n\t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n\t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\n\t\t\tsl_flags |= HTX_SL_F_CLEN;\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue; // skip this duplicate\n\t\t}\n\n\t\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n\t\t\tgoto fail;\n\n\t\t/* cookie requires special processing at the end */\n\t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n\t\t\tlist[idx].n.len = -1;\n\n\t\t\tif (ck < 0)\n\t\t\t\tck = idx;\n\t\t\telse\n\t\t\t\tlist[lck].n.len = idx;\n\n\t\t\tlck = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\n\tif (fields & H2_PHDR_FND_STAT)\n\t\tgoto fail;\n\n\t/* Let's dump the request now if not yet emitted. */\n\tif (!(fields & H2_PHDR_FND_NONE)) {\n\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n\t\tif (!sl)\n\t\t\tgoto fail;\n\t}\n\n\tif (*msgf & H2_MSGF_BODY_TUNNEL)\n\t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n\n\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n\t\t/* Request without body or tunnel requested */\n\t\tsl_flags |= HTX_SL_F_BODYLESS;\n\t\thtx->flags |= HTX_FL_EOM;\n\t}\n\n\tif (*msgf & H2_MSGF_EXT_CONNECT) {\n\t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n\t\t\tgoto fail;\n\t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n\t\t\tgoto fail;\n\t\tsl_flags |= HTX_SL_F_CONN_UPG;\n\t}\n\n\t/* update the start line with last detected header info */\n\tsl->flags |= sl_flags;\n\n\t/* complete with missing Host if needed (we may validate this test if\n\t * no regular header was found).\n\t */\n\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n\t\t/* missing Host field, use :authority instead */\n\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\tgoto fail;\n\t}\n\n\t/* now we may have to build a cookie list. We'll dump the values of all\n\t * visited headers.\n\t */\n\tif (ck >= 0) {\n\t\tuint32_t fs; // free space\n\t\tuint32_t bs; // block size\n\t\tuint32_t vl; // value len\n\t\tuint32_t tl; // total length\n\t\tstruct htx_blk *blk;\n\n\t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n\t\tif (!blk)\n\t\t\tgoto fail;\n\n\t\ttl = list[ck].v.len;\n\t\tfs = htx_free_data_space(htx);\n\t\tbs = htx_get_blksz(blk);\n\n\t\t/* for each extra cookie, we'll extend the cookie's value and\n\t\t * insert \"; \" before the new value.\n\t\t */\n\t\tfs += tl; // first one is already counted\n\t\twhile ((ck = list[ck].n.len) >= 0) {\n\t\t\tvl = list[ck].v.len;\n\t\t\ttl += vl + 2;\n\t\t\tif (tl > fs)\n\t\t\t\tgoto fail;\n\n\t\t\thtx_change_blk_value_len(htx, blk, tl);\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n\t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n\t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n\t\t\tbs += vl + 2;\n\t\t}\n\n\t}\n\n\t/* now send the end of headers marker */\n\tif (!htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto fail;\n\n\t/* proceed to scheme-based normalization on target-URI */\n\tif (fields & H2_PHDR_FND_SCHM)\n\t\thttp_scheme_based_normalize(htx);\n\n\tret = 1;\n\treturn ret;\n\n fail:\n\treturn -1;\n}\n",
                            "caller_start": 389,
                            "file_path": "src/h2.c"
                        }
                    ]
                },
                {
                    "tool": "caller_info.find_caller_for_func_file({'file_path': 'include/haproxy/htx.h', 'func_name': 'htx_add_trailer', 'project_dir': './storage/result/Part2_result/github/CVE-2021-40346/old_repos/haproxy-haproxy_3d5f19e'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 536,
                            "call_code": "htx_add_trailer(htx, hdrs[i].n, hdrs[i].v)",
                            "caller_code": "static inline struct htx_blk *htx_add_all_trailers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_trailer(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOT);\n}",
                            "caller_start": 531,
                            "file_path": "include/haproxy/htx.h"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 907,
                            "call_code": "htx_add_trailer(htx, list[idx].n, list[idx].v)",
                            "caller_code": "int h2_make_htx_trailers(struct http_hdr *list, struct htx *htx)\n{\n\tconst char *ctl;\n\tuint32_t idx;\n\tint i;\n\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* This is an indexed pseudo-header (RFC7540#8.1.2.1) */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t * #10.3: header names must be valid (i.e. match a token). This\n\t\t * also catches pseudo-headers which are forbidden in trailers.\n\t\t */\n\t\tfor (i = 0; i < list[idx].n.len; i++)\n\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\tgoto fail;\n\n\t\t/* these ones are forbidden in trailers (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\"host\")) ||\n\t\t    isteq(list[idx].n, ist(\"content-length\")) ||\n\t\t    isteq(list[idx].n, ist(\"connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n\t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n\t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n\t\t    isteq(list[idx].n, ist(\"te\")) ||\n\t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n\t\t\tgoto fail;\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (!htx_add_trailer(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOT))\n\t\tgoto fail;\n\n\treturn 1;\n\n fail:\n\treturn -1;\n}\n",
                            "caller_start": 869,
                            "file_path": "src/h2.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:47:39.789096"
        },
        {
            "stage": "analysis",
            "iteration": 2,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: BUG/MAJOR: htx: fix missing header name length check in htx_add_header/trailer\n\nOri Hollander of JFrog Security reported that htx_add_header() and\nhtx_add_trailer() were missing a length check on the header name. While\nthis does not allow to overwrite any memory area, it results in bits of\nthe header name length to slip into the header value length and may\nresult in forging certain header names on the input. The sad thing here\nis that a FIXME comment was present suggesting to add the required length\nchecks :-(\n\nThe injected headers are visible to the HTTP internals and to the config\nrules, so haproxy will generally stay synchronized with the server. But\nthere is one exception which is the content-length header field, because\nit is already deduplicated on the input, but before being indexed. As\nsuch, injecting a content-length header after the deduplication stage\nmay be abused to present a different, shorter one on the other side and\nhelp build a request smuggling attack, or even maybe a response splitting\nattack. CVE-2021-40346 was assigned to this problem.\n\nAs a mitigation measure, it is sufficient to verify that no more than\none such header is present in any message, which is normally the case\nthanks to the duplicate checks:\n\n   http-request  deny if { req.hdr_cnt(content-length) gt 1 }\n   http-response deny if { res.hdr_cnt(content-length) gt 1 }\n\nThis must be backported to all HTX-enabled versions, hence as far as 2.0.\nIn 2.3 and earlier, the functions are in src/htx.c instead.\n\nMany thanks to Ori for his work and his responsible report!\n- **Vulnerability Description**: An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.\n- **Patch Code**: [{'func_name': 'htx_add_header', 'patch': '--- func_before\\n+++ func_after\\n@@ -467,7 +467,9 @@\\n {\\n \\tstruct htx_blk *blk;\\n \\n-\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n+\\tif (name.len > 255 || value.len > 1048575)\\n+\\t\\treturn NULL;\\n+\\n \\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\\n \\tif (!blk)\\n \\t\\treturn NULL;', 'file_path': 'include/haproxy/htx.h'}, {'func_name': 'htx_add_trailer', 'patch': '--- func_before\\n+++ func_after\\n@@ -486,7 +486,9 @@\\n {\\n \\tstruct htx_blk *blk;\\n \\n-\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n+\\tif (name.len > 255 || value.len > 1048575)\\n+\\t\\treturn NULL;\\n+\\n \\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\\n \\tif (!blk)\\n \\t\\treturn NULL;', 'file_path': 'include/haproxy/htx.h'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"logic\",\n      \"repair_strategy\": \"The patch adds explicit length checks for header/trailer name and value lengths in `htx_add_header` and `htx_add_trailer` (file: include/haproxy/htx.h). For example, `if (name.len > 255 || value.len > 1048575) return NULL;` prevents oversized headers/trailers from being processed, mitigating header forgery and smuggling.\",\n      \"required_context\": [\n        \"function: htx_add_header in src/htx.c\",\n        \"function: htx_add_trailer in src/htx.c\"\n      ],\n      \"root_cause\": \"Missing length checks in `htx_add_header` and `htx_add_trailer` allowed header/trailer names/values to exceed safe limits (file: include/haproxy/htx.h). This enabled header name length manipulation, which could corrupt downstream parsing (e.g., content-length deduplication). GAP: The function implementations in `src/htx.c` are not visible in the provided patch, so the exact data flow from input parsing to HTX block construction is incomplete.\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:htx_add_header)\",\n        \"result\": [\n          {\n            \"code\": \"static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\\n\\t\\t\\t\\t\\t     const struct ist value)\\n{\\n\\tstruct htx_blk *blk;\\n\\n\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n\\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\\n\\tif (!blk)\\n\\t\\treturn NULL;\\n\\n\\tblk->info += (value.len << 8) + name.len;\\n\\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\\n\\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\\n\\treturn blk;\\n}\",\n            \"start_line\": 464,\n            \"end_line\": 478,\n            \"full_name\": \"htx_add_header\",\n            \"file_path\": \"include/haproxy/htx.h\"\n          }\n        ]\n      },\n      {\n        \"source\": \"func_info(func:htx_add_trailer)\",\n        \"result\": [\n          {\n            \"code\": \"static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\\n\\t\\t\\t\\t\\t      const struct ist value)\\n{\\n\\tstruct htx_blk *blk;\\n\\n\\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\\n\\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\\n\\tif (!blk)\\n\\t\\treturn NULL;\\n\\n\\tblk->info += (value.len << 8) + name.len;\\n\\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\\n\\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\\n\\treturn blk;\\n}\",\n            \"start_line\": 483,\n            \"end_line\": 497,\n            \"full_name\": \"htx_add_trailer\",\n            \"file_path\": \"include/haproxy/htx.h\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Missing length checks in `htx_add_header` (include/haproxy/htx.h:467) and `htx_add_trailer` (include/haproxy/htx.h:486) allowed `name.len` and `value.len` to exceed safe limits. The unchecked `name.len` (stored as a byte in `blk->info`) and `value.len` (stored as 16 bits) could be manipulated to overflow into adjacent fields, corrupting header parsing logic. For example, a header name longer than 255 bytes would overflow the 8-bit name length field in `blk->info`, corrupting the 16-bit value length field. This could allow injecting a malicious `Content-Length` header after deduplication, enabling request smuggling.\",\n    \"required_context_next\": [\n      \"caller: I need the caller(s) of function htx_add_header in include/haproxy/htx.h\",\n      \"caller: I need the caller(s) of function htx_add_trailer in include/haproxy/htx.h\"\n    ],\n    \"analysis_summary_text\": \"The vulnerability arises from missing length checks in `htx_add_header` and `htx_add_trailer`, which allow header/trailer names/values to exceed safe limits. The patch adds explicit checks for `name.len > 255` and `value.len > 1048575` to prevent header forgery. The root cause is the unchecked manipulation of `name.len` and `value.len` in `blk->info`, which can corrupt downstream parsing (e.g., for `Content-Length`). The attack vector involves crafting a header name that overflows into the value length field, enabling smuggling. However, the exact data flow from input parsing to HTX block construction remains incomplete due to missing caller context for `htx_add_header` and `htx_add_trailer`.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(file:htx.h, func:htx_add_header)\",\n        \"result\": [\n          {\n            \"call_line\": 522,\n            \"call_code\": \"htx_add_header(htx, hdrs[i].n, hdrs[i].v)\",\n            \"caller_code\": \"static inline struct htx_blk *htx_add_all_headers(struct htx *htx, const struct http_hdr *hdrs)\\n{\\n\\tint i;\\n\\n\\tfor (i = 0; hdrs[i].n.len; i++) {\\n\\t\\tif (!htx_add_header(htx, hdrs[i].n, hdrs[i].v))\\n\\t\\t\\treturn NULL;\\n\\t}\\n\\treturn htx_add_endof(htx, HTX_BLK_EOH);\\n}\",\n            \"caller_start\": 517,\n            \"file_path\": \"include/haproxy/htx.h\"\n          },\n          {\n            \"call_line\": 1415,\n            \"call_code\": \"htx_add_header(htx, ist(\\\"Cache-Control\\\"), ist(\\\"no-cache\\\"))\",\n            \"caller_code\": \"static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\\n{\\n\\tstruct channel *chn = si_ic(appctx->owner);\\n\\tstruct htx_sl *sl;\\n\\tunsigned int flags;\\n\\n\\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\\n\\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\\\"HTTP/1.1\\\"), ist(\\\"200\\\"), ist(\\\"OK\\\"));\\n\\tif (!sl)\\n\\t\\tgoto full;\\n\\tsl->info.res.status = 200;\\n\\tif (!htx_add_header(htx, ist(\\\"Cache-Control\\\"), ist(\\\"no-cache\\\")) ||\\n\\t    !htx_add_header(htx, ist(\\\"Content-Type\\\"), ist(\\\"text/plain; version=0.0.4\\\")) ||\\n\\t    !htx_add_header(htx, ist(\\\"Transfer-Encoding\\\"), ist(\\\"chunked\\\")) ||\\n\\t    !htx_add_endof(htx, HTX_BLK_EOH))\\n\\t\\tgoto full;\\n\\n\\tchannel_add_input(chn, htx->data);\\n\\treturn 1;\\n  full:\\n\\thtx_reset(htx);\\n\\tsi_rx_room_blk(si);\\n\\treturn 0;\\n}\",\n            \"caller_start\": 1404,\n            \"file_path\": \"addons/promex/service-prometheus.c\"\n          },\n          {\n            \"call_line\": 1416,\n            \"call_code\": \"htx_add_header(htx, ist(\\\"Content-Type\\\"), ist(\\\"text/plain; version=0.0.4\\\"))\",\n            \"caller_code\": \"static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\\n{\\n\\tstruct channel *chn = si_ic(appctx->owner);\\n\\tstruct htx_sl *sl;\\n\\tunsigned int flags;\\n\\n\\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\\n\\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\\\"HTTP/1.1\\\"), ist(\\\"200\\\"), ist(\\\"OK\\\"));\\n\\tif (!sl)\\n\\t\\tgoto full;\\n\\tsl->info.res.status = 200;\\n\\tif (!htx_add_header(htx, ist(\\\"Cache-Control\\\"), ist(\\\"no-cache\\\")) ||\\n\\t    !htx_add_header(htx, ist(\\\"Content-Type\\\"), ist(\\\"text/plain; version=0.0.4\\\")) ||\\n\\t    !htx_add_header(htx, ist(\\\"Transfer-Encoding\\\"), ist(\\\"chunked\\\")) ||\\n\\t    !htx_add_endof(htx, HTX_BLK_EOH))\\n\\t\\tgoto full;\\n\\n\\tchannel_add_input(chn, htx->data);\\n\\treturn 1;\\n  full:\\n\\thtx_reset(htx);\\n\\tsi_rx_room_blk(si);\\n\\treturn 0;\\n}\",\n            \"caller_start\": 1404,\n            \"file_path\": \"addons/promex/service-prometheus.c\"\n          },\n          {\n            \"call_line\": 1417,\n            \"call_code\": \"htx_add_header(htx, ist(\\\"Transfer-Encoding\\\"), ist(\\\"chunked\\\"))\",\n            \"caller_code\": \"static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\\n{\\n\\tstruct channel *chn = si_ic(appctx->owner);\\n\\tstruct htx_sl *sl;\\n\\tunsigned int flags;\\n\\n\\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\\n\\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\\\"HTTP/1.1\\\"), ist(\\\"200\\\"), ist(\\\"OK\\\"));\\n\\tif (!sl)\\n\\t\\tgoto full;\\n\\tsl->info.res.status = 200;\\n\\tif (!htx_add_header(htx, ist(\\\"Cache-Control\\\"), ist(\\\"no-cache\\\")) ||\\n\\t    !htx_add_header(htx, ist(\\\"Content-Type\\\"), ist(\\\"text/plain; version=0.0.4\\\")) ||\\n\\t    !htx_add_header(htx, ist(\\\"Transfer-Encoding\\\"), ist(\\\"chunked\\\")) ||\\n\\t    !htx_add_endof(htx, HTX_BLK_EOH))\\n\\t\\tgoto full;\\n\\n\\tchannel_add_input(chn, htx->data);\\n\\treturn 1;\\n  full:\\n\\thtx_reset(htx);\\n\\tsi_rx_room_blk(si);\\n\\treturn 0;\\n}\",\n            \"caller_start\": 1404,\n            \"file_path\": \"addons/promex/service-prometheus.c\"\n          },\n          {\n            \"call_line\": 468,\n            \"call_code\": \"htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH])\",\n            \"caller_code\": \"int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\\n{\\n\\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\\n\\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\\n\\tuint32_t idx;\\n\\tint ck, lck; /* cookie index and last cookie index */\\n\\tint phdr;\\n\\tint ret;\\n\\tint i;\\n\\tstruct htx_sl *sl = NULL;\\n\\tunsigned int sl_flags = 0;\\n\\tconst char *ctl;\\n\\n\\tlck = ck = -1; // no cookie for now\\n\\tfields = 0;\\n\\tfor (idx = 0; list[idx].n.len != 0; idx++) {\\n\\t\\tif (!list[idx].n.ptr) {\\n\\t\\t\\t/* this is an indexed pseudo-header */\\n\\t\\t\\tphdr = list[idx].n.len;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t/* this can be any type of header */\\n\\t\\t\\t/* RFC7540#8.1.2: upper case not allowed in header field names.\\n\\t\\t\\t * #10.3: header names must be valid (i.e. match a token).\\n\\t\\t\\t * For pseudo-headers we check from 2nd char and for other ones\\n\\t\\t\\t * from the first char, because HTTP_IS_TOKEN() also excludes\\n\\t\\t\\t * the colon.\\n\\t\\t\\t */\\n\\t\\t\\tphdr = h2_str_to_phdr(list[idx].n);\\n\\n\\t\\t\\tfor (i = !!phdr; i < list[idx].n.len; i++)\\n\\t\\t\\t\\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\\n\\t\\t * rejecting NUL, CR and LF characters.\\n\\t\\t */\\n\\t\\tctl = ist_find_ctl(list[idx].v);\\n\\t\\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\\n\\t\\t\\t/* insert a pseudo header by its index (in phdr) and value (in value) */\\n\\t\\t\\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\\n\\t\\t\\t\\tif (fields & H2_PHDR_FND_NONE) {\\n\\t\\t\\t\\t\\t/* pseudo header field after regular headers */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t/* repeated pseudo header field */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfields |= 1 << phdr;\\n\\t\\t\\tphdr_val[phdr] = list[idx].v;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (phdr != 0) {\\n\\t\\t\\t/* invalid pseudo header -- should never happen here */\\n\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* regular header field in (name,value) */\\n\\t\\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\\n\\t\\t\\t/* no more pseudo-headers, time to build the request line */\\n\\t\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\t\\tif (!sl)\\n\\t\\t\\t\\tgoto fail;\\n\\t\\t\\tfields |= H2_PHDR_FND_NONE;\\n\\n\\t\\t\\t/* http2bis draft recommends to drop Host in favor of :authority when\\n\\t\\t\\t * the latter is present. This is required to make sure there is no\\n\\t\\t\\t * discrepancy between the authority and the host header, especially\\n\\t\\t\\t * since routing rules usually involve Host. Here we already know if\\n\\t\\t\\t * :authority was found so we can emit it right now and mark the host\\n\\t\\t\\t * as filled so that it's skipped later.\\n\\t\\t\\t */\\n\\t\\t\\tif (fields & H2_PHDR_FND_AUTH) {\\n\\t\\t\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"host\\\"))) {\\n\\t\\t\\tif (fields & H2_PHDR_FND_HOST)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"content-length\\\"))) {\\n\\t\\t\\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\\n\\t\\t\\tif (ret < 0)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\tsl_flags |= HTX_SL_F_CLEN;\\n\\t\\t\\tif (ret == 0)\\n\\t\\t\\t\\tcontinue; // skip this duplicate\\n\\t\\t}\\n\\n\\t\\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"proxy-connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"keep-alive\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"upgrade\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"transfer-encoding\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"te\\\")) && !isteq(list[idx].v, ist(\\\"trailers\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\t/* cookie requires special processing at the end */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"cookie\\\"))) {\\n\\t\\t\\tlist[idx].n.len = -1;\\n\\n\\t\\t\\tif (ck < 0)\\n\\t\\t\\t\\tck = idx;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlist[lck].n.len = idx;\\n\\n\\t\\t\\tlck = idx;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\\n\\tif (fields & H2_PHDR_FND_STAT)\\n\\t\\tgoto fail;\\n\\n\\t/* Let's dump the request now if not yet emitted. */\\n\\tif (!(fields & H2_PHDR_FND_NONE)) {\\n\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\tif (!sl)\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_BODY_TUNNEL)\\n\\t\\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\\n\\n\\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\\n\\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\\n\\t\\t/* Request without body or tunnel requested */\\n\\t\\tsl_flags |= HTX_SL_F_BODYLESS;\\n\\t\\thtx->flags |= HTX_FL_EOM;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_EXT_CONNECT) {\\n\\t\\tif (!htx_add_header(htx, ist(\\\"upgrade\\\"), phdr_val[H2_PHDR_IDX_PROT]))\\n\\t\\t\\tgoto fail;\\n\\t\\tif (!htx_add_header(htx, ist(\\\"connection\\\"), ist(\\\"upgrade\\\")))\\n\\t\\t\\tgoto fail;\\n\\t\\tsl_flags |= HTX_SL_F_CONN_UPG;\\n\\t}\\n\\n\\t/* update the start line with last detected header info */\\n\\tsl->flags |= sl_flags;\\n\\n\\t/* complete with missing Host if needed (we may validate this test if\\n\\t * no regular header was found).\\n\\t */\\n\\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\\n\\t\\t/* missing Host field, use :authority instead */\\n\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* now we may have to build a cookie list. We'll dump the values of all\\n\\t * visited headers.\\n\\t */\\n\\tif (ck >= 0) {\\n\\t\\tuint32_t fs; // free space\\n\\t\\tuint32_t bs; // block size\\n\\t\\tuint32_t vl; // value len\\n\\t\\tuint32_t tl; // total length\\n\\t\\tstruct htx_blk *blk;\\n\\n\\t\\tblk = htx_add_header(htx, ist(\\\"cookie\\\"), list[ck].v);\\n\\t\\tif (!blk)\\n\\t\\t\\tgoto fail;\\n\\n\\t\\ttl = list[ck].v.len;\\n\\t\\tfs = htx_free_data_space(htx);\\n\\t\\tbs = htx_get_blksz(blk);\\n\\n\\t\\t/* for each extra cookie, we'll extend the cookie's value and\\n\\t\\t * insert \\\"; \\\" before the new value.\\n\\t\\t */\\n\\t\\tfs += tl; // first one is already counted\\n\\t\\twhile ((ck = list[ck].n.len) >= 0) {\\n\\t\\t\\tvl = list[ck].v.len;\\n\\t\\t\\ttl += vl + 2;\\n\\t\\t\\tif (tl > fs)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\thtx_change_blk_value_len(htx, blk, tl);\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\\n\\t\\t\\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\\n\\t\\t\\tbs += vl + 2;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/* now send the end of headers marker */\\n\\tif (!htx_add_endof(htx, HTX_BLK_EOH))\\n\\t\\tgoto fail;\\n\\n\\t/* proceed to scheme-based normalization on target-URI */\\n\\tif (fields & H2_PHDR_FND_SCHM)\\n\\t\\thttp_scheme_based_normalize(htx);\\n\\n\\tret = 1;\\n\\treturn ret;\\n\\n fail:\\n\\treturn -1;\\n}\\n\",\n            \"caller_start\": 389,\n            \"file_path\": \"src/h2.c\"\n          },\n          {\n            \"call_line\": 515,\n            \"call_code\": \"htx_add_header(htx, list[idx].n, list[idx].v)\",\n            \"caller_code\": \"int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\\n{\\n\\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\\n\\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\\n\\tuint32_t idx;\\n\\tint ck, lck; /* cookie index and last cookie index */\\n\\tint phdr;\\n\\tint ret;\\n\\tint i;\\n\\tstruct htx_sl *sl = NULL;\\n\\tunsigned int sl_flags = 0;\\n\\tconst char *ctl;\\n\\n\\tlck = ck = -1; // no cookie for now\\n\\tfields = 0;\\n\\tfor (idx = 0; list[idx].n.len != 0; idx++) {\\n\\t\\tif (!list[idx].n.ptr) {\\n\\t\\t\\t/* this is an indexed pseudo-header */\\n\\t\\t\\tphdr = list[idx].n.len;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t/* this can be any type of header */\\n\\t\\t\\t/* RFC7540#8.1.2: upper case not allowed in header field names.\\n\\t\\t\\t * #10.3: header names must be valid (i.e. match a token).\\n\\t\\t\\t * For pseudo-headers we check from 2nd char and for other ones\\n\\t\\t\\t * from the first char, because HTTP_IS_TOKEN() also excludes\\n\\t\\t\\t * the colon.\\n\\t\\t\\t */\\n\\t\\t\\tphdr = h2_str_to_phdr(list[idx].n);\\n\\n\\t\\t\\tfor (i = !!phdr; i < list[idx].n.len; i++)\\n\\t\\t\\t\\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\\n\\t\\t * rejecting NUL, CR and LF characters.\\n\\t\\t */\\n\\t\\tctl = ist_find_ctl(list[idx].v);\\n\\t\\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\\n\\t\\t\\t/* insert a pseudo header by its index (in phdr) and value (in value) */\\n\\t\\t\\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\\n\\t\\t\\t\\tif (fields & H2_PHDR_FND_NONE) {\\n\\t\\t\\t\\t\\t/* pseudo header field after regular headers */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t/* repeated pseudo header field */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfields |= 1 << phdr;\\n\\t\\t\\tphdr_val[phdr] = list[idx].v;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (phdr != 0) {\\n\\t\\t\\t/* invalid pseudo header -- should never happen here */\\n\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* regular header field in (name,value) */\\n\\t\\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\\n\\t\\t\\t/* no more pseudo-headers, time to build the request line */\\n\\t\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\t\\tif (!sl)\\n\\t\\t\\t\\tgoto fail;\\n\\t\\t\\tfields |= H2_PHDR_FND_NONE;\\n\\n\\t\\t\\t/* http2bis draft recommends to drop Host in favor of :authority when\\n\\t\\t\\t * the latter is present. This is required to make sure there is no\\n\\t\\t\\t * discrepancy between the authority and the host header, especially\\n\\t\\t\\t * since routing rules usually involve Host. Here we already know if\\n\\t\\t\\t * :authority was found so we can emit it right now and mark the host\\n\\t\\t\\t * as filled so that it's skipped later.\\n\\t\\t\\t */\\n\\t\\t\\tif (fields & H2_PHDR_FND_AUTH) {\\n\\t\\t\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"host\\\"))) {\\n\\t\\t\\tif (fields & H2_PHDR_FND_HOST)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"content-length\\\"))) {\\n\\t\\t\\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\\n\\t\\t\\tif (ret < 0)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\tsl_flags |= HTX_SL_F_CLEN;\\n\\t\\t\\tif (ret == 0)\\n\\t\\t\\t\\tcontinue; // skip this duplicate\\n\\t\\t}\\n\\n\\t\\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"proxy-connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"keep-alive\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"upgrade\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"transfer-encoding\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"te\\\")) && !isteq(list[idx].v, ist(\\\"trailers\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\t/* cookie requires special processing at the end */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"cookie\\\"))) {\\n\\t\\t\\tlist[idx].n.len = -1;\\n\\n\\t\\t\\tif (ck < 0)\\n\\t\\t\\t\\tck = idx;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlist[lck].n.len = idx;\\n\\n\\t\\t\\tlck = idx;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\\n\\tif (fields & H2_PHDR_FND_STAT)\\n\\t\\tgoto fail;\\n\\n\\t/* Let's dump the request now if not yet emitted. */\\n\\tif (!(fields & H2_PHDR_FND_NONE)) {\\n\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\tif (!sl)\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_BODY_TUNNEL)\\n\\t\\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\\n\\n\\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\\n\\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\\n\\t\\t/* Request without body or tunnel requested */\\n\\t\\tsl_flags |= HTX_SL_F_BODYLESS;\\n\\t\\thtx->flags |= HTX_FL_EOM;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_EXT_CONNECT) {\\n\\t\\tif (!htx_add_header(htx, ist(\\\"upgrade\\\"), phdr_val[H2_PHDR_IDX_PROT]))\\n\\t\\t\\tgoto fail;\\n\\t\\tif (!htx_add_header(htx, ist(\\\"connection\\\"), ist(\\\"upgrade\\\")))\\n\\t\\t\\tgoto fail;\\n\\t\\tsl_flags |= HTX_SL_F_CONN_UPG;\\n\\t}\\n\\n\\t/* update the start line with last detected header info */\\n\\tsl->flags |= sl_flags;\\n\\n\\t/* complete with missing Host if needed (we may validate this test if\\n\\t * no regular header was found).\\n\\t */\\n\\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\\n\\t\\t/* missing Host field, use :authority instead */\\n\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* now we may have to build a cookie list. We'll dump the values of all\\n\\t * visited headers.\\n\\t */\\n\\tif (ck >= 0) {\\n\\t\\tuint32_t fs; // free space\\n\\t\\tuint32_t bs; // block size\\n\\t\\tuint32_t vl; // value len\\n\\t\\tuint32_t tl; // total length\\n\\t\\tstruct htx_blk *blk;\\n\\n\\t\\tblk = htx_add_header(htx, ist(\\\"cookie\\\"), list[ck].v);\\n\\t\\tif (!blk)\\n\\t\\t\\tgoto fail;\\n\\n\\t\\ttl = list[ck].v.len;\\n\\t\\tfs = htx_free_data_space(htx);\\n\\t\\tbs = htx_get_blksz(blk);\\n\\n\\t\\t/* for each extra cookie, we'll extend the cookie's value and\\n\\t\\t * insert \\\"; \\\" before the new value.\\n\\t\\t */\\n\\t\\tfs += tl; // first one is already counted\\n\\t\\twhile ((ck = list[ck].n.len) >= 0) {\\n\\t\\t\\tvl = list[ck].v.len;\\n\\t\\t\\ttl += vl + 2;\\n\\t\\t\\tif (tl > fs)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\thtx_change_blk_value_len(htx, blk, tl);\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\\n\\t\\t\\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\\n\\t\\t\\tbs += vl + 2;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/* now send the end of headers marker */\\n\\tif (!htx_add_endof(htx, HTX_BLK_EOH))\\n\\t\\tgoto fail;\\n\\n\\t/* proceed to scheme-based normalization on target-URI */\\n\\tif (fields & H2_PHDR_FND_SCHM)\\n\\t\\thttp_scheme_based_normalize(htx);\\n\\n\\tret = 1;\\n\\treturn ret;\\n\\n fail:\\n\\treturn -1;\\n}\\n\",\n            \"caller_start\": 389,\n            \"file_path\": \"src/h2.c\"\n          },\n          {\n            \"call_line\": 541,\n            \"call_code\": \"htx_add_header(htx, ist(\\\"upgrade\\\"), phdr_val[H2_PHDR_IDX_PROT])\",\n            \"caller_code\": \"int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\\n{\\n\\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\\n\\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\\n\\tuint32_t idx;\\n\\tint ck, lck; /* cookie index and last cookie index */\\n\\tint phdr;\\n\\tint ret;\\n\\tint i;\\n\\tstruct htx_sl *sl = NULL;\\n\\tunsigned int sl_flags = 0;\\n\\tconst char *ctl;\\n\\n\\tlck = ck = -1; // no cookie for now\\n\\tfields = 0;\\n\\tfor (idx = 0; list[idx].n.len != 0; idx++) {\\n\\t\\tif (!list[idx].n.ptr) {\\n\\t\\t\\t/* this is an indexed pseudo-header */\\n\\t\\t\\tphdr = list[idx].n.len;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t/* this can be any type of header */\\n\\t\\t\\t/* RFC7540#8.1.2: upper case not allowed in header field names.\\n\\t\\t\\t * #10.3: header names must be valid (i.e. match a token).\\n\\t\\t\\t * For pseudo-headers we check from 2nd char and for other ones\\n\\t\\t\\t * from the first char, because HTTP_IS_TOKEN() also excludes\\n\\t\\t\\t * the colon.\\n\\t\\t\\t */\\n\\t\\t\\tphdr = h2_str_to_phdr(list[idx].n);\\n\\n\\t\\t\\tfor (i = !!phdr; i < list[idx].n.len; i++)\\n\\t\\t\\t\\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\\n\\t\\t * rejecting NUL, CR and LF characters.\\n\\t\\t */\\n\\t\\tctl = ist_find_ctl(list[idx].v);\\n\\t\\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\\n\\t\\t\\t/* insert a pseudo header by its index (in phdr) and value (in value) */\\n\\t\\t\\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\\n\\t\\t\\t\\tif (fields & H2_PHDR_FND_NONE) {\\n\\t\\t\\t\\t\\t/* pseudo header field after regular headers */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t/* repeated pseudo header field */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfields |= 1 << phdr;\\n\\t\\t\\tphdr_val[phdr] = list[idx].v;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (phdr != 0) {\\n\\t\\t\\t/* invalid pseudo header -- should never happen here */\\n\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* regular header field in (name,value) */\\n\\t\\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\\n\\t\\t\\t/* no more pseudo-headers, time to build the request line */\\n\\t\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\t\\tif (!sl)\\n\\t\\t\\t\\tgoto fail;\\n\\t\\t\\tfields |= H2_PHDR_FND_NONE;\\n\\n\\t\\t\\t/* http2bis draft recommends to drop Host in favor of :authority when\\n\\t\\t\\t * the latter is present. This is required to make sure there is no\\n\\t\\t\\t * discrepancy between the authority and the host header, especially\\n\\t\\t\\t * since routing rules usually involve Host. Here we already know if\\n\\t\\t\\t * :authority was found so we can emit it right now and mark the host\\n\\t\\t\\t * as filled so that it's skipped later.\\n\\t\\t\\t */\\n\\t\\t\\tif (fields & H2_PHDR_FND_AUTH) {\\n\\t\\t\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"host\\\"))) {\\n\\t\\t\\tif (fields & H2_PHDR_FND_HOST)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"content-length\\\"))) {\\n\\t\\t\\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\\n\\t\\t\\tif (ret < 0)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\tsl_flags |= HTX_SL_F_CLEN;\\n\\t\\t\\tif (ret == 0)\\n\\t\\t\\t\\tcontinue; // skip this duplicate\\n\\t\\t}\\n\\n\\t\\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"proxy-connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"keep-alive\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"upgrade\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"transfer-encoding\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"te\\\")) && !isteq(list[idx].v, ist(\\\"trailers\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\t/* cookie requires special processing at the end */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"cookie\\\"))) {\\n\\t\\t\\tlist[idx].n.len = -1;\\n\\n\\t\\t\\tif (ck < 0)\\n\\t\\t\\t\\tck = idx;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlist[lck].n.len = idx;\\n\\n\\t\\t\\tlck = idx;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\\n\\tif (fields & H2_PHDR_FND_STAT)\\n\\t\\tgoto fail;\\n\\n\\t/* Let's dump the request now if not yet emitted. */\\n\\tif (!(fields & H2_PHDR_FND_NONE)) {\\n\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\tif (!sl)\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_BODY_TUNNEL)\\n\\t\\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\\n\\n\\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\\n\\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\\n\\t\\t/* Request without body or tunnel requested */\\n\\t\\tsl_flags |= HTX_SL_F_BODYLESS;\\n\\t\\thtx->flags |= HTX_FL_EOM;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_EXT_CONNECT) {\\n\\t\\tif (!htx_add_header(htx, ist(\\\"upgrade\\\"), phdr_val[H2_PHDR_IDX_PROT]))\\n\\t\\t\\tgoto fail;\\n\\t\\tif (!htx_add_header(htx, ist(\\\"connection\\\"), ist(\\\"upgrade\\\")))\\n\\t\\t\\tgoto fail;\\n\\t\\tsl_flags |= HTX_SL_F_CONN_UPG;\\n\\t}\\n\\n\\t/* update the start line with last detected header info */\\n\\tsl->flags |= sl_flags;\\n\\n\\t/* complete with missing Host if needed (we may validate this test if\\n\\t * no regular header was found).\\n\\t */\\n\\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\\n\\t\\t/* missing Host field, use :authority instead */\\n\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* now we may have to build a cookie list. We'll dump the values of all\\n\\t * visited headers.\\n\\t */\\n\\tif (ck >= 0) {\\n\\t\\tuint32_t fs; // free space\\n\\t\\tuint32_t bs; // block size\\n\\t\\tuint32_t vl; // value len\\n\\t\\tuint32_t tl; // total length\\n\\t\\tstruct htx_blk *blk;\\n\\n\\t\\tblk = htx_add_header(htx, ist(\\\"cookie\\\"), list[ck].v);\\n\\t\\tif (!blk)\\n\\t\\t\\tgoto fail;\\n\\n\\t\\ttl = list[ck].v.len;\\n\\t\\tfs = htx_free_data_space(htx);\\n\\t\\tbs = htx_get_blksz(blk);\\n\\n\\t\\t/* for each extra cookie, we'll extend the cookie's value and\\n\\t\\t * insert \\\"; \\\" before the new value.\\n\\t\\t */\\n\\t\\tfs += tl; // first one is already counted\\n\\t\\twhile ((ck = list[ck].n.len) >= 0) {\\n\\t\\t\\tvl = list[ck].v.len;\\n\\t\\t\\ttl += vl + 2;\\n\\t\\t\\tif (tl > fs)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\thtx_change_blk_value_len(htx, blk, tl);\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\\n\\t\\t\\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\\n\\t\\t\\tbs += vl + 2;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/* now send the end of headers marker */\\n\\tif (!htx_add_endof(htx, HTX_BLK_EOH))\\n\\t\\tgoto fail;\\n\\n\\t/* proceed to scheme-based normalization on target-URI */\\n\\tif (fields & H2_PHDR_FND_SCHM)\\n\\t\\thttp_scheme_based_normalize(htx);\\n\\n\\tret = 1;\\n\\treturn ret;\\n\\n fail:\\n\\treturn -1;\\n}\\n\",\n            \"caller_start\": 389,\n            \"file_path\": \"src/h2.c\"\n          },\n          {\n            \"call_line\": 543,\n            \"call_code\": \"htx_add_header(htx, ist(\\\"connection\\\"), ist(\\\"upgrade\\\"))\",\n            \"caller_code\": \"int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\\n{\\n\\tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\\n\\tuint32_t fields; /* bit mask of H2_PHDR_FND_* */\\n\\tuint32_t idx;\\n\\tint ck, lck; /* cookie index and last cookie index */\\n\\tint phdr;\\n\\tint ret;\\n\\tint i;\\n\\tstruct htx_sl *sl = NULL;\\n\\tunsigned int sl_flags = 0;\\n\\tconst char *ctl;\\n\\n\\tlck = ck = -1; // no cookie for now\\n\\tfields = 0;\\n\\tfor (idx = 0; list[idx].n.len != 0; idx++) {\\n\\t\\tif (!list[idx].n.ptr) {\\n\\t\\t\\t/* this is an indexed pseudo-header */\\n\\t\\t\\tphdr = list[idx].n.len;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t/* this can be any type of header */\\n\\t\\t\\t/* RFC7540#8.1.2: upper case not allowed in header field names.\\n\\t\\t\\t * #10.3: header names must be valid (i.e. match a token).\\n\\t\\t\\t * For pseudo-headers we check from 2nd char and for other ones\\n\\t\\t\\t * from the first char, because HTTP_IS_TOKEN() also excludes\\n\\t\\t\\t * the colon.\\n\\t\\t\\t */\\n\\t\\t\\tphdr = h2_str_to_phdr(list[idx].n);\\n\\n\\t\\t\\tfor (i = !!phdr; i < list[idx].n.len; i++)\\n\\t\\t\\t\\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\\n\\t\\t * rejecting NUL, CR and LF characters.\\n\\t\\t */\\n\\t\\tctl = ist_find_ctl(list[idx].v);\\n\\t\\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\\n\\t\\t\\t/* insert a pseudo header by its index (in phdr) and value (in value) */\\n\\t\\t\\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\\n\\t\\t\\t\\tif (fields & H2_PHDR_FND_NONE) {\\n\\t\\t\\t\\t\\t/* pseudo header field after regular headers */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t/* repeated pseudo header field */\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfields |= 1 << phdr;\\n\\t\\t\\tphdr_val[phdr] = list[idx].v;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse if (phdr != 0) {\\n\\t\\t\\t/* invalid pseudo header -- should never happen here */\\n\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* regular header field in (name,value) */\\n\\t\\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\\n\\t\\t\\t/* no more pseudo-headers, time to build the request line */\\n\\t\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\t\\tif (!sl)\\n\\t\\t\\t\\tgoto fail;\\n\\t\\t\\tfields |= H2_PHDR_FND_NONE;\\n\\n\\t\\t\\t/* http2bis draft recommends to drop Host in favor of :authority when\\n\\t\\t\\t * the latter is present. This is required to make sure there is no\\n\\t\\t\\t * discrepancy between the authority and the host header, especially\\n\\t\\t\\t * since routing rules usually involve Host. Here we already know if\\n\\t\\t\\t * :authority was found so we can emit it right now and mark the host\\n\\t\\t\\t * as filled so that it's skipped later.\\n\\t\\t\\t */\\n\\t\\t\\tif (fields & H2_PHDR_FND_AUTH) {\\n\\t\\t\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\t\\t\\tgoto fail;\\n\\t\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"host\\\"))) {\\n\\t\\t\\tif (fields & H2_PHDR_FND_HOST)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tfields |= H2_PHDR_FND_HOST;\\n\\t\\t}\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"content-length\\\"))) {\\n\\t\\t\\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\\n\\t\\t\\tif (ret < 0)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\tsl_flags |= HTX_SL_F_CLEN;\\n\\t\\t\\tif (ret == 0)\\n\\t\\t\\t\\tcontinue; // skip this duplicate\\n\\t\\t}\\n\\n\\t\\t/* these ones are forbidden in requests (RFC7540#8.1.2.2) */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"proxy-connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"keep-alive\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"upgrade\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"transfer-encoding\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (isteq(list[idx].n, ist(\\\"te\\\")) && !isteq(list[idx].v, ist(\\\"trailers\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\t/* cookie requires special processing at the end */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"cookie\\\"))) {\\n\\t\\t\\tlist[idx].n.len = -1;\\n\\n\\t\\t\\tif (ck < 0)\\n\\t\\t\\t\\tck = idx;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlist[lck].n.len = idx;\\n\\n\\t\\t\\tlck = idx;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* RFC7540#8.1.2.1 mandates to reject response pseudo-headers (:status) */\\n\\tif (fields & H2_PHDR_FND_STAT)\\n\\t\\tgoto fail;\\n\\n\\t/* Let's dump the request now if not yet emitted. */\\n\\tif (!(fields & H2_PHDR_FND_NONE)) {\\n\\t\\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\\n\\t\\tif (!sl)\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_BODY_TUNNEL)\\n\\t\\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\\n\\n\\tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\\n\\t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\\n\\t\\t/* Request without body or tunnel requested */\\n\\t\\tsl_flags |= HTX_SL_F_BODYLESS;\\n\\t\\thtx->flags |= HTX_FL_EOM;\\n\\t}\\n\\n\\tif (*msgf & H2_MSGF_EXT_CONNECT) {\\n\\t\\tif (!htx_add_header(htx, ist(\\\"upgrade\\\"), phdr_val[H2_PHDR_IDX_PROT]))\\n\\t\\t\\tgoto fail;\\n\\t\\tif (!htx_add_header(htx, ist(\\\"connection\\\"), ist(\\\"upgrade\\\")))\\n\\t\\t\\tgoto fail;\\n\\t\\tsl_flags |= HTX_SL_F_CONN_UPG;\\n\\t}\\n\\n\\t/* update the start line with last detected header info */\\n\\tsl->flags |= sl_flags;\\n\\n\\t/* complete with missing Host if needed (we may validate this test if\\n\\t * no regular header was found).\\n\\t */\\n\\tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\\n\\t\\t/* missing Host field, use :authority instead */\\n\\t\\tif (!htx_add_header(htx, ist(\\\"host\\\"), phdr_val[H2_PHDR_IDX_AUTH]))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\t/* now we may have to build a cookie list. We'll dump the values of all\\n\\t * visited headers.\\n\\t */\\n\\tif (ck >= 0) {\\n\\t\\tuint32_t fs; // free space\\n\\t\\tuint32_t bs; // block size\\n\\t\\tuint32_t vl; // value len\\n\\t\\tuint32_t tl; // total length\\n\\t\\tstruct htx_blk *blk;\\n\\n\\t\\tblk = htx_add_header(htx, ist(\\\"cookie\\\"), list[ck].v);\\n\\t\\tif (!blk)\\n\\t\\t\\tgoto fail;\\n\\n\\t\\ttl = list[ck].v.len;\\n\\t\\tfs = htx_free_data_space(htx);\\n\\t\\tbs = htx_get_blksz(blk);\\n\\n\\t\\t/* for each extra cookie, we'll extend the cookie's value and\\n\\t\\t * insert \\\"; \\\" before the new value.\\n\\t\\t */\\n\\t\\tfs += tl; // first one is already counted\\n\\t\\twhile ((ck = list[ck].n.len) >= 0) {\\n\\t\\t\\tvl = list[ck].v.len;\\n\\t\\t\\ttl += vl + 2;\\n\\t\\t\\tif (tl > fs)\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t\\thtx_change_blk_value_len(htx, blk, tl);\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\\n\\t\\t\\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\\n\\t\\t\\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\\n\\t\\t\\tbs += vl + 2;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/* now send the end of headers marker */\\n\\tif (!htx_add_endof(htx, HTX_BLK_EOH))\\n\\t\\tgoto fail;\\n\\n\\t/* proceed to scheme-based normalization on target-URI */\\n\\tif (fields & H2_PHDR_FND_SCHM)\\n\\t\\thttp_scheme_based_normalize(htx);\\n\\n\\tret = 1;\\n\\treturn ret;\\n\\n fail:\\n\\treturn -1;\\n}\\n\",\n            \"caller_start\": 389,\n            \"file_path\": \"src/h2.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(file:htx.h, func:htx_add_trailer)\",\n        \"result\": [\n          {\n            \"call_line\": 536,\n            \"call_code\": \"htx_add_trailer(htx, hdrs[i].n, hdrs[i].v)\",\n            \"caller_code\": \"static inline struct htx_blk *htx_add_all_trailers(struct htx *htx, const struct http_hdr *hdrs)\\n{\\n\\tint i;\\n\\n\\tfor (i = 0; hdrs[i].n.len; i++) {\\n\\t\\tif (!htx_add_trailer(htx, hdrs[i].n, hdrs[i].v))\\n\\t\\t\\treturn NULL;\\n\\t}\\n\\treturn htx_add_endof(htx, HTX_BLK_EOT);\\n}\",\n            \"caller_start\": 531,\n            \"file_path\": \"include/haproxy/htx.h\"\n          },\n          {\n            \"call_line\": 907,\n            \"call_code\": \"htx_add_trailer(htx, list[idx].n, list[idx].v)\",\n            \"caller_code\": \"int h2_make_htx_trailers(struct http_hdr *list, struct htx *htx)\\n{\\n\\tconst char *ctl;\\n\\tuint32_t idx;\\n\\tint i;\\n\\n\\tfor (idx = 0; list[idx].n.len != 0; idx++) {\\n\\t\\tif (!list[idx].n.ptr) {\\n\\t\\t\\t/* This is an indexed pseudo-header (RFC7540#8.1.2.1) */\\n\\t\\t\\tgoto fail;\\n\\t\\t}\\n\\n\\t\\t/* RFC7540#8.1.2: upper case not allowed in header field names.\\n\\t\\t * #10.3: header names must be valid (i.e. match a token). This\\n\\t\\t * also catches pseudo-headers which are forbidden in trailers.\\n\\t\\t */\\n\\t\\tfor (i = 0; i < list[idx].n.len; i++)\\n\\t\\t\\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\\n\\t\\t\\t\\tgoto fail;\\n\\n\\t\\t/* these ones are forbidden in trailers (RFC7540#8.1.2.2) */\\n\\t\\tif (isteq(list[idx].n, ist(\\\"host\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"content-length\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"proxy-connection\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"keep-alive\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"upgrade\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"te\\\")) ||\\n\\t\\t    isteq(list[idx].n, ist(\\\"transfer-encoding\\\")))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\\n\\t\\t * rejecting NUL, CR and LF characters.\\n\\t\\t */\\n\\t\\tctl = ist_find_ctl(list[idx].v);\\n\\t\\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\\n\\t\\t\\tgoto fail;\\n\\n\\t\\tif (!htx_add_trailer(htx, list[idx].n, list[idx].v))\\n\\t\\t\\tgoto fail;\\n\\t}\\n\\n\\tif (!htx_add_endof(htx, HTX_BLK_EOT))\\n\\t\\tgoto fail;\\n\\n\\treturn 1;\\n\\n fail:\\n\\treturn -1;\\n}\\n\",\n            \"caller_start\": 869,\n            \"file_path\": \"src/h2.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The vulnerability stems from missing length checks in `htx_add_header` and `htx_add_trailer`, enabling header/trailer name and value overflows. The root cause is the unchecked `name.len` (stored as 8 bits) and `value.len` (stored as 16 bits) in `blk->info`, which can be manipulated to forge headers like `Content-Length` after deduplication. Attackers exploit HTTP/2 header parsing (via `h2_make_htx_request`) to inject malicious headers, bypassing ACLs and enabling smuggling. The chain is now fully evidenced from HTTP/2 input parsing to HTX block creation.",
                "need_context": false,
                "root_cause": "Missing length checks in `htx_add_header` (include/haproxy/htx.h:467) and `htx_add_trailer` (include/haproxy/htx.h:486) allowed `name.len` and `value.len` to overflow. Specifically:\\n1. `name.len` (8-bit field in `blk->info`) could overflow if >255 bytes, corrupting `value.len` (16-bit field).\\n2. `h2_make_htx_request` (src/h2.c:389) parses HTTP/2 headers into HTX blocks via `htx_add_header`, which lacked length checks until patched.\\n3. A malicious HTTP/2 header (e.g., `Content-Length`) could bypass deduplication checks, enabling smuggling by misaligning request parsing between upstream/downstream servers.",
                "confidence_score": 0.95,
                "attack_vectors": [
                    "HTTP/2 client sends a header with a name >255 bytes, causing `name.len` overflow in `blk->info` (src/h2.c:515).",
                    "Forged `Content-Length` header injected after deduplication, allowing request smuggling by splitting the HTTP message."
                ]
            },
            "timestamp": "2025-05-26T15:48:40.556967"
        }
    ],
    "debug_trace": [
        "Collected 2 context items. (0 failed)",
        "Performed analysis iteration 1. Needs more context: True. Confidence: 0.85",
        "Collected 2 context items. (0 failed)",
        "Performed analysis iteration 2. Needs more context: False. Confidence: 0.95",
        "Report generation completed."
    ],
    "status": "completed",
    "error": null
}