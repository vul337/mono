{
    "patch": [
        {
            "func_name": "CEAnsi::ReportString",
            "patch": "--- func_before\n+++ func_after\n@@ -988,7 +988,7 @@\n \tLPCWSTR pc = asRet;\n \tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n \t{\n-\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n+\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n \t\tp->EventType = KEY_EVENT;\n \t\tp->Event.KeyEvent.bKeyDown = TRUE;\n \t\tp->Event.KeyEvent.wRepeatCount = 1;",
            "file_path": "src/ConEmuHk/Ansi.cpp"
        },
        {
            "func_name": "SrvAnsiImpl::ReportString",
            "patch": "--- func_before\n+++ func_after\n@@ -986,7 +986,7 @@\n \tLPCWSTR pc = asRet;\n \tfor (int i = 0; i < nLen; i++, p++, pc++)\n \t{\n-\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n+\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n \t\tp->EventType = KEY_EVENT;\n \t\tp->Event.KeyEvent.bKeyDown = TRUE;\n \t\tp->Event.KeyEvent.wRepeatCount = 1;",
            "file_path": "src/ConEmuCD/ConAnsiImpl.cpp"
        }
    ],
    "description": "ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387.",
    "msg": "gh-2536: Do not emit control characters in title reports (capability fix).",
    "root_cause": "Original code in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) replaced control characters (<0x20) with spaces. The patch allows 0x1B (escape) but does not validate subsequent characters in ANSI sequences. After sanitization, `DumpKnownEscape(asRet, nLen, de_Report)` (src/ConEmuHk/Ansi.cpp:2515, src/ConEmuCD/ConAnsiImpl.cpp:998) processes the input. If this function does not validate the structure or content of escape sequences, malicious sequences could inject unintended behavior. GAP: Implementation of `DumpKnownEscape` is not visible.",
    "confidence_score": 0.75,
    "enriched_data": [
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'ReportString', 'project_dir': './storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                    "start_line": 974,
                    "end_line": 1004,
                    "full_name": "SrvAnsiImpl.ReportString:bool(LPCWSTR)",
                    "file_path": "src/ConEmuCD/ConAnsiImpl.cpp"
                },
                {
                    "type": "function_def",
                    "code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                    "start_line": 2492,
                    "end_line": 2525,
                    "full_name": "CEAnsi.ReportString:BOOL(LPCWSTR)",
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "function_def",
                    "code": "BOOL ReportString(LPCWSTR asRet);",
                    "start_line": 202,
                    "end_line": 202,
                    "full_name": "CEAnsi.ReportString:ANY(LPCWSTR)",
                    "file_path": "src/ConEmuHk/Ansi.h"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'ReportString', 'project_dir': './storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                    "start_line": 974,
                    "end_line": 1004,
                    "full_name": "SrvAnsiImpl.ReportString:bool(LPCWSTR)",
                    "file_path": "src/ConEmuCD/ConAnsiImpl.cpp"
                },
                {
                    "type": "function_def",
                    "code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                    "start_line": 2492,
                    "end_line": 2525,
                    "full_name": "CEAnsi.ReportString:BOOL(LPCWSTR)",
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "function_def",
                    "code": "BOOL ReportString(LPCWSTR asRet);",
                    "start_line": 202,
                    "end_line": 202,
                    "full_name": "CEAnsi.ReportString:ANY(LPCWSTR)",
                    "file_path": "src/ConEmuHk/Ansi.h"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'DumpKnownEscape', 'project_dir': './storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 1434,
                    "call_code": "DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal)",
                    "caller_code": "BOOL CEAnsi::OurWriteConsoleW(HANDLE hConsoleOutput, const VOID *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved, bool bInternal /*= false*/)\n{\n\tORIGINAL_KRNL(WriteConsoleW);\n\tBOOL lbRc = FALSE;\n\t//ExtWriteTextParm wrt = {sizeof(wrt), ewtf_None, hConsoleOutput};\n\tbool bIsConOut = false;\n\tbool bIsAnsi = false;\n\n\tFIRST_ANSI_CALL(static_cast<const BYTE*>(lpBuffer), nNumberOfCharsToWrite);\n\n#if 0\n\t// Store prompt(?) for clink 0.1.1\n\tif ((gnAllowClinkUsage == 1) && nNumberOfCharsToWrite && lpBuffer && gpszLastWriteConsole && gcchLastWriteConsoleMax)\n\t{\n\t\tsize_t cchMax = std::min(gcchLastWriteConsoleMax-1,nNumberOfCharsToWrite);\n\t\tgpszLastWriteConsole[cchMax] = 0;\n\t\twmemmove(gpszLastWriteConsole, (const wchar_t*)lpBuffer, cchMax);\n\t}\n#endif\n\n\t// In debug builds: Write to debug console all console Output\n\tconst auto ansiIndex = DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal);\n\n#ifdef _DEBUG\n\tstruct AnsiDuration  // NOLINT(cppcoreguidelines-special-member-functions)\n\t{\n\t\tconst int ansiIndex_;\n\t\tconst std::chrono::steady_clock::time_point startTime_;\n\n\t\tAnsiDuration(const int ansiIndex)\n\t\t\t: ansiIndex_(ansiIndex), startTime_(std::chrono::steady_clock::now())\n\t\t{\n\t\t}\n\n\t\t~AnsiDuration()\n\t\t{\n\t\t\tconst auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - startTime_);\n\t\t\twchar_t info[80] = L\"\";\n\t\t\tmsprintf(info, countof(info), L\"[%u] AnsiDump #%u duration(ms): %u\\n\", GetCurrentThreadId(), ansiIndex_, duration.count());\n\t\t\tOutputDebugStringW(info);\n\t\t}\n\t};\n\tAnsiDuration duration(ansiIndex);\n#endif\n\n\tCEAnsi* pObj = nullptr;\n\tCEStr cpCvtBuffer;\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput)\n\t{\n\t\tbIsAnsi = HandleKeeper::IsAnsiCapable(hConsoleOutput, &bIsConOut);\n\n\t\tif (ghAnsiLogFile && bIsConOut)\n\t\t{\n\t\t\tCEAnsi::WriteAnsiLogW(static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite);\n\t\t}\n\t}\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput && bIsAnsi)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (!bInternal && gCpConv.nFromCP && gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from unicode to MBCS\n\t\t\tCEStrA pszTemp;\n\t\t\tint iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif ((iMbcsLen > 0) && ((pszTemp.GetBuffer(iMbcsLen)) != nullptr))\n\t\t\t{\n\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped\n\t\t\t\tiMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, pszTemp.data(), iMbcsLen, nullptr, &bFailed);\n\t\t\t\tif ((iMbcsLen > 0) && !bFailed)\n\t\t\t\t{\n\t\t\t\t\tint iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, nullptr, 0);\n\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t* ptrBuf = cpCvtBuffer.GetBuffer(iWideLen);\n\t\t\t\t\t\tif (ptrBuf)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t{\n\t\t\tif (pObj->gnPrevAnsiPart || gDisplayOpt.WrapWasSet)\n\t\t\t{\n\t\t\t\t// Если остался \"хвост\" от предущей записи - сразу, без проверок\n\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\tgoto ansidone;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_ASSERTEX(ESC==27 && BEL==7 && DSC==0x90);\n\t\t\t\tconst wchar_t* pch = static_cast<const wchar_t*>(lpBuffer);\n\t\t\t\tfor (size_t i = nNumberOfCharsToWrite; i--; pch++)\n\t\t\t\t{\n\t\t\t\t\t// Если в выводимой строке встречается \"Ansi ESC Code\" - выводим сами\n\t\t\t\t\tTODO(\"Non-CSI codes, like as BEL, BS, CR, LF, FF, TAB, VT, SO, SI\");\n\t\t\t\t\tif (*pch == ESC /*|| *pch == BEL*/ /*|| *pch == ENQ*/)\n\t\t\t\t\t{\n\t\t\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\t\t\tgoto ansidone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!bIsAnsi || ((pObj = CEAnsi::Object()) == nullptr))\n\t{\n\t\tlbRc = F(WriteConsoleW)(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n\t}\n\telse\n\t{\n\t\tlbRc = pObj->WriteText(F(WriteConsoleW), hConsoleOutput, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten, TRUE);\n\t\t//wrt.Flags = ewtf_Current|ewtf_Commit;\n\t\t//wrt.Buffer = (const wchar_t*)lpBuffer;\n\t\t//wrt.NumberOfCharsToWrite = nNumberOfCharsToWrite;\n\t\t//wrt.Private = F(WriteConsoleW);\n\t\t//lbRc = ExtWriteText(&wrt);\n\t\t//if (lbRc)\n\t\t//{\n\t\t//\tif (lpNumberOfCharsWritten)\n\t\t//\t\t*lpNumberOfCharsWritten = wrt.NumberOfCharsWritten;\n\t\t//\tif (wrt.ScrolledRowsUp > 0)\n\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)wrt.ScrolledRowsUp));\n\t\t//}\n\t}\n\tgoto wrap;\n\nansidone:\n\t{\n\t\tExtCommitParm cmt = {sizeof(cmt), hConsoleOutput};\n\t\tExtCommit(&cmt);\n\t}\nwrap:\n\treturn lbRc;\n}\n",
                    "caller_start": 1413,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "caller_info",
                    "call_line": 1740,
                    "call_code": "DumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl)",
                    "caller_code": "int CEAnsi::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, CEAnsi::AnsiEscCode& Code, BOOL ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tconst INT_PTR nCurPrevLen = gnPrevAnsiPart;\n\t\t\tconst INT_PTR nAdd = std::min((lpEnd-lpBuffer),static_cast<INT_PTR>(countof(gsPrevAnsiPart))-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX(static_cast<INT_PTR>(countof(gsPrevAnsiPart)) > (nCurPrevLen + nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING(\"Проверить!!!\");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tconst int iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart + nAdd + gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst INT_PTR nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen > 0 && nSkipLen <= static_cast<INT_PTR>(countof(gsPrevAnsiPart)) && nSkipLen <= gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(writeConsoleW, hConsoleOutput, gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= (static_cast<int>(CEAnsi_MaxPrevPart) - static_cast<int>(cchPrevPart)));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += static_cast<int>(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING(\"Проверить!!!\");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && \"Invalid esc sequence, need dump to screen?\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tINT_PTR nLeft;\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like \"ESC 7\" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some \"special\" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'7': // Save xterm cursor\n\t\t\t\t\tcase L'8': // Restore xterm cursor\n\t\t\t\t\tcase L'c': // Full reset\n\t\t\t\t\tcase L'g': // Visual Bell\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\tcase L'H': // Horizontal Tab Set\n\t\t\t\t\tcase L'M': // Reverse LF\n\t\t\t\t\tcase L'E': // CR-LF\n\t\t\t\t\tcase L'D': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO(\"Bypass unrecognized ESC sequences to screen? Don't try to eliminate 'Possible' sequences?\");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* '|' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L\"[]|()%\", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk=\"VK_ESCAPE\" [27/0x001B], Scan=0x0001 uChar=[U='\\x1b' (0x001B): A='\\x1b' (0x1B)]\n\t\t\t\t\t\tconst bool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart - 1) == L'\\'' && Code.Second == L'\\'') || (*(lpSaveStart - 1) == L' ' && Code.Second == L' '));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && \"Unsupported control sequence?\");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now parameters go\n\t\t\t\t\t++lpBuffer; // move pointer to the first char beyond CSI (after '[')\n\n\t\t\t\t\tauto parseNumArgs = [&Code](const wchar_t* &lpBufferParam, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wcSave;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBufferParam < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBufferParam)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L'0': case L'1': case L'2': case L'3': case L'4':\n\t\t\t\t\t\t\tcase L'5': case L'6': case L'7': case L'8': case L'9':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (static_cast<int>(*lpBufferParam) - L'0');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L';':\n\t\t\t\t\t\t\t\t// Even if there were no digits - default is \"0\"\n\t\t\t\t\t\t\t\tif (Code.ArgC < static_cast<int>(countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L']')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (((wcSave = *lpBufferParam) >= 64) && (wcSave <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wcSave;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((static_cast<size_t>(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wcSave; // Skip private symbols\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBufferParam;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L']');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'(':\n\t\t\t\t\tcase L')':\n\t\t\t\t\tcase L'%':\n\t\t\t\t\t//case L'#':\n\t\t\t\t\t//case L'*':\n\t\t\t\t\t//case L'+':\n\t\t\t\t\t//case L'-':\n\t\t\t\t\t//case L'.':\n\t\t\t\t\t//case L'/':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\t// ReSharper disable once CppDeclaratorNeverUsed\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// В данном запросе (на запись) конца последовательности нет,\n\t\t\t\t\t\t// оставшийся хвост нужно сохранить в буфере, для следующего запроса\n\t\t\t\t\t\t// Ниже\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t\t\t\t\t\t// \"%]4;16;rgb:00/00/00%\\\" - \"%\" is ESC\n\t\t\t\t\t\t// \"%]0;this is the window titleBEL\"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t\t\t\t\t// and others... look at CEAnsi::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we'll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // первый символ последовательности\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L'\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of \"switch (Code.Second)\"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && \"Need to be checked!\"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && \"Too long Esc-sequence part, Need to be checked!\");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of \"case 27:\"\n\t\t} // end of \"switch (*lpBuffer)\"\n\n\t\t++lpBuffer;\n\t} // end of \"while (lpBuffer < lpEnd)\"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n",
                    "caller_start": 1585,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "caller_info",
                    "call_line": 2515,
                    "call_code": "DumpKnownEscape(asRet, nLen, de_Report)",
                    "caller_code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                    "caller_start": 2492,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "caller_info",
                    "call_line": 2734,
                    "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                    "caller_code": "BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n",
                    "caller_start": 2608,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "caller_info",
                    "call_line": 2749,
                    "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                    "caller_code": "BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n",
                    "caller_start": 2608,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "caller_info",
                    "call_line": 2765,
                    "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                    "caller_code": "BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n",
                    "caller_start": 2608,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "caller_info",
                    "call_line": 3286,
                    "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                    "caller_code": "void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport's upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO(\"Need to clear attributes?\");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'K':\n\t\tbreak;\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO(\"Define scrolling region\");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L'h');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mouse wheel reporting */\n\t\t\tcase 7787: /* 'W': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L'h'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can't implement all possible styles in RealConsole,\n\t\t\t\t// but we can use \"Block/Underline\" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n",
                    "caller_start": 2829,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                },
                {
                    "type": "caller_info",
                    "call_line": 3328,
                    "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                    "caller_code": "void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport's upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO(\"Need to clear attributes?\");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'K':\n\t\tbreak;\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO(\"Define scrolling region\");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L'h');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mouse wheel reporting */\n\t\t\tcase 7787: /* 'W': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L'h'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can't implement all possible styles in RealConsole,\n\t\t\t\t// but we can use \"Block/Underline\" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n",
                    "caller_start": 2829,
                    "file_path": "src/ConEmuHk/Ansi.cpp"
                }
            ]
        }
    ],
    "analysis": {
        "patch": [
            {
                "func_name": "CEAnsi::ReportString",
                "patch": "--- func_before\n+++ func_after\n@@ -988,7 +988,7 @@\n \tLPCWSTR pc = asRet;\n \tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n \t{\n-\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n+\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n \t\tp->EventType = KEY_EVENT;\n \t\tp->Event.KeyEvent.bKeyDown = TRUE;\n \t\tp->Event.KeyEvent.wRepeatCount = 1;",
                "file_path": "src/ConEmuHk/Ansi.cpp"
            },
            {
                "func_name": "SrvAnsiImpl::ReportString",
                "patch": "--- func_before\n+++ func_after\n@@ -986,7 +986,7 @@\n \tLPCWSTR pc = asRet;\n \tfor (int i = 0; i < nLen; i++, p++, pc++)\n \t{\n-\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n+\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n \t\tp->EventType = KEY_EVENT;\n \t\tp->Event.KeyEvent.bKeyDown = TRUE;\n \t\tp->Event.KeyEvent.wRepeatCount = 1;",
                "file_path": "src/ConEmuCD/ConAnsiImpl.cpp"
            }
        ],
        "msg": "gh-2536: Do not emit control characters in title reports (capability fix).",
        "description": "ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387.",
        "language": "cpp",
        "vulnerability_type": "logic",
        "repair_strategy": "The patch modifies the condition in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) to allow the escape character (0x1B) while retaining filtering of other control characters (<0x20). This changes the sanitization logic to explicitly permit ANSI escape sequences while blocking other unsafe control characters.",
        "need_context": true,
        "required_context": [
            "function: DumpKnownEscape"
        ],
        "confidence_score": 0.75,
        "root_cause": "Original code in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) replaced control characters (<0x20) with spaces. The patch allows 0x1B (escape) but does not validate subsequent characters in ANSI sequences. After sanitization, `DumpKnownEscape(asRet, nLen, de_Report)` (src/ConEmuHk/Ansi.cpp:2515, src/ConEmuCD/ConAnsiImpl.cpp:998) processes the input. If this function does not validate the structure or content of escape sequences, malicious sequences could inject unintended behavior. GAP: Implementation of `DumpKnownEscape` is not visible.",
        "analysis": "The root cause involves improper sanitization of control characters in `ReportString` functions. The patch allows 0x1B (escape) for ANSI sequences but prior handling of these sequences (e.g., in `DumpKnownEscape`) is not visible. The trigger chain involves unvalidated escape sequences reaching unsafe processing logic. A critical gap exists in the implementation of `DumpKnownEscape`, which is called after character sanitization but before console input."
    },
    "iteration": 2,
    "history": [
        {
            "stage": "initial",
            "prompt": "You are a senior security engineer. Using **only the provided patch and description**, and **restricted to context retrievable by the 'caller' and 'function' tools**, perform the initial vulnerability analysis.\n\n## INPUTS\n- **Commit Message**: gh-2536: Do not emit control characters in title reports (capability fix).\n- **Vulnerability Description**: ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387.\n- **Patch Code**: [{'func_name': 'CEAnsi::ReportString', 'patch': \"--- func_before\\n+++ func_after\\n@@ -988,7 +988,7 @@\\n \\tLPCWSTR pc = asRet;\\n \\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\\n \\t{\\n-\\t\\tconst char ch = *pc >= 0x20 ? *pc : L' ';\\n+\\t\\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\\n \\t\\tp->EventType = KEY_EVENT;\\n \\t\\tp->Event.KeyEvent.bKeyDown = TRUE;\\n \\t\\tp->Event.KeyEvent.wRepeatCount = 1;\", 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'func_name': 'SrvAnsiImpl::ReportString', 'patch': \"--- func_before\\n+++ func_after\\n@@ -986,7 +986,7 @@\\n \\tLPCWSTR pc = asRet;\\n \\tfor (int i = 0; i < nLen; i++, p++, pc++)\\n \\t{\\n-\\t\\tconst char ch = *pc >= 0x20 ? *pc : L' ';\\n+\\t\\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\\n \\t\\tp->EventType = KEY_EVENT;\\n \\t\\tp->Event.KeyEvent.bKeyDown = TRUE;\\n \\t\\tp->Event.KeyEvent.wRepeatCount = 1;\", 'file_path': 'src/ConEmuCD/ConAnsiImpl.cpp'}]\n\n## INSTRUCTIONS\n1. **Patch Review**  \n   • Detect primary language (`c`, `cpp`, `java`).  \n   • Classify vulnerability (`memory`, `logic`, `config`).  \n   • Explain how each patch hunk mitigates risk, citing `file:line`.  \n   → Populate `language`, `vulnerability_type`, `repair_rationale`.\n\n2. **Trace Root Cause within Patch**  \n   Follow calls / data flow in the patch, citing `file:line`.  \n   Where evidence ends, insert: `GAP: <why evidence stops>` → build `root_cause`.\n\n3. **Determine Missing Context (tools limited)**  \n   If gaps remain:  \n     • set `\"need_context\": true`  \n     • add precise, non-duplicate requests to `\"required_context\"` using **only**:  \n       - `function: …`  \n       - `caller: …`  \n   If the chain is fully evidenced from the patch, set `\"need_context\": false`.\n\n4. **Confidence Score**  \n   Set `confidence_score ≥ 0.90` only if the full chain is evidenced; otherwise `≤ 0.75`.\n\n## OUTPUT (MUST valid JSON — double quotes, no trailing commas)\n```json\n  {\n      \"language\": \"c | cpp | java\",\n      \"vulnerability_type\": \"memory | logic | config\",\n      \"repair_strategy\": \"<citing file:line from the patch>\",\n      \"analysis\": \"<Synthesis from Process Step 2. If full chain evident, explain that. If context needed, explain why requested context is essential to bridge gaps.>\",\n      \"need_context\": true | false, //false ONLY IF the full pattern was unambiguously evident from patch alone.\n      \"required_context\": \"<list of precise context requests if any context needed>\" ,\n      \"root_cause\": \"\"<Partial/complete trace with file:line evidence from the patch, noting gaps. If full chain evident, provide it.>\",\n      \"confidence_score\": 0.0-1.0 // Confidence in understanding the *full* path based on *this initial analysis phase*\n  }\n  ```\n\n## RULES\n* **Output must be valid JSON (no trailing commas).**\n* **Source-of-Truth** – Cite only code visible in the patch (`file:line`). Commit message / description are auxiliary.\n* **Zero-Assumption** – Never infer. Missing evidence → declare GAP, set `need_context=true`, and request context with allowed tools.\n* **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n* **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "language": "cpp",
                "vulnerability_type": "logic",
                "repair_strategy": "The patch modifies the condition in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) to allow the escape character (0x1B) while retaining filtering of other control characters (<0x20). This changes the sanitization logic to explicitly permit ANSI escape sequences while blocking other unsafe control characters.",
                "analysis": "The root cause lies in insufficient sanitization of control characters in title responses. The patch allows 0x1B (escape) through, which may be part of ANSI escape sequences, but the full handling of these sequences is not visible in the patch. Without examining how the `ReportString` functions process these sequences (e.g., parsing logic for escape codes), the chain of execution leading to arbitrary code execution remains incomplete. The vulnerability likely stems from improper validation of the full escape sequence after this sanitization step.",
                "need_context": true,
                "required_context": [
                    "function: CEAnsi::ReportString",
                    "function: SrvAnsiImpl::ReportString"
                ],
                "root_cause": "The original code in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) replaced all control characters (<0x20) with spaces. The patch adds an exception for 0x1B (escape), allowing ANSI escape sequences. If subsequent processing of these sequences does not validate their structure or content, malicious sequences could trigger unintended behavior. GAP: The implementation of `ReportString` beyond the patch lines is not visible, making it impossible to confirm if escape sequences are safely handled.",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-29T22:15:59.199492"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: CEAnsi::ReportString",
                "function: SrvAnsiImpl::ReportString"
            ],
            "results": [
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'ReportString', 'project_dir': './storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                            "start_line": 974,
                            "end_line": 1004,
                            "full_name": "SrvAnsiImpl.ReportString:bool(LPCWSTR)",
                            "file_path": "src/ConEmuCD/ConAnsiImpl.cpp"
                        },
                        {
                            "type": "function_def",
                            "code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                            "start_line": 2492,
                            "end_line": 2525,
                            "full_name": "CEAnsi.ReportString:BOOL(LPCWSTR)",
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "function_def",
                            "code": "BOOL ReportString(LPCWSTR asRet);",
                            "start_line": 202,
                            "end_line": 202,
                            "full_name": "CEAnsi.ReportString:ANY(LPCWSTR)",
                            "file_path": "src/ConEmuHk/Ansi.h"
                        }
                    ]
                },
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'ReportString', 'project_dir': './storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                            "start_line": 974,
                            "end_line": 1004,
                            "full_name": "SrvAnsiImpl.ReportString:bool(LPCWSTR)",
                            "file_path": "src/ConEmuCD/ConAnsiImpl.cpp"
                        },
                        {
                            "type": "function_def",
                            "code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                            "start_line": 2492,
                            "end_line": 2525,
                            "full_name": "CEAnsi.ReportString:BOOL(LPCWSTR)",
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "function_def",
                            "code": "BOOL ReportString(LPCWSTR asRet);",
                            "start_line": 202,
                            "end_line": 202,
                            "full_name": "CEAnsi.ReportString:ANY(LPCWSTR)",
                            "file_path": "src/ConEmuHk/Ansi.h"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-29T22:16:28.817661"
        },
        {
            "stage": "analysis",
            "iteration": 1,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: gh-2536: Do not emit control characters in title reports (capability fix).\n- **Vulnerability Description**: ConEmu before commit 230724 does not sanitize title responses correctly for control characters, potentially leading to arbitrary code execution. This is related to an incomplete fix for CVE-2022-46387.\n- **Patch Code**: [{'func_name': 'CEAnsi::ReportString', 'patch': \"--- func_before\\n+++ func_after\\n@@ -988,7 +988,7 @@\\n \\tLPCWSTR pc = asRet;\\n \\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\\n \\t{\\n-\\t\\tconst char ch = *pc >= 0x20 ? *pc : L' ';\\n+\\t\\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\\n \\t\\tp->EventType = KEY_EVENT;\\n \\t\\tp->Event.KeyEvent.bKeyDown = TRUE;\\n \\t\\tp->Event.KeyEvent.wRepeatCount = 1;\", 'file_path': 'src/ConEmuHk/Ansi.cpp'}, {'func_name': 'SrvAnsiImpl::ReportString', 'patch': \"--- func_before\\n+++ func_after\\n@@ -986,7 +986,7 @@\\n \\tLPCWSTR pc = asRet;\\n \\tfor (int i = 0; i < nLen; i++, p++, pc++)\\n \\t{\\n-\\t\\tconst char ch = *pc >= 0x20 ? *pc : L' ';\\n+\\t\\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\\n \\t\\tp->EventType = KEY_EVENT;\\n \\t\\tp->Event.KeyEvent.bKeyDown = TRUE;\\n \\t\\tp->Event.KeyEvent.wRepeatCount = 1;\", 'file_path': 'src/ConEmuCD/ConAnsiImpl.cpp'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"cpp\",\n      \"vulnerability_type\": \"logic\",\n      \"repair_strategy\": \"The patch modifies the condition in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) to allow the escape character (0x1B) while retaining filtering of other control characters (<0x20). This changes the sanitization logic to explicitly permit ANSI escape sequences while blocking other unsafe control characters.\",\n      \"required_context\": [\n        \"function: CEAnsi::ReportString\",\n        \"function: SrvAnsiImpl::ReportString\"\n      ],\n      \"root_cause\": \"The original code in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) replaced all control characters (<0x20) with spaces. The patch adds an exception for 0x1B (escape), allowing ANSI escape sequences. If subsequent processing of these sequences does not validate their structure or content, malicious sequences could trigger unintended behavior. GAP: The implementation of `ReportString` beyond the patch lines is not visible, making it impossible to confirm if escape sequences are safely handled.\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:ReportString)\",\n        \"result\": [\n          {\n            \"code\": \"bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\\n{\\n\\tif (!asRet || !*asRet)\\n\\t\\treturn FALSE;\\n\\tINPUT_RECORD ir[16] = {};\\n\\tint nLen = lstrlen(asRet);\\n\\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\\n\\tif (!pir)\\n\\t\\treturn FALSE;\\n\\n\\tINPUT_RECORD* p = pir;\\n\\tLPCWSTR pc = asRet;\\n\\tfor (int i = 0; i < nLen; i++, p++, pc++)\\n\\t{\\n\\t\\tconst char ch = *pc >= 0x20 ? *pc : L' ';\\n\\t\\tp->EventType = KEY_EVENT;\\n\\t\\tp->Event.KeyEvent.bKeyDown = TRUE;\\n\\t\\tp->Event.KeyEvent.wRepeatCount = 1;\\n\\t\\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\\n\\t}\\n\\n\\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\\n\\n\\tDWORD nWritten = 0;\\n\\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\\n\\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\\n\\n\\tif (pir != ir)\\n\\t\\tfree(pir);\\n\\treturn bSuccess;\\n}\",\n            \"start_line\": 974,\n            \"end_line\": 1004,\n            \"full_name\": \"SrvAnsiImpl.ReportString:bool(LPCWSTR)\",\n            \"file_path\": \"src/ConEmuCD/ConAnsiImpl.cpp\"\n          },\n          {\n            \"code\": \"BOOL CEAnsi::ReportString(LPCWSTR asRet)\\n{\\n\\tif (!asRet || !*asRet)\\n\\t\\treturn FALSE;\\n\\tINPUT_RECORD ir[16] = {};\\n\\tconst size_t nLen = wcslen(asRet);\\n\\tif (nLen > std::numeric_limits<DWORD>::max())\\n\\t\\treturn false;\\n\\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\\n\\tif (!pir)\\n\\t\\treturn FALSE;\\n\\n\\tINPUT_RECORD* p = pir;\\n\\tLPCWSTR pc = asRet;\\n\\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\\n\\t{\\n\\t\\tconst char ch = *pc >= 0x20 ? *pc : L' ';\\n\\t\\tp->EventType = KEY_EVENT;\\n\\t\\tp->Event.KeyEvent.bKeyDown = TRUE;\\n\\t\\tp->Event.KeyEvent.wRepeatCount = 1;\\n\\t\\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\\n\\t}\\n\\n\\tDumpKnownEscape(asRet, nLen, de_Report);\\n\\n\\tDWORD nWritten = 0;\\n\\t// ReSharper disable once CppLocalVariableMayBeConst\\n\\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\\n\\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\\n\\n\\tif (pir != ir)\\n\\t\\tfree(pir);\\n\\treturn bSuccess;\\n}\",\n            \"start_line\": 2492,\n            \"end_line\": 2525,\n            \"full_name\": \"CEAnsi.ReportString:BOOL(LPCWSTR)\",\n            \"file_path\": \"src/ConEmuHk/Ansi.cpp\"\n          },\n          {\n            \"code\": \"BOOL ReportString(LPCWSTR asRet);\",\n            \"start_line\": 202,\n            \"end_line\": 202,\n            \"full_name\": \"CEAnsi.ReportString:ANY(LPCWSTR)\",\n            \"file_path\": \"src/ConEmuHk/Ansi.h\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence* ≥ 0.90.  Incomplete chain ≤ 0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth** – Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause involves improper sanitization of control characters in `ReportString` functions. The patch allows 0x1B (escape) for ANSI sequences but prior handling of these sequences (e.g., in `DumpKnownEscape`) is not visible. The trigger chain involves unvalidated escape sequences reaching unsafe processing logic. A critical gap exists in the implementation of `DumpKnownEscape`, which is called after character sanitization but before console input.",
                "need_context": true,
                "required_context": [
                    "function: DumpKnownEscape"
                ],
                "root_cause": "Original code in `CEAnsi::ReportString` (src/ConEmuHk/Ansi.cpp:988) and `SrvAnsiImpl::ReportString` (src/ConEmuCD/ConAnsiImpl.cpp:986) replaced control characters (<0x20) with spaces. The patch allows 0x1B (escape) but does not validate subsequent characters in ANSI sequences. After sanitization, `DumpKnownEscape(asRet, nLen, de_Report)` (src/ConEmuHk/Ansi.cpp:2515, src/ConEmuCD/ConAnsiImpl.cpp:998) processes the input. If this function does not validate the structure or content of escape sequences, malicious sequences could inject unintended behavior. GAP: Implementation of `DumpKnownEscape` is not visible.",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-29T22:17:08.962117"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: DumpKnownEscape"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'DumpKnownEscape', 'project_dir': './storage/result/Part2_result/github/CVE-2023-39150/old_repos/Maximus5-ConEmu_36e1571'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 1434,
                            "call_code": "DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal)",
                            "caller_code": "BOOL CEAnsi::OurWriteConsoleW(HANDLE hConsoleOutput, const VOID *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved, bool bInternal /*= false*/)\n{\n\tORIGINAL_KRNL(WriteConsoleW);\n\tBOOL lbRc = FALSE;\n\t//ExtWriteTextParm wrt = {sizeof(wrt), ewtf_None, hConsoleOutput};\n\tbool bIsConOut = false;\n\tbool bIsAnsi = false;\n\n\tFIRST_ANSI_CALL(static_cast<const BYTE*>(lpBuffer), nNumberOfCharsToWrite);\n\n#if 0\n\t// Store prompt(?) for clink 0.1.1\n\tif ((gnAllowClinkUsage == 1) && nNumberOfCharsToWrite && lpBuffer && gpszLastWriteConsole && gcchLastWriteConsoleMax)\n\t{\n\t\tsize_t cchMax = std::min(gcchLastWriteConsoleMax-1,nNumberOfCharsToWrite);\n\t\tgpszLastWriteConsole[cchMax] = 0;\n\t\twmemmove(gpszLastWriteConsole, (const wchar_t*)lpBuffer, cchMax);\n\t}\n#endif\n\n\t// In debug builds: Write to debug console all console Output\n\tconst auto ansiIndex = DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal);\n\n#ifdef _DEBUG\n\tstruct AnsiDuration  // NOLINT(cppcoreguidelines-special-member-functions)\n\t{\n\t\tconst int ansiIndex_;\n\t\tconst std::chrono::steady_clock::time_point startTime_;\n\n\t\tAnsiDuration(const int ansiIndex)\n\t\t\t: ansiIndex_(ansiIndex), startTime_(std::chrono::steady_clock::now())\n\t\t{\n\t\t}\n\n\t\t~AnsiDuration()\n\t\t{\n\t\t\tconst auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - startTime_);\n\t\t\twchar_t info[80] = L\"\";\n\t\t\tmsprintf(info, countof(info), L\"[%u] AnsiDump #%u duration(ms): %u\\n\", GetCurrentThreadId(), ansiIndex_, duration.count());\n\t\t\tOutputDebugStringW(info);\n\t\t}\n\t};\n\tAnsiDuration duration(ansiIndex);\n#endif\n\n\tCEAnsi* pObj = nullptr;\n\tCEStr cpCvtBuffer;\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput)\n\t{\n\t\tbIsAnsi = HandleKeeper::IsAnsiCapable(hConsoleOutput, &bIsConOut);\n\n\t\tif (ghAnsiLogFile && bIsConOut)\n\t\t{\n\t\t\tCEAnsi::WriteAnsiLogW(static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite);\n\t\t}\n\t}\n\n\tif (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput && bIsAnsi)\n\t{\n\t\t// if that was API call of WriteConsoleW\n\t\tif (!bInternal && gCpConv.nFromCP && gCpConv.nToCP)\n\t\t{\n\t\t\t// Convert from unicode to MBCS\n\t\t\tCEStrA pszTemp;\n\t\t\tint iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);\n\t\t\tif ((iMbcsLen > 0) && ((pszTemp.GetBuffer(iMbcsLen)) != nullptr))\n\t\t\t{\n\t\t\t\tBOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped\n\t\t\t\tiMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, pszTemp.data(), iMbcsLen, nullptr, &bFailed);\n\t\t\t\tif ((iMbcsLen > 0) && !bFailed)\n\t\t\t\t{\n\t\t\t\t\tint iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, nullptr, 0);\n\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t* ptrBuf = cpCvtBuffer.GetBuffer(iWideLen);\n\t\t\t\t\t\tif (ptrBuf)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, ptrBuf, iWideLen);\n\t\t\t\t\t\t\tif (iWideLen > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpBuffer = ptrBuf;\n\t\t\t\t\t\t\t\tnNumberOfCharsToWrite = iWideLen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpObj = CEAnsi::Object();\n\t\tif (pObj)\n\t\t{\n\t\t\tif (pObj->gnPrevAnsiPart || gDisplayOpt.WrapWasSet)\n\t\t\t{\n\t\t\t\t// Если остался \"хвост\" от предущей записи - сразу, без проверок\n\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\tgoto ansidone;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_ASSERTEX(ESC==27 && BEL==7 && DSC==0x90);\n\t\t\t\tconst wchar_t* pch = static_cast<const wchar_t*>(lpBuffer);\n\t\t\t\tfor (size_t i = nNumberOfCharsToWrite; i--; pch++)\n\t\t\t\t{\n\t\t\t\t\t// Если в выводимой строке встречается \"Ansi ESC Code\" - выводим сами\n\t\t\t\t\tTODO(\"Non-CSI codes, like as BEL, BS, CR, LF, FF, TAB, VT, SO, SI\");\n\t\t\t\t\tif (*pch == ESC /*|| *pch == BEL*/ /*|| *pch == ENQ*/)\n\t\t\t\t\t{\n\t\t\t\t\t\tlbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);\n\t\t\t\t\t\tgoto ansidone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!bIsAnsi || ((pObj = CEAnsi::Object()) == nullptr))\n\t{\n\t\tlbRc = F(WriteConsoleW)(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);\n\t}\n\telse\n\t{\n\t\tlbRc = pObj->WriteText(F(WriteConsoleW), hConsoleOutput, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten, TRUE);\n\t\t//wrt.Flags = ewtf_Current|ewtf_Commit;\n\t\t//wrt.Buffer = (const wchar_t*)lpBuffer;\n\t\t//wrt.NumberOfCharsToWrite = nNumberOfCharsToWrite;\n\t\t//wrt.Private = F(WriteConsoleW);\n\t\t//lbRc = ExtWriteText(&wrt);\n\t\t//if (lbRc)\n\t\t//{\n\t\t//\tif (lpNumberOfCharsWritten)\n\t\t//\t\t*lpNumberOfCharsWritten = wrt.NumberOfCharsWritten;\n\t\t//\tif (wrt.ScrolledRowsUp > 0)\n\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)wrt.ScrolledRowsUp));\n\t\t//}\n\t}\n\tgoto wrap;\n\nansidone:\n\t{\n\t\tExtCommitParm cmt = {sizeof(cmt), hConsoleOutput};\n\t\tExtCommit(&cmt);\n\t}\nwrap:\n\treturn lbRc;\n}\n",
                            "caller_start": 1413,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1740,
                            "call_code": "DumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl)",
                            "caller_code": "int CEAnsi::NextEscCode(LPCWSTR lpBuffer, LPCWSTR lpEnd, wchar_t (&szPreDump)[CEAnsi_MaxPrevPart], DWORD& cchPrevPart, LPCWSTR& lpStart, LPCWSTR& lpNext, CEAnsi::AnsiEscCode& Code, BOOL ReEntrance /*= FALSE*/)\n{\n\tint iRc = 0;\n\twchar_t wc;\n\n\tLPCWSTR lpSaveStart = lpBuffer;\n\tlpStart = lpBuffer;\n\n\t_ASSERTEX(cchPrevPart==0);\n\n\tif (gnPrevAnsiPart && !ReEntrance)\n\t{\n\t\tif (*gsPrevAnsiPart == 27)\n\t\t{\n\t\t\t_ASSERTEX(gnPrevAnsiPart < 79);\n\t\t\tconst INT_PTR nCurPrevLen = gnPrevAnsiPart;\n\t\t\tconst INT_PTR nAdd = std::min((lpEnd-lpBuffer),static_cast<INT_PTR>(countof(gsPrevAnsiPart))-nCurPrevLen-1);\n\t\t\t// Need to check buffer overflow!!!\n\t\t\t_ASSERTEX(static_cast<INT_PTR>(countof(gsPrevAnsiPart)) > (nCurPrevLen + nAdd));\n\t\t\twmemcpy(gsPrevAnsiPart+nCurPrevLen, lpBuffer, nAdd);\n\t\t\tgsPrevAnsiPart[nCurPrevLen+nAdd] = 0;\n\n\t\t\tWARNING(\"Проверить!!!\");\n\t\t\tLPCWSTR lpReStart, lpReNext;\n\t\t\tconst int iCall = NextEscCode(gsPrevAnsiPart, gsPrevAnsiPart + nAdd + gnPrevAnsiPart, szPreDump, cchPrevPart, lpReStart, lpReNext, Code, TRUE);\n\t\t\tif (iCall == 1)\n\t\t\t{\n\t\t\t\tif ((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\t// Bypass unrecognized ESC sequences to screen?\n\t\t\t\t\tif (lpReStart > gsPrevAnsiPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst INT_PTR nSkipLen = (lpReStart - gsPrevAnsiPart); //DWORD nWritten;\n\t\t\t\t\t\t_ASSERTEX(nSkipLen > 0 && nSkipLen <= static_cast<INT_PTR>(countof(gsPrevAnsiPart)) && nSkipLen <= gnPrevAnsiPart);\n\t\t\t\t\t\tDumpUnknownEscape(gsPrevAnsiPart, nSkipLen);\n\n\t\t\t\t\t\t//WriteText(writeConsoleW, hConsoleOutput, gsPrevAnsiPart, nSkipLen, &nWritten);\n\t\t\t\t\t\t_ASSERTEX(nSkipLen <= (static_cast<int>(CEAnsi_MaxPrevPart) - static_cast<int>(cchPrevPart)));\n\t\t\t\t\t\tmemmove(szPreDump, gsPrevAnsiPart, nSkipLen);\n\t\t\t\t\t\tcchPrevPart += static_cast<int>(nSkipLen);\n\n\t\t\t\t\t\tif (nSkipLen < gnPrevAnsiPart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemmove(gsPrevAnsiPart, lpReStart, (gnPrevAnsiPart - nSkipLen)*sizeof(*gsPrevAnsiPart));\n\t\t\t\t\t\t\tgnPrevAnsiPart -= nSkipLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_ASSERTEX(nSkipLen == gnPrevAnsiPart);\n\t\t\t\t\t\t\t*gsPrevAnsiPart = 0;\n\t\t\t\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlpReStart = gsPrevAnsiPart;\n\t\t\t\t\t}\n\t\t\t\t\t_ASSERTEX(lpReStart == gsPrevAnsiPart);\n\t\t\t\t\tlpStart = lpBuffer; // nothing to dump before Esc-sequence\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tWARNING(\"Проверить!!!\");\n\t\t\t\t\tlpNext = lpBuffer + (lpReNext - gsPrevAnsiPart - gnPrevAnsiPart);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX((lpReNext - gsPrevAnsiPart) >= gnPrevAnsiPart);\n\t\t\t\t\tlpStart = lpNext = lpBuffer;\n\t\t\t\t}\n\t\t\t\tgnPrevAnsiPart = 0;\n\t\t\t\tgsPrevAnsiPart[0] = 0;\n\t\t\t\tiRc = 1;\n\t\t\t\tgoto wrap2;\n\t\t\t}\n\t\t\telse if (iCall == 2)\n\t\t\t{\n\t\t\t\tgnPrevAnsiPart = nCurPrevLen+nAdd;\n\t\t\t\t_ASSERTEX(gsPrevAnsiPart[nCurPrevLen+nAdd] == 0);\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t}\n\n\t\t\t_ASSERTEX((iCall == 1) && \"Invalid esc sequence, need dump to screen?\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(*gsPrevAnsiPart == 27);\n\t\t}\n\t}\n\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tswitch (*lpBuffer)\n\t\t{\n\t\tcase 27:\n\t\t\t{\n\t\t\t\tINT_PTR nLeft;\n\t\t\t\t// ReSharper disable once CppLocalVariableMayBeConst\n\t\t\t\tLPCWSTR lpEscStart = lpBuffer;\n\n\t\t\t\t#ifdef _DEBUG\n\t\t\t\tCode.pszEscStart = lpBuffer;\n\t\t\t\tCode.nTotalLen = 0;\n\t\t\t\t#endif\n\n\t\t\t\t// Special one char codes? Like \"ESC 7\" and so on...\n\t\t\t\tif ((lpBuffer + 1) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// But it may be some \"special\" codes\n\t\t\t\t\tswitch (lpBuffer[1])\n\t\t\t\t\t{\n\t\t\t\t\tcase L'7': // Save xterm cursor\n\t\t\t\t\tcase L'8': // Restore xterm cursor\n\t\t\t\t\tcase L'c': // Full reset\n\t\t\t\t\tcase L'g': // Visual Bell\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\tcase L'H': // Horizontal Tab Set\n\t\t\t\t\tcase L'M': // Reverse LF\n\t\t\t\t\tcase L'E': // CR-LF\n\t\t\t\t\tcase L'D': // LF\n\t\t\t\t\t\t// xterm?\n\t\t\t\t\t\tlpStart = lpEscStart;\n\t\t\t\t\t\tCode.First = 27;\n\t\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\t\tCode.Pvt[0] = 0;\n\t\t\t\t\t\tlpEnd = (++lpBuffer);\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If tail is larger than 2 chars, continue\n\t\t\t\tif ((lpBuffer + 2) < lpEnd)\n\t\t\t\t{\n\t\t\t\t\t// Set lpSaveStart to current start of Esc sequence, it was set to beginning of buffer\n\t\t\t\t\t_ASSERTEX(lpSaveStart <= lpBuffer);\n\t\t\t\t\tlpSaveStart = lpBuffer;\n\t\t\t\t\t_ASSERTEX(lpSaveStart == lpEscStart);\n\n\t\t\t\t\tCode.First = 27;\n\t\t\t\t\tCode.Second = *(++lpBuffer);\n\t\t\t\t\tCode.ArgC = 0;\n\t\t\t\t\tCode.PvtLen = 0;\n\t\t\t\t\tCode.Pvt[0] = 0;\n\n\t\t\t\t\tTODO(\"Bypass unrecognized ESC sequences to screen? Don't try to eliminate 'Possible' sequences?\");\n\t\t\t\t\t//if (((Code.Second < 64) || (Code.Second > 95)) && (Code.Second != 124/* '|' - vim-xterm-emulation */))\n\t\t\t\t\tif (!wcschr(L\"[]|()%\", Code.Second))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't assert on rawdump of KeyEvents.exe Esc key presses\n\t\t\t\t\t\t// 10:00:00 KEY_EVENT_RECORD: Dn, 1, Vk=\"VK_ESCAPE\" [27/0x001B], Scan=0x0001 uChar=[U='\\x1b' (0x001B): A='\\x1b' (0x1B)]\n\t\t\t\t\t\tconst bool bStandaloneEscChar = (lpStart < lpSaveStart) && ((*(lpSaveStart - 1) == L'\\'' && Code.Second == L'\\'') || (*(lpSaveStart - 1) == L' ' && Code.Second == L' '));\n\t\t\t\t\t\t//_ASSERTEX(bStandaloneEscChar && \"Unsupported control sequence?\");\n\t\t\t\t\t\tif (!bStandaloneEscChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, std::min<size_t>(Code.nTotalLen, 32), de_UnkControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue; // invalid code\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now parameters go\n\t\t\t\t\t++lpBuffer; // move pointer to the first char beyond CSI (after '[')\n\n\t\t\t\t\tauto parseNumArgs = [&Code](const wchar_t* &lpBufferParam, const wchar_t* lpSeqEnd, bool saveAction) -> bool\n\t\t\t\t\t{\n\t\t\t\t\t\twchar_t wcSave;\n\t\t\t\t\t\tint nValue = 0, nDigits = 0;\n\t\t\t\t\t\tCode.ArgC = 0;\n\n\t\t\t\t\t\twhile (lpBufferParam < lpSeqEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (*lpBufferParam)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase L'0': case L'1': case L'2': case L'3': case L'4':\n\t\t\t\t\t\t\tcase L'5': case L'6': case L'7': case L'8': case L'9':\n\t\t\t\t\t\t\t\tnValue = (nValue * 10) + (static_cast<int>(*lpBufferParam) - L'0');\n\t\t\t\t\t\t\t\t++nDigits;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase L';':\n\t\t\t\t\t\t\t\t// Even if there were no digits - default is \"0\"\n\t\t\t\t\t\t\t\tif (Code.ArgC < static_cast<int>(countof(Code.ArgV)))\n\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue; // save argument\n\t\t\t\t\t\t\t\tnDigits = nValue = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (Code.Second == L']')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// OSC specific, stop on first non-digit/non-semicolon\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn (Code.ArgC > 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (((wcSave = *lpBufferParam) >= 64) && (wcSave <= 126))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Fin\n\t\t\t\t\t\t\t\t\tif (saveAction)\n\t\t\t\t\t\t\t\t\t\tCode.Action = wcSave;\n\t\t\t\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((static_cast<size_t>(Code.PvtLen) + 2) < countof(Code.Pvt))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen++] = wcSave; // Skip private symbols\n\t\t\t\t\t\t\t\t\tCode.Pvt[Code.PvtLen] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBufferParam;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nDigits && (Code.ArgC < static_cast<int>(countof(Code.ArgV))))\n\t\t\t\t\t\t\tCode.ArgV[Code.ArgC++] = nValue;\n\t\t\t\t\t\treturn (Code.Second == L']');\n\t\t\t\t\t};\n\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'(':\n\t\t\t\t\tcase L')':\n\t\t\t\t\tcase L'%':\n\t\t\t\t\t//case L'#':\n\t\t\t\t\t//case L'*':\n\t\t\t\t\t//case L'+':\n\t\t\t\t\t//case L'-':\n\t\t\t\t\t//case L'.':\n\t\t\t\t\t//case L'/':\n\t\t\t\t\t\t// VT G0/G1/G2/G3 character sets\n\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\tCode.Action = *(lpBuffer++);\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\tlpEnd = lpBuffer;\n\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t// Standard\n\t\t\t\t\t\tCode.Skip = 0;\n\t\t\t\t\t\tCode.ArgSZ = nullptr;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t#ifdef _DEBUG\n\t\t\t\t\t\t\t// ReSharper disable once CppDeclaratorNeverUsed\n\t\t\t\t\t\t\tLPCWSTR pszSaveStart = lpBuffer;\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tif (parseNumArgs(lpBuffer, lpEnd, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// В данном запросе (на запись) конца последовательности нет,\n\t\t\t\t\t\t// оставшийся хвост нужно сохранить в буфере, для следующего запроса\n\t\t\t\t\t\t// Ниже\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t// Finalizing (ST) with \"\\x1B\\\\\" or \"\\x07\"\n\t\t\t\t\t\t// \"%]4;16;rgb:00/00/00%\\\" - \"%\" is ESC\n\t\t\t\t\t\t// \"%]0;this is the window titleBEL\"\n\t\t\t\t\t\t// ESC ] 0 ; txt ST        Set icon name and window title to txt.\n\t\t\t\t\t\t// ESC ] 1 ; txt ST        Set icon name to txt.\n\t\t\t\t\t\t// ESC ] 2 ; txt ST        Set window title to txt.\n\t\t\t\t\t\t// ESC ] 4 ; num; txt ST   Set ANSI color num to txt.\n\t\t\t\t\t\t// ESC ] 10 ; txt ST       Set dynamic text color to txt.\n\t\t\t\t\t\t// ESC ] 4 6 ; name ST     Change log file to name (normally disabled\n\t\t\t\t\t\t//\t\t\t\t\t       by a compile-time option)\n\t\t\t\t\t\t// ESC ] 5 0 ; fn ST       Set font to fn.\n\t\t\t\t\t\t//Following 2 codes - from linux terminal\n\t\t\t\t\t\t// ESC ] P nrrggbb         Set palette, with parameter given in 7\n                        //                         hexadecimal digits after the final P :-(.\n\t\t\t\t\t\t//                         Here n is the color (0-15), and rrggbb indicates\n\t\t\t\t\t\t//                         the red/green/blue values (0-255).\n\t\t\t\t\t\t// ESC ] R                 reset palette\n\n\t\t\t\t\t\t// ConEmu specific\n\t\t\t\t\t\t// ESC ] 9 ; 1 ; ms ST           Sleep. ms - milliseconds\n\t\t\t\t\t\t// ESC ] 9 ; 2 ; \"txt\" ST        Show GUI MessageBox ( txt ) for dubug purposes\n\t\t\t\t\t\t// ESC ] 9 ; 3 ; \"txt\" ST        Set TAB text\n\t\t\t\t\t\t// ESC ] 9 ; 4 ; st ; pr ST      When _st_ is 0: remove progress. When _st_ is 1: set progress value to _pr_ (number, 0-100). When _st_ is 2: set error state in progress on Windows 7 taskbar\n\t\t\t\t\t\t// ESC ] 9 ; 5 ST                Wait for ENTER/SPACE/ESC. Set EnvVar \"ConEmuWaitKey\" to ENTER/SPACE/ESC on exit.\n\t\t\t\t\t\t// ESC ] 9 ; 6 ; \"txt\" ST        Execute GuiMacro. Set EnvVar \"ConEmuMacroResult\" on exit.\n\t\t\t\t\t\t// and others... look at CEAnsi::WriteAnsiCode_OSC\n\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\t//Code.Skip = Code.Second;\n\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((lpBuffer[0] == 7) ||\n\t\t\t\t\t\t\t\t(lpBuffer[0] == 27) /* we'll check the proper terminator below */)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = *Code.ArgSZ; // первый символ последовательности\n\t\t\t\t\t\t\t\tCode.cchArgSZ = (lpBuffer - Code.ArgSZ);\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tconst wchar_t* lpBufferPtr = Code.ArgSZ;\n\t\t\t\t\t\t\t\tif (lpBuffer[0] == 27)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ((lpBuffer + 1) >= lpEnd)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Sequence is not complete yet!\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (lpBuffer[1] == L'\\\\')\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer - 1;\n\t\t\t\t\t\t\t\t\t\t_ASSERTE(*(lpEnd+1) == 27);\n\t\t\t\t\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t\t\t\t\t\tiRc = 0;\n\t\t\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlpEnd = lpBuffer + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tparseNumArgs(lpBufferPtr, lpBuffer, false);\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Sequence is not complete, we have to store it to concatenate\n\t\t\t\t\t\t// and check on future write call. Below.\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Unknown sequence, use common termination rules\n\t\t\t\t\t\tCode.Skip = Code.Second;\n\t\t\t\t\t\tCode.ArgSZ = lpBuffer;\n\t\t\t\t\t\tCode.cchArgSZ = 0;\n\t\t\t\t\t\twhile (lpBuffer < lpEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Terminator ASCII symbol: from `@` to `~`\n\t\t\t\t\t\t\tif (((wc = *lpBuffer) >= 64) && (wc <= 126))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCode.Action = wc;\n\t\t\t\t\t\t\t\tlpStart = lpSaveStart;\n\t\t\t\t\t\t\t\tlpEnd = lpBuffer+1;\n\t\t\t\t\t\t\t\tiRc = 1;\n\t\t\t\t\t\t\t\tgoto wrap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++lpBuffer;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // end of \"switch (Code.Second)\"\n\t\t\t\t} // end of minimal length check\n\n\t\t\t\tif ((nLeft = (lpEnd - lpEscStart)) <= CEAnsi_MaxPrevAnsiPart)\n\t\t\t\t{\n\t\t\t\t\tif (ReEntrance)\n\t\t\t\t\t{\n\t\t\t\t\t\t//_ASSERTEX(!ReEntrance && \"Need to be checked!\"); -- seems to be OK\n\n\t\t\t\t\t\t// gsPrevAnsiPart2 stored for debug purposes only (fully excess)\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart2, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart2[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart2 = nLeft;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twmemmove(gsPrevAnsiPart, lpEscStart, nLeft);\n\t\t\t\t\t\tgsPrevAnsiPart[nLeft] = 0;\n\t\t\t\t\t\tgnPrevAnsiPart = nLeft;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_ASSERTEX(FALSE && \"Too long Esc-sequence part, Need to be checked!\");\n\t\t\t\t}\n\n\t\t\t\tlpStart = lpEscStart;\n\n\t\t\t\tiRc = 2;\n\t\t\t\tgoto wrap;\n\t\t\t} // end of \"case 27:\"\n\t\t} // end of \"switch (*lpBuffer)\"\n\n\t\t++lpBuffer;\n\t} // end of \"while (lpBuffer < lpEnd)\"\n\nwrap:\n\tlpNext = lpEnd;\n\n\t#ifdef _DEBUG\n\tif (iRc == 1)\n\t\tCode.nTotalLen = (lpEnd - Code.pszEscStart);\n\t#endif\nwrap2:\n\t_ASSERTEX((iRc==0) || (lpStart>=lpSaveStart && lpStart<lpEnd));\n\treturn iRc;\n}\n",
                            "caller_start": 1585,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 2515,
                            "call_code": "DumpKnownEscape(asRet, nLen, de_Report)",
                            "caller_code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}",
                            "caller_start": 2492,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 2734,
                            "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                            "caller_code": "BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n",
                            "caller_start": 2608,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 2749,
                            "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                            "caller_code": "BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n",
                            "caller_start": 2608,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 2765,
                            "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                            "caller_code": "BOOL CEAnsi::WriteAnsiCodes(OnWriteConsoleW_t writeConsoleW, HANDLE hConsoleOutput, LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)\n{\n\tBOOL lbRc = TRUE, lbApply = FALSE;\n\t// ReSharper disable once CppLocalVariableMayBeConst\n\tLPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);\n\tAnsiEscCode Code = {};\n\twchar_t szPreDump[CEAnsi_MaxPrevPart];\n\t// ReSharper disable once CppJoinDeclarationAndAssignment\n\tDWORD cchPrevPart;\n\n\tReloadFeatures();\n\n\t// Store this pointer\n\tpfnWriteConsoleW = writeConsoleW;\n\t// Ans current output handle\n\tmh_WriteOutput = hConsoleOutput;\n\n\t//ExtWriteTextParm write = {sizeof(write), ewtf_Current, hConsoleOutput};\n\t//write.Private = writeConsoleW;\n\n\twhile (lpBuffer < lpEnd)\n\t{\n\t\tLPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized\n\n\t\t// '^' is ESC\n\t\t// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m\n\n\t\tcchPrevPart = 0;\n\n\t\tconst int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);\n\n\t\tif (cchPrevPart)\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, szPreDump, cchPrevPart, lpNumberOfCharsWritten);\n\t\t\tif (!lbRc)\n\t\t\t\tgoto wrap;\n\t\t}\n\n\t\tif (iEsc != 0)\n\t\t{\n\t\t\tif (lpStart > lpBuffer)\n\t\t\t{\n\t\t\t\t_ASSERTEX((lpStart-lpBuffer) < static_cast<INT_PTR>(nNumberOfCharsToWrite));\n\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpStart - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten, FALSE);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (iEsc == 1)\n\t\t\t{\n\t\t\t\tif (Code.Skip)\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (Code.Second)\n\t\t\t\t\t{\n\t\t\t\t\tcase L'[':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_CSI(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L'[':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L']':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_OSC(writeConsoleW, hConsoleOutput, Code, lbApply);\n\n\t\t\t\t\t\t} // case L']':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'|':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// vim-xterm-emulation\n\t\t\t\t\t\t\tlbApply = TRUE;\n\t\t\t\t\t\t\tWriteAnsiCode_VIM(writeConsoleW, hConsoleOutput, Code, lbApply);\n\t\t\t\t\t\t} // case L'|':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase L'7':\n\t\t\t\t\tcase L'8':\n\t\t\t\t\t\t//TODO: 7 - Save Cursor and _Attributes_\n\t\t\t\t\t\t//TODO: 8 - Restore Cursor and _Attributes_\n\t\t\t\t\t\tXTermSaveRestoreCursor((Code.Second == L'7'), hConsoleOutput);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'c':\n\t\t\t\t\t\t// Full reset\n\t\t\t\t\t\tFullReset(hConsoleOutput);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'g':\n\t\t\t\t\t\t// User may disable flashing in ConEmu settings\n\t\t\t\t\t\tGuiFlashWindow(eFlashBeep, ghConWnd, FALSE, FLASHW_ALL, 1, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'H':\n\t\t\t\t\t\t// #ANSI gh-1827: support 'H' to set tab stops\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'M':\n\t\t\t\t\t\tReverseLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'E':\n\t\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, L\"\\r\\n\", 2, nullptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'D':\n\t\t\t\t\t\tForwardLF(hConsoleOutput, lbApply);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'=':\n\t\t\t\t\tcase L'>':\n\t\t\t\t\t\t// xterm \"ESC =\" - Application Keypad (DECKPAM)\n\t\t\t\t\t\t// xterm \"ESC >\" - Normal Keypad (DECKPNM)\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase L'(':\n\t\t\t\t\t\t// xterm G0..G3?\n\t\t\t\t\t\tswitch (Code.Action)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase L'0':\n\t\t\t\t\t\t\tmCharSet = VTCS_DRAWING;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase L'B':\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\t//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmCharSet = VTCS_DEFAULT;\n\t\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse //if (iEsc != 2) // 2 - means \"Esc part stored in buffer\"\n\t\t{\n\t\t\t_ASSERTEX(iEsc == 0);\n\t\t\tif (lpNext > lpBuffer)\n\t\t\t{\n\t\t\t\tif (lbApply)\n\t\t\t\t{\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t}\n\n\t\t\t\tconst DWORD nWrite = static_cast<DWORD>(lpNext - lpBuffer);\n\t\t\t\t//lbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tlbRc = WriteText(writeConsoleW, hConsoleOutput, lpBuffer, nWrite, lpNumberOfCharsWritten);\n\t\t\t\tif (!lbRc)\n\t\t\t\t\tgoto wrap;\n\t\t\t\t//write.Buffer = lpBuffer;\n\t\t\t\t//write.NumberOfCharsToWrite = nWrite;\n\t\t\t\t//lbRc = ExtWriteText(&write);\n\t\t\t\t//if (!lbRc)\n\t\t\t\t//\tgoto wrap;\n\t\t\t\t//else\n\t\t\t\t//{\n\t\t\t\t//\tif (lpNumberOfCharsWritten)\n\t\t\t\t//\t\t*lpNumberOfCharsWritten = write.NumberOfCharsWritten;\n\t\t\t\t//\tif (write.ScrolledRowsUp > 0)\n\t\t\t\t//\t\tgDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tif (lpNext > lpBuffer)\n\t\t{\n\t\t\tlpBuffer = lpNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);\n\t\t\t++lpBuffer;\n\t\t}\n\t}\n\n\tif (lbRc && lpNumberOfCharsWritten)\n\t\t*lpNumberOfCharsWritten = nNumberOfCharsToWrite;\n\nwrap:\n\tif (lbApply)\n\t{\n\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\tlbApply = FALSE;\n\t}\n\treturn lbRc;\n}\n",
                            "caller_start": 2608,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 3286,
                            "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                            "caller_code": "void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport's upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO(\"Need to clear attributes?\");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'K':\n\t\tbreak;\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO(\"Define scrolling region\");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L'h');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mouse wheel reporting */\n\t\t\tcase 7787: /* 'W': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L'h'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can't implement all possible styles in RealConsole,\n\t\t\t\t// but we can use \"Block/Underline\" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n",
                            "caller_start": 2829,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 3328,
                            "call_code": "DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored)",
                            "caller_code": "void CEAnsi::WriteAnsiCode_CSI(OnWriteConsoleW_t writeConsoleW, HANDLE& hConsoleOutput, AnsiEscCode& Code, BOOL& lbApply)\n{\n\t/*\n\nCSI ? P m h\t\t\tDEC Private Mode Set (DECSET)\n\tP s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\nCSI ? P m l\t\t\tDEC Private Mode Reset (DECRST)\n\tP s = 4 7 → Use Normal Screen Buffer\n\tP s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)\n\tP s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.\n\n\nCSI P s @\t\t\tInsert P s (Blank) Character(s) (default = 1) (ICH)\n\n\t*/\n\tCONSOLE_SCREEN_BUFFER_INFO csbi = {};\n\n\tswitch (Code.Action) // case sensitive\n\t{\n\tcase L's':\n\t\t// Save cursor position (can not be nested)\n\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'u':\n\t\t// Restore cursor position\n\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\tbreak;\n\n\tcase L'H': // Set cursor position (1-based)\n\tcase L'f': // Same as 'H'\n\tcase L'A': // Cursor up by N rows\n\tcase L'B': // Cursor down by N rows\n\tcase L'C': // Cursor right by N cols\n\tcase L'D': // Cursor left by N cols\n\tcase L'E': // Moves cursor to beginning of the line n (default 1) lines down.\n\tcase L'F': // Moves cursor to beginning of the line n (default 1) lines up.\n\tcase L'G': // Moves the cursor to column n.\n\tcase L'd': // Moves the cursor to line n.\n\t\t// Change cursor position\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tstruct PointXY {int X,Y;};\n\t\t\tauto get_scroll_region = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tSMALL_RECT clipRgn = MakeSmallRect(0, 0, srw.Right - srw.Left, srw.Bottom - srw.Top);\n\t\t\t\tif (gDisplayOpt.ScrollRegion)\n\t\t\t\t{\n\t\t\t\t\tclipRgn.Top = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollStart, csbi.dwSize.Y-1));\n\t\t\t\t\tclipRgn.Bottom = std::max<SHORT>(0, std::min<SHORT>(gDisplayOpt.ScrollEnd, csbi.dwSize.Y-1));\n\t\t\t\t}\n\t\t\t\treturn clipRgn;\n\t\t\t};\n\t\t\tauto get_cursor = [&csbi]()\n\t\t\t{\n\t\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\t\tconst int visible_rows = srw.Bottom - srw.Top;\n\t\t\t\treturn PointXY{\n\t\t\t\t\tcsbi.dwCursorPosition.X,\n\t\t\t\t\tstd::max(0, std::min(visible_rows, csbi.dwCursorPosition.Y - srw.Top))\n\t\t\t\t};\n\t\t\t};\n\t\t\tconst struct {int left, top, right, bottom;} workRgn = {0, 0, csbi.dwSize.X - 1, csbi.dwSize.Y - 1};\n\t\t\t_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);\n\t\t\tconst auto& clipRgn = get_scroll_region();\n\t\t\tconst auto cur = get_cursor();\n\t\t\tPointXY crNewPos = cur;\n\n\t\t\tenum class Direction { kAbsolute, kCompatible, kRelative };\n\n\t\t\tauto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tconst int kLegacyY = 9999;\n\t\t\t\tif (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))\n\t\t\t\t\t// #XTERM_256 Allow to put cursor into the legacy true-color area\n\t\t\t\t\tcrNewPos.Y = workRgn.bottom;\n\t\t\t\telse if (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));\n\t\t\t\telse if (value < 0 && cur.Y >= clipRgn.Top)\n\t\t\t\t\tcrNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t\telse if (value > 0 && cur.Y <= clipRgn.Bottom)\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));\n\t\t\t};\n\t\t\tauto set_x = [&crNewPos, &workRgn, &cur](Direction direction, int value)\n\t\t\t{\n\t\t\t\tif (direction == Direction::kAbsolute || direction == Direction::kCompatible)\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));\n\t\t\t\telse\n\t\t\t\t\tcrNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));\n\t\t\t};\n\n\t\t\tswitch (Code.Action)\n\t\t\t{\n\t\t\tcase L'H':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'f':\n\t\t\t\t// Set cursor position (ANSI values are 1-based)\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'A':\n\t\t\t\t// Cursor up by N rows\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'B':\n\t\t\t\t// Cursor down by N rows\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'C':\n\t\t\t\t// Cursor right by N cols\n\t\t\t\tset_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'D':\n\t\t\t\t// Cursor left by N cols\n\t\t\t\tset_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tbreak;\n\t\t\tcase L'E':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines down.\n\t\t\t\tset_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'F':\n\t\t\t\t// Moves cursor to beginning of the line n (default 1) lines up.\n\t\t\t\tset_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));\n\t\t\t\tset_x(Direction::kAbsolute, 0);\n\t\t\t\tbreak;\n\t\t\tcase L'G':\n\t\t\t\t// Moves the cursor to column n.\n\t\t\t\tset_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\tcase L'd':\n\t\t\t\t// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).\n\t\t\t\tset_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);\n\t\t\t\tbreak;\n\t\t\t#ifdef _DEBUG\n\t\t\tdefault:\n\t\t\t\t_ASSERTEX(FALSE && \"Missed (sub)case value!\");\n\t\t\t#endif\n\t\t\t}\n\n\t\t\t// Goto\n\t\t\tORIGINAL_KRNL(SetConsoleCursorPosition);\n\t\t\t{\n\t\t\tconst auto& srw = csbi.srWindow;\n\t\t\tCOORD crNewPosAPI = {\n\t\t\t\tstatic_cast<SHORT>(crNewPos.X),\n\t\t\t\tstatic_cast<SHORT>(std::min<int>(csbi.dwSize.Y - 1, srw.Top + crNewPos.Y))\n\t\t\t};\n\t\t\t_ASSERTE(crNewPosAPI.X == crNewPos.X);\n\t\t\tF(SetConsoleCursorPosition)(hConsoleOutput, crNewPosAPI);\n\t\t\t}\n\n\t\t\tif (gbIsVimProcess)\n\t\t\t\tgbIsVimAnsi = true;\n\t\t} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'\n\t\tbreak;\n\n\tcase L'J': // Clears part of the screen\n\t\t// Clears the screen and moves the cursor to the home position (line 0, column 0).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\t// ViM: need to fill whole screen with selected background color, so Apply attributes\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tbool resetCursor = false;\n\t\t\tCOORD cr0 = {0, csbi.srWindow.Top};\n\t\t\tint nChars = 0;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\t// clear from cursor to end of screen\n\t\t\t\tcr0 = csbi.dwCursorPosition;\n\t\t\t\tnChars = (csbi.dwSize.X - csbi.dwCursorPosition.X)\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.dwCursorPosition.Y);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t// clear from cursor to beginning of the screen\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1\n\t\t\t\t\t+ csbi.dwSize.X * (csbi.dwCursorPosition.Y - csbi.srWindow.Top);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t// clear viewport and moves cursor to viewport's upper left\n\t\t\t\tnChars = csbi.dwSize.X * (csbi.srWindow.Bottom - csbi.srWindow.Top + 1);\n\t\t\t\tresetCursor = true;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// xterm: clear scrollback buffer entirely\n\t\t\t\tif (csbi.srWindow.Top > 0)\n\t\t\t\t{\n\t\t\t\t\tcr0.X = csbi.dwCursorPosition.X;\n\t\t\t\t\tcr0.Y = static_cast<SHORT>(std::max(0, (csbi.dwCursorPosition.Y - csbi.srWindow.Top)));\n\t\t\t\t\tresetCursor = true;\n\n\t\t\t\t\tSMALL_RECT scroll{ 0, 0, static_cast<SHORT>(csbi.dwSize.X - 1),\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.dwSize.Y - 1) };\n\t\t\t\t\tScrollScreen(hConsoleOutput, -csbi.srWindow.Top, true, scroll);\n\n\t\t\t\t\tSMALL_RECT topLeft = { 0, 0, scroll.Right,\n\t\t\t\t\t\tstatic_cast<SHORT>(csbi.srWindow.Bottom - csbi.srWindow.Top) };\n\t\t\t\t\tSetConsoleWindowInfo(hConsoleOutput, TRUE, &topLeft);\n\n\t\t\t\t\tUpdateAppMapRows(0, true);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t}\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars)};\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\n\t\t\tif (resetCursor)\n\t\t\t{\n\t\t\t\tSetConsoleCursorPosition(hConsoleOutput, cr0);\n\t\t\t}\n\n\t\t} // case L'J':\n\t\tbreak;\n\n\tcase L'b':\n\t\tif (!Code.PvtLen)\n\t\t{\n\t\t\tint repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tif (m_LastWrittenChar && repeat > 0)\n\t\t\t{\n\t\t\t\tCEStr buffer;\n\t\t\t\tif (wchar_t* ptr = buffer.GetBuffer(repeat))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < repeat; ++i)\n\t\t\t\t\t\tptr[i] = m_LastWrittenChar;\n\t\t\t\t\tWriteText(writeConsoleW, hConsoleOutput, ptr, repeat, nullptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\tbreak; // case L'b'\n\n\tcase L'K': // Erases part of the line\n\t\t// Clears all characters from the cursor position to the end of the line\n\t\t// (including the character at the cursor position).\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tTODO(\"Need to clear attributes?\");\n\t\t\tint nChars = 0;\n\t\t\tint nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tswitch (nCmd)\n\t\t\t{\n\t\t\tcase 0: // clear from cursor to the end of the line\n\t\t\t\tnChars = csbi.dwSize.X - csbi.dwCursorPosition.X;\n\t\t\t\tbreak;\n\t\t\tcase 1: // clear from cursor to beginning of the line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwCursorPosition.X + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // clear entire line\n\t\t\t\tcr0.X = 0;\n\t\t\t\tnChars = csbi.dwSize.X;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'K':\n\t\tbreak;\n\n\tcase L'r':\n\t\t//\\027[Pt;Pbr\n\t\t//\n\t\t//Pt is the number of the top line of the scrolling region;\n\t\t//Pb is the number of the bottom line of the scrolling region\n\t\t// and must be greater than Pt.\n\t\t//(The default for Pt is line 1, the default for Pb is the end\n\t\t// of the screen)\n\t\t//\n\t\tif ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))\n\t\t{\n\t\t\t// Values are 1-based\n\t\t\tSetScrollRegion(true, true, Code.ArgV[0], Code.ArgV[1], hConsoleOutput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetScrollRegion(false);\n\t\t}\n\t\tbreak;\n\n\tcase L'S':\n\t\t// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);\n\t\tbreak;\n\n\tcase L'L':\n\t\t// Insert P s Line(s) (default = 1) (IL).\n\t\tLinesInsert(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\tcase L'M':\n\t\t// Delete N Line(s) (default = 1) (DL).\n\t\t// This is actually \"Scroll UP N line(s) inside defined scrolling region\"\n\t\tLinesDelete(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'@':\n\t\t// Insert P s (Blank) Character(s) (default = 1) (ICH).\n\t\tScrollLine(hConsoleOutput, ((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\tcase L'P':\n\t\t// Delete P s Character(s) (default = 1) (DCH).\n\t\tScrollLine(hConsoleOutput, -((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1));\n\t\tbreak;\n\n\tcase L'T':\n\t\t// Scroll whole page down by n (default 1) lines. New lines are added at the top.\n\t\tif (lbApply)\n\t\t{\n\t\t\t// Apply default color before scrolling!\n\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t}\n\t\tTODO(\"Define scrolling region\");\n\t\tScrollScreen(hConsoleOutput, (Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);\n\t\tbreak;\n\n\tcase L'h':\n\tcase L'l':\n\t\t// Set/ReSet Mode\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\t//ESC [ 3 h\n\t\t\t//       DECCRM (default off): Display control chars.\n\n\t\t\t//ESC [ 4 h\n\t\t\t//       DECIM (default off): Set insert mode.\n\n\t\t\t//ESC [ 20 h\n\t\t\t//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.\n\n\t\t\t//ESC [ ? 1 h\n\t\t\t//\t  DECCKM (default off): When set, the cursor keys send an ESC O prefix,\n\t\t\t//\t  rather than ESC [.\n\n\t\t\t//ESC [ ? 3 h\n\t\t\t//\t  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver\n\t\t\t//\t  sources note that this alone does not suffice; some user-mode utility\n\t\t\t//\t  such as resizecons(8) has to change the hardware registers on the\n\t\t\t//\t  console video card.\n\n\t\t\t//ESC [ ? 5 h\n\t\t\t//\t  DECSCNM (default off): Set reverse-video mode.\n\n\t\t\t//ESC [ ? 6 h\n\t\t\t//\t  DECOM (default off): When set, cursor addressing is relative to the\n\t\t\t//\t  upper left corner of the scrolling region.\n\n\n\t\t\t//ESC [ ? 8 h\n\t\t\t//\t  DECARM (default on): Set keyboard autorepeat on.\n\n\t\t\t//ESC [ ? 9 h\n\t\t\t//\t  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 1000 h\n\t\t\t//\t  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to\n\t\t\t//\t  0) -- see below.\n\n\t\t\t//ESC [ ? 7711 h\n\t\t\t//    mimic mintty code, same as \"ESC ] 9 ; 12 ST\"\n\n\t\t\tswitch (Code.ArgV[0])\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tgDisplayCursor.CursorKeysApp = (Code.Action == L'h');\n\n\t\t\t\t\tif (gbIsVimProcess)\n\t\t\t\t\t{\n\t\t\t\t\t\tTODO(\"Need to find proper way for activation alternative buffer from ViM?\");\n\t\t\t\t\t\tif (Code.Action == L'h')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StartVimTerm(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thConsoleOutput = StopVimTerm();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgDisplayOpt.ShowRawAnsi = (Code.Action == L'h');\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t//ESC [ ? 7 h\n\t\t\t\t//\t  DECAWM (default off): Set autowrap on.  In this mode, a graphic\n\t\t\t\t//\t  character emitted after column 80 (or column 132 of DECCOLM is on)\n\t\t\t\t//\t  forces a wrap to the beginning of the following line first.\n\t\t\t\t//ESC [ = 7 h\n\t\t\t\t//    Enables line wrapping\n\t\t\t\t//ESC [ 7 ; _col_ h\n\t\t\t\t//    Our extension. _col_ - wrap at column (1-based), default = 80\n\t\t\t\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t\t{\n\t\t\t\t\tgDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? static_cast<SHORT>(Code.ArgV[1]) : 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 20:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{\n\t\t\t\t\tSetAutoLfNl(Code.Action == L'h');\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t//ESC [ ? 12 h\n\t\t\t//\t  Start Blinking Cursor (att610)\n\t\t\tcase 12:\n\t\t\t//ESC [ ? 25 h\n\t\t\t//\t  DECTECM (default on): Make cursor visible.\n\t\t\tcase 25:\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < Code.ArgC; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Code.ArgV[i] == 25)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\t\t\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tci.bVisible = (Code.Action == L'h');\n\t\t\t\t\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (Code.PvtLen == 0)\n\t\t\t\t{  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t/* h=Insert Mode (IRM), l=Replace Mode (IRM) */\n\t\t\t\t\t// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\t/* h=Smooth (slow) scroll, l=Jump (fast) scroll */\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored); // ignored for now\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10_MOUSE */\n\t\t\tcase 1000: /* VT200_MOUSE */\n\t\t\tcase 1002: /* BTN_EVENT_MOUSE */\n\t\t\tcase 1003: /* ANY_EVENT_MOUSE */\n\t\t\tcase 1004: /* FOCUS_EVENT_MOUSE */\n\t\t\tcase 1005: /* Xterm's UTF8 encoding for mouse positions */\n\t\t\tcase 1006: /* Xterm's CSI-style mouse encoding */\n\t\t\tcase 1015: /* Urxvt's CSI-style mouse encoding */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tstatic DWORD LastMode = 0;\n\t\t\t\t\tTermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10\n\t\t\t\t\t\t: (Code.ArgV[0] == 1000) ? tmm_VT200\n\t\t\t\t\t\t: (Code.ArgV[0] == 1002) ? tmm_BTN\n\t\t\t\t\t\t: (Code.ArgV[0] == 1003) ? tmm_ANY\n\t\t\t\t\t\t: (Code.ArgV[0] == 1004) ? tmm_FOCUS\n\t\t\t\t\t\t: (Code.ArgV[0] == 1005) ? tmm_UTF8\n\t\t\t\t\t\t: (Code.ArgV[0] == 1006) ? tmm_XTERM\n\t\t\t\t\t\t: (Code.ArgV[0] == 1015) ? tmm_URXVT\n\t\t\t\t\t\t: tmm_None;\n\t\t\t\t\tDWORD Mode = (Code.Action == L'h')\n\t\t\t\t\t\t? (LastMode | ModeMask)\n\t\t\t\t\t\t: (LastMode & ~ModeMask);\n\t\t\t\t\tLastMode = Mode;\n\t\t\t\t\tChangeTermMode(tmc_MouseMode, Mode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7786: /* 'V': Mouse wheel reporting */\n\t\t\tcase 7787: /* 'W': Application mouse wheel mode */\n\t\t\tcase 1034: // Interpret \"meta\" key, sets eighth bit. (enables/disables the eightBitInput resource).\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 47:   /* alternate screen */\n\t\t\tcase 1047: /* alternate screen */\n\t\t\tcase 1049: /* cursor & alternate screen */\n\t\t\t\t// xmux/screen: Alternate screen\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tif (lbApply)\n\t\t\t\t\t{\n\t\t\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\t\t\tlbApply = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\t// \\e[?1049h: save cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(true, hConsoleOutput);\n\t\t\t\t\t// h: switch to alternative buffer without backscroll\n\t\t\t\t\t// l: restore saved scrollback buffer\n\t\t\t\t\thConsoleOutput = XTermAltBuffer((Code.Action == L'h'), Code.ArgV[0]);\n\t\t\t\t\t// \\e[?1049l - restore cursor pos\n\t\t\t\t\tif ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))\n\t\t\t\t\t\tXTermSaveRestoreCursor(false, hConsoleOutput);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1048: /* save/restore cursor */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tXTermSaveRestoreCursor((Code.Action == L'h'), hConsoleOutput);\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* bracketed paste */\n\t\t\t\t/* All \"pasted\" text will be wrapped in `\\e[200~ ... \\e[201~` */\n\t\t\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t\tChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));\n\t\t\t\telse\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\tbreak;\n\t\t\tcase 7711:\n\t\t\t\tif ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))\n\t\t\t\t{\n\t\t\t\t\tStorePromptBegin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\n\t\t\t//switch (Code.ArgV[0])\n\t\t\t//{\n\t\t\t//case 0: case 1:\n\t\t\t//\t// 40x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 40;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 2: case 3:\n\t\t\t//\t// 80x25\n\t\t\t//\tif ((gDisplayOpt.WrapWasSet = (Code.Action == L'h')))\n\t\t\t//\t{\n\t\t\t//\t\tgDisplayOpt.WrapAt = 80;\n\t\t\t//\t}\n\t\t\t//\tbreak;\n\t\t\t//case 7:\n\t\t\t//\t{\n\t\t\t//\t\tDWORD Mode = 0;\n\t\t\t//\t\tGetConsoleMode(hConsoleOutput, &Mode);\n\t\t\t//\t\tif (Code.Action == L'h')\n\t\t\t//\t\t\tMode |= ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\telse\n\t\t\t//\t\t\tMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;\n\t\t\t//\t\tSetConsoleMode(hConsoleOutput, Mode);\n\t\t\t//\t} // enable/disable line wrapping\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // case L'h': case L'l':\n\n\tcase L'n':\n\t\tif (Code.ArgC > 0)\n\t\t{\n\t\t\tswitch (*Code.ArgV)\n\t\t\t{\n\t\t\tcase 5:\n\t\t\t\t//ESC [ 5 n\n\t\t\t\t//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).\n\t\t\t\t//\n\t\t\t\tReportString(L\"\\x1B[0n\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t//ESC [ 6 n\n\t\t\t\t//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the\n\t\t\t\t//      cursor location.\n\t\t\t\tReportCursorPosition(hConsoleOutput);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'm':\n\t\tif (Code.PvtLen > 0)\n\t\t{\n\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t}\n\t\t// Set display mode (colors, fonts, etc.)\n\t\telse if (!Code.ArgC)\n\t\t{\n\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tReSetDisplayParm(hConsoleOutput, TRUE, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t// Bold\n\t\t\t\t\tgDisplayParm.setBrightOrBold(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// Faint, decreased intensity (ISO 6429)\n\t\t\t\tcase 22:\n\t\t\t\t\t// Normal (neither bold nor faint).\n\t\t\t\t\tgDisplayParm.setBrightOrBold(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t// Italic\n\t\t\t\t\tgDisplayParm.setItalic(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 23:\n\t\t\t\t\t// Not italic\n\t\t\t\t\tgDisplayParm.setItalic(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: // #TODO ANSI Slow Blink (less than 150 per minute)\n\t\t\t\tcase 6: // #TODO ANSI Rapid Blink (150+ per minute)\n\t\t\t\tcase 25: // #TODO ANSI Blink Off\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart,Code.nTotalLen,de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4: // Underlined\n\t\t\t\t\tgDisplayParm.setUnderline(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 24:\n\t\t\t\t\t// Not underlined\n\t\t\t\t\tgDisplayParm.setUnderline(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\t// Reverse video\n\t\t\t\t\tgDisplayParm.setInverse(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 27:\n\t\t\t\t\t// Positive (not inverse)\n\t\t\t\t\tgDisplayParm.setInverse(FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\t// Crossed-out / strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 29:\n\t\t\t\t\t// Not Crossed-out / Not strikethrough\n\t\t\t\t\tgDisplayParm.setCrossed(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:\n\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i] - 30);\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 38:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setText256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setText256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 39:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setTextColor(CONFORECOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightFore(FALSE);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:\n\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i] - 40);\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 48:\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette\n\t\t\t\t\tif (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);\n\t\t\t\t\t\tgDisplayParm.setBack256(clr8b);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\t// xterm-256 colors\n\t\t\t\t\t// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color\n\t\t\t\t\telse if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tgDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));\n\t\t\t\t\t\tgDisplayParm.setBack256(clr24b);\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 49:\n\t\t\t\t\t// Reset\n\t\t\t\t\tgDisplayParm.setBackColor(CONBACKCOLOR(GetDefaultTextAttr()));\n\t\t\t\t\tgDisplayParm.setBrightBack(FALSE);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:\n\t\t\t\t\tgDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);\n\t\t\t\t\tgDisplayParm.setText256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightFore(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:\n\t\t\t\t\tgDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);\n\t\t\t\t\tgDisplayParm.setBack256(clr4b);\n\t\t\t\t\tgDisplayParm.setBrightBack(TRUE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:  // NOLINT(bugprone-branch-clone)\n\t\t\t\t\t// Something strange and unknown... (received from ssh)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 312:\n\t\t\t\tcase 315:\n\t\t\t\tcase 414:\n\t\t\t\tcase 3130:\n\t\t\t\t\t// Something strange and unknown... (received from vim on WSL)\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak; // \"[...m\"\n\n\tcase L'p':\n\t\tif (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')\n\t\t{\n\t\t\tFullReset(hConsoleOutput);\n\t\t\tlbApply = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[!p\"\n\n\tcase L'q':\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))\n\t\t{\n\t\t\t/*\n\t\t\tCSI Ps SP q\n\t\t\t\tSet cursor style (DECSCUSR, VT520).\n\t\t\t\t\tPs = 0  -> ConEmu's default.\n\t\t\t\t\tPs = 1  -> blinking block.\n\t\t\t\t\tPs = 2  -> steady block.\n\t\t\t\t\tPs = 3  -> blinking underline.\n\t\t\t\t\tPs = 4  -> steady underline.\n\t\t\t\t\tPs = 5  -> blinking bar (xterm).\n\t\t\t\t\tPs = 6  -> steady bar (xterm).\n\t\t\t*/\n\t\t\tDWORD nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))\n\t\t\t\t? 0 : Code.ArgV[0];\n\t\t\tCONSOLE_CURSOR_INFO ci = {};\n\t\t\tif (GetConsoleCursorInfo(hConsoleOutput, &ci))\n\t\t\t{\n\t\t\t\t// We can't implement all possible styles in RealConsole,\n\t\t\t\t// but we can use \"Block/Underline\" shapes...\n\t\t\t\tci.dwSize = (nStyle == 1 || nStyle == 2) ? 100 : 15;\n\t\t\t\tSetConsoleCursorInfo(hConsoleOutput, &ci);\n\t\t\t}\n\t\t\tChangeTermMode(tmc_CursorShape, nStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak; // \"[...q\"\n\n\tcase L't':\n\t\tif (Code.ArgC > 0 && Code.ArgC <= 3)\n\t\t{\n\t\t\tfor (int i = 0; i < Code.ArgC; i++)\n\t\t\t{\n\t\t\t\tswitch (Code.ArgV[i])\n\t\t\t\t{\n\t\t\t\tcase 8:\n\t\t\t\t\t// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t{\n\t\t\t\t\t\tint height = -1, width = -1;\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\theight = Code.ArgV[++i];\n\t\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t\twidth = Code.ArgV[++i];\n\t\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\t\tstd::ignore = height;\n\t\t\t\t\t\tstd::ignore = width;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\t// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.\n\t\t\t\t\tReportTerminalPixelSize();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\tcase 19:\n\t\t\t\t\t// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`\n\t\t\t\t\t// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`\n\t\t\t\t\tReportTerminalCharSize(hConsoleOutput, Code.ArgV[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 21:\n\t\t\t\t\t// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`\n\t\t\t\t\tReportConsoleTitle();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\tcase 23:\n\t\t\t\t\t// `ESC [ 2 2 ; 0 t` --> Save xterm icon and window title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 1 t` --> Save xterm icon title on stack.\n\t\t\t\t\t// `ESC [ 2 2 ; 2 t` --> Save xterm window title on stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 0 t` --> Restore xterm icon and window title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 1 t` --> Restore xterm icon title from stack.\n\t\t\t\t\t// `ESC [ 2 3 ; 2 t` --> Restore xterm window title from stack.\n\t\t\t\t\tif (i < Code.ArgC)\n\t\t\t\t\t\t++i; // subcommand\n\t\t\t\t\tif (i < Code.ArgC && !Code.ArgV[i])\n\t\t\t\t\t\t++i; // strange sequence 22;0;0t\n\t\t\t\t\tDumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTODO(\"ANSI: xterm window manipulation\");\n\t\t\t\t\t//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:\n\t\t\t\t\t// 1 --> De-iconify window.\n\t\t\t\t\t// 2 --> Iconify window.\n\t\t\t\t\t// 3 ; x ; y --> Move window to [x, y].\n\t\t\t\t\t// 4 ; height ; width --> Resize the xterm window to height and width in pixels.\n\t\t\t\t\t// 5 --> Raise the xterm window to the front of the stacking order.\n\t\t\t\t\t// 6 --> Lower the xterm window to the bottom of the stacking order.\n\t\t\t\t\t// 7 --> Refresh the xterm window.\n\t\t\t\t\t// 8 ; height ; width --> Resize the text area to [height;width] in characters.\n\t\t\t\t\t// 9 ; 0 --> Restore maximized window.\n\t\t\t\t\t// 9 ; 1 --> Maximize window (i.e., resize to screen size).\n\t\t\t\t\t// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .\n\t\t\t\t\t// 1 3 --> Report xterm window position as CSI 3 ; x; y t\n\t\t\t\t\t// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t\n\t\t\t\t\t// 2 0 --> Report xterm window�s icon label as OSC L label ST\n\t\t\t\t\t// >= 2 4 --> Resize to P s lines (DECSLPP)\n\t\t\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'c':\n\t\t// echo -e \"\\e[>c\"\n\t\tif ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')\n\t\t\t&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))\n\t\t{\n\t\t\t// P s = 0 or omitted -> request the terminal's identification code.\n\t\t\twchar_t szVerInfo[64];\n\t\t\t// this will be \"ESC > 67 ; build ; 0 c\"\n\t\t\t// 67 is ASCII code of 'C' (ConEmu, yeah)\n\t\t\t// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83\n\t\t\t// msprintf(szVerInfo, countof(szVerInfo), L\"\\x1B>%u;%u;0c\", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);\n\t\t\t// Emulate xterm version 136?\n\t\t\twcscpy_c(szVerInfo, L\"\\x1B[>0;136;0c\");\n\t\t\tReportString(szVerInfo);\n\t\t}\n\t\t// echo -e \"\\e[c\"\n\t\telse if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))\n\t\t{\n\t\t\t// Report \"VT100 with Advanced Video Option\"\n\t\t\tReportString(L\"\\x1B[?1;2c\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t\t}\n\t\tbreak;\n\n\tcase L'X':\n\t\t// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)\n\t\tif (GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))\n\t\t{\n\t\t\tif (lbApply)\n\t\t\t{\n\t\t\t\t// Apply default color before scrolling!\n\t\t\t\tReSetDisplayParm(hConsoleOutput, FALSE, TRUE);\n\t\t\t\tlbApply = FALSE;\n\t\t\t}\n\n\t\t\tint nCount = (Code.ArgC > 0) ? Code.ArgV[0] : 1;\n\t\t\tint nScreenLeft = csbi.dwSize.X - csbi.dwCursorPosition.X - 1 + (csbi.dwSize.X * (csbi.dwSize.Y - csbi.dwCursorPosition.Y - 1));\n\t\t\tint nChars = std::min(nCount,nScreenLeft);\n\t\t\tCOORD cr0 = csbi.dwCursorPosition;\n\n\t\t\tif (nChars > 0)\n\t\t\t{\n\t\t\t\tExtFillOutputParm fill = { sizeof(fill), efof_Current | efof_Attribute | efof_Character,\n\t\t\t\t\thConsoleOutput, {}, L' ', cr0, static_cast<DWORD>(nChars) };\n\t\t\t\tExtFillOutput(&fill);\n\t\t\t}\n\t\t} // case L'X':\n\t\tbreak;\n\n\tdefault:\n\t\tDumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);\n\t} // switch (Code.Action)\n}\n",
                            "caller_start": 2829,
                            "file_path": "src/ConEmuHk/Ansi.cpp"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-29T22:29:26.919272"
        }
    ],
    "debug_trace": [
        "Collected 2 context items. (0 failed)",
        "Performed analysis iteration 1. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Analysis failed: [Analysis ERROR] Root cause analysis failed"
    ],
    "status": "error",
    "error": "Analysis failed: [Analysis ERROR] Root cause analysis failed"
}