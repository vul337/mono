{
    "patch": [
        {
            "func_name": "gf_media_split_hevc_tiles",
            "patch": "--- func_before\n+++ func_after\n@@ -3544,6 +3544,10 @@\n \t\tu32 size, nb_nalus=0, nb_nal_entries=0, last_tile_group=(u32) -1;\n \t\tGF_BitStream *bs=NULL;\n \t\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\n+\t\tif (!sample) {\n+\t\t\te = gf_isom_last_error(file);\n+\t\t\tgoto err_exit;\n+\t\t}\n \n \t\tdata = (u8 *) sample->data;\n \t\tsize = sample->dataLength;",
            "file_path": "src/media_tools/isom_tools.c"
        }
    ],
    "description": "GPAC MP4Box 2.1-DEV-rev649-ga8f438d20 has a segment fault (/stack overflow) due to infinite recursion in Media_GetSample isomedia/media.c:662",
    "msg": "fixed #2359",
    "root_cause": "Infinite recursion occurs in Media_GetSample (media.c:467-680) when processing samples via gf_media_split_hevc_tiles (isom_tools.c:3544) → gf_isom_get_sample (isom_read.c:1891) → Media_GetSample. The recursion likely involves Media_RewriteODFrame or gf_isom_nalu_sample_rewrite, which may re-trigger Media_GetSample without proper termination. The patch adds a null check but does not address the recursive call chain.",
    "confidence_score": 0.75,
    "enriched_data": [
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'gf_media_split_hevc_tiles', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 1912,
                    "call_code": "gf_media_split_hevc_tiles(dest, split_tile_mode - 1)",
                    "caller_code": "GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, GF_Fraction force_fps, u32 frames_per_sample, GF_FilterSession *fsess, char **mux_args_if_first_pass, char **mux_sid_if_first_pass, u32 tk_idx)\n{\n\tu32 track_id, i, j, timescale, track, stype, profile, compat, level, new_timescale, rescale_num, rescale_den, svc_mode, txt_flags, split_tile_mode, temporal_mode, nb_tracks;\n\ts32 par_d, par_n, prog_id, force_rate, moov_timescale;\n\ts32 tw, th, tx, ty, tz, txtw, txth, txtx, txty;\n\tBool do_audio, do_video, do_auxv,do_pict, do_all, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, rap_only, refs_only, force_par, rewrite_bs;\n\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc, do_disable;\n\tconst char *szLan;\n\tGF_Err e = GF_OK;\n\tGF_Fraction delay;\n\tu32 tmcd_track = 0, neg_ctts_mode=0;\n\tBool keep_audelim = GF_FALSE;\n\tu32 print_stats_graph=fs_dump_flags;\n\tGF_MediaImporter import;\n\tchar *ext, *final_name=NULL, *handler_name, *rvc_config, *chapter_name;\n\tGF_List *kinds;\n\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\n\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\n\tu32 clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod;\n\tBool has_clap=GF_FALSE;\n\tBool use_stz2=GF_FALSE;\n\tBool has_mx=GF_FALSE;\n\ts32 mx[9];\n\tu32 bitdepth=0;\n\tchar dv_profile[100]; /*Dolby Vision*/\n\tu32 clr_type=0;\n\tu32 clr_prim;\n\tu32 clr_tranf;\n\tu32 clr_mx;\n\tBool rescale_override=GF_FALSE;\n\tBool clr_full_range=GF_FALSE;\n\tBool fmt_ok = GF_TRUE;\n\tu32 icc_size=0, track_flags=0;\n\tu8 *icc_data = NULL;\n\tu32 tc_fps_num=0, tc_fps_den=0, tc_h=0, tc_m=0, tc_s=0, tc_f=0, tc_frames_per_tick=0;\n\tBool tc_force_counter=GF_FALSE;\n\tBool tc_drop_frame = GF_FALSE;\n\tchar *ext_start;\n\tu32 xps_inband=0;\n\tu64 source_magic=0;\n\tchar *opt_src = NULL;\n\tchar *opt_dst = NULL;\n\tchar *fchain = NULL;\n\tchar *edits = NULL;\n\tconst char *fail_msg = NULL;\n\tchar *hdr_file=NULL;\n\tBool set_ccst=GF_FALSE;\n\tBool has_last_sample_dur=GF_FALSE;\n\tu32 fake_import = 0;\n\tGF_Fraction last_sample_dur = {0,0};\n\ts32 fullrange, videofmt, colorprim, colortfc, colormx;\n\tclap_wn = clap_wd = clap_hn = clap_hd = clap_hon = clap_hod = clap_von = clap_vod = 0;\n\tGF_ISOMTrackFlagOp track_flags_mode=0;\n\tu32 roll_change=0;\n\ts32 roll = 0;\n\tBool src_is_isom = GF_FALSE;\n\ts32 dlb_mode = -2;\n\n\tdv_profile[0] = 0;\n\trvc_predefined = 0;\n\tchapter_name = NULL;\n\tnew_timescale = 1;\n\tmoov_timescale = 0;\n\trescale_num = rescale_den = 0;\n\ttext_layout = 0;\n\t/*0: merge all\n\t  1: split base and all SVC in two tracks\n\t  2: split all base and SVC layers in dedicated tracks\n\t */\n\tsvc_mode = 0;\n\n\tif (import_flags==0xFFFFFFFF) {\n\t\timport_flags = 0;\n\t\tfake_import = 1;\n\t}\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\n\tfinal_name = gf_strdup(inName);\n#ifdef WIN32\n\t/*dirty hack for msys&mingw: when we use import options, the ':' separator used prevents msys from translating the path\n\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we're screwed :( */\n\tif ( (final_name[0]=='/') && (final_name[2]=='/')) {\n\t\tfinal_name[0] = final_name[1];\n\t\tfinal_name[1] = ':';\n\t}\n#endif\n\n\tis_chap_file = 0;\n\thandler = 0;\n\tdo_disable = 0;\n\tchap_ref = 0;\n\tis_chap = 0;\n\tkinds = gf_list_new();\n\ttrack_layout = 0;\n\tszLan = NULL;\n\tdelay.num = delay.den = 0;\n\tgroup = 0;\n\tstype = 0;\n\tprofile = compat = level = 0;\n\tfullrange = videofmt = colorprim = colortfc = colormx = -1;\n\tsplit_tile_mode = 0;\n\ttemporal_mode = 0;\n\trap_only = 0;\n\trefs_only = 0;\n\ttxt_flags = 0;\n\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\n\tforce_rate = -1;\n\n\ttw = th = tx = ty = tz = txtw = txth = txtx = txty = 0;\n\tpar_d = par_n = -1;\n\tforce_par = rewrite_bs = GF_FALSE;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, '#');\n\tif (!ext) ext = gf_url_colon_suffix(final_name, '=');\n\tchar c_sep = ext ? ext[0] : 0;\n\tif (ext) ext[0] = 0;\n \tif (!strlen(final_name) || !strcmp(final_name, \"self\")) {\n\t\tfake_import = 2;\n\t\tsrc_is_isom = GF_TRUE;\n\t}\n\tchar *frag = strrchr(final_name, '#');\n\tif (frag) frag[0] = 0;\n\tif (gf_isom_probe_file(final_name))\n\t\tsrc_is_isom = GF_TRUE;\n\tif (frag) frag[0] = '#';\n\n\tif (ext) ext[0] = c_sep;\n\n\text = gf_url_colon_suffix(final_name, '=');\n\n#define GOTO_EXIT(_msg) if (e) { fail_msg = _msg; goto exit; }\n\n#define CHECK_FAKEIMPORT(_opt) if (fake_import) { M4_LOG(GF_LOG_ERROR, (\"Option %s not available for self-reference import\\n\", _opt)); e = GF_BAD_PARAM; goto exit; }\n#define CHECK_FAKEIMPORT_2(_opt) if (fake_import==1) { M4_LOG(GF_LOG_ERROR, (\"Option %s not available for self-reference import\\n\", _opt)); e = GF_BAD_PARAM; goto exit; }\n\n\n\thandler_name = NULL;\n\trvc_config = NULL;\n\twhile (ext) {\n\t\tchar *ext2 = gf_url_colon_suffix(ext+1, '=');\n\n\t\tif (ext2) ext2[0] = 0;\n\n\t\t/*all extensions for track-based importing*/\n\t\tif (!strnicmp(ext+1, \"dur=\", 4)) {\n\t\t\tCHECK_FAKEIMPORT(\"dur\")\n\n\t\t\tif (strchr(ext, '-')) {\n\t\t\t\timport.duration.num = parse_s32(ext+5, \"dur\");\n\t\t\t\timport.duration.den = 1;\n\t\t\t} else {\n\t\t\t\tgf_parse_frac(ext+5, &import.duration);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"start=\", 6)) {\n\t\t\tCHECK_FAKEIMPORT(\"start\")\n\t\t\timport.start_time = atof(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"lang=\", 5)) {\n\t\t\t/* prevent leak if param is set twice */\n\t\t\tif (szLan)\n\t\t\t\tgf_free((char*) szLan);\n\n\t\t\tszLan = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"delay=\", 6)) {\n\t\t\tif (sscanf(ext+7, \"%d/%u\", &delay.num, &delay.den)!=2) {\n\t\t\t\tdelay.num = parse_s32(ext+7, \"delay\");\n\t\t\t\tdelay.den = 1000; //in ms\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"par=\", 4)) {\n\t\t\tif (!stricmp(ext + 5, \"none\")) {\n\t\t\t\tpar_n = par_d = 0;\n\t\t\t} else if (!stricmp(ext + 5, \"auto\")) {\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else if (!stricmp(ext + 5, \"force\")) {\n\t\t\t\tpar_n = par_d = 1;\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (ext2) {\n\t\t\t\t\text2[0] = ':';\n\t\t\t\t\text2 = strchr(ext2+1, ':');\n\t\t\t\t\tif (ext2) ext2[0] = 0;\n\t\t\t\t}\n\t\t\t\tif (ext[5]=='w') {\n\t\t\t\t\trewrite_bs = GF_TRUE;\n\t\t\t\t\tif (sscanf(ext+6, \"%d:%d\", &par_n, &par_d)!=2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized syntax for par=, expecting N:D got %s\\n\", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (sscanf(ext+5, \"%d:%d\", &par_n, &par_d) != 2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized syntax for par=, expecting N:D got %s\\n\", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"clap=\", 5)) {\n\t\t\tif (!stricmp(ext+6, \"none\")) {\n\t\t\t\thas_clap=GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (sscanf(ext+6, \"%d,%d,%d,%d,%d,%d,%d,%d\", &clap_wn, &clap_wd, &clap_hn, &clap_hd, &clap_hon, &clap_hod, &clap_von, &clap_vod)==8) {\n\t\t\t\t\thas_clap=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"mx=\", 3)) {\n\t\t\tif (strstr(ext+4, \"0x\")) {\n\t\t\t\tif (sscanf(ext+4, \"0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%d\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\t\thas_mx=GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (sscanf(ext+4, \"%d,%d,%d,%d,%d,%d,%d,%d,%d\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\thas_mx=GF_TRUE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"name=\", 5)) {\n\t\t\thandler_name = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"ext=\", 4)) {\n\t\t\tCHECK_FAKEIMPORT(\"ext\")\n\t\t\t/*extensions begin with '.'*/\n\t\t\tif (*(ext+5) == '.')\n\t\t\t\timport.force_ext = gf_strdup(ext+5);\n\t\t\telse {\n\t\t\t\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\n\t\t\t\timport.force_ext[0] = '.';\n\t\t\t\tstrcat(import.force_ext+1, ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"hdlr=\", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\n\t\telse if (!strnicmp(ext+1, \"stype=\", 6)) stype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\n\t\telse if (!strnicmp(ext+1, \"tkhd\", 4)) {\n\t\t\tchar *flags = ext+6;\n\t\t\tif (flags[0]=='+') { track_flags_mode = GF_ISOM_TKFLAGS_ADD; flags += 1; }\n\t\t\telse if (flags[0]=='-') { track_flags_mode = GF_ISOM_TKFLAGS_REM; flags += 1; }\n\t\t\telse track_flags_mode = GF_ISOM_TKFLAGS_SET;\n\n\t\t\tif (strstr(flags, \"enable\")) track_flags |= GF_ISOM_TK_ENABLED;\n\t\t\tif (strstr(flags, \"movie\")) track_flags |= GF_ISOM_TK_IN_MOVIE;\n\t\t\tif (strstr(flags, \"preview\")) track_flags |= GF_ISOM_TK_IN_PREVIEW;\n\t\t\tif (strstr(flags, \"size_ar\")) track_flags |= GF_ISOM_TK_SIZE_IS_AR;\n\t\t\tif (!track_flags) {\n\t\t\t\tif (!strnicmp(flags, \"0x\", 2)) flags += 2;\n\t\t\t\tsscanf(flags, \"%X\", &track_flags);\n\t\t\t}\n\t\t} else if (!strnicmp(ext+1, \"disable\", 7)) {\n\t\t\tdo_disable = !stricmp(ext+1, \"disable=no\") ? 2 : 1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"group=\", 6)) {\n\t\t\tgroup = parse_u32(ext+7, \"group\");\n\t\t\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fps=\", 4)) {\n\t\t\tu32 ticks, dts_inc;\n\t\t\tif (!strcmp(ext+5, \"auto\")) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning, fps=auto option is deprecated\\n\"));\n\t\t\t} else if ((sscanf(ext+5, \"%u-%u\", &ticks, &dts_inc) == 2) || (sscanf(ext+5, \"%u/%u\", &ticks, &dts_inc) == 2)) {\n\t\t\t\tif (!dts_inc) dts_inc=1;\n\t\t\t\tforce_fps.num = ticks;\n\t\t\t\tforce_fps.den = dts_inc;\n\t\t\t} else {\n\t\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\t\tforce_fps.den = 1000;\n\t\t\t\t\tforce_fps.num = (u32) (atof(ext+5) * force_fps.den);\n\t\t\t\t} else {\n\t\t\t\t\tgf_parse_frac(ext+5, &force_fps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"rap\")) rap_only = 1;\n\t\telse if (!stricmp(ext+1, \"refs\")) refs_only = 1;\n\t\telse if (!stricmp(ext+1, \"trailing\")) { CHECK_FAKEIMPORT(\"trailing\") import_flags |= GF_IMPORT_KEEP_TRAILING; }\n\t\telse if (!strnicmp(ext+1, \"agg=\", 4)) { CHECK_FAKEIMPORT(\"agg\") frames_per_sample = parse_u32(ext+5, \"agg\"); }\n\t\telse if (!stricmp(ext+1, \"dref\")) { CHECK_FAKEIMPORT(\"dref\")  import_flags |= GF_IMPORT_USE_DATAREF; }\n\t\telse if (!stricmp(ext+1, \"keep_refs\")) { CHECK_FAKEIMPORT(\"keep_refs\") import_flags |= GF_IMPORT_KEEP_REFS; }\n\t\telse if (!stricmp(ext+1, \"nodrop\")) { CHECK_FAKEIMPORT(\"nodrop\") import_flags |= GF_IMPORT_NO_FRAME_DROP; }\n\t\telse if (!stricmp(ext+1, \"packed\")) { CHECK_FAKEIMPORT(\"packed\") import_flags |= GF_IMPORT_FORCE_PACKED; }\n\t\telse if (!stricmp(ext+1, \"sbr\")) { CHECK_FAKEIMPORT(\"sbr\") import_flags |= GF_IMPORT_SBR_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, \"sbrx\")) { CHECK_FAKEIMPORT(\"sbrx\") import_flags |= GF_IMPORT_SBR_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, \"ovsbr\")) { CHECK_FAKEIMPORT(\"ovsbr\") import_flags |= GF_IMPORT_OVSBR; }\n\t\telse if (!stricmp(ext+1, \"ps\")) { CHECK_FAKEIMPORT(\"ps\") import_flags |= GF_IMPORT_PS_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, \"psx\")) { CHECK_FAKEIMPORT(\"psx\") import_flags |= GF_IMPORT_PS_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, \"mpeg4\")) { CHECK_FAKEIMPORT(\"mpeg4\") import_flags |= GF_IMPORT_FORCE_MPEG4; }\n\t\telse if (!stricmp(ext+1, \"nosei\")) { CHECK_FAKEIMPORT(\"nosei\") import_flags |= GF_IMPORT_NO_SEI; }\n\t\telse if (!stricmp(ext+1, \"svc\") || !stricmp(ext+1, \"lhvc\") ) { CHECK_FAKEIMPORT(\"svc/lhvc\") import_flags |= GF_IMPORT_SVC_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, \"nosvc\") || !stricmp(ext+1, \"nolhvc\")) { CHECK_FAKEIMPORT(\"nosvc/nolhvc\") import_flags |= GF_IMPORT_SVC_NONE; }\n\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, \"svcmode=\", 8) || !strnicmp(ext+1, \"lhvcmode=\", 9)) {\n\t\t\tchar *mode = ext+9;\n\t\t\tCHECK_FAKEIMPORT_2(\"svcmode/lhvcmode\")\n\t\t\tif (mode[0]=='=') mode = ext+10;\n\n\t\t\tif (!stricmp(mode, \"splitnox\"))\n\t\t\t\tsvc_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitnoxib\"))\n\t\t\t\tsvc_mode = 4;\n\t\t\telse if (!stricmp(mode, \"splitall\") || !stricmp(mode, \"split\"))\n\t\t\t\tsvc_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\tsvc_mode = 1;\n\t\t\telse if (!stricmp(mode, \"merged\") || !stricmp(mode, \"merge\"))\n\t\t\t\tsvc_mode = 0;\n\t\t}\n\t\t/*split SHVC temporal sublayers*/\n\t\telse if (!strnicmp(ext+1, \"temporal=\", 9)) {\n\t\t\tchar *mode = ext+10;\n\t\t\tCHECK_FAKEIMPORT_2(\"svcmode/lhvcmode\")\n\t\t\tif (!stricmp(mode, \"split\"))\n\t\t\t\ttemporal_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitnox\"))\n\t\t\t\ttemporal_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\ttemporal_mode = 1;\n\t\t\telse {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized temporal mode %s, ignoring\\n\", mode));\n\t\t\t\ttemporal_mode = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"subsamples\")) { CHECK_FAKEIMPORT(\"subsamples\") import_flags |= GF_IMPORT_SET_SUBSAMPLES; }\n\t\telse if (!stricmp(ext+1, \"deps\")) { CHECK_FAKEIMPORT(\"deps\") import_flags |= GF_IMPORT_SAMPLE_DEPS; }\n\t\telse if (!stricmp(ext+1, \"ccst\")) { CHECK_FAKEIMPORT(\"ccst\") set_ccst = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, \"alpha\")) { CHECK_FAKEIMPORT(\"alpha\") import.is_alpha = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, \"forcesync\")) { CHECK_FAKEIMPORT(\"forcesync\") import_flags |= GF_IMPORT_FORCE_SYNC; }\n\t\telse if (!stricmp(ext+1, \"xps_inband\")) { CHECK_FAKEIMPORT(\"xps_inband\") xps_inband = 1; }\n\t\telse if (!stricmp(ext+1, \"xps_inbandx\")) { CHECK_FAKEIMPORT(\"xps_inbandx\") xps_inband = 2; }\n\t\telse if (!stricmp(ext+1, \"au_delim\")) { CHECK_FAKEIMPORT(\"au_delim\") keep_audelim = GF_TRUE; }\n\t\telse if (!strnicmp(ext+1, \"max_lid=\", 8) || !strnicmp(ext+1, \"max_tid=\", 8)) {\n\t\t\ts32 val = parse_u32(ext+9, \"Max TID/LID\");\n\t\t\tCHECK_FAKEIMPORT_2(\"max_lid/lhvcmode\")\n\t\t\tif (val < 0) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: request max layer/temporal id is negative - ignoring\\n\"));\n\t\t\t} else {\n\t\t\t\tif (!strnicmp(ext+1, \"max_lid=\", 8))\n\t\t\t\t\tmax_layer_id_plus_one = 1 + (u8) val;\n\t\t\t\telse\n\t\t\t\t\tmax_temporal_id_plus_one = 1 + (u8) val;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"tiles\")) { CHECK_FAKEIMPORT_2(\"tiles\") split_tile_mode = 2; }\n\t\telse if (!stricmp(ext+1, \"tiles_rle\")) { CHECK_FAKEIMPORT_2(\"tiles_rle\") split_tile_mode = 3; }\n\t\telse if (!stricmp(ext+1, \"split_tiles\")) { CHECK_FAKEIMPORT_2(\"split_tiles\") split_tile_mode = 1; }\n\n\t\t/*force all composition offsets to be positive*/\n\t\telse if (!strnicmp(ext+1, \"negctts\", 7)) {\n\t\t\tneg_ctts_mode = !strnicmp(ext+1, \"negctts=no\", 10) ? 2 : 1;\n\t\t}\n\t\telse if (!stricmp(ext+1, \"chap\")) is_chap = 1;\n\t\telse if (!strnicmp(ext+1, \"chapter=\", 8)) {\n\t\t\tchapter_name = gf_strdup(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"chapfile=\", 9)) {\n\t\t\tchapter_name = gf_strdup(ext+10);\n\t\t\tis_chap_file=1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"layout=\", 7)) {\n\t\t\ttrack_layout = 1;\n\t\t\tif ( sscanf(ext+13, \"%dx%dx%dx%dx%d\", &tw, &th, &tx, &ty, &tz)==5) {\n\t\t\t} else if ( sscanf(ext+13, \"%dx%dx%dx%d\", &tw, &th, &tx, &ty)==4) {\n\t\t\t\ttz = 0;\n\t\t\t} else if ( sscanf(ext+13, \"%dx%dx%d\", &tw, &th, &tz)==3) {\n\t\t\t\ttx = ty = 0;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &tw, &th)==2) {\n\t\t\t\ttx = ty = tz = 0;\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"rescale=\", 8)) {\n\t\t\tif (sscanf(ext+9, \"%u/%u\", &rescale_num, &rescale_den) != 2) {\n\t\t\t\trescale_num = parse_u32(ext+9, \"rescale\");\n\t\t\t\trescale_den = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"sampdur=\", 8)) {\n\t\t\tif (sscanf(ext+9, \"%u/%u\", &rescale_den, &rescale_num) != 2) {\n\t\t\t\trescale_den = parse_u32(ext+9, \"sampdur\");\n\t\t\t\trescale_num = 0;\n\t\t\t}\n\t\t\trescale_override = GF_TRUE;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"timescale=\", 10)) {\n\t\t\tnew_timescale = parse_u32(ext+11, \"timescale\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"moovts=\", 7)) {\n\t\t\tmoov_timescale = parse_u32(ext+8, \"moovts\");\n\t\t}\n\n\t\telse if (!stricmp(ext+1, \"noedit\")) { import_flags |= GF_IMPORT_NO_EDIT_LIST; }\n\n\n\t\telse if (!strnicmp(ext+1, \"rvc=\", 4)) {\n\t\t\tif (sscanf(ext+5, \"%d\", &rvc_predefined) != 1) {\n\t\t\t\trvc_config = gf_strdup(ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fmt=\", 4)) import.streamFormat = gf_strdup(ext+5);\n\n\t\telse if (!strnicmp(ext+1, \"profile=\", 8)) {\n\t\t\tif (!stricmp(ext+9, \"high444\")) profile = 244;\n\t\t\telse if (!stricmp(ext+9, \"high\")) profile = 100;\n\t\t\telse if (!stricmp(ext+9, \"extended\")) profile = 88;\n\t\t\telse if (!stricmp(ext+9, \"main\")) profile = 77;\n\t\t\telse if (!stricmp(ext+9, \"baseline\")) profile = 66;\n\t\t\telse profile = parse_u32(ext+9, \"profile\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"level=\", 6)) {\n\t\t\tif( atof(ext+7) < 6 )\n\t\t\t\tlevel = (int)(10*atof(ext+7)+.5);\n\t\t\telse\n\t\t\t\tlevel = parse_u32(ext+7, \"level\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"compat=\", 7)) {\n\t\t\tcompat = parse_u32(ext+8, \"compat\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"dlba=\", 5)) {\n\t\t\tif (!strcmp(ext+6, \"no\")) dlb_mode=0;\n\t\t\telse if (!strcmp(ext+6, \"auto\")) dlb_mode=-1;\n\t\t\telse if (sscanf(ext+6, \"%d\", &dlb_mode) != 1) {\n\t\t\t\tGOTO_EXIT(\"Unrecognized dolby atmos mode\")\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"novpsext\", 8)) { CHECK_FAKEIMPORT(\"novpsext\") import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS; }\n\t\telse if (!strnicmp(ext+1, \"keepav1t\", 8)) { CHECK_FAKEIMPORT(\"keepav1t\") import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU; }\n\n\t\telse if (!strnicmp(ext+1, \"font=\", 5)) { CHECK_FAKEIMPORT(\"font\") import.fontName = gf_strdup(ext+6); }\n\t\telse if (!strnicmp(ext+1, \"size=\", 5)) { CHECK_FAKEIMPORT(\"size\") import.fontSize = parse_u32(ext+6, \"size\"); }\n\t\telse if (!strnicmp(ext+1, \"text_layout=\", 12)) {\n\t\t\tif ( sscanf(ext+13, \"%dx%dx%dx%d\", &txtw, &txth, &txtx, &txty)==4) {\n\t\t\t\ttext_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &txtw, &txth)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttxtx = txty = 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\telse if (!stricmp(ext+1, \"swf-global\")) { CHECK_FAKEIMPORT(\"swf-global\") import.swf_flags |= GF_SM_SWF_STATIC_DICT; }\n\t\telse if (!stricmp(ext+1, \"swf-no-ctrl\")) { CHECK_FAKEIMPORT(\"swf-no-ctrl\") import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE; }\n\t\telse if (!stricmp(ext+1, \"swf-no-text\")) { CHECK_FAKEIMPORT(\"swf-no-text\") import.swf_flags |= GF_SM_SWF_NO_TEXT; }\n\t\telse if (!stricmp(ext+1, \"swf-no-font\")) { CHECK_FAKEIMPORT(\"swf-no-font\") import.swf_flags |= GF_SM_SWF_NO_FONT; }\n\t\telse if (!stricmp(ext+1, \"swf-no-line\")) { CHECK_FAKEIMPORT(\"swf-no-line\") import.swf_flags |= GF_SM_SWF_NO_LINE; }\n\t\telse if (!stricmp(ext+1, \"swf-no-grad\")) { CHECK_FAKEIMPORT(\"swf-no-grad\") import.swf_flags |= GF_SM_SWF_NO_GRADIENT; }\n\t\telse if (!stricmp(ext+1, \"swf-quad\")) { CHECK_FAKEIMPORT(\"swf-quad\") import.swf_flags |= GF_SM_SWF_QUAD_CURVE; }\n\t\telse if (!stricmp(ext+1, \"swf-xlp\")) { CHECK_FAKEIMPORT(\"swf-xlp\") import.swf_flags |= GF_SM_SWF_SCALABLE_LINE; }\n\t\telse if (!stricmp(ext+1, \"swf-ic2d\")) { CHECK_FAKEIMPORT(\"swf-ic2d\") import.swf_flags |= GF_SM_SWF_USE_IC2D; }\n\t\telse if (!stricmp(ext+1, \"swf-same-app\")) { CHECK_FAKEIMPORT(\"swf-same-app\") import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE; }\n\t\telse if (!strnicmp(ext+1, \"swf-flatten=\", 12)) { CHECK_FAKEIMPORT(\"swf-flatten\") import.swf_flatten_angle = (Float) atof(ext+13); }\n#endif\n\n\t\telse if (!strnicmp(ext+1, \"kind=\", 5)) {\n\t\t\tchar *kind_scheme, *kind_value;\n\t\t\tchar *kind_data = ext+6;\n\t\t\tchar *sep = strchr(kind_data, '=');\n\t\t\tif (sep) {\n\t\t\t\t*sep = 0;\n\t\t\t}\n\t\t\tkind_scheme = gf_strdup(kind_data);\n\t\t\tif (sep) {\n\t\t\t\t*sep = '=';\n\t\t\t\tkind_value = gf_strdup(sep+1);\n\t\t\t} else {\n\t\t\t\tkind_value = NULL;\n\t\t\t}\n\t\t\tgf_list_add(kinds, kind_scheme);\n\t\t\tgf_list_add(kinds, kind_value);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"txtflags\", 8)) {\n\t\t\tif (!strnicmp(ext+1, \"txtflags=\", 9)) {\n\t\t\t\tsscanf(ext+10, \"%x\", &txt_flags);\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags+=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags-=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"rate=\", 5)) {\n\t\t\tforce_rate = parse_s32(ext+6, \"rate\");\n\t\t}\n\t\telse if (!stricmp(ext+1, \"stats\") || !stricmp(ext+1, \"fstat\"))\n\t\t\tprint_stats_graph |= 1;\n\t\telse if (!stricmp(ext+1, \"graph\") || !stricmp(ext+1, \"graph\"))\n\t\t\tprint_stats_graph |= 2;\n\t\telse if (!strncmp(ext+1, \"sopt\", 4) || !strncmp(ext+1, \"dopt\", 4) || !strncmp(ext+1, \"@\", 1)) {\n\t\t\tif (ext2) ext2[0] = ':';\n\t\t\topt_src = strstr(ext, \":sopt:\");\n\t\t\topt_dst = strstr(ext, \":dopt:\");\n\t\t\tfchain = strstr(ext, \":@\");\n\t\t\tif (opt_src) opt_src[0] = 0;\n\t\t\tif (opt_dst) opt_dst[0] = 0;\n\t\t\tif (fchain) fchain[0] = 0;\n\n\t\t\tif (opt_src) import.filter_src_opts = opt_src+6;\n\t\t\tif (opt_dst) import.filter_dst_opts = opt_dst+6;\n\t\t\tif (fchain) {\n\t\t\t\t//check for old syntax (0.9->1.0) :@@\n\t\t\t\tif (fchain[2]=='@') {\n\t\t\t\t\timport.filter_chain = fchain + 3;\n\t\t\t\t\timport.is_chain_old_syntax = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\timport.filter_chain = fchain + 2;\n\t\t\t\t\timport.is_chain_old_syntax = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\text = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"asemode=\", 8)){\n\t\t\tchar *mode = ext+9;\n\t\t\tif (!stricmp(mode, \"v0-bs\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\n\t\t\telse if (!stricmp(mode, \"v0-2\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\n\t\t\telse if (!stricmp(mode, \"v1\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\n\t\t\telse if (!stricmp(mode, \"v1-qt\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\telse\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized audio sample entry mode %s, ignoring\\n\", mode));\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"audio_roll=\", 11)) { roll_change = 3; roll = parse_s32(ext+12, \"audio_roll\"); }\n\t\telse if (!strnicmp(ext+1, \"roll=\", 5)) { roll_change = 1; roll = parse_s32(ext+6, \"roll\"); }\n\t\telse if (!strnicmp(ext+1, \"proll=\", 6)) { roll_change = 2; roll = parse_s32(ext+7, \"proll\"); }\n\t\telse if (!strcmp(ext+1, \"stz2\")) {\n\t\t\tuse_stz2 = GF_TRUE;\n\t\t} else if (!strnicmp(ext+1, \"bitdepth=\", 9)) {\n\t\t\tbitdepth = parse_u32(ext+10, \"bitdepth\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"hdr=\", 4)) {\n\t\t\thdr_file = gf_strdup(ext+5);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colr=\", 5)) {\n\t\t\tchar *cval = ext+6;\n\t\t\tif (!strcmp(cval, \"none\")) {\n\t\t\t\tclr_type = (u32) -1;\n\t\t\t} else if (strlen(cval)<6) {\n\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tclr_type = GF_4CC(cval[0],cval[1],cval[2],cval[3]);\n\t\t\t\tcval+=4;\n\t\t\t\tif (cval[0] != ',') {\n\t\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_NCLX) || (clr_type==GF_ISOM_SUBTYPE_NCLC)) {\n\t\t\t\t\tfmt_ok = scan_color(cval+1, &clr_prim, &clr_tranf, &clr_mx, &clr_full_range);\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_RICC) || (clr_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\t\t\t\tFILE *f = gf_fopen(cval+1, \"rb\");\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open file %s\\n\", cval+1));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_END);\n\t\t\t\t\t\ticc_size = (u32) gf_ftell(f);\n\t\t\t\t\t\ticc_data = gf_malloc(sizeof(char)*icc_size);\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_SET);\n\t\t\t\t\t\ticc_size = (u32) gf_fread(icc_data, icc_size, f);\n\t\t\t\t\t\tgf_fclose(f);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized colr profile %s\\n\", gf_4cc_to_str(clr_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fmt_ok) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"parsing colr option\");\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext + 1, \"dvp=\", 4)) {\n\t\t\tstrncpy(dv_profile, ext + 5, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\t//old name\n\t\telse if (!strnicmp(ext + 1, \"dv-profile=\", 11)) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"Deprecated option name, use `:dvp=` instead\\n\"));\n\t\t\tstrncpy(dv_profile, ext + 12, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fullrange=\", 10)) {\n\t\t\tif (!stricmp(ext+11, \"off\") || !stricmp(ext+11, \"no\")) fullrange = 0;\n\t\t\telse if (!stricmp(ext+11, \"on\") || !stricmp(ext+11, \"yes\")) fullrange = 1;\n\t\t\telse {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for fullrange\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"videofmt=\", 10)) {\n\t\t\tu32 idx, count = GF_ARRAY_LENGTH(videofmt_names);\n\t\t\tfor (idx=0; idx<count; idx++) {\n\t\t\t\tif (!strcmp(ext+11, videofmt_names[idx])) {\n\t\t\t\t\tvideofmt = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (videofmt==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for videofmt\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colorprim=\", 10)) {\n\t\t\tcolorprim = gf_cicp_parse_color_primaries(ext+11);\n\t\t\tif (colorprim==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for colorprim\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colortfc=\", 9)) {\n\t\t\tcolortfc = gf_cicp_parse_color_transfer(ext+10);\n\t\t\tif (colortfc==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for colortfc\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colormx=\", 10)) {\n\t\t\tcolormx = gf_cicp_parse_color_matrix(ext+11);\n\t\t\tif (colormx==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for colormx\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"tc=\", 3)) {\n\t\t\tchar *tc_str = ext+4;\n\t\t\t\n\t\t\tif (tc_str[0] == 'd') {\n\t\t\t\ttc_drop_frame=GF_TRUE;\n\t\t\t\ttc_str+=1;\n\t\t\t}\n\t\t\tif (sscanf(tc_str, \"%d/%d,%d,%d,%d,%d,%d\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 7) {\n\t\t\t} else if (sscanf(tc_str, \"%d/%d,%d,%d,%d,%d\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f) == 6) {\n\t\t\t} else if (sscanf(tc_str, \"%d,%d,%d,%d,%d,%d\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 6) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, \"%d,%d,%d,%d,%d\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f) == 5) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, \"%d/%d,%d,%d\", &tc_fps_num, &tc_fps_den, &tc_f, &tc_frames_per_tick) == 4) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, \"%d/%d,%d\", &tc_fps_num, &tc_fps_den, &tc_f) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, \"%d,%d,%d\", &tc_fps_num, &tc_f, &tc_frames_per_tick) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, \"%d,%d\", &tc_fps_num, &tc_f) == 2) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format %s for timecode, ignoring\\n\", ext+1));\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"edits=\", 6)) {\n\t\t\tedits = gf_strdup(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"lastsampdur\", 11)) {\n\t\t\thas_last_sample_dur = GF_TRUE;\n\t\t\tif (!strnicmp(ext+1, \"lastsampdur=\", 12)) {\n\t\t\t\tif (sscanf(ext+13, \"%d/%u\", &last_sample_dur.num, &last_sample_dur.den)==2) {\n\t\t\t\t} else {\n\t\t\t\t\tlast_sample_dur.num = parse_s32(ext+13, \"lastsampdur\");\n\t\t\t\t\tlast_sample_dur.den = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"ID=\", 3)) {\n\t\t\timport.target_trackID = (u32) parse_u32(ext+4, \"ID\");\n\t\t}\n\t\t/*unrecognized, assume name has colon in it*/\n\t\telse {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized import option %s, ignoring\\n\", ext+1));\n\t\t\tif (ext2) ext2[0] = ':';\n\t\t\text = ext2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (src_is_isom) {\n\t\t\tchar *opt = ext+1;\n\t\t\tchar *sep_eq = strchr(opt, '=');\n\t\t\tif (sep_eq) sep_eq[0] = 0;\n\t\t\tif (!mp4box_check_isom_fileopt(opt)) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\t! Import option `%s` not available for ISOBMFF/QT sources, ignoring !\\n\", ext+1));\n\t\t\t}\n\t\t\tif (sep_eq) sep_eq[0] = '=';\n\t\t}\n\n\t\tif (ext2) ext2[0] = ':';\n\n\t\text[0] = 0;\n\n\t\t/* restart from where we stopped\n\t\t * if we didn't stop (ext2 null) then the end has been reached\n\t\t * so we can stop the whole thing */\n\t\text = ext2;\n\t}\n\n\t/*check duration import (old syntax)*/\n\text = strrchr(final_name, '%');\n\tif (ext) {\n\t\tgf_parse_frac(ext+1, &import.duration);\n\t\text[0] = 0;\n\t}\n\n\t/*select switches for av containers import*/\n\tdo_audio = do_video = do_auxv = do_pict = 0;\n\ttrack_id = prog_id = 0;\n\tdo_all = 1;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, '#');\n\tif (ext) ext[0] = 0;\n\n\tif (fake_import && ext) {\n\t\text++;\n\t\tif (!strnicmp(ext, \"audio\", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, \"video\", 5)) do_video = 1;\n\t\telse if (!strnicmp(ext, \"auxv\", 4)) do_auxv = 1;\n\t\telse if (!strnicmp(ext, \"pict\", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, \"trackID=\", 8)) track_id = parse_u32(&ext[8], \"trackID\");\n\t\telse track_id = parse_u32(ext, \"ID\");\n\t}\n\telse if (ext) {\n\t\text++;\n\t\tchar *sep = gf_url_colon_suffix(ext, '=');\n\t\tif (sep) sep[0] = 0;\n\n\t\t//we have a fragment, we need to check if the track or the program is present in source\n\t\timport.in_name = final_name;\n\t\timport.flags = GF_IMPORT_PROBE_ONLY;\n\t\te = gf_media_import(&import);\n\t\tGOTO_EXIT(\"importing import\");\n\n\t\tif (!strnicmp(ext, \"audio\", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, \"video\", 5)) do_video = 1;\n        else if (!strnicmp(ext, \"auxv\", 4)) do_auxv = 1;\n        else if (!strnicmp(ext, \"pict\", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, \"trackID=\", 8)) track_id = parse_u32(&ext[8], \"trackID\");\n\t\telse if (!strnicmp(ext, \"PID=\", 4)) track_id = parse_u32(&ext[4], \"ID\");\n\t\telse if (!strnicmp(ext, \"program=\", 8)) {\n\t\t\tfor (i=0; i<import.nb_progs; i++) {\n\t\t\t\tif (!stricmp(import.pg_info[i].name, ext+8)) {\n\t\t\t\t\tprog_id = import.pg_info[i].number;\n\t\t\t\t\tdo_all = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext, \"prog_id=\", 8)) {\n\t\t\tprog_id = parse_u32(ext+8, \"prog_id\");\n\t\t\tdo_all = 0;\n\t\t}\n\t\telse track_id = parse_u32(ext, \"ID\");\n\n\t\t//figure out trackID\n\t\tif (do_audio || do_video || do_auxv || do_pict || track_id) {\n\t\t\tBool found = track_id ? GF_FALSE : GF_TRUE;\n\t\t\tfor (i=0; i<import.nb_tracks; i++) {\n\t\t\t\tif (track_id && (import.tk_info[i].track_num==track_id)) {\n\t\t\t\t\tfound=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (do_audio && (import.tk_info[i].stream_type==GF_STREAM_AUDIO)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_video && (import.tk_info[i].stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_auxv && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_AUXV)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_pict && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_PICT)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!track_id || !found) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot find track ID matching fragment #%s\\n\", ext));\n\t\t\t\tif (sep) sep[0] = ':';\n\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (sep) sep[0] = ':';\n\t}\n\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\n\n\tif (track_layout || is_chap) {\n\t\tu32 w, h, sw, sh, fw, fh;\n\t\tw = h = sw = sh = fw = fh = 0;\n\t\tchap_ref = 0;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n            case GF_ISOM_MEDIA_AUXV:\n            case GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\n\t\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\n\t\t\t\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\n\t\t\t\tif (w<sw) w = sw;\n\t\t\t\tif (w<fw) w = fw;\n\t\t\t\tif (h<sh) h = sh;\n\t\t\t\tif (h<fh) h = fh;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (track_layout) {\n\t\t\tif (!tw) tw = w;\n\t\t\tif (!th) th = h;\n\t\t\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\n\t\t\timport.text_width = tw;\n\t\t\timport.text_height = th;\n\t\t}\n\t\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\n\t}\n\tif (text_layout && txtw && txth) {\n\t\timport.text_track_width = import.text_width ? import.text_width : txtw;\n\t\timport.text_track_height = import.text_height ? import.text_height : txth;\n\t\timport.text_width = txtw;\n\t\timport.text_height = txth;\n\t\timport.text_x = txtx;\n\t\timport.text_y = txty;\n\t}\n\n\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\n\n\tsource_magic = (u64) gf_crc_32((u8 *)inName, (u32) strlen(inName));\n\tif (!fake_import && (!fsess || mux_args_if_first_pass)) {\n\t\timport.in_name = final_name;\n\t\timport.dest = dest;\n\t\timport.video_fps = force_fps;\n\t\timport.frames_per_sample = frames_per_sample;\n\t\timport.flags = import_flags;\n\t\timport.keep_audelim = keep_audelim;\n\t\timport.print_stats_graph = print_stats_graph;\n\t\timport.xps_inband = xps_inband;\n\t\timport.prog_id = prog_id;\n\t\timport.trackID = track_id;\n\t\timport.source_magic = source_magic;\n\t\timport.track_index = tk_idx;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (moov_timescale<0) {\n\t\t\timport.moov_timescale = moov_timescale;\n\t\t}\n\t\t//otherwise force it now\n\t\telse if (moov_timescale>0) {\n\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\tGOTO_EXIT(\"changing timescale\")\n\t\t}\n\n\t\timport.run_in_session = fsess;\n\t\timport.update_mux_args = NULL;\n\t\tif (do_all)\n\t\t\timport.flags |= GF_IMPORT_KEEP_REFS;\n\n\t\te = gf_media_import(&import);\n\t\tif (e) {\n\t\t\tif (import.update_mux_args) gf_free(import.update_mux_args);\n\t\t\tGOTO_EXIT(\"importing media\");\n\t\t}\n\n\t\tif (fsess) {\n\t\t\t*mux_args_if_first_pass = import.update_mux_args;\n\t\t\timport.update_mux_args = NULL;\n\t\t\t*mux_sid_if_first_pass = import.update_mux_sid;\n\t\t\timport.update_mux_sid = NULL;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tnb_tracks = gf_isom_get_track_count(dest);\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu32 media_type;\n\t\ttrack = i+1;\n\t\tmedia_type = gf_isom_get_media_type(dest, track);\n\t\te = GF_OK;\n\t\tif (!fake_import) {\n\t\t\tu64 tk_source_magic;\n\t\t\ttk_source_magic = gf_isom_get_track_magic(dest, track);\n\n\t\t\tif ((tk_source_magic & 0xFFFFFFFFUL) != source_magic)\n\t\t\t\tcontinue;\n\t\t\ttk_source_magic>>=32;\t\t\n\t\t\tkeep_handler = (tk_source_magic & 1) ? GF_TRUE : GF_FALSE;\n\t\t} else {\n\t\t\tkeep_handler = GF_TRUE;\n\n\t\t\tif (do_audio && (media_type!=GF_ISOM_MEDIA_AUDIO)) continue;\n\t\t\tif (do_video && (media_type!=GF_ISOM_MEDIA_VISUAL)) continue;\n\t\t\tif (do_auxv && (media_type!=GF_ISOM_MEDIA_AUXV)) continue;\n\t\t\tif (do_pict && (media_type!=GF_ISOM_MEDIA_PICT)) continue;\n\t\t\tif (track_id && (gf_isom_get_track_id(dest, track) != track_id))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttimescale = gf_isom_get_timescale(dest);\n\t\tif (szLan) {\n\t\t\te = gf_isom_set_media_language(dest, track, (char *) szLan);\n\t\t\tGOTO_EXIT(\"changing language\")\n\t\t}\n\t\tif (do_disable) {\n\t\t\te = gf_isom_set_track_enabled(dest, track, (do_disable==2) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT(\"disabling track\")\n\t\t}\n\t\tif (track_flags_mode) {\n\t\t\te = gf_isom_set_track_flags(dest, track, track_flags, track_flags_mode);\n\t\t\tGOTO_EXIT(\"disabling track\")\n\t\t}\n\n\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST) {\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\tGOTO_EXIT(\"removing edits\")\n\t\t}\n\t\tif (delay.num && delay.den) {\n\t\t\tu64 tk_dur;\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\ttk_dur = gf_isom_get_track_duration(dest, track);\n\t\t\tif (delay.num>0) {\n\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\te |= gf_isom_append_edit(dest, track, ((s64) delay.num) * timescale / delay.den, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t} else {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\tu64 to_skip = ((s64) -delay.num) * timescale / delay.den;\n\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\t\tu64 media_time = ((s64) -delay.num) * gf_isom_get_media_timescale(dest, track) / delay.den;\n\t\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: request negative delay longer than track duration - ignoring\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tGOTO_EXIT(\"assigning delay\")\n\t\t}\n\t\tif (gf_isom_is_video_handler_type(media_type)) {\n\t\t\tif (((par_n>=0) && (par_d>=0)) || force_par) {\n\t\t\t\te = gf_media_change_par(dest, track, par_n, par_d, force_par, rewrite_bs);\n\t\t\t\tGOTO_EXIT(\"changing PAR\")\n\t\t\t}\n\t\t\tif ((fullrange>=0) || (videofmt>=0) || (colorprim>=0) || (colortfc>=0) || (colormx>=0)) {\n\t\t\t\te = gf_media_change_color(dest, i+1, fullrange, videofmt, colorprim, colortfc, colormx);\n\t\t\t\tGOTO_EXIT(\"changing color in bitstream\")\n\t\t\t}\n\t\t\tif (has_clap) {\n\t\t\t\te = gf_isom_set_clean_aperture(dest, track, 1, clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod);\n\t\t\t\tGOTO_EXIT(\"changing clean aperture\")\n\t\t\t}\n\t\t\tif (bitdepth) {\n\t\t\t\te = gf_isom_set_visual_bit_depth(dest, track, 1, bitdepth);\n\t\t\t\tGOTO_EXIT(\"changing bit depth\")\n\t\t\t}\n\t\t\tif (clr_type) {\n\t\t\t\tif (clr_type==(u32)-1)\n\t\t\t\t\tclr_type = 0;\n\n\t\t\t\te = gf_isom_set_visual_color_info(dest, track, 1, clr_type, clr_prim, clr_tranf, clr_mx, clr_full_range, icc_data, icc_size);\n\t\t\t\tGOTO_EXIT(\"changing color info\")\n\t\t\t}\n\t\t\tif (hdr_file) {\n\t\t\t\te = parse_high_dynamc_range_xml_desc(dest, track, hdr_file);\n\t\t\t\tGOTO_EXIT(\"setting HDR info\")\n\t\t\t}\n\t\t\tif (dv_profile[0]) {\n\t\t\t\te = set_dv_profile(dest, track, dv_profile);\n\t\t\t\tGOTO_EXIT(\"setting DV profile\")\n\t\t\t}\n\n\t\t\tif (set_ccst) {\n\t\t\t\te = gf_isom_set_image_sequence_coding_constraints(dest, track, 1, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\t\tGOTO_EXIT(\"setting image sequence constraints\")\n\t\t\t}\n\t\t}\n\t\tif (has_mx) {\n\t\t\te = gf_isom_set_track_matrix(dest, track, mx);\n\t\t\tGOTO_EXIT(\"setting track matrix\")\n\t\t}\n\t\tif (use_stz2) {\n\t\t\te = gf_isom_use_compact_size(dest, track, GF_TRUE);\n\t\t\tGOTO_EXIT(\"setting compact size\")\n\t\t}\n\n\t\tif (gf_isom_get_media_subtype(dest, track, 1) == GF_ISOM_MEDIA_TIMECODE) {\n\t\t\ttmcd_track = track;\n\t\t}\n\t\tif (rap_only || refs_only) {\n\t\t\te = gf_media_remove_non_rap(dest, track, refs_only);\n\t\t\tGOTO_EXIT(\"removing non RAPs\")\n\t\t}\n\t\tif (handler_name) {\n\t\t\te = gf_isom_set_handler_name(dest, track, handler_name);\n\t\t\tGOTO_EXIT(\"setting handler name\")\n\t\t}\n\t\telse if (!keep_handler) {\n\t\t\tchar szHName[1024];\n\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\tfName = strchr(fName, '.');\n\t\t\tif (fName) fName += 1;\n\t\t\telse fName = \"?\";\n\n\t\t\tsprintf(szHName, \"%s@GPAC%s\", fName, gf_gpac_version());\n\t\t\te = gf_isom_set_handler_name(dest, track, szHName);\n\t\t\tGOTO_EXIT(\"setting handler name\")\n\t\t}\n\t\tif (handler) {\n\t\t\te = gf_isom_set_media_type(dest, track, handler);\n\t\t\tGOTO_EXIT(\"setting media type\")\n\t\t}\n\t\tif (group) {\n\t\t\te = gf_isom_set_alternate_group_id(dest, track, group);\n\t\t\tGOTO_EXIT(\"setting alternate group\")\n\t\t}\n\n\t\tif (track_layout) {\n\t\t\te = gf_isom_set_track_layout_info(dest, track, tw<<16, th<<16, tx<<16, ty<<16, tz);\n\t\t\tGOTO_EXIT(\"setting track layout\")\n\t\t}\n\t\tif (stype) {\n\t\t\te = gf_isom_set_media_subtype(dest, track, 1, stype);\n\t\t\tGOTO_EXIT(\"setting media subtype\")\n\t\t}\n\t\tif (is_chap && chap_ref) {\n\t\t\te = set_chapter_track(dest, track, chap_ref);\n\t\t\tGOTO_EXIT(\"setting chapter track\")\n\t\t}\n\n\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\te = gf_isom_add_track_kind(dest, i+1, kind_scheme, kind_value);\n\t\t\tGOTO_EXIT(\"setting track kind\")\n\t\t}\n\n\t\tif (profile || compat || level) {\n\t\t\te = gf_media_change_pl(dest, track, profile, compat, level);\n\t\t\tGOTO_EXIT(\"changing video PL\")\n\t\t}\n\t\tif (gf_isom_get_mpeg4_subtype(dest, track, 1))\n\t\t\tkeep_sys_tracks = 1;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (fake_import) {\n\t\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST)\n\t\t\t\tgf_isom_remove_edits(dest, track);\n\n\t\t\tif (moov_timescale<0) {\n\t\t\t\tmoov_timescale = gf_isom_get_media_timescale(dest, track);\n\t\t\t}\n\t\t\tif (moov_timescale>0) {\n\t\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\t\tGOTO_EXIT(\"changing timescale\")\n\t\t\t}\n\n\t\t\tif (import.asemode && (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\tu32 sr, ch, bps;\n\t\t\t\tgf_isom_get_audio_info(dest, track, 1, &sr, &ch, &bps);\n\t\t\t\tgf_isom_set_audio_info(dest, track, 1, sr, ch, bps, import.asemode);\n\t\t\t}\n\t\t}\n\n\t\tif (roll_change) {\n\t\t\tif ((roll_change!=3) || (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\te = gf_isom_set_sample_roll_group(dest, track, (u32) -1, (roll_change==2) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL, roll);\n\t\t\t\tGOTO_EXIT(\"assigning roll\")\n\t\t\t}\n\t\t}\n\n\t\tif (new_timescale>1) {\n\t\t\te = gf_isom_set_media_timescale(dest, track, new_timescale, 0, 0);\n\t\t\tGOTO_EXIT(\"setting media timescale\")\n\t\t}\n\n\t\tif (rescale_num > 1) {\n\t\t\tswitch (gf_isom_get_media_type(dest, track)) {\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!rescale_override) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Cannot force media timescale for audio media types - ignoring\\n\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, rescale_num, rescale_den, rescale_override ? 2 : 1);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Rescale ignored, same config in source file\\n\"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\t\t\t\tGOTO_EXIT(\"rescaling media track\")\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (src_is_isom && force_fps.den && force_fps.num) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, track))) {\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, force_fps.num, force_fps.den, 2);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Rescale ignored, same config in source file\\n\"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Cannot force FPS for media types %s - ignoring\\n\", gf_4cc_to_str( gf_isom_get_media_type(dest, track)) ));\n\t\t\t}\n\t\t}\n\n\t\tif (has_last_sample_dur) {\n\t\t\te = gf_isom_set_last_sample_duration_ex(dest, track, last_sample_dur.num, last_sample_dur.den);\n\t\t\tGOTO_EXIT(\"setting last sample duration\")\n\t\t}\n\t\tif (rvc_config) {\n#ifdef GPAC_DISABLE_ZLIB\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error: no zlib support - RVC not available\\n\"));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n#else\n\t\t\tu8 *data;\n\t\t\tu32 size;\n\t\t\te = gf_file_load_data(rvc_config, (u8 **) &data, &size);\n\t\t\tGOTO_EXIT(\"loading RVC config file\")\n\n\t\t\tgf_gz_compress_payload(&data, size, &size);\n\t\t\te |= gf_isom_set_rvc_config(dest, track, 1, 0, \"application/rvc-config+xml+gz\", data, size);\n\t\t\tgf_free(data);\n\t\t\tGOTO_EXIT(\"compressing and assigning RVC config\")\n#endif\n\t\t} else if (rvc_predefined>0) {\n\t\t\te = gf_isom_set_rvc_config(dest, track, 1, rvc_predefined, NULL, NULL, 0);\n\t\t\tGOTO_EXIT(\"setting RVC predefined config\")\n\t\t}\n\n\t\tif (neg_ctts_mode) {\n\t\t\te = gf_isom_set_composition_offset_mode(dest, track, (neg_ctts_mode==1) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT(\"setting composition offset mode\")\n\t\t}\n\n\t\tif (gf_isom_get_avc_svc_type(dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\tcheck_track_for_svc = track;\n\n\t\tswitch (gf_isom_get_hevc_lhvc_type(dest, track, 1)) {\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\tcheck_track_for_hevc=1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (txt_flags) {\n\t\t\te = gf_isom_text_set_display_flags(dest, track, 0, txt_flags, txt_mode);\n\t\t\tGOTO_EXIT(\"setting text track display flags\")\n\t\t}\n\n\t\tif (edits) {\n\t\t\te = apply_edits(dest, track, edits);\n\t\t\tGOTO_EXIT(\"applying edits\")\n\t\t}\n\n\t\tif (force_rate>=0) {\n\t\t\te = gf_isom_update_bitrate(dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\tGOTO_EXIT(\"updating bitrate\")\n\t\t}\n\n\t\tif (split_tile_mode) {\n\t\t\tswitch (gf_isom_get_media_subtype(dest, track, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((dlb_mode>=-1) && (gf_isom_get_media_subtype(dest, track, 1)==GF_ISOM_SUBTYPE_EC3)) {\n\t\t\tGF_AC3Config *ac3c = gf_isom_ac3_config_get(dest, track, 1);\n\t\t\tif (ac3c) {\n\t\t\t\tif (dlb_mode==0) {\n\t\t\t\t\tac3c->is_ec3 = GF_TRUE;\n\t\t\t\t\tac3c->atmos_ec3_ext=0;\n\t\t\t\t\tac3c->complexity_index_type=0;\n\t\t\t\t} else {\n\t\t\t\t\tu32 di;\n\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(dest, track, 1, &di);\n\t\t\t\t\tu32 pos;\n\t\t\t\t\tgf_eac3_parser(samp->data, samp->dataLength, &pos, ac3c, GF_TRUE);\n\n\t\t\t\t\tif (dlb_mode>0) {\n\t\t\t\t\t\tac3c->atmos_ec3_ext = 1;\n\t\t\t\t\t\tac3c->complexity_index_type = dlb_mode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_ac3_config_update(dest, track, 1, ac3c);\n\t\t\t\tgf_free(ac3c);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chapter_name) {\n\t\tif (is_chap_file) {\n\t\t\tGF_Fraction a_fps = {0,0};\n\t\t\te = gf_media_import_chapters(dest, chapter_name, a_fps, GF_FALSE);\n\t\t} else {\n\t\t\te = gf_isom_add_chapter(dest, 0, 0, chapter_name);\n\t\t}\n\t\tGOTO_EXIT(\"importing chapters\")\n\t}\n\n\tif (tmcd_track) {\n\t\tu32 tmcd_id = gf_isom_get_track_id(dest, tmcd_track);\n\t\tfor (i=0; i < gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_isom_set_track_reference(dest, i+1, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT(\"assigning TMCD track references\")\n\t\t}\n\t}\n\n\t/*force to rewrite all dependencies*/\n\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t{\n\t\te = gf_isom_rewrite_track_dependencies(dest, i);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Warning: track ID %d has references to a track not imported\\n\", gf_isom_get_track_id(dest, i) ));\n\t\t\te = GF_OK;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\n\t\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t\t{\n\t\t\te = gf_media_filter_hevc(dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: track ID %d: error while filtering LHVC layers\\n\", gf_isom_get_track_id(dest, i)));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (check_track_for_svc) {\n\t\tif (svc_mode) {\n\t\t\te = gf_media_split_svc(dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\n\t\t\tGOTO_EXIT(\"splitting SVC track\")\n\t\t} else {\n\t\t\te = gf_media_merge_svc(dest, check_track_for_svc, 1);\n\t\t\tGOTO_EXIT(\"merging SVC/SHVC track\")\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (check_track_for_lhvc) {\n\t\tif (svc_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\n\t\t\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\n\t\t\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\n\t\t\tGOTO_EXIT(\"splitting L-HEVC track\")\n\t\t} else {\n\t\t\t//TODO - merge, temporal sublayers\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_HEVC\n\tif (check_track_for_hevc) {\n\t\tif (split_tile_mode) {\n\t\t\te = gf_media_split_hevc_tiles(dest, split_tile_mode - 1);\n\t\t\tGOTO_EXIT(\"splitting HEVC tiles\")\n\t\t}\n\t\tif (temporal_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\n\t\t\tGOTO_EXIT(\"splitting HEVC temporal sublayers\")\n\t\t}\n\t}\n#endif\n\n\tif (tc_fps_num) {\n\t\tu32 desc_index=0;\n\t\tu32 tmcd_tk, tmcd_id;\n\t\tu32 video_ref = 0;\n\t\tGF_BitStream *bs;\n\t\tGF_ISOSample *samp;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, i+1))) {\n\t\t\t\tvideo_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttmcd_tk = gf_isom_new_track(dest, 0, GF_ISOM_MEDIA_TIMECODE, tc_fps_num);\n\t\tif (!tmcd_tk) {\n\t\t\te = gf_isom_last_error(dest);\n\t\t\tGOTO_EXIT(\"creating TMCD track\")\n\t\t}\n\t\te = gf_isom_set_track_enabled(dest, tmcd_tk, 1);\n\t\tif (e != GF_OK) {\n\t\t\tGOTO_EXIT(\"enabling TMCD track\")\n\t\t}\n\n\t\tif (!tc_frames_per_tick) {\n\t\t\ttc_frames_per_tick = tc_fps_num;\n\t\t\ttc_frames_per_tick /= tc_fps_den;\n\t\t\tif (tc_frames_per_tick * tc_fps_den < tc_fps_num)\n\t\t\t\ttc_frames_per_tick++;\n\t\t}\n\n\t\tu32 tmcd_value = (tc_h * 3600 + tc_m*60 + tc_s)*tc_frames_per_tick+tc_f;\n\t\ttmcd_id = gf_isom_get_track_id(dest, tmcd_tk);\n\n\t\te = gf_isom_tmcd_config_new(dest, tmcd_tk, tc_fps_num, tc_fps_den, tc_frames_per_tick, tc_drop_frame, tc_force_counter, &desc_index);\n\t\tGOTO_EXIT(\"configuring TMCD sample description\")\n\n\t\tif (video_ref) {\n\t\t\te = gf_isom_set_track_reference(dest, video_ref, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT(\"assigning TMCD track ref on video track\")\n\t\t}\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, tmcd_value);\n\t\tsamp = gf_isom_sample_new();\n\t\tsamp->IsRAP = SAP_TYPE_1;\n\t\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\t\tgf_bs_del(bs);\n\t\te = gf_isom_add_sample(dest, tmcd_tk, desc_index, samp);\n\t\tgf_isom_sample_del(&samp);\n\t\tGOTO_EXIT(\"assigning TMCD sample\")\n\n\t\tif (video_ref) {\n\t\t\tu64 video_ref_dur = gf_isom_get_media_duration(dest, video_ref);\n\t\t\tvideo_ref_dur *= tc_fps_num;\n\t\t\tvideo_ref_dur /= gf_isom_get_media_timescale(dest, video_ref);\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, (u32) video_ref_dur);\n\t\t} else {\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, tc_fps_den ? tc_fps_den : 1);\n\t\t}\n\t\tGOTO_EXIT(\"setting TMCD sample dur\")\n\t}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nexit:\n\twhile (gf_list_count(kinds)) {\n\t\tchar *kind = (char *)gf_list_get(kinds, 0);\n\t\tgf_list_rem(kinds, 0);\n\t\tif (kind) gf_free(kind);\n\t}\n\tif (opt_src) opt_src[0] = ':';\n\tif (opt_dst) opt_dst[0] = ':';\n\tif (fchain) fchain[0] = ':';\n\tif (hdr_file) gf_free(hdr_file);\n\n\tgf_list_del(kinds);\n\tif (handler_name) gf_free(handler_name);\n\tif (chapter_name ) gf_free(chapter_name);\n\tif (import.fontName) gf_free(import.fontName);\n\tif (import.streamFormat) gf_free(import.streamFormat);\n\tif (import.force_ext) gf_free(import.force_ext);\n\tif (rvc_config) gf_free(rvc_config);\n\tif (edits) gf_free(edits);\n\tif (szLan) gf_free((char *)szLan);\n\tif (icc_data) gf_free(icc_data);\n\tif (final_name) gf_free(final_name);\n\n\tif (!e) return GF_OK;\n\tif (fail_msg) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failure while %s: %s\\n\", fail_msg, gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n",
                    "caller_start": 622,
                    "file_path": "applications/mp4box/fileimport.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1273,
                    "call_code": "gf_media_split_hevc_tiles(movie, 0)",
                    "caller_code": "static GF_Err gf_isom_iff_create_image_item_from_track_internal(GF_ISOFile *movie, Bool root_meta, u32 meta_track_number, u32 imported_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs, u32 sample_number) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_Err e;\n\tu32 w, h, hSpacing, vSpacing;\n\tu8 num_channels;\n\tu8 bits_per_channel[3];\n\tu32 subtype;\n\tGF_ISOSample *sample = NULL;\n\tu32 timescale;\n\tu32 item_type = 0;\n\tGF_ImageItemProperties local_image_props;\n\tGF_ImageItemProtection ipro, *orig_ipro = NULL;\n\tBool config_needed = 0;\n\tGF_Box *config_box = NULL;\n\tBool is_cenc = GF_FALSE;\n\tBool is_first = GF_TRUE;\n\tBool neg_time = (image_props && image_props->time<0) ? GF_TRUE : GF_FALSE;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0, sai_alloc_size = 0;\n\tu32 sample_desc_index = 0;\n\tGF_ISOFile *fsrc = movie;\n\tBool reset_brands = GF_FALSE;\n\n\t//only reset brands if first item import\n\tif (!gf_isom_get_meta_item_count(movie, root_meta, meta_track_number))\n\t\treset_brands = GF_TRUE;\n\n\tif (image_props && image_props->src_file)\n\t\tfsrc = image_props->src_file;\n\n\tif (image_props && image_props->tile_mode != TILE_ITEM_NONE) {\n\t\t/* Processing the input file in Tiled mode:\n\t\t   The single track is split into multiple tracks\n\t\t   and each track is processed to create an item */\n\t\tu32 i, count;\n\t\tu32 tile_track;\n\t\tGF_List *tile_item_ids;\n\t\tchar sz_item_name[256];\n\t\tGF_TileItemMode orig_tile_mode;\n\n#if !defined(GPAC_DISABLE_HEVC) && !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (image_props->src_file)\n\t\t\te = GF_SERVICE_ERROR;\n\t\telse\n\t\t\te = gf_media_split_hevc_tiles(movie, 0);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\n\t\tif (e) return e;\n\t\ttile_item_ids = gf_list_new();\n\t\torig_tile_mode = image_props->tile_mode;\n\t\timage_props->tile_mode = TILE_ITEM_NONE;\n\t\tcount = gf_isom_get_reference_count(movie, imported_track, GF_ISOM_REF_SABT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_malloc(sizeof(u32));\n\t\t\tif (!tile_item_id) return GF_OUT_OF_MEM;\n\n\t\t\t*tile_item_id = item_id + i+1;\n\t\t\tgf_list_add(tile_item_ids, tile_item_id);\n\t\t\te = gf_isom_get_reference(movie, imported_track, GF_ISOM_REF_SABT, 1, &tile_track);\n\t\t\tif (e) return e;\n\t\t\tif (item_name)\n\t\t\t\tsprintf(sz_item_name, \"%s-Tile%d\", item_name, i + 1);\n\t\t\tif (orig_tile_mode != TILE_ITEM_SINGLE || image_props->single_tile_number == i + 1) {\n\t\t\t\te = gf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, tile_track, item_name ? sz_item_name : NULL, *tile_item_id, NULL, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t\tgf_isom_remove_track(movie, tile_track);\n\t\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\t\te = gf_isom_meta_add_item_ref(movie, root_meta, meta_track_number, *tile_item_id, item_id, GF_ISOM_REF_TBAS, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (item_name)\n\t\t\tsprintf(sz_item_name, \"%s-TileBase\", item_name);\n\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\tgf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, imported_track, item_name ? sz_item_name : NULL, item_id, image_props, tile_item_ids);\n\t\t}\n\t\telse if (orig_tile_mode == TILE_ITEM_ALL_GRID) {\n\t\t\t// TODO\n\t\t}\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_list_get(tile_item_ids, i);\n\t\t\tgf_free(tile_item_id);\n\t\t}\n\t\tgf_list_del(tile_item_ids);\n\t\treturn GF_OK;\n\t}\n\n\tif (!image_props) {\n\t\timage_props = &local_image_props;\n\t\tmemset(image_props, 0, sizeof(GF_ImageItemProperties));\n\t} else {\n\t\torig_ipro = image_props->cenc_info;\n\t\timage_props->cenc_info = NULL;\n\t}\n\n\tif (!imported_track) {\n\t\tGF_ImageItemProperties src_props;\n\t\tu32 item_idx, ref_id;\n\t\tu32 scheme_type=0, scheme_version=0;\n\t\tconst char *orig_item_name, *orig_item_mime_type, *orig_item_encoding;\n\t\tif (!image_props->item_ref_id) return GF_BAD_PARAM;\n\n\t\tif (gf_isom_meta_get_item_ref_count(fsrc, GF_TRUE, 0, image_props->item_ref_id, GF_4CC('d','i','m','g')) > 0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Cannnot import derived image, only native image import is supported\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\titem_idx = gf_isom_get_meta_item_by_id(fsrc, GF_TRUE, 0, image_props->item_ref_id);\n\t\tif (!item_idx) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: No item with ID %d, cannnot import\\n\", image_props->item_ref_id));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\torig_item_name = orig_item_mime_type = orig_item_encoding = NULL;\n\t\tgf_isom_get_meta_item_info(fsrc, GF_TRUE, 0, item_idx, &ref_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &orig_item_name, &orig_item_mime_type, &orig_item_encoding);\n\n\t\tif (!ref_id) return GF_BAD_PARAM;\n\t\tif (ref_id != image_props->item_ref_id) return GF_ISOM_INVALID_FILE;\n\n\t\tgf_isom_get_meta_image_props(fsrc, GF_TRUE, 0, ref_id, &src_props, NULL);\n\n\t\timage_props->config = src_props.config;\n\t\timage_props->width = src_props.width;\n\t\timage_props->height = src_props.height;\n\t\timage_props->num_channels = src_props.num_channels;\n\t\tmemcpy(image_props->av1_layer_size, src_props.av1_layer_size, sizeof(u32)*3);\n\t\tmemcpy(image_props->bits_per_channel, src_props.bits_per_channel, sizeof(u32)*3);\n\t\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\t\timage_props->hSpacing = src_props.hSpacing;\n\t\t\timage_props->vSpacing = src_props.vSpacing;\n\t\t}\n\t\tif (image_props->copy_props) {\n\t\t\tif (!image_props->hOffset && !image_props->vOffset) {\n\t\t\t\timage_props->hOffset = src_props.hOffset;\n\t\t\t\timage_props->vOffset = src_props.vOffset;\n\t\t\t}\n\t\t\tif (!image_props->clap_wden) {\n\t\t\t\timage_props->clap_wnum = src_props.clap_wnum;\n\t\t\t\timage_props->clap_wden = src_props.clap_wden;\n\t\t\t\timage_props->clap_hnum = src_props.clap_hnum;\n\t\t\t\timage_props->clap_hden = src_props.clap_hden;\n\t\t\t\timage_props->clap_honum = src_props.clap_honum;\n\t\t\t\timage_props->clap_hoden = src_props.clap_hoden;\n\t\t\t\timage_props->clap_vonum = src_props.clap_vonum;\n\t\t\t\timage_props->clap_voden = src_props.clap_voden;\n\t\t\t}\n\t\t\tif (!image_props->alpha) image_props->alpha = src_props.alpha;\n\t\t\tif (!image_props->depth) image_props->depth = src_props.depth;\n\t\t\tif (!image_props->hidden) image_props->hidden = src_props.hidden;\n\t\t\tif (!image_props->angle) image_props->angle = src_props.angle;\n\t\t\tif (!image_props->mirror) image_props->mirror = src_props.mirror;\n\t\t\tif (!image_props->av1_op_index) image_props->av1_op_index = src_props.av1_op_index;\n\t\t}\n\t\tif (!item_name) item_name = orig_item_name;\n\n\t\tif (!image_props->use_reference || (fsrc == image_props->src_file)) {\n\t\t\tu8 *data = NULL;\n\t\t\tu32 size=0;\n\t\t\te = gf_isom_extract_meta_item_mem(fsrc, GF_TRUE, 0, ref_id, &data, &size, &size, NULL, GF_FALSE);\n\t\t\tif (e) return GF_BAD_PARAM;\n\n\t\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, data, size, NULL);\n\t\t\tif (data) gf_free(data);\n\t\t} else {\n\t\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, 0, ref_id);\n\t\t}\n\t\treturn e;\n\t}\n\nimport_next_sample:\n\n\ttimescale = gf_isom_get_media_timescale(fsrc, imported_track);\n\tif (image_props->sample_num) {\n\t\tsample_number = image_props->sample_num;\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else if (image_props->time<0) {\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else {\n\t\te = gf_isom_get_sample_for_media_time(fsrc, imported_track, (u64)(image_props->time*timescale), &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &sample, &sample_number, NULL);\n\t}\n\tif (e || !sample || !sample->IsRAP) {\n\t\tif (!sample) {\n\t\t\tif (is_first) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"No sample found%s\\n\", (image_props->time<0) ? \"\" : \" for requested time\"));\n\t\t\t} else {\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if ((image_props->time<0) || (image_props->step_time)) {\n\t\t\tif (image_props->sample_num) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: imported sample %d (DTS \"LLU\") is not a sync sample (RAP %d size %d)\\n\", sample_number, sample->DTS, sample->IsRAP, sample->dataLength));\n\t\t\t} else if (image_props->step_time) {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\tsample_number++;\n\t\t\t\tif (sample_number == gf_isom_get_sample_count(fsrc, imported_track)) {\n\t\t\t\t\te = GF_OK;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgoto import_next_sample;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error no sync sample found after time %g\\n\", image_props->time));\n\t\t}\n\t\tif (!e) e = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the track type is supported as item type */\n\t/* Get the config box if needed */\n\tsubtype = gf_isom_get_media_subtype(fsrc, imported_track, sample_desc_index);\n\tif (gf_isom_is_media_encrypted(fsrc, imported_track, sample_desc_index)) {\n\t\tif (gf_isom_is_cenc_media(fsrc, imported_track, sample_desc_index)) {\n\t\t\te = gf_isom_get_original_format_type(fsrc, imported_track, sample_desc_index, &subtype);\n\t\t\tif (e) goto exit;\n\t\t\tis_cenc = GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Protected sample not using CENC, cannot add as item\\n\"));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_avc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_svc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_mvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_hevc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\tif (subtype == GF_ISOM_SUBTYPE_HVT1) {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVT1;\n\t\t}\n\t\telse {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tconfig_needed = 1;\n\t\tif (!((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_lhvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t}\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_AV01:\n\t\t{\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_isom_av1_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\t\tconfig_needed = 1;\n\t\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\t\tnum_channels = 1;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = 0;\n\t\t\t\tbits_per_channel[2] = 0;\n\t\t\t} else {\n\t\t\t\tnum_channels = 3;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = depth;\n\t\t\t\tbits_per_channel[2] = depth;\n\t\t\t}\n\t\t\t// presence of OBU SH in config is not recommended and properties should be used instead of metadata OBUs\n\t\t\twhile (gf_list_count(((GF_AV1ConfigurationBox *)config_box)->config->obu_array)) {\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_pop_back(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t\tif (obu) {\n\t\t\t\t\tif (obu->obu) gf_free(obu->obu);\n\t\t\t\t\tgf_free(obu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config->obu_array = NULL;\n\t\t\te = gf_media_av1_layer_size_get(fsrc, imported_track, sample_number, image_props->av1_op_index, image_props->av1_layer_size);\n      if (e) {\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"AV1 operating point index out of range for stream\\n\"));\n        goto exit;\n      }\n\t\t\t//media_brand = GF_ISOM_BRAND_AVIF;\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_isom_vvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\tbits_per_channel[1] = bits_per_channel[2] = bits_per_channel[0];\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Codec not supported to create HEIF image items\\n\"));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto exit;\n\t}\n\tif (config_needed && !config_box && !((GF_AVCConfigurationBox *)config_box)->config) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Image type %s requires a missing configuration box\\n\", gf_4cc_to_str(item_type)));\n\t\te = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\t/* Get some images properties from the track data */\n\te = gf_isom_get_visual_info(fsrc, imported_track, sample_desc_index, &w, &h);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error determining image size\\n\"));\n\t\tgoto exit;\n\t}\n\te = gf_isom_get_pixel_aspect_ratio(fsrc, imported_track, sample_desc_index, &hSpacing, &vSpacing);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error determining image aspect ratio\\n\"));\n\t\tgoto exit;\n\t}\n\tif (!image_props->width && !image_props->height) {\n\t\timage_props->width = w;\n\t\timage_props->height = h;\n\t}\n\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\timage_props->hSpacing = hSpacing;\n\t\timage_props->vSpacing = vSpacing;\n\t}\n\timage_props->config = config_box;\n\tif (!image_props->num_channels) {\n\t\timage_props->num_channels = num_channels;\n\t\timage_props->bits_per_channel[0] = bits_per_channel[0];\n\t\timage_props->bits_per_channel[1] = bits_per_channel[1];\n\t\timage_props->bits_per_channel[2] = bits_per_channel[2];\n\t}\n\tif (is_cenc) {\n\t\tBool Is_Encrypted;\n\n\t\tmemset(&ipro, 0, sizeof(GF_ImageItemProtection));\n\t\tgf_isom_get_cenc_info(fsrc, imported_track, sample_desc_index, NULL, &ipro.scheme_type, &ipro.scheme_version);\n\t\te = gf_isom_get_sample_cenc_info(fsrc, imported_track, sample_desc_index, &Is_Encrypted, &ipro.crypt_byte_block, &ipro.skip_byte_block, &ipro.key_info, &ipro.key_info_size);\n\t\tif (e) goto exit;\n\n\t\tif (Is_Encrypted) {\n\t\t\tsai_size = sai_alloc_size;\n\t\t\te = gf_isom_cenc_get_sample_aux_info(fsrc, imported_track, sample_number, sample_desc_index, NULL, &sai, &sai_size);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (sai_size > sai_alloc_size)\n\t\t\t\tsai_alloc_size = sai_size;\n\n\t\t\tipro.sai_data = sai;\n\t\t\tipro.sai_data_size = sai_size;\n\t\t\timage_props->cenc_info = &ipro;\n\n\t\t\tif (is_first) {\n\t\t\t\tu32 i, nb_pssh = gf_isom_get_pssh_count(fsrc);\n\t\t\t\tfor (i=0; i<nb_pssh; i++) {\n\t\t\t\t\tbin128 SystemID;\n\t\t\t\t\tu32 version;\n\t\t\t\t\tu32 KID_count;\n\t\t\t\t\tconst bin128 *KIDs;\n\t\t\t\t\tconst u8 *private_data;\n\t\t\t\t\tu32 private_data_size;\n\n\t\t\t\t\tgf_isom_get_pssh_info(fsrc, i+1, SystemID, &version, &KID_count, &KIDs, &private_data, &private_data_size);\n\t\t\t\t\t\n\t\t\t\t\tgf_cenc_set_pssh(movie, SystemID, version, KID_count, (bin128 *) KIDs, (u8 *) private_data, private_data_size, 2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\timage_props->cenc_info = NULL;\n\t\t}\n\t}\n\tif (!item_id) {\n\t\te = gf_isom_meta_get_next_item_id(movie, root_meta, meta_track_number, &item_id);\n\t\tif (e) goto exit;\n\t}\n\tif (image_props->use_reference) {\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"referring trackID %d sample %d as item %d\\n\", imported_track, sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"referring trackID %d sample at time %.3f as item %d\\n\", imported_track, (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, imported_track, sample_number);\n\t} else {\n\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Adding sample %d as item %d\\n\", sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Adding sample at time %.3f as item %d\\n\", (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, sample->data, sample->dataLength, item_extent_refs);\n\t}\n\n\timage_props->cenc_info = NULL;\n\n\tif (reset_brands) {\n\t\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(movie);\n\n\t\t// TODO Analyze configuration to determine the brand */\n\t\t//if (media_brand) {\n\t\t//\tgf_isom_modify_alternate_brand(movie, media_brand, GF_TRUE);\n\t\t//}\n\t}\n\n\t\n\tif (neg_time)\n\t\timage_props->time = -1;\n\n\tif (!e && !image_props->sample_num && ((image_props->time<0) || image_props->end_time || image_props->step_time)) {\n\t\tif (image_props->end_time || image_props->step_time) {\n\t\t\tDouble t = (Double) (sample->DTS + sample->CTS_Offset);\n\t\t\tt /= timescale;\n\t\t\tif (image_props->step_time) {\n\t\t\t\tt += image_props->step_time;\n\t\t\t} else {\n\t\t\t\t//step 1ms\n\t\t\t\tt += 0.001;\n\t\t\t}\n\n\t\t\tif ((image_props->end_time>0) && (t>image_props->end_time)) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\timage_props->time = t;\n\t\t}\n\n\t\titem_id=0;\n\t\tgf_isom_sample_del(&sample);\n\t\tif (config_box) {\n\t\t\tgf_isom_box_del(config_box);\n\t\t\tconfig_box = NULL;\n\t\t}\n\t\tis_first = GF_FALSE;\n\t\tif (sample_number >= gf_isom_get_sample_count(fsrc, imported_track)) return e;\n\t\tsample_number++;\n\t\t//avoid recursion this could get quite big\n\t\tgoto import_next_sample;\n\t}\n\nexit:\n\tif (sai) gf_free(sai);\n\tgf_isom_sample_del(&sample);\n\tif (config_box) gf_isom_box_del(config_box);\n\timage_props->cenc_info = orig_ipro;\n\treturn e;\n\n\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n",
                    "caller_start": 1229,
                    "file_path": "src/isomedia/iff.c"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'gf_isom_get_sample', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}",
                    "start_line": 1934,
                    "end_line": 1937,
                    "full_name": "gf_isom_get_sample",
                    "file_path": "src/isomedia/isom_read.c"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'Media_GetSample', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n",
                    "start_line": 467,
                    "end_line": 680,
                    "full_name": "Media_GetSample",
                    "file_path": "src/isomedia/media.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func_file({'file_path': 'isomedia/media.c', 'func_name': 'Media_GetSample', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 182,
                    "call_code": "Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL)",
                    "caller_code": "static GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(mdia->nalu_parser) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(mdia->nalu_parser, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(mdia->nalu_parser) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tsample_offset = (s8) gf_bs_read_int(mdia->nalu_parser, 8);\n\t\t\tdata_offset = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"ISOBMF: Extractor target track is not present in file - skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\tif (!mdia->extracted_samp) return GF_IO_ERR;\n\t\t\t}\n\t\t\tif (!mdia->extracted_bs) {\n\t\t\t\tmdia->extracted_bs = gf_bs_new(\"a\", 1, GF_BITSTREAM_READ);\n\t\t\t\tif (!mdia->extracted_bs) return GF_IO_ERR;\n\t\t\t}\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\t\t\tif (!mdia->extracted_samp->alloc_size)\n\t\t\t\tmdia->extracted_samp->alloc_size = mdia->extracted_samp->dataLength;\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_bs_reassign_buffer(mdia->extracted_bs, mdia->extracted_samp->data + data_offset, mdia->extracted_samp->dataLength - data_offset);\n\n\t\t\tif (mdia->extracted_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(mdia->extracted_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer_alloc = ref_nalu_size;\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(mdia->extracted_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Extractor size is larger than referred sample size - skipping.\\n\"));\n\t\t\t}\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tif (nal_size - nb_bytes_nalh > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size - nb_bytes_nalh;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * (nal_size - nb_bytes_nalh) );\n\t\t}\n\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n",
                    "caller_start": 101,
                    "file_path": "src/isomedia/avc_ext.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 1916,
                    "call_code": "Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset)",
                    "caller_code": "GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n",
                    "caller_start": 1891,
                    "file_path": "src/isomedia/isom_read.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 2069,
                    "call_code": "Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset)",
                    "caller_code": "GF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}",
                    "caller_start": 2049,
                    "file_path": "src/isomedia/isom_read.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 2266,
                    "call_code": "Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset)",
                    "caller_code": "GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n",
                    "caller_start": 2142,
                    "file_path": "src/isomedia/isom_read.c"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'Media_RewriteODFrame', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}\n",
                    "start_line": 31,
                    "end_line": 229,
                    "full_name": "Media_RewriteODFrame",
                    "file_path": "src/isomedia/media_odf.c"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'gf_isom_nalu_sample_rewrite', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "GF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_BitStream *sei_suffix_bs = NULL;\n\tBool ps_transfered = GF_FALSE;\n\tu32 nal_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\tu8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tGF_ISOSample *base_samp;\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+base_samp->dataLength) ) {\n\t\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+base_samp->dataLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\n\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\ttile_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+tile_samp->dataLength) ) {\n\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+tile_samp->dataLength;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->child_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(mdia, sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (!entry) return GF_BAD_PARAM;\n\n\t//this is a compatible HEVC, don't insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config && entry->avc_config->config)\n\t\t\tnal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\t\tnal_unit_size_field = entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\t//setup PS rewriter\n\tif (!mdia->nalu_ps_bs)\n\t\tmdia->nalu_ps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_seek(mdia->nalu_ps_bs, 0);\n\n\t//setup sample reader\n\tif (mdia->in_sample_buffer_alloc<sample->dataLength) {\n\t\tmdia->in_sample_buffer_alloc = sample->dataLength;\n\t\tmdia->in_sample_buffer = gf_realloc(mdia->in_sample_buffer, sample->dataLength);\n\t}\n\tmemcpy(mdia->in_sample_buffer, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) {\n\t\tmdia->nalu_parser = gf_bs_new(mdia->in_sample_buffer, sample->dataLength, GF_BITSTREAM_READ);\n\t\tif (!mdia->nalu_parser && sample->data) return GF_ISOM_INVALID_FILE;\n\t} else {\n\t\te = gf_bs_reassign_buffer(mdia->nalu_parser, mdia->in_sample_buffer, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\t//setup output\n\tif (!mdia->nalu_out_bs) {\n\t\tu8 *output;\n\t\tu32 outSize;\n\t\tmdia->nalu_out_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_get_content(mdia->nalu_out_bs, &output, &outSize);\n\t}\n\n\tgf_bs_reassign_buffer(mdia->nalu_out_bs, sample->data, sample->alloc_size ? sample->alloc_size : sample->dataLength);\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don't write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don't insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\tBool has_vps = GF_FALSE;\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc, &has_vps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc, &has_vps);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (! ps_transfered) {\n\t\t\t\t\tnal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\t\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tps_transfered = GF_TRUE;\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (! ps_transfered)\n\t\t{\n\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t}\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\t\treturn GF_OK;\n\t}\n\n\tif (!mdia->tmp_nal_copy_buffer) {\n\t\tmdia->tmp_nal_copy_buffer = gf_malloc(sizeof(char) * 4096);\n\t\tmdia->tmp_nal_copy_buffer_alloc = 4096;\n\t}\n\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tnal_size = gf_bs_read_int(mdia->nalu_parser, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(mdia->nalu_parser) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n\", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char)*nal_size);\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tGF_BitStream *write_to_bs = mdia->nalu_out_bs;\n#endif\n\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tswitch (nal_type) {\n\t\t\t/*we already wrote AU delim, and we trash aggregators*/\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FF_AGGREGATOR:\n\t\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-2);\n\t\t\t\tcontinue;\n\n\t\t\t//extractor\n\t\t\tcase GF_HEVC_NALU_FF_EXTRACTOR:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(mdia->nalu_out_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\tif (sei_suffix_bs) gf_bs_del(sei_suffix_bs);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid nal size %d in sample %d\\n\", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tcase GF_AVC_NALU_FF_AGGREGATOR:\n\t\t\t/*we already wrote this stuff, and we trash aggregators*/\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase GF_AVC_NALU_FF_EXTRACTOR:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (!ps_transfered) {\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(mdia->nalu_out_bs, sei_suffix_bs, GF_FALSE);\n\t}\n\t/*done*/\n\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (sei_suffix_bs)\n\t\tgf_bs_del(sei_suffix_bs);\n\n\treturn e;\n}\n",
                    "start_line": 401,
                    "end_line": 845,
                    "full_name": "gf_isom_nalu_sample_rewrite",
                    "file_path": "src/isomedia/avc_ext.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func_file({'file_path': 'isomedia/media.c', 'func_name': 'Media_RewriteODFrame', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 655,
                    "call_code": "Media_RewriteODFrame(mdia, *samp)",
                    "caller_code": "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n",
                    "caller_start": 467,
                    "file_path": "src/isomedia/media.c"
                }
            ]
        }
    ],
    "analysis": {
        "patch": [
            {
                "func_name": "gf_media_split_hevc_tiles",
                "patch": "--- func_before\n+++ func_after\n@@ -3544,6 +3544,10 @@\n \t\tu32 size, nb_nalus=0, nb_nal_entries=0, last_tile_group=(u32) -1;\n \t\tGF_BitStream *bs=NULL;\n \t\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\n+\t\tif (!sample) {\n+\t\t\te = gf_isom_last_error(file);\n+\t\t\tgoto err_exit;\n+\t\t}\n \n \t\tdata = (u8 *) sample->data;\n \t\tsize = sample->dataLength;",
                "file_path": "src/media_tools/isom_tools.c"
            }
        ],
        "msg": "fixed #2359",
        "description": "GPAC MP4Box 2.1-DEV-rev649-ga8f438d20 has a segment fault (/stack overflow) due to infinite recursion in Media_GetSample isomedia/media.c:662",
        "language": "c",
        "vulnerability_type": "memory",
        "repair_strategy": "The patch adds a null check for `sample` after calling `gf_isom_get_sample` in `isom_tools.c:3544`, preventing dereference of a null pointer which would cause a segmentation fault. If `sample` is null, it retrieves the error and exits via `err_exit`.",
        "need_context": true,
        "required_context": [
            "function: Media_RewriteODFrame in isomedia/media.c",
            "function: gf_isom_nalu_sample_rewrite in isomedia/isom_nalu.c",
            "caller: callers of Media_RewriteODFrame in isomedia/media.c"
        ],
        "confidence_score": 0.75,
        "root_cause": "Infinite recursion occurs in Media_GetSample (media.c:467-680) when processing samples via gf_media_split_hevc_tiles (isom_tools.c:3544) → gf_isom_get_sample (isom_read.c:1891) → Media_GetSample. The recursion likely involves Media_RewriteODFrame or gf_isom_nalu_sample_rewrite, which may re-trigger Media_GetSample without proper termination. The patch adds a null check but does not address the recursive call chain.",
        "analysis": "The vulnerability stems from infinite recursion in Media_GetSample (media.c), triggered via gf_media_split_hevc_tiles → gf_isom_get_sample → Media_GetSample. The patch in isom_tools.c prevents null dereference but does not resolve the recursion. Media_GetSample calls stbl_findEntryForTime and potentially re-enters via Media_RewriteODFrame/gf_isom_nalu_sample_rewrite, but their implementations are missing. The exact recursive path requires these functions' code."
    },
    "iteration": 3,
    "history": [
        {
            "stage": "initial",
            "prompt": "You are a senior security engineer. Using **only the provided patch and description**, and **restricted to context retrievable by the 'caller' and 'function' tools**, perform the initial vulnerability analysis.\n\n## INPUTS\n- **Commit Message**: fixed #2359\n- **Vulnerability Description**: GPAC MP4Box 2.1-DEV-rev649-ga8f438d20 has a segment fault (/stack overflow) due to infinite recursion in Media_GetSample isomedia/media.c:662\n- **Patch Code**: [{'func_name': 'gf_media_split_hevc_tiles', 'patch': '--- func_before\\n+++ func_after\\n@@ -3544,6 +3544,10 @@\\n \\t\\tu32 size, nb_nalus=0, nb_nal_entries=0, last_tile_group=(u32) -1;\\n \\t\\tGF_BitStream *bs=NULL;\\n \\t\\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\\n+\\t\\tif (!sample) {\\n+\\t\\t\\te = gf_isom_last_error(file);\\n+\\t\\t\\tgoto err_exit;\\n+\\t\\t}\\n \\n \\t\\tdata = (u8 *) sample->data;\\n \\t\\tsize = sample->dataLength;', 'file_path': 'src/media_tools/isom_tools.c'}]\n\n## INSTRUCTIONS\n1. **Patch Review**  \n   • Detect primary language (`c`, `cpp`, `java`).  \n   • Classify vulnerability (`memory`, `logic`, `config`).  \n   • Explain how each patch hunk mitigates risk, citing `file:line`.  \n   → Populate `language`, `vulnerability_type`, `repair_rationale`.\n\n2. **Trace Root Cause within Patch**  \n   Follow calls / data flow in the patch, citing `file:line`.  \n   Where evidence ends, insert: `GAP: <why evidence stops>` → build `root_cause`.\n\n3. **Determine Missing Context (tools limited)**  \n   If gaps remain:  \n     • set `\"need_context\": true`  \n     • add precise, non-duplicate requests to `\"required_context\"` using **only**:  \n       - `function: …`  \n       - `caller: …`  \n   If the chain is fully evidenced from the patch, set `\"need_context\": false`.\n\n4. **Confidence Score**  \n   Set `confidence_score ≥ 0.90` only if the full chain is evidenced; otherwise `≤ 0.75`.\n\n## OUTPUT (MUST valid JSON — double quotes, no trailing commas)\n```json\n  {\n      \"language\": \"c | cpp | java\",\n      \"vulnerability_type\": \"memory | logic | config\",\n      \"repair_strategy\": \"<citing file:line from the patch>\",\n      \"analysis\": \"<Synthesis from Process Step 2. If full chain evident, explain that. If context needed, explain why requested context is essential to bridge gaps.>\",\n      \"need_context\": true | false, //false ONLY IF the full pattern was unambiguously evident from patch alone.\n      \"required_context\": \"<list of precise context requests if any context needed>\" ,\n      \"root_cause\": \"\"<Partial/complete trace with file:line evidence from the patch, noting gaps. If full chain evident, provide it.>\",\n      \"confidence_score\": 0.0-1.0 // Confidence in understanding the *full* path based on *this initial analysis phase*\n  }\n  ```\n\n## RULES\n* **Output must be valid JSON (no trailing commas).**\n* **Source-of-Truth** – Cite only code visible in the patch (`file:line`). Commit message / description are auxiliary.\n* **Zero-Assumption** – Never infer. Missing evidence → declare GAP, set `need_context=true`, and request context with allowed tools.\n* **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n* **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "language": "c",
                "vulnerability_type": "memory",
                "repair_strategy": "The patch adds a null check for `sample` after calling `gf_isom_get_sample` in `isom_tools.c:3544`, preventing dereference of a null pointer which would cause a segmentation fault. If `sample` is null, it retrieves the error and exits via `err_exit`.",
                "analysis": "The null check in `gf_media_split_hevc_tiles` prevents invalid memory access when `gf_isom_get_sample` fails. However, the connection between this patch and the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly evident from the provided code. The patch likely addresses an indirect trigger condition but does not explain the recursion root cause. Further context is required to trace how `gf_media_split_hevc_tiles` interacts with `Media_GetSample`.",
                "need_context": true,
                "required_context": [
                    "caller: gf_media_split_hevc_tiles",
                    "function: gf_isom_get_sample"
                ],
                "root_cause": "In `gf_media_split_hevc_tiles` (isom_tools.c:3544), `gf_isom_get_sample` may return null, leading to uninitialized `sample->data`/`sample->dataLength` access. The patch adds a null check to prevent this. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly addressed here. GAP: Missing link between `gf_media_split_hevc_tiles` and `Media_GetSample` logic.",
                "confidence_score": 0.65
            },
            "timestamp": "2025-05-29T22:14:50.169019"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: gf_media_split_hevc_tiles",
                "function: gf_isom_get_sample"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'gf_media_split_hevc_tiles', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 1912,
                            "call_code": "gf_media_split_hevc_tiles(dest, split_tile_mode - 1)",
                            "caller_code": "GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, GF_Fraction force_fps, u32 frames_per_sample, GF_FilterSession *fsess, char **mux_args_if_first_pass, char **mux_sid_if_first_pass, u32 tk_idx)\n{\n\tu32 track_id, i, j, timescale, track, stype, profile, compat, level, new_timescale, rescale_num, rescale_den, svc_mode, txt_flags, split_tile_mode, temporal_mode, nb_tracks;\n\ts32 par_d, par_n, prog_id, force_rate, moov_timescale;\n\ts32 tw, th, tx, ty, tz, txtw, txth, txtx, txty;\n\tBool do_audio, do_video, do_auxv,do_pict, do_all, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, rap_only, refs_only, force_par, rewrite_bs;\n\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc, do_disable;\n\tconst char *szLan;\n\tGF_Err e = GF_OK;\n\tGF_Fraction delay;\n\tu32 tmcd_track = 0, neg_ctts_mode=0;\n\tBool keep_audelim = GF_FALSE;\n\tu32 print_stats_graph=fs_dump_flags;\n\tGF_MediaImporter import;\n\tchar *ext, *final_name=NULL, *handler_name, *rvc_config, *chapter_name;\n\tGF_List *kinds;\n\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\n\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\n\tu32 clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod;\n\tBool has_clap=GF_FALSE;\n\tBool use_stz2=GF_FALSE;\n\tBool has_mx=GF_FALSE;\n\ts32 mx[9];\n\tu32 bitdepth=0;\n\tchar dv_profile[100]; /*Dolby Vision*/\n\tu32 clr_type=0;\n\tu32 clr_prim;\n\tu32 clr_tranf;\n\tu32 clr_mx;\n\tBool rescale_override=GF_FALSE;\n\tBool clr_full_range=GF_FALSE;\n\tBool fmt_ok = GF_TRUE;\n\tu32 icc_size=0, track_flags=0;\n\tu8 *icc_data = NULL;\n\tu32 tc_fps_num=0, tc_fps_den=0, tc_h=0, tc_m=0, tc_s=0, tc_f=0, tc_frames_per_tick=0;\n\tBool tc_force_counter=GF_FALSE;\n\tBool tc_drop_frame = GF_FALSE;\n\tchar *ext_start;\n\tu32 xps_inband=0;\n\tu64 source_magic=0;\n\tchar *opt_src = NULL;\n\tchar *opt_dst = NULL;\n\tchar *fchain = NULL;\n\tchar *edits = NULL;\n\tconst char *fail_msg = NULL;\n\tchar *hdr_file=NULL;\n\tBool set_ccst=GF_FALSE;\n\tBool has_last_sample_dur=GF_FALSE;\n\tu32 fake_import = 0;\n\tGF_Fraction last_sample_dur = {0,0};\n\ts32 fullrange, videofmt, colorprim, colortfc, colormx;\n\tclap_wn = clap_wd = clap_hn = clap_hd = clap_hon = clap_hod = clap_von = clap_vod = 0;\n\tGF_ISOMTrackFlagOp track_flags_mode=0;\n\tu32 roll_change=0;\n\ts32 roll = 0;\n\tBool src_is_isom = GF_FALSE;\n\ts32 dlb_mode = -2;\n\n\tdv_profile[0] = 0;\n\trvc_predefined = 0;\n\tchapter_name = NULL;\n\tnew_timescale = 1;\n\tmoov_timescale = 0;\n\trescale_num = rescale_den = 0;\n\ttext_layout = 0;\n\t/*0: merge all\n\t  1: split base and all SVC in two tracks\n\t  2: split all base and SVC layers in dedicated tracks\n\t */\n\tsvc_mode = 0;\n\n\tif (import_flags==0xFFFFFFFF) {\n\t\timport_flags = 0;\n\t\tfake_import = 1;\n\t}\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\n\tfinal_name = gf_strdup(inName);\n#ifdef WIN32\n\t/*dirty hack for msys&mingw: when we use import options, the ':' separator used prevents msys from translating the path\n\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we're screwed :( */\n\tif ( (final_name[0]=='/') && (final_name[2]=='/')) {\n\t\tfinal_name[0] = final_name[1];\n\t\tfinal_name[1] = ':';\n\t}\n#endif\n\n\tis_chap_file = 0;\n\thandler = 0;\n\tdo_disable = 0;\n\tchap_ref = 0;\n\tis_chap = 0;\n\tkinds = gf_list_new();\n\ttrack_layout = 0;\n\tszLan = NULL;\n\tdelay.num = delay.den = 0;\n\tgroup = 0;\n\tstype = 0;\n\tprofile = compat = level = 0;\n\tfullrange = videofmt = colorprim = colortfc = colormx = -1;\n\tsplit_tile_mode = 0;\n\ttemporal_mode = 0;\n\trap_only = 0;\n\trefs_only = 0;\n\ttxt_flags = 0;\n\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\n\tforce_rate = -1;\n\n\ttw = th = tx = ty = tz = txtw = txth = txtx = txty = 0;\n\tpar_d = par_n = -1;\n\tforce_par = rewrite_bs = GF_FALSE;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, '#');\n\tif (!ext) ext = gf_url_colon_suffix(final_name, '=');\n\tchar c_sep = ext ? ext[0] : 0;\n\tif (ext) ext[0] = 0;\n \tif (!strlen(final_name) || !strcmp(final_name, \"self\")) {\n\t\tfake_import = 2;\n\t\tsrc_is_isom = GF_TRUE;\n\t}\n\tchar *frag = strrchr(final_name, '#');\n\tif (frag) frag[0] = 0;\n\tif (gf_isom_probe_file(final_name))\n\t\tsrc_is_isom = GF_TRUE;\n\tif (frag) frag[0] = '#';\n\n\tif (ext) ext[0] = c_sep;\n\n\text = gf_url_colon_suffix(final_name, '=');\n\n#define GOTO_EXIT(_msg) if (e) { fail_msg = _msg; goto exit; }\n\n#define CHECK_FAKEIMPORT(_opt) if (fake_import) { M4_LOG(GF_LOG_ERROR, (\"Option %s not available for self-reference import\\n\", _opt)); e = GF_BAD_PARAM; goto exit; }\n#define CHECK_FAKEIMPORT_2(_opt) if (fake_import==1) { M4_LOG(GF_LOG_ERROR, (\"Option %s not available for self-reference import\\n\", _opt)); e = GF_BAD_PARAM; goto exit; }\n\n\n\thandler_name = NULL;\n\trvc_config = NULL;\n\twhile (ext) {\n\t\tchar *ext2 = gf_url_colon_suffix(ext+1, '=');\n\n\t\tif (ext2) ext2[0] = 0;\n\n\t\t/*all extensions for track-based importing*/\n\t\tif (!strnicmp(ext+1, \"dur=\", 4)) {\n\t\t\tCHECK_FAKEIMPORT(\"dur\")\n\n\t\t\tif (strchr(ext, '-')) {\n\t\t\t\timport.duration.num = parse_s32(ext+5, \"dur\");\n\t\t\t\timport.duration.den = 1;\n\t\t\t} else {\n\t\t\t\tgf_parse_frac(ext+5, &import.duration);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"start=\", 6)) {\n\t\t\tCHECK_FAKEIMPORT(\"start\")\n\t\t\timport.start_time = atof(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"lang=\", 5)) {\n\t\t\t/* prevent leak if param is set twice */\n\t\t\tif (szLan)\n\t\t\t\tgf_free((char*) szLan);\n\n\t\t\tszLan = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"delay=\", 6)) {\n\t\t\tif (sscanf(ext+7, \"%d/%u\", &delay.num, &delay.den)!=2) {\n\t\t\t\tdelay.num = parse_s32(ext+7, \"delay\");\n\t\t\t\tdelay.den = 1000; //in ms\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"par=\", 4)) {\n\t\t\tif (!stricmp(ext + 5, \"none\")) {\n\t\t\t\tpar_n = par_d = 0;\n\t\t\t} else if (!stricmp(ext + 5, \"auto\")) {\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else if (!stricmp(ext + 5, \"force\")) {\n\t\t\t\tpar_n = par_d = 1;\n\t\t\t\tforce_par = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (ext2) {\n\t\t\t\t\text2[0] = ':';\n\t\t\t\t\text2 = strchr(ext2+1, ':');\n\t\t\t\t\tif (ext2) ext2[0] = 0;\n\t\t\t\t}\n\t\t\t\tif (ext[5]=='w') {\n\t\t\t\t\trewrite_bs = GF_TRUE;\n\t\t\t\t\tif (sscanf(ext+6, \"%d:%d\", &par_n, &par_d)!=2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized syntax for par=, expecting N:D got %s\\n\", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (sscanf(ext+5, \"%d:%d\", &par_n, &par_d) != 2) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized syntax for par=, expecting N:D got %s\\n\", ext+5));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"clap=\", 5)) {\n\t\t\tif (!stricmp(ext+6, \"none\")) {\n\t\t\t\thas_clap=GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (sscanf(ext+6, \"%d,%d,%d,%d,%d,%d,%d,%d\", &clap_wn, &clap_wd, &clap_hn, &clap_hd, &clap_hon, &clap_hod, &clap_von, &clap_vod)==8) {\n\t\t\t\t\thas_clap=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"mx=\", 3)) {\n\t\t\tif (strstr(ext+4, \"0x\")) {\n\t\t\t\tif (sscanf(ext+4, \"0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%d\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\t\thas_mx=GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (sscanf(ext+4, \"%d,%d,%d,%d,%d,%d,%d,%d,%d\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\n\t\t\t\thas_mx=GF_TRUE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"name=\", 5)) {\n\t\t\thandler_name = gf_strdup(ext+6);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"ext=\", 4)) {\n\t\t\tCHECK_FAKEIMPORT(\"ext\")\n\t\t\t/*extensions begin with '.'*/\n\t\t\tif (*(ext+5) == '.')\n\t\t\t\timport.force_ext = gf_strdup(ext+5);\n\t\t\telse {\n\t\t\t\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\n\t\t\t\timport.force_ext[0] = '.';\n\t\t\t\tstrcat(import.force_ext+1, ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"hdlr=\", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\n\t\telse if (!strnicmp(ext+1, \"stype=\", 6)) stype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\n\t\telse if (!strnicmp(ext+1, \"tkhd\", 4)) {\n\t\t\tchar *flags = ext+6;\n\t\t\tif (flags[0]=='+') { track_flags_mode = GF_ISOM_TKFLAGS_ADD; flags += 1; }\n\t\t\telse if (flags[0]=='-') { track_flags_mode = GF_ISOM_TKFLAGS_REM; flags += 1; }\n\t\t\telse track_flags_mode = GF_ISOM_TKFLAGS_SET;\n\n\t\t\tif (strstr(flags, \"enable\")) track_flags |= GF_ISOM_TK_ENABLED;\n\t\t\tif (strstr(flags, \"movie\")) track_flags |= GF_ISOM_TK_IN_MOVIE;\n\t\t\tif (strstr(flags, \"preview\")) track_flags |= GF_ISOM_TK_IN_PREVIEW;\n\t\t\tif (strstr(flags, \"size_ar\")) track_flags |= GF_ISOM_TK_SIZE_IS_AR;\n\t\t\tif (!track_flags) {\n\t\t\t\tif (!strnicmp(flags, \"0x\", 2)) flags += 2;\n\t\t\t\tsscanf(flags, \"%X\", &track_flags);\n\t\t\t}\n\t\t} else if (!strnicmp(ext+1, \"disable\", 7)) {\n\t\t\tdo_disable = !stricmp(ext+1, \"disable=no\") ? 2 : 1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"group=\", 6)) {\n\t\t\tgroup = parse_u32(ext+7, \"group\");\n\t\t\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fps=\", 4)) {\n\t\t\tu32 ticks, dts_inc;\n\t\t\tif (!strcmp(ext+5, \"auto\")) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning, fps=auto option is deprecated\\n\"));\n\t\t\t} else if ((sscanf(ext+5, \"%u-%u\", &ticks, &dts_inc) == 2) || (sscanf(ext+5, \"%u/%u\", &ticks, &dts_inc) == 2)) {\n\t\t\t\tif (!dts_inc) dts_inc=1;\n\t\t\t\tforce_fps.num = ticks;\n\t\t\t\tforce_fps.den = dts_inc;\n\t\t\t} else {\n\t\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\t\tforce_fps.den = 1000;\n\t\t\t\t\tforce_fps.num = (u32) (atof(ext+5) * force_fps.den);\n\t\t\t\t} else {\n\t\t\t\t\tgf_parse_frac(ext+5, &force_fps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"rap\")) rap_only = 1;\n\t\telse if (!stricmp(ext+1, \"refs\")) refs_only = 1;\n\t\telse if (!stricmp(ext+1, \"trailing\")) { CHECK_FAKEIMPORT(\"trailing\") import_flags |= GF_IMPORT_KEEP_TRAILING; }\n\t\telse if (!strnicmp(ext+1, \"agg=\", 4)) { CHECK_FAKEIMPORT(\"agg\") frames_per_sample = parse_u32(ext+5, \"agg\"); }\n\t\telse if (!stricmp(ext+1, \"dref\")) { CHECK_FAKEIMPORT(\"dref\")  import_flags |= GF_IMPORT_USE_DATAREF; }\n\t\telse if (!stricmp(ext+1, \"keep_refs\")) { CHECK_FAKEIMPORT(\"keep_refs\") import_flags |= GF_IMPORT_KEEP_REFS; }\n\t\telse if (!stricmp(ext+1, \"nodrop\")) { CHECK_FAKEIMPORT(\"nodrop\") import_flags |= GF_IMPORT_NO_FRAME_DROP; }\n\t\telse if (!stricmp(ext+1, \"packed\")) { CHECK_FAKEIMPORT(\"packed\") import_flags |= GF_IMPORT_FORCE_PACKED; }\n\t\telse if (!stricmp(ext+1, \"sbr\")) { CHECK_FAKEIMPORT(\"sbr\") import_flags |= GF_IMPORT_SBR_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, \"sbrx\")) { CHECK_FAKEIMPORT(\"sbrx\") import_flags |= GF_IMPORT_SBR_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, \"ovsbr\")) { CHECK_FAKEIMPORT(\"ovsbr\") import_flags |= GF_IMPORT_OVSBR; }\n\t\telse if (!stricmp(ext+1, \"ps\")) { CHECK_FAKEIMPORT(\"ps\") import_flags |= GF_IMPORT_PS_IMPLICIT; }\n\t\telse if (!stricmp(ext+1, \"psx\")) { CHECK_FAKEIMPORT(\"psx\") import_flags |= GF_IMPORT_PS_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, \"mpeg4\")) { CHECK_FAKEIMPORT(\"mpeg4\") import_flags |= GF_IMPORT_FORCE_MPEG4; }\n\t\telse if (!stricmp(ext+1, \"nosei\")) { CHECK_FAKEIMPORT(\"nosei\") import_flags |= GF_IMPORT_NO_SEI; }\n\t\telse if (!stricmp(ext+1, \"svc\") || !stricmp(ext+1, \"lhvc\") ) { CHECK_FAKEIMPORT(\"svc/lhvc\") import_flags |= GF_IMPORT_SVC_EXPLICIT; }\n\t\telse if (!stricmp(ext+1, \"nosvc\") || !stricmp(ext+1, \"nolhvc\")) { CHECK_FAKEIMPORT(\"nosvc/nolhvc\") import_flags |= GF_IMPORT_SVC_NONE; }\n\n\t\t/*split SVC layers*/\n\t\telse if (!strnicmp(ext+1, \"svcmode=\", 8) || !strnicmp(ext+1, \"lhvcmode=\", 9)) {\n\t\t\tchar *mode = ext+9;\n\t\t\tCHECK_FAKEIMPORT_2(\"svcmode/lhvcmode\")\n\t\t\tif (mode[0]=='=') mode = ext+10;\n\n\t\t\tif (!stricmp(mode, \"splitnox\"))\n\t\t\t\tsvc_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitnoxib\"))\n\t\t\t\tsvc_mode = 4;\n\t\t\telse if (!stricmp(mode, \"splitall\") || !stricmp(mode, \"split\"))\n\t\t\t\tsvc_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\tsvc_mode = 1;\n\t\t\telse if (!stricmp(mode, \"merged\") || !stricmp(mode, \"merge\"))\n\t\t\t\tsvc_mode = 0;\n\t\t}\n\t\t/*split SHVC temporal sublayers*/\n\t\telse if (!strnicmp(ext+1, \"temporal=\", 9)) {\n\t\t\tchar *mode = ext+10;\n\t\t\tCHECK_FAKEIMPORT_2(\"svcmode/lhvcmode\")\n\t\t\tif (!stricmp(mode, \"split\"))\n\t\t\t\ttemporal_mode = 2;\n\t\t\telse if (!stricmp(mode, \"splitnox\"))\n\t\t\t\ttemporal_mode = 3;\n\t\t\telse if (!stricmp(mode, \"splitbase\"))\n\t\t\t\ttemporal_mode = 1;\n\t\t\telse {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized temporal mode %s, ignoring\\n\", mode));\n\t\t\t\ttemporal_mode = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"subsamples\")) { CHECK_FAKEIMPORT(\"subsamples\") import_flags |= GF_IMPORT_SET_SUBSAMPLES; }\n\t\telse if (!stricmp(ext+1, \"deps\")) { CHECK_FAKEIMPORT(\"deps\") import_flags |= GF_IMPORT_SAMPLE_DEPS; }\n\t\telse if (!stricmp(ext+1, \"ccst\")) { CHECK_FAKEIMPORT(\"ccst\") set_ccst = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, \"alpha\")) { CHECK_FAKEIMPORT(\"alpha\") import.is_alpha = GF_TRUE; }\n\t\telse if (!stricmp(ext+1, \"forcesync\")) { CHECK_FAKEIMPORT(\"forcesync\") import_flags |= GF_IMPORT_FORCE_SYNC; }\n\t\telse if (!stricmp(ext+1, \"xps_inband\")) { CHECK_FAKEIMPORT(\"xps_inband\") xps_inband = 1; }\n\t\telse if (!stricmp(ext+1, \"xps_inbandx\")) { CHECK_FAKEIMPORT(\"xps_inbandx\") xps_inband = 2; }\n\t\telse if (!stricmp(ext+1, \"au_delim\")) { CHECK_FAKEIMPORT(\"au_delim\") keep_audelim = GF_TRUE; }\n\t\telse if (!strnicmp(ext+1, \"max_lid=\", 8) || !strnicmp(ext+1, \"max_tid=\", 8)) {\n\t\t\ts32 val = parse_u32(ext+9, \"Max TID/LID\");\n\t\t\tCHECK_FAKEIMPORT_2(\"max_lid/lhvcmode\")\n\t\t\tif (val < 0) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: request max layer/temporal id is negative - ignoring\\n\"));\n\t\t\t} else {\n\t\t\t\tif (!strnicmp(ext+1, \"max_lid=\", 8))\n\t\t\t\t\tmax_layer_id_plus_one = 1 + (u8) val;\n\t\t\t\telse\n\t\t\t\t\tmax_temporal_id_plus_one = 1 + (u8) val;\n\t\t\t}\n\t\t}\n\t\telse if (!stricmp(ext+1, \"tiles\")) { CHECK_FAKEIMPORT_2(\"tiles\") split_tile_mode = 2; }\n\t\telse if (!stricmp(ext+1, \"tiles_rle\")) { CHECK_FAKEIMPORT_2(\"tiles_rle\") split_tile_mode = 3; }\n\t\telse if (!stricmp(ext+1, \"split_tiles\")) { CHECK_FAKEIMPORT_2(\"split_tiles\") split_tile_mode = 1; }\n\n\t\t/*force all composition offsets to be positive*/\n\t\telse if (!strnicmp(ext+1, \"negctts\", 7)) {\n\t\t\tneg_ctts_mode = !strnicmp(ext+1, \"negctts=no\", 10) ? 2 : 1;\n\t\t}\n\t\telse if (!stricmp(ext+1, \"chap\")) is_chap = 1;\n\t\telse if (!strnicmp(ext+1, \"chapter=\", 8)) {\n\t\t\tchapter_name = gf_strdup(ext+9);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"chapfile=\", 9)) {\n\t\t\tchapter_name = gf_strdup(ext+10);\n\t\t\tis_chap_file=1;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"layout=\", 7)) {\n\t\t\ttrack_layout = 1;\n\t\t\tif ( sscanf(ext+13, \"%dx%dx%dx%dx%d\", &tw, &th, &tx, &ty, &tz)==5) {\n\t\t\t} else if ( sscanf(ext+13, \"%dx%dx%dx%d\", &tw, &th, &tx, &ty)==4) {\n\t\t\t\ttz = 0;\n\t\t\t} else if ( sscanf(ext+13, \"%dx%dx%d\", &tw, &th, &tz)==3) {\n\t\t\t\ttx = ty = 0;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &tw, &th)==2) {\n\t\t\t\ttx = ty = tz = 0;\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"rescale=\", 8)) {\n\t\t\tif (sscanf(ext+9, \"%u/%u\", &rescale_num, &rescale_den) != 2) {\n\t\t\t\trescale_num = parse_u32(ext+9, \"rescale\");\n\t\t\t\trescale_den = 0;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"sampdur=\", 8)) {\n\t\t\tif (sscanf(ext+9, \"%u/%u\", &rescale_den, &rescale_num) != 2) {\n\t\t\t\trescale_den = parse_u32(ext+9, \"sampdur\");\n\t\t\t\trescale_num = 0;\n\t\t\t}\n\t\t\trescale_override = GF_TRUE;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"timescale=\", 10)) {\n\t\t\tnew_timescale = parse_u32(ext+11, \"timescale\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"moovts=\", 7)) {\n\t\t\tmoov_timescale = parse_u32(ext+8, \"moovts\");\n\t\t}\n\n\t\telse if (!stricmp(ext+1, \"noedit\")) { import_flags |= GF_IMPORT_NO_EDIT_LIST; }\n\n\n\t\telse if (!strnicmp(ext+1, \"rvc=\", 4)) {\n\t\t\tif (sscanf(ext+5, \"%d\", &rvc_predefined) != 1) {\n\t\t\t\trvc_config = gf_strdup(ext+5);\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fmt=\", 4)) import.streamFormat = gf_strdup(ext+5);\n\n\t\telse if (!strnicmp(ext+1, \"profile=\", 8)) {\n\t\t\tif (!stricmp(ext+9, \"high444\")) profile = 244;\n\t\t\telse if (!stricmp(ext+9, \"high\")) profile = 100;\n\t\t\telse if (!stricmp(ext+9, \"extended\")) profile = 88;\n\t\t\telse if (!stricmp(ext+9, \"main\")) profile = 77;\n\t\t\telse if (!stricmp(ext+9, \"baseline\")) profile = 66;\n\t\t\telse profile = parse_u32(ext+9, \"profile\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"level=\", 6)) {\n\t\t\tif( atof(ext+7) < 6 )\n\t\t\t\tlevel = (int)(10*atof(ext+7)+.5);\n\t\t\telse\n\t\t\t\tlevel = parse_u32(ext+7, \"level\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"compat=\", 7)) {\n\t\t\tcompat = parse_u32(ext+8, \"compat\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"dlba=\", 5)) {\n\t\t\tif (!strcmp(ext+6, \"no\")) dlb_mode=0;\n\t\t\telse if (!strcmp(ext+6, \"auto\")) dlb_mode=-1;\n\t\t\telse if (sscanf(ext+6, \"%d\", &dlb_mode) != 1) {\n\t\t\t\tGOTO_EXIT(\"Unrecognized dolby atmos mode\")\n\t\t\t}\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"novpsext\", 8)) { CHECK_FAKEIMPORT(\"novpsext\") import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS; }\n\t\telse if (!strnicmp(ext+1, \"keepav1t\", 8)) { CHECK_FAKEIMPORT(\"keepav1t\") import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU; }\n\n\t\telse if (!strnicmp(ext+1, \"font=\", 5)) { CHECK_FAKEIMPORT(\"font\") import.fontName = gf_strdup(ext+6); }\n\t\telse if (!strnicmp(ext+1, \"size=\", 5)) { CHECK_FAKEIMPORT(\"size\") import.fontSize = parse_u32(ext+6, \"size\"); }\n\t\telse if (!strnicmp(ext+1, \"text_layout=\", 12)) {\n\t\t\tif ( sscanf(ext+13, \"%dx%dx%dx%d\", &txtw, &txth, &txtx, &txty)==4) {\n\t\t\t\ttext_layout = 1;\n\t\t\t} else if ( sscanf(ext+8, \"%dx%d\", &txtw, &txth)==2) {\n\t\t\t\ttrack_layout = 1;\n\t\t\t\ttxtx = txty = 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\telse if (!stricmp(ext+1, \"swf-global\")) { CHECK_FAKEIMPORT(\"swf-global\") import.swf_flags |= GF_SM_SWF_STATIC_DICT; }\n\t\telse if (!stricmp(ext+1, \"swf-no-ctrl\")) { CHECK_FAKEIMPORT(\"swf-no-ctrl\") import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE; }\n\t\telse if (!stricmp(ext+1, \"swf-no-text\")) { CHECK_FAKEIMPORT(\"swf-no-text\") import.swf_flags |= GF_SM_SWF_NO_TEXT; }\n\t\telse if (!stricmp(ext+1, \"swf-no-font\")) { CHECK_FAKEIMPORT(\"swf-no-font\") import.swf_flags |= GF_SM_SWF_NO_FONT; }\n\t\telse if (!stricmp(ext+1, \"swf-no-line\")) { CHECK_FAKEIMPORT(\"swf-no-line\") import.swf_flags |= GF_SM_SWF_NO_LINE; }\n\t\telse if (!stricmp(ext+1, \"swf-no-grad\")) { CHECK_FAKEIMPORT(\"swf-no-grad\") import.swf_flags |= GF_SM_SWF_NO_GRADIENT; }\n\t\telse if (!stricmp(ext+1, \"swf-quad\")) { CHECK_FAKEIMPORT(\"swf-quad\") import.swf_flags |= GF_SM_SWF_QUAD_CURVE; }\n\t\telse if (!stricmp(ext+1, \"swf-xlp\")) { CHECK_FAKEIMPORT(\"swf-xlp\") import.swf_flags |= GF_SM_SWF_SCALABLE_LINE; }\n\t\telse if (!stricmp(ext+1, \"swf-ic2d\")) { CHECK_FAKEIMPORT(\"swf-ic2d\") import.swf_flags |= GF_SM_SWF_USE_IC2D; }\n\t\telse if (!stricmp(ext+1, \"swf-same-app\")) { CHECK_FAKEIMPORT(\"swf-same-app\") import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE; }\n\t\telse if (!strnicmp(ext+1, \"swf-flatten=\", 12)) { CHECK_FAKEIMPORT(\"swf-flatten\") import.swf_flatten_angle = (Float) atof(ext+13); }\n#endif\n\n\t\telse if (!strnicmp(ext+1, \"kind=\", 5)) {\n\t\t\tchar *kind_scheme, *kind_value;\n\t\t\tchar *kind_data = ext+6;\n\t\t\tchar *sep = strchr(kind_data, '=');\n\t\t\tif (sep) {\n\t\t\t\t*sep = 0;\n\t\t\t}\n\t\t\tkind_scheme = gf_strdup(kind_data);\n\t\t\tif (sep) {\n\t\t\t\t*sep = '=';\n\t\t\t\tkind_value = gf_strdup(sep+1);\n\t\t\t} else {\n\t\t\t\tkind_value = NULL;\n\t\t\t}\n\t\t\tgf_list_add(kinds, kind_scheme);\n\t\t\tgf_list_add(kinds, kind_value);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"txtflags\", 8)) {\n\t\t\tif (!strnicmp(ext+1, \"txtflags=\", 9)) {\n\t\t\t\tsscanf(ext+10, \"%x\", &txt_flags);\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags+=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\n\t\t\t}\n\t\t\telse if (!strnicmp(ext+1, \"txtflags-=\", 10)) {\n\t\t\t\tsscanf(ext+11, \"%x\", &txt_flags);\n\t\t\t\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"rate=\", 5)) {\n\t\t\tforce_rate = parse_s32(ext+6, \"rate\");\n\t\t}\n\t\telse if (!stricmp(ext+1, \"stats\") || !stricmp(ext+1, \"fstat\"))\n\t\t\tprint_stats_graph |= 1;\n\t\telse if (!stricmp(ext+1, \"graph\") || !stricmp(ext+1, \"graph\"))\n\t\t\tprint_stats_graph |= 2;\n\t\telse if (!strncmp(ext+1, \"sopt\", 4) || !strncmp(ext+1, \"dopt\", 4) || !strncmp(ext+1, \"@\", 1)) {\n\t\t\tif (ext2) ext2[0] = ':';\n\t\t\topt_src = strstr(ext, \":sopt:\");\n\t\t\topt_dst = strstr(ext, \":dopt:\");\n\t\t\tfchain = strstr(ext, \":@\");\n\t\t\tif (opt_src) opt_src[0] = 0;\n\t\t\tif (opt_dst) opt_dst[0] = 0;\n\t\t\tif (fchain) fchain[0] = 0;\n\n\t\t\tif (opt_src) import.filter_src_opts = opt_src+6;\n\t\t\tif (opt_dst) import.filter_dst_opts = opt_dst+6;\n\t\t\tif (fchain) {\n\t\t\t\t//check for old syntax (0.9->1.0) :@@\n\t\t\t\tif (fchain[2]=='@') {\n\t\t\t\t\timport.filter_chain = fchain + 3;\n\t\t\t\t\timport.is_chain_old_syntax = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\timport.filter_chain = fchain + 2;\n\t\t\t\t\timport.is_chain_old_syntax = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\text = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (!strnicmp(ext+1, \"asemode=\", 8)){\n\t\t\tchar *mode = ext+9;\n\t\t\tif (!stricmp(mode, \"v0-bs\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\n\t\t\telse if (!stricmp(mode, \"v0-2\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\n\t\t\telse if (!stricmp(mode, \"v1\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\n\t\t\telse if (!stricmp(mode, \"v1-qt\"))\n\t\t\t\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\telse\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized audio sample entry mode %s, ignoring\\n\", mode));\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"audio_roll=\", 11)) { roll_change = 3; roll = parse_s32(ext+12, \"audio_roll\"); }\n\t\telse if (!strnicmp(ext+1, \"roll=\", 5)) { roll_change = 1; roll = parse_s32(ext+6, \"roll\"); }\n\t\telse if (!strnicmp(ext+1, \"proll=\", 6)) { roll_change = 2; roll = parse_s32(ext+7, \"proll\"); }\n\t\telse if (!strcmp(ext+1, \"stz2\")) {\n\t\t\tuse_stz2 = GF_TRUE;\n\t\t} else if (!strnicmp(ext+1, \"bitdepth=\", 9)) {\n\t\t\tbitdepth = parse_u32(ext+10, \"bitdepth\");\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"hdr=\", 4)) {\n\t\t\thdr_file = gf_strdup(ext+5);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colr=\", 5)) {\n\t\t\tchar *cval = ext+6;\n\t\t\tif (!strcmp(cval, \"none\")) {\n\t\t\t\tclr_type = (u32) -1;\n\t\t\t} else if (strlen(cval)<6) {\n\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tclr_type = GF_4CC(cval[0],cval[1],cval[2],cval[3]);\n\t\t\t\tcval+=4;\n\t\t\t\tif (cval[0] != ',') {\n\t\t\t\t\tfmt_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_NCLX) || (clr_type==GF_ISOM_SUBTYPE_NCLC)) {\n\t\t\t\t\tfmt_ok = scan_color(cval+1, &clr_prim, &clr_tranf, &clr_mx, &clr_full_range);\n\t\t\t\t}\n\t\t\t\telse if ((clr_type==GF_ISOM_SUBTYPE_RICC) || (clr_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\t\t\t\tFILE *f = gf_fopen(cval+1, \"rb\");\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open file %s\\n\", cval+1));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_END);\n\t\t\t\t\t\ticc_size = (u32) gf_ftell(f);\n\t\t\t\t\t\ticc_data = gf_malloc(sizeof(char)*icc_size);\n\t\t\t\t\t\tgf_fseek(f, 0, SEEK_SET);\n\t\t\t\t\t\ticc_size = (u32) gf_fread(icc_data, icc_size, f);\n\t\t\t\t\t\tgf_fclose(f);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized colr profile %s\\n\", gf_4cc_to_str(clr_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fmt_ok) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"parsing colr option\");\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext + 1, \"dvp=\", 4)) {\n\t\t\tstrncpy(dv_profile, ext + 5, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\t//old name\n\t\telse if (!strnicmp(ext + 1, \"dv-profile=\", 11)) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"Deprecated option name, use `:dvp=` instead\\n\"));\n\t\t\tstrncpy(dv_profile, ext + 12, 99);\n\t\t\tdv_profile[99]=0;\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"fullrange=\", 10)) {\n\t\t\tif (!stricmp(ext+11, \"off\") || !stricmp(ext+11, \"no\")) fullrange = 0;\n\t\t\telse if (!stricmp(ext+11, \"on\") || !stricmp(ext+11, \"yes\")) fullrange = 1;\n\t\t\telse {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for fullrange\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"videofmt=\", 10)) {\n\t\t\tu32 idx, count = GF_ARRAY_LENGTH(videofmt_names);\n\t\t\tfor (idx=0; idx<count; idx++) {\n\t\t\t\tif (!strcmp(ext+11, videofmt_names[idx])) {\n\t\t\t\t\tvideofmt = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (videofmt==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for videofmt\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colorprim=\", 10)) {\n\t\t\tcolorprim = gf_cicp_parse_color_primaries(ext+11);\n\t\t\tif (colorprim==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for colorprim\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colortfc=\", 9)) {\n\t\t\tcolortfc = gf_cicp_parse_color_transfer(ext+10);\n\t\t\tif (colortfc==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for colortfc\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"colormx=\", 10)) {\n\t\t\tcolormx = gf_cicp_parse_color_matrix(ext+11);\n\t\t\tif (colormx==-1) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\tGOTO_EXIT(\"invalid format for colormx\")\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"tc=\", 3)) {\n\t\t\tchar *tc_str = ext+4;\n\t\t\t\n\t\t\tif (tc_str[0] == 'd') {\n\t\t\t\ttc_drop_frame=GF_TRUE;\n\t\t\t\ttc_str+=1;\n\t\t\t}\n\t\t\tif (sscanf(tc_str, \"%d/%d,%d,%d,%d,%d,%d\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 7) {\n\t\t\t} else if (sscanf(tc_str, \"%d/%d,%d,%d,%d,%d\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f) == 6) {\n\t\t\t} else if (sscanf(tc_str, \"%d,%d,%d,%d,%d,%d\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 6) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, \"%d,%d,%d,%d,%d\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f) == 5) {\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, \"%d/%d,%d,%d\", &tc_fps_num, &tc_fps_den, &tc_f, &tc_frames_per_tick) == 4) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, \"%d/%d,%d\", &tc_fps_num, &tc_fps_den, &tc_f) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t} else if (sscanf(tc_str, \"%d,%d,%d\", &tc_fps_num, &tc_f, &tc_frames_per_tick) == 3) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else if (sscanf(tc_str, \"%d,%d\", &tc_fps_num, &tc_f) == 2) {\n\t\t\t\ttc_force_counter = GF_TRUE;\n\t\t\t\ttc_h = tc_m = tc_s = 0;\n\t\t\t\ttc_fps_den = 1;\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format %s for timecode, ignoring\\n\", ext+1));\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"edits=\", 6)) {\n\t\t\tedits = gf_strdup(ext+7);\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"lastsampdur\", 11)) {\n\t\t\thas_last_sample_dur = GF_TRUE;\n\t\t\tif (!strnicmp(ext+1, \"lastsampdur=\", 12)) {\n\t\t\t\tif (sscanf(ext+13, \"%d/%u\", &last_sample_dur.num, &last_sample_dur.den)==2) {\n\t\t\t\t} else {\n\t\t\t\t\tlast_sample_dur.num = parse_s32(ext+13, \"lastsampdur\");\n\t\t\t\t\tlast_sample_dur.den = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext+1, \"ID=\", 3)) {\n\t\t\timport.target_trackID = (u32) parse_u32(ext+4, \"ID\");\n\t\t}\n\t\t/*unrecognized, assume name has colon in it*/\n\t\telse {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized import option %s, ignoring\\n\", ext+1));\n\t\t\tif (ext2) ext2[0] = ':';\n\t\t\text = ext2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (src_is_isom) {\n\t\t\tchar *opt = ext+1;\n\t\t\tchar *sep_eq = strchr(opt, '=');\n\t\t\tif (sep_eq) sep_eq[0] = 0;\n\t\t\tif (!mp4box_check_isom_fileopt(opt)) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\t! Import option `%s` not available for ISOBMFF/QT sources, ignoring !\\n\", ext+1));\n\t\t\t}\n\t\t\tif (sep_eq) sep_eq[0] = '=';\n\t\t}\n\n\t\tif (ext2) ext2[0] = ':';\n\n\t\text[0] = 0;\n\n\t\t/* restart from where we stopped\n\t\t * if we didn't stop (ext2 null) then the end has been reached\n\t\t * so we can stop the whole thing */\n\t\text = ext2;\n\t}\n\n\t/*check duration import (old syntax)*/\n\text = strrchr(final_name, '%');\n\tif (ext) {\n\t\tgf_parse_frac(ext+1, &import.duration);\n\t\text[0] = 0;\n\t}\n\n\t/*select switches for av containers import*/\n\tdo_audio = do_video = do_auxv = do_pict = 0;\n\ttrack_id = prog_id = 0;\n\tdo_all = 1;\n\n\text_start = gf_file_ext_start(final_name);\n\text = strrchr(ext_start ? ext_start : final_name, '#');\n\tif (ext) ext[0] = 0;\n\n\tif (fake_import && ext) {\n\t\text++;\n\t\tif (!strnicmp(ext, \"audio\", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, \"video\", 5)) do_video = 1;\n\t\telse if (!strnicmp(ext, \"auxv\", 4)) do_auxv = 1;\n\t\telse if (!strnicmp(ext, \"pict\", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, \"trackID=\", 8)) track_id = parse_u32(&ext[8], \"trackID\");\n\t\telse track_id = parse_u32(ext, \"ID\");\n\t}\n\telse if (ext) {\n\t\text++;\n\t\tchar *sep = gf_url_colon_suffix(ext, '=');\n\t\tif (sep) sep[0] = 0;\n\n\t\t//we have a fragment, we need to check if the track or the program is present in source\n\t\timport.in_name = final_name;\n\t\timport.flags = GF_IMPORT_PROBE_ONLY;\n\t\te = gf_media_import(&import);\n\t\tGOTO_EXIT(\"importing import\");\n\n\t\tif (!strnicmp(ext, \"audio\", 5)) do_audio = 1;\n\t\telse if (!strnicmp(ext, \"video\", 5)) do_video = 1;\n        else if (!strnicmp(ext, \"auxv\", 4)) do_auxv = 1;\n        else if (!strnicmp(ext, \"pict\", 4)) do_pict = 1;\n\t\telse if (!strnicmp(ext, \"trackID=\", 8)) track_id = parse_u32(&ext[8], \"trackID\");\n\t\telse if (!strnicmp(ext, \"PID=\", 4)) track_id = parse_u32(&ext[4], \"ID\");\n\t\telse if (!strnicmp(ext, \"program=\", 8)) {\n\t\t\tfor (i=0; i<import.nb_progs; i++) {\n\t\t\t\tif (!stricmp(import.pg_info[i].name, ext+8)) {\n\t\t\t\t\tprog_id = import.pg_info[i].number;\n\t\t\t\t\tdo_all = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(ext, \"prog_id=\", 8)) {\n\t\t\tprog_id = parse_u32(ext+8, \"prog_id\");\n\t\t\tdo_all = 0;\n\t\t}\n\t\telse track_id = parse_u32(ext, \"ID\");\n\n\t\t//figure out trackID\n\t\tif (do_audio || do_video || do_auxv || do_pict || track_id) {\n\t\t\tBool found = track_id ? GF_FALSE : GF_TRUE;\n\t\t\tfor (i=0; i<import.nb_tracks; i++) {\n\t\t\t\tif (track_id && (import.tk_info[i].track_num==track_id)) {\n\t\t\t\t\tfound=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (do_audio && (import.tk_info[i].stream_type==GF_STREAM_AUDIO)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_video && (import.tk_info[i].stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_auxv && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_AUXV)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (do_pict && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_PICT)) {\n\t\t\t\t\ttrack_id = import.tk_info[i].track_num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!track_id || !found) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot find track ID matching fragment #%s\\n\", ext));\n\t\t\t\tif (sep) sep[0] = ':';\n\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (sep) sep[0] = ':';\n\t}\n\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\n\n\tif (track_layout || is_chap) {\n\t\tu32 w, h, sw, sh, fw, fh;\n\t\tw = h = sw = sh = fw = fh = 0;\n\t\tchap_ref = 0;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n            case GF_ISOM_MEDIA_AUXV:\n            case GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\n\t\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\n\t\t\t\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\n\t\t\t\tif (w<sw) w = sw;\n\t\t\t\tif (w<fw) w = fw;\n\t\t\t\tif (h<sh) h = sh;\n\t\t\t\tif (h<fh) h = fh;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (track_layout) {\n\t\t\tif (!tw) tw = w;\n\t\t\tif (!th) th = h;\n\t\t\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\n\t\t\timport.text_width = tw;\n\t\t\timport.text_height = th;\n\t\t}\n\t\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\n\t}\n\tif (text_layout && txtw && txth) {\n\t\timport.text_track_width = import.text_width ? import.text_width : txtw;\n\t\timport.text_track_height = import.text_height ? import.text_height : txth;\n\t\timport.text_width = txtw;\n\t\timport.text_height = txth;\n\t\timport.text_x = txtx;\n\t\timport.text_y = txty;\n\t}\n\n\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\n\n\tsource_magic = (u64) gf_crc_32((u8 *)inName, (u32) strlen(inName));\n\tif (!fake_import && (!fsess || mux_args_if_first_pass)) {\n\t\timport.in_name = final_name;\n\t\timport.dest = dest;\n\t\timport.video_fps = force_fps;\n\t\timport.frames_per_sample = frames_per_sample;\n\t\timport.flags = import_flags;\n\t\timport.keep_audelim = keep_audelim;\n\t\timport.print_stats_graph = print_stats_graph;\n\t\timport.xps_inband = xps_inband;\n\t\timport.prog_id = prog_id;\n\t\timport.trackID = track_id;\n\t\timport.source_magic = source_magic;\n\t\timport.track_index = tk_idx;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (moov_timescale<0) {\n\t\t\timport.moov_timescale = moov_timescale;\n\t\t}\n\t\t//otherwise force it now\n\t\telse if (moov_timescale>0) {\n\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\tGOTO_EXIT(\"changing timescale\")\n\t\t}\n\n\t\timport.run_in_session = fsess;\n\t\timport.update_mux_args = NULL;\n\t\tif (do_all)\n\t\t\timport.flags |= GF_IMPORT_KEEP_REFS;\n\n\t\te = gf_media_import(&import);\n\t\tif (e) {\n\t\t\tif (import.update_mux_args) gf_free(import.update_mux_args);\n\t\t\tGOTO_EXIT(\"importing media\");\n\t\t}\n\n\t\tif (fsess) {\n\t\t\t*mux_args_if_first_pass = import.update_mux_args;\n\t\t\timport.update_mux_args = NULL;\n\t\t\t*mux_sid_if_first_pass = import.update_mux_sid;\n\t\t\timport.update_mux_sid = NULL;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tnb_tracks = gf_isom_get_track_count(dest);\n\tfor (i=0; i<nb_tracks; i++) {\n\t\tu32 media_type;\n\t\ttrack = i+1;\n\t\tmedia_type = gf_isom_get_media_type(dest, track);\n\t\te = GF_OK;\n\t\tif (!fake_import) {\n\t\t\tu64 tk_source_magic;\n\t\t\ttk_source_magic = gf_isom_get_track_magic(dest, track);\n\n\t\t\tif ((tk_source_magic & 0xFFFFFFFFUL) != source_magic)\n\t\t\t\tcontinue;\n\t\t\ttk_source_magic>>=32;\t\t\n\t\t\tkeep_handler = (tk_source_magic & 1) ? GF_TRUE : GF_FALSE;\n\t\t} else {\n\t\t\tkeep_handler = GF_TRUE;\n\n\t\t\tif (do_audio && (media_type!=GF_ISOM_MEDIA_AUDIO)) continue;\n\t\t\tif (do_video && (media_type!=GF_ISOM_MEDIA_VISUAL)) continue;\n\t\t\tif (do_auxv && (media_type!=GF_ISOM_MEDIA_AUXV)) continue;\n\t\t\tif (do_pict && (media_type!=GF_ISOM_MEDIA_PICT)) continue;\n\t\t\tif (track_id && (gf_isom_get_track_id(dest, track) != track_id))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttimescale = gf_isom_get_timescale(dest);\n\t\tif (szLan) {\n\t\t\te = gf_isom_set_media_language(dest, track, (char *) szLan);\n\t\t\tGOTO_EXIT(\"changing language\")\n\t\t}\n\t\tif (do_disable) {\n\t\t\te = gf_isom_set_track_enabled(dest, track, (do_disable==2) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT(\"disabling track\")\n\t\t}\n\t\tif (track_flags_mode) {\n\t\t\te = gf_isom_set_track_flags(dest, track, track_flags, track_flags_mode);\n\t\t\tGOTO_EXIT(\"disabling track\")\n\t\t}\n\n\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST) {\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\tGOTO_EXIT(\"removing edits\")\n\t\t}\n\t\tif (delay.num && delay.den) {\n\t\t\tu64 tk_dur;\n\t\t\te = gf_isom_remove_edits(dest, track);\n\t\t\ttk_dur = gf_isom_get_track_duration(dest, track);\n\t\t\tif (delay.num>0) {\n\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\te |= gf_isom_append_edit(dest, track, ((s64) delay.num) * timescale / delay.den, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t} else {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\tu64 to_skip = ((s64) -delay.num) * timescale / delay.den;\n\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t//cast to s64, timescale*delay could be quite large before /1000\n\t\t\t\t\tu64 media_time = ((s64) -delay.num) * gf_isom_get_media_timescale(dest, track) / delay.den;\n\t\t\t\t\te |= gf_isom_append_edit(dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: request negative delay longer than track duration - ignoring\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tGOTO_EXIT(\"assigning delay\")\n\t\t}\n\t\tif (gf_isom_is_video_handler_type(media_type)) {\n\t\t\tif (((par_n>=0) && (par_d>=0)) || force_par) {\n\t\t\t\te = gf_media_change_par(dest, track, par_n, par_d, force_par, rewrite_bs);\n\t\t\t\tGOTO_EXIT(\"changing PAR\")\n\t\t\t}\n\t\t\tif ((fullrange>=0) || (videofmt>=0) || (colorprim>=0) || (colortfc>=0) || (colormx>=0)) {\n\t\t\t\te = gf_media_change_color(dest, i+1, fullrange, videofmt, colorprim, colortfc, colormx);\n\t\t\t\tGOTO_EXIT(\"changing color in bitstream\")\n\t\t\t}\n\t\t\tif (has_clap) {\n\t\t\t\te = gf_isom_set_clean_aperture(dest, track, 1, clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod);\n\t\t\t\tGOTO_EXIT(\"changing clean aperture\")\n\t\t\t}\n\t\t\tif (bitdepth) {\n\t\t\t\te = gf_isom_set_visual_bit_depth(dest, track, 1, bitdepth);\n\t\t\t\tGOTO_EXIT(\"changing bit depth\")\n\t\t\t}\n\t\t\tif (clr_type) {\n\t\t\t\tif (clr_type==(u32)-1)\n\t\t\t\t\tclr_type = 0;\n\n\t\t\t\te = gf_isom_set_visual_color_info(dest, track, 1, clr_type, clr_prim, clr_tranf, clr_mx, clr_full_range, icc_data, icc_size);\n\t\t\t\tGOTO_EXIT(\"changing color info\")\n\t\t\t}\n\t\t\tif (hdr_file) {\n\t\t\t\te = parse_high_dynamc_range_xml_desc(dest, track, hdr_file);\n\t\t\t\tGOTO_EXIT(\"setting HDR info\")\n\t\t\t}\n\t\t\tif (dv_profile[0]) {\n\t\t\t\te = set_dv_profile(dest, track, dv_profile);\n\t\t\t\tGOTO_EXIT(\"setting DV profile\")\n\t\t\t}\n\n\t\t\tif (set_ccst) {\n\t\t\t\te = gf_isom_set_image_sequence_coding_constraints(dest, track, 1, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\t\tGOTO_EXIT(\"setting image sequence constraints\")\n\t\t\t}\n\t\t}\n\t\tif (has_mx) {\n\t\t\te = gf_isom_set_track_matrix(dest, track, mx);\n\t\t\tGOTO_EXIT(\"setting track matrix\")\n\t\t}\n\t\tif (use_stz2) {\n\t\t\te = gf_isom_use_compact_size(dest, track, GF_TRUE);\n\t\t\tGOTO_EXIT(\"setting compact size\")\n\t\t}\n\n\t\tif (gf_isom_get_media_subtype(dest, track, 1) == GF_ISOM_MEDIA_TIMECODE) {\n\t\t\ttmcd_track = track;\n\t\t}\n\t\tif (rap_only || refs_only) {\n\t\t\te = gf_media_remove_non_rap(dest, track, refs_only);\n\t\t\tGOTO_EXIT(\"removing non RAPs\")\n\t\t}\n\t\tif (handler_name) {\n\t\t\te = gf_isom_set_handler_name(dest, track, handler_name);\n\t\t\tGOTO_EXIT(\"setting handler name\")\n\t\t}\n\t\telse if (!keep_handler) {\n\t\t\tchar szHName[1024];\n\t\t\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\n\t\t\tfName = strchr(fName, '.');\n\t\t\tif (fName) fName += 1;\n\t\t\telse fName = \"?\";\n\n\t\t\tsprintf(szHName, \"%s@GPAC%s\", fName, gf_gpac_version());\n\t\t\te = gf_isom_set_handler_name(dest, track, szHName);\n\t\t\tGOTO_EXIT(\"setting handler name\")\n\t\t}\n\t\tif (handler) {\n\t\t\te = gf_isom_set_media_type(dest, track, handler);\n\t\t\tGOTO_EXIT(\"setting media type\")\n\t\t}\n\t\tif (group) {\n\t\t\te = gf_isom_set_alternate_group_id(dest, track, group);\n\t\t\tGOTO_EXIT(\"setting alternate group\")\n\t\t}\n\n\t\tif (track_layout) {\n\t\t\te = gf_isom_set_track_layout_info(dest, track, tw<<16, th<<16, tx<<16, ty<<16, tz);\n\t\t\tGOTO_EXIT(\"setting track layout\")\n\t\t}\n\t\tif (stype) {\n\t\t\te = gf_isom_set_media_subtype(dest, track, 1, stype);\n\t\t\tGOTO_EXIT(\"setting media subtype\")\n\t\t}\n\t\tif (is_chap && chap_ref) {\n\t\t\te = set_chapter_track(dest, track, chap_ref);\n\t\t\tGOTO_EXIT(\"setting chapter track\")\n\t\t}\n\n\t\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\n\t\t\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\n\t\t\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\n\t\t\te = gf_isom_add_track_kind(dest, i+1, kind_scheme, kind_value);\n\t\t\tGOTO_EXIT(\"setting track kind\")\n\t\t}\n\n\t\tif (profile || compat || level) {\n\t\t\te = gf_media_change_pl(dest, track, profile, compat, level);\n\t\t\tGOTO_EXIT(\"changing video PL\")\n\t\t}\n\t\tif (gf_isom_get_mpeg4_subtype(dest, track, 1))\n\t\t\tkeep_sys_tracks = 1;\n\n\t\t//if moov timescale is <0 (auto mode) set it at import time\n\t\tif (fake_import) {\n\t\t\tif (import_flags & GF_IMPORT_NO_EDIT_LIST)\n\t\t\t\tgf_isom_remove_edits(dest, track);\n\n\t\t\tif (moov_timescale<0) {\n\t\t\t\tmoov_timescale = gf_isom_get_media_timescale(dest, track);\n\t\t\t}\n\t\t\tif (moov_timescale>0) {\n\t\t\t\te = gf_isom_set_timescale(dest, moov_timescale);\n\t\t\t\tGOTO_EXIT(\"changing timescale\")\n\t\t\t}\n\n\t\t\tif (import.asemode && (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\tu32 sr, ch, bps;\n\t\t\t\tgf_isom_get_audio_info(dest, track, 1, &sr, &ch, &bps);\n\t\t\t\tgf_isom_set_audio_info(dest, track, 1, sr, ch, bps, import.asemode);\n\t\t\t}\n\t\t}\n\n\t\tif (roll_change) {\n\t\t\tif ((roll_change!=3) || (media_type==GF_ISOM_MEDIA_AUDIO)) {\n\t\t\t\te = gf_isom_set_sample_roll_group(dest, track, (u32) -1, (roll_change==2) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL, roll);\n\t\t\t\tGOTO_EXIT(\"assigning roll\")\n\t\t\t}\n\t\t}\n\n\t\tif (new_timescale>1) {\n\t\t\te = gf_isom_set_media_timescale(dest, track, new_timescale, 0, 0);\n\t\t\tGOTO_EXIT(\"setting media timescale\")\n\t\t}\n\n\t\tif (rescale_num > 1) {\n\t\t\tswitch (gf_isom_get_media_type(dest, track)) {\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tif (!rescale_override) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Cannot force media timescale for audio media types - ignoring\\n\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, rescale_num, rescale_den, rescale_override ? 2 : 1);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Rescale ignored, same config in source file\\n\"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\t\t\t\tGOTO_EXIT(\"rescaling media track\")\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (src_is_isom && force_fps.den && force_fps.num) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, track))) {\n\t\t\t\te = gf_isom_set_media_timescale(dest, track, force_fps.num, force_fps.den, 2);\n                if (e==GF_EOS) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Rescale ignored, same config in source file\\n\"));\n\t\t\t\t\te = GF_OK;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Cannot force FPS for media types %s - ignoring\\n\", gf_4cc_to_str( gf_isom_get_media_type(dest, track)) ));\n\t\t\t}\n\t\t}\n\n\t\tif (has_last_sample_dur) {\n\t\t\te = gf_isom_set_last_sample_duration_ex(dest, track, last_sample_dur.num, last_sample_dur.den);\n\t\t\tGOTO_EXIT(\"setting last sample duration\")\n\t\t}\n\t\tif (rvc_config) {\n#ifdef GPAC_DISABLE_ZLIB\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error: no zlib support - RVC not available\\n\"));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n#else\n\t\t\tu8 *data;\n\t\t\tu32 size;\n\t\t\te = gf_file_load_data(rvc_config, (u8 **) &data, &size);\n\t\t\tGOTO_EXIT(\"loading RVC config file\")\n\n\t\t\tgf_gz_compress_payload(&data, size, &size);\n\t\t\te |= gf_isom_set_rvc_config(dest, track, 1, 0, \"application/rvc-config+xml+gz\", data, size);\n\t\t\tgf_free(data);\n\t\t\tGOTO_EXIT(\"compressing and assigning RVC config\")\n#endif\n\t\t} else if (rvc_predefined>0) {\n\t\t\te = gf_isom_set_rvc_config(dest, track, 1, rvc_predefined, NULL, NULL, 0);\n\t\t\tGOTO_EXIT(\"setting RVC predefined config\")\n\t\t}\n\n\t\tif (neg_ctts_mode) {\n\t\t\te = gf_isom_set_composition_offset_mode(dest, track, (neg_ctts_mode==1) ? GF_TRUE : GF_FALSE);\n\t\t\tGOTO_EXIT(\"setting composition offset mode\")\n\t\t}\n\n\t\tif (gf_isom_get_avc_svc_type(dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\n\t\t\tcheck_track_for_svc = track;\n\n\t\tswitch (gf_isom_get_hevc_lhvc_type(dest, track, 1)) {\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\tcheck_track_for_lhvc = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\tcheck_track_for_hevc=1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (txt_flags) {\n\t\t\te = gf_isom_text_set_display_flags(dest, track, 0, txt_flags, txt_mode);\n\t\t\tGOTO_EXIT(\"setting text track display flags\")\n\t\t}\n\n\t\tif (edits) {\n\t\t\te = apply_edits(dest, track, edits);\n\t\t\tGOTO_EXIT(\"applying edits\")\n\t\t}\n\n\t\tif (force_rate>=0) {\n\t\t\te = gf_isom_update_bitrate(dest, i+1, 1, force_rate, force_rate, 0);\n\t\t\tGOTO_EXIT(\"updating bitrate\")\n\t\t}\n\n\t\tif (split_tile_mode) {\n\t\t\tswitch (gf_isom_get_media_subtype(dest, track, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsplit_tile_mode = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((dlb_mode>=-1) && (gf_isom_get_media_subtype(dest, track, 1)==GF_ISOM_SUBTYPE_EC3)) {\n\t\t\tGF_AC3Config *ac3c = gf_isom_ac3_config_get(dest, track, 1);\n\t\t\tif (ac3c) {\n\t\t\t\tif (dlb_mode==0) {\n\t\t\t\t\tac3c->is_ec3 = GF_TRUE;\n\t\t\t\t\tac3c->atmos_ec3_ext=0;\n\t\t\t\t\tac3c->complexity_index_type=0;\n\t\t\t\t} else {\n\t\t\t\t\tu32 di;\n\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(dest, track, 1, &di);\n\t\t\t\t\tu32 pos;\n\t\t\t\t\tgf_eac3_parser(samp->data, samp->dataLength, &pos, ac3c, GF_TRUE);\n\n\t\t\t\t\tif (dlb_mode>0) {\n\t\t\t\t\t\tac3c->atmos_ec3_ext = 1;\n\t\t\t\t\t\tac3c->complexity_index_type = dlb_mode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_ac3_config_update(dest, track, 1, ac3c);\n\t\t\t\tgf_free(ac3c);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chapter_name) {\n\t\tif (is_chap_file) {\n\t\t\tGF_Fraction a_fps = {0,0};\n\t\t\te = gf_media_import_chapters(dest, chapter_name, a_fps, GF_FALSE);\n\t\t} else {\n\t\t\te = gf_isom_add_chapter(dest, 0, 0, chapter_name);\n\t\t}\n\t\tGOTO_EXIT(\"importing chapters\")\n\t}\n\n\tif (tmcd_track) {\n\t\tu32 tmcd_id = gf_isom_get_track_id(dest, tmcd_track);\n\t\tfor (i=0; i < gf_isom_get_track_count(dest); i++) {\n\t\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_isom_set_track_reference(dest, i+1, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT(\"assigning TMCD track references\")\n\t\t}\n\t}\n\n\t/*force to rewrite all dependencies*/\n\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t{\n\t\te = gf_isom_rewrite_track_dependencies(dest, i);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Warning: track ID %d has references to a track not imported\\n\", gf_isom_get_track_id(dest, i) ));\n\t\t\te = GF_OK;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\n\t\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\n\t\t{\n\t\t\te = gf_media_filter_hevc(dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: track ID %d: error while filtering LHVC layers\\n\", gf_isom_get_track_id(dest, i)));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (check_track_for_svc) {\n\t\tif (svc_mode) {\n\t\t\te = gf_media_split_svc(dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\n\t\t\tGOTO_EXIT(\"splitting SVC track\")\n\t\t} else {\n\t\t\te = gf_media_merge_svc(dest, check_track_for_svc, 1);\n\t\t\tGOTO_EXIT(\"merging SVC/SHVC track\")\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (check_track_for_lhvc) {\n\t\tif (svc_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\n\t\t\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\n\t\t\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\n\t\t\tGOTO_EXIT(\"splitting L-HEVC track\")\n\t\t} else {\n\t\t\t//TODO - merge, temporal sublayers\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_HEVC\n\tif (check_track_for_hevc) {\n\t\tif (split_tile_mode) {\n\t\t\te = gf_media_split_hevc_tiles(dest, split_tile_mode - 1);\n\t\t\tGOTO_EXIT(\"splitting HEVC tiles\")\n\t\t}\n\t\tif (temporal_mode) {\n\t\t\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\n\t\t\te = gf_media_split_lhvc(dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\n\t\t\tGOTO_EXIT(\"splitting HEVC temporal sublayers\")\n\t\t}\n\t}\n#endif\n\n\tif (tc_fps_num) {\n\t\tu32 desc_index=0;\n\t\tu32 tmcd_tk, tmcd_id;\n\t\tu32 video_ref = 0;\n\t\tGF_BitStream *bs;\n\t\tGF_ISOSample *samp;\n\t\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\t\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, i+1))) {\n\t\t\t\tvideo_ref = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttmcd_tk = gf_isom_new_track(dest, 0, GF_ISOM_MEDIA_TIMECODE, tc_fps_num);\n\t\tif (!tmcd_tk) {\n\t\t\te = gf_isom_last_error(dest);\n\t\t\tGOTO_EXIT(\"creating TMCD track\")\n\t\t}\n\t\te = gf_isom_set_track_enabled(dest, tmcd_tk, 1);\n\t\tif (e != GF_OK) {\n\t\t\tGOTO_EXIT(\"enabling TMCD track\")\n\t\t}\n\n\t\tif (!tc_frames_per_tick) {\n\t\t\ttc_frames_per_tick = tc_fps_num;\n\t\t\ttc_frames_per_tick /= tc_fps_den;\n\t\t\tif (tc_frames_per_tick * tc_fps_den < tc_fps_num)\n\t\t\t\ttc_frames_per_tick++;\n\t\t}\n\n\t\tu32 tmcd_value = (tc_h * 3600 + tc_m*60 + tc_s)*tc_frames_per_tick+tc_f;\n\t\ttmcd_id = gf_isom_get_track_id(dest, tmcd_tk);\n\n\t\te = gf_isom_tmcd_config_new(dest, tmcd_tk, tc_fps_num, tc_fps_den, tc_frames_per_tick, tc_drop_frame, tc_force_counter, &desc_index);\n\t\tGOTO_EXIT(\"configuring TMCD sample description\")\n\n\t\tif (video_ref) {\n\t\t\te = gf_isom_set_track_reference(dest, video_ref, GF_ISOM_REF_TMCD, tmcd_id);\n\t\t\tGOTO_EXIT(\"assigning TMCD track ref on video track\")\n\t\t}\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, tmcd_value);\n\t\tsamp = gf_isom_sample_new();\n\t\tsamp->IsRAP = SAP_TYPE_1;\n\t\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\t\tgf_bs_del(bs);\n\t\te = gf_isom_add_sample(dest, tmcd_tk, desc_index, samp);\n\t\tgf_isom_sample_del(&samp);\n\t\tGOTO_EXIT(\"assigning TMCD sample\")\n\n\t\tif (video_ref) {\n\t\t\tu64 video_ref_dur = gf_isom_get_media_duration(dest, video_ref);\n\t\t\tvideo_ref_dur *= tc_fps_num;\n\t\t\tvideo_ref_dur /= gf_isom_get_media_timescale(dest, video_ref);\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, (u32) video_ref_dur);\n\t\t} else {\n\t\t\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, tc_fps_den ? tc_fps_den : 1);\n\t\t}\n\t\tGOTO_EXIT(\"setting TMCD sample dur\")\n\t}\n\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\nexit:\n\twhile (gf_list_count(kinds)) {\n\t\tchar *kind = (char *)gf_list_get(kinds, 0);\n\t\tgf_list_rem(kinds, 0);\n\t\tif (kind) gf_free(kind);\n\t}\n\tif (opt_src) opt_src[0] = ':';\n\tif (opt_dst) opt_dst[0] = ':';\n\tif (fchain) fchain[0] = ':';\n\tif (hdr_file) gf_free(hdr_file);\n\n\tgf_list_del(kinds);\n\tif (handler_name) gf_free(handler_name);\n\tif (chapter_name ) gf_free(chapter_name);\n\tif (import.fontName) gf_free(import.fontName);\n\tif (import.streamFormat) gf_free(import.streamFormat);\n\tif (import.force_ext) gf_free(import.force_ext);\n\tif (rvc_config) gf_free(rvc_config);\n\tif (edits) gf_free(edits);\n\tif (szLan) gf_free((char *)szLan);\n\tif (icc_data) gf_free(icc_data);\n\tif (final_name) gf_free(final_name);\n\n\tif (!e) return GF_OK;\n\tif (fail_msg) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failure while %s: %s\\n\", fail_msg, gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n",
                            "caller_start": 622,
                            "file_path": "applications/mp4box/fileimport.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1273,
                            "call_code": "gf_media_split_hevc_tiles(movie, 0)",
                            "caller_code": "static GF_Err gf_isom_iff_create_image_item_from_track_internal(GF_ISOFile *movie, Bool root_meta, u32 meta_track_number, u32 imported_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs, u32 sample_number) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_Err e;\n\tu32 w, h, hSpacing, vSpacing;\n\tu8 num_channels;\n\tu8 bits_per_channel[3];\n\tu32 subtype;\n\tGF_ISOSample *sample = NULL;\n\tu32 timescale;\n\tu32 item_type = 0;\n\tGF_ImageItemProperties local_image_props;\n\tGF_ImageItemProtection ipro, *orig_ipro = NULL;\n\tBool config_needed = 0;\n\tGF_Box *config_box = NULL;\n\tBool is_cenc = GF_FALSE;\n\tBool is_first = GF_TRUE;\n\tBool neg_time = (image_props && image_props->time<0) ? GF_TRUE : GF_FALSE;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0, sai_alloc_size = 0;\n\tu32 sample_desc_index = 0;\n\tGF_ISOFile *fsrc = movie;\n\tBool reset_brands = GF_FALSE;\n\n\t//only reset brands if first item import\n\tif (!gf_isom_get_meta_item_count(movie, root_meta, meta_track_number))\n\t\treset_brands = GF_TRUE;\n\n\tif (image_props && image_props->src_file)\n\t\tfsrc = image_props->src_file;\n\n\tif (image_props && image_props->tile_mode != TILE_ITEM_NONE) {\n\t\t/* Processing the input file in Tiled mode:\n\t\t   The single track is split into multiple tracks\n\t\t   and each track is processed to create an item */\n\t\tu32 i, count;\n\t\tu32 tile_track;\n\t\tGF_List *tile_item_ids;\n\t\tchar sz_item_name[256];\n\t\tGF_TileItemMode orig_tile_mode;\n\n#if !defined(GPAC_DISABLE_HEVC) && !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (image_props->src_file)\n\t\t\te = GF_SERVICE_ERROR;\n\t\telse\n\t\t\te = gf_media_split_hevc_tiles(movie, 0);\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\n\t\tif (e) return e;\n\t\ttile_item_ids = gf_list_new();\n\t\torig_tile_mode = image_props->tile_mode;\n\t\timage_props->tile_mode = TILE_ITEM_NONE;\n\t\tcount = gf_isom_get_reference_count(movie, imported_track, GF_ISOM_REF_SABT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_malloc(sizeof(u32));\n\t\t\tif (!tile_item_id) return GF_OUT_OF_MEM;\n\n\t\t\t*tile_item_id = item_id + i+1;\n\t\t\tgf_list_add(tile_item_ids, tile_item_id);\n\t\t\te = gf_isom_get_reference(movie, imported_track, GF_ISOM_REF_SABT, 1, &tile_track);\n\t\t\tif (e) return e;\n\t\t\tif (item_name)\n\t\t\t\tsprintf(sz_item_name, \"%s-Tile%d\", item_name, i + 1);\n\t\t\tif (orig_tile_mode != TILE_ITEM_SINGLE || image_props->single_tile_number == i + 1) {\n\t\t\t\te = gf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, tile_track, item_name ? sz_item_name : NULL, *tile_item_id, NULL, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t\tgf_isom_remove_track(movie, tile_track);\n\t\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\t\te = gf_isom_meta_add_item_ref(movie, root_meta, meta_track_number, *tile_item_id, item_id, GF_ISOM_REF_TBAS, NULL);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (item_name)\n\t\t\tsprintf(sz_item_name, \"%s-TileBase\", item_name);\n\t\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\n\t\t\tgf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, imported_track, item_name ? sz_item_name : NULL, item_id, image_props, tile_item_ids);\n\t\t}\n\t\telse if (orig_tile_mode == TILE_ITEM_ALL_GRID) {\n\t\t\t// TODO\n\t\t}\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tu32 *tile_item_id = gf_list_get(tile_item_ids, i);\n\t\t\tgf_free(tile_item_id);\n\t\t}\n\t\tgf_list_del(tile_item_ids);\n\t\treturn GF_OK;\n\t}\n\n\tif (!image_props) {\n\t\timage_props = &local_image_props;\n\t\tmemset(image_props, 0, sizeof(GF_ImageItemProperties));\n\t} else {\n\t\torig_ipro = image_props->cenc_info;\n\t\timage_props->cenc_info = NULL;\n\t}\n\n\tif (!imported_track) {\n\t\tGF_ImageItemProperties src_props;\n\t\tu32 item_idx, ref_id;\n\t\tu32 scheme_type=0, scheme_version=0;\n\t\tconst char *orig_item_name, *orig_item_mime_type, *orig_item_encoding;\n\t\tif (!image_props->item_ref_id) return GF_BAD_PARAM;\n\n\t\tif (gf_isom_meta_get_item_ref_count(fsrc, GF_TRUE, 0, image_props->item_ref_id, GF_4CC('d','i','m','g')) > 0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Cannnot import derived image, only native image import is supported\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\titem_idx = gf_isom_get_meta_item_by_id(fsrc, GF_TRUE, 0, image_props->item_ref_id);\n\t\tif (!item_idx) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: No item with ID %d, cannnot import\\n\", image_props->item_ref_id));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\torig_item_name = orig_item_mime_type = orig_item_encoding = NULL;\n\t\tgf_isom_get_meta_item_info(fsrc, GF_TRUE, 0, item_idx, &ref_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &orig_item_name, &orig_item_mime_type, &orig_item_encoding);\n\n\t\tif (!ref_id) return GF_BAD_PARAM;\n\t\tif (ref_id != image_props->item_ref_id) return GF_ISOM_INVALID_FILE;\n\n\t\tgf_isom_get_meta_image_props(fsrc, GF_TRUE, 0, ref_id, &src_props, NULL);\n\n\t\timage_props->config = src_props.config;\n\t\timage_props->width = src_props.width;\n\t\timage_props->height = src_props.height;\n\t\timage_props->num_channels = src_props.num_channels;\n\t\tmemcpy(image_props->av1_layer_size, src_props.av1_layer_size, sizeof(u32)*3);\n\t\tmemcpy(image_props->bits_per_channel, src_props.bits_per_channel, sizeof(u32)*3);\n\t\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\t\timage_props->hSpacing = src_props.hSpacing;\n\t\t\timage_props->vSpacing = src_props.vSpacing;\n\t\t}\n\t\tif (image_props->copy_props) {\n\t\t\tif (!image_props->hOffset && !image_props->vOffset) {\n\t\t\t\timage_props->hOffset = src_props.hOffset;\n\t\t\t\timage_props->vOffset = src_props.vOffset;\n\t\t\t}\n\t\t\tif (!image_props->clap_wden) {\n\t\t\t\timage_props->clap_wnum = src_props.clap_wnum;\n\t\t\t\timage_props->clap_wden = src_props.clap_wden;\n\t\t\t\timage_props->clap_hnum = src_props.clap_hnum;\n\t\t\t\timage_props->clap_hden = src_props.clap_hden;\n\t\t\t\timage_props->clap_honum = src_props.clap_honum;\n\t\t\t\timage_props->clap_hoden = src_props.clap_hoden;\n\t\t\t\timage_props->clap_vonum = src_props.clap_vonum;\n\t\t\t\timage_props->clap_voden = src_props.clap_voden;\n\t\t\t}\n\t\t\tif (!image_props->alpha) image_props->alpha = src_props.alpha;\n\t\t\tif (!image_props->depth) image_props->depth = src_props.depth;\n\t\t\tif (!image_props->hidden) image_props->hidden = src_props.hidden;\n\t\t\tif (!image_props->angle) image_props->angle = src_props.angle;\n\t\t\tif (!image_props->mirror) image_props->mirror = src_props.mirror;\n\t\t\tif (!image_props->av1_op_index) image_props->av1_op_index = src_props.av1_op_index;\n\t\t}\n\t\tif (!item_name) item_name = orig_item_name;\n\n\t\tif (!image_props->use_reference || (fsrc == image_props->src_file)) {\n\t\t\tu8 *data = NULL;\n\t\t\tu32 size=0;\n\t\t\te = gf_isom_extract_meta_item_mem(fsrc, GF_TRUE, 0, ref_id, &data, &size, &size, NULL, GF_FALSE);\n\t\t\tif (e) return GF_BAD_PARAM;\n\n\t\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, data, size, NULL);\n\t\t\tif (data) gf_free(data);\n\t\t} else {\n\t\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, 0, ref_id);\n\t\t}\n\t\treturn e;\n\t}\n\nimport_next_sample:\n\n\ttimescale = gf_isom_get_media_timescale(fsrc, imported_track);\n\tif (image_props->sample_num) {\n\t\tsample_number = image_props->sample_num;\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else if (image_props->time<0) {\n\t\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\n\t\te = gf_isom_last_error(fsrc);\n\t} else {\n\t\te = gf_isom_get_sample_for_media_time(fsrc, imported_track, (u64)(image_props->time*timescale), &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &sample, &sample_number, NULL);\n\t}\n\tif (e || !sample || !sample->IsRAP) {\n\t\tif (!sample) {\n\t\t\tif (is_first) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"No sample found%s\\n\", (image_props->time<0) ? \"\" : \" for requested time\"));\n\t\t\t} else {\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if ((image_props->time<0) || (image_props->step_time)) {\n\t\t\tif (image_props->sample_num) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: imported sample %d (DTS \"LLU\") is not a sync sample (RAP %d size %d)\\n\", sample_number, sample->DTS, sample->IsRAP, sample->dataLength));\n\t\t\t} else if (image_props->step_time) {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\te = GF_OK;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tgf_isom_sample_del(&sample);\n\t\t\t\tsample_number++;\n\t\t\t\tif (sample_number == gf_isom_get_sample_count(fsrc, imported_track)) {\n\t\t\t\t\te = GF_OK;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tgoto import_next_sample;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error no sync sample found after time %g\\n\", image_props->time));\n\t\t}\n\t\tif (!e) e = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\n\t/* Check if the track type is supported as item type */\n\t/* Get the config box if needed */\n\tsubtype = gf_isom_get_media_subtype(fsrc, imported_track, sample_desc_index);\n\tif (gf_isom_is_media_encrypted(fsrc, imported_track, sample_desc_index)) {\n\t\tif (gf_isom_is_cenc_media(fsrc, imported_track, sample_desc_index)) {\n\t\t\te = gf_isom_get_original_format_type(fsrc, imported_track, sample_desc_index, &subtype);\n\t\t\tif (e) goto exit;\n\t\t\tis_cenc = GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Protected sample not using CENC, cannot add as item\\n\"));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_avc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_svc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_mvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_hevc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\tif (subtype == GF_ISOM_SUBTYPE_HVT1) {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVT1;\n\t\t}\n\t\telse {\n\t\t\titem_type = GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tconfig_needed = 1;\n\t\tif (!((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_lhvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t}\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\tbits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tbits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_AV01:\n\t\t{\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_isom_av1_config_get(fsrc, imported_track, sample_desc_index);\n\t\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\t\tconfig_needed = 1;\n\t\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\t\tnum_channels = 1;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = 0;\n\t\t\t\tbits_per_channel[2] = 0;\n\t\t\t} else {\n\t\t\t\tnum_channels = 3;\n\t\t\t\tbits_per_channel[0] = depth;\n\t\t\t\tbits_per_channel[1] = depth;\n\t\t\t\tbits_per_channel[2] = depth;\n\t\t\t}\n\t\t\t// presence of OBU SH in config is not recommended and properties should be used instead of metadata OBUs\n\t\t\twhile (gf_list_count(((GF_AV1ConfigurationBox *)config_box)->config->obu_array)) {\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_pop_back(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t\tif (obu) {\n\t\t\t\t\tif (obu->obu) gf_free(obu->obu);\n\t\t\t\t\tgf_free(obu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\n\t\t\t((GF_AV1ConfigurationBox *)config_box)->config->obu_array = NULL;\n\t\t\te = gf_media_av1_layer_size_get(fsrc, imported_track, sample_number, image_props->av1_op_index, image_props->av1_layer_size);\n      if (e) {\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"AV1 operating point index out of range for stream\\n\"));\n        goto exit;\n      }\n\t\t\t//media_brand = GF_ISOM_BRAND_AVIF;\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SUBTYPE_VVC1:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\t\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_isom_vvc_config_get(fsrc, imported_track, sample_desc_index);\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tconfig_needed = 1;\n\t\tnum_channels = 3;\n\t\tbits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\tbits_per_channel[1] = bits_per_channel[2] = bits_per_channel[0];\n\t\t//media_brand = GF_ISOM_BRAND_HEIC;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Codec not supported to create HEIF image items\\n\"));\n\t\te = GF_NOT_SUPPORTED;\n\t\tgoto exit;\n\t}\n\tif (config_needed && !config_box && !((GF_AVCConfigurationBox *)config_box)->config) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Image type %s requires a missing configuration box\\n\", gf_4cc_to_str(item_type)));\n\t\te = GF_BAD_PARAM;\n\t\tgoto exit;\n\t}\n\t/* Get some images properties from the track data */\n\te = gf_isom_get_visual_info(fsrc, imported_track, sample_desc_index, &w, &h);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error determining image size\\n\"));\n\t\tgoto exit;\n\t}\n\te = gf_isom_get_pixel_aspect_ratio(fsrc, imported_track, sample_desc_index, &hSpacing, &vSpacing);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error determining image aspect ratio\\n\"));\n\t\tgoto exit;\n\t}\n\tif (!image_props->width && !image_props->height) {\n\t\timage_props->width = w;\n\t\timage_props->height = h;\n\t}\n\tif (!image_props->hSpacing && !image_props->vSpacing) {\n\t\timage_props->hSpacing = hSpacing;\n\t\timage_props->vSpacing = vSpacing;\n\t}\n\timage_props->config = config_box;\n\tif (!image_props->num_channels) {\n\t\timage_props->num_channels = num_channels;\n\t\timage_props->bits_per_channel[0] = bits_per_channel[0];\n\t\timage_props->bits_per_channel[1] = bits_per_channel[1];\n\t\timage_props->bits_per_channel[2] = bits_per_channel[2];\n\t}\n\tif (is_cenc) {\n\t\tBool Is_Encrypted;\n\n\t\tmemset(&ipro, 0, sizeof(GF_ImageItemProtection));\n\t\tgf_isom_get_cenc_info(fsrc, imported_track, sample_desc_index, NULL, &ipro.scheme_type, &ipro.scheme_version);\n\t\te = gf_isom_get_sample_cenc_info(fsrc, imported_track, sample_desc_index, &Is_Encrypted, &ipro.crypt_byte_block, &ipro.skip_byte_block, &ipro.key_info, &ipro.key_info_size);\n\t\tif (e) goto exit;\n\n\t\tif (Is_Encrypted) {\n\t\t\tsai_size = sai_alloc_size;\n\t\t\te = gf_isom_cenc_get_sample_aux_info(fsrc, imported_track, sample_number, sample_desc_index, NULL, &sai, &sai_size);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (sai_size > sai_alloc_size)\n\t\t\t\tsai_alloc_size = sai_size;\n\n\t\t\tipro.sai_data = sai;\n\t\t\tipro.sai_data_size = sai_size;\n\t\t\timage_props->cenc_info = &ipro;\n\n\t\t\tif (is_first) {\n\t\t\t\tu32 i, nb_pssh = gf_isom_get_pssh_count(fsrc);\n\t\t\t\tfor (i=0; i<nb_pssh; i++) {\n\t\t\t\t\tbin128 SystemID;\n\t\t\t\t\tu32 version;\n\t\t\t\t\tu32 KID_count;\n\t\t\t\t\tconst bin128 *KIDs;\n\t\t\t\t\tconst u8 *private_data;\n\t\t\t\t\tu32 private_data_size;\n\n\t\t\t\t\tgf_isom_get_pssh_info(fsrc, i+1, SystemID, &version, &KID_count, &KIDs, &private_data, &private_data_size);\n\t\t\t\t\t\n\t\t\t\t\tgf_cenc_set_pssh(movie, SystemID, version, KID_count, (bin128 *) KIDs, (u8 *) private_data, private_data_size, 2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\timage_props->cenc_info = NULL;\n\t\t}\n\t}\n\tif (!item_id) {\n\t\te = gf_isom_meta_get_next_item_id(movie, root_meta, meta_track_number, &item_id);\n\t\tif (e) goto exit;\n\t}\n\tif (image_props->use_reference) {\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"referring trackID %d sample %d as item %d\\n\", imported_track, sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"referring trackID %d sample at time %.3f as item %d\\n\", imported_track, (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, imported_track, sample_number);\n\t} else {\n\n\t\tif (image_props->sample_num) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Adding sample %d as item %d\\n\", sample_number, item_id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Adding sample at time %.3f as item %d\\n\", (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\n\t\t}\n\t\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, sample->data, sample->dataLength, item_extent_refs);\n\t}\n\n\timage_props->cenc_info = NULL;\n\n\tif (reset_brands) {\n\t\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(movie);\n\n\t\t// TODO Analyze configuration to determine the brand */\n\t\t//if (media_brand) {\n\t\t//\tgf_isom_modify_alternate_brand(movie, media_brand, GF_TRUE);\n\t\t//}\n\t}\n\n\t\n\tif (neg_time)\n\t\timage_props->time = -1;\n\n\tif (!e && !image_props->sample_num && ((image_props->time<0) || image_props->end_time || image_props->step_time)) {\n\t\tif (image_props->end_time || image_props->step_time) {\n\t\t\tDouble t = (Double) (sample->DTS + sample->CTS_Offset);\n\t\t\tt /= timescale;\n\t\t\tif (image_props->step_time) {\n\t\t\t\tt += image_props->step_time;\n\t\t\t} else {\n\t\t\t\t//step 1ms\n\t\t\t\tt += 0.001;\n\t\t\t}\n\n\t\t\tif ((image_props->end_time>0) && (t>image_props->end_time)) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\timage_props->time = t;\n\t\t}\n\n\t\titem_id=0;\n\t\tgf_isom_sample_del(&sample);\n\t\tif (config_box) {\n\t\t\tgf_isom_box_del(config_box);\n\t\t\tconfig_box = NULL;\n\t\t}\n\t\tis_first = GF_FALSE;\n\t\tif (sample_number >= gf_isom_get_sample_count(fsrc, imported_track)) return e;\n\t\tsample_number++;\n\t\t//avoid recursion this could get quite big\n\t\tgoto import_next_sample;\n\t}\n\nexit:\n\tif (sai) gf_free(sai);\n\tgf_isom_sample_del(&sample);\n\tif (config_box) gf_isom_box_del(config_box);\n\timage_props->cenc_info = orig_ipro;\n\treturn e;\n\n\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\n}\n",
                            "caller_start": 1229,
                            "file_path": "src/isomedia/iff.c"
                        }
                    ]
                },
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'gf_isom_get_sample', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}",
                            "start_line": 1934,
                            "end_line": 1937,
                            "full_name": "gf_isom_get_sample",
                            "file_path": "src/isomedia/isom_read.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-29T22:15:10.463936"
        },
        {
            "stage": "analysis",
            "iteration": 1,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: fixed #2359\n- **Vulnerability Description**: GPAC MP4Box 2.1-DEV-rev649-ga8f438d20 has a segment fault (/stack overflow) due to infinite recursion in Media_GetSample isomedia/media.c:662\n- **Patch Code**: [{'func_name': 'gf_media_split_hevc_tiles', 'patch': '--- func_before\\n+++ func_after\\n@@ -3544,6 +3544,10 @@\\n \\t\\tu32 size, nb_nalus=0, nb_nal_entries=0, last_tile_group=(u32) -1;\\n \\t\\tGF_BitStream *bs=NULL;\\n \\t\\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\\n+\\t\\tif (!sample) {\\n+\\t\\t\\te = gf_isom_last_error(file);\\n+\\t\\t\\tgoto err_exit;\\n+\\t\\t}\\n \\n \\t\\tdata = (u8 *) sample->data;\\n \\t\\tsize = sample->dataLength;', 'file_path': 'src/media_tools/isom_tools.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a null check for `sample` after calling `gf_isom_get_sample` in `isom_tools.c:3544`, preventing dereference of a null pointer which would cause a segmentation fault. If `sample` is null, it retrieves the error and exits via `err_exit`.\",\n      \"required_context\": [\n        \"caller: gf_media_split_hevc_tiles\",\n        \"function: gf_isom_get_sample\"\n      ],\n      \"root_cause\": \"In `gf_media_split_hevc_tiles` (isom_tools.c:3544), `gf_isom_get_sample` may return null, leading to uninitialized `sample->data`/`sample->dataLength` access. The patch adds a null check to prevent this. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly addressed here. GAP: Missing link between `gf_media_split_hevc_tiles` and `Media_GetSample` logic.\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:gf_media_split_hevc_tiles)\",\n        \"result\": [\n          {\n            \"call_line\": 1912,\n            \"call_code\": \"gf_media_split_hevc_tiles(dest, split_tile_mode - 1)\",\n            \"caller_code\": \"GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, GF_Fraction force_fps, u32 frames_per_sample, GF_FilterSession *fsess, char **mux_args_if_first_pass, char **mux_sid_if_first_pass, u32 tk_idx)\\n{\\n\\tu32 track_id, i, j, timescale, track, stype, profile, compat, level, new_timescale, rescale_num, rescale_den, svc_mode, txt_flags, split_tile_mode, temporal_mode, nb_tracks;\\n\\ts32 par_d, par_n, prog_id, force_rate, moov_timescale;\\n\\ts32 tw, th, tx, ty, tz, txtw, txth, txtx, txty;\\n\\tBool do_audio, do_video, do_auxv,do_pict, do_all, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, rap_only, refs_only, force_par, rewrite_bs;\\n\\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc, do_disable;\\n\\tconst char *szLan;\\n\\tGF_Err e = GF_OK;\\n\\tGF_Fraction delay;\\n\\tu32 tmcd_track = 0, neg_ctts_mode=0;\\n\\tBool keep_audelim = GF_FALSE;\\n\\tu32 print_stats_graph=fs_dump_flags;\\n\\tGF_MediaImporter import;\\n\\tchar *ext, *final_name=NULL, *handler_name, *rvc_config, *chapter_name;\\n\\tGF_List *kinds;\\n\\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\\n\\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\\n\\tu32 clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod;\\n\\tBool has_clap=GF_FALSE;\\n\\tBool use_stz2=GF_FALSE;\\n\\tBool has_mx=GF_FALSE;\\n\\ts32 mx[9];\\n\\tu32 bitdepth=0;\\n\\tchar dv_profile[100]; /*Dolby Vision*/\\n\\tu32 clr_type=0;\\n\\tu32 clr_prim;\\n\\tu32 clr_tranf;\\n\\tu32 clr_mx;\\n\\tBool rescale_override=GF_FALSE;\\n\\tBool clr_full_range=GF_FALSE;\\n\\tBool fmt_ok = GF_TRUE;\\n\\tu32 icc_size=0, track_flags=0;\\n\\tu8 *icc_data = NULL;\\n\\tu32 tc_fps_num=0, tc_fps_den=0, tc_h=0, tc_m=0, tc_s=0, tc_f=0, tc_frames_per_tick=0;\\n\\tBool tc_force_counter=GF_FALSE;\\n\\tBool tc_drop_frame = GF_FALSE;\\n\\tchar *ext_start;\\n\\tu32 xps_inband=0;\\n\\tu64 source_magic=0;\\n\\tchar *opt_src = NULL;\\n\\tchar *opt_dst = NULL;\\n\\tchar *fchain = NULL;\\n\\tchar *edits = NULL;\\n\\tconst char *fail_msg = NULL;\\n\\tchar *hdr_file=NULL;\\n\\tBool set_ccst=GF_FALSE;\\n\\tBool has_last_sample_dur=GF_FALSE;\\n\\tu32 fake_import = 0;\\n\\tGF_Fraction last_sample_dur = {0,0};\\n\\ts32 fullrange, videofmt, colorprim, colortfc, colormx;\\n\\tclap_wn = clap_wd = clap_hn = clap_hd = clap_hon = clap_hod = clap_von = clap_vod = 0;\\n\\tGF_ISOMTrackFlagOp track_flags_mode=0;\\n\\tu32 roll_change=0;\\n\\ts32 roll = 0;\\n\\tBool src_is_isom = GF_FALSE;\\n\\ts32 dlb_mode = -2;\\n\\n\\tdv_profile[0] = 0;\\n\\trvc_predefined = 0;\\n\\tchapter_name = NULL;\\n\\tnew_timescale = 1;\\n\\tmoov_timescale = 0;\\n\\trescale_num = rescale_den = 0;\\n\\ttext_layout = 0;\\n\\t/*0: merge all\\n\\t  1: split base and all SVC in two tracks\\n\\t  2: split all base and SVC layers in dedicated tracks\\n\\t */\\n\\tsvc_mode = 0;\\n\\n\\tif (import_flags==0xFFFFFFFF) {\\n\\t\\timport_flags = 0;\\n\\t\\tfake_import = 1;\\n\\t}\\n\\n\\tmemset(&import, 0, sizeof(GF_MediaImporter));\\n\\n\\tfinal_name = gf_strdup(inName);\\n#ifdef WIN32\\n\\t/*dirty hack for msys&mingw: when we use import options, the ':' separator used prevents msys from translating the path\\n\\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we're screwed :( */\\n\\tif ( (final_name[0]=='/') && (final_name[2]=='/')) {\\n\\t\\tfinal_name[0] = final_name[1];\\n\\t\\tfinal_name[1] = ':';\\n\\t}\\n#endif\\n\\n\\tis_chap_file = 0;\\n\\thandler = 0;\\n\\tdo_disable = 0;\\n\\tchap_ref = 0;\\n\\tis_chap = 0;\\n\\tkinds = gf_list_new();\\n\\ttrack_layout = 0;\\n\\tszLan = NULL;\\n\\tdelay.num = delay.den = 0;\\n\\tgroup = 0;\\n\\tstype = 0;\\n\\tprofile = compat = level = 0;\\n\\tfullrange = videofmt = colorprim = colortfc = colormx = -1;\\n\\tsplit_tile_mode = 0;\\n\\ttemporal_mode = 0;\\n\\trap_only = 0;\\n\\trefs_only = 0;\\n\\ttxt_flags = 0;\\n\\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\\n\\tforce_rate = -1;\\n\\n\\ttw = th = tx = ty = tz = txtw = txth = txtx = txty = 0;\\n\\tpar_d = par_n = -1;\\n\\tforce_par = rewrite_bs = GF_FALSE;\\n\\n\\text_start = gf_file_ext_start(final_name);\\n\\text = strrchr(ext_start ? ext_start : final_name, '#');\\n\\tif (!ext) ext = gf_url_colon_suffix(final_name, '=');\\n\\tchar c_sep = ext ? ext[0] : 0;\\n\\tif (ext) ext[0] = 0;\\n \\tif (!strlen(final_name) || !strcmp(final_name, \\\"self\\\")) {\\n\\t\\tfake_import = 2;\\n\\t\\tsrc_is_isom = GF_TRUE;\\n\\t}\\n\\tchar *frag = strrchr(final_name, '#');\\n\\tif (frag) frag[0] = 0;\\n\\tif (gf_isom_probe_file(final_name))\\n\\t\\tsrc_is_isom = GF_TRUE;\\n\\tif (frag) frag[0] = '#';\\n\\n\\tif (ext) ext[0] = c_sep;\\n\\n\\text = gf_url_colon_suffix(final_name, '=');\\n\\n#define GOTO_EXIT(_msg) if (e) { fail_msg = _msg; goto exit; }\\n\\n#define CHECK_FAKEIMPORT(_opt) if (fake_import) { M4_LOG(GF_LOG_ERROR, (\\\"Option %s not available for self-reference import\\\\n\\\", _opt)); e = GF_BAD_PARAM; goto exit; }\\n#define CHECK_FAKEIMPORT_2(_opt) if (fake_import==1) { M4_LOG(GF_LOG_ERROR, (\\\"Option %s not available for self-reference import\\\\n\\\", _opt)); e = GF_BAD_PARAM; goto exit; }\\n\\n\\n\\thandler_name = NULL;\\n\\trvc_config = NULL;\\n\\twhile (ext) {\\n\\t\\tchar *ext2 = gf_url_colon_suffix(ext+1, '=');\\n\\n\\t\\tif (ext2) ext2[0] = 0;\\n\\n\\t\\t/*all extensions for track-based importing*/\\n\\t\\tif (!strnicmp(ext+1, \\\"dur=\\\", 4)) {\\n\\t\\t\\tCHECK_FAKEIMPORT(\\\"dur\\\")\\n\\n\\t\\t\\tif (strchr(ext, '-')) {\\n\\t\\t\\t\\timport.duration.num = parse_s32(ext+5, \\\"dur\\\");\\n\\t\\t\\t\\timport.duration.den = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgf_parse_frac(ext+5, &import.duration);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"start=\\\", 6)) {\\n\\t\\t\\tCHECK_FAKEIMPORT(\\\"start\\\")\\n\\t\\t\\timport.start_time = atof(ext+7);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"lang=\\\", 5)) {\\n\\t\\t\\t/* prevent leak if param is set twice */\\n\\t\\t\\tif (szLan)\\n\\t\\t\\t\\tgf_free((char*) szLan);\\n\\n\\t\\t\\tszLan = gf_strdup(ext+6);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"delay=\\\", 6)) {\\n\\t\\t\\tif (sscanf(ext+7, \\\"%d/%u\\\", &delay.num, &delay.den)!=2) {\\n\\t\\t\\t\\tdelay.num = parse_s32(ext+7, \\\"delay\\\");\\n\\t\\t\\t\\tdelay.den = 1000; //in ms\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"par=\\\", 4)) {\\n\\t\\t\\tif (!stricmp(ext + 5, \\\"none\\\")) {\\n\\t\\t\\t\\tpar_n = par_d = 0;\\n\\t\\t\\t} else if (!stricmp(ext + 5, \\\"auto\\\")) {\\n\\t\\t\\t\\tforce_par = GF_TRUE;\\n\\t\\t\\t} else if (!stricmp(ext + 5, \\\"force\\\")) {\\n\\t\\t\\t\\tpar_n = par_d = 1;\\n\\t\\t\\t\\tforce_par = GF_TRUE;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (ext2) {\\n\\t\\t\\t\\t\\text2[0] = ':';\\n\\t\\t\\t\\t\\text2 = strchr(ext2+1, ':');\\n\\t\\t\\t\\t\\tif (ext2) ext2[0] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (ext[5]=='w') {\\n\\t\\t\\t\\t\\trewrite_bs = GF_TRUE;\\n\\t\\t\\t\\t\\tif (sscanf(ext+6, \\\"%d:%d\\\", &par_n, &par_d)!=2) {\\n\\t\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized syntax for par=, expecting N:D got %s\\\\n\\\", ext+5));\\n\\t\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (sscanf(ext+5, \\\"%d:%d\\\", &par_n, &par_d) != 2) {\\n\\t\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized syntax for par=, expecting N:D got %s\\\\n\\\", ext+5));\\n\\t\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"clap=\\\", 5)) {\\n\\t\\t\\tif (!stricmp(ext+6, \\\"none\\\")) {\\n\\t\\t\\t\\thas_clap=GF_TRUE;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (sscanf(ext+6, \\\"%d,%d,%d,%d,%d,%d,%d,%d\\\", &clap_wn, &clap_wd, &clap_hn, &clap_hd, &clap_hon, &clap_hod, &clap_von, &clap_vod)==8) {\\n\\t\\t\\t\\t\\thas_clap=GF_TRUE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"mx=\\\", 3)) {\\n\\t\\t\\tif (strstr(ext+4, \\\"0x\\\")) {\\n\\t\\t\\t\\tif (sscanf(ext+4, \\\"0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%d\\\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\\n\\t\\t\\t\\t\\thas_mx=GF_TRUE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (sscanf(ext+4, \\\"%d,%d,%d,%d,%d,%d,%d,%d,%d\\\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\\n\\t\\t\\t\\thas_mx=GF_TRUE;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"name=\\\", 5)) {\\n\\t\\t\\thandler_name = gf_strdup(ext+6);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"ext=\\\", 4)) {\\n\\t\\t\\tCHECK_FAKEIMPORT(\\\"ext\\\")\\n\\t\\t\\t/*extensions begin with '.'*/\\n\\t\\t\\tif (*(ext+5) == '.')\\n\\t\\t\\t\\timport.force_ext = gf_strdup(ext+5);\\n\\t\\t\\telse {\\n\\t\\t\\t\\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\\n\\t\\t\\t\\timport.force_ext[0] = '.';\\n\\t\\t\\t\\tstrcat(import.force_ext+1, ext+5);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"hdlr=\\\", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\\n\\t\\telse if (!strnicmp(ext+1, \\\"stype=\\\", 6)) stype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\\n\\t\\telse if (!strnicmp(ext+1, \\\"tkhd\\\", 4)) {\\n\\t\\t\\tchar *flags = ext+6;\\n\\t\\t\\tif (flags[0]=='+') { track_flags_mode = GF_ISOM_TKFLAGS_ADD; flags += 1; }\\n\\t\\t\\telse if (flags[0]=='-') { track_flags_mode = GF_ISOM_TKFLAGS_REM; flags += 1; }\\n\\t\\t\\telse track_flags_mode = GF_ISOM_TKFLAGS_SET;\\n\\n\\t\\t\\tif (strstr(flags, \\\"enable\\\")) track_flags |= GF_ISOM_TK_ENABLED;\\n\\t\\t\\tif (strstr(flags, \\\"movie\\\")) track_flags |= GF_ISOM_TK_IN_MOVIE;\\n\\t\\t\\tif (strstr(flags, \\\"preview\\\")) track_flags |= GF_ISOM_TK_IN_PREVIEW;\\n\\t\\t\\tif (strstr(flags, \\\"size_ar\\\")) track_flags |= GF_ISOM_TK_SIZE_IS_AR;\\n\\t\\t\\tif (!track_flags) {\\n\\t\\t\\t\\tif (!strnicmp(flags, \\\"0x\\\", 2)) flags += 2;\\n\\t\\t\\t\\tsscanf(flags, \\\"%X\\\", &track_flags);\\n\\t\\t\\t}\\n\\t\\t} else if (!strnicmp(ext+1, \\\"disable\\\", 7)) {\\n\\t\\t\\tdo_disable = !stricmp(ext+1, \\\"disable=no\\\") ? 2 : 1;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"group=\\\", 6)) {\\n\\t\\t\\tgroup = parse_u32(ext+7, \\\"group\\\");\\n\\t\\t\\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"fps=\\\", 4)) {\\n\\t\\t\\tu32 ticks, dts_inc;\\n\\t\\t\\tif (!strcmp(ext+5, \\\"auto\\\")) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning, fps=auto option is deprecated\\\\n\\\"));\\n\\t\\t\\t} else if ((sscanf(ext+5, \\\"%u-%u\\\", &ticks, &dts_inc) == 2) || (sscanf(ext+5, \\\"%u/%u\\\", &ticks, &dts_inc) == 2)) {\\n\\t\\t\\t\\tif (!dts_inc) dts_inc=1;\\n\\t\\t\\t\\tforce_fps.num = ticks;\\n\\t\\t\\t\\tforce_fps.den = dts_inc;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (gf_sys_old_arch_compat()) {\\n\\t\\t\\t\\t\\tforce_fps.den = 1000;\\n\\t\\t\\t\\t\\tforce_fps.num = (u32) (atof(ext+5) * force_fps.den);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgf_parse_frac(ext+5, &force_fps);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"rap\\\")) rap_only = 1;\\n\\t\\telse if (!stricmp(ext+1, \\\"refs\\\")) refs_only = 1;\\n\\t\\telse if (!stricmp(ext+1, \\\"trailing\\\")) { CHECK_FAKEIMPORT(\\\"trailing\\\") import_flags |= GF_IMPORT_KEEP_TRAILING; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"agg=\\\", 4)) { CHECK_FAKEIMPORT(\\\"agg\\\") frames_per_sample = parse_u32(ext+5, \\\"agg\\\"); }\\n\\t\\telse if (!stricmp(ext+1, \\\"dref\\\")) { CHECK_FAKEIMPORT(\\\"dref\\\")  import_flags |= GF_IMPORT_USE_DATAREF; }\\n\\t\\telse if (!stricmp(ext+1, \\\"keep_refs\\\")) { CHECK_FAKEIMPORT(\\\"keep_refs\\\") import_flags |= GF_IMPORT_KEEP_REFS; }\\n\\t\\telse if (!stricmp(ext+1, \\\"nodrop\\\")) { CHECK_FAKEIMPORT(\\\"nodrop\\\") import_flags |= GF_IMPORT_NO_FRAME_DROP; }\\n\\t\\telse if (!stricmp(ext+1, \\\"packed\\\")) { CHECK_FAKEIMPORT(\\\"packed\\\") import_flags |= GF_IMPORT_FORCE_PACKED; }\\n\\t\\telse if (!stricmp(ext+1, \\\"sbr\\\")) { CHECK_FAKEIMPORT(\\\"sbr\\\") import_flags |= GF_IMPORT_SBR_IMPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"sbrx\\\")) { CHECK_FAKEIMPORT(\\\"sbrx\\\") import_flags |= GF_IMPORT_SBR_EXPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"ovsbr\\\")) { CHECK_FAKEIMPORT(\\\"ovsbr\\\") import_flags |= GF_IMPORT_OVSBR; }\\n\\t\\telse if (!stricmp(ext+1, \\\"ps\\\")) { CHECK_FAKEIMPORT(\\\"ps\\\") import_flags |= GF_IMPORT_PS_IMPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"psx\\\")) { CHECK_FAKEIMPORT(\\\"psx\\\") import_flags |= GF_IMPORT_PS_EXPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"mpeg4\\\")) { CHECK_FAKEIMPORT(\\\"mpeg4\\\") import_flags |= GF_IMPORT_FORCE_MPEG4; }\\n\\t\\telse if (!stricmp(ext+1, \\\"nosei\\\")) { CHECK_FAKEIMPORT(\\\"nosei\\\") import_flags |= GF_IMPORT_NO_SEI; }\\n\\t\\telse if (!stricmp(ext+1, \\\"svc\\\") || !stricmp(ext+1, \\\"lhvc\\\") ) { CHECK_FAKEIMPORT(\\\"svc/lhvc\\\") import_flags |= GF_IMPORT_SVC_EXPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"nosvc\\\") || !stricmp(ext+1, \\\"nolhvc\\\")) { CHECK_FAKEIMPORT(\\\"nosvc/nolhvc\\\") import_flags |= GF_IMPORT_SVC_NONE; }\\n\\n\\t\\t/*split SVC layers*/\\n\\t\\telse if (!strnicmp(ext+1, \\\"svcmode=\\\", 8) || !strnicmp(ext+1, \\\"lhvcmode=\\\", 9)) {\\n\\t\\t\\tchar *mode = ext+9;\\n\\t\\t\\tCHECK_FAKEIMPORT_2(\\\"svcmode/lhvcmode\\\")\\n\\t\\t\\tif (mode[0]=='=') mode = ext+10;\\n\\n\\t\\t\\tif (!stricmp(mode, \\\"splitnox\\\"))\\n\\t\\t\\t\\tsvc_mode = 3;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitnoxib\\\"))\\n\\t\\t\\t\\tsvc_mode = 4;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitall\\\") || !stricmp(mode, \\\"split\\\"))\\n\\t\\t\\t\\tsvc_mode = 2;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitbase\\\"))\\n\\t\\t\\t\\tsvc_mode = 1;\\n\\t\\t\\telse if (!stricmp(mode, \\\"merged\\\") || !stricmp(mode, \\\"merge\\\"))\\n\\t\\t\\t\\tsvc_mode = 0;\\n\\t\\t}\\n\\t\\t/*split SHVC temporal sublayers*/\\n\\t\\telse if (!strnicmp(ext+1, \\\"temporal=\\\", 9)) {\\n\\t\\t\\tchar *mode = ext+10;\\n\\t\\t\\tCHECK_FAKEIMPORT_2(\\\"svcmode/lhvcmode\\\")\\n\\t\\t\\tif (!stricmp(mode, \\\"split\\\"))\\n\\t\\t\\t\\ttemporal_mode = 2;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitnox\\\"))\\n\\t\\t\\t\\ttemporal_mode = 3;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitbase\\\"))\\n\\t\\t\\t\\ttemporal_mode = 1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized temporal mode %s, ignoring\\\\n\\\", mode));\\n\\t\\t\\t\\ttemporal_mode = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"subsamples\\\")) { CHECK_FAKEIMPORT(\\\"subsamples\\\") import_flags |= GF_IMPORT_SET_SUBSAMPLES; }\\n\\t\\telse if (!stricmp(ext+1, \\\"deps\\\")) { CHECK_FAKEIMPORT(\\\"deps\\\") import_flags |= GF_IMPORT_SAMPLE_DEPS; }\\n\\t\\telse if (!stricmp(ext+1, \\\"ccst\\\")) { CHECK_FAKEIMPORT(\\\"ccst\\\") set_ccst = GF_TRUE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"alpha\\\")) { CHECK_FAKEIMPORT(\\\"alpha\\\") import.is_alpha = GF_TRUE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"forcesync\\\")) { CHECK_FAKEIMPORT(\\\"forcesync\\\") import_flags |= GF_IMPORT_FORCE_SYNC; }\\n\\t\\telse if (!stricmp(ext+1, \\\"xps_inband\\\")) { CHECK_FAKEIMPORT(\\\"xps_inband\\\") xps_inband = 1; }\\n\\t\\telse if (!stricmp(ext+1, \\\"xps_inbandx\\\")) { CHECK_FAKEIMPORT(\\\"xps_inbandx\\\") xps_inband = 2; }\\n\\t\\telse if (!stricmp(ext+1, \\\"au_delim\\\")) { CHECK_FAKEIMPORT(\\\"au_delim\\\") keep_audelim = GF_TRUE; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"max_lid=\\\", 8) || !strnicmp(ext+1, \\\"max_tid=\\\", 8)) {\\n\\t\\t\\ts32 val = parse_u32(ext+9, \\\"Max TID/LID\\\");\\n\\t\\t\\tCHECK_FAKEIMPORT_2(\\\"max_lid/lhvcmode\\\")\\n\\t\\t\\tif (val < 0) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning: request max layer/temporal id is negative - ignoring\\\\n\\\"));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!strnicmp(ext+1, \\\"max_lid=\\\", 8))\\n\\t\\t\\t\\t\\tmax_layer_id_plus_one = 1 + (u8) val;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmax_temporal_id_plus_one = 1 + (u8) val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"tiles\\\")) { CHECK_FAKEIMPORT_2(\\\"tiles\\\") split_tile_mode = 2; }\\n\\t\\telse if (!stricmp(ext+1, \\\"tiles_rle\\\")) { CHECK_FAKEIMPORT_2(\\\"tiles_rle\\\") split_tile_mode = 3; }\\n\\t\\telse if (!stricmp(ext+1, \\\"split_tiles\\\")) { CHECK_FAKEIMPORT_2(\\\"split_tiles\\\") split_tile_mode = 1; }\\n\\n\\t\\t/*force all composition offsets to be positive*/\\n\\t\\telse if (!strnicmp(ext+1, \\\"negctts\\\", 7)) {\\n\\t\\t\\tneg_ctts_mode = !strnicmp(ext+1, \\\"negctts=no\\\", 10) ? 2 : 1;\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"chap\\\")) is_chap = 1;\\n\\t\\telse if (!strnicmp(ext+1, \\\"chapter=\\\", 8)) {\\n\\t\\t\\tchapter_name = gf_strdup(ext+9);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"chapfile=\\\", 9)) {\\n\\t\\t\\tchapter_name = gf_strdup(ext+10);\\n\\t\\t\\tis_chap_file=1;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"layout=\\\", 7)) {\\n\\t\\t\\ttrack_layout = 1;\\n\\t\\t\\tif ( sscanf(ext+13, \\\"%dx%dx%dx%dx%d\\\", &tw, &th, &tx, &ty, &tz)==5) {\\n\\t\\t\\t} else if ( sscanf(ext+13, \\\"%dx%dx%dx%d\\\", &tw, &th, &tx, &ty)==4) {\\n\\t\\t\\t\\ttz = 0;\\n\\t\\t\\t} else if ( sscanf(ext+13, \\\"%dx%dx%d\\\", &tw, &th, &tz)==3) {\\n\\t\\t\\t\\ttx = ty = 0;\\n\\t\\t\\t} else if ( sscanf(ext+8, \\\"%dx%d\\\", &tw, &th)==2) {\\n\\t\\t\\t\\ttx = ty = tz = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"rescale=\\\", 8)) {\\n\\t\\t\\tif (sscanf(ext+9, \\\"%u/%u\\\", &rescale_num, &rescale_den) != 2) {\\n\\t\\t\\t\\trescale_num = parse_u32(ext+9, \\\"rescale\\\");\\n\\t\\t\\t\\trescale_den = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"sampdur=\\\", 8)) {\\n\\t\\t\\tif (sscanf(ext+9, \\\"%u/%u\\\", &rescale_den, &rescale_num) != 2) {\\n\\t\\t\\t\\trescale_den = parse_u32(ext+9, \\\"sampdur\\\");\\n\\t\\t\\t\\trescale_num = 0;\\n\\t\\t\\t}\\n\\t\\t\\trescale_override = GF_TRUE;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"timescale=\\\", 10)) {\\n\\t\\t\\tnew_timescale = parse_u32(ext+11, \\\"timescale\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"moovts=\\\", 7)) {\\n\\t\\t\\tmoov_timescale = parse_u32(ext+8, \\\"moovts\\\");\\n\\t\\t}\\n\\n\\t\\telse if (!stricmp(ext+1, \\\"noedit\\\")) { import_flags |= GF_IMPORT_NO_EDIT_LIST; }\\n\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"rvc=\\\", 4)) {\\n\\t\\t\\tif (sscanf(ext+5, \\\"%d\\\", &rvc_predefined) != 1) {\\n\\t\\t\\t\\trvc_config = gf_strdup(ext+5);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"fmt=\\\", 4)) import.streamFormat = gf_strdup(ext+5);\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"profile=\\\", 8)) {\\n\\t\\t\\tif (!stricmp(ext+9, \\\"high444\\\")) profile = 244;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"high\\\")) profile = 100;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"extended\\\")) profile = 88;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"main\\\")) profile = 77;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"baseline\\\")) profile = 66;\\n\\t\\t\\telse profile = parse_u32(ext+9, \\\"profile\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"level=\\\", 6)) {\\n\\t\\t\\tif( atof(ext+7) < 6 )\\n\\t\\t\\t\\tlevel = (int)(10*atof(ext+7)+.5);\\n\\t\\t\\telse\\n\\t\\t\\t\\tlevel = parse_u32(ext+7, \\\"level\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"compat=\\\", 7)) {\\n\\t\\t\\tcompat = parse_u32(ext+8, \\\"compat\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"dlba=\\\", 5)) {\\n\\t\\t\\tif (!strcmp(ext+6, \\\"no\\\")) dlb_mode=0;\\n\\t\\t\\telse if (!strcmp(ext+6, \\\"auto\\\")) dlb_mode=-1;\\n\\t\\t\\telse if (sscanf(ext+6, \\\"%d\\\", &dlb_mode) != 1) {\\n\\t\\t\\t\\tGOTO_EXIT(\\\"Unrecognized dolby atmos mode\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"novpsext\\\", 8)) { CHECK_FAKEIMPORT(\\\"novpsext\\\") import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"keepav1t\\\", 8)) { CHECK_FAKEIMPORT(\\\"keepav1t\\\") import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU; }\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"font=\\\", 5)) { CHECK_FAKEIMPORT(\\\"font\\\") import.fontName = gf_strdup(ext+6); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"size=\\\", 5)) { CHECK_FAKEIMPORT(\\\"size\\\") import.fontSize = parse_u32(ext+6, \\\"size\\\"); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"text_layout=\\\", 12)) {\\n\\t\\t\\tif ( sscanf(ext+13, \\\"%dx%dx%dx%d\\\", &txtw, &txth, &txtx, &txty)==4) {\\n\\t\\t\\t\\ttext_layout = 1;\\n\\t\\t\\t} else if ( sscanf(ext+8, \\\"%dx%d\\\", &txtw, &txth)==2) {\\n\\t\\t\\t\\ttrack_layout = 1;\\n\\t\\t\\t\\ttxtx = txty = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n#ifndef GPAC_DISABLE_SWF_IMPORT\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-global\\\")) { CHECK_FAKEIMPORT(\\\"swf-global\\\") import.swf_flags |= GF_SM_SWF_STATIC_DICT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-ctrl\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-ctrl\\\") import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-text\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-text\\\") import.swf_flags |= GF_SM_SWF_NO_TEXT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-font\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-font\\\") import.swf_flags |= GF_SM_SWF_NO_FONT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-line\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-line\\\") import.swf_flags |= GF_SM_SWF_NO_LINE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-grad\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-grad\\\") import.swf_flags |= GF_SM_SWF_NO_GRADIENT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-quad\\\")) { CHECK_FAKEIMPORT(\\\"swf-quad\\\") import.swf_flags |= GF_SM_SWF_QUAD_CURVE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-xlp\\\")) { CHECK_FAKEIMPORT(\\\"swf-xlp\\\") import.swf_flags |= GF_SM_SWF_SCALABLE_LINE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-ic2d\\\")) { CHECK_FAKEIMPORT(\\\"swf-ic2d\\\") import.swf_flags |= GF_SM_SWF_USE_IC2D; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-same-app\\\")) { CHECK_FAKEIMPORT(\\\"swf-same-app\\\") import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"swf-flatten=\\\", 12)) { CHECK_FAKEIMPORT(\\\"swf-flatten\\\") import.swf_flatten_angle = (Float) atof(ext+13); }\\n#endif\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"kind=\\\", 5)) {\\n\\t\\t\\tchar *kind_scheme, *kind_value;\\n\\t\\t\\tchar *kind_data = ext+6;\\n\\t\\t\\tchar *sep = strchr(kind_data, '=');\\n\\t\\t\\tif (sep) {\\n\\t\\t\\t\\t*sep = 0;\\n\\t\\t\\t}\\n\\t\\t\\tkind_scheme = gf_strdup(kind_data);\\n\\t\\t\\tif (sep) {\\n\\t\\t\\t\\t*sep = '=';\\n\\t\\t\\t\\tkind_value = gf_strdup(sep+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkind_value = NULL;\\n\\t\\t\\t}\\n\\t\\t\\tgf_list_add(kinds, kind_scheme);\\n\\t\\t\\tgf_list_add(kinds, kind_value);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"txtflags\\\", 8)) {\\n\\t\\t\\tif (!strnicmp(ext+1, \\\"txtflags=\\\", 9)) {\\n\\t\\t\\t\\tsscanf(ext+10, \\\"%x\\\", &txt_flags);\\n\\t\\t\\t}\\n\\t\\t\\telse if (!strnicmp(ext+1, \\\"txtflags+=\\\", 10)) {\\n\\t\\t\\t\\tsscanf(ext+11, \\\"%x\\\", &txt_flags);\\n\\t\\t\\t\\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\\n\\t\\t\\t}\\n\\t\\t\\telse if (!strnicmp(ext+1, \\\"txtflags-=\\\", 10)) {\\n\\t\\t\\t\\tsscanf(ext+11, \\\"%x\\\", &txt_flags);\\n\\t\\t\\t\\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"rate=\\\", 5)) {\\n\\t\\t\\tforce_rate = parse_s32(ext+6, \\\"rate\\\");\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"stats\\\") || !stricmp(ext+1, \\\"fstat\\\"))\\n\\t\\t\\tprint_stats_graph |= 1;\\n\\t\\telse if (!stricmp(ext+1, \\\"graph\\\") || !stricmp(ext+1, \\\"graph\\\"))\\n\\t\\t\\tprint_stats_graph |= 2;\\n\\t\\telse if (!strncmp(ext+1, \\\"sopt\\\", 4) || !strncmp(ext+1, \\\"dopt\\\", 4) || !strncmp(ext+1, \\\"@\\\", 1)) {\\n\\t\\t\\tif (ext2) ext2[0] = ':';\\n\\t\\t\\topt_src = strstr(ext, \\\":sopt:\\\");\\n\\t\\t\\topt_dst = strstr(ext, \\\":dopt:\\\");\\n\\t\\t\\tfchain = strstr(ext, \\\":@\\\");\\n\\t\\t\\tif (opt_src) opt_src[0] = 0;\\n\\t\\t\\tif (opt_dst) opt_dst[0] = 0;\\n\\t\\t\\tif (fchain) fchain[0] = 0;\\n\\n\\t\\t\\tif (opt_src) import.filter_src_opts = opt_src+6;\\n\\t\\t\\tif (opt_dst) import.filter_dst_opts = opt_dst+6;\\n\\t\\t\\tif (fchain) {\\n\\t\\t\\t\\t//check for old syntax (0.9->1.0) :@@\\n\\t\\t\\t\\tif (fchain[2]=='@') {\\n\\t\\t\\t\\t\\timport.filter_chain = fchain + 3;\\n\\t\\t\\t\\t\\timport.is_chain_old_syntax = GF_TRUE;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\timport.filter_chain = fchain + 2;\\n\\t\\t\\t\\t\\timport.is_chain_old_syntax = GF_FALSE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\text = NULL;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"asemode=\\\", 8)){\\n\\t\\t\\tchar *mode = ext+9;\\n\\t\\t\\tif (!stricmp(mode, \\\"v0-bs\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\\n\\t\\t\\telse if (!stricmp(mode, \\\"v0-2\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\\n\\t\\t\\telse if (!stricmp(mode, \\\"v1\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\\n\\t\\t\\telse if (!stricmp(mode, \\\"v1-qt\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\\n\\t\\t\\telse\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized audio sample entry mode %s, ignoring\\\\n\\\", mode));\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"audio_roll=\\\", 11)) { roll_change = 3; roll = parse_s32(ext+12, \\\"audio_roll\\\"); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"roll=\\\", 5)) { roll_change = 1; roll = parse_s32(ext+6, \\\"roll\\\"); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"proll=\\\", 6)) { roll_change = 2; roll = parse_s32(ext+7, \\\"proll\\\"); }\\n\\t\\telse if (!strcmp(ext+1, \\\"stz2\\\")) {\\n\\t\\t\\tuse_stz2 = GF_TRUE;\\n\\t\\t} else if (!strnicmp(ext+1, \\\"bitdepth=\\\", 9)) {\\n\\t\\t\\tbitdepth = parse_u32(ext+10, \\\"bitdepth\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"hdr=\\\", 4)) {\\n\\t\\t\\thdr_file = gf_strdup(ext+5);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colr=\\\", 5)) {\\n\\t\\t\\tchar *cval = ext+6;\\n\\t\\t\\tif (!strcmp(cval, \\\"none\\\")) {\\n\\t\\t\\t\\tclr_type = (u32) -1;\\n\\t\\t\\t} else if (strlen(cval)<6) {\\n\\t\\t\\t\\tfmt_ok = GF_FALSE;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tclr_type = GF_4CC(cval[0],cval[1],cval[2],cval[3]);\\n\\t\\t\\t\\tcval+=4;\\n\\t\\t\\t\\tif (cval[0] != ',') {\\n\\t\\t\\t\\t\\tfmt_ok = GF_FALSE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if ((clr_type==GF_ISOM_SUBTYPE_NCLX) || (clr_type==GF_ISOM_SUBTYPE_NCLC)) {\\n\\t\\t\\t\\t\\tfmt_ok = scan_color(cval+1, &clr_prim, &clr_tranf, &clr_mx, &clr_full_range);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if ((clr_type==GF_ISOM_SUBTYPE_RICC) || (clr_type==GF_ISOM_SUBTYPE_PROF)) {\\n\\t\\t\\t\\t\\tFILE *f = gf_fopen(cval+1, \\\"rb\\\");\\n\\t\\t\\t\\t\\tif (!f) {\\n\\t\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Failed to open file %s\\\\n\\\", cval+1));\\n\\t\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tgf_fseek(f, 0, SEEK_END);\\n\\t\\t\\t\\t\\t\\ticc_size = (u32) gf_ftell(f);\\n\\t\\t\\t\\t\\t\\ticc_data = gf_malloc(sizeof(char)*icc_size);\\n\\t\\t\\t\\t\\t\\tgf_fseek(f, 0, SEEK_SET);\\n\\t\\t\\t\\t\\t\\ticc_size = (u32) gf_fread(icc_data, icc_size, f);\\n\\t\\t\\t\\t\\t\\tgf_fclose(f);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized colr profile %s\\\\n\\\", gf_4cc_to_str(clr_type) ));\\n\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!fmt_ok) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"parsing colr option\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext + 1, \\\"dvp=\\\", 4)) {\\n\\t\\t\\tstrncpy(dv_profile, ext + 5, 99);\\n\\t\\t\\tdv_profile[99]=0;\\n\\t\\t}\\n\\t\\t//old name\\n\\t\\telse if (!strnicmp(ext + 1, \\\"dv-profile=\\\", 11)) {\\n\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Deprecated option name, use `:dvp=` instead\\\\n\\\"));\\n\\t\\t\\tstrncpy(dv_profile, ext + 12, 99);\\n\\t\\t\\tdv_profile[99]=0;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"fullrange=\\\", 10)) {\\n\\t\\t\\tif (!stricmp(ext+11, \\\"off\\\") || !stricmp(ext+11, \\\"no\\\")) fullrange = 0;\\n\\t\\t\\telse if (!stricmp(ext+11, \\\"on\\\") || !stricmp(ext+11, \\\"yes\\\")) fullrange = 1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for fullrange\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"videofmt=\\\", 10)) {\\n\\t\\t\\tu32 idx, count = GF_ARRAY_LENGTH(videofmt_names);\\n\\t\\t\\tfor (idx=0; idx<count; idx++) {\\n\\t\\t\\t\\tif (!strcmp(ext+11, videofmt_names[idx])) {\\n\\t\\t\\t\\t\\tvideofmt = idx;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (videofmt==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for videofmt\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colorprim=\\\", 10)) {\\n\\t\\t\\tcolorprim = gf_cicp_parse_color_primaries(ext+11);\\n\\t\\t\\tif (colorprim==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for colorprim\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colortfc=\\\", 9)) {\\n\\t\\t\\tcolortfc = gf_cicp_parse_color_transfer(ext+10);\\n\\t\\t\\tif (colortfc==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for colortfc\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colormx=\\\", 10)) {\\n\\t\\t\\tcolormx = gf_cicp_parse_color_matrix(ext+11);\\n\\t\\t\\tif (colormx==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for colormx\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"tc=\\\", 3)) {\\n\\t\\t\\tchar *tc_str = ext+4;\\n\\t\\t\\t\\n\\t\\t\\tif (tc_str[0] == 'd') {\\n\\t\\t\\t\\ttc_drop_frame=GF_TRUE;\\n\\t\\t\\t\\ttc_str+=1;\\n\\t\\t\\t}\\n\\t\\t\\tif (sscanf(tc_str, \\\"%d/%d,%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 7) {\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d/%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f) == 6) {\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 6) {\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f) == 5) {\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d/%d,%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_f, &tc_frames_per_tick) == 4) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d/%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_f) == 3) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d,%d\\\", &tc_fps_num, &tc_f, &tc_frames_per_tick) == 3) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d\\\", &tc_fps_num, &tc_f) == 2) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Bad format %s for timecode, ignoring\\\\n\\\", ext+1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"edits=\\\", 6)) {\\n\\t\\t\\tedits = gf_strdup(ext+7);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"lastsampdur\\\", 11)) {\\n\\t\\t\\thas_last_sample_dur = GF_TRUE;\\n\\t\\t\\tif (!strnicmp(ext+1, \\\"lastsampdur=\\\", 12)) {\\n\\t\\t\\t\\tif (sscanf(ext+13, \\\"%d/%u\\\", &last_sample_dur.num, &last_sample_dur.den)==2) {\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlast_sample_dur.num = parse_s32(ext+13, \\\"lastsampdur\\\");\\n\\t\\t\\t\\t\\tlast_sample_dur.den = 1000;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"ID=\\\", 3)) {\\n\\t\\t\\timport.target_trackID = (u32) parse_u32(ext+4, \\\"ID\\\");\\n\\t\\t}\\n\\t\\t/*unrecognized, assume name has colon in it*/\\n\\t\\telse {\\n\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized import option %s, ignoring\\\\n\\\", ext+1));\\n\\t\\t\\tif (ext2) ext2[0] = ':';\\n\\t\\t\\text = ext2;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (src_is_isom) {\\n\\t\\t\\tchar *opt = ext+1;\\n\\t\\t\\tchar *sep_eq = strchr(opt, '=');\\n\\t\\t\\tif (sep_eq) sep_eq[0] = 0;\\n\\t\\t\\tif (!mp4box_check_isom_fileopt(opt)) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"\\\\t! Import option `%s` not available for ISOBMFF/QT sources, ignoring !\\\\n\\\", ext+1));\\n\\t\\t\\t}\\n\\t\\t\\tif (sep_eq) sep_eq[0] = '=';\\n\\t\\t}\\n\\n\\t\\tif (ext2) ext2[0] = ':';\\n\\n\\t\\text[0] = 0;\\n\\n\\t\\t/* restart from where we stopped\\n\\t\\t * if we didn't stop (ext2 null) then the end has been reached\\n\\t\\t * so we can stop the whole thing */\\n\\t\\text = ext2;\\n\\t}\\n\\n\\t/*check duration import (old syntax)*/\\n\\text = strrchr(final_name, '%');\\n\\tif (ext) {\\n\\t\\tgf_parse_frac(ext+1, &import.duration);\\n\\t\\text[0] = 0;\\n\\t}\\n\\n\\t/*select switches for av containers import*/\\n\\tdo_audio = do_video = do_auxv = do_pict = 0;\\n\\ttrack_id = prog_id = 0;\\n\\tdo_all = 1;\\n\\n\\text_start = gf_file_ext_start(final_name);\\n\\text = strrchr(ext_start ? ext_start : final_name, '#');\\n\\tif (ext) ext[0] = 0;\\n\\n\\tif (fake_import && ext) {\\n\\t\\text++;\\n\\t\\tif (!strnicmp(ext, \\\"audio\\\", 5)) do_audio = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"video\\\", 5)) do_video = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"auxv\\\", 4)) do_auxv = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"pict\\\", 4)) do_pict = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"trackID=\\\", 8)) track_id = parse_u32(&ext[8], \\\"trackID\\\");\\n\\t\\telse track_id = parse_u32(ext, \\\"ID\\\");\\n\\t}\\n\\telse if (ext) {\\n\\t\\text++;\\n\\t\\tchar *sep = gf_url_colon_suffix(ext, '=');\\n\\t\\tif (sep) sep[0] = 0;\\n\\n\\t\\t//we have a fragment, we need to check if the track or the program is present in source\\n\\t\\timport.in_name = final_name;\\n\\t\\timport.flags = GF_IMPORT_PROBE_ONLY;\\n\\t\\te = gf_media_import(&import);\\n\\t\\tGOTO_EXIT(\\\"importing import\\\");\\n\\n\\t\\tif (!strnicmp(ext, \\\"audio\\\", 5)) do_audio = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"video\\\", 5)) do_video = 1;\\n        else if (!strnicmp(ext, \\\"auxv\\\", 4)) do_auxv = 1;\\n        else if (!strnicmp(ext, \\\"pict\\\", 4)) do_pict = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"trackID=\\\", 8)) track_id = parse_u32(&ext[8], \\\"trackID\\\");\\n\\t\\telse if (!strnicmp(ext, \\\"PID=\\\", 4)) track_id = parse_u32(&ext[4], \\\"ID\\\");\\n\\t\\telse if (!strnicmp(ext, \\\"program=\\\", 8)) {\\n\\t\\t\\tfor (i=0; i<import.nb_progs; i++) {\\n\\t\\t\\t\\tif (!stricmp(import.pg_info[i].name, ext+8)) {\\n\\t\\t\\t\\t\\tprog_id = import.pg_info[i].number;\\n\\t\\t\\t\\t\\tdo_all = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext, \\\"prog_id=\\\", 8)) {\\n\\t\\t\\tprog_id = parse_u32(ext+8, \\\"prog_id\\\");\\n\\t\\t\\tdo_all = 0;\\n\\t\\t}\\n\\t\\telse track_id = parse_u32(ext, \\\"ID\\\");\\n\\n\\t\\t//figure out trackID\\n\\t\\tif (do_audio || do_video || do_auxv || do_pict || track_id) {\\n\\t\\t\\tBool found = track_id ? GF_FALSE : GF_TRUE;\\n\\t\\t\\tfor (i=0; i<import.nb_tracks; i++) {\\n\\t\\t\\t\\tif (track_id && (import.tk_info[i].track_num==track_id)) {\\n\\t\\t\\t\\t\\tfound=GF_TRUE;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (do_audio && (import.tk_info[i].stream_type==GF_STREAM_AUDIO)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (do_video && (import.tk_info[i].stream_type==GF_STREAM_VISUAL)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (do_auxv && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_AUXV)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (do_pict && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_PICT)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!track_id || !found) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Cannot find track ID matching fragment #%s\\\\n\\\", ext));\\n\\t\\t\\t\\tif (sep) sep[0] = ':';\\n\\t\\t\\t\\te = GF_NOT_FOUND;\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (sep) sep[0] = ':';\\n\\t}\\n\\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\\n\\n\\tif (track_layout || is_chap) {\\n\\t\\tu32 w, h, sw, sh, fw, fh;\\n\\t\\tw = h = sw = sh = fw = fh = 0;\\n\\t\\tchap_ref = 0;\\n\\t\\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\\n\\t\\t\\tswitch (gf_isom_get_media_type(dest, i+1)) {\\n\\t\\t\\tcase GF_ISOM_MEDIA_SCENE:\\n\\t\\t\\tcase GF_ISOM_MEDIA_VISUAL:\\n            case GF_ISOM_MEDIA_AUXV:\\n            case GF_ISOM_MEDIA_PICT:\\n\\t\\t\\t\\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\\n\\n\\t\\t\\t\\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\\n\\t\\t\\t\\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\\n\\t\\t\\t\\tif (w<sw) w = sw;\\n\\t\\t\\t\\tif (w<fw) w = fw;\\n\\t\\t\\t\\tif (h<sh) h = sh;\\n\\t\\t\\t\\tif (h<fh) h = fh;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase GF_ISOM_MEDIA_AUDIO:\\n\\t\\t\\t\\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (track_layout) {\\n\\t\\t\\tif (!tw) tw = w;\\n\\t\\t\\tif (!th) th = h;\\n\\t\\t\\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\\n\\t\\t\\timport.text_width = tw;\\n\\t\\t\\timport.text_height = th;\\n\\t\\t}\\n\\t\\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\\n\\t}\\n\\tif (text_layout && txtw && txth) {\\n\\t\\timport.text_track_width = import.text_width ? import.text_width : txtw;\\n\\t\\timport.text_track_height = import.text_height ? import.text_height : txth;\\n\\t\\timport.text_width = txtw;\\n\\t\\timport.text_height = txth;\\n\\t\\timport.text_x = txtx;\\n\\t\\timport.text_y = txty;\\n\\t}\\n\\n\\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\\n\\n\\tsource_magic = (u64) gf_crc_32((u8 *)inName, (u32) strlen(inName));\\n\\tif (!fake_import && (!fsess || mux_args_if_first_pass)) {\\n\\t\\timport.in_name = final_name;\\n\\t\\timport.dest = dest;\\n\\t\\timport.video_fps = force_fps;\\n\\t\\timport.frames_per_sample = frames_per_sample;\\n\\t\\timport.flags = import_flags;\\n\\t\\timport.keep_audelim = keep_audelim;\\n\\t\\timport.print_stats_graph = print_stats_graph;\\n\\t\\timport.xps_inband = xps_inband;\\n\\t\\timport.prog_id = prog_id;\\n\\t\\timport.trackID = track_id;\\n\\t\\timport.source_magic = source_magic;\\n\\t\\timport.track_index = tk_idx;\\n\\n\\t\\t//if moov timescale is <0 (auto mode) set it at import time\\n\\t\\tif (moov_timescale<0) {\\n\\t\\t\\timport.moov_timescale = moov_timescale;\\n\\t\\t}\\n\\t\\t//otherwise force it now\\n\\t\\telse if (moov_timescale>0) {\\n\\t\\t\\te = gf_isom_set_timescale(dest, moov_timescale);\\n\\t\\t\\tGOTO_EXIT(\\\"changing timescale\\\")\\n\\t\\t}\\n\\n\\t\\timport.run_in_session = fsess;\\n\\t\\timport.update_mux_args = NULL;\\n\\t\\tif (do_all)\\n\\t\\t\\timport.flags |= GF_IMPORT_KEEP_REFS;\\n\\n\\t\\te = gf_media_import(&import);\\n\\t\\tif (e) {\\n\\t\\t\\tif (import.update_mux_args) gf_free(import.update_mux_args);\\n\\t\\t\\tGOTO_EXIT(\\\"importing media\\\");\\n\\t\\t}\\n\\n\\t\\tif (fsess) {\\n\\t\\t\\t*mux_args_if_first_pass = import.update_mux_args;\\n\\t\\t\\timport.update_mux_args = NULL;\\n\\t\\t\\t*mux_sid_if_first_pass = import.update_mux_sid;\\n\\t\\t\\timport.update_mux_sid = NULL;\\n\\t\\t\\tgoto exit;\\n\\t\\t}\\n\\t}\\n\\n\\tnb_tracks = gf_isom_get_track_count(dest);\\n\\tfor (i=0; i<nb_tracks; i++) {\\n\\t\\tu32 media_type;\\n\\t\\ttrack = i+1;\\n\\t\\tmedia_type = gf_isom_get_media_type(dest, track);\\n\\t\\te = GF_OK;\\n\\t\\tif (!fake_import) {\\n\\t\\t\\tu64 tk_source_magic;\\n\\t\\t\\ttk_source_magic = gf_isom_get_track_magic(dest, track);\\n\\n\\t\\t\\tif ((tk_source_magic & 0xFFFFFFFFUL) != source_magic)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttk_source_magic>>=32;\\t\\t\\n\\t\\t\\tkeep_handler = (tk_source_magic & 1) ? GF_TRUE : GF_FALSE;\\n\\t\\t} else {\\n\\t\\t\\tkeep_handler = GF_TRUE;\\n\\n\\t\\t\\tif (do_audio && (media_type!=GF_ISOM_MEDIA_AUDIO)) continue;\\n\\t\\t\\tif (do_video && (media_type!=GF_ISOM_MEDIA_VISUAL)) continue;\\n\\t\\t\\tif (do_auxv && (media_type!=GF_ISOM_MEDIA_AUXV)) continue;\\n\\t\\t\\tif (do_pict && (media_type!=GF_ISOM_MEDIA_PICT)) continue;\\n\\t\\t\\tif (track_id && (gf_isom_get_track_id(dest, track) != track_id))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\ttimescale = gf_isom_get_timescale(dest);\\n\\t\\tif (szLan) {\\n\\t\\t\\te = gf_isom_set_media_language(dest, track, (char *) szLan);\\n\\t\\t\\tGOTO_EXIT(\\\"changing language\\\")\\n\\t\\t}\\n\\t\\tif (do_disable) {\\n\\t\\t\\te = gf_isom_set_track_enabled(dest, track, (do_disable==2) ? GF_TRUE : GF_FALSE);\\n\\t\\t\\tGOTO_EXIT(\\\"disabling track\\\")\\n\\t\\t}\\n\\t\\tif (track_flags_mode) {\\n\\t\\t\\te = gf_isom_set_track_flags(dest, track, track_flags, track_flags_mode);\\n\\t\\t\\tGOTO_EXIT(\\\"disabling track\\\")\\n\\t\\t}\\n\\n\\t\\tif (import_flags & GF_IMPORT_NO_EDIT_LIST) {\\n\\t\\t\\te = gf_isom_remove_edits(dest, track);\\n\\t\\t\\tGOTO_EXIT(\\\"removing edits\\\")\\n\\t\\t}\\n\\t\\tif (delay.num && delay.den) {\\n\\t\\t\\tu64 tk_dur;\\n\\t\\t\\te = gf_isom_remove_edits(dest, track);\\n\\t\\t\\ttk_dur = gf_isom_get_track_duration(dest, track);\\n\\t\\t\\tif (delay.num>0) {\\n\\t\\t\\t\\t//cast to s64, timescale*delay could be quite large before /1000\\n\\t\\t\\t\\te |= gf_isom_append_edit(dest, track, ((s64) delay.num) * timescale / delay.den, 0, GF_ISOM_EDIT_EMPTY);\\n\\t\\t\\t\\te |= gf_isom_append_edit(dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//cast to s64, timescale*delay could be quite large before /1000\\n\\t\\t\\t\\tu64 to_skip = ((s64) -delay.num) * timescale / delay.den;\\n\\t\\t\\t\\tif (to_skip<tk_dur) {\\n\\t\\t\\t\\t\\t//cast to s64, timescale*delay could be quite large before /1000\\n\\t\\t\\t\\t\\tu64 media_time = ((s64) -delay.num) * gf_isom_get_media_timescale(dest, track) / delay.den;\\n\\t\\t\\t\\t\\te |= gf_isom_append_edit(dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning: request negative delay longer than track duration - ignoring\\\\n\\\"));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tGOTO_EXIT(\\\"assigning delay\\\")\\n\\t\\t}\\n\\t\\tif (gf_isom_is_video_handler_type(media_type)) {\\n\\t\\t\\tif (((par_n>=0) && (par_d>=0)) || force_par) {\\n\\t\\t\\t\\te = gf_media_change_par(dest, track, par_n, par_d, force_par, rewrite_bs);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing PAR\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif ((fullrange>=0) || (videofmt>=0) || (colorprim>=0) || (colortfc>=0) || (colormx>=0)) {\\n\\t\\t\\t\\te = gf_media_change_color(dest, i+1, fullrange, videofmt, colorprim, colortfc, colormx);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing color in bitstream\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (has_clap) {\\n\\t\\t\\t\\te = gf_isom_set_clean_aperture(dest, track, 1, clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing clean aperture\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (bitdepth) {\\n\\t\\t\\t\\te = gf_isom_set_visual_bit_depth(dest, track, 1, bitdepth);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing bit depth\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (clr_type) {\\n\\t\\t\\t\\tif (clr_type==(u32)-1)\\n\\t\\t\\t\\t\\tclr_type = 0;\\n\\n\\t\\t\\t\\te = gf_isom_set_visual_color_info(dest, track, 1, clr_type, clr_prim, clr_tranf, clr_mx, clr_full_range, icc_data, icc_size);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing color info\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (hdr_file) {\\n\\t\\t\\t\\te = parse_high_dynamc_range_xml_desc(dest, track, hdr_file);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"setting HDR info\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (dv_profile[0]) {\\n\\t\\t\\t\\te = set_dv_profile(dest, track, dv_profile);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"setting DV profile\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (set_ccst) {\\n\\t\\t\\t\\te = gf_isom_set_image_sequence_coding_constraints(dest, track, 1, GF_FALSE, GF_FALSE, GF_TRUE, 15);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"setting image sequence constraints\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (has_mx) {\\n\\t\\t\\te = gf_isom_set_track_matrix(dest, track, mx);\\n\\t\\t\\tGOTO_EXIT(\\\"setting track matrix\\\")\\n\\t\\t}\\n\\t\\tif (use_stz2) {\\n\\t\\t\\te = gf_isom_use_compact_size(dest, track, GF_TRUE);\\n\\t\\t\\tGOTO_EXIT(\\\"setting compact size\\\")\\n\\t\\t}\\n\\n\\t\\tif (gf_isom_get_media_subtype(dest, track, 1) == GF_ISOM_MEDIA_TIMECODE) {\\n\\t\\t\\ttmcd_track = track;\\n\\t\\t}\\n\\t\\tif (rap_only || refs_only) {\\n\\t\\t\\te = gf_media_remove_non_rap(dest, track, refs_only);\\n\\t\\t\\tGOTO_EXIT(\\\"removing non RAPs\\\")\\n\\t\\t}\\n\\t\\tif (handler_name) {\\n\\t\\t\\te = gf_isom_set_handler_name(dest, track, handler_name);\\n\\t\\t\\tGOTO_EXIT(\\\"setting handler name\\\")\\n\\t\\t}\\n\\t\\telse if (!keep_handler) {\\n\\t\\t\\tchar szHName[1024];\\n\\t\\t\\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\\n\\t\\t\\tfName = strchr(fName, '.');\\n\\t\\t\\tif (fName) fName += 1;\\n\\t\\t\\telse fName = \\\"?\\\";\\n\\n\\t\\t\\tsprintf(szHName, \\\"%s@GPAC%s\\\", fName, gf_gpac_version());\\n\\t\\t\\te = gf_isom_set_handler_name(dest, track, szHName);\\n\\t\\t\\tGOTO_EXIT(\\\"setting handler name\\\")\\n\\t\\t}\\n\\t\\tif (handler) {\\n\\t\\t\\te = gf_isom_set_media_type(dest, track, handler);\\n\\t\\t\\tGOTO_EXIT(\\\"setting media type\\\")\\n\\t\\t}\\n\\t\\tif (group) {\\n\\t\\t\\te = gf_isom_set_alternate_group_id(dest, track, group);\\n\\t\\t\\tGOTO_EXIT(\\\"setting alternate group\\\")\\n\\t\\t}\\n\\n\\t\\tif (track_layout) {\\n\\t\\t\\te = gf_isom_set_track_layout_info(dest, track, tw<<16, th<<16, tx<<16, ty<<16, tz);\\n\\t\\t\\tGOTO_EXIT(\\\"setting track layout\\\")\\n\\t\\t}\\n\\t\\tif (stype) {\\n\\t\\t\\te = gf_isom_set_media_subtype(dest, track, 1, stype);\\n\\t\\t\\tGOTO_EXIT(\\\"setting media subtype\\\")\\n\\t\\t}\\n\\t\\tif (is_chap && chap_ref) {\\n\\t\\t\\te = set_chapter_track(dest, track, chap_ref);\\n\\t\\t\\tGOTO_EXIT(\\\"setting chapter track\\\")\\n\\t\\t}\\n\\n\\t\\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\\n\\t\\t\\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\\n\\t\\t\\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\\n\\t\\t\\te = gf_isom_add_track_kind(dest, i+1, kind_scheme, kind_value);\\n\\t\\t\\tGOTO_EXIT(\\\"setting track kind\\\")\\n\\t\\t}\\n\\n\\t\\tif (profile || compat || level) {\\n\\t\\t\\te = gf_media_change_pl(dest, track, profile, compat, level);\\n\\t\\t\\tGOTO_EXIT(\\\"changing video PL\\\")\\n\\t\\t}\\n\\t\\tif (gf_isom_get_mpeg4_subtype(dest, track, 1))\\n\\t\\t\\tkeep_sys_tracks = 1;\\n\\n\\t\\t//if moov timescale is <0 (auto mode) set it at import time\\n\\t\\tif (fake_import) {\\n\\t\\t\\tif (import_flags & GF_IMPORT_NO_EDIT_LIST)\\n\\t\\t\\t\\tgf_isom_remove_edits(dest, track);\\n\\n\\t\\t\\tif (moov_timescale<0) {\\n\\t\\t\\t\\tmoov_timescale = gf_isom_get_media_timescale(dest, track);\\n\\t\\t\\t}\\n\\t\\t\\tif (moov_timescale>0) {\\n\\t\\t\\t\\te = gf_isom_set_timescale(dest, moov_timescale);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing timescale\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (import.asemode && (media_type==GF_ISOM_MEDIA_AUDIO)) {\\n\\t\\t\\t\\tu32 sr, ch, bps;\\n\\t\\t\\t\\tgf_isom_get_audio_info(dest, track, 1, &sr, &ch, &bps);\\n\\t\\t\\t\\tgf_isom_set_audio_info(dest, track, 1, sr, ch, bps, import.asemode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (roll_change) {\\n\\t\\t\\tif ((roll_change!=3) || (media_type==GF_ISOM_MEDIA_AUDIO)) {\\n\\t\\t\\t\\te = gf_isom_set_sample_roll_group(dest, track, (u32) -1, (roll_change==2) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL, roll);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"assigning roll\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (new_timescale>1) {\\n\\t\\t\\te = gf_isom_set_media_timescale(dest, track, new_timescale, 0, 0);\\n\\t\\t\\tGOTO_EXIT(\\\"setting media timescale\\\")\\n\\t\\t}\\n\\n\\t\\tif (rescale_num > 1) {\\n\\t\\t\\tswitch (gf_isom_get_media_type(dest, track)) {\\n\\t\\t\\tcase GF_ISOM_MEDIA_AUDIO:\\n\\t\\t\\t\\tif (!rescale_override) {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Cannot force media timescale for audio media types - ignoring\\\\n\\\"));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\te = gf_isom_set_media_timescale(dest, track, rescale_num, rescale_den, rescale_override ? 2 : 1);\\n                if (e==GF_EOS) {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Rescale ignored, same config in source file\\\\n\\\"));\\n\\t\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tGOTO_EXIT(\\\"rescaling media track\\\")\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} else if (src_is_isom && force_fps.den && force_fps.num) {\\n\\t\\t\\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, track))) {\\n\\t\\t\\t\\te = gf_isom_set_media_timescale(dest, track, force_fps.num, force_fps.den, 2);\\n                if (e==GF_EOS) {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Rescale ignored, same config in source file\\\\n\\\"));\\n\\t\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Cannot force FPS for media types %s - ignoring\\\\n\\\", gf_4cc_to_str( gf_isom_get_media_type(dest, track)) ));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (has_last_sample_dur) {\\n\\t\\t\\te = gf_isom_set_last_sample_duration_ex(dest, track, last_sample_dur.num, last_sample_dur.den);\\n\\t\\t\\tGOTO_EXIT(\\\"setting last sample duration\\\")\\n\\t\\t}\\n\\t\\tif (rvc_config) {\\n#ifdef GPAC_DISABLE_ZLIB\\n\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Error: no zlib support - RVC not available\\\\n\\\"));\\n\\t\\t\\te = GF_NOT_SUPPORTED;\\n\\t\\t\\tgoto exit;\\n#else\\n\\t\\t\\tu8 *data;\\n\\t\\t\\tu32 size;\\n\\t\\t\\te = gf_file_load_data(rvc_config, (u8 **) &data, &size);\\n\\t\\t\\tGOTO_EXIT(\\\"loading RVC config file\\\")\\n\\n\\t\\t\\tgf_gz_compress_payload(&data, size, &size);\\n\\t\\t\\te |= gf_isom_set_rvc_config(dest, track, 1, 0, \\\"application/rvc-config+xml+gz\\\", data, size);\\n\\t\\t\\tgf_free(data);\\n\\t\\t\\tGOTO_EXIT(\\\"compressing and assigning RVC config\\\")\\n#endif\\n\\t\\t} else if (rvc_predefined>0) {\\n\\t\\t\\te = gf_isom_set_rvc_config(dest, track, 1, rvc_predefined, NULL, NULL, 0);\\n\\t\\t\\tGOTO_EXIT(\\\"setting RVC predefined config\\\")\\n\\t\\t}\\n\\n\\t\\tif (neg_ctts_mode) {\\n\\t\\t\\te = gf_isom_set_composition_offset_mode(dest, track, (neg_ctts_mode==1) ? GF_TRUE : GF_FALSE);\\n\\t\\t\\tGOTO_EXIT(\\\"setting composition offset mode\\\")\\n\\t\\t}\\n\\n\\t\\tif (gf_isom_get_avc_svc_type(dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\\n\\t\\t\\tcheck_track_for_svc = track;\\n\\n\\t\\tswitch (gf_isom_get_hevc_lhvc_type(dest, track, 1)) {\\n\\t\\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\\n\\t\\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\\n\\t\\t\\tcheck_track_for_lhvc = i+1;\\n\\t\\t\\tbreak;\\n\\t\\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\\n\\t\\t\\tcheck_track_for_hevc=1;\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (txt_flags) {\\n\\t\\t\\te = gf_isom_text_set_display_flags(dest, track, 0, txt_flags, txt_mode);\\n\\t\\t\\tGOTO_EXIT(\\\"setting text track display flags\\\")\\n\\t\\t}\\n\\n\\t\\tif (edits) {\\n\\t\\t\\te = apply_edits(dest, track, edits);\\n\\t\\t\\tGOTO_EXIT(\\\"applying edits\\\")\\n\\t\\t}\\n\\n\\t\\tif (force_rate>=0) {\\n\\t\\t\\te = gf_isom_update_bitrate(dest, i+1, 1, force_rate, force_rate, 0);\\n\\t\\t\\tGOTO_EXIT(\\\"updating bitrate\\\")\\n\\t\\t}\\n\\n\\t\\tif (split_tile_mode) {\\n\\t\\t\\tswitch (gf_isom_get_media_subtype(dest, track, 1)) {\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HVC1:\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HEV1:\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HVC2:\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HEV2:\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tsplit_tile_mode = 0;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ((dlb_mode>=-1) && (gf_isom_get_media_subtype(dest, track, 1)==GF_ISOM_SUBTYPE_EC3)) {\\n\\t\\t\\tGF_AC3Config *ac3c = gf_isom_ac3_config_get(dest, track, 1);\\n\\t\\t\\tif (ac3c) {\\n\\t\\t\\t\\tif (dlb_mode==0) {\\n\\t\\t\\t\\t\\tac3c->is_ec3 = GF_TRUE;\\n\\t\\t\\t\\t\\tac3c->atmos_ec3_ext=0;\\n\\t\\t\\t\\t\\tac3c->complexity_index_type=0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tu32 di;\\n\\t\\t\\t\\t\\tGF_ISOSample *samp = gf_isom_get_sample(dest, track, 1, &di);\\n\\t\\t\\t\\t\\tu32 pos;\\n\\t\\t\\t\\t\\tgf_eac3_parser(samp->data, samp->dataLength, &pos, ac3c, GF_TRUE);\\n\\n\\t\\t\\t\\t\\tif (dlb_mode>0) {\\n\\t\\t\\t\\t\\t\\tac3c->atmos_ec3_ext = 1;\\n\\t\\t\\t\\t\\t\\tac3c->complexity_index_type = dlb_mode;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgf_isom_ac3_config_update(dest, track, 1, ac3c);\\n\\t\\t\\t\\tgf_free(ac3c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (chapter_name) {\\n\\t\\tif (is_chap_file) {\\n\\t\\t\\tGF_Fraction a_fps = {0,0};\\n\\t\\t\\te = gf_media_import_chapters(dest, chapter_name, a_fps, GF_FALSE);\\n\\t\\t} else {\\n\\t\\t\\te = gf_isom_add_chapter(dest, 0, 0, chapter_name);\\n\\t\\t}\\n\\t\\tGOTO_EXIT(\\\"importing chapters\\\")\\n\\t}\\n\\n\\tif (tmcd_track) {\\n\\t\\tu32 tmcd_id = gf_isom_get_track_id(dest, tmcd_track);\\n\\t\\tfor (i=0; i < gf_isom_get_track_count(dest); i++) {\\n\\t\\t\\tswitch (gf_isom_get_media_type(dest, i+1)) {\\n\\t\\t\\tcase GF_ISOM_MEDIA_VISUAL:\\n\\t\\t\\tcase GF_ISOM_MEDIA_AUXV:\\n\\t\\t\\tcase GF_ISOM_MEDIA_PICT:\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\te = gf_isom_set_track_reference(dest, i+1, GF_ISOM_REF_TMCD, tmcd_id);\\n\\t\\t\\tGOTO_EXIT(\\\"assigning TMCD track references\\\")\\n\\t\\t}\\n\\t}\\n\\n\\t/*force to rewrite all dependencies*/\\n\\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\\n\\t{\\n\\t\\te = gf_isom_rewrite_track_dependencies(dest, i);\\n\\t\\tif (e) {\\n\\t\\t\\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\\\"Warning: track ID %d has references to a track not imported\\\\n\\\", gf_isom_get_track_id(dest, i) ));\\n\\t\\t\\te = GF_OK;\\n\\t\\t}\\n\\t}\\n\\n#ifndef GPAC_DISABLE_AV_PARSERS\\n\\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\\n\\t\\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\\n\\t\\t{\\n\\t\\t\\te = gf_media_filter_hevc(dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\\n\\t\\t\\tif (e) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning: track ID %d: error while filtering LHVC layers\\\\n\\\", gf_isom_get_track_id(dest, i)));\\n\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n#endif\\n\\n\\tif (check_track_for_svc) {\\n\\t\\tif (svc_mode) {\\n\\t\\t\\te = gf_media_split_svc(dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\\n\\t\\t\\tGOTO_EXIT(\\\"splitting SVC track\\\")\\n\\t\\t} else {\\n\\t\\t\\te = gf_media_merge_svc(dest, check_track_for_svc, 1);\\n\\t\\t\\tGOTO_EXIT(\\\"merging SVC/SHVC track\\\")\\n\\t\\t}\\n\\t}\\n#ifndef GPAC_DISABLE_AV_PARSERS\\n\\tif (check_track_for_lhvc) {\\n\\t\\tif (svc_mode) {\\n\\t\\t\\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\\n\\t\\t\\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\\n\\t\\t\\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\\n\\t\\t\\te = gf_media_split_lhvc(dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\\n\\t\\t\\tGOTO_EXIT(\\\"splitting L-HEVC track\\\")\\n\\t\\t} else {\\n\\t\\t\\t//TODO - merge, temporal sublayers\\n\\t\\t}\\n\\t}\\n#ifndef GPAC_DISABLE_HEVC\\n\\tif (check_track_for_hevc) {\\n\\t\\tif (split_tile_mode) {\\n\\t\\t\\te = gf_media_split_hevc_tiles(dest, split_tile_mode - 1);\\n\\t\\t\\tGOTO_EXIT(\\\"splitting HEVC tiles\\\")\\n\\t\\t}\\n\\t\\tif (temporal_mode) {\\n\\t\\t\\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\\n\\t\\t\\te = gf_media_split_lhvc(dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\\n\\t\\t\\tGOTO_EXIT(\\\"splitting HEVC temporal sublayers\\\")\\n\\t\\t}\\n\\t}\\n#endif\\n\\n\\tif (tc_fps_num) {\\n\\t\\tu32 desc_index=0;\\n\\t\\tu32 tmcd_tk, tmcd_id;\\n\\t\\tu32 video_ref = 0;\\n\\t\\tGF_BitStream *bs;\\n\\t\\tGF_ISOSample *samp;\\n\\t\\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\\n\\t\\t\\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, i+1))) {\\n\\t\\t\\t\\tvideo_ref = i+1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttmcd_tk = gf_isom_new_track(dest, 0, GF_ISOM_MEDIA_TIMECODE, tc_fps_num);\\n\\t\\tif (!tmcd_tk) {\\n\\t\\t\\te = gf_isom_last_error(dest);\\n\\t\\t\\tGOTO_EXIT(\\\"creating TMCD track\\\")\\n\\t\\t}\\n\\t\\te = gf_isom_set_track_enabled(dest, tmcd_tk, 1);\\n\\t\\tif (e != GF_OK) {\\n\\t\\t\\tGOTO_EXIT(\\\"enabling TMCD track\\\")\\n\\t\\t}\\n\\n\\t\\tif (!tc_frames_per_tick) {\\n\\t\\t\\ttc_frames_per_tick = tc_fps_num;\\n\\t\\t\\ttc_frames_per_tick /= tc_fps_den;\\n\\t\\t\\tif (tc_frames_per_tick * tc_fps_den < tc_fps_num)\\n\\t\\t\\t\\ttc_frames_per_tick++;\\n\\t\\t}\\n\\n\\t\\tu32 tmcd_value = (tc_h * 3600 + tc_m*60 + tc_s)*tc_frames_per_tick+tc_f;\\n\\t\\ttmcd_id = gf_isom_get_track_id(dest, tmcd_tk);\\n\\n\\t\\te = gf_isom_tmcd_config_new(dest, tmcd_tk, tc_fps_num, tc_fps_den, tc_frames_per_tick, tc_drop_frame, tc_force_counter, &desc_index);\\n\\t\\tGOTO_EXIT(\\\"configuring TMCD sample description\\\")\\n\\n\\t\\tif (video_ref) {\\n\\t\\t\\te = gf_isom_set_track_reference(dest, video_ref, GF_ISOM_REF_TMCD, tmcd_id);\\n\\t\\t\\tGOTO_EXIT(\\\"assigning TMCD track ref on video track\\\")\\n\\t\\t}\\n\\t\\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\\n\\t\\tgf_bs_write_u32(bs, tmcd_value);\\n\\t\\tsamp = gf_isom_sample_new();\\n\\t\\tsamp->IsRAP = SAP_TYPE_1;\\n\\t\\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\\n\\t\\tgf_bs_del(bs);\\n\\t\\te = gf_isom_add_sample(dest, tmcd_tk, desc_index, samp);\\n\\t\\tgf_isom_sample_del(&samp);\\n\\t\\tGOTO_EXIT(\\\"assigning TMCD sample\\\")\\n\\n\\t\\tif (video_ref) {\\n\\t\\t\\tu64 video_ref_dur = gf_isom_get_media_duration(dest, video_ref);\\n\\t\\t\\tvideo_ref_dur *= tc_fps_num;\\n\\t\\t\\tvideo_ref_dur /= gf_isom_get_media_timescale(dest, video_ref);\\n\\t\\t\\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, (u32) video_ref_dur);\\n\\t\\t} else {\\n\\t\\t\\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, tc_fps_den ? tc_fps_den : 1);\\n\\t\\t}\\n\\t\\tGOTO_EXIT(\\\"setting TMCD sample dur\\\")\\n\\t}\\n\\n#endif /*GPAC_DISABLE_AV_PARSERS*/\\n\\nexit:\\n\\twhile (gf_list_count(kinds)) {\\n\\t\\tchar *kind = (char *)gf_list_get(kinds, 0);\\n\\t\\tgf_list_rem(kinds, 0);\\n\\t\\tif (kind) gf_free(kind);\\n\\t}\\n\\tif (opt_src) opt_src[0] = ':';\\n\\tif (opt_dst) opt_dst[0] = ':';\\n\\tif (fchain) fchain[0] = ':';\\n\\tif (hdr_file) gf_free(hdr_file);\\n\\n\\tgf_list_del(kinds);\\n\\tif (handler_name) gf_free(handler_name);\\n\\tif (chapter_name ) gf_free(chapter_name);\\n\\tif (import.fontName) gf_free(import.fontName);\\n\\tif (import.streamFormat) gf_free(import.streamFormat);\\n\\tif (import.force_ext) gf_free(import.force_ext);\\n\\tif (rvc_config) gf_free(rvc_config);\\n\\tif (edits) gf_free(edits);\\n\\tif (szLan) gf_free((char *)szLan);\\n\\tif (icc_data) gf_free(icc_data);\\n\\tif (final_name) gf_free(final_name);\\n\\n\\tif (!e) return GF_OK;\\n\\tif (fail_msg) {\\n\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Failure while %s: %s\\\\n\\\", fail_msg, gf_error_to_string(e) ));\\n\\t}\\n\\treturn e;\\n}\\n\",\n            \"caller_start\": 622,\n            \"file_path\": \"applications/mp4box/fileimport.c\"\n          },\n          {\n            \"call_line\": 1273,\n            \"call_code\": \"gf_media_split_hevc_tiles(movie, 0)\",\n            \"caller_code\": \"static GF_Err gf_isom_iff_create_image_item_from_track_internal(GF_ISOFile *movie, Bool root_meta, u32 meta_track_number, u32 imported_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs, u32 sample_number) {\\n#ifndef GPAC_DISABLE_ISOM_WRITE\\n\\tGF_Err e;\\n\\tu32 w, h, hSpacing, vSpacing;\\n\\tu8 num_channels;\\n\\tu8 bits_per_channel[3];\\n\\tu32 subtype;\\n\\tGF_ISOSample *sample = NULL;\\n\\tu32 timescale;\\n\\tu32 item_type = 0;\\n\\tGF_ImageItemProperties local_image_props;\\n\\tGF_ImageItemProtection ipro, *orig_ipro = NULL;\\n\\tBool config_needed = 0;\\n\\tGF_Box *config_box = NULL;\\n\\tBool is_cenc = GF_FALSE;\\n\\tBool is_first = GF_TRUE;\\n\\tBool neg_time = (image_props && image_props->time<0) ? GF_TRUE : GF_FALSE;\\n\\tu8 *sai = NULL;\\n\\tu32 sai_size = 0, sai_alloc_size = 0;\\n\\tu32 sample_desc_index = 0;\\n\\tGF_ISOFile *fsrc = movie;\\n\\tBool reset_brands = GF_FALSE;\\n\\n\\t//only reset brands if first item import\\n\\tif (!gf_isom_get_meta_item_count(movie, root_meta, meta_track_number))\\n\\t\\treset_brands = GF_TRUE;\\n\\n\\tif (image_props && image_props->src_file)\\n\\t\\tfsrc = image_props->src_file;\\n\\n\\tif (image_props && image_props->tile_mode != TILE_ITEM_NONE) {\\n\\t\\t/* Processing the input file in Tiled mode:\\n\\t\\t   The single track is split into multiple tracks\\n\\t\\t   and each track is processed to create an item */\\n\\t\\tu32 i, count;\\n\\t\\tu32 tile_track;\\n\\t\\tGF_List *tile_item_ids;\\n\\t\\tchar sz_item_name[256];\\n\\t\\tGF_TileItemMode orig_tile_mode;\\n\\n#if !defined(GPAC_DISABLE_HEVC) && !defined(GPAC_DISABLE_AV_PARSERS)\\n\\t\\tif (image_props->src_file)\\n\\t\\t\\te = GF_SERVICE_ERROR;\\n\\t\\telse\\n\\t\\t\\te = gf_media_split_hevc_tiles(movie, 0);\\n#else\\n\\t\\te = GF_NOT_SUPPORTED;\\n#endif\\n\\n\\t\\tif (e) return e;\\n\\t\\ttile_item_ids = gf_list_new();\\n\\t\\torig_tile_mode = image_props->tile_mode;\\n\\t\\timage_props->tile_mode = TILE_ITEM_NONE;\\n\\t\\tcount = gf_isom_get_reference_count(movie, imported_track, GF_ISOM_REF_SABT);\\n\\t\\tfor (i = 0; i < count; i++) {\\n\\t\\t\\tu32 *tile_item_id = gf_malloc(sizeof(u32));\\n\\t\\t\\tif (!tile_item_id) return GF_OUT_OF_MEM;\\n\\n\\t\\t\\t*tile_item_id = item_id + i+1;\\n\\t\\t\\tgf_list_add(tile_item_ids, tile_item_id);\\n\\t\\t\\te = gf_isom_get_reference(movie, imported_track, GF_ISOM_REF_SABT, 1, &tile_track);\\n\\t\\t\\tif (e) return e;\\n\\t\\t\\tif (item_name)\\n\\t\\t\\t\\tsprintf(sz_item_name, \\\"%s-Tile%d\\\", item_name, i + 1);\\n\\t\\t\\tif (orig_tile_mode != TILE_ITEM_SINGLE || image_props->single_tile_number == i + 1) {\\n\\t\\t\\t\\te = gf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, tile_track, item_name ? sz_item_name : NULL, *tile_item_id, NULL, NULL);\\n\\t\\t\\t}\\n\\t\\t\\tif (e) return e;\\n\\t\\t\\tgf_isom_remove_track(movie, tile_track);\\n\\t\\t\\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\\n\\t\\t\\t\\te = gf_isom_meta_add_item_ref(movie, root_meta, meta_track_number, *tile_item_id, item_id, GF_ISOM_REF_TBAS, NULL);\\n\\t\\t\\t}\\n\\t\\t\\tif (e) return e;\\n\\t\\t}\\n\\t\\tif (item_name)\\n\\t\\t\\tsprintf(sz_item_name, \\\"%s-TileBase\\\", item_name);\\n\\t\\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\\n\\t\\t\\tgf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, imported_track, item_name ? sz_item_name : NULL, item_id, image_props, tile_item_ids);\\n\\t\\t}\\n\\t\\telse if (orig_tile_mode == TILE_ITEM_ALL_GRID) {\\n\\t\\t\\t// TODO\\n\\t\\t}\\n\\t\\tfor (i = 0; i < count; i++) {\\n\\t\\t\\tu32 *tile_item_id = gf_list_get(tile_item_ids, i);\\n\\t\\t\\tgf_free(tile_item_id);\\n\\t\\t}\\n\\t\\tgf_list_del(tile_item_ids);\\n\\t\\treturn GF_OK;\\n\\t}\\n\\n\\tif (!image_props) {\\n\\t\\timage_props = &local_image_props;\\n\\t\\tmemset(image_props, 0, sizeof(GF_ImageItemProperties));\\n\\t} else {\\n\\t\\torig_ipro = image_props->cenc_info;\\n\\t\\timage_props->cenc_info = NULL;\\n\\t}\\n\\n\\tif (!imported_track) {\\n\\t\\tGF_ImageItemProperties src_props;\\n\\t\\tu32 item_idx, ref_id;\\n\\t\\tu32 scheme_type=0, scheme_version=0;\\n\\t\\tconst char *orig_item_name, *orig_item_mime_type, *orig_item_encoding;\\n\\t\\tif (!image_props->item_ref_id) return GF_BAD_PARAM;\\n\\n\\t\\tif (gf_isom_meta_get_item_ref_count(fsrc, GF_TRUE, 0, image_props->item_ref_id, GF_4CC('d','i','m','g')) > 0) {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: Cannnot import derived image, only native image import is supported\\\\n\\\"));\\n\\t\\t\\treturn GF_NOT_SUPPORTED;\\n\\t\\t}\\n\\n\\t\\titem_idx = gf_isom_get_meta_item_by_id(fsrc, GF_TRUE, 0, image_props->item_ref_id);\\n\\t\\tif (!item_idx) {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: No item with ID %d, cannnot import\\\\n\\\", image_props->item_ref_id));\\n\\t\\t\\treturn GF_BAD_PARAM;\\n\\t\\t}\\n\\t\\torig_item_name = orig_item_mime_type = orig_item_encoding = NULL;\\n\\t\\tgf_isom_get_meta_item_info(fsrc, GF_TRUE, 0, item_idx, &ref_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &orig_item_name, &orig_item_mime_type, &orig_item_encoding);\\n\\n\\t\\tif (!ref_id) return GF_BAD_PARAM;\\n\\t\\tif (ref_id != image_props->item_ref_id) return GF_ISOM_INVALID_FILE;\\n\\n\\t\\tgf_isom_get_meta_image_props(fsrc, GF_TRUE, 0, ref_id, &src_props, NULL);\\n\\n\\t\\timage_props->config = src_props.config;\\n\\t\\timage_props->width = src_props.width;\\n\\t\\timage_props->height = src_props.height;\\n\\t\\timage_props->num_channels = src_props.num_channels;\\n\\t\\tmemcpy(image_props->av1_layer_size, src_props.av1_layer_size, sizeof(u32)*3);\\n\\t\\tmemcpy(image_props->bits_per_channel, src_props.bits_per_channel, sizeof(u32)*3);\\n\\t\\tif (!image_props->hSpacing && !image_props->vSpacing) {\\n\\t\\t\\timage_props->hSpacing = src_props.hSpacing;\\n\\t\\t\\timage_props->vSpacing = src_props.vSpacing;\\n\\t\\t}\\n\\t\\tif (image_props->copy_props) {\\n\\t\\t\\tif (!image_props->hOffset && !image_props->vOffset) {\\n\\t\\t\\t\\timage_props->hOffset = src_props.hOffset;\\n\\t\\t\\t\\timage_props->vOffset = src_props.vOffset;\\n\\t\\t\\t}\\n\\t\\t\\tif (!image_props->clap_wden) {\\n\\t\\t\\t\\timage_props->clap_wnum = src_props.clap_wnum;\\n\\t\\t\\t\\timage_props->clap_wden = src_props.clap_wden;\\n\\t\\t\\t\\timage_props->clap_hnum = src_props.clap_hnum;\\n\\t\\t\\t\\timage_props->clap_hden = src_props.clap_hden;\\n\\t\\t\\t\\timage_props->clap_honum = src_props.clap_honum;\\n\\t\\t\\t\\timage_props->clap_hoden = src_props.clap_hoden;\\n\\t\\t\\t\\timage_props->clap_vonum = src_props.clap_vonum;\\n\\t\\t\\t\\timage_props->clap_voden = src_props.clap_voden;\\n\\t\\t\\t}\\n\\t\\t\\tif (!image_props->alpha) image_props->alpha = src_props.alpha;\\n\\t\\t\\tif (!image_props->depth) image_props->depth = src_props.depth;\\n\\t\\t\\tif (!image_props->hidden) image_props->hidden = src_props.hidden;\\n\\t\\t\\tif (!image_props->angle) image_props->angle = src_props.angle;\\n\\t\\t\\tif (!image_props->mirror) image_props->mirror = src_props.mirror;\\n\\t\\t\\tif (!image_props->av1_op_index) image_props->av1_op_index = src_props.av1_op_index;\\n\\t\\t}\\n\\t\\tif (!item_name) item_name = orig_item_name;\\n\\n\\t\\tif (!image_props->use_reference || (fsrc == image_props->src_file)) {\\n\\t\\t\\tu8 *data = NULL;\\n\\t\\t\\tu32 size=0;\\n\\t\\t\\te = gf_isom_extract_meta_item_mem(fsrc, GF_TRUE, 0, ref_id, &data, &size, &size, NULL, GF_FALSE);\\n\\t\\t\\tif (e) return GF_BAD_PARAM;\\n\\n\\t\\t\\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, data, size, NULL);\\n\\t\\t\\tif (data) gf_free(data);\\n\\t\\t} else {\\n\\t\\t\\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, 0, ref_id);\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\nimport_next_sample:\\n\\n\\ttimescale = gf_isom_get_media_timescale(fsrc, imported_track);\\n\\tif (image_props->sample_num) {\\n\\t\\tsample_number = image_props->sample_num;\\n\\t\\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\\n\\t\\te = gf_isom_last_error(fsrc);\\n\\t} else if (image_props->time<0) {\\n\\t\\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\\n\\t\\te = gf_isom_last_error(fsrc);\\n\\t} else {\\n\\t\\te = gf_isom_get_sample_for_media_time(fsrc, imported_track, (u64)(image_props->time*timescale), &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &sample, &sample_number, NULL);\\n\\t}\\n\\tif (e || !sample || !sample->IsRAP) {\\n\\t\\tif (!sample) {\\n\\t\\t\\tif (is_first) {\\n\\t\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"No sample found%s\\\\n\\\", (image_props->time<0) ? \\\"\\\" : \\\" for requested time\\\"));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t}\\n\\t\\t} else if ((image_props->time<0) || (image_props->step_time)) {\\n\\t\\t\\tif (image_props->sample_num) {\\n\\t\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: imported sample %d (DTS \\\"LLU\\\") is not a sync sample (RAP %d size %d)\\\\n\\\", sample_number, sample->DTS, sample->IsRAP, sample->dataLength));\\n\\t\\t\\t} else if (image_props->step_time) {\\n\\t\\t\\t\\tgf_isom_sample_del(&sample);\\n\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgf_isom_sample_del(&sample);\\n\\t\\t\\t\\tsample_number++;\\n\\t\\t\\t\\tif (sample_number == gf_isom_get_sample_count(fsrc, imported_track)) {\\n\\t\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgoto import_next_sample;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error no sync sample found after time %g\\\\n\\\", image_props->time));\\n\\t\\t}\\n\\t\\tif (!e) e = GF_BAD_PARAM;\\n\\t\\tgoto exit;\\n\\t}\\n\\n\\t/* Check if the track type is supported as item type */\\n\\t/* Get the config box if needed */\\n\\tsubtype = gf_isom_get_media_subtype(fsrc, imported_track, sample_desc_index);\\n\\tif (gf_isom_is_media_encrypted(fsrc, imported_track, sample_desc_index)) {\\n\\t\\tif (gf_isom_is_cenc_media(fsrc, imported_track, sample_desc_index)) {\\n\\t\\t\\te = gf_isom_get_original_format_type(fsrc, imported_track, sample_desc_index, &subtype);\\n\\t\\t\\tif (e) goto exit;\\n\\t\\t\\tis_cenc = GF_TRUE;\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Protected sample not using CENC, cannot add as item\\\\n\\\"));\\n\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\tgoto exit;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tswitch (subtype) {\\n\\tcase GF_ISOM_SUBTYPE_AVC_H264:\\n\\tcase GF_ISOM_SUBTYPE_AVC2_H264:\\n\\tcase GF_ISOM_SUBTYPE_AVC3_H264:\\n\\tcase GF_ISOM_SUBTYPE_AVC4_H264:\\n\\t\\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_avc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_SVC_H264:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_svc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_MVC_H264:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_mvc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_HVC1:\\n\\tcase GF_ISOM_SUBTYPE_HEV1:\\n\\tcase GF_ISOM_SUBTYPE_HVC2:\\n\\tcase GF_ISOM_SUBTYPE_HEV2:\\n\\tcase GF_ISOM_SUBTYPE_HVT1:\\n\\tcase GF_ISOM_SUBTYPE_LHV1:\\n\\tcase GF_ISOM_SUBTYPE_LHE1:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_hevc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\tif (subtype == GF_ISOM_SUBTYPE_HVT1) {\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_HVT1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_HVC1;\\n\\t\\t}\\n\\t\\tconfig_needed = 1;\\n\\t\\tif (!((GF_HEVCConfigurationBox *)config_box)->config) {\\n\\t\\t\\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_lhvc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\t\\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_LHV1;\\n\\t\\t}\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\t//media_brand = GF_ISOM_BRAND_HEIC;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_AV01:\\n\\t\\t{\\n\\t\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\\n\\t\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t\\t((GF_AV1ConfigurationBox *)config_box)->config = gf_isom_av1_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\t\\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_AV01;\\n\\t\\t\\tconfig_needed = 1;\\n\\t\\t\\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\\n\\t\\t\\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\\n\\t\\t\\t\\tnum_channels = 1;\\n\\t\\t\\t\\tbits_per_channel[0] = depth;\\n\\t\\t\\t\\tbits_per_channel[1] = 0;\\n\\t\\t\\t\\tbits_per_channel[2] = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnum_channels = 3;\\n\\t\\t\\t\\tbits_per_channel[0] = depth;\\n\\t\\t\\t\\tbits_per_channel[1] = depth;\\n\\t\\t\\t\\tbits_per_channel[2] = depth;\\n\\t\\t\\t}\\n\\t\\t\\t// presence of OBU SH in config is not recommended and properties should be used instead of metadata OBUs\\n\\t\\t\\twhile (gf_list_count(((GF_AV1ConfigurationBox *)config_box)->config->obu_array)) {\\n\\t\\t\\t\\tGF_AV1_OBUArrayEntry *obu = gf_list_pop_back(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\\n\\t\\t\\t\\tif (obu) {\\n\\t\\t\\t\\t\\tif (obu->obu) gf_free(obu->obu);\\n\\t\\t\\t\\t\\tgf_free(obu);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tgf_list_del(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\\n\\t\\t\\t((GF_AV1ConfigurationBox *)config_box)->config->obu_array = NULL;\\n\\t\\t\\te = gf_media_av1_layer_size_get(fsrc, imported_track, sample_number, image_props->av1_op_index, image_props->av1_layer_size);\\n      if (e) {\\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"AV1 operating point index out of range for stream\\\\n\\\"));\\n        goto exit;\\n      }\\n\\t\\t\\t//media_brand = GF_ISOM_BRAND_AVIF;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase GF_ISOM_SUBTYPE_VVC1:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_VVCConfigurationBox *)config_box)->config = gf_isom_vvc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_VVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_VVC1;\\n\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\\n\\t\\tbits_per_channel[1] = bits_per_channel[2] = bits_per_channel[0];\\n\\t\\t//media_brand = GF_ISOM_BRAND_HEIC;\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: Codec not supported to create HEIF image items\\\\n\\\"));\\n\\t\\te = GF_NOT_SUPPORTED;\\n\\t\\tgoto exit;\\n\\t}\\n\\tif (config_needed && !config_box && !((GF_AVCConfigurationBox *)config_box)->config) {\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: Image type %s requires a missing configuration box\\\\n\\\", gf_4cc_to_str(item_type)));\\n\\t\\te = GF_BAD_PARAM;\\n\\t\\tgoto exit;\\n\\t}\\n\\t/* Get some images properties from the track data */\\n\\te = gf_isom_get_visual_info(fsrc, imported_track, sample_desc_index, &w, &h);\\n\\tif (e) {\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error determining image size\\\\n\\\"));\\n\\t\\tgoto exit;\\n\\t}\\n\\te = gf_isom_get_pixel_aspect_ratio(fsrc, imported_track, sample_desc_index, &hSpacing, &vSpacing);\\n\\tif (e) {\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error determining image aspect ratio\\\\n\\\"));\\n\\t\\tgoto exit;\\n\\t}\\n\\tif (!image_props->width && !image_props->height) {\\n\\t\\timage_props->width = w;\\n\\t\\timage_props->height = h;\\n\\t}\\n\\tif (!image_props->hSpacing && !image_props->vSpacing) {\\n\\t\\timage_props->hSpacing = hSpacing;\\n\\t\\timage_props->vSpacing = vSpacing;\\n\\t}\\n\\timage_props->config = config_box;\\n\\tif (!image_props->num_channels) {\\n\\t\\timage_props->num_channels = num_channels;\\n\\t\\timage_props->bits_per_channel[0] = bits_per_channel[0];\\n\\t\\timage_props->bits_per_channel[1] = bits_per_channel[1];\\n\\t\\timage_props->bits_per_channel[2] = bits_per_channel[2];\\n\\t}\\n\\tif (is_cenc) {\\n\\t\\tBool Is_Encrypted;\\n\\n\\t\\tmemset(&ipro, 0, sizeof(GF_ImageItemProtection));\\n\\t\\tgf_isom_get_cenc_info(fsrc, imported_track, sample_desc_index, NULL, &ipro.scheme_type, &ipro.scheme_version);\\n\\t\\te = gf_isom_get_sample_cenc_info(fsrc, imported_track, sample_desc_index, &Is_Encrypted, &ipro.crypt_byte_block, &ipro.skip_byte_block, &ipro.key_info, &ipro.key_info_size);\\n\\t\\tif (e) goto exit;\\n\\n\\t\\tif (Is_Encrypted) {\\n\\t\\t\\tsai_size = sai_alloc_size;\\n\\t\\t\\te = gf_isom_cenc_get_sample_aux_info(fsrc, imported_track, sample_number, sample_desc_index, NULL, &sai, &sai_size);\\n\\t\\t\\tif (e) goto exit;\\n\\n\\t\\t\\tif (sai_size > sai_alloc_size)\\n\\t\\t\\t\\tsai_alloc_size = sai_size;\\n\\n\\t\\t\\tipro.sai_data = sai;\\n\\t\\t\\tipro.sai_data_size = sai_size;\\n\\t\\t\\timage_props->cenc_info = &ipro;\\n\\n\\t\\t\\tif (is_first) {\\n\\t\\t\\t\\tu32 i, nb_pssh = gf_isom_get_pssh_count(fsrc);\\n\\t\\t\\t\\tfor (i=0; i<nb_pssh; i++) {\\n\\t\\t\\t\\t\\tbin128 SystemID;\\n\\t\\t\\t\\t\\tu32 version;\\n\\t\\t\\t\\t\\tu32 KID_count;\\n\\t\\t\\t\\t\\tconst bin128 *KIDs;\\n\\t\\t\\t\\t\\tconst u8 *private_data;\\n\\t\\t\\t\\t\\tu32 private_data_size;\\n\\n\\t\\t\\t\\t\\tgf_isom_get_pssh_info(fsrc, i+1, SystemID, &version, &KID_count, &KIDs, &private_data, &private_data_size);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tgf_cenc_set_pssh(movie, SystemID, version, KID_count, (bin128 *) KIDs, (u8 *) private_data, private_data_size, 2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\timage_props->cenc_info = NULL;\\n\\t\\t}\\n\\t}\\n\\tif (!item_id) {\\n\\t\\te = gf_isom_meta_get_next_item_id(movie, root_meta, meta_track_number, &item_id);\\n\\t\\tif (e) goto exit;\\n\\t}\\n\\tif (image_props->use_reference) {\\n\\t\\tif (image_props->sample_num) {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"referring trackID %d sample %d as item %d\\\\n\\\", imported_track, sample_number, item_id));\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"referring trackID %d sample at time %.3f as item %d\\\\n\\\", imported_track, (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\\n\\t\\t}\\n\\t\\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, imported_track, sample_number);\\n\\t} else {\\n\\n\\t\\tif (image_props->sample_num) {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"Adding sample %d as item %d\\\\n\\\", sample_number, item_id));\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"Adding sample at time %.3f as item %d\\\\n\\\", (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\\n\\t\\t}\\n\\t\\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, sample->data, sample->dataLength, item_extent_refs);\\n\\t}\\n\\n\\timage_props->cenc_info = NULL;\\n\\n\\tif (reset_brands) {\\n\\t\\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MIF1, 0);\\n\\t\\tgf_isom_reset_alt_brands(movie);\\n\\n\\t\\t// TODO Analyze configuration to determine the brand */\\n\\t\\t//if (media_brand) {\\n\\t\\t//\\tgf_isom_modify_alternate_brand(movie, media_brand, GF_TRUE);\\n\\t\\t//}\\n\\t}\\n\\n\\t\\n\\tif (neg_time)\\n\\t\\timage_props->time = -1;\\n\\n\\tif (!e && !image_props->sample_num && ((image_props->time<0) || image_props->end_time || image_props->step_time)) {\\n\\t\\tif (image_props->end_time || image_props->step_time) {\\n\\t\\t\\tDouble t = (Double) (sample->DTS + sample->CTS_Offset);\\n\\t\\t\\tt /= timescale;\\n\\t\\t\\tif (image_props->step_time) {\\n\\t\\t\\t\\tt += image_props->step_time;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t//step 1ms\\n\\t\\t\\t\\tt += 0.001;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ((image_props->end_time>0) && (t>image_props->end_time)) {\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t}\\n\\t\\t\\timage_props->time = t;\\n\\t\\t}\\n\\n\\t\\titem_id=0;\\n\\t\\tgf_isom_sample_del(&sample);\\n\\t\\tif (config_box) {\\n\\t\\t\\tgf_isom_box_del(config_box);\\n\\t\\t\\tconfig_box = NULL;\\n\\t\\t}\\n\\t\\tis_first = GF_FALSE;\\n\\t\\tif (sample_number >= gf_isom_get_sample_count(fsrc, imported_track)) return e;\\n\\t\\tsample_number++;\\n\\t\\t//avoid recursion this could get quite big\\n\\t\\tgoto import_next_sample;\\n\\t}\\n\\nexit:\\n\\tif (sai) gf_free(sai);\\n\\tgf_isom_sample_del(&sample);\\n\\tif (config_box) gf_isom_box_del(config_box);\\n\\timage_props->cenc_info = orig_ipro;\\n\\treturn e;\\n\\n\\n#else\\n\\treturn GF_NOT_SUPPORTED;\\n#endif\\n\\n}\\n\",\n            \"caller_start\": 1229,\n            \"file_path\": \"src/isomedia/iff.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"func_info(func:gf_isom_get_sample)\",\n        \"result\": [\n          {\n            \"code\": \"GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\\n{\\n\\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\\n}\",\n            \"start_line\": 1934,\n            \"end_line\": 1937,\n            \"full_name\": \"gf_isom_get_sample\",\n            \"file_path\": \"src/isomedia/isom_read.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence* ≥ 0.90.  Incomplete chain ≤ 0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth** – Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The patch in `isom_tools.c:3544` prevents a null dereference in `gf_media_split_hevc_tiles` by checking `sample` after `gf_isom_get_sample`. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) remains unexplained. The current chain shows `gf_media_split_hevc_tiles` calls `gf_isom_get_sample`, which may trigger `Media_GetSample`. The gap lies in the unprovided code for `Media_GetSample` and its interaction with `gf_isom_get_sample`, which is necessary to trace the recursion cycle.",
                "need_context": true,
                "required_context": [
                    "function: Media_GetSample in isomedia/media.c",
                    "caller: callers of Media_GetSample in isomedia/media.c"
                ],
                "root_cause": "In `gf_media_split_hevc_tiles` (isom_tools.c:3544), `gf_isom_get_sample` may return null, leading to uninitialized `sample->data`/`sample->dataLength` access. The patch adds a null check to prevent this. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly addressed here. GAP: Missing code for `Media_GetSample` and its callers to trace the recursion.",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-29T22:16:16.948878"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: Media_GetSample in isomedia/media.c",
                "caller: callers of Media_GetSample in isomedia/media.c"
            ],
            "results": [
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'Media_GetSample', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n",
                            "start_line": 467,
                            "end_line": 680,
                            "full_name": "Media_GetSample",
                            "file_path": "src/isomedia/media.c"
                        }
                    ]
                },
                {
                    "tool": "caller_info.find_caller_for_func_file({'file_path': 'isomedia/media.c', 'func_name': 'Media_GetSample', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 182,
                            "call_code": "Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL)",
                            "caller_code": "static GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, u32 extractor_mode)\n{\n\tGF_Err e;\n\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *ref_trak;\n\ts8 sample_offset;\n\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\n\tBool header_written = GF_FALSE;\n\tnb_bytes_nalh = is_hevc ? 2 : 1;\n\n\tswitch (extractor_mode) {\n\tcase 0:\n\t\tlast_byte = (u32) gf_bs_get_position(mdia->nalu_parser) + nal_size - (is_hevc ? 2 : 1);\n\t\tif (!is_hevc) gf_bs_read_int(mdia->nalu_parser, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\n\t\twhile (gf_bs_get_position(mdia->nalu_parser) < last_byte) {\n\t\t\tu32 xmode = 0;\n\t\t\t//hevc extractors use constructors\n\t\t\tif (is_hevc) xmode = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tif (xmode) {\n\t\t\t\tu8 done=0, len = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\twhile (done<len) {\n\t\t\t\t\tu8 c = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\t\t\tdone++;\n\t\t\t\t\tif (header_written) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t} else if (done==nal_unit_size_field) {\n\t\t\t\t\t\tif (rewrite_start_codes) {\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theader_written = GF_TRUE;\n\t\t\t\t\t} else if (!rewrite_start_codes) {\n\t\t\t\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tref_track_index = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tsample_offset = (s8) gf_bs_read_int(mdia->nalu_parser, 8);\n\t\t\tdata_offset = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\t\t\tdata_length = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\n\n\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\n\t\t\tref_track_num = 0;\n\t\t\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\n\t\t\t\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\n\n\t\t\tif (!ref_track_num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"ISOBMF: Extractor target track is not present in file - skipping.\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\n\n\t\t\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\n\t\t\t//and this will corrupt extraction (wrong data offsets)\n\t\t\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\n\n\t\t\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\n\t\t\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\n\n\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\tif (!mdia->extracted_samp) return GF_IO_ERR;\n\t\t\t}\n\t\t\tif (!mdia->extracted_bs) {\n\t\t\t\tmdia->extracted_bs = gf_bs_new(\"a\", 1, GF_BITSTREAM_READ);\n\t\t\t\tif (!mdia->extracted_bs) return GF_IO_ERR;\n\t\t\t}\n\n\t\t\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\n\t\t\tif (e) return e;\n\t\t\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\n\t\t\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\n\t\t\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\n\t\t\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\n\n\t\t\te = Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL);\n\t\t\tif (e) return e;\n\t\t\tif (!mdia->extracted_samp->alloc_size)\n\t\t\t\tmdia->extracted_samp->alloc_size = mdia->extracted_samp->dataLength;\n#if 0\n\t\t\tif (!header_written && rewrite_start_codes) {\n\t\t\t\tgf_bs_write_int(dst_bs, 1, 32);\n\t\t\t\tif (is_hevc) {\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 1);\n\t\t\t\t\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 9);\n\t\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\t\tgf_bs_write_int(dst_bs, 2, 3);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0, 5);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\t\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_bs_reassign_buffer(mdia->extracted_bs, mdia->extracted_samp->data + data_offset, mdia->extracted_samp->dataLength - data_offset);\n\n\t\t\tif (mdia->extracted_samp->dataLength - data_offset >= data_length) {\n\n\t\t\t\twhile (data_length && gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);\n\n\t\t\t\t\t\tassert(data_length>nal_unit_size_field);\n\t\t\t\t\t\tdata_length -= nal_unit_size_field;\n\t\t\t\t\t\tif (data_length > gf_bs_available(mdia->extracted_bs)) {\n\t\t\t\t\t\t\tdata_length = (u32)gf_bs_available(mdia->extracted_bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref_nalu_size = data_length;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ref_nalu_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer_alloc = ref_nalu_size;\n\t\t\t\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * ref_nalu_size );\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_data(mdia->extracted_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\n\t\t\t\t\tif (!header_written) {\n\t\t\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, ref_nalu_size, 8*nal_unit_size_field);\n\t\t\t\t\t}\n\t\t\t\t\tassert(data_length >= ref_nalu_size);\n\t\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\n\t\t\t\t\tdata_length -= ref_nalu_size;\n\n\t\t\t\t\theader_written = GF_FALSE;\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"ISOBMF: Extractor size is larger than referred sample size - skipping.\\n\"));\n\t\t\t}\n\t\t\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\n\n\t\t\tif (!is_hevc) break;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t//skip to end of this NALU\n\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\tcase 2:\n\t\tif (nal_size - nb_bytes_nalh > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size - nb_bytes_nalh;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * (nal_size - nb_bytes_nalh) );\n\t\t}\n\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tif (rewrite_start_codes)\n\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\telse\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n",
                            "caller_start": 101,
                            "file_path": "src/isomedia/avc_ext.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 1916,
                            "call_code": "Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset)",
                            "caller_code": "GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n",
                            "caller_start": 1891,
                            "file_path": "src/isomedia/isom_read.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 2069,
                            "call_code": "Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset)",
                            "caller_code": "GF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}",
                            "caller_start": 2049,
                            "file_path": "src/isomedia/isom_read.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 2266,
                            "call_code": "Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset)",
                            "caller_code": "GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n",
                            "caller_start": 2142,
                            "file_path": "src/isomedia/isom_read.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-29T22:16:28.332402"
        },
        {
            "stage": "analysis",
            "iteration": 2,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: fixed #2359\n- **Vulnerability Description**: GPAC MP4Box 2.1-DEV-rev649-ga8f438d20 has a segment fault (/stack overflow) due to infinite recursion in Media_GetSample isomedia/media.c:662\n- **Patch Code**: [{'func_name': 'gf_media_split_hevc_tiles', 'patch': '--- func_before\\n+++ func_after\\n@@ -3544,6 +3544,10 @@\\n \\t\\tu32 size, nb_nalus=0, nb_nal_entries=0, last_tile_group=(u32) -1;\\n \\t\\tGF_BitStream *bs=NULL;\\n \\t\\tGF_ISOSample *sample = gf_isom_get_sample(file, track, i+1, &di);\\n+\\t\\tif (!sample) {\\n+\\t\\t\\te = gf_isom_last_error(file);\\n+\\t\\t\\tgoto err_exit;\\n+\\t\\t}\\n \\n \\t\\tdata = (u8 *) sample->data;\\n \\t\\tsize = sample->dataLength;', 'file_path': 'src/media_tools/isom_tools.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a null check for `sample` after calling `gf_isom_get_sample` in `isom_tools.c:3544`, preventing dereference of a null pointer which would cause a segmentation fault. If `sample` is null, it retrieves the error and exits via `err_exit`.\",\n      \"required_context\": [\n        \"caller: gf_media_split_hevc_tiles\",\n        \"function: gf_isom_get_sample\"\n      ],\n      \"root_cause\": \"In `gf_media_split_hevc_tiles` (isom_tools.c:3544), `gf_isom_get_sample` may return null, leading to uninitialized `sample->data`/`sample->dataLength` access. The patch adds a null check to prevent this. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly addressed here. GAP: Missing link between `gf_media_split_hevc_tiles` and `Media_GetSample` logic.\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:gf_media_split_hevc_tiles)\",\n        \"result\": [\n          {\n            \"call_line\": 1912,\n            \"call_code\": \"gf_media_split_hevc_tiles(dest, split_tile_mode - 1)\",\n            \"caller_code\": \"GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, GF_Fraction force_fps, u32 frames_per_sample, GF_FilterSession *fsess, char **mux_args_if_first_pass, char **mux_sid_if_first_pass, u32 tk_idx)\\n{\\n\\tu32 track_id, i, j, timescale, track, stype, profile, compat, level, new_timescale, rescale_num, rescale_den, svc_mode, txt_flags, split_tile_mode, temporal_mode, nb_tracks;\\n\\ts32 par_d, par_n, prog_id, force_rate, moov_timescale;\\n\\ts32 tw, th, tx, ty, tz, txtw, txth, txtx, txty;\\n\\tBool do_audio, do_video, do_auxv,do_pict, do_all, track_layout, text_layout, chap_ref, is_chap, is_chap_file, keep_handler, rap_only, refs_only, force_par, rewrite_bs;\\n\\tu32 group, handler, rvc_predefined, check_track_for_svc, check_track_for_lhvc, check_track_for_hevc, do_disable;\\n\\tconst char *szLan;\\n\\tGF_Err e = GF_OK;\\n\\tGF_Fraction delay;\\n\\tu32 tmcd_track = 0, neg_ctts_mode=0;\\n\\tBool keep_audelim = GF_FALSE;\\n\\tu32 print_stats_graph=fs_dump_flags;\\n\\tGF_MediaImporter import;\\n\\tchar *ext, *final_name=NULL, *handler_name, *rvc_config, *chapter_name;\\n\\tGF_List *kinds;\\n\\tGF_TextFlagsMode txt_mode = GF_ISOM_TEXT_FLAGS_OVERWRITE;\\n\\tu8 max_layer_id_plus_one, max_temporal_id_plus_one;\\n\\tu32 clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod;\\n\\tBool has_clap=GF_FALSE;\\n\\tBool use_stz2=GF_FALSE;\\n\\tBool has_mx=GF_FALSE;\\n\\ts32 mx[9];\\n\\tu32 bitdepth=0;\\n\\tchar dv_profile[100]; /*Dolby Vision*/\\n\\tu32 clr_type=0;\\n\\tu32 clr_prim;\\n\\tu32 clr_tranf;\\n\\tu32 clr_mx;\\n\\tBool rescale_override=GF_FALSE;\\n\\tBool clr_full_range=GF_FALSE;\\n\\tBool fmt_ok = GF_TRUE;\\n\\tu32 icc_size=0, track_flags=0;\\n\\tu8 *icc_data = NULL;\\n\\tu32 tc_fps_num=0, tc_fps_den=0, tc_h=0, tc_m=0, tc_s=0, tc_f=0, tc_frames_per_tick=0;\\n\\tBool tc_force_counter=GF_FALSE;\\n\\tBool tc_drop_frame = GF_FALSE;\\n\\tchar *ext_start;\\n\\tu32 xps_inband=0;\\n\\tu64 source_magic=0;\\n\\tchar *opt_src = NULL;\\n\\tchar *opt_dst = NULL;\\n\\tchar *fchain = NULL;\\n\\tchar *edits = NULL;\\n\\tconst char *fail_msg = NULL;\\n\\tchar *hdr_file=NULL;\\n\\tBool set_ccst=GF_FALSE;\\n\\tBool has_last_sample_dur=GF_FALSE;\\n\\tu32 fake_import = 0;\\n\\tGF_Fraction last_sample_dur = {0,0};\\n\\ts32 fullrange, videofmt, colorprim, colortfc, colormx;\\n\\tclap_wn = clap_wd = clap_hn = clap_hd = clap_hon = clap_hod = clap_von = clap_vod = 0;\\n\\tGF_ISOMTrackFlagOp track_flags_mode=0;\\n\\tu32 roll_change=0;\\n\\ts32 roll = 0;\\n\\tBool src_is_isom = GF_FALSE;\\n\\ts32 dlb_mode = -2;\\n\\n\\tdv_profile[0] = 0;\\n\\trvc_predefined = 0;\\n\\tchapter_name = NULL;\\n\\tnew_timescale = 1;\\n\\tmoov_timescale = 0;\\n\\trescale_num = rescale_den = 0;\\n\\ttext_layout = 0;\\n\\t/*0: merge all\\n\\t  1: split base and all SVC in two tracks\\n\\t  2: split all base and SVC layers in dedicated tracks\\n\\t */\\n\\tsvc_mode = 0;\\n\\n\\tif (import_flags==0xFFFFFFFF) {\\n\\t\\timport_flags = 0;\\n\\t\\tfake_import = 1;\\n\\t}\\n\\n\\tmemset(&import, 0, sizeof(GF_MediaImporter));\\n\\n\\tfinal_name = gf_strdup(inName);\\n#ifdef WIN32\\n\\t/*dirty hack for msys&mingw: when we use import options, the ':' separator used prevents msys from translating the path\\n\\twe do this for regular cases where the path starts with the drive letter. If the path start with anything else (/home , /opt, ...) we're screwed :( */\\n\\tif ( (final_name[0]=='/') && (final_name[2]=='/')) {\\n\\t\\tfinal_name[0] = final_name[1];\\n\\t\\tfinal_name[1] = ':';\\n\\t}\\n#endif\\n\\n\\tis_chap_file = 0;\\n\\thandler = 0;\\n\\tdo_disable = 0;\\n\\tchap_ref = 0;\\n\\tis_chap = 0;\\n\\tkinds = gf_list_new();\\n\\ttrack_layout = 0;\\n\\tszLan = NULL;\\n\\tdelay.num = delay.den = 0;\\n\\tgroup = 0;\\n\\tstype = 0;\\n\\tprofile = compat = level = 0;\\n\\tfullrange = videofmt = colorprim = colortfc = colormx = -1;\\n\\tsplit_tile_mode = 0;\\n\\ttemporal_mode = 0;\\n\\trap_only = 0;\\n\\trefs_only = 0;\\n\\ttxt_flags = 0;\\n\\tmax_layer_id_plus_one = max_temporal_id_plus_one = 0;\\n\\tforce_rate = -1;\\n\\n\\ttw = th = tx = ty = tz = txtw = txth = txtx = txty = 0;\\n\\tpar_d = par_n = -1;\\n\\tforce_par = rewrite_bs = GF_FALSE;\\n\\n\\text_start = gf_file_ext_start(final_name);\\n\\text = strrchr(ext_start ? ext_start : final_name, '#');\\n\\tif (!ext) ext = gf_url_colon_suffix(final_name, '=');\\n\\tchar c_sep = ext ? ext[0] : 0;\\n\\tif (ext) ext[0] = 0;\\n \\tif (!strlen(final_name) || !strcmp(final_name, \\\"self\\\")) {\\n\\t\\tfake_import = 2;\\n\\t\\tsrc_is_isom = GF_TRUE;\\n\\t}\\n\\tchar *frag = strrchr(final_name, '#');\\n\\tif (frag) frag[0] = 0;\\n\\tif (gf_isom_probe_file(final_name))\\n\\t\\tsrc_is_isom = GF_TRUE;\\n\\tif (frag) frag[0] = '#';\\n\\n\\tif (ext) ext[0] = c_sep;\\n\\n\\text = gf_url_colon_suffix(final_name, '=');\\n\\n#define GOTO_EXIT(_msg) if (e) { fail_msg = _msg; goto exit; }\\n\\n#define CHECK_FAKEIMPORT(_opt) if (fake_import) { M4_LOG(GF_LOG_ERROR, (\\\"Option %s not available for self-reference import\\\\n\\\", _opt)); e = GF_BAD_PARAM; goto exit; }\\n#define CHECK_FAKEIMPORT_2(_opt) if (fake_import==1) { M4_LOG(GF_LOG_ERROR, (\\\"Option %s not available for self-reference import\\\\n\\\", _opt)); e = GF_BAD_PARAM; goto exit; }\\n\\n\\n\\thandler_name = NULL;\\n\\trvc_config = NULL;\\n\\twhile (ext) {\\n\\t\\tchar *ext2 = gf_url_colon_suffix(ext+1, '=');\\n\\n\\t\\tif (ext2) ext2[0] = 0;\\n\\n\\t\\t/*all extensions for track-based importing*/\\n\\t\\tif (!strnicmp(ext+1, \\\"dur=\\\", 4)) {\\n\\t\\t\\tCHECK_FAKEIMPORT(\\\"dur\\\")\\n\\n\\t\\t\\tif (strchr(ext, '-')) {\\n\\t\\t\\t\\timport.duration.num = parse_s32(ext+5, \\\"dur\\\");\\n\\t\\t\\t\\timport.duration.den = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgf_parse_frac(ext+5, &import.duration);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"start=\\\", 6)) {\\n\\t\\t\\tCHECK_FAKEIMPORT(\\\"start\\\")\\n\\t\\t\\timport.start_time = atof(ext+7);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"lang=\\\", 5)) {\\n\\t\\t\\t/* prevent leak if param is set twice */\\n\\t\\t\\tif (szLan)\\n\\t\\t\\t\\tgf_free((char*) szLan);\\n\\n\\t\\t\\tszLan = gf_strdup(ext+6);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"delay=\\\", 6)) {\\n\\t\\t\\tif (sscanf(ext+7, \\\"%d/%u\\\", &delay.num, &delay.den)!=2) {\\n\\t\\t\\t\\tdelay.num = parse_s32(ext+7, \\\"delay\\\");\\n\\t\\t\\t\\tdelay.den = 1000; //in ms\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"par=\\\", 4)) {\\n\\t\\t\\tif (!stricmp(ext + 5, \\\"none\\\")) {\\n\\t\\t\\t\\tpar_n = par_d = 0;\\n\\t\\t\\t} else if (!stricmp(ext + 5, \\\"auto\\\")) {\\n\\t\\t\\t\\tforce_par = GF_TRUE;\\n\\t\\t\\t} else if (!stricmp(ext + 5, \\\"force\\\")) {\\n\\t\\t\\t\\tpar_n = par_d = 1;\\n\\t\\t\\t\\tforce_par = GF_TRUE;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (ext2) {\\n\\t\\t\\t\\t\\text2[0] = ':';\\n\\t\\t\\t\\t\\text2 = strchr(ext2+1, ':');\\n\\t\\t\\t\\t\\tif (ext2) ext2[0] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (ext[5]=='w') {\\n\\t\\t\\t\\t\\trewrite_bs = GF_TRUE;\\n\\t\\t\\t\\t\\tif (sscanf(ext+6, \\\"%d:%d\\\", &par_n, &par_d)!=2) {\\n\\t\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized syntax for par=, expecting N:D got %s\\\\n\\\", ext+5));\\n\\t\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (sscanf(ext+5, \\\"%d:%d\\\", &par_n, &par_d) != 2) {\\n\\t\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized syntax for par=, expecting N:D got %s\\\\n\\\", ext+5));\\n\\t\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"clap=\\\", 5)) {\\n\\t\\t\\tif (!stricmp(ext+6, \\\"none\\\")) {\\n\\t\\t\\t\\thas_clap=GF_TRUE;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (sscanf(ext+6, \\\"%d,%d,%d,%d,%d,%d,%d,%d\\\", &clap_wn, &clap_wd, &clap_hn, &clap_hd, &clap_hon, &clap_hod, &clap_von, &clap_vod)==8) {\\n\\t\\t\\t\\t\\thas_clap=GF_TRUE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"mx=\\\", 3)) {\\n\\t\\t\\tif (strstr(ext+4, \\\"0x\\\")) {\\n\\t\\t\\t\\tif (sscanf(ext+4, \\\"0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%d\\\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\\n\\t\\t\\t\\t\\thas_mx=GF_TRUE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (sscanf(ext+4, \\\"%d,%d,%d,%d,%d,%d,%d,%d,%d\\\", &mx[0], &mx[1], &mx[2], &mx[3], &mx[4], &mx[5], &mx[6], &mx[7], &mx[8])==9) {\\n\\t\\t\\t\\thas_mx=GF_TRUE;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"name=\\\", 5)) {\\n\\t\\t\\thandler_name = gf_strdup(ext+6);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"ext=\\\", 4)) {\\n\\t\\t\\tCHECK_FAKEIMPORT(\\\"ext\\\")\\n\\t\\t\\t/*extensions begin with '.'*/\\n\\t\\t\\tif (*(ext+5) == '.')\\n\\t\\t\\t\\timport.force_ext = gf_strdup(ext+5);\\n\\t\\t\\telse {\\n\\t\\t\\t\\timport.force_ext = gf_calloc(1+strlen(ext+5)+1, 1);\\n\\t\\t\\t\\timport.force_ext[0] = '.';\\n\\t\\t\\t\\tstrcat(import.force_ext+1, ext+5);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"hdlr=\\\", 5)) handler = GF_4CC(ext[6], ext[7], ext[8], ext[9]);\\n\\t\\telse if (!strnicmp(ext+1, \\\"stype=\\\", 6)) stype = GF_4CC(ext[7], ext[8], ext[9], ext[10]);\\n\\t\\telse if (!strnicmp(ext+1, \\\"tkhd\\\", 4)) {\\n\\t\\t\\tchar *flags = ext+6;\\n\\t\\t\\tif (flags[0]=='+') { track_flags_mode = GF_ISOM_TKFLAGS_ADD; flags += 1; }\\n\\t\\t\\telse if (flags[0]=='-') { track_flags_mode = GF_ISOM_TKFLAGS_REM; flags += 1; }\\n\\t\\t\\telse track_flags_mode = GF_ISOM_TKFLAGS_SET;\\n\\n\\t\\t\\tif (strstr(flags, \\\"enable\\\")) track_flags |= GF_ISOM_TK_ENABLED;\\n\\t\\t\\tif (strstr(flags, \\\"movie\\\")) track_flags |= GF_ISOM_TK_IN_MOVIE;\\n\\t\\t\\tif (strstr(flags, \\\"preview\\\")) track_flags |= GF_ISOM_TK_IN_PREVIEW;\\n\\t\\t\\tif (strstr(flags, \\\"size_ar\\\")) track_flags |= GF_ISOM_TK_SIZE_IS_AR;\\n\\t\\t\\tif (!track_flags) {\\n\\t\\t\\t\\tif (!strnicmp(flags, \\\"0x\\\", 2)) flags += 2;\\n\\t\\t\\t\\tsscanf(flags, \\\"%X\\\", &track_flags);\\n\\t\\t\\t}\\n\\t\\t} else if (!strnicmp(ext+1, \\\"disable\\\", 7)) {\\n\\t\\t\\tdo_disable = !stricmp(ext+1, \\\"disable=no\\\") ? 2 : 1;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"group=\\\", 6)) {\\n\\t\\t\\tgroup = parse_u32(ext+7, \\\"group\\\");\\n\\t\\t\\tif (!group) group = gf_isom_get_next_alternate_group_id(dest);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"fps=\\\", 4)) {\\n\\t\\t\\tu32 ticks, dts_inc;\\n\\t\\t\\tif (!strcmp(ext+5, \\\"auto\\\")) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning, fps=auto option is deprecated\\\\n\\\"));\\n\\t\\t\\t} else if ((sscanf(ext+5, \\\"%u-%u\\\", &ticks, &dts_inc) == 2) || (sscanf(ext+5, \\\"%u/%u\\\", &ticks, &dts_inc) == 2)) {\\n\\t\\t\\t\\tif (!dts_inc) dts_inc=1;\\n\\t\\t\\t\\tforce_fps.num = ticks;\\n\\t\\t\\t\\tforce_fps.den = dts_inc;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (gf_sys_old_arch_compat()) {\\n\\t\\t\\t\\t\\tforce_fps.den = 1000;\\n\\t\\t\\t\\t\\tforce_fps.num = (u32) (atof(ext+5) * force_fps.den);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgf_parse_frac(ext+5, &force_fps);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"rap\\\")) rap_only = 1;\\n\\t\\telse if (!stricmp(ext+1, \\\"refs\\\")) refs_only = 1;\\n\\t\\telse if (!stricmp(ext+1, \\\"trailing\\\")) { CHECK_FAKEIMPORT(\\\"trailing\\\") import_flags |= GF_IMPORT_KEEP_TRAILING; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"agg=\\\", 4)) { CHECK_FAKEIMPORT(\\\"agg\\\") frames_per_sample = parse_u32(ext+5, \\\"agg\\\"); }\\n\\t\\telse if (!stricmp(ext+1, \\\"dref\\\")) { CHECK_FAKEIMPORT(\\\"dref\\\")  import_flags |= GF_IMPORT_USE_DATAREF; }\\n\\t\\telse if (!stricmp(ext+1, \\\"keep_refs\\\")) { CHECK_FAKEIMPORT(\\\"keep_refs\\\") import_flags |= GF_IMPORT_KEEP_REFS; }\\n\\t\\telse if (!stricmp(ext+1, \\\"nodrop\\\")) { CHECK_FAKEIMPORT(\\\"nodrop\\\") import_flags |= GF_IMPORT_NO_FRAME_DROP; }\\n\\t\\telse if (!stricmp(ext+1, \\\"packed\\\")) { CHECK_FAKEIMPORT(\\\"packed\\\") import_flags |= GF_IMPORT_FORCE_PACKED; }\\n\\t\\telse if (!stricmp(ext+1, \\\"sbr\\\")) { CHECK_FAKEIMPORT(\\\"sbr\\\") import_flags |= GF_IMPORT_SBR_IMPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"sbrx\\\")) { CHECK_FAKEIMPORT(\\\"sbrx\\\") import_flags |= GF_IMPORT_SBR_EXPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"ovsbr\\\")) { CHECK_FAKEIMPORT(\\\"ovsbr\\\") import_flags |= GF_IMPORT_OVSBR; }\\n\\t\\telse if (!stricmp(ext+1, \\\"ps\\\")) { CHECK_FAKEIMPORT(\\\"ps\\\") import_flags |= GF_IMPORT_PS_IMPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"psx\\\")) { CHECK_FAKEIMPORT(\\\"psx\\\") import_flags |= GF_IMPORT_PS_EXPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"mpeg4\\\")) { CHECK_FAKEIMPORT(\\\"mpeg4\\\") import_flags |= GF_IMPORT_FORCE_MPEG4; }\\n\\t\\telse if (!stricmp(ext+1, \\\"nosei\\\")) { CHECK_FAKEIMPORT(\\\"nosei\\\") import_flags |= GF_IMPORT_NO_SEI; }\\n\\t\\telse if (!stricmp(ext+1, \\\"svc\\\") || !stricmp(ext+1, \\\"lhvc\\\") ) { CHECK_FAKEIMPORT(\\\"svc/lhvc\\\") import_flags |= GF_IMPORT_SVC_EXPLICIT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"nosvc\\\") || !stricmp(ext+1, \\\"nolhvc\\\")) { CHECK_FAKEIMPORT(\\\"nosvc/nolhvc\\\") import_flags |= GF_IMPORT_SVC_NONE; }\\n\\n\\t\\t/*split SVC layers*/\\n\\t\\telse if (!strnicmp(ext+1, \\\"svcmode=\\\", 8) || !strnicmp(ext+1, \\\"lhvcmode=\\\", 9)) {\\n\\t\\t\\tchar *mode = ext+9;\\n\\t\\t\\tCHECK_FAKEIMPORT_2(\\\"svcmode/lhvcmode\\\")\\n\\t\\t\\tif (mode[0]=='=') mode = ext+10;\\n\\n\\t\\t\\tif (!stricmp(mode, \\\"splitnox\\\"))\\n\\t\\t\\t\\tsvc_mode = 3;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitnoxib\\\"))\\n\\t\\t\\t\\tsvc_mode = 4;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitall\\\") || !stricmp(mode, \\\"split\\\"))\\n\\t\\t\\t\\tsvc_mode = 2;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitbase\\\"))\\n\\t\\t\\t\\tsvc_mode = 1;\\n\\t\\t\\telse if (!stricmp(mode, \\\"merged\\\") || !stricmp(mode, \\\"merge\\\"))\\n\\t\\t\\t\\tsvc_mode = 0;\\n\\t\\t}\\n\\t\\t/*split SHVC temporal sublayers*/\\n\\t\\telse if (!strnicmp(ext+1, \\\"temporal=\\\", 9)) {\\n\\t\\t\\tchar *mode = ext+10;\\n\\t\\t\\tCHECK_FAKEIMPORT_2(\\\"svcmode/lhvcmode\\\")\\n\\t\\t\\tif (!stricmp(mode, \\\"split\\\"))\\n\\t\\t\\t\\ttemporal_mode = 2;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitnox\\\"))\\n\\t\\t\\t\\ttemporal_mode = 3;\\n\\t\\t\\telse if (!stricmp(mode, \\\"splitbase\\\"))\\n\\t\\t\\t\\ttemporal_mode = 1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized temporal mode %s, ignoring\\\\n\\\", mode));\\n\\t\\t\\t\\ttemporal_mode = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"subsamples\\\")) { CHECK_FAKEIMPORT(\\\"subsamples\\\") import_flags |= GF_IMPORT_SET_SUBSAMPLES; }\\n\\t\\telse if (!stricmp(ext+1, \\\"deps\\\")) { CHECK_FAKEIMPORT(\\\"deps\\\") import_flags |= GF_IMPORT_SAMPLE_DEPS; }\\n\\t\\telse if (!stricmp(ext+1, \\\"ccst\\\")) { CHECK_FAKEIMPORT(\\\"ccst\\\") set_ccst = GF_TRUE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"alpha\\\")) { CHECK_FAKEIMPORT(\\\"alpha\\\") import.is_alpha = GF_TRUE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"forcesync\\\")) { CHECK_FAKEIMPORT(\\\"forcesync\\\") import_flags |= GF_IMPORT_FORCE_SYNC; }\\n\\t\\telse if (!stricmp(ext+1, \\\"xps_inband\\\")) { CHECK_FAKEIMPORT(\\\"xps_inband\\\") xps_inband = 1; }\\n\\t\\telse if (!stricmp(ext+1, \\\"xps_inbandx\\\")) { CHECK_FAKEIMPORT(\\\"xps_inbandx\\\") xps_inband = 2; }\\n\\t\\telse if (!stricmp(ext+1, \\\"au_delim\\\")) { CHECK_FAKEIMPORT(\\\"au_delim\\\") keep_audelim = GF_TRUE; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"max_lid=\\\", 8) || !strnicmp(ext+1, \\\"max_tid=\\\", 8)) {\\n\\t\\t\\ts32 val = parse_u32(ext+9, \\\"Max TID/LID\\\");\\n\\t\\t\\tCHECK_FAKEIMPORT_2(\\\"max_lid/lhvcmode\\\")\\n\\t\\t\\tif (val < 0) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning: request max layer/temporal id is negative - ignoring\\\\n\\\"));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!strnicmp(ext+1, \\\"max_lid=\\\", 8))\\n\\t\\t\\t\\t\\tmax_layer_id_plus_one = 1 + (u8) val;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmax_temporal_id_plus_one = 1 + (u8) val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"tiles\\\")) { CHECK_FAKEIMPORT_2(\\\"tiles\\\") split_tile_mode = 2; }\\n\\t\\telse if (!stricmp(ext+1, \\\"tiles_rle\\\")) { CHECK_FAKEIMPORT_2(\\\"tiles_rle\\\") split_tile_mode = 3; }\\n\\t\\telse if (!stricmp(ext+1, \\\"split_tiles\\\")) { CHECK_FAKEIMPORT_2(\\\"split_tiles\\\") split_tile_mode = 1; }\\n\\n\\t\\t/*force all composition offsets to be positive*/\\n\\t\\telse if (!strnicmp(ext+1, \\\"negctts\\\", 7)) {\\n\\t\\t\\tneg_ctts_mode = !strnicmp(ext+1, \\\"negctts=no\\\", 10) ? 2 : 1;\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"chap\\\")) is_chap = 1;\\n\\t\\telse if (!strnicmp(ext+1, \\\"chapter=\\\", 8)) {\\n\\t\\t\\tchapter_name = gf_strdup(ext+9);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"chapfile=\\\", 9)) {\\n\\t\\t\\tchapter_name = gf_strdup(ext+10);\\n\\t\\t\\tis_chap_file=1;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"layout=\\\", 7)) {\\n\\t\\t\\ttrack_layout = 1;\\n\\t\\t\\tif ( sscanf(ext+13, \\\"%dx%dx%dx%dx%d\\\", &tw, &th, &tx, &ty, &tz)==5) {\\n\\t\\t\\t} else if ( sscanf(ext+13, \\\"%dx%dx%dx%d\\\", &tw, &th, &tx, &ty)==4) {\\n\\t\\t\\t\\ttz = 0;\\n\\t\\t\\t} else if ( sscanf(ext+13, \\\"%dx%dx%d\\\", &tw, &th, &tz)==3) {\\n\\t\\t\\t\\ttx = ty = 0;\\n\\t\\t\\t} else if ( sscanf(ext+8, \\\"%dx%d\\\", &tw, &th)==2) {\\n\\t\\t\\t\\ttx = ty = tz = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"rescale=\\\", 8)) {\\n\\t\\t\\tif (sscanf(ext+9, \\\"%u/%u\\\", &rescale_num, &rescale_den) != 2) {\\n\\t\\t\\t\\trescale_num = parse_u32(ext+9, \\\"rescale\\\");\\n\\t\\t\\t\\trescale_den = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"sampdur=\\\", 8)) {\\n\\t\\t\\tif (sscanf(ext+9, \\\"%u/%u\\\", &rescale_den, &rescale_num) != 2) {\\n\\t\\t\\t\\trescale_den = parse_u32(ext+9, \\\"sampdur\\\");\\n\\t\\t\\t\\trescale_num = 0;\\n\\t\\t\\t}\\n\\t\\t\\trescale_override = GF_TRUE;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"timescale=\\\", 10)) {\\n\\t\\t\\tnew_timescale = parse_u32(ext+11, \\\"timescale\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"moovts=\\\", 7)) {\\n\\t\\t\\tmoov_timescale = parse_u32(ext+8, \\\"moovts\\\");\\n\\t\\t}\\n\\n\\t\\telse if (!stricmp(ext+1, \\\"noedit\\\")) { import_flags |= GF_IMPORT_NO_EDIT_LIST; }\\n\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"rvc=\\\", 4)) {\\n\\t\\t\\tif (sscanf(ext+5, \\\"%d\\\", &rvc_predefined) != 1) {\\n\\t\\t\\t\\trvc_config = gf_strdup(ext+5);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"fmt=\\\", 4)) import.streamFormat = gf_strdup(ext+5);\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"profile=\\\", 8)) {\\n\\t\\t\\tif (!stricmp(ext+9, \\\"high444\\\")) profile = 244;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"high\\\")) profile = 100;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"extended\\\")) profile = 88;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"main\\\")) profile = 77;\\n\\t\\t\\telse if (!stricmp(ext+9, \\\"baseline\\\")) profile = 66;\\n\\t\\t\\telse profile = parse_u32(ext+9, \\\"profile\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"level=\\\", 6)) {\\n\\t\\t\\tif( atof(ext+7) < 6 )\\n\\t\\t\\t\\tlevel = (int)(10*atof(ext+7)+.5);\\n\\t\\t\\telse\\n\\t\\t\\t\\tlevel = parse_u32(ext+7, \\\"level\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"compat=\\\", 7)) {\\n\\t\\t\\tcompat = parse_u32(ext+8, \\\"compat\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"dlba=\\\", 5)) {\\n\\t\\t\\tif (!strcmp(ext+6, \\\"no\\\")) dlb_mode=0;\\n\\t\\t\\telse if (!strcmp(ext+6, \\\"auto\\\")) dlb_mode=-1;\\n\\t\\t\\telse if (sscanf(ext+6, \\\"%d\\\", &dlb_mode) != 1) {\\n\\t\\t\\t\\tGOTO_EXIT(\\\"Unrecognized dolby atmos mode\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"novpsext\\\", 8)) { CHECK_FAKEIMPORT(\\\"novpsext\\\") import_flags |= GF_IMPORT_NO_VPS_EXTENSIONS; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"keepav1t\\\", 8)) { CHECK_FAKEIMPORT(\\\"keepav1t\\\") import_flags |= GF_IMPORT_KEEP_AV1_TEMPORAL_OBU; }\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"font=\\\", 5)) { CHECK_FAKEIMPORT(\\\"font\\\") import.fontName = gf_strdup(ext+6); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"size=\\\", 5)) { CHECK_FAKEIMPORT(\\\"size\\\") import.fontSize = parse_u32(ext+6, \\\"size\\\"); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"text_layout=\\\", 12)) {\\n\\t\\t\\tif ( sscanf(ext+13, \\\"%dx%dx%dx%d\\\", &txtw, &txth, &txtx, &txty)==4) {\\n\\t\\t\\t\\ttext_layout = 1;\\n\\t\\t\\t} else if ( sscanf(ext+8, \\\"%dx%d\\\", &txtw, &txth)==2) {\\n\\t\\t\\t\\ttrack_layout = 1;\\n\\t\\t\\t\\ttxtx = txty = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n#ifndef GPAC_DISABLE_SWF_IMPORT\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-global\\\")) { CHECK_FAKEIMPORT(\\\"swf-global\\\") import.swf_flags |= GF_SM_SWF_STATIC_DICT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-ctrl\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-ctrl\\\") import.swf_flags &= ~GF_SM_SWF_SPLIT_TIMELINE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-text\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-text\\\") import.swf_flags |= GF_SM_SWF_NO_TEXT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-font\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-font\\\") import.swf_flags |= GF_SM_SWF_NO_FONT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-line\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-line\\\") import.swf_flags |= GF_SM_SWF_NO_LINE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-no-grad\\\")) { CHECK_FAKEIMPORT(\\\"swf-no-grad\\\") import.swf_flags |= GF_SM_SWF_NO_GRADIENT; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-quad\\\")) { CHECK_FAKEIMPORT(\\\"swf-quad\\\") import.swf_flags |= GF_SM_SWF_QUAD_CURVE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-xlp\\\")) { CHECK_FAKEIMPORT(\\\"swf-xlp\\\") import.swf_flags |= GF_SM_SWF_SCALABLE_LINE; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-ic2d\\\")) { CHECK_FAKEIMPORT(\\\"swf-ic2d\\\") import.swf_flags |= GF_SM_SWF_USE_IC2D; }\\n\\t\\telse if (!stricmp(ext+1, \\\"swf-same-app\\\")) { CHECK_FAKEIMPORT(\\\"swf-same-app\\\") import.swf_flags |= GF_SM_SWF_REUSE_APPEARANCE; }\\n\\t\\telse if (!strnicmp(ext+1, \\\"swf-flatten=\\\", 12)) { CHECK_FAKEIMPORT(\\\"swf-flatten\\\") import.swf_flatten_angle = (Float) atof(ext+13); }\\n#endif\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"kind=\\\", 5)) {\\n\\t\\t\\tchar *kind_scheme, *kind_value;\\n\\t\\t\\tchar *kind_data = ext+6;\\n\\t\\t\\tchar *sep = strchr(kind_data, '=');\\n\\t\\t\\tif (sep) {\\n\\t\\t\\t\\t*sep = 0;\\n\\t\\t\\t}\\n\\t\\t\\tkind_scheme = gf_strdup(kind_data);\\n\\t\\t\\tif (sep) {\\n\\t\\t\\t\\t*sep = '=';\\n\\t\\t\\t\\tkind_value = gf_strdup(sep+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkind_value = NULL;\\n\\t\\t\\t}\\n\\t\\t\\tgf_list_add(kinds, kind_scheme);\\n\\t\\t\\tgf_list_add(kinds, kind_value);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"txtflags\\\", 8)) {\\n\\t\\t\\tif (!strnicmp(ext+1, \\\"txtflags=\\\", 9)) {\\n\\t\\t\\t\\tsscanf(ext+10, \\\"%x\\\", &txt_flags);\\n\\t\\t\\t}\\n\\t\\t\\telse if (!strnicmp(ext+1, \\\"txtflags+=\\\", 10)) {\\n\\t\\t\\t\\tsscanf(ext+11, \\\"%x\\\", &txt_flags);\\n\\t\\t\\t\\ttxt_mode = GF_ISOM_TEXT_FLAGS_TOGGLE;\\n\\t\\t\\t}\\n\\t\\t\\telse if (!strnicmp(ext+1, \\\"txtflags-=\\\", 10)) {\\n\\t\\t\\t\\tsscanf(ext+11, \\\"%x\\\", &txt_flags);\\n\\t\\t\\t\\ttxt_mode = GF_ISOM_TEXT_FLAGS_UNTOGGLE;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"rate=\\\", 5)) {\\n\\t\\t\\tforce_rate = parse_s32(ext+6, \\\"rate\\\");\\n\\t\\t}\\n\\t\\telse if (!stricmp(ext+1, \\\"stats\\\") || !stricmp(ext+1, \\\"fstat\\\"))\\n\\t\\t\\tprint_stats_graph |= 1;\\n\\t\\telse if (!stricmp(ext+1, \\\"graph\\\") || !stricmp(ext+1, \\\"graph\\\"))\\n\\t\\t\\tprint_stats_graph |= 2;\\n\\t\\telse if (!strncmp(ext+1, \\\"sopt\\\", 4) || !strncmp(ext+1, \\\"dopt\\\", 4) || !strncmp(ext+1, \\\"@\\\", 1)) {\\n\\t\\t\\tif (ext2) ext2[0] = ':';\\n\\t\\t\\topt_src = strstr(ext, \\\":sopt:\\\");\\n\\t\\t\\topt_dst = strstr(ext, \\\":dopt:\\\");\\n\\t\\t\\tfchain = strstr(ext, \\\":@\\\");\\n\\t\\t\\tif (opt_src) opt_src[0] = 0;\\n\\t\\t\\tif (opt_dst) opt_dst[0] = 0;\\n\\t\\t\\tif (fchain) fchain[0] = 0;\\n\\n\\t\\t\\tif (opt_src) import.filter_src_opts = opt_src+6;\\n\\t\\t\\tif (opt_dst) import.filter_dst_opts = opt_dst+6;\\n\\t\\t\\tif (fchain) {\\n\\t\\t\\t\\t//check for old syntax (0.9->1.0) :@@\\n\\t\\t\\t\\tif (fchain[2]=='@') {\\n\\t\\t\\t\\t\\timport.filter_chain = fchain + 3;\\n\\t\\t\\t\\t\\timport.is_chain_old_syntax = GF_TRUE;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\timport.filter_chain = fchain + 2;\\n\\t\\t\\t\\t\\timport.is_chain_old_syntax = GF_FALSE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\text = NULL;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\telse if (!strnicmp(ext+1, \\\"asemode=\\\", 8)){\\n\\t\\t\\tchar *mode = ext+9;\\n\\t\\t\\tif (!stricmp(mode, \\\"v0-bs\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS;\\n\\t\\t\\telse if (!stricmp(mode, \\\"v0-2\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2;\\n\\t\\t\\telse if (!stricmp(mode, \\\"v1\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG;\\n\\t\\t\\telse if (!stricmp(mode, \\\"v1-qt\\\"))\\n\\t\\t\\t\\timport.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\\n\\t\\t\\telse\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized audio sample entry mode %s, ignoring\\\\n\\\", mode));\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"audio_roll=\\\", 11)) { roll_change = 3; roll = parse_s32(ext+12, \\\"audio_roll\\\"); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"roll=\\\", 5)) { roll_change = 1; roll = parse_s32(ext+6, \\\"roll\\\"); }\\n\\t\\telse if (!strnicmp(ext+1, \\\"proll=\\\", 6)) { roll_change = 2; roll = parse_s32(ext+7, \\\"proll\\\"); }\\n\\t\\telse if (!strcmp(ext+1, \\\"stz2\\\")) {\\n\\t\\t\\tuse_stz2 = GF_TRUE;\\n\\t\\t} else if (!strnicmp(ext+1, \\\"bitdepth=\\\", 9)) {\\n\\t\\t\\tbitdepth = parse_u32(ext+10, \\\"bitdepth\\\");\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"hdr=\\\", 4)) {\\n\\t\\t\\thdr_file = gf_strdup(ext+5);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colr=\\\", 5)) {\\n\\t\\t\\tchar *cval = ext+6;\\n\\t\\t\\tif (!strcmp(cval, \\\"none\\\")) {\\n\\t\\t\\t\\tclr_type = (u32) -1;\\n\\t\\t\\t} else if (strlen(cval)<6) {\\n\\t\\t\\t\\tfmt_ok = GF_FALSE;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tclr_type = GF_4CC(cval[0],cval[1],cval[2],cval[3]);\\n\\t\\t\\t\\tcval+=4;\\n\\t\\t\\t\\tif (cval[0] != ',') {\\n\\t\\t\\t\\t\\tfmt_ok = GF_FALSE;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if ((clr_type==GF_ISOM_SUBTYPE_NCLX) || (clr_type==GF_ISOM_SUBTYPE_NCLC)) {\\n\\t\\t\\t\\t\\tfmt_ok = scan_color(cval+1, &clr_prim, &clr_tranf, &clr_mx, &clr_full_range);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if ((clr_type==GF_ISOM_SUBTYPE_RICC) || (clr_type==GF_ISOM_SUBTYPE_PROF)) {\\n\\t\\t\\t\\t\\tFILE *f = gf_fopen(cval+1, \\\"rb\\\");\\n\\t\\t\\t\\t\\tif (!f) {\\n\\t\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Failed to open file %s\\\\n\\\", cval+1));\\n\\t\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tgf_fseek(f, 0, SEEK_END);\\n\\t\\t\\t\\t\\t\\ticc_size = (u32) gf_ftell(f);\\n\\t\\t\\t\\t\\t\\ticc_data = gf_malloc(sizeof(char)*icc_size);\\n\\t\\t\\t\\t\\t\\tgf_fseek(f, 0, SEEK_SET);\\n\\t\\t\\t\\t\\t\\ticc_size = (u32) gf_fread(icc_data, icc_size, f);\\n\\t\\t\\t\\t\\t\\tgf_fclose(f);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized colr profile %s\\\\n\\\", gf_4cc_to_str(clr_type) ));\\n\\t\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!fmt_ok) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"parsing colr option\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext + 1, \\\"dvp=\\\", 4)) {\\n\\t\\t\\tstrncpy(dv_profile, ext + 5, 99);\\n\\t\\t\\tdv_profile[99]=0;\\n\\t\\t}\\n\\t\\t//old name\\n\\t\\telse if (!strnicmp(ext + 1, \\\"dv-profile=\\\", 11)) {\\n\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Deprecated option name, use `:dvp=` instead\\\\n\\\"));\\n\\t\\t\\tstrncpy(dv_profile, ext + 12, 99);\\n\\t\\t\\tdv_profile[99]=0;\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"fullrange=\\\", 10)) {\\n\\t\\t\\tif (!stricmp(ext+11, \\\"off\\\") || !stricmp(ext+11, \\\"no\\\")) fullrange = 0;\\n\\t\\t\\telse if (!stricmp(ext+11, \\\"on\\\") || !stricmp(ext+11, \\\"yes\\\")) fullrange = 1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for fullrange\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"videofmt=\\\", 10)) {\\n\\t\\t\\tu32 idx, count = GF_ARRAY_LENGTH(videofmt_names);\\n\\t\\t\\tfor (idx=0; idx<count; idx++) {\\n\\t\\t\\t\\tif (!strcmp(ext+11, videofmt_names[idx])) {\\n\\t\\t\\t\\t\\tvideofmt = idx;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (videofmt==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for videofmt\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colorprim=\\\", 10)) {\\n\\t\\t\\tcolorprim = gf_cicp_parse_color_primaries(ext+11);\\n\\t\\t\\tif (colorprim==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for colorprim\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colortfc=\\\", 9)) {\\n\\t\\t\\tcolortfc = gf_cicp_parse_color_transfer(ext+10);\\n\\t\\t\\tif (colortfc==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for colortfc\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"colormx=\\\", 10)) {\\n\\t\\t\\tcolormx = gf_cicp_parse_color_matrix(ext+11);\\n\\t\\t\\tif (colormx==-1) {\\n\\t\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\t\\tGOTO_EXIT(\\\"invalid format for colormx\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"tc=\\\", 3)) {\\n\\t\\t\\tchar *tc_str = ext+4;\\n\\t\\t\\t\\n\\t\\t\\tif (tc_str[0] == 'd') {\\n\\t\\t\\t\\ttc_drop_frame=GF_TRUE;\\n\\t\\t\\t\\ttc_str+=1;\\n\\t\\t\\t}\\n\\t\\t\\tif (sscanf(tc_str, \\\"%d/%d,%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 7) {\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d/%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_h, &tc_m, &tc_s, &tc_f) == 6) {\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f, &tc_frames_per_tick) == 6) {\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d,%d,%d,%d\\\", &tc_fps_num, &tc_h, &tc_m, &tc_s, &tc_f) == 5) {\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d/%d,%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_f, &tc_frames_per_tick) == 4) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d/%d,%d\\\", &tc_fps_num, &tc_fps_den, &tc_f) == 3) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d,%d\\\", &tc_fps_num, &tc_f, &tc_frames_per_tick) == 3) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else if (sscanf(tc_str, \\\"%d,%d\\\", &tc_fps_num, &tc_f) == 2) {\\n\\t\\t\\t\\ttc_force_counter = GF_TRUE;\\n\\t\\t\\t\\ttc_h = tc_m = tc_s = 0;\\n\\t\\t\\t\\ttc_fps_den = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Bad format %s for timecode, ignoring\\\\n\\\", ext+1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"edits=\\\", 6)) {\\n\\t\\t\\tedits = gf_strdup(ext+7);\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"lastsampdur\\\", 11)) {\\n\\t\\t\\thas_last_sample_dur = GF_TRUE;\\n\\t\\t\\tif (!strnicmp(ext+1, \\\"lastsampdur=\\\", 12)) {\\n\\t\\t\\t\\tif (sscanf(ext+13, \\\"%d/%u\\\", &last_sample_dur.num, &last_sample_dur.den)==2) {\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlast_sample_dur.num = parse_s32(ext+13, \\\"lastsampdur\\\");\\n\\t\\t\\t\\t\\tlast_sample_dur.den = 1000;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext+1, \\\"ID=\\\", 3)) {\\n\\t\\t\\timport.target_trackID = (u32) parse_u32(ext+4, \\\"ID\\\");\\n\\t\\t}\\n\\t\\t/*unrecognized, assume name has colon in it*/\\n\\t\\telse {\\n\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Unrecognized import option %s, ignoring\\\\n\\\", ext+1));\\n\\t\\t\\tif (ext2) ext2[0] = ':';\\n\\t\\t\\text = ext2;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif (src_is_isom) {\\n\\t\\t\\tchar *opt = ext+1;\\n\\t\\t\\tchar *sep_eq = strchr(opt, '=');\\n\\t\\t\\tif (sep_eq) sep_eq[0] = 0;\\n\\t\\t\\tif (!mp4box_check_isom_fileopt(opt)) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"\\\\t! Import option `%s` not available for ISOBMFF/QT sources, ignoring !\\\\n\\\", ext+1));\\n\\t\\t\\t}\\n\\t\\t\\tif (sep_eq) sep_eq[0] = '=';\\n\\t\\t}\\n\\n\\t\\tif (ext2) ext2[0] = ':';\\n\\n\\t\\text[0] = 0;\\n\\n\\t\\t/* restart from where we stopped\\n\\t\\t * if we didn't stop (ext2 null) then the end has been reached\\n\\t\\t * so we can stop the whole thing */\\n\\t\\text = ext2;\\n\\t}\\n\\n\\t/*check duration import (old syntax)*/\\n\\text = strrchr(final_name, '%');\\n\\tif (ext) {\\n\\t\\tgf_parse_frac(ext+1, &import.duration);\\n\\t\\text[0] = 0;\\n\\t}\\n\\n\\t/*select switches for av containers import*/\\n\\tdo_audio = do_video = do_auxv = do_pict = 0;\\n\\ttrack_id = prog_id = 0;\\n\\tdo_all = 1;\\n\\n\\text_start = gf_file_ext_start(final_name);\\n\\text = strrchr(ext_start ? ext_start : final_name, '#');\\n\\tif (ext) ext[0] = 0;\\n\\n\\tif (fake_import && ext) {\\n\\t\\text++;\\n\\t\\tif (!strnicmp(ext, \\\"audio\\\", 5)) do_audio = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"video\\\", 5)) do_video = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"auxv\\\", 4)) do_auxv = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"pict\\\", 4)) do_pict = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"trackID=\\\", 8)) track_id = parse_u32(&ext[8], \\\"trackID\\\");\\n\\t\\telse track_id = parse_u32(ext, \\\"ID\\\");\\n\\t}\\n\\telse if (ext) {\\n\\t\\text++;\\n\\t\\tchar *sep = gf_url_colon_suffix(ext, '=');\\n\\t\\tif (sep) sep[0] = 0;\\n\\n\\t\\t//we have a fragment, we need to check if the track or the program is present in source\\n\\t\\timport.in_name = final_name;\\n\\t\\timport.flags = GF_IMPORT_PROBE_ONLY;\\n\\t\\te = gf_media_import(&import);\\n\\t\\tGOTO_EXIT(\\\"importing import\\\");\\n\\n\\t\\tif (!strnicmp(ext, \\\"audio\\\", 5)) do_audio = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"video\\\", 5)) do_video = 1;\\n        else if (!strnicmp(ext, \\\"auxv\\\", 4)) do_auxv = 1;\\n        else if (!strnicmp(ext, \\\"pict\\\", 4)) do_pict = 1;\\n\\t\\telse if (!strnicmp(ext, \\\"trackID=\\\", 8)) track_id = parse_u32(&ext[8], \\\"trackID\\\");\\n\\t\\telse if (!strnicmp(ext, \\\"PID=\\\", 4)) track_id = parse_u32(&ext[4], \\\"ID\\\");\\n\\t\\telse if (!strnicmp(ext, \\\"program=\\\", 8)) {\\n\\t\\t\\tfor (i=0; i<import.nb_progs; i++) {\\n\\t\\t\\t\\tif (!stricmp(import.pg_info[i].name, ext+8)) {\\n\\t\\t\\t\\t\\tprog_id = import.pg_info[i].number;\\n\\t\\t\\t\\t\\tdo_all = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (!strnicmp(ext, \\\"prog_id=\\\", 8)) {\\n\\t\\t\\tprog_id = parse_u32(ext+8, \\\"prog_id\\\");\\n\\t\\t\\tdo_all = 0;\\n\\t\\t}\\n\\t\\telse track_id = parse_u32(ext, \\\"ID\\\");\\n\\n\\t\\t//figure out trackID\\n\\t\\tif (do_audio || do_video || do_auxv || do_pict || track_id) {\\n\\t\\t\\tBool found = track_id ? GF_FALSE : GF_TRUE;\\n\\t\\t\\tfor (i=0; i<import.nb_tracks; i++) {\\n\\t\\t\\t\\tif (track_id && (import.tk_info[i].track_num==track_id)) {\\n\\t\\t\\t\\t\\tfound=GF_TRUE;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (do_audio && (import.tk_info[i].stream_type==GF_STREAM_AUDIO)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (do_video && (import.tk_info[i].stream_type==GF_STREAM_VISUAL)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (do_auxv && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_AUXV)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (do_pict && (import.tk_info[i].media_subtype==GF_ISOM_MEDIA_PICT)) {\\n\\t\\t\\t\\t\\ttrack_id = import.tk_info[i].track_num;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!track_id || !found) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Cannot find track ID matching fragment #%s\\\\n\\\", ext));\\n\\t\\t\\t\\tif (sep) sep[0] = ':';\\n\\t\\t\\t\\te = GF_NOT_FOUND;\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (sep) sep[0] = ':';\\n\\t}\\n\\tif (do_audio || do_video || do_auxv || do_pict || track_id) do_all = 0;\\n\\n\\tif (track_layout || is_chap) {\\n\\t\\tu32 w, h, sw, sh, fw, fh;\\n\\t\\tw = h = sw = sh = fw = fh = 0;\\n\\t\\tchap_ref = 0;\\n\\t\\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\\n\\t\\t\\tswitch (gf_isom_get_media_type(dest, i+1)) {\\n\\t\\t\\tcase GF_ISOM_MEDIA_SCENE:\\n\\t\\t\\tcase GF_ISOM_MEDIA_VISUAL:\\n            case GF_ISOM_MEDIA_AUXV:\\n            case GF_ISOM_MEDIA_PICT:\\n\\t\\t\\t\\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\\n\\n\\t\\t\\t\\tgf_isom_get_visual_info(dest, i+1, 1, &sw, &sh);\\n\\t\\t\\t\\tgf_isom_get_track_layout_info(dest, i+1, &fw, &fh, NULL, NULL, NULL);\\n\\t\\t\\t\\tif (w<sw) w = sw;\\n\\t\\t\\t\\tif (w<fw) w = fw;\\n\\t\\t\\t\\tif (h<sh) h = sh;\\n\\t\\t\\t\\tif (h<fh) h = fh;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase GF_ISOM_MEDIA_AUDIO:\\n\\t\\t\\t\\tif (!chap_ref && gf_isom_is_track_enabled(dest, i+1) ) chap_ref = i+1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (track_layout) {\\n\\t\\t\\tif (!tw) tw = w;\\n\\t\\t\\tif (!th) th = h;\\n\\t\\t\\tif (ty==-1) ty = (h>(u32)th) ? h-th : 0;\\n\\t\\t\\timport.text_width = tw;\\n\\t\\t\\timport.text_height = th;\\n\\t\\t}\\n\\t\\tif (is_chap && chap_ref) import_flags |= GF_IMPORT_NO_TEXT_FLUSH;\\n\\t}\\n\\tif (text_layout && txtw && txth) {\\n\\t\\timport.text_track_width = import.text_width ? import.text_width : txtw;\\n\\t\\timport.text_track_height = import.text_height ? import.text_height : txth;\\n\\t\\timport.text_width = txtw;\\n\\t\\timport.text_height = txth;\\n\\t\\timport.text_x = txtx;\\n\\t\\timport.text_y = txty;\\n\\t}\\n\\n\\tcheck_track_for_svc = check_track_for_lhvc = check_track_for_hevc = 0;\\n\\n\\tsource_magic = (u64) gf_crc_32((u8 *)inName, (u32) strlen(inName));\\n\\tif (!fake_import && (!fsess || mux_args_if_first_pass)) {\\n\\t\\timport.in_name = final_name;\\n\\t\\timport.dest = dest;\\n\\t\\timport.video_fps = force_fps;\\n\\t\\timport.frames_per_sample = frames_per_sample;\\n\\t\\timport.flags = import_flags;\\n\\t\\timport.keep_audelim = keep_audelim;\\n\\t\\timport.print_stats_graph = print_stats_graph;\\n\\t\\timport.xps_inband = xps_inband;\\n\\t\\timport.prog_id = prog_id;\\n\\t\\timport.trackID = track_id;\\n\\t\\timport.source_magic = source_magic;\\n\\t\\timport.track_index = tk_idx;\\n\\n\\t\\t//if moov timescale is <0 (auto mode) set it at import time\\n\\t\\tif (moov_timescale<0) {\\n\\t\\t\\timport.moov_timescale = moov_timescale;\\n\\t\\t}\\n\\t\\t//otherwise force it now\\n\\t\\telse if (moov_timescale>0) {\\n\\t\\t\\te = gf_isom_set_timescale(dest, moov_timescale);\\n\\t\\t\\tGOTO_EXIT(\\\"changing timescale\\\")\\n\\t\\t}\\n\\n\\t\\timport.run_in_session = fsess;\\n\\t\\timport.update_mux_args = NULL;\\n\\t\\tif (do_all)\\n\\t\\t\\timport.flags |= GF_IMPORT_KEEP_REFS;\\n\\n\\t\\te = gf_media_import(&import);\\n\\t\\tif (e) {\\n\\t\\t\\tif (import.update_mux_args) gf_free(import.update_mux_args);\\n\\t\\t\\tGOTO_EXIT(\\\"importing media\\\");\\n\\t\\t}\\n\\n\\t\\tif (fsess) {\\n\\t\\t\\t*mux_args_if_first_pass = import.update_mux_args;\\n\\t\\t\\timport.update_mux_args = NULL;\\n\\t\\t\\t*mux_sid_if_first_pass = import.update_mux_sid;\\n\\t\\t\\timport.update_mux_sid = NULL;\\n\\t\\t\\tgoto exit;\\n\\t\\t}\\n\\t}\\n\\n\\tnb_tracks = gf_isom_get_track_count(dest);\\n\\tfor (i=0; i<nb_tracks; i++) {\\n\\t\\tu32 media_type;\\n\\t\\ttrack = i+1;\\n\\t\\tmedia_type = gf_isom_get_media_type(dest, track);\\n\\t\\te = GF_OK;\\n\\t\\tif (!fake_import) {\\n\\t\\t\\tu64 tk_source_magic;\\n\\t\\t\\ttk_source_magic = gf_isom_get_track_magic(dest, track);\\n\\n\\t\\t\\tif ((tk_source_magic & 0xFFFFFFFFUL) != source_magic)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttk_source_magic>>=32;\\t\\t\\n\\t\\t\\tkeep_handler = (tk_source_magic & 1) ? GF_TRUE : GF_FALSE;\\n\\t\\t} else {\\n\\t\\t\\tkeep_handler = GF_TRUE;\\n\\n\\t\\t\\tif (do_audio && (media_type!=GF_ISOM_MEDIA_AUDIO)) continue;\\n\\t\\t\\tif (do_video && (media_type!=GF_ISOM_MEDIA_VISUAL)) continue;\\n\\t\\t\\tif (do_auxv && (media_type!=GF_ISOM_MEDIA_AUXV)) continue;\\n\\t\\t\\tif (do_pict && (media_type!=GF_ISOM_MEDIA_PICT)) continue;\\n\\t\\t\\tif (track_id && (gf_isom_get_track_id(dest, track) != track_id))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\ttimescale = gf_isom_get_timescale(dest);\\n\\t\\tif (szLan) {\\n\\t\\t\\te = gf_isom_set_media_language(dest, track, (char *) szLan);\\n\\t\\t\\tGOTO_EXIT(\\\"changing language\\\")\\n\\t\\t}\\n\\t\\tif (do_disable) {\\n\\t\\t\\te = gf_isom_set_track_enabled(dest, track, (do_disable==2) ? GF_TRUE : GF_FALSE);\\n\\t\\t\\tGOTO_EXIT(\\\"disabling track\\\")\\n\\t\\t}\\n\\t\\tif (track_flags_mode) {\\n\\t\\t\\te = gf_isom_set_track_flags(dest, track, track_flags, track_flags_mode);\\n\\t\\t\\tGOTO_EXIT(\\\"disabling track\\\")\\n\\t\\t}\\n\\n\\t\\tif (import_flags & GF_IMPORT_NO_EDIT_LIST) {\\n\\t\\t\\te = gf_isom_remove_edits(dest, track);\\n\\t\\t\\tGOTO_EXIT(\\\"removing edits\\\")\\n\\t\\t}\\n\\t\\tif (delay.num && delay.den) {\\n\\t\\t\\tu64 tk_dur;\\n\\t\\t\\te = gf_isom_remove_edits(dest, track);\\n\\t\\t\\ttk_dur = gf_isom_get_track_duration(dest, track);\\n\\t\\t\\tif (delay.num>0) {\\n\\t\\t\\t\\t//cast to s64, timescale*delay could be quite large before /1000\\n\\t\\t\\t\\te |= gf_isom_append_edit(dest, track, ((s64) delay.num) * timescale / delay.den, 0, GF_ISOM_EDIT_EMPTY);\\n\\t\\t\\t\\te |= gf_isom_append_edit(dest, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t//cast to s64, timescale*delay could be quite large before /1000\\n\\t\\t\\t\\tu64 to_skip = ((s64) -delay.num) * timescale / delay.den;\\n\\t\\t\\t\\tif (to_skip<tk_dur) {\\n\\t\\t\\t\\t\\t//cast to s64, timescale*delay could be quite large before /1000\\n\\t\\t\\t\\t\\tu64 media_time = ((s64) -delay.num) * gf_isom_get_media_timescale(dest, track) / delay.den;\\n\\t\\t\\t\\t\\te |= gf_isom_append_edit(dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning: request negative delay longer than track duration - ignoring\\\\n\\\"));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tGOTO_EXIT(\\\"assigning delay\\\")\\n\\t\\t}\\n\\t\\tif (gf_isom_is_video_handler_type(media_type)) {\\n\\t\\t\\tif (((par_n>=0) && (par_d>=0)) || force_par) {\\n\\t\\t\\t\\te = gf_media_change_par(dest, track, par_n, par_d, force_par, rewrite_bs);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing PAR\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif ((fullrange>=0) || (videofmt>=0) || (colorprim>=0) || (colortfc>=0) || (colormx>=0)) {\\n\\t\\t\\t\\te = gf_media_change_color(dest, i+1, fullrange, videofmt, colorprim, colortfc, colormx);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing color in bitstream\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (has_clap) {\\n\\t\\t\\t\\te = gf_isom_set_clean_aperture(dest, track, 1, clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing clean aperture\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (bitdepth) {\\n\\t\\t\\t\\te = gf_isom_set_visual_bit_depth(dest, track, 1, bitdepth);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing bit depth\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (clr_type) {\\n\\t\\t\\t\\tif (clr_type==(u32)-1)\\n\\t\\t\\t\\t\\tclr_type = 0;\\n\\n\\t\\t\\t\\te = gf_isom_set_visual_color_info(dest, track, 1, clr_type, clr_prim, clr_tranf, clr_mx, clr_full_range, icc_data, icc_size);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing color info\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (hdr_file) {\\n\\t\\t\\t\\te = parse_high_dynamc_range_xml_desc(dest, track, hdr_file);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"setting HDR info\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (dv_profile[0]) {\\n\\t\\t\\t\\te = set_dv_profile(dest, track, dv_profile);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"setting DV profile\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (set_ccst) {\\n\\t\\t\\t\\te = gf_isom_set_image_sequence_coding_constraints(dest, track, 1, GF_FALSE, GF_FALSE, GF_TRUE, 15);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"setting image sequence constraints\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (has_mx) {\\n\\t\\t\\te = gf_isom_set_track_matrix(dest, track, mx);\\n\\t\\t\\tGOTO_EXIT(\\\"setting track matrix\\\")\\n\\t\\t}\\n\\t\\tif (use_stz2) {\\n\\t\\t\\te = gf_isom_use_compact_size(dest, track, GF_TRUE);\\n\\t\\t\\tGOTO_EXIT(\\\"setting compact size\\\")\\n\\t\\t}\\n\\n\\t\\tif (gf_isom_get_media_subtype(dest, track, 1) == GF_ISOM_MEDIA_TIMECODE) {\\n\\t\\t\\ttmcd_track = track;\\n\\t\\t}\\n\\t\\tif (rap_only || refs_only) {\\n\\t\\t\\te = gf_media_remove_non_rap(dest, track, refs_only);\\n\\t\\t\\tGOTO_EXIT(\\\"removing non RAPs\\\")\\n\\t\\t}\\n\\t\\tif (handler_name) {\\n\\t\\t\\te = gf_isom_set_handler_name(dest, track, handler_name);\\n\\t\\t\\tGOTO_EXIT(\\\"setting handler name\\\")\\n\\t\\t}\\n\\t\\telse if (!keep_handler) {\\n\\t\\t\\tchar szHName[1024];\\n\\t\\t\\tconst char *fName = gf_url_get_resource_name((const  char *)inName);\\n\\t\\t\\tfName = strchr(fName, '.');\\n\\t\\t\\tif (fName) fName += 1;\\n\\t\\t\\telse fName = \\\"?\\\";\\n\\n\\t\\t\\tsprintf(szHName, \\\"%s@GPAC%s\\\", fName, gf_gpac_version());\\n\\t\\t\\te = gf_isom_set_handler_name(dest, track, szHName);\\n\\t\\t\\tGOTO_EXIT(\\\"setting handler name\\\")\\n\\t\\t}\\n\\t\\tif (handler) {\\n\\t\\t\\te = gf_isom_set_media_type(dest, track, handler);\\n\\t\\t\\tGOTO_EXIT(\\\"setting media type\\\")\\n\\t\\t}\\n\\t\\tif (group) {\\n\\t\\t\\te = gf_isom_set_alternate_group_id(dest, track, group);\\n\\t\\t\\tGOTO_EXIT(\\\"setting alternate group\\\")\\n\\t\\t}\\n\\n\\t\\tif (track_layout) {\\n\\t\\t\\te = gf_isom_set_track_layout_info(dest, track, tw<<16, th<<16, tx<<16, ty<<16, tz);\\n\\t\\t\\tGOTO_EXIT(\\\"setting track layout\\\")\\n\\t\\t}\\n\\t\\tif (stype) {\\n\\t\\t\\te = gf_isom_set_media_subtype(dest, track, 1, stype);\\n\\t\\t\\tGOTO_EXIT(\\\"setting media subtype\\\")\\n\\t\\t}\\n\\t\\tif (is_chap && chap_ref) {\\n\\t\\t\\te = set_chapter_track(dest, track, chap_ref);\\n\\t\\t\\tGOTO_EXIT(\\\"setting chapter track\\\")\\n\\t\\t}\\n\\n\\t\\tfor (j = 0; j < gf_list_count(kinds); j+=2) {\\n\\t\\t\\tchar *kind_scheme = (char *)gf_list_get(kinds, j);\\n\\t\\t\\tchar *kind_value = (char *)gf_list_get(kinds, j+1);\\n\\t\\t\\te = gf_isom_add_track_kind(dest, i+1, kind_scheme, kind_value);\\n\\t\\t\\tGOTO_EXIT(\\\"setting track kind\\\")\\n\\t\\t}\\n\\n\\t\\tif (profile || compat || level) {\\n\\t\\t\\te = gf_media_change_pl(dest, track, profile, compat, level);\\n\\t\\t\\tGOTO_EXIT(\\\"changing video PL\\\")\\n\\t\\t}\\n\\t\\tif (gf_isom_get_mpeg4_subtype(dest, track, 1))\\n\\t\\t\\tkeep_sys_tracks = 1;\\n\\n\\t\\t//if moov timescale is <0 (auto mode) set it at import time\\n\\t\\tif (fake_import) {\\n\\t\\t\\tif (import_flags & GF_IMPORT_NO_EDIT_LIST)\\n\\t\\t\\t\\tgf_isom_remove_edits(dest, track);\\n\\n\\t\\t\\tif (moov_timescale<0) {\\n\\t\\t\\t\\tmoov_timescale = gf_isom_get_media_timescale(dest, track);\\n\\t\\t\\t}\\n\\t\\t\\tif (moov_timescale>0) {\\n\\t\\t\\t\\te = gf_isom_set_timescale(dest, moov_timescale);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"changing timescale\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (import.asemode && (media_type==GF_ISOM_MEDIA_AUDIO)) {\\n\\t\\t\\t\\tu32 sr, ch, bps;\\n\\t\\t\\t\\tgf_isom_get_audio_info(dest, track, 1, &sr, &ch, &bps);\\n\\t\\t\\t\\tgf_isom_set_audio_info(dest, track, 1, sr, ch, bps, import.asemode);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (roll_change) {\\n\\t\\t\\tif ((roll_change!=3) || (media_type==GF_ISOM_MEDIA_AUDIO)) {\\n\\t\\t\\t\\te = gf_isom_set_sample_roll_group(dest, track, (u32) -1, (roll_change==2) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL, roll);\\n\\t\\t\\t\\tGOTO_EXIT(\\\"assigning roll\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (new_timescale>1) {\\n\\t\\t\\te = gf_isom_set_media_timescale(dest, track, new_timescale, 0, 0);\\n\\t\\t\\tGOTO_EXIT(\\\"setting media timescale\\\")\\n\\t\\t}\\n\\n\\t\\tif (rescale_num > 1) {\\n\\t\\t\\tswitch (gf_isom_get_media_type(dest, track)) {\\n\\t\\t\\tcase GF_ISOM_MEDIA_AUDIO:\\n\\t\\t\\t\\tif (!rescale_override) {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Cannot force media timescale for audio media types - ignoring\\\\n\\\"));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\te = gf_isom_set_media_timescale(dest, track, rescale_num, rescale_den, rescale_override ? 2 : 1);\\n                if (e==GF_EOS) {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Rescale ignored, same config in source file\\\\n\\\"));\\n\\t\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tGOTO_EXIT(\\\"rescaling media track\\\")\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} else if (src_is_isom && force_fps.den && force_fps.num) {\\n\\t\\t\\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, track))) {\\n\\t\\t\\t\\te = gf_isom_set_media_timescale(dest, track, force_fps.num, force_fps.den, 2);\\n                if (e==GF_EOS) {\\n\\t\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Rescale ignored, same config in source file\\\\n\\\"));\\n\\t\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_WARNING, (\\\"Cannot force FPS for media types %s - ignoring\\\\n\\\", gf_4cc_to_str( gf_isom_get_media_type(dest, track)) ));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (has_last_sample_dur) {\\n\\t\\t\\te = gf_isom_set_last_sample_duration_ex(dest, track, last_sample_dur.num, last_sample_dur.den);\\n\\t\\t\\tGOTO_EXIT(\\\"setting last sample duration\\\")\\n\\t\\t}\\n\\t\\tif (rvc_config) {\\n#ifdef GPAC_DISABLE_ZLIB\\n\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Error: no zlib support - RVC not available\\\\n\\\"));\\n\\t\\t\\te = GF_NOT_SUPPORTED;\\n\\t\\t\\tgoto exit;\\n#else\\n\\t\\t\\tu8 *data;\\n\\t\\t\\tu32 size;\\n\\t\\t\\te = gf_file_load_data(rvc_config, (u8 **) &data, &size);\\n\\t\\t\\tGOTO_EXIT(\\\"loading RVC config file\\\")\\n\\n\\t\\t\\tgf_gz_compress_payload(&data, size, &size);\\n\\t\\t\\te |= gf_isom_set_rvc_config(dest, track, 1, 0, \\\"application/rvc-config+xml+gz\\\", data, size);\\n\\t\\t\\tgf_free(data);\\n\\t\\t\\tGOTO_EXIT(\\\"compressing and assigning RVC config\\\")\\n#endif\\n\\t\\t} else if (rvc_predefined>0) {\\n\\t\\t\\te = gf_isom_set_rvc_config(dest, track, 1, rvc_predefined, NULL, NULL, 0);\\n\\t\\t\\tGOTO_EXIT(\\\"setting RVC predefined config\\\")\\n\\t\\t}\\n\\n\\t\\tif (neg_ctts_mode) {\\n\\t\\t\\te = gf_isom_set_composition_offset_mode(dest, track, (neg_ctts_mode==1) ? GF_TRUE : GF_FALSE);\\n\\t\\t\\tGOTO_EXIT(\\\"setting composition offset mode\\\")\\n\\t\\t}\\n\\n\\t\\tif (gf_isom_get_avc_svc_type(dest, track, 1)>=GF_ISOM_AVCTYPE_AVC_SVC)\\n\\t\\t\\tcheck_track_for_svc = track;\\n\\n\\t\\tswitch (gf_isom_get_hevc_lhvc_type(dest, track, 1)) {\\n\\t\\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\\n\\t\\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\\n\\t\\t\\tcheck_track_for_lhvc = i+1;\\n\\t\\t\\tbreak;\\n\\t\\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\\n\\t\\t\\tcheck_track_for_hevc=1;\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif (txt_flags) {\\n\\t\\t\\te = gf_isom_text_set_display_flags(dest, track, 0, txt_flags, txt_mode);\\n\\t\\t\\tGOTO_EXIT(\\\"setting text track display flags\\\")\\n\\t\\t}\\n\\n\\t\\tif (edits) {\\n\\t\\t\\te = apply_edits(dest, track, edits);\\n\\t\\t\\tGOTO_EXIT(\\\"applying edits\\\")\\n\\t\\t}\\n\\n\\t\\tif (force_rate>=0) {\\n\\t\\t\\te = gf_isom_update_bitrate(dest, i+1, 1, force_rate, force_rate, 0);\\n\\t\\t\\tGOTO_EXIT(\\\"updating bitrate\\\")\\n\\t\\t}\\n\\n\\t\\tif (split_tile_mode) {\\n\\t\\t\\tswitch (gf_isom_get_media_subtype(dest, track, 1)) {\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HVC1:\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HEV1:\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HVC2:\\n\\t\\t\\tcase GF_ISOM_SUBTYPE_HEV2:\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tsplit_tile_mode = 0;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ((dlb_mode>=-1) && (gf_isom_get_media_subtype(dest, track, 1)==GF_ISOM_SUBTYPE_EC3)) {\\n\\t\\t\\tGF_AC3Config *ac3c = gf_isom_ac3_config_get(dest, track, 1);\\n\\t\\t\\tif (ac3c) {\\n\\t\\t\\t\\tif (dlb_mode==0) {\\n\\t\\t\\t\\t\\tac3c->is_ec3 = GF_TRUE;\\n\\t\\t\\t\\t\\tac3c->atmos_ec3_ext=0;\\n\\t\\t\\t\\t\\tac3c->complexity_index_type=0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tu32 di;\\n\\t\\t\\t\\t\\tGF_ISOSample *samp = gf_isom_get_sample(dest, track, 1, &di);\\n\\t\\t\\t\\t\\tu32 pos;\\n\\t\\t\\t\\t\\tgf_eac3_parser(samp->data, samp->dataLength, &pos, ac3c, GF_TRUE);\\n\\n\\t\\t\\t\\t\\tif (dlb_mode>0) {\\n\\t\\t\\t\\t\\t\\tac3c->atmos_ec3_ext = 1;\\n\\t\\t\\t\\t\\t\\tac3c->complexity_index_type = dlb_mode;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgf_isom_ac3_config_update(dest, track, 1, ac3c);\\n\\t\\t\\t\\tgf_free(ac3c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (chapter_name) {\\n\\t\\tif (is_chap_file) {\\n\\t\\t\\tGF_Fraction a_fps = {0,0};\\n\\t\\t\\te = gf_media_import_chapters(dest, chapter_name, a_fps, GF_FALSE);\\n\\t\\t} else {\\n\\t\\t\\te = gf_isom_add_chapter(dest, 0, 0, chapter_name);\\n\\t\\t}\\n\\t\\tGOTO_EXIT(\\\"importing chapters\\\")\\n\\t}\\n\\n\\tif (tmcd_track) {\\n\\t\\tu32 tmcd_id = gf_isom_get_track_id(dest, tmcd_track);\\n\\t\\tfor (i=0; i < gf_isom_get_track_count(dest); i++) {\\n\\t\\t\\tswitch (gf_isom_get_media_type(dest, i+1)) {\\n\\t\\t\\tcase GF_ISOM_MEDIA_VISUAL:\\n\\t\\t\\tcase GF_ISOM_MEDIA_AUXV:\\n\\t\\t\\tcase GF_ISOM_MEDIA_PICT:\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\te = gf_isom_set_track_reference(dest, i+1, GF_ISOM_REF_TMCD, tmcd_id);\\n\\t\\t\\tGOTO_EXIT(\\\"assigning TMCD track references\\\")\\n\\t\\t}\\n\\t}\\n\\n\\t/*force to rewrite all dependencies*/\\n\\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\\n\\t{\\n\\t\\te = gf_isom_rewrite_track_dependencies(dest, i);\\n\\t\\tif (e) {\\n\\t\\t\\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\\\"Warning: track ID %d has references to a track not imported\\\\n\\\", gf_isom_get_track_id(dest, i) ));\\n\\t\\t\\te = GF_OK;\\n\\t\\t}\\n\\t}\\n\\n#ifndef GPAC_DISABLE_AV_PARSERS\\n\\tif (max_layer_id_plus_one || max_temporal_id_plus_one) {\\n\\t\\tfor (i = 1; i <= gf_isom_get_track_count(dest); i++)\\n\\t\\t{\\n\\t\\t\\te = gf_media_filter_hevc(dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);\\n\\t\\t\\tif (e) {\\n\\t\\t\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Warning: track ID %d: error while filtering LHVC layers\\\\n\\\", gf_isom_get_track_id(dest, i)));\\n\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n#endif\\n\\n\\tif (check_track_for_svc) {\\n\\t\\tif (svc_mode) {\\n\\t\\t\\te = gf_media_split_svc(dest, check_track_for_svc, (svc_mode==2) ? 1 : 0);\\n\\t\\t\\tGOTO_EXIT(\\\"splitting SVC track\\\")\\n\\t\\t} else {\\n\\t\\t\\te = gf_media_merge_svc(dest, check_track_for_svc, 1);\\n\\t\\t\\tGOTO_EXIT(\\\"merging SVC/SHVC track\\\")\\n\\t\\t}\\n\\t}\\n#ifndef GPAC_DISABLE_AV_PARSERS\\n\\tif (check_track_for_lhvc) {\\n\\t\\tif (svc_mode) {\\n\\t\\t\\tGF_LHVCExtractoreMode xmode = GF_LHVC_EXTRACTORS_ON;\\n\\t\\t\\tif (svc_mode==3) xmode = GF_LHVC_EXTRACTORS_OFF;\\n\\t\\t\\telse if (svc_mode==4) xmode = GF_LHVC_EXTRACTORS_OFF_FORCE_INBAND;\\n\\t\\t\\te = gf_media_split_lhvc(dest, check_track_for_lhvc, GF_FALSE, (svc_mode==1) ? 0 : 1, xmode );\\n\\t\\t\\tGOTO_EXIT(\\\"splitting L-HEVC track\\\")\\n\\t\\t} else {\\n\\t\\t\\t//TODO - merge, temporal sublayers\\n\\t\\t}\\n\\t}\\n#ifndef GPAC_DISABLE_HEVC\\n\\tif (check_track_for_hevc) {\\n\\t\\tif (split_tile_mode) {\\n\\t\\t\\te = gf_media_split_hevc_tiles(dest, split_tile_mode - 1);\\n\\t\\t\\tGOTO_EXIT(\\\"splitting HEVC tiles\\\")\\n\\t\\t}\\n\\t\\tif (temporal_mode) {\\n\\t\\t\\tGF_LHVCExtractoreMode xmode = (temporal_mode==3) ? GF_LHVC_EXTRACTORS_OFF : GF_LHVC_EXTRACTORS_ON;\\n\\t\\t\\te = gf_media_split_lhvc(dest, check_track_for_hevc, GF_TRUE, (temporal_mode==1) ? GF_FALSE : GF_TRUE, xmode );\\n\\t\\t\\tGOTO_EXIT(\\\"splitting HEVC temporal sublayers\\\")\\n\\t\\t}\\n\\t}\\n#endif\\n\\n\\tif (tc_fps_num) {\\n\\t\\tu32 desc_index=0;\\n\\t\\tu32 tmcd_tk, tmcd_id;\\n\\t\\tu32 video_ref = 0;\\n\\t\\tGF_BitStream *bs;\\n\\t\\tGF_ISOSample *samp;\\n\\t\\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\\n\\t\\t\\tif (gf_isom_is_video_handler_type(gf_isom_get_media_type(dest, i+1))) {\\n\\t\\t\\t\\tvideo_ref = i+1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttmcd_tk = gf_isom_new_track(dest, 0, GF_ISOM_MEDIA_TIMECODE, tc_fps_num);\\n\\t\\tif (!tmcd_tk) {\\n\\t\\t\\te = gf_isom_last_error(dest);\\n\\t\\t\\tGOTO_EXIT(\\\"creating TMCD track\\\")\\n\\t\\t}\\n\\t\\te = gf_isom_set_track_enabled(dest, tmcd_tk, 1);\\n\\t\\tif (e != GF_OK) {\\n\\t\\t\\tGOTO_EXIT(\\\"enabling TMCD track\\\")\\n\\t\\t}\\n\\n\\t\\tif (!tc_frames_per_tick) {\\n\\t\\t\\ttc_frames_per_tick = tc_fps_num;\\n\\t\\t\\ttc_frames_per_tick /= tc_fps_den;\\n\\t\\t\\tif (tc_frames_per_tick * tc_fps_den < tc_fps_num)\\n\\t\\t\\t\\ttc_frames_per_tick++;\\n\\t\\t}\\n\\n\\t\\tu32 tmcd_value = (tc_h * 3600 + tc_m*60 + tc_s)*tc_frames_per_tick+tc_f;\\n\\t\\ttmcd_id = gf_isom_get_track_id(dest, tmcd_tk);\\n\\n\\t\\te = gf_isom_tmcd_config_new(dest, tmcd_tk, tc_fps_num, tc_fps_den, tc_frames_per_tick, tc_drop_frame, tc_force_counter, &desc_index);\\n\\t\\tGOTO_EXIT(\\\"configuring TMCD sample description\\\")\\n\\n\\t\\tif (video_ref) {\\n\\t\\t\\te = gf_isom_set_track_reference(dest, video_ref, GF_ISOM_REF_TMCD, tmcd_id);\\n\\t\\t\\tGOTO_EXIT(\\\"assigning TMCD track ref on video track\\\")\\n\\t\\t}\\n\\t\\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\\n\\t\\tgf_bs_write_u32(bs, tmcd_value);\\n\\t\\tsamp = gf_isom_sample_new();\\n\\t\\tsamp->IsRAP = SAP_TYPE_1;\\n\\t\\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\\n\\t\\tgf_bs_del(bs);\\n\\t\\te = gf_isom_add_sample(dest, tmcd_tk, desc_index, samp);\\n\\t\\tgf_isom_sample_del(&samp);\\n\\t\\tGOTO_EXIT(\\\"assigning TMCD sample\\\")\\n\\n\\t\\tif (video_ref) {\\n\\t\\t\\tu64 video_ref_dur = gf_isom_get_media_duration(dest, video_ref);\\n\\t\\t\\tvideo_ref_dur *= tc_fps_num;\\n\\t\\t\\tvideo_ref_dur /= gf_isom_get_media_timescale(dest, video_ref);\\n\\t\\t\\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, (u32) video_ref_dur);\\n\\t\\t} else {\\n\\t\\t\\te = gf_isom_set_last_sample_duration(dest, tmcd_tk, tc_fps_den ? tc_fps_den : 1);\\n\\t\\t}\\n\\t\\tGOTO_EXIT(\\\"setting TMCD sample dur\\\")\\n\\t}\\n\\n#endif /*GPAC_DISABLE_AV_PARSERS*/\\n\\nexit:\\n\\twhile (gf_list_count(kinds)) {\\n\\t\\tchar *kind = (char *)gf_list_get(kinds, 0);\\n\\t\\tgf_list_rem(kinds, 0);\\n\\t\\tif (kind) gf_free(kind);\\n\\t}\\n\\tif (opt_src) opt_src[0] = ':';\\n\\tif (opt_dst) opt_dst[0] = ':';\\n\\tif (fchain) fchain[0] = ':';\\n\\tif (hdr_file) gf_free(hdr_file);\\n\\n\\tgf_list_del(kinds);\\n\\tif (handler_name) gf_free(handler_name);\\n\\tif (chapter_name ) gf_free(chapter_name);\\n\\tif (import.fontName) gf_free(import.fontName);\\n\\tif (import.streamFormat) gf_free(import.streamFormat);\\n\\tif (import.force_ext) gf_free(import.force_ext);\\n\\tif (rvc_config) gf_free(rvc_config);\\n\\tif (edits) gf_free(edits);\\n\\tif (szLan) gf_free((char *)szLan);\\n\\tif (icc_data) gf_free(icc_data);\\n\\tif (final_name) gf_free(final_name);\\n\\n\\tif (!e) return GF_OK;\\n\\tif (fail_msg) {\\n\\t\\tM4_LOG(GF_LOG_ERROR, (\\\"Failure while %s: %s\\\\n\\\", fail_msg, gf_error_to_string(e) ));\\n\\t}\\n\\treturn e;\\n}\\n\",\n            \"caller_start\": 622,\n            \"file_path\": \"applications/mp4box/fileimport.c\"\n          },\n          {\n            \"call_line\": 1273,\n            \"call_code\": \"gf_media_split_hevc_tiles(movie, 0)\",\n            \"caller_code\": \"static GF_Err gf_isom_iff_create_image_item_from_track_internal(GF_ISOFile *movie, Bool root_meta, u32 meta_track_number, u32 imported_track, const char *item_name, u32 item_id, GF_ImageItemProperties *image_props, GF_List *item_extent_refs, u32 sample_number) {\\n#ifndef GPAC_DISABLE_ISOM_WRITE\\n\\tGF_Err e;\\n\\tu32 w, h, hSpacing, vSpacing;\\n\\tu8 num_channels;\\n\\tu8 bits_per_channel[3];\\n\\tu32 subtype;\\n\\tGF_ISOSample *sample = NULL;\\n\\tu32 timescale;\\n\\tu32 item_type = 0;\\n\\tGF_ImageItemProperties local_image_props;\\n\\tGF_ImageItemProtection ipro, *orig_ipro = NULL;\\n\\tBool config_needed = 0;\\n\\tGF_Box *config_box = NULL;\\n\\tBool is_cenc = GF_FALSE;\\n\\tBool is_first = GF_TRUE;\\n\\tBool neg_time = (image_props && image_props->time<0) ? GF_TRUE : GF_FALSE;\\n\\tu8 *sai = NULL;\\n\\tu32 sai_size = 0, sai_alloc_size = 0;\\n\\tu32 sample_desc_index = 0;\\n\\tGF_ISOFile *fsrc = movie;\\n\\tBool reset_brands = GF_FALSE;\\n\\n\\t//only reset brands if first item import\\n\\tif (!gf_isom_get_meta_item_count(movie, root_meta, meta_track_number))\\n\\t\\treset_brands = GF_TRUE;\\n\\n\\tif (image_props && image_props->src_file)\\n\\t\\tfsrc = image_props->src_file;\\n\\n\\tif (image_props && image_props->tile_mode != TILE_ITEM_NONE) {\\n\\t\\t/* Processing the input file in Tiled mode:\\n\\t\\t   The single track is split into multiple tracks\\n\\t\\t   and each track is processed to create an item */\\n\\t\\tu32 i, count;\\n\\t\\tu32 tile_track;\\n\\t\\tGF_List *tile_item_ids;\\n\\t\\tchar sz_item_name[256];\\n\\t\\tGF_TileItemMode orig_tile_mode;\\n\\n#if !defined(GPAC_DISABLE_HEVC) && !defined(GPAC_DISABLE_AV_PARSERS)\\n\\t\\tif (image_props->src_file)\\n\\t\\t\\te = GF_SERVICE_ERROR;\\n\\t\\telse\\n\\t\\t\\te = gf_media_split_hevc_tiles(movie, 0);\\n#else\\n\\t\\te = GF_NOT_SUPPORTED;\\n#endif\\n\\n\\t\\tif (e) return e;\\n\\t\\ttile_item_ids = gf_list_new();\\n\\t\\torig_tile_mode = image_props->tile_mode;\\n\\t\\timage_props->tile_mode = TILE_ITEM_NONE;\\n\\t\\tcount = gf_isom_get_reference_count(movie, imported_track, GF_ISOM_REF_SABT);\\n\\t\\tfor (i = 0; i < count; i++) {\\n\\t\\t\\tu32 *tile_item_id = gf_malloc(sizeof(u32));\\n\\t\\t\\tif (!tile_item_id) return GF_OUT_OF_MEM;\\n\\n\\t\\t\\t*tile_item_id = item_id + i+1;\\n\\t\\t\\tgf_list_add(tile_item_ids, tile_item_id);\\n\\t\\t\\te = gf_isom_get_reference(movie, imported_track, GF_ISOM_REF_SABT, 1, &tile_track);\\n\\t\\t\\tif (e) return e;\\n\\t\\t\\tif (item_name)\\n\\t\\t\\t\\tsprintf(sz_item_name, \\\"%s-Tile%d\\\", item_name, i + 1);\\n\\t\\t\\tif (orig_tile_mode != TILE_ITEM_SINGLE || image_props->single_tile_number == i + 1) {\\n\\t\\t\\t\\te = gf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, tile_track, item_name ? sz_item_name : NULL, *tile_item_id, NULL, NULL);\\n\\t\\t\\t}\\n\\t\\t\\tif (e) return e;\\n\\t\\t\\tgf_isom_remove_track(movie, tile_track);\\n\\t\\t\\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\\n\\t\\t\\t\\te = gf_isom_meta_add_item_ref(movie, root_meta, meta_track_number, *tile_item_id, item_id, GF_ISOM_REF_TBAS, NULL);\\n\\t\\t\\t}\\n\\t\\t\\tif (e) return e;\\n\\t\\t}\\n\\t\\tif (item_name)\\n\\t\\t\\tsprintf(sz_item_name, \\\"%s-TileBase\\\", item_name);\\n\\t\\tif (orig_tile_mode == TILE_ITEM_ALL_BASE) {\\n\\t\\t\\tgf_isom_iff_create_image_item_from_track(movie, root_meta, meta_track_number, imported_track, item_name ? sz_item_name : NULL, item_id, image_props, tile_item_ids);\\n\\t\\t}\\n\\t\\telse if (orig_tile_mode == TILE_ITEM_ALL_GRID) {\\n\\t\\t\\t// TODO\\n\\t\\t}\\n\\t\\tfor (i = 0; i < count; i++) {\\n\\t\\t\\tu32 *tile_item_id = gf_list_get(tile_item_ids, i);\\n\\t\\t\\tgf_free(tile_item_id);\\n\\t\\t}\\n\\t\\tgf_list_del(tile_item_ids);\\n\\t\\treturn GF_OK;\\n\\t}\\n\\n\\tif (!image_props) {\\n\\t\\timage_props = &local_image_props;\\n\\t\\tmemset(image_props, 0, sizeof(GF_ImageItemProperties));\\n\\t} else {\\n\\t\\torig_ipro = image_props->cenc_info;\\n\\t\\timage_props->cenc_info = NULL;\\n\\t}\\n\\n\\tif (!imported_track) {\\n\\t\\tGF_ImageItemProperties src_props;\\n\\t\\tu32 item_idx, ref_id;\\n\\t\\tu32 scheme_type=0, scheme_version=0;\\n\\t\\tconst char *orig_item_name, *orig_item_mime_type, *orig_item_encoding;\\n\\t\\tif (!image_props->item_ref_id) return GF_BAD_PARAM;\\n\\n\\t\\tif (gf_isom_meta_get_item_ref_count(fsrc, GF_TRUE, 0, image_props->item_ref_id, GF_4CC('d','i','m','g')) > 0) {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: Cannnot import derived image, only native image import is supported\\\\n\\\"));\\n\\t\\t\\treturn GF_NOT_SUPPORTED;\\n\\t\\t}\\n\\n\\t\\titem_idx = gf_isom_get_meta_item_by_id(fsrc, GF_TRUE, 0, image_props->item_ref_id);\\n\\t\\tif (!item_idx) {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: No item with ID %d, cannnot import\\\\n\\\", image_props->item_ref_id));\\n\\t\\t\\treturn GF_BAD_PARAM;\\n\\t\\t}\\n\\t\\torig_item_name = orig_item_mime_type = orig_item_encoding = NULL;\\n\\t\\tgf_isom_get_meta_item_info(fsrc, GF_TRUE, 0, item_idx, &ref_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &orig_item_name, &orig_item_mime_type, &orig_item_encoding);\\n\\n\\t\\tif (!ref_id) return GF_BAD_PARAM;\\n\\t\\tif (ref_id != image_props->item_ref_id) return GF_ISOM_INVALID_FILE;\\n\\n\\t\\tgf_isom_get_meta_image_props(fsrc, GF_TRUE, 0, ref_id, &src_props, NULL);\\n\\n\\t\\timage_props->config = src_props.config;\\n\\t\\timage_props->width = src_props.width;\\n\\t\\timage_props->height = src_props.height;\\n\\t\\timage_props->num_channels = src_props.num_channels;\\n\\t\\tmemcpy(image_props->av1_layer_size, src_props.av1_layer_size, sizeof(u32)*3);\\n\\t\\tmemcpy(image_props->bits_per_channel, src_props.bits_per_channel, sizeof(u32)*3);\\n\\t\\tif (!image_props->hSpacing && !image_props->vSpacing) {\\n\\t\\t\\timage_props->hSpacing = src_props.hSpacing;\\n\\t\\t\\timage_props->vSpacing = src_props.vSpacing;\\n\\t\\t}\\n\\t\\tif (image_props->copy_props) {\\n\\t\\t\\tif (!image_props->hOffset && !image_props->vOffset) {\\n\\t\\t\\t\\timage_props->hOffset = src_props.hOffset;\\n\\t\\t\\t\\timage_props->vOffset = src_props.vOffset;\\n\\t\\t\\t}\\n\\t\\t\\tif (!image_props->clap_wden) {\\n\\t\\t\\t\\timage_props->clap_wnum = src_props.clap_wnum;\\n\\t\\t\\t\\timage_props->clap_wden = src_props.clap_wden;\\n\\t\\t\\t\\timage_props->clap_hnum = src_props.clap_hnum;\\n\\t\\t\\t\\timage_props->clap_hden = src_props.clap_hden;\\n\\t\\t\\t\\timage_props->clap_honum = src_props.clap_honum;\\n\\t\\t\\t\\timage_props->clap_hoden = src_props.clap_hoden;\\n\\t\\t\\t\\timage_props->clap_vonum = src_props.clap_vonum;\\n\\t\\t\\t\\timage_props->clap_voden = src_props.clap_voden;\\n\\t\\t\\t}\\n\\t\\t\\tif (!image_props->alpha) image_props->alpha = src_props.alpha;\\n\\t\\t\\tif (!image_props->depth) image_props->depth = src_props.depth;\\n\\t\\t\\tif (!image_props->hidden) image_props->hidden = src_props.hidden;\\n\\t\\t\\tif (!image_props->angle) image_props->angle = src_props.angle;\\n\\t\\t\\tif (!image_props->mirror) image_props->mirror = src_props.mirror;\\n\\t\\t\\tif (!image_props->av1_op_index) image_props->av1_op_index = src_props.av1_op_index;\\n\\t\\t}\\n\\t\\tif (!item_name) item_name = orig_item_name;\\n\\n\\t\\tif (!image_props->use_reference || (fsrc == image_props->src_file)) {\\n\\t\\t\\tu8 *data = NULL;\\n\\t\\t\\tu32 size=0;\\n\\t\\t\\te = gf_isom_extract_meta_item_mem(fsrc, GF_TRUE, 0, ref_id, &data, &size, &size, NULL, GF_FALSE);\\n\\t\\t\\tif (e) return GF_BAD_PARAM;\\n\\n\\t\\t\\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, data, size, NULL);\\n\\t\\t\\tif (data) gf_free(data);\\n\\t\\t} else {\\n\\t\\t\\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, 0, ref_id);\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\nimport_next_sample:\\n\\n\\ttimescale = gf_isom_get_media_timescale(fsrc, imported_track);\\n\\tif (image_props->sample_num) {\\n\\t\\tsample_number = image_props->sample_num;\\n\\t\\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\\n\\t\\te = gf_isom_last_error(fsrc);\\n\\t} else if (image_props->time<0) {\\n\\t\\tsample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);\\n\\t\\te = gf_isom_last_error(fsrc);\\n\\t} else {\\n\\t\\te = gf_isom_get_sample_for_media_time(fsrc, imported_track, (u64)(image_props->time*timescale), &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &sample, &sample_number, NULL);\\n\\t}\\n\\tif (e || !sample || !sample->IsRAP) {\\n\\t\\tif (!sample) {\\n\\t\\t\\tif (is_first) {\\n\\t\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"No sample found%s\\\\n\\\", (image_props->time<0) ? \\\"\\\" : \\\" for requested time\\\"));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t}\\n\\t\\t} else if ((image_props->time<0) || (image_props->step_time)) {\\n\\t\\t\\tif (image_props->sample_num) {\\n\\t\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: imported sample %d (DTS \\\"LLU\\\") is not a sync sample (RAP %d size %d)\\\\n\\\", sample_number, sample->DTS, sample->IsRAP, sample->dataLength));\\n\\t\\t\\t} else if (image_props->step_time) {\\n\\t\\t\\t\\tgf_isom_sample_del(&sample);\\n\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgf_isom_sample_del(&sample);\\n\\t\\t\\t\\tsample_number++;\\n\\t\\t\\t\\tif (sample_number == gf_isom_get_sample_count(fsrc, imported_track)) {\\n\\t\\t\\t\\t\\te = GF_OK;\\n\\t\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgoto import_next_sample;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error no sync sample found after time %g\\\\n\\\", image_props->time));\\n\\t\\t}\\n\\t\\tif (!e) e = GF_BAD_PARAM;\\n\\t\\tgoto exit;\\n\\t}\\n\\n\\t/* Check if the track type is supported as item type */\\n\\t/* Get the config box if needed */\\n\\tsubtype = gf_isom_get_media_subtype(fsrc, imported_track, sample_desc_index);\\n\\tif (gf_isom_is_media_encrypted(fsrc, imported_track, sample_desc_index)) {\\n\\t\\tif (gf_isom_is_cenc_media(fsrc, imported_track, sample_desc_index)) {\\n\\t\\t\\te = gf_isom_get_original_format_type(fsrc, imported_track, sample_desc_index, &subtype);\\n\\t\\t\\tif (e) goto exit;\\n\\t\\t\\tis_cenc = GF_TRUE;\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Protected sample not using CENC, cannot add as item\\\\n\\\"));\\n\\t\\t\\te = GF_BAD_PARAM;\\n\\t\\t\\tgoto exit;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tswitch (subtype) {\\n\\tcase GF_ISOM_SUBTYPE_AVC_H264:\\n\\tcase GF_ISOM_SUBTYPE_AVC2_H264:\\n\\tcase GF_ISOM_SUBTYPE_AVC3_H264:\\n\\tcase GF_ISOM_SUBTYPE_AVC4_H264:\\n\\t\\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_avc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_SVC_H264:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_svc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_MVC_H264:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_AVCConfigurationBox *)config_box)->config = gf_isom_mvc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_HVC1:\\n\\tcase GF_ISOM_SUBTYPE_HEV1:\\n\\tcase GF_ISOM_SUBTYPE_HVC2:\\n\\tcase GF_ISOM_SUBTYPE_HEV2:\\n\\tcase GF_ISOM_SUBTYPE_HVT1:\\n\\tcase GF_ISOM_SUBTYPE_LHV1:\\n\\tcase GF_ISOM_SUBTYPE_LHE1:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_hevc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\tif (subtype == GF_ISOM_SUBTYPE_HVT1) {\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_HVT1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_HVC1;\\n\\t\\t}\\n\\t\\tconfig_needed = 1;\\n\\t\\tif (!((GF_HEVCConfigurationBox *)config_box)->config) {\\n\\t\\t\\t((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_lhvc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\t\\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_LHV1;\\n\\t\\t}\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\\n\\t\\tbits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\tbits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\\n\\t\\t//media_brand = GF_ISOM_BRAND_HEIC;\\n\\t\\tbreak;\\n\\tcase GF_ISOM_SUBTYPE_AV01:\\n\\t\\t{\\n\\t\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\\n\\t\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t\\t((GF_AV1ConfigurationBox *)config_box)->config = gf_isom_av1_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\t\\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t\\titem_type = GF_ISOM_SUBTYPE_AV01;\\n\\t\\t\\tconfig_needed = 1;\\n\\t\\t\\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\\n\\t\\t\\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\\n\\t\\t\\t\\tnum_channels = 1;\\n\\t\\t\\t\\tbits_per_channel[0] = depth;\\n\\t\\t\\t\\tbits_per_channel[1] = 0;\\n\\t\\t\\t\\tbits_per_channel[2] = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnum_channels = 3;\\n\\t\\t\\t\\tbits_per_channel[0] = depth;\\n\\t\\t\\t\\tbits_per_channel[1] = depth;\\n\\t\\t\\t\\tbits_per_channel[2] = depth;\\n\\t\\t\\t}\\n\\t\\t\\t// presence of OBU SH in config is not recommended and properties should be used instead of metadata OBUs\\n\\t\\t\\twhile (gf_list_count(((GF_AV1ConfigurationBox *)config_box)->config->obu_array)) {\\n\\t\\t\\t\\tGF_AV1_OBUArrayEntry *obu = gf_list_pop_back(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\\n\\t\\t\\t\\tif (obu) {\\n\\t\\t\\t\\t\\tif (obu->obu) gf_free(obu->obu);\\n\\t\\t\\t\\t\\tgf_free(obu);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tgf_list_del(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);\\n\\t\\t\\t((GF_AV1ConfigurationBox *)config_box)->config->obu_array = NULL;\\n\\t\\t\\te = gf_media_av1_layer_size_get(fsrc, imported_track, sample_number, image_props->av1_op_index, image_props->av1_layer_size);\\n      if (e) {\\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"AV1 operating point index out of range for stream\\\\n\\\"));\\n        goto exit;\\n      }\\n\\t\\t\\t//media_brand = GF_ISOM_BRAND_AVIF;\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\tcase GF_ISOM_SUBTYPE_VVC1:\\n\\t\\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\\n\\t\\tif (!config_box) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\t((GF_VVCConfigurationBox *)config_box)->config = gf_isom_vvc_config_get(fsrc, imported_track, sample_desc_index);\\n\\t\\tif (! ((GF_VVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }\\n\\t\\titem_type = GF_ISOM_SUBTYPE_VVC1;\\n\\n\\t\\tconfig_needed = 1;\\n\\t\\tnum_channels = 3;\\n\\t\\tbits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\\n\\t\\tbits_per_channel[1] = bits_per_channel[2] = bits_per_channel[0];\\n\\t\\t//media_brand = GF_ISOM_BRAND_HEIC;\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: Codec not supported to create HEIF image items\\\\n\\\"));\\n\\t\\te = GF_NOT_SUPPORTED;\\n\\t\\tgoto exit;\\n\\t}\\n\\tif (config_needed && !config_box && !((GF_AVCConfigurationBox *)config_box)->config) {\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error: Image type %s requires a missing configuration box\\\\n\\\", gf_4cc_to_str(item_type)));\\n\\t\\te = GF_BAD_PARAM;\\n\\t\\tgoto exit;\\n\\t}\\n\\t/* Get some images properties from the track data */\\n\\te = gf_isom_get_visual_info(fsrc, imported_track, sample_desc_index, &w, &h);\\n\\tif (e) {\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error determining image size\\\\n\\\"));\\n\\t\\tgoto exit;\\n\\t}\\n\\te = gf_isom_get_pixel_aspect_ratio(fsrc, imported_track, sample_desc_index, &hSpacing, &vSpacing);\\n\\tif (e) {\\n\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"Error determining image aspect ratio\\\\n\\\"));\\n\\t\\tgoto exit;\\n\\t}\\n\\tif (!image_props->width && !image_props->height) {\\n\\t\\timage_props->width = w;\\n\\t\\timage_props->height = h;\\n\\t}\\n\\tif (!image_props->hSpacing && !image_props->vSpacing) {\\n\\t\\timage_props->hSpacing = hSpacing;\\n\\t\\timage_props->vSpacing = vSpacing;\\n\\t}\\n\\timage_props->config = config_box;\\n\\tif (!image_props->num_channels) {\\n\\t\\timage_props->num_channels = num_channels;\\n\\t\\timage_props->bits_per_channel[0] = bits_per_channel[0];\\n\\t\\timage_props->bits_per_channel[1] = bits_per_channel[1];\\n\\t\\timage_props->bits_per_channel[2] = bits_per_channel[2];\\n\\t}\\n\\tif (is_cenc) {\\n\\t\\tBool Is_Encrypted;\\n\\n\\t\\tmemset(&ipro, 0, sizeof(GF_ImageItemProtection));\\n\\t\\tgf_isom_get_cenc_info(fsrc, imported_track, sample_desc_index, NULL, &ipro.scheme_type, &ipro.scheme_version);\\n\\t\\te = gf_isom_get_sample_cenc_info(fsrc, imported_track, sample_desc_index, &Is_Encrypted, &ipro.crypt_byte_block, &ipro.skip_byte_block, &ipro.key_info, &ipro.key_info_size);\\n\\t\\tif (e) goto exit;\\n\\n\\t\\tif (Is_Encrypted) {\\n\\t\\t\\tsai_size = sai_alloc_size;\\n\\t\\t\\te = gf_isom_cenc_get_sample_aux_info(fsrc, imported_track, sample_number, sample_desc_index, NULL, &sai, &sai_size);\\n\\t\\t\\tif (e) goto exit;\\n\\n\\t\\t\\tif (sai_size > sai_alloc_size)\\n\\t\\t\\t\\tsai_alloc_size = sai_size;\\n\\n\\t\\t\\tipro.sai_data = sai;\\n\\t\\t\\tipro.sai_data_size = sai_size;\\n\\t\\t\\timage_props->cenc_info = &ipro;\\n\\n\\t\\t\\tif (is_first) {\\n\\t\\t\\t\\tu32 i, nb_pssh = gf_isom_get_pssh_count(fsrc);\\n\\t\\t\\t\\tfor (i=0; i<nb_pssh; i++) {\\n\\t\\t\\t\\t\\tbin128 SystemID;\\n\\t\\t\\t\\t\\tu32 version;\\n\\t\\t\\t\\t\\tu32 KID_count;\\n\\t\\t\\t\\t\\tconst bin128 *KIDs;\\n\\t\\t\\t\\t\\tconst u8 *private_data;\\n\\t\\t\\t\\t\\tu32 private_data_size;\\n\\n\\t\\t\\t\\t\\tgf_isom_get_pssh_info(fsrc, i+1, SystemID, &version, &KID_count, &KIDs, &private_data, &private_data_size);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tgf_cenc_set_pssh(movie, SystemID, version, KID_count, (bin128 *) KIDs, (u8 *) private_data, private_data_size, 2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\timage_props->cenc_info = NULL;\\n\\t\\t}\\n\\t}\\n\\tif (!item_id) {\\n\\t\\te = gf_isom_meta_get_next_item_id(movie, root_meta, meta_track_number, &item_id);\\n\\t\\tif (e) goto exit;\\n\\t}\\n\\tif (image_props->use_reference) {\\n\\t\\tif (image_props->sample_num) {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"referring trackID %d sample %d as item %d\\\\n\\\", imported_track, sample_number, item_id));\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"referring trackID %d sample at time %.3f as item %d\\\\n\\\", imported_track, (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\\n\\t\\t}\\n\\t\\te = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, imported_track, sample_number);\\n\\t} else {\\n\\n\\t\\tif (image_props->sample_num) {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"Adding sample %d as item %d\\\\n\\\", sample_number, item_id));\\n\\t\\t} else {\\n\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"Adding sample at time %.3f as item %d\\\\n\\\", (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));\\n\\t\\t}\\n\\t\\te = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, item_name, &item_id, item_type, NULL, NULL, image_props, sample->data, sample->dataLength, item_extent_refs);\\n\\t}\\n\\n\\timage_props->cenc_info = NULL;\\n\\n\\tif (reset_brands) {\\n\\t\\tgf_isom_set_brand_info(movie, GF_ISOM_BRAND_MIF1, 0);\\n\\t\\tgf_isom_reset_alt_brands(movie);\\n\\n\\t\\t// TODO Analyze configuration to determine the brand */\\n\\t\\t//if (media_brand) {\\n\\t\\t//\\tgf_isom_modify_alternate_brand(movie, media_brand, GF_TRUE);\\n\\t\\t//}\\n\\t}\\n\\n\\t\\n\\tif (neg_time)\\n\\t\\timage_props->time = -1;\\n\\n\\tif (!e && !image_props->sample_num && ((image_props->time<0) || image_props->end_time || image_props->step_time)) {\\n\\t\\tif (image_props->end_time || image_props->step_time) {\\n\\t\\t\\tDouble t = (Double) (sample->DTS + sample->CTS_Offset);\\n\\t\\t\\tt /= timescale;\\n\\t\\t\\tif (image_props->step_time) {\\n\\t\\t\\t\\tt += image_props->step_time;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t//step 1ms\\n\\t\\t\\t\\tt += 0.001;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ((image_props->end_time>0) && (t>image_props->end_time)) {\\n\\t\\t\\t\\tgoto exit;\\n\\t\\t\\t}\\n\\t\\t\\timage_props->time = t;\\n\\t\\t}\\n\\n\\t\\titem_id=0;\\n\\t\\tgf_isom_sample_del(&sample);\\n\\t\\tif (config_box) {\\n\\t\\t\\tgf_isom_box_del(config_box);\\n\\t\\t\\tconfig_box = NULL;\\n\\t\\t}\\n\\t\\tis_first = GF_FALSE;\\n\\t\\tif (sample_number >= gf_isom_get_sample_count(fsrc, imported_track)) return e;\\n\\t\\tsample_number++;\\n\\t\\t//avoid recursion this could get quite big\\n\\t\\tgoto import_next_sample;\\n\\t}\\n\\nexit:\\n\\tif (sai) gf_free(sai);\\n\\tgf_isom_sample_del(&sample);\\n\\tif (config_box) gf_isom_box_del(config_box);\\n\\timage_props->cenc_info = orig_ipro;\\n\\treturn e;\\n\\n\\n#else\\n\\treturn GF_NOT_SUPPORTED;\\n#endif\\n\\n}\\n\",\n            \"caller_start\": 1229,\n            \"file_path\": \"src/isomedia/iff.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"func_info(func:gf_isom_get_sample)\",\n        \"result\": [\n          {\n            \"code\": \"GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\\n{\\n\\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\\n}\",\n            \"start_line\": 1934,\n            \"end_line\": 1937,\n            \"full_name\": \"gf_isom_get_sample\",\n            \"file_path\": \"src/isomedia/isom_read.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"In `gf_media_split_hevc_tiles` (isom_tools.c:3544), `gf_isom_get_sample` may return null, leading to uninitialized `sample->data`/`sample->dataLength` access. The patch adds a null check to prevent this. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) is not directly addressed here. GAP: Missing code for `Media_GetSample` and its callers to trace the recursion.\",\n    \"required_context_next\": [\n      \"function: Media_GetSample in isomedia/media.c\",\n      \"caller: callers of Media_GetSample in isomedia/media.c\"\n    ],\n    \"analysis_summary_text\": \"The patch in `isom_tools.c:3544` prevents a null dereference in `gf_media_split_hevc_tiles` by checking `sample` after `gf_isom_get_sample`. However, the infinite recursion in `Media_GetSample` (isomedia/media.c:662) remains unexplained. The current chain shows `gf_media_split_hevc_tiles` calls `gf_isom_get_sample`, which may trigger `Media_GetSample`. The gap lies in the unprovided code for `Media_GetSample` and its interaction with `gf_isom_get_sample`, which is necessary to trace the recursion cycle.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:Media_GetSample)\",\n        \"result\": [\n          {\n            \"code\": \"GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\\n{\\n\\tGF_Err e;\\n\\tu32 bytesRead;\\n\\tu32 dataRefIndex, chunkNumber;\\n\\tu64 offset, new_size;\\n\\tu32 sdesc_idx, data_size;\\n\\tGF_SampleEntryBox *entry;\\n\\tGF_StscEntry *stsc_entry;\\n\\n\\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\\n\\tif (!mdia->information->sampleTable->SampleSize)\\n\\t\\treturn GF_ISOM_INVALID_FILE;\\n\\n\\t//OK, here we go....\\n\\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\\n\\n\\t//the data info\\n\\tif (!sIDX && !no_data) return GF_BAD_PARAM;\\n\\n\\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\\n\\tif (e) return e;\\n\\tif (sIDX) (*sIDX) = sdesc_idx;\\n\\n\\tif (out_offset) *out_offset = offset;\\n\\tif (!samp ) return GF_OK;\\n\\n\\tif (mdia->information->sampleTable->TimeToSample) {\\n\\t\\t//get the DTS\\n\\t\\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\\n\\t\\tif (e) return e;\\n\\t} else {\\n\\t\\t(*samp)->DTS=0;\\n\\t}\\n\\t//the CTS offset\\n\\tif (mdia->information->sampleTable->CompositionOffset) {\\n\\t\\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\\n\\t\\tif (e) return e;\\n\\t} else {\\n\\t\\t(*samp)->CTS_Offset = 0;\\n\\t}\\n\\t//the size\\n\\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\\n\\tif (e) return e;\\n\\t//the RAP\\n\\tif (mdia->information->sampleTable->SyncSample) {\\n\\t\\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\\n\\t\\tif (e) return e;\\n\\t} else {\\n\\t\\t//if no SyncSample, all samples are sync (cf spec)\\n\\t\\t(*samp)->IsRAP = RAP;\\n\\t}\\n\\n\\tif (mdia->information->sampleTable->SampleDep) {\\n\\t\\tu32 isLeading, dependsOn, dependedOn, redundant;\\n\\t\\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\\n\\t\\tif (!e) {\\n\\t\\t\\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\\n\\t\\t\\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\\n\\t\\t\\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\\n\\t\\t\\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\\n\\n\\t\\t\\t/*if not depended upon and redundant, mark as carousel sample*/\\n\\t\\t\\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\\n\\t\\t\\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\\n\\t\\t}\\n\\t}\\n\\n\\t/*get sync shadow*/\\n\\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\\n\\n\\t//the data info\\n\\tif (!sIDX && !no_data) return GF_BAD_PARAM;\\n//\\tif (!sIDX && !out_offset) return GF_OK;\\n\\tif (!sIDX) {\\n\\t\\t(*samp)->dataLength = data_size;\\n\\t\\treturn GF_OK;\\n\\t}\\n\\t(*sIDX) = sdesc_idx;\\n\\n\\t//then get the DataRef\\n\\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\\n\\tif (e) return e;\\n\\n\\t//if moov is compressed, remove offset if sample is after moov in this file\\n\\tif (mdia->mediaTrack->moov->compressed_diff) {\\n\\t\\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\\n\\t\\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\\n\\t\\t\\toffset -= mdia->mediaTrack->moov->compressed_diff;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tif (no_data) {\\n\\t\\t(*samp)->dataLength = data_size;\\n\\t\\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\\n\\t\\t\\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\\n\\t\\t\\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\\n\\t\\t\\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\\n\\t\\t\\t\\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\\n\\t\\t\\t(*samp)->dataLength *= left_in_chunk;\\n\\t\\t\\t(*samp)->nb_pack = left_in_chunk;\\n\\t\\t}\\n\\t\\treturn GF_OK;\\n\\t}\\n\\n\\t// Open the data handler - check our mode, don't reopen in read only if this is\\n\\t//the same entry. In other modes we have no choice because the main data map is\\n\\t//divided into the original and the edition files\\n\\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\\n\\t\\t//same as last call in read mode\\n\\t\\tif (!mdia->information->dataHandler) {\\n\\t\\t\\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\\n\\t\\t\\tif (e) return e;\\n\\t\\t}\\n\\t\\tmdia->information->dataEntryIndex = dataRefIndex;\\n\\t} else {\\n\\t\\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\\n\\t\\tif (e) return e;\\n\\t}\\n\\n\\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\\n\\t\\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\\n\\t\\tif (ent && (ent->flags&1)) {\\n\\t\\t\\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\\n\\t\\t\\tif (offset < real_offset)\\n\\t\\t\\t\\treturn GF_IO_ERR;\\n\\n\\t\\t\\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\\n\\t\\t\\t\\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\\n\\t\\t\\t\\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\\n\\t\\t\\t}\\n\\n\\t\\t\\toffset -= real_offset;\\n\\t\\t}\\n\\t}\\n\\n\\tif (data_size != 0) {\\n\\t\\tif (mdia->mediaTrack->pack_num_samples) {\\n\\t\\t\\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\\n\\t\\t\\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\\n\\t\\t\\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\\n\\t\\t\\t\\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\\n\\t\\t\\tdata_size *= left_in_chunk;\\n\\t\\t\\t(*samp)->nb_pack = left_in_chunk;\\n\\t\\t}\\n\\n\\t\\t/*and finally get the data, include padding if needed*/\\n\\t\\tif ((*samp)->alloc_size) {\\n\\t\\t\\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\\n\\t\\t\\t\\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\\n\\t\\t\\t\\tif (! (*samp)->data) return GF_OUT_OF_MEM;\\n\\n\\t\\t\\t\\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\\n\\t\\t\\tif (! (*samp)->data) return GF_OUT_OF_MEM;\\n\\t\\t}\\n\\t\\t(*samp)->dataLength = data_size;\\n\\t\\tif (mdia->mediaTrack->padding_bytes)\\n\\t\\t\\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\\n\\n\\t\\t//check if we can get the sample (make sure we have enougth data...)\\n\\t\\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\\n\\t\\tif (offset + data_size > new_size) {\\n\\t\\t\\t//always refresh the size to avoid wrong info on http/ftp\\n\\t\\t\\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\\n\\t\\t\\tif (offset + data_size > new_size) {\\n\\t\\t\\t\\tmdia->BytesMissing = offset + data_size - new_size;\\n\\t\\t\\t\\treturn GF_ISOM_INCOMPLETE_FILE;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\\n\\t\\t//if bytesRead != sampleSize, we have an IO err\\n\\t\\tif (bytesRead < data_size) {\\n\\t\\t\\treturn GF_IO_ERR;\\n\\t\\t}\\n\\t\\tmdia->BytesMissing = 0;\\n\\t} else {\\n\\t\\t(*samp)->dataLength = 0;\\n\\t}\\n\\n\\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\\n\\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\\n\\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\\n\\t\\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\\n\\t\\t\\te = Media_RewriteODFrame(mdia, *samp);\\n\\t\\t\\tif (e) return e;\\n\\t\\t}\\n\\t}\\n\\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\\n\\t\\t&& !gf_isom_is_encrypted_entry(entry->type)\\n\\t) {\\n\\t\\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\\n\\t\\tif (e) return e;\\n\\t}\\n\\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\\n\\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\\n\\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\\n\\t        ) {\\n\\t\\tu64 dur;\\n\\t\\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\\n\\t\\t\\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\\n\\t\\t} else {\\n\\t\\t\\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\\n\\t\\t\\tdur -= (*samp)->DTS;\\n\\t\\t}\\n\\t\\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\\n\\t\\tif (e) return e;\\n\\t}\\n\\treturn GF_OK;\\n}\\n\",\n            \"start_line\": 467,\n            \"end_line\": 680,\n            \"full_name\": \"Media_GetSample\",\n            \"file_path\": \"src/isomedia/media.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(file:media.c, func:Media_GetSample)\",\n        \"result\": [\n          {\n            \"call_line\": 182,\n            \"call_code\": \"Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL)\",\n            \"caller_code\": \"static GF_Err process_extractor(GF_ISOFile *file, GF_MediaBox *mdia, u32 sampleNumber, u64 sampleDTS, u32 nal_size, u16 nal_hdr, u32 nal_unit_size_field, Bool is_hevc, Bool rewrite_ps, Bool rewrite_start_codes, u32 extractor_mode)\\n{\\n\\tGF_Err e;\\n\\tu32 di, ref_track_index, ref_track_num, data_offset, data_length, cur_extract_mode, ref_extract_mode, ref_nalu_size, nb_bytes_nalh;\\n\\tGF_TrackReferenceTypeBox *dpnd;\\n\\tGF_TrackBox *ref_trak;\\n\\ts8 sample_offset;\\n\\tu32 last_byte, ref_sample_num, prev_ref_sample_num;\\n\\tBool header_written = GF_FALSE;\\n\\tnb_bytes_nalh = is_hevc ? 2 : 1;\\n\\n\\tswitch (extractor_mode) {\\n\\tcase 0:\\n\\t\\tlast_byte = (u32) gf_bs_get_position(mdia->nalu_parser) + nal_size - (is_hevc ? 2 : 1);\\n\\t\\tif (!is_hevc) gf_bs_read_int(mdia->nalu_parser, 24); //1 byte for HEVC , 3 bytes for AVC of NALUHeader in extractor\\n\\t\\twhile (gf_bs_get_position(mdia->nalu_parser) < last_byte) {\\n\\t\\t\\tu32 xmode = 0;\\n\\t\\t\\t//hevc extractors use constructors\\n\\t\\t\\tif (is_hevc) xmode = gf_bs_read_u8(mdia->nalu_parser);\\n\\t\\t\\tif (xmode) {\\n\\t\\t\\t\\tu8 done=0, len = gf_bs_read_u8(mdia->nalu_parser);\\n\\t\\t\\t\\twhile (done<len) {\\n\\t\\t\\t\\t\\tu8 c = gf_bs_read_u8(mdia->nalu_parser);\\n\\t\\t\\t\\t\\tdone++;\\n\\t\\t\\t\\t\\tif (header_written) {\\n\\t\\t\\t\\t\\t\\tgf_bs_write_u8(mdia->nalu_out_bs, c);\\n\\t\\t\\t\\t\\t} else if (done==nal_unit_size_field) {\\n\\t\\t\\t\\t\\t\\tif (rewrite_start_codes) {\\n\\t\\t\\t\\t\\t\\t\\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tgf_bs_write_u8(mdia->nalu_out_bs, c);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\theader_written = GF_TRUE;\\n\\t\\t\\t\\t\\t} else if (!rewrite_start_codes) {\\n\\t\\t\\t\\t\\t\\tgf_bs_write_u8(mdia->nalu_out_bs, c);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tref_track_index = gf_bs_read_u8(mdia->nalu_parser);\\n\\t\\t\\tsample_offset = (s8) gf_bs_read_int(mdia->nalu_parser, 8);\\n\\t\\t\\tdata_offset = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\\n\\t\\t\\tdata_length = gf_bs_read_int(mdia->nalu_parser, nal_unit_size_field*8);\\n\\n\\t\\t\\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &dpnd);\\n\\t\\t\\tref_track_num = 0;\\n\\t\\t\\tif (dpnd && ref_track_index && (ref_track_index<=dpnd->trackIDCount))\\n\\t\\t\\t\\tref_track_num = gf_isom_get_track_by_id(file, dpnd->trackIDs[ref_track_index-1]);\\n\\n\\t\\t\\tif (!ref_track_num) {\\n\\t\\t\\t\\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\\\"ISOBMF: Extractor target track is not present in file - skipping.\\\\n\\\"));\\n\\t\\t\\t\\treturn GF_OK;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcur_extract_mode = gf_isom_get_nalu_extract_mode(file, ref_track_num);\\n\\n\\t\\t\\t//we must be in inspect mode only otherwise the reference sample will not be the one stored on file (change in start codes, PS inserted or other NALUs inserted)\\n\\t\\t\\t//and this will corrupt extraction (wrong data offsets)\\n\\t\\t\\tref_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT;\\n\\t\\t\\tgf_isom_set_nalu_extract_mode(file, ref_track_num, ref_extract_mode);\\n\\n\\t\\t\\tref_trak = gf_isom_get_track_from_file(file, ref_track_num);\\n\\t\\t\\tif (!ref_trak) return GF_ISOM_INVALID_FILE;\\n\\n\\t\\t\\tif (!mdia->extracted_samp) {\\n\\t\\t\\t\\tmdia->extracted_samp = gf_isom_sample_new();\\n\\t\\t\\t\\tif (!mdia->extracted_samp) return GF_IO_ERR;\\n\\t\\t\\t}\\n\\t\\t\\tif (!mdia->extracted_bs) {\\n\\t\\t\\t\\tmdia->extracted_bs = gf_bs_new(\\\"a\\\", 1, GF_BITSTREAM_READ);\\n\\t\\t\\t\\tif (!mdia->extracted_bs) return GF_IO_ERR;\\n\\t\\t\\t}\\n\\n\\t\\t\\te = stbl_findEntryForTime(ref_trak->Media->information->sampleTable, sampleDTS, 0, &ref_sample_num, &prev_ref_sample_num);\\n\\t\\t\\tif (e) return e;\\n\\t\\t\\tif (!ref_sample_num) ref_sample_num = prev_ref_sample_num;\\n\\t\\t\\tif (!ref_sample_num) return GF_ISOM_INVALID_FILE;\\n\\t\\t\\tif ((sample_offset<0) && (ref_sample_num > (u32) -sample_offset)) return GF_ISOM_INVALID_FILE;\\n\\t\\t\\tref_sample_num = (u32) ( (s32) ref_sample_num + sample_offset);\\n\\n\\t\\t\\te = Media_GetSample(ref_trak->Media, ref_sample_num, &mdia->extracted_samp, &di, GF_FALSE, NULL);\\n\\t\\t\\tif (e) return e;\\n\\t\\t\\tif (!mdia->extracted_samp->alloc_size)\\n\\t\\t\\t\\tmdia->extracted_samp->alloc_size = mdia->extracted_samp->dataLength;\\n#if 0\\n\\t\\t\\tif (!header_written && rewrite_start_codes) {\\n\\t\\t\\t\\tgf_bs_write_int(dst_bs, 1, 32);\\n\\t\\t\\t\\tif (is_hevc) {\\n\\t\\t\\t\\t\\tgf_bs_write_int(dst_bs, 0, 1);\\n\\t\\t\\t\\t\\tgf_bs_write_int(dst_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\\n\\t\\t\\t\\t\\tgf_bs_write_int(dst_bs, 0, 9);\\n\\t\\t\\t\\t\\t/*pic-type - by default we signal all slice types possible*/\\n\\t\\t\\t\\t\\tgf_bs_write_int(dst_bs, 2, 3);\\n\\t\\t\\t\\t\\tgf_bs_write_int(dst_bs, 0, 5);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgf_bs_write_int(dst_bs, (ref_samp->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\\n\\t\\t\\t\\t\\tgf_bs_write_int(dst_bs, 0xF0 , 8); /*7 \\\"all supported NALUs\\\" (=111) + rbsp trailing (10000)*/;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n#endif\\n\\t\\t\\tgf_bs_reassign_buffer(mdia->extracted_bs, mdia->extracted_samp->data + data_offset, mdia->extracted_samp->dataLength - data_offset);\\n\\n\\t\\t\\tif (mdia->extracted_samp->dataLength - data_offset >= data_length) {\\n\\n\\t\\t\\t\\twhile (data_length && gf_bs_available(mdia->extracted_bs)) {\\n\\t\\t\\t\\t\\tif (!header_written) {\\n\\t\\t\\t\\t\\t\\tref_nalu_size = gf_bs_read_int(mdia->extracted_bs, 8*nal_unit_size_field);\\n\\n\\t\\t\\t\\t\\t\\tassert(data_length>nal_unit_size_field);\\n\\t\\t\\t\\t\\t\\tdata_length -= nal_unit_size_field;\\n\\t\\t\\t\\t\\t\\tif (data_length > gf_bs_available(mdia->extracted_bs)) {\\n\\t\\t\\t\\t\\t\\t\\tdata_length = (u32)gf_bs_available(mdia->extracted_bs);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tref_nalu_size = data_length;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (ref_nalu_size > mdia->tmp_nal_copy_buffer_alloc) {\\n\\t\\t\\t\\t\\t\\tmdia->tmp_nal_copy_buffer_alloc = ref_nalu_size;\\n\\t\\t\\t\\t\\t\\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * ref_nalu_size );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgf_bs_read_data(mdia->extracted_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\\n\\n\\t\\t\\t\\t\\tif (!header_written) {\\n\\t\\t\\t\\t\\t\\tif (rewrite_start_codes)\\n\\t\\t\\t\\t\\t\\t\\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tgf_bs_write_int(mdia->nalu_out_bs, ref_nalu_size, 8*nal_unit_size_field);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tassert(data_length >= ref_nalu_size);\\n\\t\\t\\t\\t\\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, ref_nalu_size);\\n\\t\\t\\t\\t\\tdata_length -= ref_nalu_size;\\n\\n\\t\\t\\t\\t\\theader_written = GF_FALSE;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\\\"ISOBMF: Extractor size is larger than referred sample size - skipping.\\\\n\\\"));\\n\\t\\t\\t}\\n\\t\\t\\tgf_isom_set_nalu_extract_mode(file, ref_track_num, cur_extract_mode);\\n\\n\\t\\t\\tif (!is_hevc) break;\\n\\t\\t}\\n\\t\\tbreak;\\n\\tcase 1:\\n\\t\\t//skip to end of this NALU\\n\\t\\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size - nb_bytes_nalh);\\n\\t\\tbreak;\\n\\tcase 2:\\n\\t\\tif (nal_size - nb_bytes_nalh > mdia->tmp_nal_copy_buffer_alloc) {\\n\\t\\t\\tmdia->tmp_nal_copy_buffer_alloc = nal_size - nb_bytes_nalh;\\n\\t\\t\\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char) * (nal_size - nb_bytes_nalh) );\\n\\t\\t}\\n\\t\\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\\n\\t\\tif (rewrite_start_codes)\\n\\t\\t\\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\\n\\t\\telse\\n\\t\\t\\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\\n\\n\\t\\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\\n\\t\\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size - nb_bytes_nalh);\\n\\t\\tbreak;\\n\\t}\\n\\treturn GF_OK;\\n}\\n\",\n            \"caller_start\": 101,\n            \"file_path\": \"src/isomedia/avc_ext.c\"\n          },\n          {\n            \"call_line\": 1916,\n            \"call_code\": \"Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset)\",\n            \"caller_code\": \"GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\\n{\\n\\tGF_Err e;\\n\\tu32 descIndex;\\n\\tGF_TrackBox *trak;\\n\\tGF_ISOSample *samp;\\n\\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\\n\\tif (!trak) return NULL;\\n\\n\\tif (!sampleNumber) return NULL;\\n\\tif (static_sample) {\\n\\t\\tsamp = static_sample;\\n\\t\\tif (static_sample->dataLength && !static_sample->alloc_size)\\n\\t\\t\\tstatic_sample->alloc_size = static_sample->dataLength;\\n\\t} else {\\n\\t\\tsamp = gf_isom_sample_new();\\n\\t}\\n\\tif (!samp) return NULL;\\n\\n#ifndef\\tGPAC_DISABLE_ISOM_FRAGMENTS\\n\\tif (sampleNumber<=trak->sample_count_at_seg_start)\\n\\t\\treturn NULL;\\n\\tsampleNumber -= trak->sample_count_at_seg_start;\\n#endif\\n\\n\\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\\n\\tif (static_sample && !static_sample->alloc_size)\\n\\t\\tstatic_sample->alloc_size = static_sample->dataLength;\\n\\n\\tif (e) {\\n\\t\\tgf_isom_set_last_error(the_file, e);\\n\\t\\tif (!static_sample) gf_isom_sample_del(&samp);\\n\\t\\treturn NULL;\\n\\t}\\n\\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\\n#ifndef\\tGPAC_DISABLE_ISOM_FRAGMENTS\\n\\tif (samp) samp->DTS += trak->dts_at_seg_start;\\n#endif\\n\\n\\treturn samp;\\n}\\n\",\n            \"caller_start\": 1891,\n            \"file_path\": \"src/isomedia/isom_read.c\"\n          },\n          {\n            \"call_line\": 2069,\n            \"call_code\": \"Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset)\",\n            \"caller_code\": \"GF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\\n{\\n\\tGF_Err e;\\n\\tGF_TrackBox *trak;\\n\\tGF_ISOSample *samp;\\n\\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\\n\\tif (!trak) return NULL;\\n\\n\\tif (!sampleNumber) return NULL;\\n#ifndef\\tGPAC_DISABLE_ISOM_FRAGMENTS\\n\\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\\n\\tsampleNumber -= trak->sample_count_at_seg_start;\\n#endif\\n\\tif (static_sample) {\\n\\t\\tsamp = static_sample;\\n\\t} else {\\n\\t\\tsamp = gf_isom_sample_new();\\n\\t\\tif (!samp) return NULL;\\n\\t}\\n\\n\\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\\n\\tif (e) {\\n\\t\\tgf_isom_set_last_error(the_file, e);\\n\\t\\tif (!static_sample)\\n\\t\\t\\tgf_isom_sample_del(&samp);\\n\\t\\treturn NULL;\\n\\t}\\n#ifndef\\tGPAC_DISABLE_ISOM_FRAGMENTS\\n\\tif (samp) samp->DTS += trak->dts_at_seg_start;\\n#endif\\n\\treturn samp;\\n}\",\n            \"caller_start\": 2049,\n            \"file_path\": \"src/isomedia/isom_read.c\"\n          },\n          {\n            \"call_line\": 2266,\n            \"call_code\": \"Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset)\",\n            \"caller_code\": \"GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\\n{\\n\\tGF_Err e;\\n\\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\\n\\tGF_TrackBox *trak;\\n\\tGF_ISOSample *shadow;\\n\\tGF_SampleTableBox *stbl;\\n\\tBool static_sample = GF_FALSE;\\n\\tu8 useShadow, IsSync;\\n\\n\\tif (SampleNum) *SampleNum = 0;\\n\\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\\n\\tif (!trak) return GF_BAD_PARAM;\\n\\n\\tstbl = trak->Media->information->sampleTable;\\n\\n#ifndef\\tGPAC_DISABLE_ISOM_FRAGMENTS\\n\\tif (desiredTime < trak->dts_at_seg_start) {\\n\\t\\tdesiredTime = 0;\\n\\t} else {\\n\\t\\tdesiredTime -= trak->dts_at_seg_start;\\n\\t}\\n#endif\\n\\n\\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\\n\\tif (e) return e;\\n\\n\\t//if no shadow table, reset to sync only\\n\\tuseShadow = 0;\\n\\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\\n\\t\\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\\n\\n\\t//if no syncTable, disable syncSearching, as all samples ARE sync\\n\\tif (! trak->Media->information->sampleTable->SyncSample) {\\n\\t\\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\\n\\t\\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\\n\\t}\\n\\n\\t//not found, return EOF or browse backward\\n\\tif (!sampleNumber && !prevSampleNumber) {\\n\\t\\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\\n\\t\\t\\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\\n\\t\\t}\\n\\t\\tif (!sampleNumber) return GF_EOS;\\n\\t}\\n\\n\\t//check in case we have the perfect sample\\n\\tIsSync = 0;\\n\\n\\t//according to the direction adjust the sampleNum value\\n\\tswitch (SearchMode) {\\n\\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\\n\\t\\tIsSync = 1;\\n\\tcase GF_ISOM_SEARCH_FORWARD:\\n\\t\\t//not the exact one\\n\\t\\tif (!sampleNumber) {\\n\\t\\t\\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\\n\\t\\t\\t\\tsampleNumber = prevSampleNumber + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsampleNumber = prevSampleNumber;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbreak;\\n\\n\\t//if dummy mode, reset to default browsing\\n\\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\\n\\t\\tIsSync = 1;\\n\\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\\n\\tcase GF_ISOM_SEARCH_BACKWARD:\\n\\tdefault:\\n\\t\\t//first case, not found....\\n\\t\\tif (!sampleNumber && !prevSampleNumber) {\\n\\t\\t\\tsampleNumber = stbl->SampleSize->sampleCount;\\n\\t\\t} else if (!sampleNumber) {\\n\\t\\t\\tsampleNumber = prevSampleNumber;\\n\\t\\t}\\n\\t\\tbreak;\\n\\t}\\n\\n\\t//get the sync sample num\\n\\tif (IsSync) {\\n\\t\\t//get the SyncNumber\\n\\t\\te = Media_FindSyncSample(trak->Media->information->sampleTable,\\n\\t\\t                         sampleNumber, &syncNum, SearchMode);\\n\\t\\tif (e) return e;\\n\\t\\tif (syncNum) sampleNumber = syncNum;\\n\\t\\tsyncNum = 0;\\n\\t}\\n\\t//if we are in shadow mode, get the previous sync sample\\n\\t//in case we can't find a good SyncShadow\\n\\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\\n\\t\\t//get the SyncNumber\\n\\t\\te = Media_FindSyncSample(trak->Media->information->sampleTable,\\n\\t\\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\\n\\t\\tif (e) return e;\\n\\t}\\n\\n\\n\\t//OK sampleNumber is exactly the sample we need (except for shadow)\\n\\n\\tif (sample) {\\n\\t\\tif (*sample) {\\n\\t\\t\\tstatic_sample = GF_TRUE;\\n\\t\\t} else {\\n\\t\\t\\t*sample = gf_isom_sample_new();\\n\\t\\t\\tif (*sample == NULL) return GF_OUT_OF_MEM;\\n\\t\\t}\\n\\t}\\n\\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\\n\\t//the desired sample...\\n\\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\\n\\t\\t//get the shadowing number\\n\\t\\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\\n\\t\\t//now sampleNumber is the closest previous shadowed sample.\\n\\t\\t//1- If we have a closer sync sample, use it.\\n\\t\\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\\n\\t\\tif ((sampleNumber < syncNum) || (!shadowSync)) {\\n\\t\\t\\tsampleNumber = syncNum;\\n\\t\\t} else {\\n\\t\\t\\t//otherwise, we have a better alternate sample in the shadowSync for this sample\\n\\t\\t\\tuseShadow = 1;\\n\\t\\t}\\n\\t}\\n\\n\\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\\n\\tif (e) {\\n\\t\\tif (!static_sample)\\n\\t\\t\\tgf_isom_sample_del(sample);\\n\\t\\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\\n\\t\\t \\t(*sample)->alloc_size =  (*sample)->dataLength;\\n\\n\\t\\treturn e;\\n\\t}\\n\\tif (sample && ! (*sample)->IsRAP) {\\n\\t\\tBool is_rap;\\n\\t\\tGF_ISOSampleRollType roll_type;\\n\\t\\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\\n\\t\\tif (e) return e;\\n\\t\\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\\n\\t}\\n\\t//optionally get the sample number\\n\\tif (SampleNum) {\\n\\t\\t*SampleNum = sampleNumber;\\n#ifndef\\tGPAC_DISABLE_ISOM_FRAGMENTS\\n\\t\\t*SampleNum += trak->sample_count_at_seg_start;\\n#endif\\n\\t}\\n\\n\\t//in shadow mode, we only get the data of the shadowing sample !\\n\\tif (sample && useShadow) {\\n\\t\\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\\n\\t\\t//though this is unlikely as non optimized...\\n\\t\\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\\n\\t\\t//if no sample, the shadowSync is broken, return the sample\\n\\t\\tif (!shadow) return GF_OK;\\n\\t\\t(*sample)->IsRAP = RAP;\\n\\t\\tgf_free((*sample)->data);\\n\\t\\t(*sample)->dataLength = shadow->dataLength;\\n\\t\\t(*sample)->data = shadow->data;\\n\\t\\t//set data length to 0 to keep the buffer alive...\\n\\t\\tshadow->dataLength = 0;\\n\\t\\tgf_isom_sample_del(&shadow);\\n\\t}\\n\\tif (static_sample && ! (*sample)->alloc_size )\\n\\t\\t (*sample)->alloc_size =  (*sample)->dataLength;\\n\\t\\t \\n\\treturn GF_OK;\\n}\\n\",\n            \"caller_start\": 2142,\n            \"file_path\": \"src/isomedia/isom_read.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence* ≥ 0.90.  Incomplete chain ≤ 0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth** – Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction** – `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition** – Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The vulnerability stems from infinite recursion in Media_GetSample (media.c), triggered via gf_media_split_hevc_tiles → gf_isom_get_sample → Media_GetSample. The patch in isom_tools.c prevents null dereference but does not resolve the recursion. Media_GetSample calls stbl_findEntryForTime and potentially re-enters via Media_RewriteODFrame/gf_isom_nalu_sample_rewrite, but their implementations are missing. The exact recursive path requires these functions' code.",
                "need_context": true,
                "required_context": [
                    "function: Media_RewriteODFrame in isomedia/media.c",
                    "function: gf_isom_nalu_sample_rewrite in isomedia/isom_nalu.c",
                    "caller: callers of Media_RewriteODFrame in isomedia/media.c"
                ],
                "root_cause": "Infinite recursion occurs in Media_GetSample (media.c:467-680) when processing samples via gf_media_split_hevc_tiles (isom_tools.c:3544) → gf_isom_get_sample (isom_read.c:1891) → Media_GetSample. The recursion likely involves Media_RewriteODFrame or gf_isom_nalu_sample_rewrite, which may re-trigger Media_GetSample without proper termination. The patch adds a null check but does not address the recursive call chain.",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-29T22:17:09.047703"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: Media_RewriteODFrame in isomedia/media.c",
                "function: gf_isom_nalu_sample_rewrite in isomedia/isom_nalu.c",
                "caller: callers of Media_RewriteODFrame in isomedia/media.c"
            ],
            "results": [
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'Media_RewriteODFrame', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_ODCodec *ODdecode;\n\tGF_ODCodec *ODencode;\n\tGF_ODCom *com;\n\n\t//the commands we proceed\n\tGF_ESDUpdate *esdU, *esdU2;\n\tGF_ESDRemove *esdR, *esdR2;\n\tGF_ODUpdate *odU, *odU2;\n\n\t//the desc they contain\n\tGF_ObjectDescriptor *od;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_ESD *esd;\n\tGF_ES_ID_Ref *ref;\n\tGF_Descriptor *desc;\n\tGF_TrackReferenceTypeBox *mpod;\n\tu32 i, j, skipped;\n\n\tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n\n\tmpod = NULL;\n\te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n\tif (e) return e;\n\t//no references, nothing to do...\n\tif (!mpod || !mpod->trackIDs) return GF_OK;\n\n\tODdecode = gf_odf_codec_new();\n\tif (!ODdecode) return GF_OUT_OF_MEM;\n\tODencode = gf_odf_codec_new();\n\tif (!ODencode) {\n\t\tgf_odf_codec_del(ODdecode);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n\tif (e) goto err_exit;\n\te = gf_odf_codec_decode(ODdecode);\n\tif (e) goto err_exit;\n\n\twhile (1) {\n\t\tcom = gf_odf_codec_get_com(ODdecode);\n\t\tif (!com) break;\n\n\t\t//we only need to rewrite commands with ESDs inside: ESDUpdate and ODUpdate\n\t\tswitch (com->tag) {\n\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\todU = (GF_ODUpdate *) com;\n\t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\n\t\t\ti=0;\n\t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n\t\t\t\tswitch (desc->tag) {\n\t\t\t\tcase GF_ODF_OD_TAG:\n\t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n\t\t\t\t//IOD can be used in OD streams\n\t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n\t\t\t\tif (e) goto err_exit;\n\n\t\t\t\t//create our OD...\n\t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\t\t\t} else {\n\t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\t\t\t}\n\t\t\t\tif (!od) {\n\t\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tod->ESDescriptors = gf_list_new();\n\t\t\t\t//and duplicate...\n\t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\t\t\tod->tag = GF_ODF_OD_TAG;\n\t\t\t\tod->URLString = isom_od->URLString;\n\t\t\t\tisom_od->URLString = NULL;\n\t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\t\t\tisom_od->extensionDescriptors = NULL;\n\t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\t\t\tisom_od->IPMP_Descriptors = NULL;\n\t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\t\t\tisom_od->OCIDescriptors = NULL;\n\n\t\t\t\t//init as IOD\n\t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n\t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n\t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n\t\t\t\t}\n\n\t\t\t\t//then rewrite the ESDesc\n\t\t\t\tj=0;\n\t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t\t//OK, get the esd\n\t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t//delete our desc\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n\t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n\t\t\t}\n\t\t\t//clean a bit\n\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n\t\t\tbreak;\n\n\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\tesdU = (GF_ESDUpdate *) com;\n\t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tesdU2->ODID = esdU->ODID;\n\t\t\ti=0;\n\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, skip this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n\t\t\t\t//OK, get the esd\n\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n\t\t\tbreak;\n\n\t\t//brand new case: the ESRemove follows the same principle according to the spec...\n\t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n\t\t\t//both commands have the same structure, only the tags change\n\t\t\tesdR = (GF_ESDRemove *) com;\n\t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR2->ODID = esdR->ODID;\n\t\t\tesdR2->NbESDs = esdR->NbESDs;\n\t\t\t//alloc our stuff\n\t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n\t\t\tif (!esdR2->ES_ID) {\n\t\t\t\te = GF_OUT_OF_MEM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t\t//get the ES_ID in the mpod indicated in the ES_ID[]\n\t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n\t\t\t\t//if the ref index is not valid, remove this desc...\n\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n\t\t\t\t\tskipped ++;\n\t\t\t\t} else {\n\t\t\t\t\t//the command in the file has the ref index of the trackID in the mpod\n\t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//gf_realloc...\n\t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n\t\t\t\tesdR2->NbESDs -= skipped;\n\t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n\t\t\t}\n\t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n\t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\te = gf_odf_codec_add_com(ODencode, com);\n\t\t\tif (e) goto err_exit;\n\t\t}\n\t}\n\t//encode our new AU\n\te = gf_odf_codec_encode(ODencode, 1);\n\tif (e) goto err_exit;\n\n\t//and set the buffer in the sample\n\tgf_free(sample->data);\n\tsample->data = NULL;\n\tsample->dataLength = 0;\n\te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n\nerr_exit:\n\tgf_odf_codec_del(ODdecode);\n\tgf_odf_codec_del(ODencode);\n\treturn e;\n}\n",
                            "start_line": 31,
                            "end_line": 229,
                            "full_name": "Media_RewriteODFrame",
                            "file_path": "src/isomedia/media_odf.c"
                        }
                    ]
                },
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'gf_isom_nalu_sample_rewrite', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "GF_Err gf_isom_nalu_sample_rewrite(GF_MediaBox *mdia, GF_ISOSample *sample, u32 sampleNumber, GF_MPEGVisualSampleEntryBox *entry)\n{\n\tBool is_hevc = GF_FALSE;\n\t//if only one sync given in the sample sync table, insert sps/pps/vps before cra/bla in hevc\n//\tBool check_cra_bla = (mdia->information->sampleTable->SyncSample && mdia->information->sampleTable->SyncSample->nb_entries>1) ? 0 : 1;\n\tBool check_cra_bla = GF_TRUE;\n\tBool insert_nalu_delim = GF_TRUE;\n\tBool force_sei_inspect = GF_FALSE;\n\tGF_Err e = GF_OK;\n\tGF_BitStream *sei_suffix_bs = NULL;\n\tBool ps_transfered = GF_FALSE;\n\tu32 nal_size, nal_unit_size_field, extractor_mode;\n\tBool rewrite_ps, rewrite_start_codes, insert_vdrd_code;\n\tu8 nal_type;\n\tu32 nal_hdr, sabt_ref, i, track_num;\n\tu32 temporal_id = 0;\n\tGF_ISOFile *file = mdia->mediaTrack->moov->mov;\n\tGF_TrackReferenceTypeBox *scal = NULL;\n\n\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_SCAL, &scal);\n\n\trewrite_ps = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG) ? GF_TRUE : GF_FALSE;\n\trewrite_start_codes = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG) ? GF_TRUE : GF_FALSE;\n\tinsert_vdrd_code = (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_VDRD_FLAG) ? GF_TRUE : GF_FALSE;\n\tif (!entry->svc_config && !entry->mvc_config && !entry->lhvc_config) insert_vdrd_code = GF_FALSE;\n\textractor_mode = mdia->mediaTrack->extractor_mode&0x0000FFFF;\n\n\tif (mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) {\n\t\tinsert_nalu_delim = GF_FALSE;\n\t}\n\n\ttrack_num = 1 + gf_list_find(mdia->mediaTrack->moov->trackList, mdia->mediaTrack);\n\n\tif ( (extractor_mode != GF_ISOM_NALU_EXTRACT_INSPECT) && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_TILE_ONLY) ) {\n\t\tu32 ref_track, di;\n\t\t//aggregate all sabt samples with the same DTS\n\t\tif (entry->lhvc_config && !entry->hevc_config && !(mdia->mediaTrack->extractor_mode & GF_ISOM_NALU_EXTRACT_LAYER_ONLY)) {\n\t\t\tif (gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SCAL) <= 0) {\n\t\t\t\t//FIXME - for now we only support two layers (base + enh) in implicit\n\t\t\t\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE) >= 1) {\n\t\t\t\t\tGF_ISOSample *base_samp;\n\t\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_BASE, 1, &ref_track);\n\t\t\t\t\tswitch (gf_isom_get_media_subtype(mdia->mediaTrack->moov->mov , ref_track, 1)) {\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\n\t\t\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbase_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\t\t\tif (base_samp && base_samp->data) {\n\t\t\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+base_samp->dataLength) ) {\n\t\t\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+base_samp->dataLength);\n\t\t\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+base_samp->dataLength;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemmove(sample->data + base_samp->dataLength, sample->data , sample->dataLength);\n\t\t\t\t\t\t\tmemcpy(sample->data, base_samp->data, base_samp->dataLength);\n\t\t\t\t\t\t\tsample->dataLength += base_samp->dataLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTrack_FindRef(mdia->mediaTrack, GF_ISOM_REF_BASE, &scal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsabt_ref = gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT);\n\t\tif ((s32) sabt_ref > 0) {\n\t\t\tforce_sei_inspect = GF_TRUE;\n\t\t\tfor (i=0; i<sabt_ref; i++) {\n\t\t\t\tGF_ISOSample *tile_samp;\n\t\t\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_SABT, i+1, &ref_track);\n\n\t\t\t\tif (!mdia->extracted_samp) {\n\t\t\t\t\tmdia->extracted_samp = gf_isom_sample_new();\n\t\t\t\t\tif (!mdia->extracted_samp) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\n\t\t\t\ttile_samp = gf_isom_get_sample_ex(mdia->mediaTrack->moov->mov, ref_track, sampleNumber + mdia->mediaTrack->sample_count_at_seg_start, &di, mdia->extracted_samp, NULL);\n\t\t\t\tif (tile_samp  && tile_samp ->data) {\n\t\t\t\t\tif (!sample->alloc_size || (sample->alloc_size<sample->dataLength+tile_samp->dataLength) ) {\n\t\t\t\t\t\tsample->data = gf_realloc(sample->data, sample->dataLength+tile_samp->dataLength);\n\t\t\t\t\t\tif (sample->alloc_size) sample->alloc_size = sample->dataLength+tile_samp->dataLength;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(sample->data + sample->dataLength, tile_samp->data, tile_samp->dataLength);\n\t\t\t\t\tsample->dataLength += tile_samp->dataLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( gf_isom_get_reference_count(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS) >= 1) {\n\t\tu32 ref_track;\n\t\tu32 idx = gf_list_find(mdia->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\tGF_TrackBox *tbas;\n\t\tgf_isom_get_reference(mdia->mediaTrack->moov->mov, track_num, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\ttbas = (GF_TrackBox *)gf_list_get(mdia->mediaTrack->moov->trackList, ref_track-1);\n\t\tentry = gf_list_get(tbas->Media->information->sampleTable->SampleDescription->child_boxes, idx);\n\t}\n\n\n\tif (sample->IsRAP < SAP_TYPE_2) {\n\t\tif (mdia->information->sampleTable->no_sync_found || (!sample->IsRAP && check_cra_bla) ) {\n\t\t\tsample->IsRAP = is_sample_idr(mdia, sample, entry);\n\t\t}\n\t}\n\tif (!sample->IsRAP)\n\t\trewrite_ps = GF_FALSE;\n\n\tif (extractor_mode != GF_ISOM_NALU_EXTRACT_LAYER_ONLY)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (!entry) return GF_BAD_PARAM;\n\n\t//this is a compatible HEVC, don't insert VDRD, insert NALU delim\n\tif (entry->lhvc_config && entry->hevc_config)\n\t\tinsert_vdrd_code = GF_FALSE;\n\n\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_INSPECT) {\n\t\tif (!rewrite_ps && !rewrite_start_codes)\n\t\t\treturn GF_OK;\n\t}\n\n\tnal_unit_size_field = 0;\n\t/*if svc rewrite*/\n\tif (entry->svc_config && entry->svc_config->config)\n\t\tnal_unit_size_field = entry->svc_config->config->nal_unit_size;\n\t/*if mvc rewrite*/\n\tif (entry->mvc_config && entry->mvc_config->config)\n\t\tnal_unit_size_field = entry->mvc_config->config->nal_unit_size;\n\n\t/*if lhvc rewrite*/\n\telse if (entry->lhvc_config && entry->lhvc_config->config)  {\n\t\tis_hevc = GF_TRUE;\n\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t}\n\n\t/*otherwise do nothing*/\n\telse if (!rewrite_ps && !rewrite_start_codes && !scal && !force_sei_inspect) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!nal_unit_size_field) {\n\t\tif (entry->avc_config && entry->avc_config->config)\n\t\t\tnal_unit_size_field = entry->avc_config->config->nal_unit_size;\n\t\telse if (entry->lhvc_config && entry->lhvc_config->config) {\n\t\t\tnal_unit_size_field = entry->lhvc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t\telse if (entry->hevc_config && entry->hevc_config->config) {\n\t\t\tnal_unit_size_field = entry->hevc_config->config->nal_unit_size;\n\t\t\tis_hevc = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!nal_unit_size_field) return GF_ISOM_INVALID_FILE;\n\n\t//setup PS rewriter\n\tif (!mdia->nalu_ps_bs)\n\t\tmdia->nalu_ps_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_seek(mdia->nalu_ps_bs, 0);\n\n\t//setup sample reader\n\tif (mdia->in_sample_buffer_alloc<sample->dataLength) {\n\t\tmdia->in_sample_buffer_alloc = sample->dataLength;\n\t\tmdia->in_sample_buffer = gf_realloc(mdia->in_sample_buffer, sample->dataLength);\n\t}\n\tmemcpy(mdia->in_sample_buffer, sample->data, sample->dataLength);\n\n\tif (!mdia->nalu_parser) {\n\t\tmdia->nalu_parser = gf_bs_new(mdia->in_sample_buffer, sample->dataLength, GF_BITSTREAM_READ);\n\t\tif (!mdia->nalu_parser && sample->data) return GF_ISOM_INVALID_FILE;\n\t} else {\n\t\te = gf_bs_reassign_buffer(mdia->nalu_parser, mdia->in_sample_buffer, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\t//setup output\n\tif (!mdia->nalu_out_bs) {\n\t\tu8 *output;\n\t\tu32 outSize;\n\t\tmdia->nalu_out_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_get_content(mdia->nalu_out_bs, &output, &outSize);\n\t}\n\n\tgf_bs_reassign_buffer(mdia->nalu_out_bs, sample->data, sample->alloc_size ? sample->alloc_size : sample->dataLength);\n\n\t/*rewrite start code with NALU delim*/\n\tif (rewrite_start_codes) {\n\n\t\t//we are SVC, don't write NALU delim, only insert VDRD NALU\n\t\tif (insert_vdrd_code) {\n\t\t\tif (is_hevc) {\n\t\t\t\t//spec is not clear here, we don't insert an NALU AU delimiter before the layer starts since it breaks openHEVC\n//\t\t\t\tinsert_nalu_delim=0;\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_AVC_NALU_VDRD , 8);\n\t\t\t\tinsert_nalu_delim=0;\n\t\t\t}\n\t\t}\n\n\t\t//AVC/HEVC base, insert NALU delim\n\t\tif (insert_nalu_delim) {\n\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 32);\n\t\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 1);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, GF_HEVC_NALU_ACCESS_UNIT, 6);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, insert_vdrd_code ? 1 : 0, 6); //we should pick the layerID of the following nalus ...\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 1, 3); //nuh_temporal_id_plus1 - cannot be 0, we use 1 by default, and overwrite it if needed at the end\n\n\t\t\t\t/*pic-type - by default we signal all slice types possible*/\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 2, 3);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0, 5);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, (sample->data[0] & 0x60) | GF_AVC_NALU_ACCESS_UNIT, 8);\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, 0xF0 , 8); /*7 \"all supported NALUs\" (=111) + rbsp trailing (10000)*/;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rewrite_ps) {\n\t\tBool has_vps = GF_FALSE;\n\t\t//in inspect mode or single-layer mode just use the xPS from this layer\n\t\tif (extractor_mode == GF_ISOM_NALU_EXTRACT_DEFAULT) {\n\t\t\tif (scal) {\n\t\t\t\tfor (i=0; i<scal->trackIDCount; i++) {\n\t\t\t\t\tGF_TrackBox *a_track = GetTrackbyID(mdia->mediaTrack->moov, scal->trackIDs[i]);\n\t\t\t\t\tGF_MPEGVisualSampleEntryBox *an_entry = NULL;\n\t\t\t\t\tif (a_track && a_track->Media && a_track->Media->information && a_track->Media->information->sampleTable && a_track->Media->information->sampleTable->SampleDescription)\n\t\t\t\t\t\tan_entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(a_track->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\n\t\t\t\t\tif (an_entry)\n\t\t\t\t\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, an_entry, is_hevc, &has_vps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnalu_merge_ps(mdia->nalu_ps_bs, rewrite_start_codes, nal_unit_size_field, entry, is_hevc, &has_vps);\n\n\n\t\tif (is_hevc) {\n\t\t\t/*little optimization if we are not asked to start codes: copy over the sample*/\n\t\t\tif (!rewrite_start_codes && !entry->lhvc_config && !scal) {\n\t\t\t\tif (! ps_transfered) {\n\t\t\t\t\tnal_type = (sample->data[nal_unit_size_field] & 0x7E) >> 1;\n\t\t\t\t\t//temp fix - if we detect xPS in the beginning of the sample do NOT copy the ps bitstream\n\t\t\t\t\t//this is not correct since we are not sure whether they are the same xPS or not, but it crashes openHEVC ...\n\t\t\t\t\tswitch (nal_type) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\t\t\tbreak;\n#endif\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\t\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tps_transfered = GF_TRUE;\n\t}\n\n\t/*little optimization if we are not asked to rewrite extractors or start codes: copy over the sample*/\n\tif (!scal && !rewrite_start_codes && !rewrite_ps && !force_sei_inspect) {\n\t\tif (! ps_transfered)\n\t\t{\n\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t}\n\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->in_sample_buffer, sample->dataLength);\n\t\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\t\treturn GF_OK;\n\t}\n\n\tif (!mdia->tmp_nal_copy_buffer) {\n\t\tmdia->tmp_nal_copy_buffer = gf_malloc(sizeof(char) * 4096);\n\t\tmdia->tmp_nal_copy_buffer_alloc = 4096;\n\t}\n\n\n\twhile (gf_bs_available(mdia->nalu_parser)) {\n\t\tnal_size = gf_bs_read_int(mdia->nalu_parser, 8*nal_unit_size_field);\n\t\tif (gf_bs_get_position(mdia->nalu_parser) + nal_size > sample->dataLength) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"Sample %u (size %u) rewrite: corrupted NAL Unit (size %u)\\n\", sampleNumber, sample->dataLength, nal_size));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (nal_size > mdia->tmp_nal_copy_buffer_alloc) {\n\t\t\tmdia->tmp_nal_copy_buffer_alloc = nal_size;\n\t\t\tmdia->tmp_nal_copy_buffer = (char*) gf_realloc(mdia->tmp_nal_copy_buffer, sizeof(char)*nal_size);\n\t\t}\n\t\tif (is_hevc) {\n\t\t\tnal_hdr = gf_bs_read_u16(mdia->nalu_parser);\n\t\t\tnal_type = (nal_hdr&0x7E00) >> 9;\n\t\t} else {\n\t\t\tnal_hdr = gf_bs_read_u8(mdia->nalu_parser);\n\t\t\tnal_type = nal_hdr & 0x1F;\n\t\t}\n\n\t\tif (is_hevc) {\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tGF_BitStream *write_to_bs = mdia->nalu_out_bs;\n#endif\n\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\n#ifndef GPAC_DISABLE_HEVC\n\t\t\tswitch (nal_type) {\n\t\t\t/*we already wrote AU delim, and we trash aggregators*/\n\t\t\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\t\tcase GF_HEVC_NALU_FF_AGGREGATOR:\n\t\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-2);\n\t\t\t\tcontinue;\n\n\t\t\t//extractor\n\t\t\tcase GF_HEVC_NALU_FF_EXTRACTOR:\n\t\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_TRUE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\t\tif (temporal_id < (nal_hdr & 0x7))\n\t\t\t\t\ttemporal_id = (nal_hdr & 0x7);\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(mdia->nalu_out_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t\tbreak;\n\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t//insert xPS before CRA/BLA\n\t\t\t\tif (check_cra_bla && !sample->IsRAP) {\n\t\t\t\t\tsample->IsRAP = sap_type_from_nal_type(nal_type);\n\t\t\t\t\tif (sei_suffix_bs) gf_bs_del(sei_suffix_bs);\n\t\t\t\t\treturn gf_isom_nalu_sample_rewrite(mdia, sample, sampleNumber, entry);\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t/*rewrite nal*/\n\t\t\t\tif (nal_size<2) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid nal size %d in sample %d\\n\", nal_type, sampleNumber));\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-2);\n\n\t\t\t\tif (nal_type==GF_HEVC_NALU_SEI_SUFFIX) {\n\t\t\t\t\tif (!sei_suffix_bs) sei_suffix_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\t\twrite_to_bs = sei_suffix_bs;\n\t\t\t\t}\n\n\t\t\t\tif (rewrite_start_codes)\n\t\t\t\t\tgf_bs_write_u32(write_to_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(write_to_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\t\tgf_bs_write_u16(write_to_bs, nal_hdr);\n\t\t\t\tgf_bs_write_data(write_to_bs, mdia->tmp_nal_copy_buffer, nal_size-2);\n\t\t\t}\n#endif\n\n\t\t\t//done with HEVC\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(nal_type) {\n\t\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tcase GF_AVC_NALU_FF_AGGREGATOR:\n\t\t\t/*we already wrote this stuff, and we trash aggregators*/\n\t\t\tgf_bs_skip_bytes(mdia->nalu_parser, nal_size-1);\n\t\t\tcontinue;\n\t\t//extractor\n\t\tcase GF_AVC_NALU_FF_EXTRACTOR:\n\t\t\te = process_extractor(file, mdia, sampleNumber, sample->DTS, nal_size, nal_hdr, nal_unit_size_field, GF_FALSE, rewrite_ps, rewrite_start_codes, extractor_mode);\n\t\t\tif (e) goto exit;\n\t\t\tbreak;\n//\t\t\tcase GF_AVC_NALU_SEI:\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\t// we will rewrite the sps/pps if and only if there is no sps/pps in bistream\n\t\t\tif (!ps_transfered) {\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\tdefault:\n\t\t\tif (!ps_transfered) {\n\t\t\t\tgf_bs_transfer(mdia->nalu_out_bs, mdia->nalu_ps_bs, GF_TRUE);\n\t\t\t\tps_transfered = GF_TRUE;\n\t\t\t}\n\t\t\tgf_bs_read_data(mdia->nalu_parser, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t\tif (rewrite_start_codes)\n\t\t\t\tgf_bs_write_u32(mdia->nalu_out_bs, 1);\n\t\t\telse\n\t\t\t\tgf_bs_write_int(mdia->nalu_out_bs, nal_size, 8*nal_unit_size_field);\n\n\t\t\tgf_bs_write_u8(mdia->nalu_out_bs, nal_hdr);\n\t\t\tgf_bs_write_data(mdia->nalu_out_bs, mdia->tmp_nal_copy_buffer, nal_size-1);\n\t\t}\n\t}\n\n\tif (sei_suffix_bs) {\n\t\tgf_bs_transfer(mdia->nalu_out_bs, sei_suffix_bs, GF_FALSE);\n\t}\n\t/*done*/\n\tgf_bs_get_content_no_truncate(mdia->nalu_out_bs, &sample->data, &sample->dataLength, &sample->alloc_size);\n\n\t/*rewrite temporal ID of AU Ddelim NALU (first one)*/\n\tif (rewrite_start_codes && is_hevc && temporal_id) {\n\t\tsample->data[6] = (sample->data[6] & 0xF8) | (temporal_id+1);\n\t}\n\n\nexit:\n\tif (sei_suffix_bs)\n\t\tgf_bs_del(sei_suffix_bs);\n\n\treturn e;\n}\n",
                            "start_line": 401,
                            "end_line": 845,
                            "full_name": "gf_isom_nalu_sample_rewrite",
                            "file_path": "src/isomedia/avc_ext.c"
                        }
                    ]
                },
                {
                    "tool": "caller_info.find_caller_for_func_file({'file_path': 'isomedia/media.c', 'func_name': 'Media_RewriteODFrame', 'project_dir': './storage/result/Part2_result/github/CVE-2022-47662/old_repos/gpac-gpac_aa8fbec'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 655,
                            "call_code": "Media_RewriteODFrame(mdia, *samp)",
                            "caller_code": "GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\t(*samp)->data = (char *) gf_malloc(sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)\n\t\t&& !gf_isom_is_encrypted_entry(entry->type)\n\t) {\n\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\tif (e) return e;\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n",
                            "caller_start": 467,
                            "file_path": "src/isomedia/media.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-29T22:17:24.939015"
        }
    ],
    "debug_trace": [
        "Collected 2 context items. (0 failed)",
        "Performed analysis iteration 1. Needs more context: True. Confidence: 0.75",
        "Collected 2 context items. (0 failed)",
        "Performed analysis iteration 2. Needs more context: True. Confidence: 0.75",
        "Collected 3 context items. (0 failed)",
        "Analysis failed: [Analysis ERROR] Root cause analysis failed"
    ],
    "status": "error",
    "error": "Analysis failed: [Analysis ERROR] Root cause analysis failed"
}