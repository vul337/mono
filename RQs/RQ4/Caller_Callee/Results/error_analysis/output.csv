CVE,LLM Res
CVE-2019-14934,"Unvalidated size parameters in dynamic allocations (e.g., `pdf.c:315`: `sz = pdf->xrefs[i].end - ftell(fp);` → `buf = safe_calloc(sz + 1);`, `pdf.c:1293`: `ascii = safe_calloc(str_len);`). These sizes are derived from untrusted input (PDF xrefs/strings) without explicit bounds checks in the original `malloc`-based code. The patch introduces `safe_calloc`, but its implementation is missing, leaving the exact validation logic (e.g., overflow checks, maximum size limits) unknown."
CVE-2021-3308,"Premature removal of pirqs from `d->pirq_tree` (xen/drivers/passthrough/x86/hvm.c:1072-1075) during unbind caused `free_domain_pirqs` (xen/arch/x86/irq.c:2442-2455) to skip unmapping, leading to vector exhaustion. The patch in `pci_clean_dpci_irq` (xen/drivers/passthrough/x86/hvm.c:1051) clears `pirq_dpci->flags` instead of deleting pirqs from the tree, retaining them for cleanup."
CVE-2017-17044,"1. `p2m_pod_demand_populate` (xen/arch/x86/mm/p2m-pod.c:1114-1117) unconditionally returns `true` after calling `p2m_set_entry`, ignoring its return value. 2. `p2m_set_entry` (xen/arch/x86/mm/p2m.c:536-573) returns the result of `p2m->set_entry`, a function pointer whose x86 implementation is missing. 3. On ARM, `__p2m_set_entry` (xen/arch/arm/p2m.c:777-974) returns `-ENOMEM` when splitting superpages fails due to memory allocation errors. 4. Without the x86 `p2m->set_entry` implementation, it is unknown if similar error codes propagate to `p2m_set_entry`, causing `p2m_pod_demand_populate` to retry infinitely."
CVE-2017-7453,"Unbounded LZW code lengths during GIF decompression → excessive calls to iwgif_record_pixel (src/imagew-gif.c:312) → invalid pixnum → out-of-bounds (xs, ys) in iwgif_record_pixel (src/imagew-gif.c:214-216) → NULL dereference. lzw_init (src/imagew-gif.c:275-291) initializes code lengths but does not constrain dynamic code length growth during decoding (GAP: LZW decoding logic missing)."
CVE-2021-3881,"compression.c:142: Unbounded increment of `code_length` in `mobi_decompress_huffman_internal` risks indexing beyond `mincode_table`/`maxcode_table` bounds. read.c:590: Previous hard-coded loop limit (33) may mismatch `HUFF_CODETABLE_SIZE`, causing incomplete table initialization. The patch adds bounds checks but requires `HUFF_CODETABLE_SIZE`'s definition to validate correctness."
CVE-2016-7977,"The vulnerability occurs because `i_ctx_p->starting_arg_file` remains true during non-initial file operations (e.g., `.libfile` calls). The patch in `zfile.c:1081+` adds a check to reset `starting_arg_file` to false after initial argument file processing. Callers like `zlibfile` (zfile.c:588+) invoke `lib_file_open` for `.libfile` operations. However, the exact SAFER validation logic that evaluates `starting_arg_file` is missing, leaving a gap in the chain."
CVE-2012-1013,"In `check_1_6_dummy` (src/lib/kadm5/srv/svr_principal.c:6), `password = *passptr` is assigned without null validation. If `passptr` is NULL (e.g., due to a create-principal request with no password but `KRB5_KDB_DISALLOW_ALL_TIX`), dereferencing causes a crash. The patch adds `password == NULL` as a guard condition. GAP: Missing how `passptr` is initialized in the caller."
CVE-2022-47021,"1. **Allocation Failure**: ogg_malloc() (external allocator) returns NULL on failure (GAP: implementation not visible).\n2. **Propagation in ogg_sync_buffer**: ogg_sync_buffer() (called in src/opusfile.c:149, 1528) returns NULL if allocation fails (GAP: implementation not visible, but implied by existing checks in op_test).\n3. **Missing NULL Check**: Original code in op_get_data (src/opusfile.c:149) and op_open1 (src/opusfile.c:1528) did not validate the return value of ogg_sync_buffer(), leading to dereference of NULL during memcpy or read operations.\n4. **Patch Fix**: Added NULL checks to return OP_EFAULT instead of dereferencing."
CVE-2018-15861,"src/xkbcomp/expr.c:35-61 (ExprResolveLhs) assigns *field_rtrn = xkb_atom_text(ctx, expr->ident.ident). xkb_atom_text (src/context-priv.c:70-74) calls atom_text (src/atom.c:118-125), which returns NULL if expr->ident.ident is XKB_ATOM_NONE or exceeds table bounds. expr->ident.ident is populated during parsing (unknown location), likely via xkb_intern_atom. If xkb_intern_atom fails (e.g., OOM), it returns XKB_ATOM_NONE, leading to NULL *field_rtrn. Previous unconditional return of true allowed downstream NULL dereference."
CVE-2016-7838,"src/updatedownloader.cpp:192+: UpdateDownloader::CleanLeftovers reads UpdateTempDir from registry storage without validation (pre-patch). The patch adds a check ensuring the path starts with a prefix from GetUniqueTempDirectoryPrefix(). GAP: Implementation of GetUniqueTempDirectoryPrefix() is missing, making it impossible to confirm if the prefix enforces WinSparkle's naming convention or system-specific constraints."
CVE-2016-9438,"In 'file.c:3026-3031', flushline() unconditionally dereferences obuf->input_alt.name->ptr, obuf->input_alt.type->ptr, and obuf->input_alt.value->ptr without null checks. If these fields are null (due to malformed HTML input), a segmentation fault occurs. The patch adds null checks to mitigate this. GAP: The code paths responsible for initializing obuf->input_alt.name, type, and value are unknown, preventing confirmation of whether insufficient input validation or error handling allows these fields to be uninitialized."
CVE-2014-3166,"The root cause lies in `SpdySession::VerifyDomainAuthentication` (net/spdy/spdy_session.cc:715-726) and `QuicClientSession::CanPool` (net/quic/quic_client_session.cc:489-510), which validated certificate names (`ssl_info.cert->VerifyNameMatch`) and eTLD+1 domains (`ChannelIDService::GetDomainForHost`) but did not enforce PKP pin checks during session reuse. Callers like `SpdySessionPool::FindAvailableSession` (net/spdy/spdy_session_pool.cc:188) and `QuicStreamFactory::OnResolution` (net/quic/quic_stream_factory.cc:574) relied on these functions to determine session reuse eligibility. The absence of PKP validation allowed attackers to reuse sessions with mismatched pins."
CVE-2020-13962,Qt's q_SSL_shutdown() (commit 93a803a6de27) causes OpenSSL errors to leak to unrelated QSslSocket instances. The Mumble patch in Server::connectionClosed (src/murmur/Server.cpp:1425-1437) checks if the 'reason' string contains '140E0197' and suppresses error handling. The 'reason' parameter is passed to Server::connectionClosed but its construction from Qt's error system is not visible in the provided code (GAP).
CVE-2022-35926,"In `os/net/ipv6/uip-nd6.c:ns_input()` (lines 194-203), the original loop condition `while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len)` did not account for `UIP_ND6_OPT_HDR_LEN`, allowing invalid option header reads. The patch adds `+ UIP_ND6_OPT_HDR_LEN` to the condition and introduces a check for SLLAO data length. However, the calculation of `uip_l3_icmp_hdr_len` (critical for offset calculation) is missing from the provided context, creating a gap in confirming full mitigation."
CVE-2022-2571,"In `ins_comp_get_next_word_or_line` (src/insexpand.c:3502), `tmp_ptr` is advanced by `compl_length` without verifying that `compl_length` does not exceed the length of `tmp_ptr`, risking a heap-based buffer overflow. The patch adds `compl_length <= (int)STRLEN(tmp_ptr)` to mitigate this. `tmp_ptr` is allocated via `ml_get_buf(...)` (src/insexpand.c:3485). GAP: The origin of `compl_length` is unknown."
CVE-2014-2066,"AuthenticationProcessingFilter2.java:86 invalidates the session post-authentication to prevent reuse of pre-login session IDs. Prior to the patch, Jenkins retained the same session ID across authentication states, allowing attackers to fixate a session ID via crafted links or cookies and hijack it post-login. The exact data flow of how the SecurityContext was tied to the session (and thus how the vulnerability was exploited) depends on the missing HttpSessionContextIntegrationFilter.doFilter implementation."
CVE-2019-12735,"The `openscript` function (src/nvim/getchar.c:1245) lacked a sandbox check via `check_secure()`, enabling `:source!` to bypass security restrictions. The `:source!` command is triggered via `ex_source()` (ex_cmds2.c:2815) → `cmd_source()` (ex_cmds2.c:2830) → `openscript()`. The patch added `check_secure()` to block this in sandboxes."
CVE-2017-13098,"Missing PMS size validation in RSA decryption (JceDefaultTlsCredentialedDecryptor.java:76-80) allowed attackers to infer decryption success via error patterns (Bleichenbacher oracle). The `decrypt` method (JceDefaultTlsCredentialedDecryptor.java) invokes `safeDecryptPreMasterSecret`, but the TLS handshake caller for `decrypt()` remains untraced. Callers include SM2Engine.java:88, ECIESKeyEncapsulation.java:220, and others, but none are TLS-specific. GAP: TLS handshake caller for `decrypt()` during RSA key exchange is unknown."
CVE-2023-5377,"In `gf_isom_set_audio_layout` (src/isomedia/isom_write.c:2504-2550), `layout->channels_count` is copied into `chnl->layout` (line 2543) without prior validation. The patch adds a check to reject `channels_count >= 64` (line 2513+) to prevent downstream misuse. The vulnerability arises when this value is later used in unbounded array operations (e.g., audio processing code) that assume a safe maximum channel count, leading to an out-of-bounds read. GAP: The exact site of the unsafe access (e.g., array indexing using `chnl->layout.channels_count`) is missing from available context."
CVE-2020-12607,"Mishandling of the identity element during elliptic curve operations in `pointZZ_pMul` (src/curveMath.c:75) and `pointZZ_pDouble` (src/curveMath.c:19). These functions are foundational to scalar multiplication and point doubling, which are used in ECDSA. The patch adds explicit checks to return the identity element when encountered. However, the propagation path to verification logic (e.g., `ecdsa_verify`) remains unconfirmed due to missing caller context."
CVE-2020-27828,"In `src/libjasper/jpc/jpc_enc.c:510-514`, `tccp->maxrlvls` is assigned without bounds checking, allowing values exceeding `JPC_MAXRLVLS`. The patch adds a check to reject invalid values, confirming prior unchecked usage could lead to heap overflow. Downstream usage of `tccp->maxrlvls` (e.g., in array indexing or buffer allocation) remains unidentified."
CVE-2016-9815,"Asynchronous aborts from a guest bypass HYP handling due to PSTATE.A being masked during Guest->HYP transitions (commit message). The patch adds checks in do_trap_data_abort_guest (xen/arch/arm/traps.c:2511+) and do_trap_instr_abort_guest (xen/arch/arm/traps.c:2408+) to crash the guest when EAT is set. do_trap_data_abort (xen/arch/arm/arm32/traps.c:64+) routes guest-generated aborts to do_trap_guest_error (xen/arch/arm/traps.c:2744-2757), which calls domain_crash_synchronous(). However, the code unmasking PSTATE.A during Guest->HYP transitions (commit message) is missing, leaving the mechanism to open the abort-catching window unverified."
CVE-2023-35852,"Prior to 6.0.13, SetupSavePath (src/detect-dataset.c:303) allowed absolute paths and directory traversal in 'save' filenames derived from rule input. The 'save' parameter is populated via DetectDatasetParse (src/detect-dataset.c:98), which parses 'rawstr' without validation. This allowed adversary-controlled rules to specify malicious paths (e.g., '/etc/passwd' or '../../tmp/malicious'). The patch adds checks for PathIsAbsolute and SCPathContainsTraversal, but the source of 'rawstr' remains unconfirmed."
CVE-2017-11714,"1. Allocation: scanner_state is stack-allocated in ztoken (psi/ztoken.c:56) and ztokenexec (psi/ztoken.c:166) via gs_scanner_init. 2. Reference: pstate is pushed to operand stack in token_continue (psi/ztoken.c:108) and tokenexec_continue (psi/ztoken.c:184). 3. Dangling Reference: If pstate is freed (exact location UNKNOWN) without clearing the operand stack reference, garbage collector (igc_reloc_struct_ptr in psi/igc.c) processes the freed object. 4. Patch: make_null(osp) in token_continue/tokenexec_continue clears the reference before popping."
CVE-2022-32073,"In wolfSSH_SFTP_RecvRMDIR (src/wolfsftp.c:1597), the original condition `sz + idx > maxSz` allowed integer overflow when `sz` and `idx` summed to a value exceeding 32-bit limits. This bypassed buffer size checks, enabling out-of-bounds memory access during allocation (`dir = (char*)WMALLOC(sz + 1, ...)` at src/wolfsftp.c:1597-1599). The patch replaces the condition with `sz > maxSz - idx` to avoid overflow. However, `maxSz` (the buffer size) is a function parameter whose source remains untraceable due to missing caller context."
CVE-2018-18836,"['1. Unvalidated tqx parameters in `web/api/web_api_v1.c:web_client_api_request_v1_data` (line 333-343) allowed unsanitized user input (e.g., `google_out`, `responseHandler`).', ""2. The patch adds calls to `fix_google_param()` for tqx parameters, but the function's implementation is missing from the provided context."", '3. URL decoding in `libnetdata/url/url.c:url_decode_r` (line 61-65) replaces non-printable characters with spaces during decoding, preventing injection via malformed URLs.']"
CVE-2020-36158,Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is populated with `struct cfg80211_ssid` from userspace via `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650) but the exact caller initiating `HostCmd_CMD_802_11_AD_HOC_START` with this data is missing from the context.
CVE-2023-45897,"Unbounded iteration in read_file_dentry_set (exfat2img/exfat2img.c:320, fsck/fsck.c:342) using file_de->file_num_ext without checking MAX_NAME_DENTRIES. The loop calls exfat_de_iter_get (lib/exfat_dir.c:254) with index `i`, which retrieves directory entries by offset but does not enforce logical limits. If file_de->file_num_ext (derived from SecondaryCount in EXFAT on-disk data) exceeds (1 + MAX_NAME_DENTRIES), this leads to out-of-bounds writes to `node->name`."
CVE-2018-6337,"1. `BufferedRandomDevice::BufferedRandomDevice` (Random.cpp:102-119) registers an `AtFork` child handler to reset `ptr_` after fork. 2. `AtFork::registerHandler` (AtFork.cpp:108-116) adds the handler to `AtForkList::tasks`. 3. GAP: Missing code showing how `AtForkList::tasks` are tied to fork lifecycle events (e.g., via `pthread_atfork`)."
CVE-2021-26199,"In `ecma_builtin_regexp_prototype_compile` (ecma-builtin-regexp-prototype.c:39), the original code called `ecma_bytecode_deref(old_bc_p)` immediately after returning the result of `ecma_op_create_regexp_from_bytecode`. If `ecma_op_create_regexp_from_bytecode` throws an error or returns early, `old_bc_p` could be freed before the operation completes, leading to a use-after-free. The patch stores the result in `ret_value` (ecma-builtin-regexp-prototype.c:40-41) before calling `ecma_bytecode_deref`, ensuring the old bytecode is only freed after the new operation completes. The root cause lies in the assumption that `ecma_op_create_regexp_from_bytecode` does not throw errors."
CVE-2023-46228,"1. Malformed zchunk files provide oversized compint values parsed via `compint_to_size` (src/lib/compint.c:46) into `header_length` and `lead_size`. 2. These values are used in `realloc` calculations in `read_header_from_file` (src/lib/header.c:77) and `multipart_extract` (src/lib/dl/multipart.c:120). 3. In `comp_add_to_data` (src/lib/comp/comp.c:115), `src_size` from `read_data` (src/lib/comp/comp.c:522) is used in `realloc`. 4. Prior to the patch, no overflow checks existed for these calculations, leading to potential integer overflows and heap corruption. GAP: Missing how 'l' and 'c' in `zck_write_chunk_cb` (src/lib/dl/dl.c:451) are derived from zchunk file data."
CVE-2022-29237,"Vulnerable Code:\n- `IngestServiceImpl.java:1569`: `organizationDirectoryService.getOrganization(uri.toURL())` resolves organization from URL's host, allowing cross-tenant URLs.\nPatch:\n- Replaced with `securityService.getOrganization()` to enforce active tenant context.\nGAP: Implementation details of `organizationDirectoryService.getOrganization(URL)` and `securityService.getOrganization()` are missing."
CVE-2022-24122,"kernel/ucount.c:190: alloc_ucounts fails to hold a reference to the user_namespace in ucounts structures for contexts (e.g., POSIX mqueues, SysV shm, SIGPENDING) where no independent user_namespace reference exists. This allows the user_namespace refcount to underflow, risking use-after-free when the last reference is released. The patch adds get_user_ns(new->ns) to retain the reference."
