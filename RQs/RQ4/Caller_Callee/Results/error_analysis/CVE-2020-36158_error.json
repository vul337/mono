{
    "patch": [
        {
            "func_name": "mwifiex_cmd_802_11_ad_hoc_start",
            "patch": "--- func_before\n+++ func_after\n@@ -877,6 +877,8 @@\n \n \tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n \n+\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\n+\t\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\n \tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n \n \tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",",
            "file_path": "drivers/net/wireless/marvell/mwifiex/join.c"
        }
    ],
    "description": "mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.",
    "msg": "mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com",
    "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is populated with `struct cfg80211_ssid` from userspace via `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650) but the exact caller initiating `HostCmd_CMD_802_11_AD_HOC_START` with this data is missing from the context.",
    "confidence_score": 0.75,
    "enriched_data": [
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "int\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct cfg80211_ssid *req_ssid)\n{\n\tint rsn_ie_len = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n\t\t&cmd->params.adhoc_start;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu32 cmd_append_size = 0;\n\tu32 i;\n\tu16 tmp_cap;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 radio_type;\n\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tu8 *pos = (u8 *) adhoc_start +\n\t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n\n\tif (!adapter)\n\t\treturn -1;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tpriv->attempted_bss_desc = bss_desc;\n\n\t/*\n\t * Fill in the parameters for 2 data structures:\n\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\n\t *   2. bss_desc\n\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\n\t * probe delay, and Cap info.\n\t * Firmware will fill up beacon period, Basic rates\n\t * and operational rates.\n\t */\n\n\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n\n\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n\t\t    adhoc_start->ssid);\n\n\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n\n\t/* Set the BSS mode */\n\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n\tbss_desc->beacon_period = priv->beacon_period;\n\n\t/* Set Physical param set */\n/* Parameter IE Id */\n#define DS_PARA_IE_ID   3\n/* Parameter IE length */\n#define DS_PARA_IE_LEN  1\n\n\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n\n\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t     (u16) priv->adhoc_channel, 0)) {\n\t\tstruct mwifiex_chan_freq_power *cfp;\n\t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t\t      FIRST_VALID_CHANNEL, 0);\n\t\tif (cfp)\n\t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n\t}\n\n\tif (!priv->adhoc_channel) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n\t\t    priv->adhoc_channel);\n\n\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n\n\tbss_desc->channel = priv->adhoc_channel;\n\tadhoc_start->phy_param_set.ds_param_set.current_chan =\n\t\tpriv->adhoc_channel;\n\n\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\t/* Set IBSS param set */\n/* IBSS parameter IE Id */\n#define IBSS_PARA_IE_ID   6\n/* IBSS parameter IE length */\n#define IBSS_PARA_IE_LEN  2\n\n\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n\tadhoc_start->ss_param_set.ibss_param_set.atim_window\n\t\t\t\t\t= cpu_to_le16(priv->atim_window);\n\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n\t       sizeof(union ieee_types_ss_param_set));\n\n\t/* Set Capability info */\n\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n\ttmp_cap = WLAN_CAPABILITY_IBSS;\n\n\t/* Set up privacy in bss_desc */\n\tif (priv->sec_info.encryption_mode) {\n\t\t/* Ad-Hoc capability privacy on */\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n\t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\n\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n\tif ((adapter->adhoc_start_band & BAND_G) &&\n\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &priv->curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Find the last non zero */\n\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n\t\tif (!adhoc_start->data_rate[i])\n\t\t\tbreak;\n\n\tpriv->curr_bss_params.num_of_rates = i;\n\n\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\n\tmemcpy(&priv->curr_bss_params.data_rates,\n\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n\t\t    adhoc_start->data_rate);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n\n\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n\t\t/* Append a channel TLV */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type\n\t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tif (adapter->adhoc_start_band & BAND_GN ||\n\t\t    adapter->adhoc_start_band & BAND_AN) {\n\t\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n\t\t\telse if (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n\t\t}\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size +=\n\t\t\tsizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tif (priv->sec_info.wpa_enabled) {\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t\tcmd_append_size += rsn_ie_len;\n\t}\n\n\tif (adapter->adhoc_11n_enabled) {\n\t\t/* Fill HT CAPABILITY */\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type = mwifiex_band_to_radio_type(\n\t\t\t\t\tpriv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\n\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n\t\t\tu16 tmp_ht_cap;\n\n\t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n\t\t}\n\n\t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n\t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n\n\t\t/* Fill HT INFORMATION */\n\t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n\t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n\t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\tht_info->header.len =\n\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n\n\t\tht_info->ht_oper.primary_chan =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tif (adapter->sec_chan_offset) {\n\t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n\t\t\tht_info->ht_oper.ht_param |=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\t\t}\n\t\tht_info->ht_oper.operation_mode =\n\t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tht_info->ht_oper.basic_set[0] = 0xff;\n\t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n\t\tcmd_append_size +=\n\t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n\t}\n\n\tcmd->size =\n\t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n\t\t\t\t  + S_DS_GEN + cmd_append_size));\n\n\tif (adapter->adhoc_start_band == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\telse\n\t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n",
                    "start_line": 839,
                    "end_line": 1099,
                    "full_name": "mwifiex_cmd_802_11_ad_hoc_start",
                    "file_path": "drivers/net/wireless/marvell/mwifiex/join.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 2013,
                    "call_code": "mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\n\t\t\t\t\t\t      data_buf)",
                    "caller_code": "int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\n\t\t\t    u16 cmd_action, u32 cmd_oid,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\n\tint ret = 0;\n\n\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"0x%x command not supported by firmware\\n\",\n\t\t\t    cmd_no);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* Prepare command */\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_GET_HW_SPEC:\n\t\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_CFG_DATA:\n\t\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_CONTROL:\n\t\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\n\t\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\n\t\t\t\t\t\t     cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\n\t\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TX_RATE_CFG:\n\t\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TXPWR_CFG:\n\t\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_TX_PWR:\n\t\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_ANTENNA:\n\t\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\n\t\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t (uint16_t)cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\n\t\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t(struct mwifiex_hs_config_param *) data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN:\n\t\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\n\t\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\n\t\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_ASSOCIATE:\n\t\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\n\t\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_START:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_GET_LOG:\n\t\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\n\t\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_RSSI_INFO:\n\t\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SNMP_MIB:\n\t\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t  cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\n\t\tcmd_ptr->command =\n\t\t\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\n\t\t\t\t    S_DS_GEN);\n\t\tpriv->tx_rate = 0;\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_VERSION_EXT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.verext.version_str_sel =\n\t\t\t(u8)(get_unaligned((u32 *)data_buf));\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_version_ext));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_MGMT_FRAME_REG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\n\t\t\t\t\t\tget_unaligned((u32 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_REMAIN_ON_CHAN:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_remain_on_chan));\n\t\tcmd_ptr->size =\n\t\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\n\t\t\t\t  S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11AC_CFG:\n\t\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.enable =\n\t\t\t\t\t\tcpu_to_le16(*(u16 *)data_buf);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_P2P_MODE_CFG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\n\t\t\t\t\t\tget_unaligned((u16 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_INIT:\n\t\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\n\t\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_SHUTDOWN:\n\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_REQ:\n\t\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_DELBA:\n\t\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_RSP:\n\t\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\n\t\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action, cmd_oid,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\n\t\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\n\t\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\n\t\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\n\t\t\t\t\t\t  data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_CFG:\n\t\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_WMM_GET_STATUS:\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: WMM: WMM_GET_STATUS cmd sent\\n\");\n\t\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\n\t\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\n\t\t\t\t\t\t\t data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN_EXT:\n\t\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEM_ACCESS:\n\t\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SET_BSS_MODE:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_ADHOC;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_INFRA;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\n\t\t\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\n\t\tcmd_ptr->size = cpu_to_le16(sizeof(struct\n\t\t\t\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\n\t\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\n\t\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEF_CFG:\n\t\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_COALESCE_CFG:\n\t\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_OPER:\n\t\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_CONFIG:\n\t\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\n\t\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\n\t\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t\t   data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_HS_WAKEUP_REASON:\n\t\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_MC_POLICY:\n\t\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_ROBUST_COEX:\n\t\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\n\t\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REGION_CFG:\n\t\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_FW_DUMP_EVENT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_STA_CONFIGURE:\n\t\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd- %#x\\n\", cmd_no);\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
                    "caller_start": 1937,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/sta_cmd.c"
                }
            ]
        },
        {
            "tool": "func_info.fetch_func_by_name({'func_name': 'mwifiex_sta_prepare_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "function_def",
                    "code": "int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\n\t\t\t    u16 cmd_action, u32 cmd_oid,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\n\tint ret = 0;\n\n\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"0x%x command not supported by firmware\\n\",\n\t\t\t    cmd_no);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* Prepare command */\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_GET_HW_SPEC:\n\t\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_CFG_DATA:\n\t\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_CONTROL:\n\t\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\n\t\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\n\t\t\t\t\t\t     cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\n\t\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TX_RATE_CFG:\n\t\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TXPWR_CFG:\n\t\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_TX_PWR:\n\t\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_ANTENNA:\n\t\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\n\t\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t (uint16_t)cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\n\t\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t(struct mwifiex_hs_config_param *) data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN:\n\t\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\n\t\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\n\t\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_ASSOCIATE:\n\t\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\n\t\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_START:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_GET_LOG:\n\t\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\n\t\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_RSSI_INFO:\n\t\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SNMP_MIB:\n\t\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t  cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\n\t\tcmd_ptr->command =\n\t\t\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\n\t\t\t\t    S_DS_GEN);\n\t\tpriv->tx_rate = 0;\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_VERSION_EXT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.verext.version_str_sel =\n\t\t\t(u8)(get_unaligned((u32 *)data_buf));\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_version_ext));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_MGMT_FRAME_REG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\n\t\t\t\t\t\tget_unaligned((u32 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_REMAIN_ON_CHAN:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_remain_on_chan));\n\t\tcmd_ptr->size =\n\t\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\n\t\t\t\t  S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11AC_CFG:\n\t\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.enable =\n\t\t\t\t\t\tcpu_to_le16(*(u16 *)data_buf);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_P2P_MODE_CFG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\n\t\t\t\t\t\tget_unaligned((u16 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_INIT:\n\t\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\n\t\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_SHUTDOWN:\n\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_REQ:\n\t\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_DELBA:\n\t\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_RSP:\n\t\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\n\t\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action, cmd_oid,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\n\t\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\n\t\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\n\t\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\n\t\t\t\t\t\t  data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_CFG:\n\t\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_WMM_GET_STATUS:\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: WMM: WMM_GET_STATUS cmd sent\\n\");\n\t\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\n\t\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\n\t\t\t\t\t\t\t data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN_EXT:\n\t\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEM_ACCESS:\n\t\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SET_BSS_MODE:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_ADHOC;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_INFRA;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\n\t\t\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\n\t\tcmd_ptr->size = cpu_to_le16(sizeof(struct\n\t\t\t\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\n\t\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\n\t\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEF_CFG:\n\t\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_COALESCE_CFG:\n\t\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_OPER:\n\t\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_CONFIG:\n\t\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\n\t\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\n\t\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t\t   data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_HS_WAKEUP_REASON:\n\t\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_MC_POLICY:\n\t\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_ROBUST_COEX:\n\t\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\n\t\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REGION_CFG:\n\t\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_FW_DUMP_EVENT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_STA_CONFIGURE:\n\t\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd- %#x\\n\", cmd_no);\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
                    "start_line": 1937,
                    "end_line": 2235,
                    "full_name": "mwifiex_sta_prepare_cmd",
                    "file_path": "drivers/net/wireless/marvell/mwifiex/sta_cmd.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_sta_prepare_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 650,
                    "call_code": "mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr)",
                    "caller_code": "int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\n\t\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\tstruct host_cmd_ds_command *cmd_ptr;\n\n\tif (!adapter) {\n\t\tpr_err(\"PREP_CMD: adapter is NULL\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: device in suspended state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\n\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: host entering sleep state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: card is removed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: FW is in bad state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\n\t\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"PREP_CMD: FW in reset state\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* We don't expect commands in manufacturing mode. They are cooked\n\t * in application and ready to download buffer is passed to the driver\n\t */\n\tif (adapter->mfg_mode && cmd_no) {\n\t\tdev_dbg(adapter->dev, \"Ignoring commands in manufacturing mode\\n\");\n\t\treturn -1;\n\t}\n\n\n\t/* Get a new command node */\n\tcmd_node = mwifiex_get_cmd_node(adapter);\n\n\tif (!cmd_node) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: no free cmd node\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the command node */\n\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\n\n\tif (!cmd_node->cmd_skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: no free cmd buf\\n\");\n\t\treturn -1;\n\t}\n\n\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\n\n\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\n\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\tcmd_ptr->result = 0;\n\n\t/* Prepare command */\n\tif (cmd_no) {\n\t\tswitch (cmd_no) {\n\t\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tcase HostCmd_CMD_UAP_BSS_START:\n\t\tcase HostCmd_CMD_UAP_BSS_STOP:\n\t\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tcase HOST_CMD_APCMD_SYS_RESET:\n\t\tcase HOST_CMD_APCMD_STA_LIST:\n\t\t\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\n\t\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\n\t}\n\n\t/* Return error, since the command preparation failed */\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: cmd %#x preparation failed\\n\",\n\t\t\tcmd_no);\n\t\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\n\t\treturn -1;\n\t}\n\n\t/* Send command */\n\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\n\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\n\t\tmwifiex_queue_scan_cmd(priv, cmd_node);\n\t} else {\n\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\t\tif (cmd_node->wait_q_enabled)\n\t\t\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\n\t}\n\n\treturn ret;\n}\n",
                    "caller_start": 558,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cmdevt.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 90,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                    "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                    "caller_start": 82,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 180,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                    "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                    "caller_start": 171,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 643,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                    "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                    "caller_start": 590,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 671,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                    "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                    "caller_start": 652,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 790,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                    "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                    "caller_start": 777,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 282,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                    "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                    "caller_start": 272,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 407,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                    "caller_start": 399,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 522,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                    "caller_start": 506,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 90,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                    "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                    "caller_start": 82,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 180,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                    "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                    "caller_start": 171,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 643,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                    "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                    "caller_start": 590,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 671,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                    "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                    "caller_start": 652,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 790,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                    "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                    "caller_start": 777,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 282,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                    "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                    "caller_start": 272,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 407,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                    "caller_start": 399,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 522,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                    "caller_start": 506,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 90,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                    "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                    "caller_start": 82,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 180,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                    "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                    "caller_start": 171,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 643,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                    "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                    "caller_start": 590,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 671,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                    "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                    "caller_start": 652,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 790,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                    "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                    "caller_start": 777,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 282,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                    "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                    "caller_start": 272,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 407,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                    "caller_start": 399,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 522,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                    "caller_start": 506,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 90,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                    "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                    "caller_start": 82,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 180,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                    "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                    "caller_start": 171,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 643,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                    "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                    "caller_start": 590,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 671,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                    "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                    "caller_start": 652,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 790,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                    "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                    "caller_start": 777,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 282,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                    "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                    "caller_start": 272,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 407,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                    "caller_start": 399,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 522,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                    "caller_start": 506,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 90,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                    "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                    "caller_start": 82,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 180,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                    "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                    "caller_start": 171,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 643,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                    "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                    "caller_start": 590,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 671,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                    "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                    "caller_start": 652,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 790,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                    "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                    "caller_start": 777,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 282,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                    "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                    "caller_start": 272,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 407,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                    "caller_start": 399,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 522,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                    "caller_start": 506,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                }
            ]
        },
        {
            "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
            "result": [
                {
                    "type": "caller_info",
                    "call_line": 90,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                    "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                    "caller_start": 82,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 180,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                    "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                    "caller_start": 171,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 643,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                    "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                    "caller_start": 590,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 671,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                    "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                    "caller_start": 652,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 790,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                    "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                    "caller_start": 777,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 282,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                    "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                    "caller_start": 272,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 407,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                    "caller_start": 399,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                },
                {
                    "type": "caller_info",
                    "call_line": 522,
                    "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                    "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                    "caller_start": 506,
                    "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                }
            ]
        }
    ],
    "analysis": {
        "patch": [
            {
                "func_name": "mwifiex_cmd_802_11_ad_hoc_start",
                "patch": "--- func_before\n+++ func_after\n@@ -877,6 +877,8 @@\n \n \tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n \n+\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\n+\t\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\n \tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n \n \tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",",
                "file_path": "drivers/net/wireless/marvell/mwifiex/join.c"
            }
        ],
        "msg": "mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com",
        "description": "mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.",
        "language": "c",
        "vulnerability_type": "memory",
        "repair_strategy": "The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.",
        "need_context": true,
        "required_context": [
            "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command in cfg80211 or netlink interface)"
        ],
        "confidence_score": 0.75,
        "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is populated with `struct cfg80211_ssid` from userspace via `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650) but the exact caller initiating `HostCmd_CMD_802_11_AD_HOC_START` with this data is missing from the context.",
        "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, containing `struct cfg80211_ssid` with user-controlled `ssid_len`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced."
    },
    "iteration": 8,
    "history": [
        {
            "stage": "initial",
            "prompt": "You are a senior security engineer. Using **only the provided patch and description**, and **restricted to context retrievable by the 'caller' and 'function' tools**, perform the initial vulnerability analysis.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n\n## INSTRUCTIONS\n1. **Patch Review**  \n    Detect primary language (`c`, `cpp`, `java`).  \n    Classify vulnerability (`memory`, `logic`, `config`).  \n    Explain how each patch hunk mitigates risk, citing `file:line`.  \n    Populate `language`, `vulnerability_type`, `repair_rationale`.\n\n2. **Trace Root Cause within Patch**  \n   Follow calls / data flow in the patch, citing `file:line`.  \n   Where evidence ends, insert: `GAP: <why evidence stops>`  build `root_cause`.\n\n3. **Determine Missing Context (tools limited)**  \n   If gaps remain:  \n      set `\"need_context\": true`  \n      add precise, non-duplicate requests to `\"required_context\"` using **only**:  \n       - `function: `  \n       - `caller: `  \n   If the chain is fully evidenced from the patch, set `\"need_context\": false`.\n\n4. **Confidence Score**  \n   Set `confidence_score  0.90` only if the full chain is evidenced; otherwise ` 0.75`.\n\n## OUTPUT (MUST valid JSON  double quotes, no trailing commas)\n```json\n  {\n      \"language\": \"c | cpp | java\",\n      \"vulnerability_type\": \"memory | logic | config\",\n      \"repair_strategy\": \"<citing file:line from the patch>\",\n      \"analysis\": \"<Synthesis from Process Step 2. If full chain evident, explain that. If context needed, explain why requested context is essential to bridge gaps.>\",\n      \"need_context\": true | false, //false ONLY IF the full pattern was unambiguously evident from patch alone.\n      \"required_context\": \"<list of precise context requests if any context needed>\" ,\n      \"root_cause\": \"\"<Partial/complete trace with file:line evidence from the patch, noting gaps. If full chain evident, provide it.>\",\n      \"confidence_score\": 0.0-1.0 // Confidence in understanding the *full* path based on *this initial analysis phase*\n  }\n  ```\n\n## RULES\n* **Output must be valid JSON (no trailing commas).**\n* **Source-of-Truth**  Cite only code visible in the patch (`file:line`). Commit message / description are auxiliary.\n* **Zero-Assumption**  Never infer. Missing evidence  declare GAP, set `need_context=true`, and request context with allowed tools.\n* **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n* **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "language": "c",
                "vulnerability_type": "memory",
                "repair_strategy": "The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.",
                "analysis": "The vulnerability arises from `memcpy()` being called without verifying that `req_ssid->ssid_len` fits within the destination buffer size (`IEEE80211_MAX_SSID_LEN`). The patch clamps the length to the maximum allowed value before copying. However, the root cause (how `req_ssid->ssid_len` is populated) is not visible in the provided patch, requiring additional context to confirm if the input is user-controlled or sanitized earlier in the call chain.",
                "need_context": true,
                "required_context": [
                    "function: mwifiex_cmd_802_11_ad_hoc_start",
                    "caller: mwifiex_cmd_802_11_ad_hoc_start"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:51:33.430881"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: mwifiex_cmd_802_11_ad_hoc_start",
                "caller: mwifiex_cmd_802_11_ad_hoc_start"
            ],
            "results": [
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "int\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct cfg80211_ssid *req_ssid)\n{\n\tint rsn_ie_len = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n\t\t&cmd->params.adhoc_start;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu32 cmd_append_size = 0;\n\tu32 i;\n\tu16 tmp_cap;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 radio_type;\n\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tu8 *pos = (u8 *) adhoc_start +\n\t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n\n\tif (!adapter)\n\t\treturn -1;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tpriv->attempted_bss_desc = bss_desc;\n\n\t/*\n\t * Fill in the parameters for 2 data structures:\n\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\n\t *   2. bss_desc\n\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\n\t * probe delay, and Cap info.\n\t * Firmware will fill up beacon period, Basic rates\n\t * and operational rates.\n\t */\n\n\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n\n\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n\t\t    adhoc_start->ssid);\n\n\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n\n\t/* Set the BSS mode */\n\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n\tbss_desc->beacon_period = priv->beacon_period;\n\n\t/* Set Physical param set */\n/* Parameter IE Id */\n#define DS_PARA_IE_ID   3\n/* Parameter IE length */\n#define DS_PARA_IE_LEN  1\n\n\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n\n\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t     (u16) priv->adhoc_channel, 0)) {\n\t\tstruct mwifiex_chan_freq_power *cfp;\n\t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t\t      FIRST_VALID_CHANNEL, 0);\n\t\tif (cfp)\n\t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n\t}\n\n\tif (!priv->adhoc_channel) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n\t\t    priv->adhoc_channel);\n\n\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n\n\tbss_desc->channel = priv->adhoc_channel;\n\tadhoc_start->phy_param_set.ds_param_set.current_chan =\n\t\tpriv->adhoc_channel;\n\n\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\t/* Set IBSS param set */\n/* IBSS parameter IE Id */\n#define IBSS_PARA_IE_ID   6\n/* IBSS parameter IE length */\n#define IBSS_PARA_IE_LEN  2\n\n\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n\tadhoc_start->ss_param_set.ibss_param_set.atim_window\n\t\t\t\t\t= cpu_to_le16(priv->atim_window);\n\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n\t       sizeof(union ieee_types_ss_param_set));\n\n\t/* Set Capability info */\n\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n\ttmp_cap = WLAN_CAPABILITY_IBSS;\n\n\t/* Set up privacy in bss_desc */\n\tif (priv->sec_info.encryption_mode) {\n\t\t/* Ad-Hoc capability privacy on */\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n\t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\n\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n\tif ((adapter->adhoc_start_band & BAND_G) &&\n\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &priv->curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Find the last non zero */\n\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n\t\tif (!adhoc_start->data_rate[i])\n\t\t\tbreak;\n\n\tpriv->curr_bss_params.num_of_rates = i;\n\n\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\n\tmemcpy(&priv->curr_bss_params.data_rates,\n\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n\t\t    adhoc_start->data_rate);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n\n\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n\t\t/* Append a channel TLV */\n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type\n\t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tif (adapter->adhoc_start_band & BAND_GN ||\n\t\t    adapter->adhoc_start_band & BAND_AN) {\n\t\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n\t\t\telse if (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n\t\t}\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size +=\n\t\t\tsizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\t/* Append vendor specific IE TLV */\n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tif (priv->sec_info.wpa_enabled) {\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t\tcmd_append_size += rsn_ie_len;\n\t}\n\n\tif (adapter->adhoc_11n_enabled) {\n\t\t/* Fill HT CAPABILITY */\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type = mwifiex_band_to_radio_type(\n\t\t\t\t\tpriv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\n\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n\t\t\tu16 tmp_ht_cap;\n\n\t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n\t\t}\n\n\t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n\t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n\n\t\t/* Fill HT INFORMATION */\n\t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n\t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n\t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\tht_info->header.len =\n\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n\n\t\tht_info->ht_oper.primary_chan =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tif (adapter->sec_chan_offset) {\n\t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n\t\t\tht_info->ht_oper.ht_param |=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\t\t}\n\t\tht_info->ht_oper.operation_mode =\n\t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tht_info->ht_oper.basic_set[0] = 0xff;\n\t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n\t\tcmd_append_size +=\n\t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n\t}\n\n\tcmd->size =\n\t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n\t\t\t\t  + S_DS_GEN + cmd_append_size));\n\n\tif (adapter->adhoc_start_band == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\telse\n\t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n",
                            "start_line": 839,
                            "end_line": 1099,
                            "full_name": "mwifiex_cmd_802_11_ad_hoc_start",
                            "file_path": "drivers/net/wireless/marvell/mwifiex/join.c"
                        }
                    ]
                },
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 2013,
                            "call_code": "mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\n\t\t\t\t\t\t      data_buf)",
                            "caller_code": "int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\n\t\t\t    u16 cmd_action, u32 cmd_oid,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\n\tint ret = 0;\n\n\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"0x%x command not supported by firmware\\n\",\n\t\t\t    cmd_no);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* Prepare command */\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_GET_HW_SPEC:\n\t\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_CFG_DATA:\n\t\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_CONTROL:\n\t\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\n\t\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\n\t\t\t\t\t\t     cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\n\t\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TX_RATE_CFG:\n\t\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TXPWR_CFG:\n\t\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_TX_PWR:\n\t\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_ANTENNA:\n\t\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\n\t\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t (uint16_t)cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\n\t\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t(struct mwifiex_hs_config_param *) data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN:\n\t\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\n\t\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\n\t\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_ASSOCIATE:\n\t\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\n\t\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_START:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_GET_LOG:\n\t\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\n\t\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_RSSI_INFO:\n\t\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SNMP_MIB:\n\t\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t  cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\n\t\tcmd_ptr->command =\n\t\t\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\n\t\t\t\t    S_DS_GEN);\n\t\tpriv->tx_rate = 0;\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_VERSION_EXT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.verext.version_str_sel =\n\t\t\t(u8)(get_unaligned((u32 *)data_buf));\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_version_ext));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_MGMT_FRAME_REG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\n\t\t\t\t\t\tget_unaligned((u32 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_REMAIN_ON_CHAN:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_remain_on_chan));\n\t\tcmd_ptr->size =\n\t\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\n\t\t\t\t  S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11AC_CFG:\n\t\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.enable =\n\t\t\t\t\t\tcpu_to_le16(*(u16 *)data_buf);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_P2P_MODE_CFG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\n\t\t\t\t\t\tget_unaligned((u16 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_INIT:\n\t\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\n\t\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_SHUTDOWN:\n\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_REQ:\n\t\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_DELBA:\n\t\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_RSP:\n\t\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\n\t\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action, cmd_oid,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\n\t\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\n\t\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\n\t\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\n\t\t\t\t\t\t  data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_CFG:\n\t\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_WMM_GET_STATUS:\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: WMM: WMM_GET_STATUS cmd sent\\n\");\n\t\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\n\t\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\n\t\t\t\t\t\t\t data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN_EXT:\n\t\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEM_ACCESS:\n\t\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SET_BSS_MODE:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_ADHOC;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_INFRA;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\n\t\t\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\n\t\tcmd_ptr->size = cpu_to_le16(sizeof(struct\n\t\t\t\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\n\t\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\n\t\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEF_CFG:\n\t\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_COALESCE_CFG:\n\t\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_OPER:\n\t\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_CONFIG:\n\t\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\n\t\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\n\t\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t\t   data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_HS_WAKEUP_REASON:\n\t\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_MC_POLICY:\n\t\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_ROBUST_COEX:\n\t\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\n\t\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REGION_CFG:\n\t\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_FW_DUMP_EVENT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_STA_CONFIGURE:\n\t\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd- %#x\\n\", cmd_no);\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
                            "caller_start": 1937,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/sta_cmd.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:51:57.133217"
        },
        {
            "stage": "analysis",
            "iteration": 1,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.",
                "need_context": true,
                "required_context": [
                    "function: mwifiex_sta_prepare_cmd",
                    "caller: mwifiex_sta_prepare_cmd"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:52:42.415626"
        },
        {
            "stage": "collection",
            "required_context": [
                "function: mwifiex_sta_prepare_cmd",
                "caller: mwifiex_sta_prepare_cmd"
            ],
            "results": [
                {
                    "tool": "func_info.fetch_func_by_name({'func_name': 'mwifiex_sta_prepare_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "function_def",
                            "code": "int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\n\t\t\t    u16 cmd_action, u32 cmd_oid,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\n\tint ret = 0;\n\n\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"0x%x command not supported by firmware\\n\",\n\t\t\t    cmd_no);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* Prepare command */\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_GET_HW_SPEC:\n\t\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_CFG_DATA:\n\t\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_CONTROL:\n\t\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\n\t\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\n\t\t\t\t\t\t     cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\n\t\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TX_RATE_CFG:\n\t\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TXPWR_CFG:\n\t\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_TX_PWR:\n\t\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_ANTENNA:\n\t\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\n\t\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t (uint16_t)cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\n\t\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t(struct mwifiex_hs_config_param *) data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN:\n\t\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\n\t\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\n\t\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_ASSOCIATE:\n\t\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\n\t\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_START:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_GET_LOG:\n\t\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\n\t\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_RSSI_INFO:\n\t\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SNMP_MIB:\n\t\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t  cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\n\t\tcmd_ptr->command =\n\t\t\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\n\t\t\t\t    S_DS_GEN);\n\t\tpriv->tx_rate = 0;\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_VERSION_EXT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.verext.version_str_sel =\n\t\t\t(u8)(get_unaligned((u32 *)data_buf));\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_version_ext));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_MGMT_FRAME_REG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\n\t\t\t\t\t\tget_unaligned((u32 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_REMAIN_ON_CHAN:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_remain_on_chan));\n\t\tcmd_ptr->size =\n\t\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\n\t\t\t\t  S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11AC_CFG:\n\t\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.enable =\n\t\t\t\t\t\tcpu_to_le16(*(u16 *)data_buf);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_P2P_MODE_CFG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\n\t\t\t\t\t\tget_unaligned((u16 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_INIT:\n\t\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\n\t\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_SHUTDOWN:\n\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_REQ:\n\t\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_DELBA:\n\t\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_RSP:\n\t\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\n\t\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action, cmd_oid,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\n\t\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\n\t\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\n\t\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\n\t\t\t\t\t\t  data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_CFG:\n\t\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_WMM_GET_STATUS:\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: WMM: WMM_GET_STATUS cmd sent\\n\");\n\t\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\n\t\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\n\t\t\t\t\t\t\t data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN_EXT:\n\t\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEM_ACCESS:\n\t\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SET_BSS_MODE:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_ADHOC;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_INFRA;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\n\t\t\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\n\t\tcmd_ptr->size = cpu_to_le16(sizeof(struct\n\t\t\t\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\n\t\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\n\t\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEF_CFG:\n\t\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_COALESCE_CFG:\n\t\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_OPER:\n\t\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_CONFIG:\n\t\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\n\t\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\n\t\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t\t   data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_HS_WAKEUP_REASON:\n\t\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_MC_POLICY:\n\t\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_ROBUST_COEX:\n\t\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\n\t\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REGION_CFG:\n\t\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_FW_DUMP_EVENT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_STA_CONFIGURE:\n\t\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd- %#x\\n\", cmd_no);\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
                            "start_line": 1937,
                            "end_line": 2235,
                            "full_name": "mwifiex_sta_prepare_cmd",
                            "file_path": "drivers/net/wireless/marvell/mwifiex/sta_cmd.c"
                        }
                    ]
                },
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_sta_prepare_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 650,
                            "call_code": "mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr)",
                            "caller_code": "int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\n\t\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\tstruct host_cmd_ds_command *cmd_ptr;\n\n\tif (!adapter) {\n\t\tpr_err(\"PREP_CMD: adapter is NULL\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: device in suspended state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\n\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: host entering sleep state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: card is removed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: FW is in bad state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\n\t\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"PREP_CMD: FW in reset state\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* We don't expect commands in manufacturing mode. They are cooked\n\t * in application and ready to download buffer is passed to the driver\n\t */\n\tif (adapter->mfg_mode && cmd_no) {\n\t\tdev_dbg(adapter->dev, \"Ignoring commands in manufacturing mode\\n\");\n\t\treturn -1;\n\t}\n\n\n\t/* Get a new command node */\n\tcmd_node = mwifiex_get_cmd_node(adapter);\n\n\tif (!cmd_node) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: no free cmd node\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Initialize the command node */\n\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\n\n\tif (!cmd_node->cmd_skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: no free cmd buf\\n\");\n\t\treturn -1;\n\t}\n\n\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\n\n\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\n\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\tcmd_ptr->result = 0;\n\n\t/* Prepare command */\n\tif (cmd_no) {\n\t\tswitch (cmd_no) {\n\t\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tcase HostCmd_CMD_UAP_BSS_START:\n\t\tcase HostCmd_CMD_UAP_BSS_STOP:\n\t\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tcase HOST_CMD_APCMD_SYS_RESET:\n\t\tcase HOST_CMD_APCMD_STA_LIST:\n\t\t\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\n\t\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\n\t}\n\n\t/* Return error, since the command preparation failed */\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: cmd %#x preparation failed\\n\",\n\t\t\tcmd_no);\n\t\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\n\t\treturn -1;\n\t}\n\n\t/* Send command */\n\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\n\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\n\t\tmwifiex_queue_scan_cmd(priv, cmd_node);\n\t} else {\n\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\t\tif (cmd_node->wait_q_enabled)\n\t\t\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\n\t}\n\n\treturn ret;\n}\n",
                            "caller_start": 558,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cmdevt.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:53:03.115983"
        },
        {
            "stage": "analysis",
            "iteration": 2,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"function: mwifiex_sta_prepare_cmd\",\n      \"caller: mwifiex_sta_prepare_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"start_line\": 1937,\n            \"end_line\": 2235,\n            \"full_name\": \"mwifiex_sta_prepare_cmd\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 650,\n            \"call_code\": \"mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr)\",\n            \"caller_code\": \"int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\\n\\t\\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\\n{\\n\\tint ret;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct cmd_ctrl_node *cmd_node;\\n\\tstruct host_cmd_ds_command *cmd_ptr;\\n\\n\\tif (!adapter) {\\n\\t\\tpr_err(\\\"PREP_CMD: adapter is NULL\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: device in suspended state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\\n\\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: host entering sleep state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: card is removed\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: FW is in bad state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\\n\\t\\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"PREP_CMD: FW in reset state\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* We don't expect commands in manufacturing mode. They are cooked\\n\\t * in application and ready to download buffer is passed to the driver\\n\\t */\\n\\tif (adapter->mfg_mode && cmd_no) {\\n\\t\\tdev_dbg(adapter->dev, \\\"Ignoring commands in manufacturing mode\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\n\\t/* Get a new command node */\\n\\tcmd_node = mwifiex_get_cmd_node(adapter);\\n\\n\\tif (!cmd_node) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd node\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Initialize the command node */\\n\\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\\n\\n\\tif (!cmd_node->cmd_skb) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd buf\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\\n\\n\\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\\n\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\tcmd_ptr->result = 0;\\n\\n\\t/* Prepare command */\\n\\tif (cmd_no) {\\n\\t\\tswitch (cmd_no) {\\n\\t\\tcase HostCmd_CMD_UAP_SYS_CONFIG:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_START:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_STOP:\\n\\t\\tcase HostCmd_CMD_UAP_STA_DEAUTH:\\n\\t\\tcase HOST_CMD_APCMD_SYS_RESET:\\n\\t\\tcase HOST_CMD_APCMD_STA_LIST:\\n\\t\\t\\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} else {\\n\\t\\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\\n\\t\\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\\n\\t}\\n\\n\\t/* Return error, since the command preparation failed */\\n\\tif (ret) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: cmd %#x preparation failed\\\\n\\\",\\n\\t\\t\\tcmd_no);\\n\\t\\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Send command */\\n\\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\\n\\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\\n\\t\\tmwifiex_queue_scan_cmd(priv, cmd_node);\\n\\t} else {\\n\\t\\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\\n\\t\\tqueue_work(adapter->workqueue, &adapter->main_work);\\n\\t\\tif (cmd_node->wait_q_enabled)\\n\\t\\t\\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\\n\\t}\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 558,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cmdevt.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` passed to `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013). However, the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs that handle SSID input.",
                "need_context": true,
                "required_context": [
                    "caller: mwifiex_send_cmd"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but its origin is untraced (GAP: data_buf source).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:53:45.824270"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: mwifiex_send_cmd"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 90,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                            "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                            "caller_start": 82,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 180,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                            "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                            "caller_start": 171,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 643,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                            "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                            "caller_start": 590,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 671,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                            "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                            "caller_start": 652,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 790,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                            "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                            "caller_start": 777,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 282,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                            "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                            "caller_start": 272,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 407,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                            "caller_start": 399,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 522,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                            "caller_start": 506,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:54:00.303833"
        },
        {
            "stage": "analysis",
            "iteration": 3,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"function: mwifiex_sta_prepare_cmd\",\n      \"caller: mwifiex_sta_prepare_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"start_line\": 1937,\n            \"end_line\": 2235,\n            \"full_name\": \"mwifiex_sta_prepare_cmd\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 650,\n            \"call_code\": \"mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr)\",\n            \"caller_code\": \"int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\\n\\t\\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\\n{\\n\\tint ret;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct cmd_ctrl_node *cmd_node;\\n\\tstruct host_cmd_ds_command *cmd_ptr;\\n\\n\\tif (!adapter) {\\n\\t\\tpr_err(\\\"PREP_CMD: adapter is NULL\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: device in suspended state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\\n\\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: host entering sleep state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: card is removed\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: FW is in bad state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\\n\\t\\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"PREP_CMD: FW in reset state\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* We don't expect commands in manufacturing mode. They are cooked\\n\\t * in application and ready to download buffer is passed to the driver\\n\\t */\\n\\tif (adapter->mfg_mode && cmd_no) {\\n\\t\\tdev_dbg(adapter->dev, \\\"Ignoring commands in manufacturing mode\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\n\\t/* Get a new command node */\\n\\tcmd_node = mwifiex_get_cmd_node(adapter);\\n\\n\\tif (!cmd_node) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd node\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Initialize the command node */\\n\\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\\n\\n\\tif (!cmd_node->cmd_skb) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd buf\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\\n\\n\\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\\n\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\tcmd_ptr->result = 0;\\n\\n\\t/* Prepare command */\\n\\tif (cmd_no) {\\n\\t\\tswitch (cmd_no) {\\n\\t\\tcase HostCmd_CMD_UAP_SYS_CONFIG:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_START:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_STOP:\\n\\t\\tcase HostCmd_CMD_UAP_STA_DEAUTH:\\n\\t\\tcase HOST_CMD_APCMD_SYS_RESET:\\n\\t\\tcase HOST_CMD_APCMD_STA_LIST:\\n\\t\\t\\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} else {\\n\\t\\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\\n\\t\\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\\n\\t}\\n\\n\\t/* Return error, since the command preparation failed */\\n\\tif (ret) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: cmd %#x preparation failed\\\\n\\\",\\n\\t\\t\\tcmd_no);\\n\\t\\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Send command */\\n\\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\\n\\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\\n\\t\\tmwifiex_queue_scan_cmd(priv, cmd_node);\\n\\t} else {\\n\\t\\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\\n\\t\\tqueue_work(adapter->workqueue, &adapter->main_work);\\n\\t\\tif (cmd_node->wait_q_enabled)\\n\\t\\t\\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\\n\\t}\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 558,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cmdevt.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but its origin is untraced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` passed to `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013). However, the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs that handle SSID input.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.",
                "need_context": true,
                "required_context": [
                    "caller: mwifiex_send_cmd (specific to AD_HOC_START command)"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but no visible caller of `mwifiex_send_cmd` handles SSID input (GAP: data_buf source).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:54:36.725064"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: mwifiex_send_cmd (specific to AD_HOC_START command)"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 90,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                            "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                            "caller_start": 82,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 180,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                            "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                            "caller_start": 171,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 643,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                            "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                            "caller_start": 590,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 671,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                            "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                            "caller_start": 652,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 790,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                            "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                            "caller_start": 777,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 282,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                            "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                            "caller_start": 272,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 407,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                            "caller_start": 399,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 522,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                            "caller_start": 506,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:55:02.418122"
        },
        {
            "stage": "analysis",
            "iteration": 4,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"function: mwifiex_sta_prepare_cmd\",\n      \"caller: mwifiex_sta_prepare_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"start_line\": 1937,\n            \"end_line\": 2235,\n            \"full_name\": \"mwifiex_sta_prepare_cmd\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 650,\n            \"call_code\": \"mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr)\",\n            \"caller_code\": \"int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\\n\\t\\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\\n{\\n\\tint ret;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct cmd_ctrl_node *cmd_node;\\n\\tstruct host_cmd_ds_command *cmd_ptr;\\n\\n\\tif (!adapter) {\\n\\t\\tpr_err(\\\"PREP_CMD: adapter is NULL\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: device in suspended state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\\n\\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: host entering sleep state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: card is removed\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: FW is in bad state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\\n\\t\\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"PREP_CMD: FW in reset state\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* We don't expect commands in manufacturing mode. They are cooked\\n\\t * in application and ready to download buffer is passed to the driver\\n\\t */\\n\\tif (adapter->mfg_mode && cmd_no) {\\n\\t\\tdev_dbg(adapter->dev, \\\"Ignoring commands in manufacturing mode\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\n\\t/* Get a new command node */\\n\\tcmd_node = mwifiex_get_cmd_node(adapter);\\n\\n\\tif (!cmd_node) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd node\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Initialize the command node */\\n\\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\\n\\n\\tif (!cmd_node->cmd_skb) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd buf\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\\n\\n\\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\\n\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\tcmd_ptr->result = 0;\\n\\n\\t/* Prepare command */\\n\\tif (cmd_no) {\\n\\t\\tswitch (cmd_no) {\\n\\t\\tcase HostCmd_CMD_UAP_SYS_CONFIG:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_START:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_STOP:\\n\\t\\tcase HostCmd_CMD_UAP_STA_DEAUTH:\\n\\t\\tcase HOST_CMD_APCMD_SYS_RESET:\\n\\t\\tcase HOST_CMD_APCMD_STA_LIST:\\n\\t\\t\\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} else {\\n\\t\\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\\n\\t\\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\\n\\t}\\n\\n\\t/* Return error, since the command preparation failed */\\n\\tif (ret) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: cmd %#x preparation failed\\\\n\\\",\\n\\t\\t\\tcmd_no);\\n\\t\\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Send command */\\n\\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\\n\\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\\n\\t\\tmwifiex_queue_scan_cmd(priv, cmd_node);\\n\\t} else {\\n\\t\\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\\n\\t\\tqueue_work(adapter->workqueue, &adapter->main_work);\\n\\t\\tif (cmd_node->wait_q_enabled)\\n\\t\\t\\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\\n\\t}\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 558,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cmdevt.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but its origin is untraced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` passed to `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013). However, the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs that handle SSID input.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but no visible caller of `mwifiex_send_cmd` handles SSID input (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle the `HostCmd_CMD_802_11_AD_HOC_START` command with SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.",
                "need_context": true,
                "required_context": [
                    "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:55:39.542776"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 90,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                            "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                            "caller_start": 82,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 180,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                            "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                            "caller_start": 171,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 643,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                            "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                            "caller_start": 590,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 671,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                            "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                            "caller_start": 652,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 790,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                            "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                            "caller_start": 777,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 282,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                            "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                            "caller_start": 272,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 407,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                            "caller_start": 399,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 522,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                            "caller_start": 506,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:55:58.285128"
        },
        {
            "stage": "analysis",
            "iteration": 5,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"function: mwifiex_sta_prepare_cmd\",\n      \"caller: mwifiex_sta_prepare_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"start_line\": 1937,\n            \"end_line\": 2235,\n            \"full_name\": \"mwifiex_sta_prepare_cmd\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 650,\n            \"call_code\": \"mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr)\",\n            \"caller_code\": \"int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\\n\\t\\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\\n{\\n\\tint ret;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct cmd_ctrl_node *cmd_node;\\n\\tstruct host_cmd_ds_command *cmd_ptr;\\n\\n\\tif (!adapter) {\\n\\t\\tpr_err(\\\"PREP_CMD: adapter is NULL\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: device in suspended state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\\n\\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: host entering sleep state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: card is removed\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: FW is in bad state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\\n\\t\\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"PREP_CMD: FW in reset state\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* We don't expect commands in manufacturing mode. They are cooked\\n\\t * in application and ready to download buffer is passed to the driver\\n\\t */\\n\\tif (adapter->mfg_mode && cmd_no) {\\n\\t\\tdev_dbg(adapter->dev, \\\"Ignoring commands in manufacturing mode\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\n\\t/* Get a new command node */\\n\\tcmd_node = mwifiex_get_cmd_node(adapter);\\n\\n\\tif (!cmd_node) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd node\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Initialize the command node */\\n\\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\\n\\n\\tif (!cmd_node->cmd_skb) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd buf\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\\n\\n\\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\\n\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\tcmd_ptr->result = 0;\\n\\n\\t/* Prepare command */\\n\\tif (cmd_no) {\\n\\t\\tswitch (cmd_no) {\\n\\t\\tcase HostCmd_CMD_UAP_SYS_CONFIG:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_START:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_STOP:\\n\\t\\tcase HostCmd_CMD_UAP_STA_DEAUTH:\\n\\t\\tcase HOST_CMD_APCMD_SYS_RESET:\\n\\t\\tcase HOST_CMD_APCMD_STA_LIST:\\n\\t\\t\\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} else {\\n\\t\\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\\n\\t\\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\\n\\t}\\n\\n\\t/* Return error, since the command preparation failed */\\n\\tif (ret) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: cmd %#x preparation failed\\\\n\\\",\\n\\t\\t\\tcmd_no);\\n\\t\\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Send command */\\n\\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\\n\\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\\n\\t\\tmwifiex_queue_scan_cmd(priv, cmd_node);\\n\\t} else {\\n\\t\\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\\n\\t\\tqueue_work(adapter->workqueue, &adapter->main_work);\\n\\t\\tif (cmd_node->wait_q_enabled)\\n\\t\\t\\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\\n\\t}\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 558,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cmdevt.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but its origin is untraced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` passed to `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013). However, the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs that handle SSID input.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but no visible caller of `mwifiex_send_cmd` handles SSID input (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle the `HostCmd_CMD_802_11_AD_HOC_START` command with SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.",
                "need_context": true,
                "required_context": [
                    "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:56:38.259686"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 90,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                            "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                            "caller_start": 82,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 180,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                            "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                            "caller_start": 171,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 643,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                            "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                            "caller_start": 590,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 671,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                            "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                            "caller_start": 652,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 790,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                            "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                            "caller_start": 777,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 282,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                            "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                            "caller_start": 272,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 407,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                            "caller_start": 399,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 522,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                            "caller_start": 506,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:56:39.703768"
        },
        {
            "stage": "analysis",
            "iteration": 6,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"function: mwifiex_sta_prepare_cmd\",\n      \"caller: mwifiex_sta_prepare_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"start_line\": 1937,\n            \"end_line\": 2235,\n            \"full_name\": \"mwifiex_sta_prepare_cmd\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 650,\n            \"call_code\": \"mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr)\",\n            \"caller_code\": \"int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\\n\\t\\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\\n{\\n\\tint ret;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct cmd_ctrl_node *cmd_node;\\n\\tstruct host_cmd_ds_command *cmd_ptr;\\n\\n\\tif (!adapter) {\\n\\t\\tpr_err(\\\"PREP_CMD: adapter is NULL\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: device in suspended state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\\n\\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: host entering sleep state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: card is removed\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: FW is in bad state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\\n\\t\\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"PREP_CMD: FW in reset state\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* We don't expect commands in manufacturing mode. They are cooked\\n\\t * in application and ready to download buffer is passed to the driver\\n\\t */\\n\\tif (adapter->mfg_mode && cmd_no) {\\n\\t\\tdev_dbg(adapter->dev, \\\"Ignoring commands in manufacturing mode\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\n\\t/* Get a new command node */\\n\\tcmd_node = mwifiex_get_cmd_node(adapter);\\n\\n\\tif (!cmd_node) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd node\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Initialize the command node */\\n\\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\\n\\n\\tif (!cmd_node->cmd_skb) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd buf\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\\n\\n\\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\\n\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\tcmd_ptr->result = 0;\\n\\n\\t/* Prepare command */\\n\\tif (cmd_no) {\\n\\t\\tswitch (cmd_no) {\\n\\t\\tcase HostCmd_CMD_UAP_SYS_CONFIG:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_START:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_STOP:\\n\\t\\tcase HostCmd_CMD_UAP_STA_DEAUTH:\\n\\t\\tcase HOST_CMD_APCMD_SYS_RESET:\\n\\t\\tcase HOST_CMD_APCMD_STA_LIST:\\n\\t\\t\\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} else {\\n\\t\\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\\n\\t\\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\\n\\t}\\n\\n\\t/* Return error, since the command preparation failed */\\n\\tif (ret) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: cmd %#x preparation failed\\\\n\\\",\\n\\t\\t\\tcmd_no);\\n\\t\\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Send command */\\n\\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\\n\\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\\n\\t\\tmwifiex_queue_scan_cmd(priv, cmd_node);\\n\\t} else {\\n\\t\\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\\n\\t\\tqueue_work(adapter->workqueue, &adapter->main_work);\\n\\t\\tif (cmd_node->wait_q_enabled)\\n\\t\\t\\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\\n\\t}\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 558,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cmdevt.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but its origin is untraced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` passed to `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013). However, the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs that handle SSID input.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but no visible caller of `mwifiex_send_cmd` handles SSID input (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle the `HostCmd_CMD_802_11_AD_HOC_START` command with SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.",
                "need_context": true,
                "required_context": [
                    "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:57:22.913827"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 90,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                            "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                            "caller_start": 82,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 180,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                            "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                            "caller_start": 171,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 643,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                            "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                            "caller_start": 590,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 671,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                            "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                            "caller_start": 652,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 790,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                            "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                            "caller_start": 777,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 282,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                            "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                            "caller_start": 272,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 407,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                            "caller_start": 399,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 522,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                            "caller_start": 506,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:57:24.206328"
        },
        {
            "stage": "analysis",
            "iteration": 7,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"function: mwifiex_sta_prepare_cmd\",\n      \"caller: mwifiex_sta_prepare_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"start_line\": 1937,\n            \"end_line\": 2235,\n            \"full_name\": \"mwifiex_sta_prepare_cmd\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 650,\n            \"call_code\": \"mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr)\",\n            \"caller_code\": \"int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\\n\\t\\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\\n{\\n\\tint ret;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct cmd_ctrl_node *cmd_node;\\n\\tstruct host_cmd_ds_command *cmd_ptr;\\n\\n\\tif (!adapter) {\\n\\t\\tpr_err(\\\"PREP_CMD: adapter is NULL\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: device in suspended state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\\n\\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: host entering sleep state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: card is removed\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: FW is in bad state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\\n\\t\\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"PREP_CMD: FW in reset state\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* We don't expect commands in manufacturing mode. They are cooked\\n\\t * in application and ready to download buffer is passed to the driver\\n\\t */\\n\\tif (adapter->mfg_mode && cmd_no) {\\n\\t\\tdev_dbg(adapter->dev, \\\"Ignoring commands in manufacturing mode\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\n\\t/* Get a new command node */\\n\\tcmd_node = mwifiex_get_cmd_node(adapter);\\n\\n\\tif (!cmd_node) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd node\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Initialize the command node */\\n\\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\\n\\n\\tif (!cmd_node->cmd_skb) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd buf\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\\n\\n\\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\\n\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\tcmd_ptr->result = 0;\\n\\n\\t/* Prepare command */\\n\\tif (cmd_no) {\\n\\t\\tswitch (cmd_no) {\\n\\t\\tcase HostCmd_CMD_UAP_SYS_CONFIG:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_START:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_STOP:\\n\\t\\tcase HostCmd_CMD_UAP_STA_DEAUTH:\\n\\t\\tcase HOST_CMD_APCMD_SYS_RESET:\\n\\t\\tcase HOST_CMD_APCMD_STA_LIST:\\n\\t\\t\\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} else {\\n\\t\\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\\n\\t\\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\\n\\t}\\n\\n\\t/* Return error, since the command preparation failed */\\n\\tif (ret) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: cmd %#x preparation failed\\\\n\\\",\\n\\t\\t\\tcmd_no);\\n\\t\\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Send command */\\n\\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\\n\\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\\n\\t\\tmwifiex_queue_scan_cmd(priv, cmd_node);\\n\\t} else {\\n\\t\\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\\n\\t\\tqueue_work(adapter->workqueue, &adapter->main_work);\\n\\t\\tif (cmd_node->wait_q_enabled)\\n\\t\\t\\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\\n\\t}\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 558,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cmdevt.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but its origin is untraced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` passed to `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013). However, the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs that handle SSID input.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but no visible caller of `mwifiex_send_cmd` handles SSID input (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle the `HostCmd_CMD_802_11_AD_HOC_START` command with SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.",
                "need_context": true,
                "required_context": [
                    "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:58:04.754020"
        },
        {
            "stage": "collection",
            "required_context": [
                "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)"
            ],
            "results": [
                {
                    "tool": "caller_info.find_caller_for_func({'func_name': 'mwifiex_send_cmd', 'project_dir': './storage/result/Part2_result/github/CVE-2020-36158/old_repos/torvalds-linux_871a8'})",
                    "result": [
                        {
                            "type": "caller_info",
                            "call_line": 90,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)",
                            "caller_code": "int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t/* enable master mode radar detection on AP interface */\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}",
                            "caller_start": 82,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 180,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)",
                            "caller_code": "int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}",
                            "caller_start": 171,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11h.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 643,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false)",
                            "caller_code": "int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t/* enable AMSDU inside AMPDU */\n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n",
                            "caller_start": 590,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 671,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false)",
                            "caller_code": "int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\n\n\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t/* We don't wait for the response of this command */\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}",
                            "caller_start": 652,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 790,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)",
                            "caller_code": "void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}",
                            "caller_start": 777,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 282,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false)",
                            "caller_code": "static void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}",
                            "caller_start": 272,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 407,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}",
                            "caller_start": 399,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        },
                        {
                            "type": "caller_info",
                            "call_line": 522,
                            "call_code": "mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)",
                            "caller_code": "static int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\n}",
                            "caller_start": 506,
                            "file_path": "drivers/net/wireless/marvell/mwifiex/cfg80211.c"
                        }
                    ]
                }
            ],
            "timestamp": "2025-05-26T15:58:06.249930"
        },
        {
            "stage": "analysis",
            "iteration": 8,
            "prompt": "You are a senior security engineer. Using **all available code context**, build the **complete, evidence-backed root-cause and trigger chain** for the vulnerability.\n\n## INPUTS\n- **Commit Message**: mwifiex: Fix possible buffer overflows in mwifiex_cmd_802_11_ad_hoc_start\n\nmwifiex_cmd_802_11_ad_hoc_start() calls memcpy() without checking\nthe destination size may trigger a buffer overflower,\nwhich a local user could use to cause denial of service\nor the execution of arbitrary code.\nFix it by putting the length check before calling memcpy().\n\nSigned-off-by: Zhang Xiaohui <ruc_zhangxiaohui@163.com>\nSigned-off-by: Kalle Valo <kvalo@codeaurora.org>\nLink: https://lore.kernel.org/r/20201206084801.26479-1-ruc_zhangxiaohui@163.com\n- **Vulnerability Description**: mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.\n- **Patch Code**: [{'func_name': 'mwifiex_cmd_802_11_ad_hoc_start', 'patch': '--- func_before\\n+++ func_after\\n@@ -877,6 +877,8 @@\\n \\n \\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n \\n+\\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\\n+\\t\\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\\n \\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n \\n \\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\\\n\",', 'file_path': 'drivers/net/wireless/marvell/mwifiex/join.c'}]\n- **History Summary (all prior context & analysis)**: [\n  {\n    \"stage\": \"initial\",\n    \"result\": {\n      \"language\": \"c\",\n      \"vulnerability_type\": \"memory\",\n      \"repair_strategy\": \"The patch adds a length check (`if (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN) req_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;`) before `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` to prevent buffer overflow.\",\n      \"required_context\": [\n        \"function: mwifiex_cmd_802_11_ad_hoc_start\",\n        \"caller: mwifiex_cmd_802_11_ad_hoc_start\"\n      ],\n      \"root_cause\": \"Unbounded `req_ssid->ssid_len` passed to `memcpy()` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`, but the origin of `req_ssid->ssid_len` is not visible (GAP: req_ssid data source).\"\n    }\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"code\": \"int\\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\\n\\t\\t\\t\\tstruct host_cmd_ds_command *cmd,\\n\\t\\t\\t\\tstruct cfg80211_ssid *req_ssid)\\n{\\n\\tint rsn_ie_len = 0;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\\n\\t\\t&cmd->params.adhoc_start;\\n\\tstruct mwifiex_bssdescriptor *bss_desc;\\n\\tu32 cmd_append_size = 0;\\n\\tu32 i;\\n\\tu16 tmp_cap;\\n\\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\\n\\tu8 radio_type;\\n\\n\\tstruct mwifiex_ie_types_htcap *ht_cap;\\n\\tstruct mwifiex_ie_types_htinfo *ht_info;\\n\\tu8 *pos = (u8 *) adhoc_start +\\n\\t\\t\\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\\n\\n\\tif (!adapter)\\n\\t\\treturn -1;\\n\\n\\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\\n\\n\\tbss_desc = &priv->curr_bss_params.bss_descriptor;\\n\\tpriv->attempted_bss_desc = bss_desc;\\n\\n\\t/*\\n\\t * Fill in the parameters for 2 data structures:\\n\\t *   1. struct host_cmd_ds_802_11_ad_hoc_start command\\n\\t *   2. bss_desc\\n\\t * Driver will fill up SSID, bss_mode,IBSS param, Physical Param,\\n\\t * probe delay, and Cap info.\\n\\t * Firmware will fill up beacon period, Basic rates\\n\\t * and operational rates.\\n\\t */\\n\\n\\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\n\\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: SSID = %s\\\\n\\\",\\n\\t\\t    adhoc_start->ssid);\\n\\n\\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\\n\\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\\n\\n\\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\\n\\n\\t/* Set the BSS mode */\\n\\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\\n\\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\\n\\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\\n\\tbss_desc->beacon_period = priv->beacon_period;\\n\\n\\t/* Set Physical param set */\\n/* Parameter IE Id */\\n#define DS_PARA_IE_ID   3\\n/* Parameter IE length */\\n#define DS_PARA_IE_LEN  1\\n\\n\\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\\n\\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\\n\\n\\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t     (u16) priv->adhoc_channel, 0)) {\\n\\t\\tstruct mwifiex_chan_freq_power *cfp;\\n\\t\\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\\n\\t\\t\\t\\t      FIRST_VALID_CHANNEL, 0);\\n\\t\\tif (cfp)\\n\\t\\t\\tpriv->adhoc_channel = (u8) cfp->channel;\\n\\t}\\n\\n\\tif (!priv->adhoc_channel) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"ADHOC_S_CMD: adhoc_channel cannot be 0\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t    \\\"info: ADHOC_S_CMD: creating ADHOC on channel %d\\\\n\\\",\\n\\t\\t    priv->adhoc_channel);\\n\\n\\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\\n\\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\\n\\n\\tbss_desc->channel = priv->adhoc_channel;\\n\\tadhoc_start->phy_param_set.ds_param_set.current_chan =\\n\\t\\tpriv->adhoc_channel;\\n\\n\\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\\n\\t       sizeof(union ieee_types_phy_param_set));\\n\\n\\t/* Set IBSS param set */\\n/* IBSS parameter IE Id */\\n#define IBSS_PARA_IE_ID   6\\n/* IBSS parameter IE length */\\n#define IBSS_PARA_IE_LEN  2\\n\\n\\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\\n\\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\\n\\tadhoc_start->ss_param_set.ibss_param_set.atim_window\\n\\t\\t\\t\\t\\t= cpu_to_le16(priv->atim_window);\\n\\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\\n\\t       sizeof(union ieee_types_ss_param_set));\\n\\n\\t/* Set Capability info */\\n\\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\\n\\ttmp_cap = WLAN_CAPABILITY_IBSS;\\n\\n\\t/* Set up privacy in bss_desc */\\n\\tif (priv->sec_info.encryption_mode) {\\n\\t\\t/* Ad-Hoc capability privacy on */\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status set privacy to WEP\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\\n\\t} else {\\n\\t\\tmwifiex_dbg(adapter, INFO,\\n\\t\\t\\t    \\\"info: ADHOC_S_CMD: wep_status NOT set,\\\\t\\\"\\n\\t\\t\\t    \\\"setting privacy to ACCEPT ALL\\\\n\\\");\\n\\t\\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\\n\\t}\\n\\n\\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\\n\\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\\n\\tif ((adapter->adhoc_start_band & BAND_G) &&\\n\\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\\n\\t\\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\\n\\t\\t\\t\\t     HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t     &priv->curr_pkt_filter, false)) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"ADHOC_S_CMD: G Protection config failed\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* Find the last non zero */\\n\\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\\n\\t\\tif (!adhoc_start->data_rate[i])\\n\\t\\t\\tbreak;\\n\\n\\tpriv->curr_bss_params.num_of_rates = i;\\n\\n\\t/* Copy the ad-hoc creating rates into Current BSS rate structure */\\n\\tmemcpy(&priv->curr_bss_params.data_rates,\\n\\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: rates=%4ph\\\\n\\\",\\n\\t\\t    adhoc_start->data_rate);\\n\\n\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: AD-HOC Start command is ready\\\\n\\\");\\n\\n\\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\\n\\t\\t/* Append a channel TLV */\\n\\t\\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\\n\\t\\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\\n\\t\\tchan_tlv->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\\n\\n\\t\\tmemset(chan_tlv->chan_scan_param, 0x00,\\n\\t\\t       sizeof(struct mwifiex_chan_scan_param_set));\\n\\t\\tchan_tlv->chan_scan_param[0].chan_number =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Chan = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].chan_number);\\n\\n\\t\\tchan_tlv->chan_scan_param[0].radio_type\\n\\t\\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\\n\\t\\tif (adapter->adhoc_start_band & BAND_GN ||\\n\\t\\t    adapter->adhoc_start_band & BAND_AN) {\\n\\t\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\\n\\t\\t\\telse if (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\\n\\t\\t\\t\\tchan_tlv->chan_scan_param[0].radio_type |=\\n\\t\\t\\t\\t\\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\\n\\t\\t}\\n\\t\\tmwifiex_dbg(adapter, INFO, \\\"info: ADHOC_S_CMD: TLV Band = %d\\\\n\\\",\\n\\t\\t\\t    chan_tlv->chan_scan_param[0].radio_type);\\n\\t\\tpos += sizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\tsizeof(chan_tlv->header) +\\n\\t\\t\\tsizeof(struct mwifiex_chan_scan_param_set);\\n\\t}\\n\\n\\t/* Append vendor specific IE TLV */\\n\\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\\n\\t\\t\\t\\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\\n\\n\\tif (priv->sec_info.wpa_enabled) {\\n\\t\\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\\n\\t\\tif (rsn_ie_len == -1)\\n\\t\\t\\treturn -1;\\n\\t\\tcmd_append_size += rsn_ie_len;\\n\\t}\\n\\n\\tif (adapter->adhoc_11n_enabled) {\\n\\t\\t/* Fill HT CAPABILITY */\\n\\t\\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\\n\\t\\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\\n\\t\\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\\n\\t\\tht_cap->header.len =\\n\\t\\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\\n\\t\\tradio_type = mwifiex_band_to_radio_type(\\n\\t\\t\\t\\t\\tpriv->adapter->config_bands);\\n\\t\\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\\n\\n\\t\\tif (adapter->sec_chan_offset ==\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\\n\\t\\t\\tu16 tmp_ht_cap;\\n\\n\\t\\t\\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\\n\\t\\t\\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\\n\\t\\t\\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\\n\\t\\t}\\n\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htcap);\\n\\t\\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\\n\\n\\t\\t/* Fill HT INFORMATION */\\n\\t\\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\\n\\t\\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\\n\\t\\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\\n\\t\\tht_info->header.len =\\n\\t\\t\\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\\n\\n\\t\\tht_info->ht_oper.primary_chan =\\n\\t\\t\\t(u8) priv->curr_bss_params.bss_descriptor.channel;\\n\\t\\tif (adapter->sec_chan_offset) {\\n\\t\\t\\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\\n\\t\\t\\tht_info->ht_oper.ht_param |=\\n\\t\\t\\t\\t\\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\\n\\t\\t}\\n\\t\\tht_info->ht_oper.operation_mode =\\n\\t\\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\\n\\t\\tht_info->ht_oper.basic_set[0] = 0xff;\\n\\t\\tpos += sizeof(struct mwifiex_ie_types_htinfo);\\n\\t\\tcmd_append_size +=\\n\\t\\t\\t\\tsizeof(struct mwifiex_ie_types_htinfo);\\n\\t}\\n\\n\\tcmd->size =\\n\\t\\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\\n\\t\\t\\t\\t  + S_DS_GEN + cmd_append_size));\\n\\n\\tif (adapter->adhoc_start_band == BAND_B)\\n\\t\\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\telse\\n\\t\\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\\n\\n\\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\\n\\n\\treturn 0;\\n}\\n\",\n            \"start_line\": 839,\n            \"end_line\": 1099,\n            \"full_name\": \"mwifiex_cmd_802_11_ad_hoc_start\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/join.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_cmd_802_11_ad_hoc_start)\",\n        \"result\": [\n          {\n            \"call_line\": 2013,\n            \"call_code\": \"mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf)\",\n            \"caller_code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 1937,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The patch clamps `ssid_len` to `IEEE80211_MAX_SSID_LEN`, but the origin of `data_buf` (user-controlled input) is not fully traced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"function: mwifiex_sta_prepare_cmd\",\n      \"caller: mwifiex_sta_prepare_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` passed to `memcpy()` in `mwifiex_cmd_802_11_ad_hoc_start`, allowing buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` in the caller `mwifiex_sta_prepare_cmd`, but the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"func_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"code\": \"int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\\n\\t\\t\\t    u16 cmd_action, u32 cmd_oid,\\n\\t\\t\\t    void *data_buf, void *cmd_buf)\\n{\\n\\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\\n\\tint ret = 0;\\n\\n\\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"0x%x command not supported by firmware\\\\n\\\",\\n\\t\\t\\t    cmd_no);\\n\\t\\treturn -EOPNOTSUPP;\\n\\t}\\n\\n\\t/* Prepare command */\\n\\tswitch (cmd_no) {\\n\\tcase HostCmd_CMD_GET_HW_SPEC:\\n\\t\\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CFG_DATA:\\n\\t\\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_CONTROL:\\n\\t\\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\\n\\t\\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\\n\\t\\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TX_RATE_CFG:\\n\\t\\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TXPWR_CFG:\\n\\t\\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_TX_PWR:\\n\\t\\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RF_ANTENNA:\\n\\t\\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\\n\\t\\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t (uint16_t)cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\\n\\t\\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t(struct mwifiex_hs_config_param *) data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN:\\n\\t\\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\\n\\t\\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_ASSOCIATE:\\n\\t\\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\\n\\t\\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_START:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_GET_LOG:\\n\\t\\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t     data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\\n\\t\\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RSSI_INFO:\\n\\t\\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SNMP_MIB:\\n\\t\\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  cmd_oid, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\\n\\t\\tcmd_ptr->command =\\n\\t\\t\\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tpriv->tx_rate = 0;\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_VERSION_EXT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.verext.version_str_sel =\\n\\t\\t\\t(u8)(get_unaligned((u32 *)data_buf));\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_version_ext));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MGMT_FRAME_REG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u32 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_REMAIN_ON_CHAN:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tmemcpy(&cmd_ptr->params, data_buf,\\n\\t\\t       sizeof(struct host_cmd_ds_remain_on_chan));\\n\\t\\tcmd_ptr->size =\\n\\t\\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\\n\\t\\t\\t\\t  S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11AC_CFG:\\n\\t\\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.pkt_aggr_ctrl.enable =\\n\\t\\t\\t\\t\\t\\tcpu_to_le16(*(u16 *)data_buf);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_P2P_MODE_CFG:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\\n\\t\\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\\n\\t\\t\\t\\t\\t\\tget_unaligned((u16 *)data_buf));\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_INIT:\\n\\t\\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\\n\\t\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FUNC_SHUTDOWN:\\n\\t\\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_REQ:\\n\\t\\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_DELBA:\\n\\t\\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_ADDBA_RSP:\\n\\t\\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\\n\\t\\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action, cmd_oid,\\n\\t\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\\n\\t\\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t      cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\\n\\t\\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\\n\\t\\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t  data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_11N_CFG:\\n\\t\\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_WMM_GET_STATUS:\\n\\t\\tmwifiex_dbg(priv->adapter, CMD,\\n\\t\\t\\t    \\\"cmd: WMM: WMM_GET_STATUS cmd sent\\\\n\\\");\\n\\t\\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\\n\\t\\tcmd_ptr->size =\\n\\t\\t\\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\\n\\t\\t\\t\\t    S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\\n\\t\\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t\\t data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SCAN_EXT:\\n\\t\\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEM_ACCESS:\\n\\t\\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MAC_REG_ACCESS:\\n\\tcase HostCmd_CMD_BBP_REG_ACCESS:\\n\\tcase HostCmd_CMD_RF_REG_ACCESS:\\n\\tcase HostCmd_CMD_PMIC_REG_ACCESS:\\n\\tcase HostCmd_CMD_CAU_REG_ACCESS:\\n\\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\\n\\t\\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SET_BSS_MODE:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_ADHOC;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type =\\n\\t\\t\\t\\tCONNECTION_TYPE_INFRA;\\n\\t\\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\\n\\t\\t\\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\\n\\t\\t\\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\\n\\t\\tcmd_ptr->size = cpu_to_le16(sizeof(struct\\n\\t\\t\\t\\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\\n\\t\\tret = 0;\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\\n\\t\\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\\n\\t\\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MEF_CFG:\\n\\t\\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_COALESCE_CFG:\\n\\t\\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t       data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_OPER:\\n\\t\\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_TDLS_CONFIG:\\n\\t\\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\\n\\t\\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\\n\\t\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\\n\\t\\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t   data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_HS_WAKEUP_REASON:\\n\\t\\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_MC_POLICY:\\n\\t\\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\tdata_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_ROBUST_COEX:\\n\\t\\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t      data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\\n\\t\\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\\n\\t\\t\\t\\t\\t\\t    data_buf);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_CHAN_REGION_CFG:\\n\\t\\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_FW_DUMP_EVENT:\\n\\t\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\t\\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\\n\\t\\tbreak;\\n\\tcase HostCmd_CMD_STA_CONFIGURE:\\n\\t\\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\\n\\t\\tbreak;\\n\\tdefault:\\n\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: unknown cmd- %#x\\\\n\\\", cmd_no);\\n\\t\\tret = -1;\\n\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n\",\n            \"start_line\": 1937,\n            \"end_line\": 2235,\n            \"full_name\": \"mwifiex_sta_prepare_cmd\",\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/sta_cmd.c\"\n          }\n        ]\n      },\n      {\n        \"source\": \"caller_info(func:mwifiex_sta_prepare_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 650,\n            \"call_code\": \"mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr)\",\n            \"caller_code\": \"int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\\n\\t\\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\\n{\\n\\tint ret;\\n\\tstruct mwifiex_adapter *adapter = priv->adapter;\\n\\tstruct cmd_ctrl_node *cmd_node;\\n\\tstruct host_cmd_ds_command *cmd_ptr;\\n\\n\\tif (!adapter) {\\n\\t\\tpr_err(\\\"PREP_CMD: adapter is NULL\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: device in suspended state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\\n\\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: host entering sleep state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: card is removed\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: FW is in bad state\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\\n\\t\\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\\n\\t\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t\\t    \\\"PREP_CMD: FW in reset state\\\\n\\\");\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\t/* We don't expect commands in manufacturing mode. They are cooked\\n\\t * in application and ready to download buffer is passed to the driver\\n\\t */\\n\\tif (adapter->mfg_mode && cmd_no) {\\n\\t\\tdev_dbg(adapter->dev, \\\"Ignoring commands in manufacturing mode\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\n\\t/* Get a new command node */\\n\\tcmd_node = mwifiex_get_cmd_node(adapter);\\n\\n\\tif (!cmd_node) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd node\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Initialize the command node */\\n\\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\\n\\n\\tif (!cmd_node->cmd_skb) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: no free cmd buf\\\\n\\\");\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\\n\\n\\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\\n\\tcmd_ptr->command = cpu_to_le16(cmd_no);\\n\\tcmd_ptr->result = 0;\\n\\n\\t/* Prepare command */\\n\\tif (cmd_no) {\\n\\t\\tswitch (cmd_no) {\\n\\t\\tcase HostCmd_CMD_UAP_SYS_CONFIG:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_START:\\n\\t\\tcase HostCmd_CMD_UAP_BSS_STOP:\\n\\t\\tcase HostCmd_CMD_UAP_STA_DEAUTH:\\n\\t\\tcase HOST_CMD_APCMD_SYS_RESET:\\n\\t\\tcase HOST_CMD_APCMD_STA_LIST:\\n\\t\\t\\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\\n\\t\\t\\t\\t\\t\\t      cmd_oid, data_buf,\\n\\t\\t\\t\\t\\t\\t      cmd_ptr);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t} else {\\n\\t\\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\\n\\t\\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\\n\\t}\\n\\n\\t/* Return error, since the command preparation failed */\\n\\tif (ret) {\\n\\t\\tmwifiex_dbg(adapter, ERROR,\\n\\t\\t\\t    \\\"PREP_CMD: cmd %#x preparation failed\\\\n\\\",\\n\\t\\t\\tcmd_no);\\n\\t\\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/* Send command */\\n\\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\\n\\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\\n\\t\\tmwifiex_queue_scan_cmd(priv, cmd_node);\\n\\t} else {\\n\\t\\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\\n\\t\\tqueue_work(adapter->workqueue, &adapter->main_work);\\n\\t\\tif (cmd_node->wait_q_enabled)\\n\\t\\t\\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\\n\\t}\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 558,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cmdevt.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `drivers/net/wireless/marvell/mwifiex/join.c:877` triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but its origin is untraced (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `req_ssid` originates from `data_buf` passed to `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013). However, the source of `data_buf` (how it is populated with user input) is not visible in the provided context. A critical gap remains in tracing `data_buf` to its origin in userspace or kernel APIs that handle SSID input.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650), but no visible caller of `mwifiex_send_cmd` handles SSID input (GAP: data_buf source).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, none of the provided callers of `mwifiex_send_cmd` handle the `HostCmd_CMD_802_11_AD_HOC_START` command with SSID input, leaving the origin of `data_buf` untraced. A critical gap remains in identifying the specific caller that populates `data_buf` with user-controlled SSID data.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"stage\": \"analysis\",\n    \"need_context\": true,\n    \"root_cause_partial\": \"Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). The origin of `data_buf` for `HostCmd_CMD_802_11_AD_HOC_START` is untraced (GAP).\",\n    \"required_context_next\": [\n      \"caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command)\"\n    ],\n    \"analysis_summary_text\": \"The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, which provides `req_ssid`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.\"\n  },\n  {\n    \"stage\": \"collection\",\n    \"result\": [\n      {\n        \"source\": \"caller_info(func:mwifiex_send_cmd)\",\n        \"result\": [\n          {\n            \"call_line\": 90,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true)\",\n            \"caller_code\": \"int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\\n{\\n\\tu32 enable = flag;\\n\\n\\t/* enable master mode radar detection on AP interface */\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\\n\\t\\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\\n}\",\n            \"caller_start\": 82,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 180,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true)\",\n            \"caller_code\": \"int mwifiex_stop_radar_detection(struct mwifiex_private *priv,\\n\\t\\t\\t\\t struct cfg80211_chan_def *chandef)\\n{\\n\\tstruct mwifiex_radar_params radar_params;\\n\\n\\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\\n\\tradar_params.chandef = chandef;\\n\\tradar_params.cac_time_ms = 0;\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\\n}\",\n            \"caller_start\": 171,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11h.c\"\n          },\n          {\n            \"call_line\": 643,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false)\",\n            \"caller_code\": \"int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\\n{\\n\\tstruct host_cmd_ds_11n_addba_req add_ba_req;\\n\\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\\n\\tstatic u8 dialog_tok;\\n\\tint ret;\\n\\tu16 block_ack_param_set;\\n\\n\\tmwifiex_dbg(priv->adapter, CMD, \\\"cmd: %s: tid %d\\\\n\\\", __func__, tid);\\n\\n\\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\\n\\n\\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\\n\\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\\n\\t    priv->adapter->is_hw_11ac_capable &&\\n\\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\\n\\t\\tstruct mwifiex_sta_node *sta_ptr;\\n\\n\\t\\tspin_lock_bh(&priv->sta_list_spinlock);\\n\\t\\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\\n\\t\\tif (!sta_ptr) {\\n\\t\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t\\t\\tmwifiex_dbg(priv->adapter, ERROR,\\n\\t\\t\\t\\t    \\\"BA setup with unknown TDLS peer %pM!\\\\n\\\",\\n\\t\\t\\t\\t    peer_mac);\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tif (sta_ptr->is_11ac_enabled)\\n\\t\\t\\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\\n\\t\\tspin_unlock_bh(&priv->sta_list_spinlock);\\n\\t}\\n\\n\\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\\n\\t\\t\\t\\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\\n\\t\\t\\t\\t    IMMEDIATE_BLOCK_ACK);\\n\\n\\t/* enable AMSDU inside AMPDU */\\n\\tif (priv->add_ba_param.tx_amsdu &&\\n\\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\\n\\t\\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\\n\\n\\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\\n\\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\\n\\n\\t++dialog_tok;\\n\\n\\tif (dialog_tok == 0)\\n\\t\\tdialog_tok = 1;\\n\\n\\tadd_ba_req.dialog_token = dialog_tok;\\n\\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\\n\\t\\t\\t       0, 0, &add_ba_req, false);\\n\\n\\treturn ret;\\n}\\n\",\n            \"caller_start\": 590,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 671,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false)\",\n            \"caller_code\": \"int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\\n\\t\\t       int initiator)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\tint ret;\\n\\tuint16_t del_ba_param_set;\\n\\n\\tmemset(&delba, 0, sizeof(delba));\\n\\tdelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\\n\\n\\tdel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\\n\\tif (initiator)\\n\\t\\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\telse\\n\\t\\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\\n\\n\\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\\n\\n\\t/* We don't wait for the response of this command */\\n\\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\\n\\t\\t\\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\\n\\n\\treturn ret;\\n}\",\n            \"caller_start\": 652,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n.c\"\n          },\n          {\n            \"call_line\": 790,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false)\",\n            \"caller_code\": \"void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\\n\\t\\t\\t\\t   struct host_cmd_ds_11n_batimeout *event)\\n{\\n\\tstruct host_cmd_ds_11n_delba delba;\\n\\n\\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\\n\\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\\n\\n\\tdelba.del_ba_param_set |=\\n\\t\\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\\n\\tdelba.del_ba_param_set |= cpu_to_le16(\\n\\t\\t(u16) event->origninator << DELBA_INITIATOR_POS);\\n\\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\\n\\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\\n}\",\n            \"caller_start\": 777,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c\"\n          },\n          {\n            \"call_line\": 282,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false)\",\n            \"caller_code\": \"static void\\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\\n\\t\\t\\t\\t\\t\\t struct wireless_dev *wdev,\\n\\t\\t\\t\\t\\t\\t struct mgmt_frame_regs *upd)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\\n\\tu32 mask = upd->interface_stypes;\\n\\n\\tif (mask != priv->mgmt_frame_mask) {\\n\\t\\tpriv->mgmt_frame_mask = mask;\\n\\t\\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\\n\\t\\t\\t\\t HostCmd_ACT_GEN_SET, 0,\\n\\t\\t\\t\\t &priv->mgmt_frame_mask, false);\\n\\t\\tmwifiex_dbg(priv->adapter, INFO, \\\"info: mgmt frame registered\\\\n\\\");\\n\\t}\\n}\",\n            \"caller_start\": 272,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 407,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\\n\\t\\t\\t      struct wireless_dev *wdev,\\n\\t\\t\\t      int *dbm)\\n{\\n\\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\\n\\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\\n\\t\\t\\t\\t\\t\\t\\tMWIFIEX_BSS_ROLE_ANY);\\n\\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\\n\\t\\t\\t\\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\\n\\n\\tif (ret < 0)\\n\\t\\treturn ret;\\n\\n\\t/* tx_power_level is set in HostCmd_CMD_RF_TX_PWR command handler */\\n\\t*dbm = priv->tx_power_level;\\n\\n\\treturn 0;\\n}\",\n            \"caller_start\": 399,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          },\n          {\n            \"call_line\": 522,\n            \"call_code\": \"mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true)\",\n            \"caller_code\": \"static int\\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\\n\\t\\t\\t\\t      struct net_device *netdev,\\n\\t\\t\\t\\t      u8 key_index)\\n{\\n\\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\\n\\tstruct mwifiex_ds_encrypt_key encrypt_key;\\n\\n\\twiphy_dbg(wiphy, \\\"set default mgmt key, key index=%d\\\\n\\\", key_index);\\n\\n\\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\\n\\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\\n\\tencrypt_key.key_index = key_index;\\n\\tencrypt_key.is_igtk_def_key = true;\\n\\teth_broadcast_addr(encrypt_key.mac_addr);\\n\\n\\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\\n\\t\\t\\t\\tHostCmd_ACT_GEN_SET, true, &encrypt_key, true);\\n}\",\n            \"caller_start\": 506,\n            \"file_path\": \"drivers/net/wireless/marvell/mwifiex/cfg80211.c\"\n          }\n        ]\n      }\n    ]\n  }\n]\n\n## INSTRUCTIONS\n1. **Review & Integrate Context** \n  Review all `history_summary` (*incl. past analysis and request results*) \n\n2. **Extend Chain from Code**  \n   Trace calls / data flow step-by-step, citing `file:line` for each fact.  \n   Where evidence ends, insert  \n   `GAP: <why evidence stops>`.\n\n3. **Request Missing Context**  \n   If any critical gap remains:  \n     * Always request context and set `\"need_context\": true`. \n     * Add precise, non-duplicate requests to `\"required_context\"` using the following types:  \n      `function`, `caller`, `e.g. caller: I need the caller of function X in file Y`.\n      **DO NOT** request the new patch code.\n     * Try alternative parameters or request types for gaps previously unfulfilled.  \n   If the chain is fully evidenced, set `\"need_context\": false`.\n\n4. **Score Confidence**  \n   *Full chain with direct evidence*  0.90.  Incomplete chain  0.75.\n\n## OUTPUT  (JSON only, no trailing commas)\n  ```json\n  {\n      \"analysis\": \"Summary of iteration progress, remaining gaps, explanation for new context requests (if any). If complete, summarize the full chain.\",\n      \"need_context\": true/false, \n      \"required_context\": \"<list of precise context requests>\" ,\n      \"root_cause\": \"<Partial/complete trace with file:line evidence from ALL available context>\",\n      \"confidence_score\": 0.0-1.0\n      // attack_vectors added when confidence >= 0.90 AND need_context is False\n  }\n  ```\n  ## RULES\n  * Output must be valid JSON.\n  * **Source-of-Truth**  Only accept facts visible in code (file:line). Commit message & description are auxiliary.\n  * **Reject every hypothesis or inference** - When evidence is missing, always declare a GAP and request the needed context.\n  * **Tool Restriction**  `required_context` items **must** be of type `function` or `caller` only.\n  * **Stop Condition**  Terminate only when the trigger chain is fully evidenced from the patch; else continue requesting context.\n",
            "result": {
                "analysis": "The root cause is an unchecked `req_ssid->ssid_len` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877), leading to a buffer overflow via `memcpy()`. The patch clamps the length to `IEEE80211_MAX_SSID_LEN`. The `data_buf` parameter, containing `struct cfg80211_ssid` with user-controlled `ssid_len`, is passed through `mwifiex_sta_prepare_cmd` (drivers/net/wireless/marvell/mwifiex/sta_cmd.c:2013) and `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650). However, no caller of `mwifiex_send_cmd` handling `HostCmd_CMD_802_11_AD_HOC_START` is visible in the provided context. The origin of `data_buf` (user-controlled SSID input) remains untraced.",
                "need_context": true,
                "required_context": [
                    "caller: mwifiex_send_cmd (specific to HostCmd_CMD_802_11_AD_HOC_START command in cfg80211 or netlink interface)"
                ],
                "root_cause": "Unbounded `req_ssid->ssid_len` from `data_buf` in `mwifiex_cmd_802_11_ad_hoc_start` (drivers/net/wireless/marvell/mwifiex/join.c:877) triggers buffer overflow via `memcpy()`. The `data_buf` is populated with `struct cfg80211_ssid` from userspace via `mwifiex_send_cmd` (drivers/net/wireless/marvell/mwifiex/cmdevt.c:650) but the exact caller initiating `HostCmd_CMD_802_11_AD_HOC_START` with this data is missing from the context.",
                "confidence_score": 0.75
            },
            "timestamp": "2025-05-26T15:58:39.547696"
        }
    ],
    "debug_trace": [
        "Collected 2 context items. (0 failed)",
        "Performed analysis iteration 1. Needs more context: True. Confidence: 0.75",
        "Collected 2 context items. (0 failed)",
        "Performed analysis iteration 2. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 3. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 4. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 5. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 6. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 7. Needs more context: True. Confidence: 0.75",
        "Collected 1 context items. (0 failed)",
        "Performed analysis iteration 8. Needs more context: True. Confidence: 0.75",
        "Report generation completed."
    ],
    "status": "completed",
    "error": null
}