{
  "cve_id": "CVE-2023-37457",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H",
  "cvss_is_v3": true,
  "repo_name": "asterisk",
  "commit_msg": "res_pjsip_header_funcs: Duplicate new header value, don't copy.\n\nWhen updating an existing header the 'update' code incorrectly\njust copied the new value into the existing buffer. If the\nnew value exceeded the available buffer size memory outside\nof the buffer would be written into, potentially causing\na crash.\n\nThis change makes it so that the 'update' now duplicates\nthe new header value instead of copying it into the existing\nbuffer.",
  "commit_hash": "a1ca0268254374b515fa5992f01340f7717113fa",
  "git_url": "https://github.com/asterisk/asterisk/commit/a1ca0268254374b515fa5992f01340f7717113fa",
  "file_path": "res/res_pjsip_header_funcs.c",
  "func_name": "update_header",
  "func_before": "static int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\n\treturn 0;\n}",
  "abstract_func_before": "static int update_header(void *VAR_0)\n{\n\tstruct header_data *VAR_1 = VAR_0;\n\tpjsip_hdr *VAR_2 = NULL;\n\tVAR_3(struct ast_datastore *, VAR_4,\n\t\t\t ast_sip_session_get_datastore(VAR_1->channel->session, VAR_1->header_datastore->type),\n\t\t\t VAR_5);\n\n\tif (!VAR_4 || !VAR_4->data) {\n\t\tast_log(VAR_6, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\tVAR_2 = find_header((struct hdr_list *) VAR_4->data, VAR_1->header_name,\n\t\t\t\t\t  VAR_1->header_number);\n\n\tif (!VAR_2) {\n\t\tast_log(VAR_6, \"There was no header named %s.\\n\", VAR_1->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_strcpy2(&((pjsip_generic_string_hdr *) VAR_2)->hvalue, VAR_1->header_value);\n\n\treturn 0;\n}",
  "func_graph_path_before": "asterisk/a1ca0268254374b515fa5992f01340f7717113fa/res_pjsip_header_funcs.c/vul/before/0.json",
  "func": "static int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpj_pool_t *pool = data->channel->session->inv_session->dlg->pool;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_strdup2(pool, &((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\n\treturn 0;\n}",
  "abstract_func": "static int update_header(void *VAR_0)\n{\n\tstruct header_data *VAR_1 = VAR_0;\n\tpj_pool_t *VAR_2 = VAR_1->channel->session->inv_session->dlg->pool;\n\tpjsip_hdr *VAR_3 = NULL;\n\tVAR_4(struct ast_datastore *, VAR_5,\n\t\t\t ast_sip_session_get_datastore(VAR_1->channel->session, VAR_1->header_datastore->type),\n\t\t\t VAR_6);\n\n\tif (!VAR_5 || !VAR_5->data) {\n\t\tast_log(VAR_7, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\n\tVAR_3 = find_header((struct hdr_list *) VAR_5->data, VAR_1->header_name,\n\t\t\t\t\t  VAR_1->header_number);\n\n\tif (!VAR_3) {\n\t\tast_log(VAR_7, \"There was no header named %s.\\n\", VAR_1->header_name);\n\t\treturn -1;\n\t}\n\n\tpj_strdup2(VAR_2, &((pjsip_generic_string_hdr *) VAR_3)->hvalue, VAR_1->header_value);\n\n\treturn 0;\n}",
  "func_graph_path": "asterisk/a1ca0268254374b515fa5992f01340f7717113fa/res_pjsip_header_funcs.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n static int update_header(void *obj)\n {\n \tstruct header_data *data = obj;\n+\tpj_pool_t *pool = data->channel->session->inv_session->dlg->pool;\n \tpjsip_hdr *hdr = NULL;\n \tRAII_VAR(struct ast_datastore *, datastore,\n \t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n@@ -19,7 +20,7 @@\n \t\treturn -1;\n \t}\n \n-\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n+\tpj_strdup2(pool, &((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n \n \treturn 0;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);"
    ],
    "added_lines": [
      "\tpj_pool_t *pool = data->channel->session->inv_session->dlg->pool;",
      "\tpj_strdup2(pool, &((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/asterisk/asterisk/pull/497",
  "description": {
    "pr_info": {
      "title": "res_pjsip_header_funcs: Duplicate new header value, don't copy.",
      "number": 497
    },
    "comment": [
      "When updating an existing header the 'update' code incorrectly\njust copied the new value into the existing buffer. If the\nnew value exceeded the available buffer size memory outside\nof the buffer would be written into, potentially causing\na crash.\n\nThis change makes it so that the 'update' now duplicates\nthe new header value instead of copying it into the existing\nbuffer.\n",
      "cherry-pick-to: 18\r\ncherry-pick-to: 20\r\ncherry-pick-to: 21\r\ncherry-pick-to: certified/18.9",
      "cherry-pick-test",
      "Successfully merged to branch master and cherry-picked to [\"18\",\"20\",\"21\",\"certified/18.9\"]"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}