{
  "cve_id": "CVE-2023-45145",
  "cwe_ids": [
    "CWE-668"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145) (#12671)\n\nBefore this commit, Unix socket setup performed chmod(2) on the socket\r\nfile after calling listen(2). Depending on what umask is used, this\r\ncould leave the file with the wrong permissions for a short period of\r\ntime. As a result, another process could exploit this race condition and\r\nestablish a connection that would otherwise not be possible.\r\n\r\nWe now make sure the socket permissions are set up prior to calling\r\nlisten(2).\r\n\r\n(cherry picked from commit 1119ecae6fd8796fa337df2212f09173ab6c7b0a)\r\n\r\nCo-authored-by: Yossi Gottlieb <yossigo@gmail.com>",
  "commit_hash": "03345ddc7faf7af079485f2cbe5d17a1611cbce1",
  "git_url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1",
  "file_path": "src/anet.c",
  "func_name": "anetUnixServer",
  "func_before": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}",
  "abstract_func_before": "int anetUnixServer(char *VAR_0, char *VAR_1, mode_t VAR_2, int VAR_3)\n{\n    int VAR_4;\n    struct sockaddr_un VAR_5;\n\n    if (strlen(VAR_1) > sizeof(VAR_5.sun_path)-1) {\n        anetSetError(VAR_0,\"unix socket path too long (%zu), must be under %zu\", strlen(VAR_1), sizeof(VAR_5.sun_path));\n        return VAR_6;\n    }\n    if ((VAR_4 = anetCreateSocket(VAR_0,VAR_7)) == VAR_6)\n        return VAR_6;\n\n    memset(&VAR_5,0,sizeof(VAR_5));\n    VAR_5.sun_family = VAR_7;\n    redis_strlcpy(VAR_5.sun_path,VAR_1,sizeof(VAR_5.sun_path));\n    if (anetListen(VAR_0,VAR_4,(struct sockaddr*)&VAR_5,sizeof(VAR_5),VAR_3) == VAR_6)\n        return VAR_6;\n    if (VAR_2)\n        chmod(VAR_5.sun_path, VAR_2);\n    return VAR_4;\n}",
  "func_graph_path_before": "redis/03345ddc7faf7af079485f2cbe5d17a1611cbce1/anet.c/vul/before/1.json",
  "func": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)\n        return ANET_ERR;\n    return s;\n}",
  "abstract_func": "int anetUnixServer(char *VAR_0, char *VAR_1, mode_t VAR_2, int VAR_3)\n{\n    int VAR_4;\n    struct sockaddr_un VAR_5;\n\n    if (strlen(VAR_1) > sizeof(VAR_5.sun_path)-1) {\n        anetSetError(VAR_0,\"unix socket path too long (%zu), must be under %zu\", strlen(VAR_1), sizeof(VAR_5.sun_path));\n        return VAR_6;\n    }\n    if ((VAR_4 = anetCreateSocket(VAR_0,VAR_7)) == VAR_6)\n        return VAR_6;\n\n    memset(&VAR_5,0,sizeof(VAR_5));\n    VAR_5.sun_family = VAR_7;\n    redis_strlcpy(VAR_5.sun_path,VAR_1,sizeof(VAR_5.sun_path));\n    if (anetListen(VAR_0,VAR_4,(struct sockaddr*)&VAR_5,sizeof(VAR_5),VAR_3,VAR_2) == VAR_6)\n        return VAR_6;\n    return VAR_4;\n}",
  "func_graph_path": "redis/03345ddc7faf7af079485f2cbe5d17a1611cbce1/anet.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,9 +13,7 @@\n     memset(&sa,0,sizeof(sa));\n     sa.sun_family = AF_LOCAL;\n     redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n-    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n+    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)\n         return ANET_ERR;\n-    if (perm)\n-        chmod(sa.sun_path, perm);\n     return s;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)",
      "    if (perm)",
      "        chmod(sa.sun_path, perm);"
    ],
    "added_lines": [
      "    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/12671",
  "description": {
    "pr_info": {
      "title": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145)",
      "number": 12671
    },
    "comment": [
      "Before this commit, Unix socket setup performed chmod(2) on the socket file after calling listen(2). Depending on what umask is used, this could leave the file with the wrong permissions for a short period of time. As a result, another process could exploit this race condition and establish a connection that would otherwise not be possible.\r\n\r\nWe now make sure the socket permissions are set up prior to calling listen(2).",
      "released in 7.2.2, 7.0.14, and 6.2.14.\r\nthis PR is for unstable.",
      "Hello @oranagra is this applicable for docker Redis servers?",
      "It depends on the configuration. If a Unix socket is exposed outside the container then it could apply.",
      "Thanks @yossigo for confirmation."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}