{
  "cve_id": "CVE-2018-20362",
  "cwe_ids": [
    "CWE-787",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "sbr_hfadj: sanitize frequency band borders\n\nuser passed f_table_lim contains frequency band borders. Frequency\nbands are groups of consecutive QMF channels. This means that their\nbounds, as provided by f_table_lim, should never exceed MAX_M (maximum\nnumber of QMF channels). c.f. ISO/IEC 14496-3:2001\n\nFAAD2 does not verify this, leading to security issues when\nprocessing files defining f_table_lim with values > MAX_M.\n\nThis patch sanitizes the values of f_table_lim so that they can be safely\nused as index for Q_M_lim and G_lim arrays.\n\nFixes #21 (CVE-2018-20194).",
  "commit_hash": "6b4a7cde30f2e2cb03e78ef476cc73179cfffda3",
  "git_url": "https://github.com/knik0/faad2/commit/6b4a7cde30f2e2cb03e78ef476cc73179cfffda3",
  "file_path": "libfaad/sbr_hfadj.c",
  "func_name": "calculate_gain",
  "func_before": "static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)\n{\n    /* log2 values of limiter gains */\n    static real_t limGain[] = { -1.0, 0.0, 1.0, 33.219 };\n    uint8_t m, l, k;\n\n    uint8_t current_t_noise_band = 0;\n    uint8_t S_mapped;\n\n    ALIGN real_t Q_M_lim[MAX_M];\n    ALIGN real_t G_lim[MAX_M];\n    ALIGN real_t G_boost;\n    ALIGN real_t S_M[MAX_M];\n\n\n    for (l = 0; l < sbr->L_E[ch]; l++)\n    {\n        uint8_t current_f_noise_band = 0;\n        uint8_t current_res_band = 0;\n        uint8_t current_res_band2 = 0;\n        uint8_t current_hi_res_band = 0;\n\n        real_t delta = (l == sbr->l_A[ch] || l == sbr->prevEnvIsShort[ch]) ? 0 : 1;\n\n        S_mapped = get_S_mapped(sbr, ch, l, current_res_band2);\n\n        if (sbr->t_E[ch][l+1] > sbr->t_Q[ch][current_t_noise_band+1])\n        {\n            current_t_noise_band++;\n        }\n\n        for (k = 0; k < sbr->N_L[sbr->bs_limiter_bands]; k++)\n        {\n            real_t Q_M = 0;\n            real_t G_max;\n            real_t den = 0;\n            real_t acc1 = 0;\n            real_t acc2 = 0;\n            uint8_t current_res_band_size = 0;\n            uint8_t Q_M_size = 0;\n\n            uint8_t ml1, ml2;\n\n            /* bounds of current limiter bands */\n            ml1 = sbr->f_table_lim[sbr->bs_limiter_bands][k];\n            ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];\n\n\n            /* calculate the accumulated E_orig and E_curr over the limiter band */\n            for (m = ml1; m < ml2; m++)\n            {\n                if ((m + sbr->kx) < sbr->f_table_res[sbr->f[ch][l]][current_res_band+1])\n                {\n                    current_res_band_size++;\n                } else {\n                    acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch)));\n\n                    current_res_band++;\n                    current_res_band_size = 1;\n                }\n\n                acc2 += QUANTISE2INT(sbr->E_curr[ch][m][l]/1024.0);\n            }\n            acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch)));\n\n            acc1 = QUANTISE2REAL( log2(EPS + acc1) );\n\n\n            /* calculate the maximum gain */\n            /* ratio of the energy of the original signal and the energy\n             * of the HF generated signal\n             */\n            G_max = acc1 - QUANTISE2REAL(log2(EPS + acc2)) + QUANTISE2REAL(limGain[sbr->bs_limiter_gains]);\n            G_max = min(G_max, QUANTISE2REAL(limGain[3]));\n\n\n            for (m = ml1; m < ml2; m++)\n            {\n                real_t G;\n                real_t E_curr, E_orig;\n                real_t Q_orig, Q_orig_plus1;\n                uint8_t S_index_mapped;\n\n\n                /* check if m is on a noise band border */\n                if ((m + sbr->kx) == sbr->f_table_noise[current_f_noise_band+1])\n                {\n                    /* step to next noise band */\n                    current_f_noise_band++;\n                }\n\n\n                /* check if m is on a resolution band border */\n                if ((m + sbr->kx) == sbr->f_table_res[sbr->f[ch][l]][current_res_band2+1])\n                {\n                    /* accumulate a whole range of equal Q_Ms */\n                    if (Q_M_size > 0)\n                        den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M));\n                    Q_M_size = 0;\n\n                    /* step to next resolution band */\n                    current_res_band2++;\n\n                    /* if we move to a new resolution band, we should check if we are\n                     * going to add a sinusoid in this band\n                     */\n                    S_mapped = get_S_mapped(sbr, ch, l, current_res_band2);\n                }\n\n\n                /* check if m is on a HI_RES band border */\n                if ((m + sbr->kx) == sbr->f_table_res[HI_RES][current_hi_res_band+1])\n                {\n                    /* step to next HI_RES band */\n                    current_hi_res_band++;\n                }\n\n\n                /* find S_index_mapped\n                 * S_index_mapped can only be 1 for the m in the middle of the\n                 * current HI_RES band\n                 */\n                S_index_mapped = 0;\n                if ((l >= sbr->l_A[ch]) ||\n                    (sbr->bs_add_harmonic_prev[ch][current_hi_res_band] && sbr->bs_add_harmonic_flag_prev[ch]))\n                {\n                    /* find the middle subband of the HI_RES frequency band */\n                    if ((m + sbr->kx) == (sbr->f_table_res[HI_RES][current_hi_res_band+1] + sbr->f_table_res[HI_RES][current_hi_res_band]) >> 1)\n                        S_index_mapped = sbr->bs_add_harmonic[ch][current_hi_res_band];\n                }\n\n\n                /* find bitstream parameters */\n                if (sbr->E_curr[ch][m][l] == 0)\n                    E_curr = LOG2_MIN_INF;\n                else\n                    E_curr = -10 + log2(sbr->E_curr[ch][m][l]);\n                E_orig = -10 + find_log2_E(sbr, current_res_band2, l, ch);\n\n                Q_orig = find_log2_Q(sbr, current_f_noise_band, current_t_noise_band, ch);\n                Q_orig_plus1 = find_log2_Qplus1(sbr, current_f_noise_band, current_t_noise_band, ch);\n\n\n                /* Q_M only depends on E_orig and Q_div2:\n                 * since N_Q <= N_Low <= N_High we only need to recalculate Q_M on\n                 * a change of current res band (HI or LO)\n                 */\n                Q_M = E_orig + Q_orig - Q_orig_plus1;\n\n\n                /* S_M only depends on E_orig, Q_div and S_index_mapped:\n                 * S_index_mapped can only be non-zero once per HI_RES band\n                 */\n                if (S_index_mapped == 0)\n                {\n                    S_M[m] = LOG2_MIN_INF; /* -inf */\n                } else {\n                    S_M[m] = E_orig - Q_orig_plus1;\n\n                    /* accumulate sinusoid part of the total energy */\n                    den += pow2(S_M[m]);\n                }\n\n\n                /* calculate gain */\n                /* ratio of the energy of the original signal and the energy\n                 * of the HF generated signal\n                 */\n                /* E_curr here is officially E_curr+1 so the log2() of that can never be < 0 */\n                /* scaled by -10 */\n                G = E_orig - max(-10, E_curr);\n                if ((S_mapped == 0) && (delta == 1))\n                {\n                    /* G = G * 1/(1+Q) */\n                    G -= Q_orig_plus1;\n                } else if (S_mapped == 1) {\n                    /* G = G * Q/(1+Q) */\n                    G += Q_orig - Q_orig_plus1;\n                }\n\n\n                /* limit the additional noise energy level */\n                /* and apply the limiter */\n                if (G_max > G)\n                {\n                    Q_M_lim[m] = QUANTISE2REAL(Q_M);\n                    G_lim[m] = QUANTISE2REAL(G);\n\n                    if ((S_index_mapped == 0) && (l != sbr->l_A[ch]))\n                    {\n                        Q_M_size++;\n                    }\n                } else {\n                    /* G > G_max */\n                    Q_M_lim[m] = QUANTISE2REAL(Q_M) + G_max - QUANTISE2REAL(G);\n                    G_lim[m] = G_max;\n\n                    /* accumulate limited Q_M */\n                    if ((S_index_mapped == 0) && (l != sbr->l_A[ch]))\n                    {\n                        den += QUANTISE2INT(pow2(Q_M_lim[m]));\n                    }\n                }\n\n\n                /* accumulate the total energy */\n                /* E_curr changes for every m so we do need to accumulate every m */\n                den += QUANTISE2INT(pow2(E_curr + G_lim[m]));\n            }\n\n            /* accumulate last range of equal Q_Ms */\n            if (Q_M_size > 0)\n            {\n                den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M));\n            }\n\n\n            /* calculate the final gain */\n            /* G_boost: [0..2.51188643] */\n            G_boost = acc1 - QUANTISE2REAL(log2(den + EPS));\n            G_boost = min(G_boost, QUANTISE2REAL(1.328771237) /* log2(1.584893192 ^ 2) */);\n\n\n            for (m = ml1; m < ml2; m++)\n            {\n                /* apply compensation to gain, noise floor sf's and sinusoid levels */\n#ifndef SBR_LOW_POWER\n                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0));\n#else\n                /* sqrt() will be done after the aliasing reduction to save a\n                 * few multiplies\n                 */\n                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2(G_lim[m] + G_boost));\n#endif\n                adj->Q_M_lim_boost[l][m] = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0));\n\n                if (S_M[m] != LOG2_MIN_INF)\n                {\n                    adj->S_M_boost[l][m] = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0));\n                } else {\n                    adj->S_M_boost[l][m] = 0;\n                }\n            }\n        }\n    }\n}",
  "abstract_func_before": "static void calculate_gain(sbr_info *VAR_0, sbr_hfadj_info *VAR_1, uint8_t VAR_2)\n{\n    /* COMMENT_0 */\n    static real_t VAR_3[] = { -1.0, 0.0, 1.0, 33.219 };\n    uint8_t VAR_4, VAR_5, VAR_6;\n\n    uint8_t VAR_7 = 0;\n    uint8_t VAR_8;\n\n    ALIGN real_t VAR_9[VAR_10];\n    ALIGN real_t VAR_11[VAR_10];\n    ALIGN real_t VAR_12;\n    ALIGN real_t VAR_13[VAR_10];\n\n\n    for (VAR_5 = 0; VAR_5 < VAR_0->L_E[VAR_2]; VAR_5++)\n    {\n        uint8_t VAR_14 = 0;\n        uint8_t VAR_15 = 0;\n        uint8_t VAR_16 = 0;\n        uint8_t VAR_17 = 0;\n\n        real_t VAR_18 = (VAR_5 == VAR_0->l_A[VAR_2] || VAR_5 == VAR_0->prevEnvIsShort[VAR_2]) ? 0 : 1;\n\n        VAR_8 = get_S_mapped(VAR_0, VAR_2, VAR_5, VAR_16);\n\n        if (VAR_0->t_E[VAR_2][VAR_5+1] > VAR_0->t_Q[VAR_2][VAR_7+1])\n        {\n            VAR_7++;\n        }\n\n        for (VAR_6 = 0; VAR_6 < VAR_0->N_L[VAR_0->bs_limiter_bands]; VAR_6++)\n        {\n            real_t VAR_19 = 0;\n            real_t VAR_20;\n            real_t VAR_21 = 0;\n            real_t VAR_22 = 0;\n            real_t VAR_23 = 0;\n            uint8_t VAR_24 = 0;\n            uint8_t VAR_25 = 0;\n\n            uint8_t VAR_26, VAR_27;\n\n            /* COMMENT_1 */\n            VAR_26 = VAR_0->f_table_lim[VAR_0->bs_limiter_bands][VAR_6];\n            VAR_27 = VAR_0->f_table_lim[VAR_0->bs_limiter_bands][VAR_6+1];\n\n\n            /* COMMENT_2 */\n            for (VAR_4 = VAR_26; VAR_4 < VAR_27; VAR_4++)\n            {\n                if ((VAR_4 + VAR_0->kx) < VAR_0->f_table_res[VAR_0->f[VAR_2][VAR_5]][VAR_15+1])\n                {\n                    VAR_24++;\n                } else {\n                    VAR_22 += QUANTISE2INT(pow2(-10 + VAR_28[VAR_24] + find_log2_E(VAR_0, VAR_15, VAR_5, VAR_2)));\n\n                    VAR_15++;\n                    VAR_24 = 1;\n                }\n\n                VAR_23 += QUANTISE2INT(VAR_0->E_curr[VAR_2][VAR_4][VAR_5]/1024.0);\n            }\n            VAR_22 += QUANTISE2INT(pow2(-10 + VAR_28[VAR_24] + find_log2_E(VAR_0, VAR_15, VAR_5, VAR_2)));\n\n            VAR_22 = QUANTISE2REAL( log2(VAR_29 + VAR_22) );\n\n\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n                                         \n               \n            VAR_20 = VAR_22 - QUANTISE2REAL(log2(VAR_29 + VAR_23)) + QUANTISE2REAL(VAR_3[VAR_0->bs_limiter_gains]);\n            VAR_20 = min(VAR_20, QUANTISE2REAL(VAR_3[3]));\n\n\n            for (VAR_4 = VAR_26; VAR_4 < VAR_27; VAR_4++)\n            {\n                real_t VAR_30;\n                real_t VAR_31, VAR_32;\n                real_t VAR_33, VAR_34;\n                uint8_t VAR_35;\n\n\n                /* COMMENT_7 */\n                if ((VAR_4 + VAR_0->kx) == VAR_0->f_table_noise[VAR_14+1])\n                {\n                    /* COMMENT_8 */\n                    VAR_14++;\n                }\n\n\n                /* COMMENT_9 */\n                if ((VAR_4 + VAR_0->kx) == VAR_0->f_table_res[VAR_0->f[VAR_2][VAR_5]][VAR_16+1])\n                {\n                    /* COMMENT_10 */\n                    if (VAR_25 > 0)\n                        VAR_21 += QUANTISE2INT(pow2(VAR_28[VAR_25] + VAR_19));\n                    VAR_25 = 0;\n\n                    /* COMMENT_11 */\n                    VAR_16++;\n\n                    /* COMMENT_12 */\n                                                           \n                       \n                    VAR_8 = get_S_mapped(VAR_0, VAR_2, VAR_5, VAR_16);\n                }\n\n\n                /* COMMENT_15 */\n                if ((VAR_4 + VAR_0->kx) == VAR_0->f_table_res[VAR_36][VAR_17+1])\n                {\n                    /* COMMENT_16 */\n                    VAR_17++;\n                }\n\n\n                /* COMMENT_17 */\n                                                                              \n                                      \n                   \n                VAR_35 = 0;\n                if ((VAR_5 >= VAR_0->l_A[VAR_2]) ||\n                    (VAR_0->bs_add_harmonic_prev[VAR_2][VAR_17] && VAR_0->bs_add_harmonic_flag_prev[VAR_2]))\n                {\n                    /* COMMENT_21 */\n                    if ((VAR_4 + VAR_0->kx) == (VAR_0->f_table_res[VAR_36][VAR_17+1] + VAR_0->f_table_res[VAR_36][VAR_17]) >> 1)\n                        VAR_35 = VAR_0->bs_add_harmonic[VAR_2][VAR_17];\n                }\n\n\n                /* COMMENT_22 */\n                if (VAR_0->E_curr[VAR_2][VAR_4][VAR_5] == 0)\n                    VAR_31 = VAR_37;\n                else\n                    VAR_31 = -10 + log2(VAR_0->E_curr[VAR_2][VAR_4][VAR_5]);\n                VAR_32 = -10 + find_log2_E(VAR_0, VAR_16, VAR_5, VAR_2);\n\n                VAR_33 = find_log2_Q(VAR_0, VAR_14, VAR_7, VAR_2);\n                VAR_34 = find_log2_Qplus1(VAR_0, VAR_14, VAR_7, VAR_2);\n\n\n                /* COMMENT_23 */\n                                                                                  \n                                                          \n                   \n                VAR_19 = VAR_32 + VAR_33 - VAR_34;\n\n\n                /* COMMENT_27 */\n                                                                           \n                   \n                if (VAR_35 == 0)\n                {\n                    VAR_13[VAR_4] = VAR_37; /* COMMENT_30 */\n                } else {\n                    VAR_13[VAR_4] = VAR_32 - VAR_34;\n\n                    /* COMMENT_31 */\n                    VAR_21 += pow2(VAR_13[VAR_4]);\n                }\n\n\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n                                             \n                   \n                /* COMMENT_36 */\n                /* COMMENT_37 */\n                VAR_30 = VAR_32 - max(-10, VAR_31);\n                if ((VAR_8 == 0) && (VAR_18 == 1))\n                {\n                    /* COMMENT_38 */\n                    VAR_30 -= VAR_34;\n                } else if (VAR_8 == 1) {\n                    /* COMMENT_39 */\n                    VAR_30 += VAR_33 - VAR_34;\n                }\n\n\n                /* COMMENT_40 */\n                /* COMMENT_41 */\n                if (VAR_20 > VAR_30)\n                {\n                    VAR_9[VAR_4] = QUANTISE2REAL(VAR_19);\n                    VAR_11[VAR_4] = QUANTISE2REAL(VAR_30);\n\n                    if ((VAR_35 == 0) && (VAR_5 != VAR_0->l_A[VAR_2]))\n                    {\n                        VAR_25++;\n                    }\n                } else {\n                    /* COMMENT_42 */\n                    VAR_9[VAR_4] = QUANTISE2REAL(VAR_19) + VAR_20 - QUANTISE2REAL(VAR_30);\n                    VAR_11[VAR_4] = VAR_20;\n\n                    /* COMMENT_43 */\n                    if ((VAR_35 == 0) && (VAR_5 != VAR_0->l_A[VAR_2]))\n                    {\n                        VAR_21 += QUANTISE2INT(pow2(VAR_9[VAR_4]));\n                    }\n                }\n\n\n                /* COMMENT_44 */\n                /* COMMENT_45 */\n                VAR_21 += QUANTISE2INT(pow2(VAR_31 + VAR_11[VAR_4]));\n            }\n\n            /* COMMENT_46 */\n            if (VAR_25 > 0)\n            {\n                VAR_21 += QUANTISE2INT(pow2(VAR_28[VAR_25] + VAR_19));\n            }\n\n\n            /* COMMENT_47 */\n            /* COMMENT_48 */\n            VAR_12 = VAR_22 - QUANTISE2REAL(log2(VAR_21 + VAR_29));\n            VAR_12 = min(VAR_12, QUANTISE2REAL(1.328771237) /* COMMENT_49 */);\n\n\n            for (VAR_4 = VAR_26; VAR_4 < VAR_27; VAR_4++)\n            {\n                /* COMMENT_50 */\n#ifndef VAR_38\n                VAR_1->G_lim_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2((VAR_11[VAR_4] + VAR_12) / 2.0));\n#else\n                /* COMMENT_51 */\n                                 \n                   \n                VAR_1->G_lim_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2(VAR_11[VAR_4] + VAR_12));\n#endif\n                VAR_1->Q_M_lim_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2((VAR_9[VAR_4] + 10 + VAR_12) / 2.0));\n\n                if (VAR_13[VAR_4] != VAR_37)\n                {\n                    VAR_1->S_M_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2((VAR_13[VAR_4] + 10 + VAR_12) / 2.0));\n                } else {\n                    VAR_1->S_M_boost[VAR_5][VAR_4] = 0;\n                }\n            }\n        }\n    }\n}",
  "func_graph_path_before": "knik0/faad2/6b4a7cde30f2e2cb03e78ef476cc73179cfffda3/sbr_hfadj.c/vul/before/0.json",
  "func": "static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)\n{\n    /* log2 values of limiter gains */\n    static real_t limGain[] = { -1.0, 0.0, 1.0, 33.219 };\n    uint8_t m, l, k;\n\n    uint8_t current_t_noise_band = 0;\n    uint8_t S_mapped;\n\n    ALIGN real_t Q_M_lim[MAX_M];\n    ALIGN real_t G_lim[MAX_M];\n    ALIGN real_t G_boost;\n    ALIGN real_t S_M[MAX_M];\n\n\n    for (l = 0; l < sbr->L_E[ch]; l++)\n    {\n        uint8_t current_f_noise_band = 0;\n        uint8_t current_res_band = 0;\n        uint8_t current_res_band2 = 0;\n        uint8_t current_hi_res_band = 0;\n\n        real_t delta = (l == sbr->l_A[ch] || l == sbr->prevEnvIsShort[ch]) ? 0 : 1;\n\n        S_mapped = get_S_mapped(sbr, ch, l, current_res_band2);\n\n        if (sbr->t_E[ch][l+1] > sbr->t_Q[ch][current_t_noise_band+1])\n        {\n            current_t_noise_band++;\n        }\n\n        for (k = 0; k < sbr->N_L[sbr->bs_limiter_bands]; k++)\n        {\n            real_t Q_M = 0;\n            real_t G_max;\n            real_t den = 0;\n            real_t acc1 = 0;\n            real_t acc2 = 0;\n            uint8_t current_res_band_size = 0;\n            uint8_t Q_M_size = 0;\n\n            uint8_t ml1, ml2;\n\n            /* bounds of current limiter bands */\n            ml1 = sbr->f_table_lim[sbr->bs_limiter_bands][k];\n            ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];\n\n            if (ml1 > MAX_M)\n                ml1 = MAX_M;\n\n            if (ml2 > MAX_M)\n                ml2 = MAX_M;\n\n\n            /* calculate the accumulated E_orig and E_curr over the limiter band */\n            for (m = ml1; m < ml2; m++)\n            {\n                if ((m + sbr->kx) < sbr->f_table_res[sbr->f[ch][l]][current_res_band+1])\n                {\n                    current_res_band_size++;\n                } else {\n                    acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch)));\n\n                    current_res_band++;\n                    current_res_band_size = 1;\n                }\n\n                acc2 += QUANTISE2INT(sbr->E_curr[ch][m][l]/1024.0);\n            }\n            acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch)));\n\n            acc1 = QUANTISE2REAL( log2(EPS + acc1) );\n\n\n            /* calculate the maximum gain */\n            /* ratio of the energy of the original signal and the energy\n             * of the HF generated signal\n             */\n            G_max = acc1 - QUANTISE2REAL(log2(EPS + acc2)) + QUANTISE2REAL(limGain[sbr->bs_limiter_gains]);\n            G_max = min(G_max, QUANTISE2REAL(limGain[3]));\n\n\n            for (m = ml1; m < ml2; m++)\n            {\n                real_t G;\n                real_t E_curr, E_orig;\n                real_t Q_orig, Q_orig_plus1;\n                uint8_t S_index_mapped;\n\n\n                /* check if m is on a noise band border */\n                if ((m + sbr->kx) == sbr->f_table_noise[current_f_noise_band+1])\n                {\n                    /* step to next noise band */\n                    current_f_noise_band++;\n                }\n\n\n                /* check if m is on a resolution band border */\n                if ((m + sbr->kx) == sbr->f_table_res[sbr->f[ch][l]][current_res_band2+1])\n                {\n                    /* accumulate a whole range of equal Q_Ms */\n                    if (Q_M_size > 0)\n                        den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M));\n                    Q_M_size = 0;\n\n                    /* step to next resolution band */\n                    current_res_band2++;\n\n                    /* if we move to a new resolution band, we should check if we are\n                     * going to add a sinusoid in this band\n                     */\n                    S_mapped = get_S_mapped(sbr, ch, l, current_res_band2);\n                }\n\n\n                /* check if m is on a HI_RES band border */\n                if ((m + sbr->kx) == sbr->f_table_res[HI_RES][current_hi_res_band+1])\n                {\n                    /* step to next HI_RES band */\n                    current_hi_res_band++;\n                }\n\n\n                /* find S_index_mapped\n                 * S_index_mapped can only be 1 for the m in the middle of the\n                 * current HI_RES band\n                 */\n                S_index_mapped = 0;\n                if ((l >= sbr->l_A[ch]) ||\n                    (sbr->bs_add_harmonic_prev[ch][current_hi_res_band] && sbr->bs_add_harmonic_flag_prev[ch]))\n                {\n                    /* find the middle subband of the HI_RES frequency band */\n                    if ((m + sbr->kx) == (sbr->f_table_res[HI_RES][current_hi_res_band+1] + sbr->f_table_res[HI_RES][current_hi_res_band]) >> 1)\n                        S_index_mapped = sbr->bs_add_harmonic[ch][current_hi_res_band];\n                }\n\n\n                /* find bitstream parameters */\n                if (sbr->E_curr[ch][m][l] == 0)\n                    E_curr = LOG2_MIN_INF;\n                else\n                    E_curr = -10 + log2(sbr->E_curr[ch][m][l]);\n                E_orig = -10 + find_log2_E(sbr, current_res_band2, l, ch);\n\n                Q_orig = find_log2_Q(sbr, current_f_noise_band, current_t_noise_band, ch);\n                Q_orig_plus1 = find_log2_Qplus1(sbr, current_f_noise_band, current_t_noise_band, ch);\n\n\n                /* Q_M only depends on E_orig and Q_div2:\n                 * since N_Q <= N_Low <= N_High we only need to recalculate Q_M on\n                 * a change of current res band (HI or LO)\n                 */\n                Q_M = E_orig + Q_orig - Q_orig_plus1;\n\n\n                /* S_M only depends on E_orig, Q_div and S_index_mapped:\n                 * S_index_mapped can only be non-zero once per HI_RES band\n                 */\n                if (S_index_mapped == 0)\n                {\n                    S_M[m] = LOG2_MIN_INF; /* -inf */\n                } else {\n                    S_M[m] = E_orig - Q_orig_plus1;\n\n                    /* accumulate sinusoid part of the total energy */\n                    den += pow2(S_M[m]);\n                }\n\n\n                /* calculate gain */\n                /* ratio of the energy of the original signal and the energy\n                 * of the HF generated signal\n                 */\n                /* E_curr here is officially E_curr+1 so the log2() of that can never be < 0 */\n                /* scaled by -10 */\n                G = E_orig - max(-10, E_curr);\n                if ((S_mapped == 0) && (delta == 1))\n                {\n                    /* G = G * 1/(1+Q) */\n                    G -= Q_orig_plus1;\n                } else if (S_mapped == 1) {\n                    /* G = G * Q/(1+Q) */\n                    G += Q_orig - Q_orig_plus1;\n                }\n\n\n                /* limit the additional noise energy level */\n                /* and apply the limiter */\n                if (G_max > G)\n                {\n                    Q_M_lim[m] = QUANTISE2REAL(Q_M);\n                    G_lim[m] = QUANTISE2REAL(G);\n\n                    if ((S_index_mapped == 0) && (l != sbr->l_A[ch]))\n                    {\n                        Q_M_size++;\n                    }\n                } else {\n                    /* G > G_max */\n                    Q_M_lim[m] = QUANTISE2REAL(Q_M) + G_max - QUANTISE2REAL(G);\n                    G_lim[m] = G_max;\n\n                    /* accumulate limited Q_M */\n                    if ((S_index_mapped == 0) && (l != sbr->l_A[ch]))\n                    {\n                        den += QUANTISE2INT(pow2(Q_M_lim[m]));\n                    }\n                }\n\n\n                /* accumulate the total energy */\n                /* E_curr changes for every m so we do need to accumulate every m */\n                den += QUANTISE2INT(pow2(E_curr + G_lim[m]));\n            }\n\n            /* accumulate last range of equal Q_Ms */\n            if (Q_M_size > 0)\n            {\n                den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M));\n            }\n\n\n            /* calculate the final gain */\n            /* G_boost: [0..2.51188643] */\n            G_boost = acc1 - QUANTISE2REAL(log2(den + EPS));\n            G_boost = min(G_boost, QUANTISE2REAL(1.328771237) /* log2(1.584893192 ^ 2) */);\n\n\n            for (m = ml1; m < ml2; m++)\n            {\n                /* apply compensation to gain, noise floor sf's and sinusoid levels */\n#ifndef SBR_LOW_POWER\n                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0));\n#else\n                /* sqrt() will be done after the aliasing reduction to save a\n                 * few multiplies\n                 */\n                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2(G_lim[m] + G_boost));\n#endif\n                adj->Q_M_lim_boost[l][m] = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0));\n\n                if (S_M[m] != LOG2_MIN_INF)\n                {\n                    adj->S_M_boost[l][m] = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0));\n                } else {\n                    adj->S_M_boost[l][m] = 0;\n                }\n            }\n        }\n    }\n}",
  "abstract_func": "static void calculate_gain(sbr_info *VAR_0, sbr_hfadj_info *VAR_1, uint8_t VAR_2)\n{\n    /* COMMENT_0 */\n    static real_t VAR_3[] = { -1.0, 0.0, 1.0, 33.219 };\n    uint8_t VAR_4, VAR_5, VAR_6;\n\n    uint8_t VAR_7 = 0;\n    uint8_t VAR_8;\n\n    ALIGN real_t VAR_9[VAR_10];\n    ALIGN real_t VAR_11[VAR_10];\n    ALIGN real_t VAR_12;\n    ALIGN real_t VAR_13[VAR_10];\n\n\n    for (VAR_5 = 0; VAR_5 < VAR_0->L_E[VAR_2]; VAR_5++)\n    {\n        uint8_t VAR_14 = 0;\n        uint8_t VAR_15 = 0;\n        uint8_t VAR_16 = 0;\n        uint8_t VAR_17 = 0;\n\n        real_t VAR_18 = (VAR_5 == VAR_0->l_A[VAR_2] || VAR_5 == VAR_0->prevEnvIsShort[VAR_2]) ? 0 : 1;\n\n        VAR_8 = get_S_mapped(VAR_0, VAR_2, VAR_5, VAR_16);\n\n        if (VAR_0->t_E[VAR_2][VAR_5+1] > VAR_0->t_Q[VAR_2][VAR_7+1])\n        {\n            VAR_7++;\n        }\n\n        for (VAR_6 = 0; VAR_6 < VAR_0->N_L[VAR_0->bs_limiter_bands]; VAR_6++)\n        {\n            real_t VAR_19 = 0;\n            real_t VAR_20;\n            real_t VAR_21 = 0;\n            real_t VAR_22 = 0;\n            real_t VAR_23 = 0;\n            uint8_t VAR_24 = 0;\n            uint8_t VAR_25 = 0;\n\n            uint8_t VAR_26, VAR_27;\n\n            /* COMMENT_1 */\n            VAR_26 = VAR_0->f_table_lim[VAR_0->bs_limiter_bands][VAR_6];\n            VAR_27 = VAR_0->f_table_lim[VAR_0->bs_limiter_bands][VAR_6+1];\n\n            if (VAR_26 > VAR_10)\n                VAR_26 = VAR_10;\n\n            if (VAR_27 > VAR_10)\n                VAR_27 = VAR_10;\n\n\n            /* COMMENT_2 */\n            for (VAR_4 = VAR_26; VAR_4 < VAR_27; VAR_4++)\n            {\n                if ((VAR_4 + VAR_0->kx) < VAR_0->f_table_res[VAR_0->f[VAR_2][VAR_5]][VAR_15+1])\n                {\n                    VAR_24++;\n                } else {\n                    VAR_22 += QUANTISE2INT(pow2(-10 + VAR_28[VAR_24] + find_log2_E(VAR_0, VAR_15, VAR_5, VAR_2)));\n\n                    VAR_15++;\n                    VAR_24 = 1;\n                }\n\n                VAR_23 += QUANTISE2INT(VAR_0->E_curr[VAR_2][VAR_4][VAR_5]/1024.0);\n            }\n            VAR_22 += QUANTISE2INT(pow2(-10 + VAR_28[VAR_24] + find_log2_E(VAR_0, VAR_15, VAR_5, VAR_2)));\n\n            VAR_22 = QUANTISE2REAL( log2(VAR_29 + VAR_22) );\n\n\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n                                         \n               \n            VAR_20 = VAR_22 - QUANTISE2REAL(log2(VAR_29 + VAR_23)) + QUANTISE2REAL(VAR_3[VAR_0->bs_limiter_gains]);\n            VAR_20 = min(VAR_20, QUANTISE2REAL(VAR_3[3]));\n\n\n            for (VAR_4 = VAR_26; VAR_4 < VAR_27; VAR_4++)\n            {\n                real_t VAR_30;\n                real_t VAR_31, VAR_32;\n                real_t VAR_33, VAR_34;\n                uint8_t VAR_35;\n\n\n                /* COMMENT_7 */\n                if ((VAR_4 + VAR_0->kx) == VAR_0->f_table_noise[VAR_14+1])\n                {\n                    /* COMMENT_8 */\n                    VAR_14++;\n                }\n\n\n                /* COMMENT_9 */\n                if ((VAR_4 + VAR_0->kx) == VAR_0->f_table_res[VAR_0->f[VAR_2][VAR_5]][VAR_16+1])\n                {\n                    /* COMMENT_10 */\n                    if (VAR_25 > 0)\n                        VAR_21 += QUANTISE2INT(pow2(VAR_28[VAR_25] + VAR_19));\n                    VAR_25 = 0;\n\n                    /* COMMENT_11 */\n                    VAR_16++;\n\n                    /* COMMENT_12 */\n                                                           \n                       \n                    VAR_8 = get_S_mapped(VAR_0, VAR_2, VAR_5, VAR_16);\n                }\n\n\n                /* COMMENT_15 */\n                if ((VAR_4 + VAR_0->kx) == VAR_0->f_table_res[VAR_36][VAR_17+1])\n                {\n                    /* COMMENT_16 */\n                    VAR_17++;\n                }\n\n\n                /* COMMENT_17 */\n                                                                              \n                                      \n                   \n                VAR_35 = 0;\n                if ((VAR_5 >= VAR_0->l_A[VAR_2]) ||\n                    (VAR_0->bs_add_harmonic_prev[VAR_2][VAR_17] && VAR_0->bs_add_harmonic_flag_prev[VAR_2]))\n                {\n                    /* COMMENT_21 */\n                    if ((VAR_4 + VAR_0->kx) == (VAR_0->f_table_res[VAR_36][VAR_17+1] + VAR_0->f_table_res[VAR_36][VAR_17]) >> 1)\n                        VAR_35 = VAR_0->bs_add_harmonic[VAR_2][VAR_17];\n                }\n\n\n                /* COMMENT_22 */\n                if (VAR_0->E_curr[VAR_2][VAR_4][VAR_5] == 0)\n                    VAR_31 = VAR_37;\n                else\n                    VAR_31 = -10 + log2(VAR_0->E_curr[VAR_2][VAR_4][VAR_5]);\n                VAR_32 = -10 + find_log2_E(VAR_0, VAR_16, VAR_5, VAR_2);\n\n                VAR_33 = find_log2_Q(VAR_0, VAR_14, VAR_7, VAR_2);\n                VAR_34 = find_log2_Qplus1(VAR_0, VAR_14, VAR_7, VAR_2);\n\n\n                /* COMMENT_23 */\n                                                                                  \n                                                          \n                   \n                VAR_19 = VAR_32 + VAR_33 - VAR_34;\n\n\n                /* COMMENT_27 */\n                                                                           \n                   \n                if (VAR_35 == 0)\n                {\n                    VAR_13[VAR_4] = VAR_37; /* COMMENT_30 */\n                } else {\n                    VAR_13[VAR_4] = VAR_32 - VAR_34;\n\n                    /* COMMENT_31 */\n                    VAR_21 += pow2(VAR_13[VAR_4]);\n                }\n\n\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n                                             \n                   \n                /* COMMENT_36 */\n                /* COMMENT_37 */\n                VAR_30 = VAR_32 - max(-10, VAR_31);\n                if ((VAR_8 == 0) && (VAR_18 == 1))\n                {\n                    /* COMMENT_38 */\n                    VAR_30 -= VAR_34;\n                } else if (VAR_8 == 1) {\n                    /* COMMENT_39 */\n                    VAR_30 += VAR_33 - VAR_34;\n                }\n\n\n                /* COMMENT_40 */\n                /* COMMENT_41 */\n                if (VAR_20 > VAR_30)\n                {\n                    VAR_9[VAR_4] = QUANTISE2REAL(VAR_19);\n                    VAR_11[VAR_4] = QUANTISE2REAL(VAR_30);\n\n                    if ((VAR_35 == 0) && (VAR_5 != VAR_0->l_A[VAR_2]))\n                    {\n                        VAR_25++;\n                    }\n                } else {\n                    /* COMMENT_42 */\n                    VAR_9[VAR_4] = QUANTISE2REAL(VAR_19) + VAR_20 - QUANTISE2REAL(VAR_30);\n                    VAR_11[VAR_4] = VAR_20;\n\n                    /* COMMENT_43 */\n                    if ((VAR_35 == 0) && (VAR_5 != VAR_0->l_A[VAR_2]))\n                    {\n                        VAR_21 += QUANTISE2INT(pow2(VAR_9[VAR_4]));\n                    }\n                }\n\n\n                /* COMMENT_44 */\n                /* COMMENT_45 */\n                VAR_21 += QUANTISE2INT(pow2(VAR_31 + VAR_11[VAR_4]));\n            }\n\n            /* COMMENT_46 */\n            if (VAR_25 > 0)\n            {\n                VAR_21 += QUANTISE2INT(pow2(VAR_28[VAR_25] + VAR_19));\n            }\n\n\n            /* COMMENT_47 */\n            /* COMMENT_48 */\n            VAR_12 = VAR_22 - QUANTISE2REAL(log2(VAR_21 + VAR_29));\n            VAR_12 = min(VAR_12, QUANTISE2REAL(1.328771237) /* COMMENT_49 */);\n\n\n            for (VAR_4 = VAR_26; VAR_4 < VAR_27; VAR_4++)\n            {\n                /* COMMENT_50 */\n#ifndef VAR_38\n                VAR_1->G_lim_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2((VAR_11[VAR_4] + VAR_12) / 2.0));\n#else\n                /* COMMENT_51 */\n                                 \n                   \n                VAR_1->G_lim_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2(VAR_11[VAR_4] + VAR_12));\n#endif\n                VAR_1->Q_M_lim_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2((VAR_9[VAR_4] + 10 + VAR_12) / 2.0));\n\n                if (VAR_13[VAR_4] != VAR_37)\n                {\n                    VAR_1->S_M_boost[VAR_5][VAR_4] = QUANTISE2REAL(pow2((VAR_13[VAR_4] + 10 + VAR_12) / 2.0));\n                } else {\n                    VAR_1->S_M_boost[VAR_5][VAR_4] = 0;\n                }\n            }\n        }\n    }\n}",
  "func_graph_path": "knik0/faad2/6b4a7cde30f2e2cb03e78ef476cc73179cfffda3/sbr_hfadj.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,12 @@\n             ml1 = sbr->f_table_lim[sbr->bs_limiter_bands][k];\n             ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];\n \n+            if (ml1 > MAX_M)\n+                ml1 = MAX_M;\n+\n+            if (ml2 > MAX_M)\n+                ml2 = MAX_M;\n+\n \n             /* calculate the accumulated E_orig and E_curr over the limiter band */\n             for (m = ml1; m < ml2; m++)",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            if (ml1 > MAX_M)",
      "                ml1 = MAX_M;",
      "",
      "            if (ml2 > MAX_M)",
      "                ml2 = MAX_M;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/33",
  "description": {
    "pr_info": {
      "title": "CVE-2018-20194 / CVE-2018-20362 fixes",
      "number": 33
    },
    "comment": [
      "**Issue summary:**\r\n\r\nThe faad2 code base appears to assume that all frames of a same AAC file share the same syntax element structure. However, input files are not strictly verified again this assumption, or too late during file processing.\r\n\r\nThis leads to security vulnerabilities when processing crafted AAC files where these assumptions are false. For example, files declaring two frames, the first SCE+FIL and the second CPE.\r\n\r\n**Patch summary:**\r\n\r\nAdd checks to decode_sce_lfe and decode_cpe to make sure inter-frame inconsistencies are detected as early as possible.\r\n\r\nThese checks first read hDecoder->frame: if this is not the first frame then we make sure that the syntax element at the same position in the previous frame also had element_id id_syn_ele. If not, return 21 as this is a fatal file structure issue.\r\n\r\n**Issues addressed:**\r\n\r\nThis patch addresses CVE-2018-20362 (fixes #26) and possibly other related issues.",
      "This patch should fix #27 and #23 as well (same underlying issue everywhere).",
      "Thank you very much for the patch and sorry for the stupid question, but I may be he last remaining person with commit rights to this repository and my knowledge of the innards of the code is quite limited. So, is it really impossible in the AAC format that two consecutive frames have different types?",
      "Hi @fabiangreffrath, sorry for the late answer.\r\n\r\nI am not an AAC expert. I did not find any kind of official AAC file format specification which could precisely answer this question.\r\n\r\nMy guess is: it is not forbidden to define an AAC file containing frames of different formats. AFAIK, frames are independent units of data.\r\n\r\nWhether defining AAC files with frames of different formats makes sense or not is another question. Whether FAAD2 should support this is yet another question.\r\n\r\nFor the moment it is obvious that FAAD2 does not support it, because buffers are shared between frames. FAAD2 crashes if a complex frame requiring more buffers follows a simple frame. Supporting it would probably require more changes than what this patch suggests.\r\n\r\nIf my analysis is right, I suggest to officially declare this unsupported, make sure FAAD2 exits cleanly in these cases, and add this to the todo/roadmap. This is a refactoring, it should be done properly with tests, etc. not a security patch.\r\n\r\nbut then again, my knowledge of AAC is limited, and poorly documented.",
      "I have found [a copy](http://read.pudn.com/downloads69/ebook/247256/247256/13818-7_2006.pdf) of the ISO/IEC 13818-7:2006 spec. This should answer our questions.\r\n\r\nThere are three ways of specifying channel mapping: in the adts header, using PCE elements, or implicitly (8.5.3.3).\r\n\r\nIn the implicit case: _\"the  resulting configuration may not change within the bitstream without sending a program_config_element(), i.e. an implicit reconfiguration is not allowed\"_\r\n\r\nSo it looks like this patch goes the right way.\r\n\r\nI don't know whether FAAD2 handles reconfiguration via PCE elements properly.",
      "I have pushed another patch addressing CVE-2018-20194. I am quite confident in this patch, please tell me if the explanations I provided are clear enough to you.\r\n\r\nI have also updated the commit message of CVE-2018-20362 to use more precise terms and provide explanations based on the specification.",
      "@hlef May this patch from VLC be related? Just guessing from the patch description. \r\n\r\nhttps://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-cpe-reconstruction.patch",
      "> @hlef May this patch from VLC be related? Just guessing from the patch description.\r\n> \r\n> https://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-cpe-reconstruction.patch\r\n\r\nYes it is.\r\n\r\nWhat this patch does is one of the first things I tried when investigating this issue (see #26).\r\n\r\nAs far as I remember, this was not sufficient to prevent FAAD2 from crashing with the reproducer.\r\n\r\nFrom my point of view:\r\n* this situation (implicit reconfiguration) is not legal according to the specification (*as far as I understand the spec*, I am not an AAC expert)\r\n* if we don't exit at this point, FAAD2 will thus continue processing inconsistent data\r\n* this *might* trigger a variety of issues at other places in the source code\r\n* the result is likely to be garbage anyways\r\n\r\nGiven my limited knowledge of the codebase and of the AAC standard, the safest option seemed to abort at this point. This patch might work, or it might just as well replace one issue with another.",
      "So, your current stance is to better not apply that patch?",
      "> So, your current stance is to better not apply that patch?\r\n\r\nApplying both the VLC patch and my patch is probably a good idea.\r\n\r\nI'm skeptical about applying the VLC patch only, because I don't think we should continue to process the input at this point (unless my interpretation of the spec is wrong and this is a valid situtation).",
      "Since your patch is already applied for quite some time, I'll add the VLC one asap. If I got you right, it won't hurt. \r\n\r\nThanks for your input! ",
      "I consider applying this patch as well, we already have it in the Debian package:\r\n\r\nhttps://github.com/videolan/vlc/blob/master/contrib/src/faad2/faad2-fix-overflows.patch"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}