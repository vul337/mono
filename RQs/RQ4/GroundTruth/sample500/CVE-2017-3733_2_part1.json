{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/t1_enc.c",
  "func_name": "tls1_setup_key_block",
  "func_before": "int tls1_setup_key_block(SSL *s)\n{\n    unsigned char *p;\n    const EVP_CIPHER *c;\n    const EVP_MD *hash;\n    int num;\n    SSL_COMP *comp;\n    int mac_type = NID_undef, mac_secret_size = 0;\n    int ret = 0;\n\n    if (s->s3->tmp.key_block_length != 0)\n        return (1);\n\n    if (!ssl_cipher_get_evp\n        (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp,\n         SSL_USE_ETM(s))) {\n        SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\n        return (0);\n    }\n\n    s->s3->tmp.new_sym_enc = c;\n    s->s3->tmp.new_hash = hash;\n    s->s3->tmp.new_mac_pkey_type = mac_type;\n    s->s3->tmp.new_mac_secret_size = mac_secret_size;\n    num = EVP_CIPHER_key_length(c) + mac_secret_size + EVP_CIPHER_iv_length(c);\n    num *= 2;\n\n    ssl3_cleanup_key_block(s);\n\n    if ((p = OPENSSL_malloc(num)) == NULL) {\n        SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    s->s3->tmp.key_block_length = num;\n    s->s3->tmp.key_block = p;\n\n#ifdef SSL_DEBUG\n    printf(\"client random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->client_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"server random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->server_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"master key\\n\");\n    {\n        int z;\n        for (z = 0; z < s->session->master_key_length; z++)\n            printf(\"%02X%c\", s->session->master_key[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n    if (!tls1_generate_key_block(s, p, num))\n        goto err;\n#ifdef SSL_DEBUG\n    printf(\"\\nkey block\\n\");\n    {\n        int z;\n        for (z = 0; z < num; z++)\n            printf(\"%02X%c\", p[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)\n        && s->method->version <= TLS1_VERSION) {\n        /*\n         * enable vulnerability countermeasure for CBC ciphers with known-IV\n         * problem (http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n        s->s3->need_empty_fragments = 1;\n\n        if (s->session->cipher != NULL) {\n            if (s->session->cipher->algorithm_enc == SSL_eNULL)\n                s->s3->need_empty_fragments = 0;\n\n#ifndef OPENSSL_NO_RC4\n            if (s->session->cipher->algorithm_enc == SSL_RC4)\n                s->s3->need_empty_fragments = 0;\n#endif\n        }\n    }\n\n    ret = 1;\n err:\n    return (ret);\n}",
  "abstract_func_before": "int tls1_setup_key_block(SSL *VAR_0)\n{\n    unsigned char *VAR_1;\n    const EVP_CIPHER *VAR_2;\n    const EVP_MD *VAR_3;\n    int VAR_4;\n    SSL_COMP *VAR_5;\n    int VAR_6 = VAR_7, VAR_8 = 0;\n    int VAR_9 = 0;\n\n    if (VAR_0->s3->tmp.key_block_length != 0)\n        return (1);\n\n    if (!ssl_cipher_get_evp\n        (VAR_0->session, &VAR_2, &VAR_3, &VAR_6, &VAR_8, &VAR_5,\n         SSL_USE_ETM(VAR_0))) {\n        SSLerr(VAR_10, VAR_11);\n        return (0);\n    }\n\n    VAR_0->s3->tmp.new_sym_enc = VAR_2;\n    VAR_0->s3->tmp.new_hash = VAR_3;\n    VAR_0->s3->tmp.new_mac_pkey_type = VAR_6;\n    VAR_0->s3->tmp.new_mac_secret_size = VAR_8;\n    VAR_4 = EVP_CIPHER_key_length(VAR_2) + VAR_8 + EVP_CIPHER_iv_length(VAR_2);\n    VAR_4 *= 2;\n\n    ssl3_cleanup_key_block(VAR_0);\n\n    if ((VAR_1 = OPENSSL_malloc(VAR_4)) == NULL) {\n        SSLerr(VAR_10, VAR_12);\n        goto err;\n    }\n\n    VAR_0->s3->tmp.key_block_length = VAR_4;\n    VAR_0->s3->tmp.key_block = VAR_1;\n\n#ifdef VAR_13\n    printf(\"client random\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)\n            printf(\"%02X%c\", VAR_0->s3->client_random[VAR_14],\n                   ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"server random\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)\n            printf(\"%02X%c\", VAR_0->s3->server_random[VAR_14],\n                   ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"master key\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_0->session->master_key_length; VAR_14++)\n            printf(\"%02X%c\", VAR_0->session->master_key[VAR_14],\n                   ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n    if (!tls1_generate_key_block(VAR_0, VAR_1, VAR_4))\n        goto err;\n#ifdef VAR_13\n    printf(\"\\nkey block\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_4; VAR_14++)\n            printf(\"%02X%c\", VAR_1[VAR_14], ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (!(VAR_0->options & VAR_16)\n        && VAR_0->method->version <= VAR_17) {\n        /* COMMENT_0 */\n                                                                            \n                                                             \n           \n        VAR_0->s3->need_empty_fragments = 1;\n\n        if (VAR_0->session->cipher != NULL) {\n            if (VAR_0->session->cipher->algorithm_enc == VAR_18)\n                VAR_0->s3->need_empty_fragments = 0;\n\n#ifndef VAR_19\n            if (VAR_0->session->cipher->algorithm_enc == VAR_20)\n                VAR_0->s3->need_empty_fragments = 0;\n#endif\n        }\n    }\n\n    VAR_9 = 1;\n err:\n    return (VAR_9);\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_enc.c/vul/before/0.json",
  "func": "int tls1_setup_key_block(SSL *s)\n{\n    unsigned char *p;\n    const EVP_CIPHER *c;\n    const EVP_MD *hash;\n    int num;\n    SSL_COMP *comp;\n    int mac_type = NID_undef, mac_secret_size = 0;\n    int ret = 0;\n\n    if (s->s3->tmp.key_block_length != 0)\n        return (1);\n\n    if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size,\n                            &comp, s->tlsext_use_etm)) {\n        SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\n        return (0);\n    }\n\n    s->s3->tmp.new_sym_enc = c;\n    s->s3->tmp.new_hash = hash;\n    s->s3->tmp.new_mac_pkey_type = mac_type;\n    s->s3->tmp.new_mac_secret_size = mac_secret_size;\n    num = EVP_CIPHER_key_length(c) + mac_secret_size + EVP_CIPHER_iv_length(c);\n    num *= 2;\n\n    ssl3_cleanup_key_block(s);\n\n    if ((p = OPENSSL_malloc(num)) == NULL) {\n        SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    s->s3->tmp.key_block_length = num;\n    s->s3->tmp.key_block = p;\n\n#ifdef SSL_DEBUG\n    printf(\"client random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->client_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"server random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->server_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"master key\\n\");\n    {\n        int z;\n        for (z = 0; z < s->session->master_key_length; z++)\n            printf(\"%02X%c\", s->session->master_key[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n    if (!tls1_generate_key_block(s, p, num))\n        goto err;\n#ifdef SSL_DEBUG\n    printf(\"\\nkey block\\n\");\n    {\n        int z;\n        for (z = 0; z < num; z++)\n            printf(\"%02X%c\", p[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)\n        && s->method->version <= TLS1_VERSION) {\n        /*\n         * enable vulnerability countermeasure for CBC ciphers with known-IV\n         * problem (http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n        s->s3->need_empty_fragments = 1;\n\n        if (s->session->cipher != NULL) {\n            if (s->session->cipher->algorithm_enc == SSL_eNULL)\n                s->s3->need_empty_fragments = 0;\n\n#ifndef OPENSSL_NO_RC4\n            if (s->session->cipher->algorithm_enc == SSL_RC4)\n                s->s3->need_empty_fragments = 0;\n#endif\n        }\n    }\n\n    ret = 1;\n err:\n    return (ret);\n}",
  "abstract_func": "int tls1_setup_key_block(SSL *VAR_0)\n{\n    unsigned char *VAR_1;\n    const EVP_CIPHER *VAR_2;\n    const EVP_MD *VAR_3;\n    int VAR_4;\n    SSL_COMP *VAR_5;\n    int VAR_6 = VAR_7, VAR_8 = 0;\n    int VAR_9 = 0;\n\n    if (VAR_0->s3->tmp.key_block_length != 0)\n        return (1);\n\n    if (!ssl_cipher_get_evp(VAR_0->session, &VAR_2, &VAR_3, &VAR_6, &VAR_8,\n                            &VAR_5, VAR_0->tlsext_use_etm)) {\n        SSLerr(VAR_10, VAR_11);\n        return (0);\n    }\n\n    VAR_0->s3->tmp.new_sym_enc = VAR_2;\n    VAR_0->s3->tmp.new_hash = VAR_3;\n    VAR_0->s3->tmp.new_mac_pkey_type = VAR_6;\n    VAR_0->s3->tmp.new_mac_secret_size = VAR_8;\n    VAR_4 = EVP_CIPHER_key_length(VAR_2) + VAR_8 + EVP_CIPHER_iv_length(VAR_2);\n    VAR_4 *= 2;\n\n    ssl3_cleanup_key_block(VAR_0);\n\n    if ((VAR_1 = OPENSSL_malloc(VAR_4)) == NULL) {\n        SSLerr(VAR_10, VAR_12);\n        goto err;\n    }\n\n    VAR_0->s3->tmp.key_block_length = VAR_4;\n    VAR_0->s3->tmp.key_block = VAR_1;\n\n#ifdef VAR_13\n    printf(\"client random\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)\n            printf(\"%02X%c\", VAR_0->s3->client_random[VAR_14],\n                   ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"server random\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++)\n            printf(\"%02X%c\", VAR_0->s3->server_random[VAR_14],\n                   ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"master key\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_0->session->master_key_length; VAR_14++)\n            printf(\"%02X%c\", VAR_0->session->master_key[VAR_14],\n                   ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n    if (!tls1_generate_key_block(VAR_0, VAR_1, VAR_4))\n        goto err;\n#ifdef VAR_13\n    printf(\"\\nkey block\\n\");\n    {\n        int VAR_14;\n        for (VAR_14 = 0; VAR_14 < VAR_4; VAR_14++)\n            printf(\"%02X%c\", VAR_1[VAR_14], ((VAR_14 + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (!(VAR_0->options & VAR_16)\n        && VAR_0->method->version <= VAR_17) {\n        /* COMMENT_0 */\n                                                                            \n                                                             \n           \n        VAR_0->s3->need_empty_fragments = 1;\n\n        if (VAR_0->session->cipher != NULL) {\n            if (VAR_0->session->cipher->algorithm_enc == VAR_18)\n                VAR_0->s3->need_empty_fragments = 0;\n\n#ifndef VAR_19\n            if (VAR_0->session->cipher->algorithm_enc == VAR_20)\n                VAR_0->s3->need_empty_fragments = 0;\n#endif\n        }\n    }\n\n    VAR_9 = 1;\n err:\n    return (VAR_9);\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_enc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,9 +11,8 @@\n     if (s->s3->tmp.key_block_length != 0)\n         return (1);\n \n-    if (!ssl_cipher_get_evp\n-        (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp,\n-         SSL_USE_ETM(s))) {\n+    if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size,\n+                            &comp, s->tlsext_use_etm)) {\n         SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\n         return (0);\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "    if (!ssl_cipher_get_evp",
      "        (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp,",
      "         SSL_USE_ETM(s))) {"
    ],
    "added_lines": [
      "    if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size,",
      "                            &comp, s->tlsext_use_etm)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit addresses CVE-2017-3733 and modifies how ETM flags are handled to prevent crashes during TLS renegotiations, which is a clear security fix. The code changes are consistent with the described vulnerability."
}