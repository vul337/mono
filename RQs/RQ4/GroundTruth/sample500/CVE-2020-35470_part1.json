{
  "cve_id": "CVE-2020-35470",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:A/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "proxy protocol: set downstreamRemoteAddress on StreamInfo\n\nThis fixes a regression which resulted in the downstreamRemoteAddress\non the StreamInfo for a connection not having the address supplied by\nthe proxy protocol filter, but instead having the address of the\ndirectly connected peer.\n\nThis issue does not affect HTTP filters.\n\nFixes #14087\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>",
  "commit_hash": "9a5318781e341e141b09bca996720aa417944206",
  "git_url": "https://github.com/envoyproxy/envoy/commit/9a5318781e341e141b09bca996720aa417944206",
  "file_path": "source/server/connection_handler_impl.cc",
  "func_name": "ConnectionHandlerImpl::ActiveTcpListener::newConnection",
  "func_before": "void ConnectionHandlerImpl::ActiveTcpListener::newConnection(\n    Network::ConnectionSocketPtr&& socket, std::unique_ptr<StreamInfo::StreamInfo> stream_info) {\n  // Refresh local address in case it was restored by a listener filter like the original_dst\n  // filter.\n  stream_info->setDownstreamLocalAddress(socket->localAddress());\n\n  // Find matching filter chain.\n  const auto filter_chain = config_->filterChainManager().findFilterChain(*socket);\n  if (filter_chain == nullptr) {\n    ENVOY_LOG(debug, \"closing connection: no matching filter chain found\");\n    stats_.no_filter_chain_match_.inc();\n    stream_info->setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    stream_info->setResponseCodeDetails(StreamInfo::ResponseCodeDetails::get().FilterChainNotFound);\n    emitLogs(*config_, *stream_info);\n    socket->close();\n    return;\n  }\n\n  auto transport_socket = filter_chain->transportSocketFactory().createTransportSocket(nullptr);\n  stream_info->setDownstreamSslConnection(transport_socket->ssl());\n  auto& active_connections = getOrCreateActiveConnections(*filter_chain);\n  auto server_conn_ptr = parent_.dispatcher_.createServerConnection(\n      std::move(socket), std::move(transport_socket), *stream_info);\n  if (const auto timeout = filter_chain->transportSocketConnectTimeout();\n      timeout != std::chrono::milliseconds::zero()) {\n    server_conn_ptr->setTransportSocketConnectTimeout(timeout);\n  }\n  ActiveTcpConnectionPtr active_connection(\n      new ActiveTcpConnection(active_connections, std::move(server_conn_ptr),\n                              parent_.dispatcher_.timeSource(), std::move(stream_info)));\n  active_connection->connection_->setBufferLimits(config_->perConnectionBufferLimitBytes());\n\n  const bool empty_filter_chain = !config_->filterChainFactory().createNetworkFilterChain(\n      *active_connection->connection_, filter_chain->networkFilterFactories());\n  if (empty_filter_chain) {\n    ENVOY_CONN_LOG(debug, \"closing connection: no filters\", *active_connection->connection_);\n    active_connection->connection_->close(Network::ConnectionCloseType::NoFlush);\n  }\n\n  // If the connection is already closed, we can just let this connection immediately die.\n  if (active_connection->connection_->state() != Network::Connection::State::Closed) {\n    ENVOY_CONN_LOG(debug, \"new connection\", *active_connection->connection_);\n    active_connection->connection_->addConnectionCallbacks(*active_connection);\n    LinkedList::moveIntoList(std::move(active_connection), active_connections.connections_);\n  }\n}",
  "abstract_func_before": "void ConnectionHandlerImpl::ActiveTcpListener::newConnection(\n    Network::ConnectionSocketPtr&& VAR_0, std::unique_ptr<StreamInfo::StreamInfo> VAR_1) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_1->setDownstreamLocalAddress(VAR_0->localAddress());\n\n  /* COMMENT_2 */\n  const auto VAR_2 = VAR_3->filterChainManager().findFilterChain(*VAR_0);\n  if (VAR_2 == nullptr) {\n    ENVOY_LOG(VAR_4, \"closing connection: no matching filter chain found\");\n    VAR_5.no_filter_chain_match_.inc();\n    VAR_1->setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    VAR_1->setResponseCodeDetails(StreamInfo::ResponseCodeDetails::get().FilterChainNotFound);\n    emitLogs(*VAR_3, *VAR_1);\n    VAR_0->close();\n    return;\n  }\n\n  auto VAR_6 = VAR_2->transportSocketFactory().createTransportSocket(nullptr);\n  VAR_1->setDownstreamSslConnection(VAR_6->ssl());\n  auto& VAR_7 = getOrCreateActiveConnections(*VAR_2);\n  auto VAR_8 = VAR_9.dispatcher_.createServerConnection(\n      std::move(VAR_0), std::move(VAR_6), *VAR_1);\n  if (const auto VAR_10 = VAR_2->transportSocketConnectTimeout();\n      VAR_10 != std::chrono::milliseconds::zero()) {\n    VAR_8->setTransportSocketConnectTimeout(VAR_10);\n  }\n  ActiveTcpConnectionPtr VAR_11(\n      new ActiveTcpConnection(VAR_7, std::move(VAR_8),\n                              VAR_9.dispatcher_.timeSource(), std::move(VAR_1)));\n  VAR_11->connection_->setBufferLimits(VAR_3->perConnectionBufferLimitBytes());\n\n  const bool VAR_12 = !VAR_3->filterChainFactory().createNetworkFilterChain(\n      *VAR_11->connection_, VAR_2->networkFilterFactories());\n  if (VAR_12) {\n    ENVOY_CONN_LOG(VAR_4, \"closing connection: no filters\", *VAR_11->connection_);\n    VAR_11->connection_->close(Network::ConnectionCloseType::NoFlush);\n  }\n\n  /* COMMENT_3 */\n  if (VAR_11->connection_->state() != Network::Connection::State::Closed) {\n    ENVOY_CONN_LOG(VAR_4, \"new connection\", *VAR_11->connection_);\n    VAR_11->connection_->addConnectionCallbacks(*VAR_11);\n    LinkedList::moveIntoList(std::move(VAR_11), VAR_7.connections_);\n  }\n}",
  "func_graph_path_before": "envoyproxy/envoy/9a5318781e341e141b09bca996720aa417944206/connection_handler_impl.cc/vul/before/0.json",
  "func": "void ConnectionHandlerImpl::ActiveTcpListener::newConnection(\n    Network::ConnectionSocketPtr&& socket, std::unique_ptr<StreamInfo::StreamInfo> stream_info) {\n  // Refresh addresses in case they are modified by listener filters, such as proxy protocol or\n  // original_dst.\n  stream_info->setDownstreamLocalAddress(socket->localAddress());\n  stream_info->setDownstreamRemoteAddress(socket->remoteAddress());\n\n  // Find matching filter chain.\n  const auto filter_chain = config_->filterChainManager().findFilterChain(*socket);\n  if (filter_chain == nullptr) {\n    ENVOY_LOG(debug, \"closing connection: no matching filter chain found\");\n    stats_.no_filter_chain_match_.inc();\n    stream_info->setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    stream_info->setResponseCodeDetails(StreamInfo::ResponseCodeDetails::get().FilterChainNotFound);\n    emitLogs(*config_, *stream_info);\n    socket->close();\n    return;\n  }\n\n  auto transport_socket = filter_chain->transportSocketFactory().createTransportSocket(nullptr);\n  stream_info->setDownstreamSslConnection(transport_socket->ssl());\n  auto& active_connections = getOrCreateActiveConnections(*filter_chain);\n  auto server_conn_ptr = parent_.dispatcher_.createServerConnection(\n      std::move(socket), std::move(transport_socket), *stream_info);\n  if (const auto timeout = filter_chain->transportSocketConnectTimeout();\n      timeout != std::chrono::milliseconds::zero()) {\n    server_conn_ptr->setTransportSocketConnectTimeout(timeout);\n  }\n  ActiveTcpConnectionPtr active_connection(\n      new ActiveTcpConnection(active_connections, std::move(server_conn_ptr),\n                              parent_.dispatcher_.timeSource(), std::move(stream_info)));\n  active_connection->connection_->setBufferLimits(config_->perConnectionBufferLimitBytes());\n\n  const bool empty_filter_chain = !config_->filterChainFactory().createNetworkFilterChain(\n      *active_connection->connection_, filter_chain->networkFilterFactories());\n  if (empty_filter_chain) {\n    ENVOY_CONN_LOG(debug, \"closing connection: no filters\", *active_connection->connection_);\n    active_connection->connection_->close(Network::ConnectionCloseType::NoFlush);\n  }\n\n  // If the connection is already closed, we can just let this connection immediately die.\n  if (active_connection->connection_->state() != Network::Connection::State::Closed) {\n    ENVOY_CONN_LOG(debug, \"new connection\", *active_connection->connection_);\n    active_connection->connection_->addConnectionCallbacks(*active_connection);\n    LinkedList::moveIntoList(std::move(active_connection), active_connections.connections_);\n  }\n}",
  "abstract_func": "void ConnectionHandlerImpl::ActiveTcpListener::newConnection(\n    Network::ConnectionSocketPtr&& VAR_0, std::unique_ptr<StreamInfo::StreamInfo> VAR_1) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_1->setDownstreamLocalAddress(VAR_0->localAddress());\n  VAR_1->setDownstreamRemoteAddress(VAR_0->remoteAddress());\n\n  /* COMMENT_2 */\n  const auto VAR_2 = VAR_3->filterChainManager().findFilterChain(*VAR_0);\n  if (VAR_2 == nullptr) {\n    ENVOY_LOG(VAR_4, \"closing connection: no matching filter chain found\");\n    VAR_5.no_filter_chain_match_.inc();\n    VAR_1->setResponseFlag(StreamInfo::ResponseFlag::NoRouteFound);\n    VAR_1->setResponseCodeDetails(StreamInfo::ResponseCodeDetails::get().FilterChainNotFound);\n    emitLogs(*VAR_3, *VAR_1);\n    VAR_0->close();\n    return;\n  }\n\n  auto VAR_6 = VAR_2->transportSocketFactory().createTransportSocket(nullptr);\n  VAR_1->setDownstreamSslConnection(VAR_6->ssl());\n  auto& VAR_7 = getOrCreateActiveConnections(*VAR_2);\n  auto VAR_8 = VAR_9.dispatcher_.createServerConnection(\n      std::move(VAR_0), std::move(VAR_6), *VAR_1);\n  if (const auto VAR_10 = VAR_2->transportSocketConnectTimeout();\n      VAR_10 != std::chrono::milliseconds::zero()) {\n    VAR_8->setTransportSocketConnectTimeout(VAR_10);\n  }\n  ActiveTcpConnectionPtr VAR_11(\n      new ActiveTcpConnection(VAR_7, std::move(VAR_8),\n                              VAR_9.dispatcher_.timeSource(), std::move(VAR_1)));\n  VAR_11->connection_->setBufferLimits(VAR_3->perConnectionBufferLimitBytes());\n\n  const bool VAR_12 = !VAR_3->filterChainFactory().createNetworkFilterChain(\n      *VAR_11->connection_, VAR_2->networkFilterFactories());\n  if (VAR_12) {\n    ENVOY_CONN_LOG(VAR_4, \"closing connection: no filters\", *VAR_11->connection_);\n    VAR_11->connection_->close(Network::ConnectionCloseType::NoFlush);\n  }\n\n  /* COMMENT_3 */\n  if (VAR_11->connection_->state() != Network::Connection::State::Closed) {\n    ENVOY_CONN_LOG(VAR_4, \"new connection\", *VAR_11->connection_);\n    VAR_11->connection_->addConnectionCallbacks(*VAR_11);\n    LinkedList::moveIntoList(std::move(VAR_11), VAR_7.connections_);\n  }\n}",
  "func_graph_path": "envoyproxy/envoy/9a5318781e341e141b09bca996720aa417944206/connection_handler_impl.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n void ConnectionHandlerImpl::ActiveTcpListener::newConnection(\n     Network::ConnectionSocketPtr&& socket, std::unique_ptr<StreamInfo::StreamInfo> stream_info) {\n-  // Refresh local address in case it was restored by a listener filter like the original_dst\n-  // filter.\n+  // Refresh addresses in case they are modified by listener filters, such as proxy protocol or\n+  // original_dst.\n   stream_info->setDownstreamLocalAddress(socket->localAddress());\n+  stream_info->setDownstreamRemoteAddress(socket->remoteAddress());\n \n   // Find matching filter chain.\n   const auto filter_chain = config_->filterChainManager().findFilterChain(*socket);",
  "diff_line_info": {
    "deleted_lines": [
      "  // Refresh local address in case it was restored by a listener filter like the original_dst",
      "  // filter."
    ],
    "added_lines": [
      "  // Refresh addresses in case they are modified by listener filters, such as proxy protocol or",
      "  // original_dst.",
      "  stream_info->setDownstreamRemoteAddress(socket->remoteAddress());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/14131",
  "description": {
    "pr_info": {
      "title": "proxy protocol: set downstreamRemoteAddress on StreamInfo",
      "number": 14131
    },
    "comment": [
      "This fixes a regression which resulted in the downstreamRemoteAddress\r\non the StreamInfo for a connection not having the address supplied by\r\nthe proxy protocol filter, but instead having the address of the\r\ndirectly connected peer.\r\n\r\nThis issue does not affect HTTP filters.\r\n\r\nFixes #14087\r\n\r\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\r\n\r\n\r\nCommit Message:\r\nAdditional Description:\r\nRisk Level: Low\r\nTesting: New test added to prevent future regressions\r\nDocs Changes: none needed\r\nRelease Notes: added\r\nPlatform Specific Features:\r\n[Optional Runtime guard:]\r\n[Optional Fixes #Issue]\r\n[Optional Deprecated:]\r\n",
      "[CVE-2020-35470](https://nvd.nist.gov/vuln/detail/CVE-2020-35470) was assigned to this request."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.99,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.99\n\nThe patch addresses a regression in setting downstream addresses correctly, which is a core functionality fix, not a security issue."
}