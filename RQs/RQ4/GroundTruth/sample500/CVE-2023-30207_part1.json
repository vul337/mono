{
  "cve_id": "CVE-2023-30207",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "xbmc",
  "commit_msg": "VideoPlayerCodec: Stop dividing by zero\n\nWhen parsing a file failed so that needed fields, in our case frameSize\nare not available a guess work like with m_channels or m_samplerate does\nnot help. Therefore fail early.",
  "commit_hash": "dbc00c500f4c4830049cc040a61c439c580eea73",
  "git_url": "https://github.com/xbmc/xbmc/commit/dbc00c500f4c4830049cc040a61c439c580eea73",
  "file_path": "xbmc/cores/paplayer/VideoPlayerCodec.cpp",
  "func_name": "VideoPlayerCodec::Init",
  "func_before": "bool VideoPlayerCodec::Init(const CFileItem &file, unsigned int filecache)\n{\n  // take precaution if Init()ialized earlier\n  if (m_bInited)\n  {\n    // keep things as is if Init() was done with known strFile\n    if (m_strFileName == file.GetDynPath())\n      return true;\n\n    // got differing filename, so cleanup before starting over\n    DeInit();\n  }\n\n  m_nDecodedLen = 0;\n\n  CFileItem fileitem(file);\n  fileitem.SetMimeType(m_strContentType);\n  fileitem.SetMimeTypeForInternetFile();\n  m_pInputStream = CDVDFactoryInputStream::CreateInputStream(NULL, fileitem);\n  if (!m_pInputStream)\n  {\n    CLog::Log(LOGERROR, \"{}: Error creating input stream for {}\", __FUNCTION__, file.GetDynPath());\n    return false;\n  }\n\n  //! @todo\n  //! convey CFileItem::ContentLookup() into Open()\n  if (!m_pInputStream->Open())\n  {\n    CLog::Log(LOGERROR, \"{}: Error opening file {}\", __FUNCTION__, file.GetDynPath());\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  m_pDemuxer = NULL;\n\n  try\n  {\n    m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream);\n    if (!m_pDemuxer)\n    {\n      if (m_pInputStream.use_count() > 1)\n        throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n      m_pInputStream.reset();\n      CLog::Log(LOGERROR, \"{}: Error creating demuxer\", __FUNCTION__);\n      return false;\n    }\n  }\n  catch(...)\n  {\n    CLog::Log(LOGERROR, \"{}: Exception thrown when opening demuxer\", __FUNCTION__);\n    if (m_pDemuxer)\n    {\n      delete m_pDemuxer;\n      m_pDemuxer = NULL;\n    }\n    return false;\n  }\n\n  CDemuxStream* pStream = NULL;\n  m_nAudioStream = -1;\n  int64_t demuxerId = -1;\n  for (auto stream : m_pDemuxer->GetStreams())\n  {\n    if (stream && stream->type == STREAM_AUDIO)\n    {\n      m_nAudioStream = stream->uniqueId;\n      demuxerId = stream->demuxerId;\n      pStream = stream;\n      break;\n    }\n  }\n\n  if (m_nAudioStream == -1)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not find audio stream\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  CDVDStreamInfo hint(*pStream, true);\n\n  CAEStreamInfo::DataType ptStreamTye =\n      GetPassthroughStreamType(hint.codec, hint.samplerate, hint.profile);\n  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint, *m_processInfo, true, true, ptStreamTye);\n  if (!m_pAudioCodec)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not create audio codec\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  //  Extract ReplayGain info\n  // tagLoaderTagLib.Load will try to determine tag type by file extension, so set fallback by contentType\n  std::string strFallbackFileExtension = \"\";\n  if (m_strContentType == \"audio/aacp\" ||\n      m_strContentType == \"audio/aac\")\n    strFallbackFileExtension = \"m4a\";\n  else if (m_strContentType == \"audio/x-ms-wma\")\n    strFallbackFileExtension = \"wma\";\n  else if (m_strContentType == \"audio/x-ape\" ||\n           m_strContentType == \"audio/ape\")\n    strFallbackFileExtension = \"ape\";\n  CTagLoaderTagLib tagLoaderTagLib;\n  tagLoaderTagLib.Load(file.GetDynPath(), m_tag, strFallbackFileExtension);\n\n  // we have to decode initial data in order to get channels/samplerate\n  // for sanity - we read no more than 10 packets\n  int nErrors = 0;\n  for (int nPacket=0; nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0); nPacket++)\n  {\n    uint8_t dummy[256];\n    size_t nSize = 256;\n    if (ReadPCM(dummy, nSize, &nSize) == READ_ERROR)\n      ++nErrors;\n\n    m_srcFormat = m_pAudioCodec->GetFormat();\n    m_format = m_srcFormat;\n    m_channels = m_srcFormat.m_channelLayout.Count();\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_srcFormat.m_dataFormat);\n    m_bitsPerCodedSample = static_cast<CDemuxStreamAudio*>(pStream)->iBitsPerSample;\n  }\n  if (nErrors >= 10)\n  {\n    CLog::Log(LOGDEBUG, \"{}: Could not decode data\", __FUNCTION__);\n    return false;\n  }\n\n  // test if seeking is supported\n  m_bCanSeek = false;\n  if (m_pInputStream->Seek(0, SEEK_POSSIBLE))\n  {\n    if (Seek(1))\n    {\n      // rewind stream to beginning\n      Seek(0);\n      m_bCanSeek = true;\n    }\n    else\n    {\n      m_pInputStream->Seek(0, SEEK_SET);\n      if (!m_pDemuxer->Reset())\n        return false;\n    }\n  }\n\n  if (m_channels == 0) // no data - just guess and hope for the best\n  {\n    m_srcFormat.m_channelLayout = CAEChannelInfo(AE_CH_LAYOUT_2_0);\n    m_channels = m_srcFormat.m_channelLayout.Count();\n  }\n\n  if (m_srcFormat.m_sampleRate == 0)\n    m_srcFormat.m_sampleRate = 44100;\n\n  m_TotalTime = m_pDemuxer->GetStreamLength();\n  m_bitRate = m_pAudioCodec->GetBitRate();\n  if (!m_bitRate && m_TotalTime)\n  {\n    m_bitRate = (int)(((m_pInputStream->GetLength()*1000) / m_TotalTime) * 8);\n  }\n  m_CodecName = m_pDemuxer->GetStreamCodecName(demuxerId, m_nAudioStream);\n\n  m_needConvert = false;\n  if (NeedConvert(m_srcFormat.m_dataFormat))\n  {\n    m_needConvert = true;\n    m_pResampler = ActiveAE::CAEResampleFactory::Create();\n\n    SampleConfig dstConfig, srcConfig;\n    dstConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    dstConfig.channels = m_channels;\n    dstConfig.sample_rate = m_srcFormat.m_sampleRate;\n    dstConfig.fmt = CAEUtil::GetAVSampleFormat(AE_FMT_FLOAT);\n    dstConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(AE_FMT_FLOAT);\n    dstConfig.dither_bits = CAEUtil::DataFormatToDitherBits(AE_FMT_FLOAT);\n\n    srcConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    srcConfig.channels = m_channels;\n    srcConfig.sample_rate = m_srcFormat.m_sampleRate;\n    srcConfig.fmt = CAEUtil::GetAVSampleFormat(m_srcFormat.m_dataFormat);\n    srcConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(m_srcFormat.m_dataFormat);\n    srcConfig.dither_bits = CAEUtil::DataFormatToDitherBits(m_srcFormat.m_dataFormat);\n\n    m_pResampler->Init(dstConfig, srcConfig,\n                       false,\n                       false,\n                       M_SQRT1_2,\n                       NULL,\n                       AE_QUALITY_UNKNOWN,\n                       false);\n\n    m_planes = AE_IS_PLANAR(m_srcFormat.m_dataFormat) ? m_channels : 1;\n    m_format = m_srcFormat;\n    m_format.m_dataFormat = AE_FMT_FLOAT;\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);\n  }\n\n  m_strFileName = file.GetDynPath();\n  m_bInited = true;\n\n  return true;\n}",
  "abstract_func_before": "bool VideoPlayerCodec::Init(const CFileItem &VAR_0, unsigned int VAR_1)\n{\n  /* COMMENT_0 */\n  if (VAR_2)\n  {\n    /* COMMENT_1 */\n    if (VAR_3 == VAR_0.GetDynPath())\n      return true;\n\n    /* COMMENT_2 */\n    DeInit();\n  }\n\n  VAR_4 = 0;\n\n  CFileItem fileitem(file);\n  VAR_5.SetMimeType(VAR_6);\n  VAR_5.SetMimeTypeForInternetFile();\n  VAR_7 = CDVDFactoryInputStream::CreateInputStream(NULL, VAR_5);\n  if (!VAR_7)\n  {\n    CLog::Log(VAR_8, \"{}: Error creating input stream for {}\", VAR_9, file.GetDynPath());\n    return false;\n  }\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  if (!VAR_7->Open())\n  {\n    CLog::Log(VAR_8, \"{}: Error opening file {}\", VAR_9, file.GetDynPath());\n    if (VAR_7.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    VAR_7.reset();\n    return false;\n  }\n\n  VAR_10 = NULL;\n\n  try\n  {\n    VAR_10 = CDVDFactoryDemuxer::CreateDemuxer(VAR_7);\n    if (!VAR_10)\n    {\n      if (VAR_7.use_count() > 1)\n        throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n      VAR_7.reset();\n      CLog::Log(VAR_8, \"{}: Error creating demuxer\", VAR_9);\n      return false;\n    }\n  }\n  catch(...)\n  {\n    CLog::Log(VAR_8, \"{}: Exception thrown when opening demuxer\", VAR_9);\n    if (VAR_10)\n    {\n      delete VAR_10;\n      VAR_10 = NULL;\n    }\n    return false;\n  }\n\n  CDemuxStream* VAR_11 = NULL;\n  VAR_12 = -1;\n  int64_t VAR_13 = -1;\n  for (auto VAR_14 : VAR_10->GetStreams())\n  {\n    if (VAR_14 && VAR_14->type == VAR_15)\n    {\n      VAR_12 = VAR_14->uniqueId;\n      VAR_13 = VAR_14->demuxerId;\n      VAR_11 = VAR_14;\n      break;\n    }\n  }\n\n  if (VAR_12 == -1)\n  {\n    CLog::Log(VAR_8, \"{}: Could not find audio stream\", VAR_9);\n    delete VAR_10;\n    VAR_10 = NULL;\n    if (VAR_7.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    VAR_7.reset();\n    return false;\n  }\n\n  CDVDStreamInfo VAR_16(*VAR_11, true);\n\n  CAEStreamInfo::DataType VAR_17 =\n      GetPassthroughStreamType(VAR_16.codec, VAR_16.samplerate, VAR_16.profile);\n  VAR_18 = CDVDFactoryCodec::CreateAudioCodec(VAR_16, *VAR_19, true, true, VAR_17);\n  if (!VAR_18)\n  {\n    CLog::Log(VAR_8, \"{}: Could not create audio codec\", VAR_9);\n    delete VAR_10;\n    VAR_10 = NULL;\n    if (VAR_7.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    VAR_7.reset();\n    return false;\n  }\n\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  std::string VAR_20 = \"\";\n  if (VAR_6 == \"audio/aacp\" ||\n      VAR_6 == \"audio/aac\")\n    VAR_20 = \"m4a\";\n  else if (VAR_6 == \"audio/x-ms-wma\")\n    VAR_20 = \"wma\";\n  else if (VAR_6 == \"audio/x-ape\" ||\n           VAR_6 == \"audio/ape\")\n    VAR_20 = \"ape\";\n  CTagLoaderTagLib VAR_21;\n  VAR_21.Load(file.GetDynPath(), VAR_22, VAR_20);\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  int VAR_23 = 0;\n  for (int VAR_24=0; VAR_24 < 10 && (VAR_25 == 0 || VAR_26.m_sampleRate == 0); VAR_24++)\n  {\n    uint8_t VAR_27[256];\n    size_t VAR_28 = 256;\n    if (ReadPCM(VAR_27, VAR_28, &VAR_28) == VAR_29)\n      ++VAR_23;\n\n    VAR_30 = VAR_18->GetFormat();\n    VAR_26 = VAR_30;\n    VAR_25 = VAR_30.m_channelLayout.Count();\n    VAR_31 = CAEUtil::DataFormatToBits(VAR_30.m_dataFormat);\n    VAR_32 = VAR_33<CDemuxStreamAudio*>(VAR_11)->iBitsPerSample;\n  }\n  if (VAR_23 >= 10)\n  {\n    CLog::Log(VAR_34, \"{}: Could not decode data\", VAR_9);\n    return false;\n  }\n\n  /* COMMENT_9 */\n  VAR_35 = false;\n  if (VAR_7->Seek(0, VAR_36))\n  {\n    if (Seek(1))\n    {\n      /* COMMENT_10 */\n      Seek(0);\n      VAR_35 = true;\n    }\n    else\n    {\n      VAR_7->Seek(0, VAR_37);\n      if (!VAR_10->Reset())\n        return false;\n    }\n  }\n\n  if (VAR_25 == 0) /* COMMENT_11 */\n  {\n    VAR_30.m_channelLayout = CAEChannelInfo(VAR_38);\n    VAR_25 = VAR_30.m_channelLayout.Count();\n  }\n\n  if (VAR_30.m_sampleRate == 0)\n    VAR_30.m_sampleRate = 44100;\n\n  VAR_39 = VAR_10->GetStreamLength();\n  VAR_40 = VAR_18->GetBitRate();\n  if (!VAR_40 && VAR_39)\n  {\n    VAR_40 = (int)(((VAR_7->GetLength()*1000) / VAR_39) * 8);\n  }\n  VAR_41 = VAR_10->GetStreamCodecName(VAR_13, VAR_12);\n\n  VAR_42 = false;\n  if (NeedConvert(VAR_30.m_dataFormat))\n  {\n    VAR_42 = true;\n    VAR_43 = ActiveAE::CAEResampleFactory::Create();\n\n    SampleConfig VAR_44, VAR_45;\n    VAR_44.channel_layout = CAEUtil::GetAVChannelLayout(VAR_30.m_channelLayout);\n    VAR_44.channels = VAR_25;\n    VAR_44.sample_rate = VAR_30.m_sampleRate;\n    VAR_44.fmt = CAEUtil::GetAVSampleFormat(VAR_46);\n    VAR_44.bits_per_sample = CAEUtil::DataFormatToUsedBits(VAR_46);\n    VAR_44.dither_bits = CAEUtil::DataFormatToDitherBits(VAR_46);\n\n    VAR_45.channel_layout = CAEUtil::GetAVChannelLayout(VAR_30.m_channelLayout);\n    VAR_45.channels = VAR_25;\n    VAR_45.sample_rate = VAR_30.m_sampleRate;\n    VAR_45.fmt = CAEUtil::GetAVSampleFormat(VAR_30.m_dataFormat);\n    VAR_45.bits_per_sample = CAEUtil::DataFormatToUsedBits(VAR_30.m_dataFormat);\n    VAR_45.dither_bits = CAEUtil::DataFormatToDitherBits(VAR_30.m_dataFormat);\n\n    VAR_43->Init(VAR_44, VAR_45,\n                       false,\n                       false,\n                       VAR_47,\n                       NULL,\n                       VAR_48,\n                       false);\n\n    VAR_49 = AE_IS_PLANAR(VAR_30.m_dataFormat) ? VAR_25 : 1;\n    VAR_26 = VAR_30;\n    VAR_26.m_dataFormat = VAR_46;\n    VAR_31 = CAEUtil::DataFormatToBits(VAR_26.m_dataFormat);\n  }\n\n  VAR_3 = file.GetDynPath();\n  VAR_2 = true;\n\n  return true;\n}",
  "func_graph_path_before": null,
  "func": "bool VideoPlayerCodec::Init(const CFileItem &file, unsigned int filecache)\n{\n  // take precaution if Init()ialized earlier\n  if (m_bInited)\n  {\n    // keep things as is if Init() was done with known strFile\n    if (m_strFileName == file.GetDynPath())\n      return true;\n\n    // got differing filename, so cleanup before starting over\n    DeInit();\n  }\n\n  m_nDecodedLen = 0;\n\n  CFileItem fileitem(file);\n  fileitem.SetMimeType(m_strContentType);\n  fileitem.SetMimeTypeForInternetFile();\n  m_pInputStream = CDVDFactoryInputStream::CreateInputStream(NULL, fileitem);\n  if (!m_pInputStream)\n  {\n    CLog::Log(LOGERROR, \"{}: Error creating input stream for {}\", __FUNCTION__, file.GetDynPath());\n    return false;\n  }\n\n  //! @todo\n  //! convey CFileItem::ContentLookup() into Open()\n  if (!m_pInputStream->Open())\n  {\n    CLog::Log(LOGERROR, \"{}: Error opening file {}\", __FUNCTION__, file.GetDynPath());\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  m_pDemuxer = NULL;\n\n  try\n  {\n    m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream);\n    if (!m_pDemuxer)\n    {\n      if (m_pInputStream.use_count() > 1)\n        throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n      m_pInputStream.reset();\n      CLog::Log(LOGERROR, \"{}: Error creating demuxer\", __FUNCTION__);\n      return false;\n    }\n  }\n  catch(...)\n  {\n    CLog::Log(LOGERROR, \"{}: Exception thrown when opening demuxer\", __FUNCTION__);\n    if (m_pDemuxer)\n    {\n      delete m_pDemuxer;\n      m_pDemuxer = NULL;\n    }\n    return false;\n  }\n\n  CDemuxStream* pStream = NULL;\n  m_nAudioStream = -1;\n  int64_t demuxerId = -1;\n  for (auto stream : m_pDemuxer->GetStreams())\n  {\n    if (stream && stream->type == STREAM_AUDIO)\n    {\n      m_nAudioStream = stream->uniqueId;\n      demuxerId = stream->demuxerId;\n      pStream = stream;\n      break;\n    }\n  }\n\n  if (m_nAudioStream == -1)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not find audio stream\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  CDVDStreamInfo hint(*pStream, true);\n\n  CAEStreamInfo::DataType ptStreamTye =\n      GetPassthroughStreamType(hint.codec, hint.samplerate, hint.profile);\n  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint, *m_processInfo, true, true, ptStreamTye);\n  if (!m_pAudioCodec)\n  {\n    CLog::Log(LOGERROR, \"{}: Could not create audio codec\", __FUNCTION__);\n    delete m_pDemuxer;\n    m_pDemuxer = NULL;\n    if (m_pInputStream.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    m_pInputStream.reset();\n    return false;\n  }\n\n  //  Extract ReplayGain info\n  // tagLoaderTagLib.Load will try to determine tag type by file extension, so set fallback by contentType\n  std::string strFallbackFileExtension = \"\";\n  if (m_strContentType == \"audio/aacp\" ||\n      m_strContentType == \"audio/aac\")\n    strFallbackFileExtension = \"m4a\";\n  else if (m_strContentType == \"audio/x-ms-wma\")\n    strFallbackFileExtension = \"wma\";\n  else if (m_strContentType == \"audio/x-ape\" ||\n           m_strContentType == \"audio/ape\")\n    strFallbackFileExtension = \"ape\";\n  CTagLoaderTagLib tagLoaderTagLib;\n  tagLoaderTagLib.Load(file.GetDynPath(), m_tag, strFallbackFileExtension);\n\n  // we have to decode initial data in order to get channels/samplerate\n  // for sanity - we read no more than 10 packets\n  int nErrors = 0;\n  for (int nPacket = 0;\n       nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0 || m_format.m_frameSize == 0);\n       nPacket++)\n  {\n    uint8_t dummy[256];\n    size_t nSize = 256;\n    if (ReadPCM(dummy, nSize, &nSize) == READ_ERROR)\n      ++nErrors;\n\n    m_srcFormat = m_pAudioCodec->GetFormat();\n    m_format = m_srcFormat;\n    m_channels = m_srcFormat.m_channelLayout.Count();\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_srcFormat.m_dataFormat);\n    m_bitsPerCodedSample = static_cast<CDemuxStreamAudio*>(pStream)->iBitsPerSample;\n  }\n  if (nErrors >= 10)\n  {\n    CLog::Log(LOGDEBUG, \"{}: Could not decode data\", __FUNCTION__);\n    return false;\n  }\n\n  // test if seeking is supported\n  m_bCanSeek = false;\n  if (m_pInputStream->Seek(0, SEEK_POSSIBLE))\n  {\n    if (Seek(1))\n    {\n      // rewind stream to beginning\n      Seek(0);\n      m_bCanSeek = true;\n    }\n    else\n    {\n      m_pInputStream->Seek(0, SEEK_SET);\n      if (!m_pDemuxer->Reset())\n        return false;\n    }\n  }\n\n  if (m_channels == 0) // no data - just guess and hope for the best\n  {\n    m_srcFormat.m_channelLayout = CAEChannelInfo(AE_CH_LAYOUT_2_0);\n    m_channels = m_srcFormat.m_channelLayout.Count();\n  }\n\n  if (m_srcFormat.m_sampleRate == 0)\n    m_srcFormat.m_sampleRate = 44100;\n\n  m_TotalTime = m_pDemuxer->GetStreamLength();\n  m_bitRate = m_pAudioCodec->GetBitRate();\n  if (!m_bitRate && m_TotalTime)\n  {\n    m_bitRate = (int)(((m_pInputStream->GetLength()*1000) / m_TotalTime) * 8);\n  }\n  m_CodecName = m_pDemuxer->GetStreamCodecName(demuxerId, m_nAudioStream);\n\n  m_needConvert = false;\n  if (NeedConvert(m_srcFormat.m_dataFormat))\n  {\n    m_needConvert = true;\n    // if we don't know the framesize yet, we will fail when converting\n    if (m_srcFormat.m_frameSize == 0)\n      return false;\n\n    m_pResampler = ActiveAE::CAEResampleFactory::Create();\n\n    SampleConfig dstConfig, srcConfig;\n    dstConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    dstConfig.channels = m_channels;\n    dstConfig.sample_rate = m_srcFormat.m_sampleRate;\n    dstConfig.fmt = CAEUtil::GetAVSampleFormat(AE_FMT_FLOAT);\n    dstConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(AE_FMT_FLOAT);\n    dstConfig.dither_bits = CAEUtil::DataFormatToDitherBits(AE_FMT_FLOAT);\n\n    srcConfig.channel_layout = CAEUtil::GetAVChannelLayout(m_srcFormat.m_channelLayout);\n    srcConfig.channels = m_channels;\n    srcConfig.sample_rate = m_srcFormat.m_sampleRate;\n    srcConfig.fmt = CAEUtil::GetAVSampleFormat(m_srcFormat.m_dataFormat);\n    srcConfig.bits_per_sample = CAEUtil::DataFormatToUsedBits(m_srcFormat.m_dataFormat);\n    srcConfig.dither_bits = CAEUtil::DataFormatToDitherBits(m_srcFormat.m_dataFormat);\n\n    m_pResampler->Init(dstConfig, srcConfig,\n                       false,\n                       false,\n                       M_SQRT1_2,\n                       NULL,\n                       AE_QUALITY_UNKNOWN,\n                       false);\n\n    m_planes = AE_IS_PLANAR(m_srcFormat.m_dataFormat) ? m_channels : 1;\n    m_format = m_srcFormat;\n    m_format.m_dataFormat = AE_FMT_FLOAT;\n    m_bitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);\n  }\n\n  m_strFileName = file.GetDynPath();\n  m_bInited = true;\n\n  return true;\n}",
  "abstract_func": "bool VideoPlayerCodec::Init(const CFileItem &VAR_0, unsigned int VAR_1)\n{\n  /* COMMENT_0 */\n  if (VAR_2)\n  {\n    /* COMMENT_1 */\n    if (VAR_3 == VAR_0.GetDynPath())\n      return true;\n\n    /* COMMENT_2 */\n    DeInit();\n  }\n\n  VAR_4 = 0;\n\n  CFileItem fileitem(file);\n  VAR_5.SetMimeType(VAR_6);\n  VAR_5.SetMimeTypeForInternetFile();\n  VAR_7 = CDVDFactoryInputStream::CreateInputStream(NULL, VAR_5);\n  if (!VAR_7)\n  {\n    CLog::Log(VAR_8, \"{}: Error creating input stream for {}\", VAR_9, file.GetDynPath());\n    return false;\n  }\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  if (!VAR_7->Open())\n  {\n    CLog::Log(VAR_8, \"{}: Error opening file {}\", VAR_9, file.GetDynPath());\n    if (VAR_7.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    VAR_7.reset();\n    return false;\n  }\n\n  VAR_10 = NULL;\n\n  try\n  {\n    VAR_10 = CDVDFactoryDemuxer::CreateDemuxer(VAR_7);\n    if (!VAR_10)\n    {\n      if (VAR_7.use_count() > 1)\n        throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n      VAR_7.reset();\n      CLog::Log(VAR_8, \"{}: Error creating demuxer\", VAR_9);\n      return false;\n    }\n  }\n  catch(...)\n  {\n    CLog::Log(VAR_8, \"{}: Exception thrown when opening demuxer\", VAR_9);\n    if (VAR_10)\n    {\n      delete VAR_10;\n      VAR_10 = NULL;\n    }\n    return false;\n  }\n\n  CDemuxStream* VAR_11 = NULL;\n  VAR_12 = -1;\n  int64_t VAR_13 = -1;\n  for (auto VAR_14 : VAR_10->GetStreams())\n  {\n    if (VAR_14 && VAR_14->type == VAR_15)\n    {\n      VAR_12 = VAR_14->uniqueId;\n      VAR_13 = VAR_14->demuxerId;\n      VAR_11 = VAR_14;\n      break;\n    }\n  }\n\n  if (VAR_12 == -1)\n  {\n    CLog::Log(VAR_8, \"{}: Could not find audio stream\", VAR_9);\n    delete VAR_10;\n    VAR_10 = NULL;\n    if (VAR_7.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    VAR_7.reset();\n    return false;\n  }\n\n  CDVDStreamInfo VAR_16(*VAR_11, true);\n\n  CAEStreamInfo::DataType VAR_17 =\n      GetPassthroughStreamType(VAR_16.codec, VAR_16.samplerate, VAR_16.profile);\n  VAR_18 = CDVDFactoryCodec::CreateAudioCodec(VAR_16, *VAR_19, true, true, VAR_17);\n  if (!VAR_18)\n  {\n    CLog::Log(VAR_8, \"{}: Could not create audio codec\", VAR_9);\n    delete VAR_10;\n    VAR_10 = NULL;\n    if (VAR_7.use_count() > 1)\n      throw std::runtime_error(\"m_pInputStream reference count is greater than 1\");\n    VAR_7.reset();\n    return false;\n  }\n\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  std::string VAR_20 = \"\";\n  if (VAR_6 == \"audio/aacp\" ||\n      VAR_6 == \"audio/aac\")\n    VAR_20 = \"m4a\";\n  else if (VAR_6 == \"audio/x-ms-wma\")\n    VAR_20 = \"wma\";\n  else if (VAR_6 == \"audio/x-ape\" ||\n           VAR_6 == \"audio/ape\")\n    VAR_20 = \"ape\";\n  CTagLoaderTagLib VAR_21;\n  VAR_21.Load(file.GetDynPath(), VAR_22, VAR_20);\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  int VAR_23 = 0;\n  for (int VAR_24 = 0;\n       VAR_24 < 10 && (VAR_25 == 0 || VAR_26.m_sampleRate == 0 || VAR_26.m_frameSize == 0);\n       VAR_24++)\n  {\n    uint8_t VAR_27[256];\n    size_t VAR_28 = 256;\n    if (ReadPCM(VAR_27, VAR_28, &VAR_28) == VAR_29)\n      ++VAR_23;\n\n    VAR_30 = VAR_18->GetFormat();\n    VAR_26 = VAR_30;\n    VAR_25 = VAR_30.m_channelLayout.Count();\n    VAR_31 = CAEUtil::DataFormatToBits(VAR_30.m_dataFormat);\n    VAR_32 = VAR_33<CDemuxStreamAudio*>(VAR_11)->iBitsPerSample;\n  }\n  if (VAR_23 >= 10)\n  {\n    CLog::Log(VAR_34, \"{}: Could not decode data\", VAR_9);\n    return false;\n  }\n\n  /* COMMENT_9 */\n  VAR_35 = false;\n  if (VAR_7->Seek(0, VAR_36))\n  {\n    if (Seek(1))\n    {\n      /* COMMENT_10 */\n      Seek(0);\n      VAR_35 = true;\n    }\n    else\n    {\n      VAR_7->Seek(0, VAR_37);\n      if (!VAR_10->Reset())\n        return false;\n    }\n  }\n\n  if (VAR_25 == 0) /* COMMENT_11 */\n  {\n    VAR_30.m_channelLayout = CAEChannelInfo(VAR_38);\n    VAR_25 = VAR_30.m_channelLayout.Count();\n  }\n\n  if (VAR_30.m_sampleRate == 0)\n    VAR_30.m_sampleRate = 44100;\n\n  VAR_39 = VAR_10->GetStreamLength();\n  VAR_40 = VAR_18->GetBitRate();\n  if (!VAR_40 && VAR_39)\n  {\n    VAR_40 = (int)(((VAR_7->GetLength()*1000) / VAR_39) * 8);\n  }\n  VAR_41 = VAR_10->GetStreamCodecName(VAR_13, VAR_12);\n\n  VAR_42 = false;\n  if (NeedConvert(VAR_30.m_dataFormat))\n  {\n    VAR_42 = true;\n    /* COMMENT_12 */\n    if (VAR_30.m_frameSize == 0)\n      return false;\n\n    VAR_43 = ActiveAE::CAEResampleFactory::Create();\n\n    SampleConfig VAR_44, VAR_45;\n    VAR_44.channel_layout = CAEUtil::GetAVChannelLayout(VAR_30.m_channelLayout);\n    VAR_44.channels = VAR_25;\n    VAR_44.sample_rate = VAR_30.m_sampleRate;\n    VAR_44.fmt = CAEUtil::GetAVSampleFormat(VAR_46);\n    VAR_44.bits_per_sample = CAEUtil::DataFormatToUsedBits(VAR_46);\n    VAR_44.dither_bits = CAEUtil::DataFormatToDitherBits(VAR_46);\n\n    VAR_45.channel_layout = CAEUtil::GetAVChannelLayout(VAR_30.m_channelLayout);\n    VAR_45.channels = VAR_25;\n    VAR_45.sample_rate = VAR_30.m_sampleRate;\n    VAR_45.fmt = CAEUtil::GetAVSampleFormat(VAR_30.m_dataFormat);\n    VAR_45.bits_per_sample = CAEUtil::DataFormatToUsedBits(VAR_30.m_dataFormat);\n    VAR_45.dither_bits = CAEUtil::DataFormatToDitherBits(VAR_30.m_dataFormat);\n\n    VAR_43->Init(VAR_44, VAR_45,\n                       false,\n                       false,\n                       VAR_47,\n                       NULL,\n                       VAR_48,\n                       false);\n\n    VAR_49 = AE_IS_PLANAR(VAR_30.m_dataFormat) ? VAR_25 : 1;\n    VAR_26 = VAR_30;\n    VAR_26.m_dataFormat = VAR_46;\n    VAR_31 = CAEUtil::DataFormatToBits(VAR_26.m_dataFormat);\n  }\n\n  VAR_3 = file.GetDynPath();\n  VAR_2 = true;\n\n  return true;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -117,7 +117,9 @@\n   // we have to decode initial data in order to get channels/samplerate\n   // for sanity - we read no more than 10 packets\n   int nErrors = 0;\n-  for (int nPacket=0; nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0); nPacket++)\n+  for (int nPacket = 0;\n+       nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0 || m_format.m_frameSize == 0);\n+       nPacket++)\n   {\n     uint8_t dummy[256];\n     size_t nSize = 256;\n@@ -175,6 +177,10 @@\n   if (NeedConvert(m_srcFormat.m_dataFormat))\n   {\n     m_needConvert = true;\n+    // if we don't know the framesize yet, we will fail when converting\n+    if (m_srcFormat.m_frameSize == 0)\n+      return false;\n+\n     m_pResampler = ActiveAE::CAEResampleFactory::Create();\n \n     SampleConfig dstConfig, srcConfig;",
  "diff_line_info": {
    "deleted_lines": [
      "  for (int nPacket=0; nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0); nPacket++)"
    ],
    "added_lines": [
      "  for (int nPacket = 0;",
      "       nPacket < 10 && (m_channels == 0 || m_format.m_sampleRate == 0 || m_format.m_frameSize == 0);",
      "       nPacket++)",
      "    // if we don't know the framesize yet, we will fail when converting",
      "    if (m_srcFormat.m_frameSize == 0)",
      "      return false;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xbmc/xbmc/pull/22391",
  "description": {
    "pr_info": {
      "title": "VideoPlayerCodec: Stop dividing by zero",
      "number": 22391
    },
    "comment": [
      "When parsing a file failed so that needed fields, in our case frameSize are not available a guess work like with m_channels or m_samplerate does not help. Therefore fail early.\r\n\r\nFixes: #22378"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.6\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message indicates a potential division by zero issue. The code change adds checks for frameSize to prevent such errors.\n\n2. **Consistency Check:** The code modifications align with the commit message, adding necessary checks for frameSize.\n\n3. **Purpose Evaluation:** The changes address a crash condition by ensuring frameSize is available, but not explicitly for security.\n\n4. **Security Vulnerability Assessment:** While division by zero can crash the program, without an external exploit vector, it's not classified as a security fix.\n\n5. **Non-Security Classification:** This is a defect fix in core logic, thus classified under Defect Remediation.\n\n6. **Confidence Scoring:** Medium confidence due to ambiguity in whether the issue is security-related without explicit mentions."
}