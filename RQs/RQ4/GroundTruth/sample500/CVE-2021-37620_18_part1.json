{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/xmp.cpp",
  "func_name": "nsDumper",
  "func_before": "static XMP_Status nsDumper\n    ( void*           refCon\n    , XMP_StringPtr   buffer\n    , XMP_StringLen   bufferSize\n    ) {\n        XMP_Status result = 0 ;\n        std::string out(buffer,bufferSize);\n\n        // remove blanks\n        // http://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c\n        std::string::iterator end_pos = std::remove(out.begin(), out.end(), ' ');\n        out.erase(end_pos, out.end());\n\n        bool bURI = out.find(\"http://\") != std::string::npos   ;\n        bool bNS  = out.find(':') != std::string::npos && !bURI;\n\n        // pop trailing ':' on a namespace\n        if ( bNS ) {\n        std::size_t length = out.length();\n            if ( out[length-1] == ':' ) out = out.substr(0,length-1);\n        }\n\n        if ( bURI || bNS ) {\n            std::map<std::string,std::string>* p = (std::map<std::string,std::string>*) refCon;\n            std::map<std::string,std::string>& m = *p;\n\n            std::string b(\"\");\n            if ( bNS ) {  // store the NS in dict[\"\"]\n                m[b]=out;\n            } else if ( m.find(b) != m.end() ) {  // store dict[uri] = dict[\"\"]\n                m[m[b]]=out;\n                m.erase(b);\n            }\n        }\n        return result;\n    }",
  "abstract_func_before": "static XMP_Status nsDumper\n    ( void*           VAR_0\n    , XMP_StringPtr   VAR_1\n    , XMP_StringLen   VAR_2\n    ) {\n        XMP_Status VAR_3 = 0 ;\n        std::string out(buffer,bufferSize);\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        std::string::iterator VAR_4 = std::remove(VAR_5.begin(), VAR_5.end(), ' ');\n        VAR_5.erase(VAR_4, VAR_5.end());\n\n        bool VAR_6 = VAR_5.find(\"http://\") != std::string::npos   ;\n        bool VAR_7  = VAR_5.find(':') != std::string::npos && !VAR_6;\n\n        /* COMMENT_2 */\n        if ( VAR_7 ) {\n        std::size_t VAR_8 = VAR_5.length();\n            if ( VAR_5[VAR_8-1] == ':' ) VAR_5 = VAR_5.substr(0,VAR_8-1);\n        }\n\n        if ( VAR_6 || VAR_7 ) {\n            std::map<std::string,std::string>* VAR_9 = (std::map<std::string,std::string>*) VAR_0;\n            std::map<std::string,std::string>& VAR_10 = *VAR_9;\n\n            std::string VAR_11(\"\");\n            if ( VAR_7 ) {  /* COMMENT_3 */\n                VAR_10[VAR_11]=VAR_5;\n            } else if ( VAR_10.find(VAR_11) != VAR_10.end() ) {  /* COMMENT_4 */\n                VAR_10[VAR_10[VAR_11]]=VAR_5;\n                VAR_10.erase(VAR_11);\n            }\n        }\n        return VAR_3;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/xmp.cpp/vul/before/0.json",
  "func": "static XMP_Status nsDumper\n    ( void*           refCon\n    , XMP_StringPtr   buffer\n    , XMP_StringLen   bufferSize\n    ) {\n        XMP_Status result = 0 ;\n        std::string out(buffer,bufferSize);\n\n        // remove blanks\n        // http://stackoverflow.com/questions/83439/remove-spaces-from-stdstring-in-c\n        std::string::iterator end_pos = std::remove(out.begin(), out.end(), ' ');\n        out.erase(end_pos, out.end());\n\n        bool bURI = out.find(\"http://\") != std::string::npos   ;\n        bool bNS  = out.find(':') != std::string::npos && !bURI;\n\n        // pop trailing ':' on a namespace\n        if ( bNS && !out.empty() ) {\n            std::size_t length = out.length();\n            if ( out[length-1] == ':' ) out = out.substr(0,length-1);\n        }\n\n        if ( bURI || bNS ) {\n            std::map<std::string,std::string>* p = (std::map<std::string,std::string>*) refCon;\n            std::map<std::string,std::string>& m = *p;\n\n            std::string b(\"\");\n            if ( bNS ) {  // store the NS in dict[\"\"]\n                m[b]=out;\n            } else if ( m.find(b) != m.end() ) {  // store dict[uri] = dict[\"\"]\n                m[m[b]]=out;\n                m.erase(b);\n            }\n        }\n        return result;\n    }",
  "abstract_func": "static XMP_Status nsDumper\n    ( void*           VAR_0\n    , XMP_StringPtr   VAR_1\n    , XMP_StringLen   VAR_2\n    ) {\n        XMP_Status VAR_3 = 0 ;\n        std::string out(buffer,bufferSize);\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        std::string::iterator VAR_4 = std::remove(VAR_5.begin(), VAR_5.end(), ' ');\n        VAR_5.erase(VAR_4, VAR_5.end());\n\n        bool VAR_6 = VAR_5.find(\"http://\") != std::string::npos   ;\n        bool VAR_7  = VAR_5.find(':') != std::string::npos && !VAR_6;\n\n        /* COMMENT_2 */\n        if ( VAR_7 && !VAR_5.empty() ) {\n            std::size_t VAR_8 = VAR_5.length();\n            if ( VAR_5[VAR_8-1] == ':' ) VAR_5 = VAR_5.substr(0,VAR_8-1);\n        }\n\n        if ( VAR_6 || VAR_7 ) {\n            std::map<std::string,std::string>* VAR_9 = (std::map<std::string,std::string>*) VAR_0;\n            std::map<std::string,std::string>& VAR_10 = *VAR_9;\n\n            std::string VAR_11(\"\");\n            if ( VAR_7 ) {  /* COMMENT_3 */\n                VAR_10[VAR_11]=VAR_5;\n            } else if ( VAR_10.find(VAR_11) != VAR_10.end() ) {  /* COMMENT_4 */\n                VAR_10[VAR_10[VAR_11]]=VAR_5;\n                VAR_10.erase(VAR_11);\n            }\n        }\n        return VAR_3;\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/xmp.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,8 @@\n         bool bNS  = out.find(':') != std::string::npos && !bURI;\n \n         // pop trailing ':' on a namespace\n-        if ( bNS ) {\n-        std::size_t length = out.length();\n+        if ( bNS && !out.empty() ) {\n+            std::size_t length = out.length();\n             if ( out[length-1] == ':' ) out = out.substr(0,length-1);\n         }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        if ( bNS ) {",
      "        std::size_t length = out.length();"
    ],
    "added_lines": [
      "        if ( bNS && !out.empty() ) {",
      "            std::size_t length = out.length();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "The commit message indicates a security fix related to buffer indexing. The code change adds a null check to prevent accessing an empty string, which prevents a buffer underflow. Despite the mismatched vulnerability description, the code change addresses a security issue, so it's classified as a security fix.\n\n**Final Classification:** Security Vulnerability Fix\n**Confidence:** 0.7"
}