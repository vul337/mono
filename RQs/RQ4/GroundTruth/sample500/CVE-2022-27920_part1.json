{
  "cve_id": "CVE-2022-27920",
  "cwe_ids": [
    "CWE-79"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "kiwix/libkiwix",
  "commit_msg": "use encoded URLs for searchSuggestionHtml\n\nPreviously, the seachURL was not encoded.\nThis resulted in an XSS vulnerability, a concept of proof is:\n\nstart kiwix-serve\nvisit - http://192.168.18.1:8081/\"><svg onload=\"alert(1)\">\nThis would display an alert message.\n\nThis encodes the searchURL before passing it to searchSuggestionHtml",
  "commit_hash": "8136138492ab51ae8a311be589b8b131d04125ce",
  "git_url": "https://github.com/kiwix/libkiwix/commit/8136138492ab51ae8a311be589b8b131d04125ce",
  "file_path": "src/server/internalServer.cpp",
  "func_name": "InternalServer::handle_content",
  "func_before": "std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request)\n{\n  const std::string url = request.get_url();\n  const std::string pattern = url.substr((url.find_last_of('/'))+1);\n  if (m_verbose.load()) {\n    printf(\"** running handle_content\\n\");\n  }\n\n  const std::string bookName = get_book_name(request);\n  if (bookName.empty())\n    return build_homepage(request);\n\n  std::shared_ptr<zim::Archive> archive;\n  try {\n    const std::string bookId = mp_nameMapper->getIdForName(bookName);\n    archive = mp_library->getArchiveById(bookId);\n  } catch (const std::out_of_range& e) {}\n\n  if (archive == nullptr) {\n    std::string searchURL = m_root+\"/search?pattern=\"+pattern; // Make a full search on the entire library.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, \"\", details);\n  }\n\n  auto urlStr = request.get_url().substr(bookName.size()+1);\n  if (urlStr[0] == '/') {\n    urlStr = urlStr.substr(1);\n  }\n\n  try {\n    auto entry = getEntryFromPath(*archive, urlStr);\n    if (entry.isRedirect() || urlStr.empty()) {\n      // If urlStr is empty, we want to mainPage.\n      // We must do a redirection to the real page.\n      return build_redirect(bookName, getFinalItem(*archive, entry));\n    }\n    auto response = ItemResponse::build(*this, request, entry.getItem());\n    try {\n      dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive));\n    } catch (std::bad_cast& e) {}\n\n    if (m_verbose.load()) {\n      printf(\"Found %s\\n\", entry.getPath().c_str());\n      printf(\"mimeType: %s\\n\", entry.getItem(true).getMimetype().c_str());\n    }\n\n    return response;\n  } catch(zim::EntryNotFound& e) {\n    if (m_verbose.load())\n      printf(\"Failed to find %s\\n\", urlStr.c_str());\n\n    std::string searchURL = m_root+\"/search?content=\"+bookName+\"&pattern=\"+pattern; // Make a search on this specific book only.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);\n  }\n}",
  "abstract_func_before": "std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& VAR_0)\n{\n  const std::string VAR_1 = VAR_0.get_url();\n  const std::string VAR_2 = VAR_1.substr((VAR_1.find_last_of('/'))+1);\n  if (VAR_3.load()) {\n    printf(\"** running handle_content\\n\");\n  }\n\n  const std::string VAR_4 = get_book_name(VAR_0);\n  if (VAR_4.empty())\n    return build_homepage(VAR_0);\n\n  std::shared_ptr<zim::Archive> VAR_5;\n  try {\n    const std::string VAR_6 = VAR_7->getIdForName(VAR_4);\n    VAR_5 = VAR_8->getArchiveById(VAR_6);\n  } catch (const std::out_of_range& VAR_9) {}\n\n  if (VAR_5 == nullptr) {\n    std::string VAR_10 = VAR_11+\"/search?pattern=\"+VAR_2; /* COMMENT_0 */\n    const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));\n\n    return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, \"\", VAR_12);\n  }\n\n  auto VAR_13 = VAR_0.get_url().substr(VAR_4.size()+1);\n  if (VAR_13[0] == '/') {\n    VAR_13 = VAR_13.substr(1);\n  }\n\n  try {\n    auto VAR_14 = getEntryFromPath(*VAR_5, VAR_13);\n    if (VAR_14.isRedirect() || VAR_13.empty()) {\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      return build_redirect(VAR_4, getFinalItem(*VAR_5, VAR_14));\n    }\n    auto VAR_15 = ItemResponse::build(*this, VAR_0, VAR_14.getItem());\n    try {\n      VAR_16<ContentResponse&>(*VAR_15).set_taskbar(VAR_4, getArchiveTitle(*VAR_5));\n    } catch (std::bad_cast& VAR_9) {}\n\n    if (VAR_3.load()) {\n      printf(\"Found %s\\n\", VAR_14.getPath().c_str());\n      printf(\"mimeType: %s\\n\", VAR_14.getItem(true).getMimetype().c_str());\n    }\n\n    return VAR_15;\n  } catch(zim::EntryNotFound& VAR_9) {\n    if (VAR_3.load())\n      printf(\"Failed to find %s\\n\", VAR_13.c_str());\n\n    std::string VAR_10 = VAR_11+\"/search?content=\"+VAR_4+\"&pattern=\"+VAR_2; /* COMMENT_3 */\n    const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));\n\n    return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, getArchiveTitle(*VAR_5), VAR_12);\n  }\n}",
  "func_graph_path_before": "kiwix/libkiwix/8136138492ab51ae8a311be589b8b131d04125ce/internalServer.cpp/vul/before/0.json",
  "func": "std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request)\n{\n  const std::string url = request.get_url();\n  const std::string pattern = url.substr((url.find_last_of('/'))+1);\n  if (m_verbose.load()) {\n    printf(\"** running handle_content\\n\");\n  }\n\n  const std::string bookName = get_book_name(request);\n  if (bookName.empty())\n    return build_homepage(request);\n\n  std::shared_ptr<zim::Archive> archive;\n  try {\n    const std::string bookId = mp_nameMapper->getIdForName(bookName);\n    archive = mp_library->getArchiveById(bookId);\n  } catch (const std::out_of_range& e) {}\n\n  if (archive == nullptr) {\n    std::string searchURL = m_root + \"/search?pattern=\" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, \"\", details);\n  }\n\n  auto urlStr = request.get_url().substr(bookName.size()+1);\n  if (urlStr[0] == '/') {\n    urlStr = urlStr.substr(1);\n  }\n\n  try {\n    auto entry = getEntryFromPath(*archive, urlStr);\n    if (entry.isRedirect() || urlStr.empty()) {\n      // If urlStr is empty, we want to mainPage.\n      // We must do a redirection to the real page.\n      return build_redirect(bookName, getFinalItem(*archive, entry));\n    }\n    auto response = ItemResponse::build(*this, request, entry.getItem());\n    try {\n      dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive));\n    } catch (std::bad_cast& e) {}\n\n    if (m_verbose.load()) {\n      printf(\"Found %s\\n\", entry.getPath().c_str());\n      printf(\"mimeType: %s\\n\", entry.getItem(true).getMimetype().c_str());\n    }\n\n    return response;\n  } catch(zim::EntryNotFound& e) {\n    if (m_verbose.load())\n      printf(\"Failed to find %s\\n\", urlStr.c_str());\n\n    std::string searchURL = m_root + \"/search?content=\" + bookName + \"&pattern=\" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);\n  }\n}",
  "abstract_func": "std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& VAR_0)\n{\n  const std::string VAR_1 = VAR_0.get_url();\n  const std::string VAR_2 = VAR_1.substr((VAR_1.find_last_of('/'))+1);\n  if (VAR_3.load()) {\n    printf(\"** running handle_content\\n\");\n  }\n\n  const std::string VAR_4 = get_book_name(VAR_0);\n  if (VAR_4.empty())\n    return build_homepage(VAR_0);\n\n  std::shared_ptr<zim::Archive> VAR_5;\n  try {\n    const std::string VAR_6 = VAR_7->getIdForName(VAR_4);\n    VAR_5 = VAR_8->getArchiveById(VAR_6);\n  } catch (const std::out_of_range& VAR_9) {}\n\n  if (VAR_5 == nullptr) {\n    std::string VAR_10 = VAR_11 + \"/search?pattern=\" + kiwix::urlEncode(VAR_2, true); /* COMMENT_0 */\n    const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));\n\n    return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, \"\", VAR_12);\n  }\n\n  auto VAR_13 = VAR_0.get_url().substr(VAR_4.size()+1);\n  if (VAR_13[0] == '/') {\n    VAR_13 = VAR_13.substr(1);\n  }\n\n  try {\n    auto VAR_14 = getEntryFromPath(*VAR_5, VAR_13);\n    if (VAR_14.isRedirect() || VAR_13.empty()) {\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      return build_redirect(VAR_4, getFinalItem(*VAR_5, VAR_14));\n    }\n    auto VAR_15 = ItemResponse::build(*this, VAR_0, VAR_14.getItem());\n    try {\n      VAR_16<ContentResponse&>(*VAR_15).set_taskbar(VAR_4, getArchiveTitle(*VAR_5));\n    } catch (std::bad_cast& VAR_9) {}\n\n    if (VAR_3.load()) {\n      printf(\"Found %s\\n\", VAR_14.getPath().c_str());\n      printf(\"mimeType: %s\\n\", VAR_14.getItem(true).getMimetype().c_str());\n    }\n\n    return VAR_15;\n  } catch(zim::EntryNotFound& VAR_9) {\n    if (VAR_3.load())\n      printf(\"Failed to find %s\\n\", VAR_13.c_str());\n\n    std::string VAR_10 = VAR_11 + \"/search?content=\" + VAR_4 + \"&pattern=\" + kiwix::urlEncode(VAR_2, true); /* COMMENT_3 */\n    const std::string VAR_12 = searchSuggestionHTML(VAR_10, kiwix::urlDecode(VAR_2));\n\n    return Response::build_404(*this, VAR_0.get_full_url(), VAR_4, getArchiveTitle(*VAR_5), VAR_12);\n  }\n}",
  "func_graph_path": "kiwix/libkiwix/8136138492ab51ae8a311be589b8b131d04125ce/internalServer.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n   } catch (const std::out_of_range& e) {}\n \n   if (archive == nullptr) {\n-    std::string searchURL = m_root+\"/search?pattern=\"+pattern; // Make a full search on the entire library.\n+    std::string searchURL = m_root + \"/search?pattern=\" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.\n     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n \n     return Response::build_404(*this, request.get_full_url(), bookName, \"\", details);\n@@ -50,7 +50,7 @@\n     if (m_verbose.load())\n       printf(\"Failed to find %s\\n\", urlStr.c_str());\n \n-    std::string searchURL = m_root+\"/search?content=\"+bookName+\"&pattern=\"+pattern; // Make a search on this specific book only.\n+    std::string searchURL = m_root + \"/search?content=\" + bookName + \"&pattern=\" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.\n     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n \n     return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);",
  "diff_line_info": {
    "deleted_lines": [
      "    std::string searchURL = m_root+\"/search?pattern=\"+pattern; // Make a full search on the entire library.",
      "    std::string searchURL = m_root+\"/search?content=\"+bookName+\"&pattern=\"+pattern; // Make a search on this specific book only."
    ],
    "added_lines": [
      "    std::string searchURL = m_root + \"/search?pattern=\" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.",
      "    std::string searchURL = m_root + \"/search?content=\" + bookName + \"&pattern=\" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only."
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/kiwix/libkiwix/pull/721",
  "description": {
    "pr_info": {
      "title": "Use encoded URLs for searchSuggestionHtml ",
      "number": 721
    },
    "comment": [
      "Previously, the seachURL was not encoded.\r\nThis resulted in an XSS vulnerability, a concept of proof is:\r\n\r\nstart kiwix-serve\r\nvisit - `http://192.168.18.1:8081/\"><svg onload=alert(1)>`\r\nThis would display an alert message.\r\n\r\nThis encodes the searchURL before passing it to searchSuggestionHtml",
      "# [Codecov](https://codecov.io/gh/kiwix/libkiwix/pull/721?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix) Report\n> Merging [#721](https://codecov.io/gh/kiwix/libkiwix/pull/721?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix) (04d6824) into [master](https://codecov.io/gh/kiwix/libkiwix/commit/e48b550b68c86bdfa678f1d833feda81c85a13bb?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix) (e48b550) will **not change** coverage.\n> The diff coverage is `100.00%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/kiwix/libkiwix/pull/721/graphs/tree.svg?width=650&height=150&src=pr&token=U6kdddwOoR&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix)](https://codecov.io/gh/kiwix/libkiwix/pull/721?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix)\n\n```diff\n@@           Coverage Diff           @@\n##           master     #721   +/-   ##\n=======================================\n  Coverage   57.81%   57.81%           \n=======================================\n  Files          56       56           \n  Lines        3651     3651           \n  Branches     2047     2047           \n=======================================\n  Hits         2111     2111           \n  Misses       1539     1539           \n  Partials        1        1           \n```\n\n\n| [Impacted Files](https://codecov.io/gh/kiwix/libkiwix/pull/721?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix) | Coverage Δ | |\n|---|---|---|\n| [src/server/internalServer.cpp](https://codecov.io/gh/kiwix/libkiwix/pull/721/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix#diff-c3JjL3NlcnZlci9pbnRlcm5hbFNlcnZlci5jcHA=) | `81.25% <100.00%> (ø)` | |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/kiwix/libkiwix/pull/721?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/kiwix/libkiwix/pull/721?src=pr&el=footer&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix). Last update [e48b550...04d6824](https://codecov.io/gh/kiwix/libkiwix/pull/721?src=pr&el=lastupdated&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=kiwix).\n",
      "@juuz0 @kelson42 do we know what version the XSS vulnerability was introduced in?",
      "@legoktm I don't know, but I would guess for an old weakness",
      "https://github.com/kiwix/libkiwix/pull/465\r\nProbably this\r\nthe method added into this explicitly defines no escaping `{{{searchURL}}}`",
      "Thanks, so https://github.com/kiwix/libkiwix/commit/a59787002510a52171684487a10562d8d096c421 was only included in 10.0.0 (no released Debian versions are affected, just unstable).\r\n\r\nCould we do a 10.0.2 release with just this cherry-picked? I note that even library.kiwix.org is vulnerable to this. Or if 10.1.0 is coming pretty soon then waiting wouldn't be too bad.\r\n\r\nAnd we should also get a CVE ID assigned for this vulnerability, @kelson42 if you haven't gone through this [process](https://cveform.mitre.org/) before I'm happy to help out.",
      "@legoktm Thx for your last comment. For the moment I don’t have a strong opinion on this but understand the rationals. It seems as well your have a clearer opinion on the next release than I do. But, considering this PR to be closed, could you please open a new ticket with this arguments and why you woukd like to request early release of 10.1.0?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}